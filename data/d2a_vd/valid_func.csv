code	label
▁static ▁int ▁decode _ n al _ units ▁( ▁H 264 Context ▁* ▁h ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁AVCodecContext ▁* ▁const ▁avctx ▁= ▁h ▁-> ▁avctx ▁; ▁unsigned ▁context _ count ▁= ▁0 ▁; ▁int ▁n als _ needed ▁= ▁0 ▁; ▁int ▁i ▁, ▁ret ▁= ▁0 ▁; ▁h ▁-> ▁max _ contexts ▁= ▁h ▁-> ▁slice _ context _ count ▁; ▁if ▁( ▁! ▁( ▁avctx ▁-> ▁flags 2 ▁& ▁AV _ CODEC _ FLAG 2_ CHUNK S ▁) ▁) ▁{ ▁h ▁-> ▁current _ slice ▁= ▁0 ▁; ▁if ▁( ▁! ▁h ▁-> ▁first _ field ▁) ▁h ▁-> ▁cur _ pic _ ptr ▁= ▁NULL ▁; ▁ff _ h 264_ se i _ uninit ▁( ▁& ▁h ▁-> ▁se i ▁) ▁; ▁} ▁ret ▁= ▁ff _ h 264 5_ packet _ split ▁( ▁& ▁h ▁-> ▁pkt ▁, ▁buf ▁, ▁buf _ size ▁, ▁avctx ▁, ▁h ▁-> ▁is _ avc ▁, ▁h ▁-> ▁nal _ length _ size ▁, ▁avctx ▁-> ▁codec _ id ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Errors plit ting the input into NAL units .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ FRAME ▁) ▁n als _ needed ▁= ▁get _ last _ needed _ n al ▁( ▁h ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁-> ▁pkt ▁. ▁nb _ n als ▁; ▁i ▁++ ▁) ▁{ ▁H 264 5 NAL ▁* ▁nal ▁= ▁& ▁h ▁-> ▁pkt ▁. ▁n als ▁[ ▁i ▁] ▁; ▁H 264 Slice Context ▁* ▁sl ▁= ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁context _ count ▁] ▁; ▁int ▁err ▁; ▁if ▁( ▁avctx ▁-> ▁skip _ frame ▁>= ▁AV DISCARD _ NON REF ▁&& ▁nal ▁-> ▁ref _ id c ▁== ▁0 ▁&& ▁nal ▁-> ▁type ▁!= ▁N AL _ SE I ▁) ▁continue ▁; ▁again ▁: ▁h ▁-> ▁nal _ ref _ id c ▁= ▁nal ▁-> ▁ref _ id c ▁; ▁h ▁-> ▁nal _ unit _ type ▁= ▁nal ▁-> ▁type ▁; ▁err ▁= ▁0 ▁; ▁switch ▁( ▁nal ▁-> ▁type ▁) ▁{ ▁case ▁N AL _ IDR _ SL ICE ▁: ▁if ▁( ▁nal ▁-> ▁type ▁!= ▁N AL _ IDR _ SL ICE ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid mix of id rand non - id rs lices \ n " ▁) ▁; ▁ret ▁= ▁-1 ▁; ▁goto ▁end ▁; ▁} ▁idr ▁( ▁h ▁) ▁; ▁case ▁N AL _ SL ICE ▁: ▁sl ▁-> ▁gb ▁= ▁nal ▁-> ▁gb ▁; ▁if ▁( ▁( ▁err ▁= ▁ff _ h 264_ decode _ slice _ header ▁( ▁h ▁, ▁sl ▁) ▁) ▁) ▁break ▁; ▁if ▁( ▁h ▁-> ▁se i ▁. ▁recovery _ point ▁. ▁recovery _ frame _ cnt ▁>= ▁0 ▁&& ▁h ▁-> ▁recovery _ frame ▁< ▁0 ▁) ▁{ ▁h ▁-> ▁recovery _ frame ▁= ▁( ▁h ▁-> ▁p oc ▁. ▁frame _ num ▁+ ▁h ▁-> ▁se i ▁. ▁recovery _ point ▁. ▁recovery _ frame _ cnt ▁) ▁& ▁( ▁( ▁1 ▁<< ▁h ▁-> ▁ps ▁. ▁sps ▁-> ▁log 2_ max _ frame _ num ▁) ▁- ▁1 ▁) ▁; ▁} ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁f ▁-> ▁key _ frame ▁|= ▁( ▁nal ▁-> ▁type ▁== ▁N AL _ IDR _ SL ICE ▁) ▁|| ▁( ▁h ▁-> ▁se i ▁. ▁recovery _ point ▁. ▁recovery _ frame _ cnt ▁>= ▁0 ▁) ▁; ▁if ▁( ▁nal ▁-> ▁type ▁== ▁N AL _ IDR _ SL ICE ▁|| ▁h ▁-> ▁recovery _ frame ▁== ▁h ▁-> ▁p oc ▁. ▁frame _ num ▁) ▁{ ▁h ▁-> ▁recovery _ frame ▁= ▁-1 ▁; ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁recovered ▁= ▁1 ▁; ▁} ▁if ▁( ▁nal ▁-> ▁type ▁== ▁N AL _ IDR _ SL ICE ▁) ▁h ▁-> ▁frame _ re covered ▁|= ▁FRAME _ RECOVER ED _ IDR ▁; ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁recovered ▁|= ▁! ▁! ▁( ▁h ▁-> ▁frame _ re covered ▁& ▁FRAME _ RECOVER ED _ IDR ▁) ▁; ▁if ▁( ▁h ▁-> ▁current _ slice ▁== ▁1 ▁) ▁{ ▁if ▁( ▁! ▁( ▁avctx ▁-> ▁flags 2 ▁& ▁AV _ CODEC _ FLAG 2_ CHUNK S ▁) ▁) ▁decode _ post init ▁( ▁h ▁, ▁i ▁>= ▁n als _ needed ▁) ▁; ▁if ▁( ▁h ▁-> ▁avctx ▁-> ▁hw accel ▁&& ▁( ▁ret ▁= ▁h ▁-> ▁avctx ▁-> ▁hw accel ▁-> ▁start _ frame ▁( ▁h ▁-> ▁avctx ▁, ▁NULL ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁sl ▁-> ▁redundant _ pic _ count ▁== ▁0 ▁&& ▁( ▁avctx ▁-> ▁skip _ frame ▁< ▁AV DISCARD _ NON REF ▁|| ▁nal ▁-> ▁ref _ id c ▁) ▁&& ▁( ▁avctx ▁-> ▁skip _ frame ▁< ▁AV DISCARD _ BID IR ▁|| ▁sl ▁-> ▁slice _ type _ nos ▁!= ▁AV _ PICTURE _ TYPE _ B ▁) ▁&& ▁( ▁avctx ▁-> ▁skip _ frame ▁< ▁AV DISCARD _ NON KEY ▁|| ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁f ▁-> ▁key _ frame ▁) ▁&& ▁avctx ▁-> ▁skip _ frame ▁< ▁AV DISCARD _ ALL ▁) ▁{ ▁if ▁( ▁avctx ▁-> ▁hw accel ▁) ▁{ ▁ret ▁= ▁avctx ▁-> ▁hw accel ▁-> ▁decode _ slice ▁( ▁avctx ▁, ▁nal ▁-> ▁raw _ data ▁, ▁nal ▁-> ▁raw _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁else ▁context _ count ▁++ ▁; ▁} ▁break ▁; ▁case ▁N AL _ D PA ▁: ▁case ▁N AL _ DP B ▁: ▁case ▁N AL _ D PC ▁: ▁avpriv _ request _ sample ▁( ▁avctx ▁, ▁" datap art ition ing " ▁) ▁; ▁ret ▁= ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁goto ▁end ▁; ▁break ▁; ▁case ▁N AL _ SE I ▁: ▁ret ▁= ▁ff _ h 264_ se i _ decode ▁( ▁& ▁h ▁-> ▁se i ▁, ▁& ▁nal ▁-> ▁gb ▁, ▁& ▁h ▁-> ▁ps ▁, ▁avctx ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁&& ▁( ▁h ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁) ▁goto ▁end ▁; ▁break ▁; ▁case ▁N AL _ SP S ▁: ▁ret ▁= ▁ff _ h 264_ decode _ seq _ parameter _ set ▁( ▁& ▁nal ▁-> ▁gb ▁, ▁avctx ▁, ▁& ▁h ▁-> ▁ps ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁&& ▁( ▁h ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁) ▁goto ▁end ▁; ▁break ▁; ▁case ▁N AL _ PP S ▁: ▁ret ▁= ▁ff _ h 264_ decode _ picture _ parameter _ set ▁( ▁& ▁nal ▁-> ▁gb ▁, ▁avctx ▁, ▁& ▁h ▁-> ▁ps ▁, ▁nal ▁-> ▁size _ bits ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁&& ▁( ▁h ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁) ▁goto ▁end ▁; ▁break ▁; ▁case ▁N AL _ AUD ▁: ▁case ▁N AL _ END _ SEQUENCE ▁: ▁case ▁N AL _ END _ STREAM ▁: ▁case ▁N AL _ FIL LER _ DATA ▁: ▁case ▁N AL _ SP S _ EXT ▁: ▁case ▁N AL _ AUX IL I ARY _ SL ICE ▁: ▁break ▁; ▁case ▁N AL _ FF _ IGNORE ▁: ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Unknown NAL code :% d (% db its )\ n " ▁, ▁nal ▁-> ▁type ▁, ▁nal ▁-> ▁size _ bits ▁) ▁; ▁} ▁if ▁( ▁context _ count ▁== ▁h ▁-> ▁max _ contexts ▁) ▁{ ▁ret ▁= ▁ff _ h 264_ execute _ decode _ s lices ▁( ▁h ▁, ▁context _ count ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁&& ▁( ▁h ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁) ▁goto ▁end ▁; ▁context _ count ▁= ▁0 ▁; ▁} ▁if ▁( ▁err ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" decode _ slice _ header error \ n " ▁) ▁; ▁sl ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁= ▁sl ▁-> ▁ref _ count ▁[ ▁1 ▁] ▁= ▁sl ▁-> ▁list _ count ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁err ▁== ▁1 ▁) ▁{ ▁sl ▁= ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁; ▁goto ▁again ▁; ▁} ▁} ▁if ▁( ▁context _ count ▁) ▁{ ▁ret ▁= ▁ff _ h 264_ execute _ decode _ s lices ▁( ▁h ▁, ▁context _ count ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁&& ▁( ▁h ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁) ▁goto ▁end ▁; ▁} ▁ret ▁= ▁0 ▁; ▁end ▁: ▁if ▁( ▁h ▁-> ▁cur _ pic _ ptr ▁&& ▁! ▁h ▁-> ▁dro pp able ▁) ▁{ ▁ff _ thread _ report _ progress ▁( ▁& ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁tf ▁, ▁INT _ MAX ▁, ▁h ▁-> ▁picture _ structure ▁== ▁P ICT _ BOTTOM _ FIELD ▁) ▁; ▁} ▁return ▁( ▁ret ▁< ▁0 ▁) ▁? ▁ret ▁: ▁buf _ size ▁; ▁}	1
▁static ▁OSSL _ PARAM ▁* ▁param _ template _ to _ param ▁( ▁PARAM S _ TEMPLATE ▁* ▁tmpl ▁, ▁size _ t ▁* ▁sz ▁) ▁{ ▁size _ t ▁i ▁; ▁void ▁* ▁buf ▁; ▁OSSL _ PARAM ▁* ▁param ▁= ▁NULL ▁; ▁unsigned ▁char ▁* ▁curr buf ▁= ▁NULL ▁; ▁if ▁( ▁tmpl ▁-> ▁tot sz ▁== ▁0 ▁) ▁return ▁NULL ▁; ▁tmpl ▁-> ▁tot sz ▁+= ▁sizeof ▁( ▁* ▁param ▁) ▁; ▁if ▁( ▁tmpl ▁-> ▁is public ▁) ▁buf ▁= ▁OPENSSL _ zalloc ▁( ▁tmpl ▁-> ▁tot sz ▁) ▁; ▁else ▁buf ▁= ▁OPENSSL _ secure _ zalloc ▁( ▁tmpl ▁-> ▁tot sz ▁) ▁; ▁if ▁( ▁buf ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁param ▁= ▁buf ▁; ▁curr buf ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁buf ▁+ ▁( ▁sizeof ▁( ▁* ▁param ▁) ▁* ▁( ▁tmpl ▁-> ▁curr ▁+ ▁1 ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tmpl ▁-> ▁curr ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁ossl _ assert ▁( ▁( ▁curr buf ▁- ▁( ▁unsigned ▁char ▁* ▁) ▁buf ▁) ▁+ ▁tmpl ▁-> ▁params ▁[ ▁i ▁] ▁. ▁bufsz ▁<= ▁tmpl ▁-> ▁tot sz ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ bn 2 native pad ▁( ▁tmpl ▁-> ▁params ▁[ ▁i ▁] ▁. ▁bn param ▁, ▁curr buf ▁, ▁tmpl ▁-> ▁params ▁[ ▁i ▁] ▁. ▁bufsz ▁) ▁< ▁0 ▁) ▁goto ▁err ▁; ▁param ▁[ ▁i ▁] ▁= ▁OSSL _ PARAM _ construct _ BN ▁( ▁tmpl ▁-> ▁params ▁[ ▁i ▁] ▁. ▁key ▁, ▁curr buf ▁, ▁tmpl ▁-> ▁params ▁[ ▁i ▁] ▁. ▁bufsz ▁) ▁; ▁curr buf ▁+= ▁tmpl ▁-> ▁params ▁[ ▁i ▁] ▁. ▁bufsz ▁; ▁} ▁param ▁[ ▁i ▁] ▁= ▁OSSL _ PARAM _ construct _ end ▁( ▁) ▁; ▁if ▁( ▁sz ▁!= ▁NULL ▁) ▁* ▁sz ▁= ▁tmpl ▁-> ▁tot sz ▁; ▁return ▁param ▁; ▁err ▁: ▁if ▁( ▁tmpl ▁-> ▁is public ▁) ▁OPENSSL _ free ▁( ▁param ▁) ▁; ▁else ▁OPENSSL _ clear _ free ▁( ▁param ▁, ▁tmpl ▁-> ▁tot sz ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁int ▁internal _ verify ▁( ▁X 509_ STORE _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁ok ▁= ▁0 ▁, ▁n ▁; ▁X 509 ▁* ▁xs ▁, ▁* ▁xi ▁; ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁int ▁( ▁* ▁cb ▁) ▁( ▁int ▁x ok ▁, ▁X 509_ STORE _ CTX ▁* ▁x ctx ▁) ▁; ▁cb ▁= ▁ctx ▁-> ▁verify _ cb ▁; ▁n ▁= ▁sk _ X 509_ num ▁( ▁ctx ▁-> ▁chain ▁) ▁- ▁1 ▁; ▁ctx ▁-> ▁error _ depth ▁= ▁n ▁; ▁xi ▁= ▁sk _ X 509_ value ▁( ▁ctx ▁-> ▁chain ▁, ▁n ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁bare _ ta _ signed ▁) ▁{ ▁xs ▁= ▁xi ▁; ▁xi ▁= ▁NULL ▁; ▁goto ▁check _ cert ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁check _ iss ued ▁( ▁ctx ▁, ▁xi ▁, ▁xi ▁) ▁) ▁xs ▁= ▁xi ▁; ▁else ▁{ ▁if ▁( ▁ctx ▁-> ▁param ▁-> ▁flags ▁& ▁X 509_ V _ FLAG _ PARTIAL _ CHAIN ▁) ▁{ ▁xs ▁= ▁xi ▁; ▁goto ▁check _ cert ▁; ▁} ▁if ▁( ▁n ▁<= ▁0 ▁) ▁{ ▁ctx ▁-> ▁error ▁= ▁X 509_ V _ ERR _ UN ABLE _ TO _ VERIFY _ LEAF _ SIGNATURE ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁xi ▁; ▁ok ▁= ▁cb ▁( ▁0 ▁, ▁ctx ▁) ▁; ▁goto ▁end ▁; ▁} ▁else ▁{ ▁n ▁-- ▁; ▁ctx ▁-> ▁error _ depth ▁= ▁n ▁; ▁xs ▁= ▁sk _ X 509_ value ▁( ▁ctx ▁-> ▁chain ▁, ▁n ▁) ▁; ▁} ▁} ▁while ▁( ▁n ▁>= ▁0 ▁) ▁{ ▁ctx ▁-> ▁error _ depth ▁= ▁n ▁; ▁if ▁( ▁xs ▁!= ▁xi ▁|| ▁( ▁ctx ▁-> ▁param ▁-> ▁flags ▁& ▁X 509_ V _ FLAG _ CHECK _ SS _ SIGNATURE ▁) ▁) ▁{ ▁if ▁( ▁( ▁pkey ▁= ▁X 509_ get 0_ pubkey ▁( ▁xi ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁ctx ▁-> ▁error ▁= ▁X 509_ V _ ERR _ UN ABLE _ TO _ DECODE _ IS SU ER _ PUBLIC _ KEY ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁xi ▁; ▁ok ▁= ▁( ▁* ▁cb ▁) ▁( ▁0 ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁goto ▁end ▁; ▁} ▁else ▁if ▁( ▁X 509_ verify ▁( ▁xs ▁, ▁pkey ▁) ▁<= ▁0 ▁) ▁{ ▁ctx ▁-> ▁error ▁= ▁X 509_ V _ ERR _ CERT _ SIGNATURE _ FAILURE ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁xs ▁; ▁ok ▁= ▁( ▁* ▁cb ▁) ▁( ▁0 ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁goto ▁end ▁; ▁} ▁} ▁check _ cert ▁: ▁ok ▁= ▁x 509_ check _ cert _ time ▁( ▁ctx ▁, ▁xs ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁goto ▁end ▁; ▁ctx ▁-> ▁current _ iss uer ▁= ▁xi ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁xs ▁; ▁ok ▁= ▁( ▁* ▁cb ▁) ▁( ▁1 ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁goto ▁end ▁; ▁n ▁-- ▁; ▁if ▁( ▁n ▁>= ▁0 ▁) ▁{ ▁xi ▁= ▁xs ▁; ▁xs ▁= ▁sk _ X 509_ value ▁( ▁ctx ▁-> ▁chain ▁, ▁n ▁) ▁; ▁} ▁} ▁ok ▁= ▁1 ▁; ▁end ▁: ▁return ▁ok ▁; ▁}	0
▁static ▁int ▁write _ image _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁; ▁AVCodec Parameters ▁* ▁enc ctx ▁= ▁st ▁-> ▁codecpar ▁; ▁FIT S Context ▁* ▁fits ctx ▁= ▁s ▁-> ▁priv _ data ▁; ▁uint 8_ t ▁buffer ▁[ ▁80 ▁] ▁; ▁int ▁bit pix ▁, ▁n axis ▁, ▁n axis 3 ▁= ▁1 ▁, ▁bzero ▁= ▁0 ▁, ▁rgb ▁= ▁0 ▁, ▁lines _ written ▁= ▁0 ▁, ▁lines _ left ▁; ▁switch ▁( ▁enc ctx ▁-> ▁format ▁) ▁{ ▁case ▁AV _ PIX _ FMT _ GRAY 8 ▁: ▁bit pix ▁= ▁8 ▁; ▁n axis ▁= ▁2 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ GRAY 16 BE ▁: ▁bit pix ▁= ▁16 ▁; ▁n axis ▁= ▁2 ▁; ▁bzero ▁= ▁32768 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ GB RP ▁: ▁case ▁AV _ PIX _ FMT _ GB R AP ▁: ▁bit pix ▁= ▁8 ▁; ▁n axis ▁= ▁3 ▁; ▁rgb ▁= ▁1 ▁; ▁if ▁( ▁enc ctx ▁-> ▁format ▁== ▁AV _ PIX _ FMT _ GB RP ▁) ▁{ ▁n axis 3 ▁= ▁3 ▁; ▁} ▁else ▁{ ▁n axis 3 ▁= ▁4 ▁; ▁} ▁break ▁; ▁case ▁AV _ PIX _ FMT _ GB RP 16 BE ▁: ▁case ▁AV _ PIX _ FMT _ GB R AP 16 BE ▁: ▁bit pix ▁= ▁16 ▁; ▁n axis ▁= ▁3 ▁; ▁rgb ▁= ▁1 ▁; ▁if ▁( ▁enc ctx ▁-> ▁format ▁== ▁AV _ PIX _ FMT _ GB RP 16 BE ▁) ▁{ ▁n axis 3 ▁= ▁3 ▁; ▁} ▁else ▁{ ▁n axis 3 ▁= ▁4 ▁; ▁} ▁bzero ▁= ▁32768 ▁; ▁break ▁; ▁default ▁: ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁fits ctx ▁-> ▁first _ image ▁) ▁{ ▁memcpy ▁( ▁buffer ▁, ▁" SIMPLE =" ▁, ▁10 ▁) ▁; ▁memset ▁( ▁buffer ▁+ ▁10 ▁, ▁' ▁' ▁, ▁70 ▁) ▁; ▁buffer ▁[ ▁29 ▁] ▁= ▁' ▁' ▁; ▁avio _ write ▁( ▁s ▁-> ▁pb ▁, ▁buffer ▁, ▁sizeof ▁( ▁buffer ▁) ▁) ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁buffer ▁, ▁" XT ENSION =' IMAGE '" ▁, ▁20 ▁) ▁; ▁memset ▁( ▁buffer ▁+ ▁20 ▁, ▁' ▁' ▁, ▁60 ▁) ▁; ▁avio _ write ▁( ▁s ▁-> ▁pb ▁, ▁buffer ▁, ▁sizeof ▁( ▁buffer ▁) ▁) ▁; ▁} ▁lines _ written ▁++ ▁; ▁write _ keyword _ value ▁( ▁s ▁, ▁" BIT PIX " ▁, ▁bit pix ▁, ▁& ▁lines _ written ▁) ▁; ▁write _ keyword _ value ▁( ▁s ▁, ▁" N AXIS " ▁, ▁n axis ▁, ▁& ▁lines _ written ▁) ▁; ▁write _ keyword _ value ▁( ▁s ▁, ▁" N AXIS 1" ▁, ▁enc ctx ▁-> ▁width ▁, ▁& ▁lines _ written ▁) ▁; ▁write _ keyword _ value ▁( ▁s ▁, ▁" N AXIS 2" ▁, ▁enc ctx ▁-> ▁height ▁, ▁& ▁lines _ written ▁) ▁; ▁if ▁( ▁rgb ▁) ▁write _ keyword _ value ▁( ▁s ▁, ▁" N AXIS 3" ▁, ▁n axis 3 ▁, ▁& ▁lines _ written ▁) ▁; ▁if ▁( ▁! ▁fits ctx ▁-> ▁first _ image ▁) ▁{ ▁write _ keyword _ value ▁( ▁s ▁, ▁" P COUNT " ▁, ▁0 ▁, ▁& ▁lines _ written ▁) ▁; ▁write _ keyword _ value ▁( ▁s ▁, ▁" G COUNT " ▁, ▁1 ▁, ▁& ▁lines _ written ▁) ▁; ▁} ▁else ▁{ ▁fits ctx ▁-> ▁first _ image ▁= ▁0 ▁; ▁} ▁if ▁( ▁bit pix ▁== ▁16 ▁) ▁write _ keyword _ value ▁( ▁s ▁, ▁" B ZERO " ▁, ▁bzero ▁, ▁& ▁lines _ written ▁) ▁; ▁if ▁( ▁rgb ▁) ▁{ ▁memcpy ▁( ▁buffer ▁, ▁" CTYPE 3 =' RGB '" ▁, ▁20 ▁) ▁; ▁memset ▁( ▁buffer ▁+ ▁20 ▁, ▁' ▁' ▁, ▁60 ▁) ▁; ▁avio _ write ▁( ▁s ▁-> ▁pb ▁, ▁buffer ▁, ▁sizeof ▁( ▁buffer ▁) ▁) ▁; ▁lines _ written ▁++ ▁; ▁} ▁memcpy ▁( ▁buffer ▁, ▁" END " ▁, ▁3 ▁) ▁; ▁memset ▁( ▁buffer ▁+ ▁3 ▁, ▁' ▁' ▁, ▁77 ▁) ▁; ▁avio _ write ▁( ▁s ▁-> ▁pb ▁, ▁buffer ▁, ▁sizeof ▁( ▁buffer ▁) ▁) ▁; ▁lines _ written ▁++ ▁; ▁lines _ left ▁= ▁( ▁( ▁lines _ written ▁+ ▁35 ▁) ▁/ ▁36 ▁) ▁* ▁36 ▁- ▁lines _ written ▁; ▁memset ▁( ▁buffer ▁, ▁' ▁' ▁, ▁80 ▁) ▁; ▁while ▁( ▁lines _ left ▁> ▁0 ▁) ▁{ ▁avio _ write ▁( ▁s ▁-> ▁pb ▁, ▁buffer ▁, ▁sizeof ▁( ▁buffer ▁) ▁) ▁; ▁lines _ left ▁-- ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁ngx _ http _ up stream _ process _ header ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ http _ up stream _ t ▁* ▁u ▁) ▁{ ▁ssize _ t ▁n ▁; ▁ngx _ int _ t ▁rc ▁; ▁ngx _ connection _ t ▁* ▁c ▁; ▁c ▁= ▁u ▁-> ▁peer ▁. ▁connection ▁; ▁ngx _ log _ debug 0 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" http up st reamp ro cess header " ▁) ▁; ▁c ▁-> ▁log ▁-> ▁action ▁= ▁" reading response header from up stream " ▁; ▁if ▁( ▁c ▁-> ▁read ▁-> ▁timed out ▁) ▁{ ▁ngx _ http _ up stream _ next ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ UP STREAM _ FT _ TIMEOUT ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁u ▁-> ▁request _ sent ▁&& ▁ngx _ http _ up stream _ test _ connect ▁( ▁c ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁ngx _ http _ up stream _ next ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ UP STREAM _ FT _ ERROR ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁u ▁-> ▁buffer ▁. ▁start ▁== ▁NULL ▁) ▁{ ▁u ▁-> ▁buffer ▁. ▁start ▁= ▁ngx _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁u ▁-> ▁conf ▁-> ▁buffer _ size ▁) ▁; ▁if ▁( ▁u ▁-> ▁buffer ▁. ▁start ▁== ▁NULL ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁; ▁} ▁u ▁-> ▁buffer ▁. ▁pos ▁= ▁u ▁-> ▁buffer ▁. ▁start ▁; ▁u ▁-> ▁buffer ▁. ▁last ▁= ▁u ▁-> ▁buffer ▁. ▁start ▁; ▁u ▁-> ▁buffer ▁. ▁end ▁= ▁u ▁-> ▁buffer ▁. ▁start ▁+ ▁u ▁-> ▁conf ▁-> ▁buffer _ size ▁; ▁u ▁-> ▁buffer ▁. ▁temporary ▁= ▁1 ▁; ▁u ▁-> ▁buffer ▁. ▁tag ▁= ▁u ▁-> ▁output ▁. ▁tag ▁; ▁if ▁( ▁ngx _ list _ init ▁( ▁& ▁u ▁-> ▁headers _ in ▁. ▁headers ▁, ▁r ▁-> ▁pool ▁, ▁8 ▁, ▁sizeof ▁( ▁ngx _ table _ elt _ t ▁) ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁; ▁} ▁# if ▁( ▁NGX _ HTTP _ CACHE ▁) ▁if ▁( ▁r ▁-> ▁cache ▁) ▁{ ▁u ▁-> ▁buffer ▁. ▁pos ▁+= ▁r ▁-> ▁cache ▁-> ▁header _ start ▁; ▁u ▁-> ▁buffer ▁. ▁last ▁= ▁u ▁-> ▁buffer ▁. ▁pos ▁; ▁} ▁# endif ▁} ▁for ▁( ▁; ▁; ▁) ▁{ ▁n ▁= ▁c ▁-> ▁recv ▁( ▁c ▁, ▁u ▁-> ▁buffer ▁. ▁last ▁, ▁u ▁-> ▁buffer ▁. ▁end ▁- ▁u ▁-> ▁buffer ▁. ▁last ▁) ▁; ▁if ▁( ▁n ▁== ▁NGX _ AGAIN ▁) ▁{ ▁# if ▁0 ▁ngx _ add _ timer ▁( ▁rev ▁, ▁u ▁-> ▁read _ timeout ▁) ▁; ▁# endif ▁if ▁( ▁ngx _ handle _ read _ event ▁( ▁c ▁-> ▁read ▁, ▁0 ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁; ▁} ▁return ▁; ▁} ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" up st reamp rem ature ly closed connection " ▁) ▁; ▁} ▁if ▁( ▁n ▁== ▁NGX _ ERROR ▁|| ▁n ▁== ▁0 ▁) ▁{ ▁ngx _ http _ up stream _ next ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ UP STREAM _ FT _ ERROR ▁) ▁; ▁return ▁; ▁} ▁u ▁-> ▁state ▁-> ▁bytes _ received ▁+= ▁n ▁; ▁u ▁-> ▁buffer ▁. ▁last ▁+= ▁n ▁; ▁# if ▁0 ▁u ▁-> ▁valid _ header _ in ▁= ▁0 ▁; ▁u ▁-> ▁peer ▁. ▁cached ▁= ▁0 ▁; ▁# endif ▁rc ▁= ▁u ▁-> ▁process _ header ▁( ▁r ▁) ▁; ▁if ▁( ▁rc ▁== ▁NGX _ AGAIN ▁) ▁{ ▁if ▁( ▁u ▁-> ▁buffer ▁. ▁last ▁== ▁u ▁-> ▁buffer ▁. ▁end ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" up stream sent too big header " ▁) ▁; ▁ngx _ http _ up stream _ next ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ UP STREAM _ FT _ INVALID _ HEADER ▁) ▁; ▁return ▁; ▁} ▁continue ▁; ▁} ▁break ▁; ▁} ▁if ▁( ▁rc ▁== ▁NGX _ HTTP _ UP STREAM _ INVALID _ HEADER ▁) ▁{ ▁ngx _ http _ up stream _ next ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ UP STREAM _ FT _ INVALID _ HEADER ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁rc ▁== ▁NGX _ ERROR ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁; ▁} ▁u ▁-> ▁state ▁-> ▁header _ time ▁= ▁ngx _ current _ msec ▁- ▁u ▁-> ▁state ▁-> ▁response _ time ▁; ▁if ▁( ▁u ▁-> ▁headers _ in ▁. ▁status _ n ▁>= ▁NGX _ HTTP _ SPECIAL _ RESPONSE ▁) ▁{ ▁if ▁( ▁ngx _ http _ up stream _ test _ next ▁( ▁r ▁, ▁u ▁) ▁== ▁NGX _ OK ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁ngx _ http _ up stream _ intercept _ errors ▁( ▁r ▁, ▁u ▁) ▁== ▁NGX _ OK ▁) ▁{ ▁return ▁; ▁} ▁} ▁if ▁( ▁ngx _ http _ up stream _ process _ headers ▁( ▁r ▁, ▁u ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁! ▁r ▁-> ▁sub request _ in _ memory ▁) ▁{ ▁ngx _ http _ up stream _ send _ response ▁( ▁r ▁, ▁u ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁u ▁-> ▁input _ filter ▁== ▁NULL ▁) ▁{ ▁u ▁-> ▁input _ filter _ init ▁= ▁ngx _ http _ up stream _ non _ buffered _ filter _ init ▁; ▁u ▁-> ▁input _ filter ▁= ▁ngx _ http _ up stream _ non _ buffered _ filter ▁; ▁u ▁-> ▁input _ filter _ ctx ▁= ▁r ▁; ▁} ▁if ▁( ▁u ▁-> ▁input _ filter _ init ▁( ▁u ▁-> ▁input _ filter _ ctx ▁) ▁== ▁NGX _ ERROR ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁NGX _ ERROR ▁) ▁; ▁return ▁; ▁} ▁n ▁= ▁u ▁-> ▁buffer ▁. ▁last ▁- ▁u ▁-> ▁buffer ▁. ▁pos ▁; ▁if ▁( ▁n ▁) ▁{ ▁u ▁-> ▁buffer ▁. ▁last ▁= ▁u ▁-> ▁buffer ▁. ▁pos ▁; ▁u ▁-> ▁state ▁-> ▁response _ length ▁+= ▁n ▁; ▁if ▁( ▁u ▁-> ▁input _ filter ▁( ▁u ▁-> ▁input _ filter _ ctx ▁, ▁n ▁) ▁== ▁NGX _ ERROR ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁NGX _ ERROR ▁) ▁; ▁return ▁; ▁} ▁} ▁if ▁( ▁u ▁-> ▁length ▁== ▁0 ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁0 ▁) ▁; ▁return ▁; ▁} ▁u ▁-> ▁read _ event _ handler ▁= ▁ngx _ http _ up stream _ process _ body _ in _ memory ▁; ▁ngx _ http _ up stream _ process _ body _ in _ memory ▁( ▁r ▁, ▁u ▁) ▁; ▁}	1
▁static ▁int ▁init _ pass 2 ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁Rate Control Context ▁* ▁rcc ▁= ▁& ▁s ▁-> ▁rc _ context ▁; ▁AVCodecContext ▁* ▁a ▁= ▁s ▁-> ▁avctx ▁; ▁int ▁i ▁, ▁too big ▁; ▁double ▁fps ▁= ▁get _ fps ▁( ▁s ▁-> ▁avctx ▁) ▁; ▁double ▁complexity ▁[ ▁5 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁uint 64_ t ▁const _ bits ▁[ ▁5 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁uint 64_ t ▁all _ const _ bits ▁; ▁uint 64_ t ▁all _ available _ bits ▁= ▁( ▁uint 64_ t ▁) ▁( ▁s ▁-> ▁bit _ rate ▁* ▁( ▁double ▁) ▁rcc ▁-> ▁num _ entries ▁/ ▁fps ▁) ▁; ▁double ▁rate _ factor ▁= ▁0 ▁; ▁double ▁step ▁; ▁const ▁int ▁filter _ size ▁= ▁( ▁int ▁) ▁( ▁a ▁-> ▁q blur ▁* ▁4 ▁) ▁| ▁1 ▁; ▁double ▁expected _ bits ▁= ▁0 ▁; ▁double ▁* ▁q scale ▁, ▁* ▁bl urred _ q scale ▁, ▁q scale _ sum ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁rcc ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁Rate Control Entry ▁* ▁r ce ▁= ▁& ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁; ▁r ce ▁-> ▁new _ p ict _ type ▁= ▁r ce ▁-> ▁pict _ type ▁; ▁rcc ▁-> ▁i _ c plx _ sum ▁[ ▁r ce ▁-> ▁pict _ type ▁] ▁+= ▁r ce ▁-> ▁i _ tex _ bits ▁* ▁r ce ▁-> ▁q scale ▁; ▁rcc ▁-> ▁p _ c plx _ sum ▁[ ▁r ce ▁-> ▁pict _ type ▁] ▁+= ▁r ce ▁-> ▁p _ tex _ bits ▁* ▁r ce ▁-> ▁q scale ▁; ▁rcc ▁-> ▁mv _ bits _ sum ▁[ ▁r ce ▁-> ▁pict _ type ▁] ▁+= ▁r ce ▁-> ▁mv _ bits ▁; ▁rcc ▁-> ▁frame _ count ▁[ ▁r ce ▁-> ▁pict _ type ▁] ▁++ ▁; ▁complexity ▁[ ▁r ce ▁-> ▁new _ p ict _ type ▁] ▁+= ▁( ▁r ce ▁-> ▁i _ tex _ bits ▁+ ▁r ce ▁-> ▁p _ tex _ bits ▁) ▁* ▁( ▁double ▁) ▁r ce ▁-> ▁q scale ▁; ▁const _ bits ▁[ ▁r ce ▁-> ▁new _ p ict _ type ▁] ▁+= ▁r ce ▁-> ▁mv _ bits ▁+ ▁r ce ▁-> ▁misc _ bits ▁; ▁} ▁all _ const _ bits ▁= ▁const _ bits ▁[ ▁AV _ PICTURE _ TYPE _ I ▁] ▁+ ▁const _ bits ▁[ ▁AV _ PICTURE _ TYPE _ P ▁] ▁+ ▁const _ bits ▁[ ▁AV _ PICTURE _ TYPE _ B ▁] ▁; ▁if ▁( ▁all _ available _ bits ▁< ▁all _ const _ bits ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" requested bitrate ist oo low \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁q scale ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁double ▁) ▁* ▁rcc ▁-> ▁num _ entries ▁) ▁; ▁bl urred _ q scale ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁double ▁) ▁* ▁rcc ▁-> ▁num _ entries ▁) ▁; ▁too big ▁= ▁0 ▁; ▁for ▁( ▁step ▁= ▁256 ▁* ▁256 ▁; ▁step ▁> ▁0. 0000001 ▁; ▁step ▁*= ▁0.5 ▁) ▁{ ▁expected _ bits ▁= ▁0 ▁; ▁rate _ factor ▁+= ▁step ▁; ▁rcc ▁-> ▁buffer _ index ▁= ▁s ▁-> ▁avctx ▁-> ▁rc _ buffer _ size ▁/ ▁2 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁rcc ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁Rate Control Entry ▁* ▁r ce ▁= ▁& ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁; ▁q scale ▁[ ▁i ▁] ▁= ▁get _ q scale ▁( ▁s ▁, ▁& ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁, ▁rate _ factor ▁, ▁i ▁) ▁; ▁rcc ▁-> ▁last _ q scale _ for ▁[ ▁r ce ▁-> ▁pict _ type ▁] ▁= ▁q scale ▁[ ▁i ▁] ▁; ▁} ▁assert ▁( ▁filter _ size ▁% ▁2 ▁== ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁FF MAX ▁( ▁0 ▁, ▁rcc ▁-> ▁num _ entries ▁- ▁300 ▁) ▁; ▁i ▁< ▁rcc ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁Rate Control Entry ▁* ▁r ce ▁= ▁& ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁; ▁q scale ▁[ ▁i ▁] ▁= ▁get _ diff _ limited _ q ▁( ▁s ▁, ▁r ce ▁, ▁q scale ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁rcc ▁-> ▁num _ entries ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁Rate Control Entry ▁* ▁r ce ▁= ▁& ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁; ▁q scale ▁[ ▁i ▁] ▁= ▁get _ diff _ limited _ q ▁( ▁s ▁, ▁r ce ▁, ▁q scale ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁rcc ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁Rate Control Entry ▁* ▁r ce ▁= ▁& ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁; ▁const ▁int ▁pict _ type ▁= ▁r ce ▁-> ▁new _ p ict _ type ▁; ▁int ▁j ▁; ▁double ▁q ▁= ▁0.0 ▁, ▁sum ▁= ▁0.0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁filter _ size ▁; ▁j ▁++ ▁) ▁{ ▁int ▁index ▁= ▁i ▁+ ▁j ▁- ▁filter _ size ▁/ ▁2 ▁; ▁double ▁d ▁= ▁index ▁- ▁i ▁; ▁double ▁coeff ▁= ▁a ▁-> ▁q blur ▁== ▁0 ▁? ▁1.0 ▁: ▁exp ▁( ▁- ▁d ▁* ▁d ▁/ ▁( ▁a ▁-> ▁q blur ▁* ▁a ▁-> ▁q blur ▁) ▁) ▁; ▁if ▁( ▁index ▁< ▁0 ▁|| ▁index ▁>= ▁rcc ▁-> ▁num _ entries ▁) ▁continue ▁; ▁if ▁( ▁pict _ type ▁!= ▁rcc ▁-> ▁entry ▁[ ▁index ▁] ▁. ▁new _ p ict _ type ▁) ▁continue ▁; ▁q ▁+= ▁q scale ▁[ ▁index ▁] ▁* ▁coeff ▁; ▁sum ▁+= ▁coeff ▁; ▁} ▁bl urred _ q scale ▁[ ▁i ▁] ▁= ▁q ▁/ ▁sum ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁rcc ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁Rate Control Entry ▁* ▁r ce ▁= ▁& ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁; ▁double ▁bits ▁; ▁r ce ▁-> ▁new _ q scale ▁= ▁modify _ q scale ▁( ▁s ▁, ▁r ce ▁, ▁bl urred _ q scale ▁[ ▁i ▁] ▁, ▁i ▁) ▁; ▁bits ▁= ▁qp 2 bits ▁( ▁r ce ▁, ▁r ce ▁-> ▁new _ q scale ▁) ▁+ ▁r ce ▁-> ▁mv _ bits ▁+ ▁r ce ▁-> ▁misc _ bits ▁; ▁bits ▁+= ▁8 ▁* ▁ff _ vb v _ update ▁( ▁s ▁, ▁bits ▁) ▁; ▁r ce ▁-> ▁expected _ bits ▁= ▁expected _ bits ▁; ▁expected _ bits ▁+= ▁bits ▁; ▁} ▁av _ d log ▁( ▁s ▁-> ▁avctx ▁, ▁" expected _ bits :% fall _ available _ bits :% drate _ factor :% f \ n " ▁, ▁expected _ bits ▁, ▁( ▁int ▁) ▁all _ available _ bits ▁, ▁rate _ factor ▁) ▁; ▁if ▁( ▁expected _ bits ▁> ▁all _ available _ bits ▁) ▁{ ▁rate _ factor ▁-= ▁step ▁; ▁++ ▁too big ▁; ▁} ▁} ▁av _ free ▁( ▁q scale ▁) ▁; ▁av _ free ▁( ▁bl urred _ q scale ▁) ▁; ▁q scale _ sum ▁= ▁0.0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁rcc ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁av _ d log ▁( ▁s ▁, ▁"[ la vc rc ] entry [% d ]. new _ q scale =% .3 f qp =% .3 f \ n " ▁, ▁i ▁, ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁. ▁new _ q scale ▁, ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁. ▁new _ q scale ▁/ ▁FF _ QP 2 L AMBDA ▁) ▁; ▁q scale _ sum ▁+= ▁av _ clip ▁( ▁rcc ▁-> ▁entry ▁[ ▁i ▁] ▁. ▁new _ q scale ▁/ ▁FF _ QP 2 L AMBDA ▁, ▁s ▁-> ▁avctx ▁-> ▁q min ▁, ▁s ▁-> ▁avctx ▁-> ▁q max ▁) ▁; ▁} ▁assert ▁( ▁too big ▁<= ▁40 ▁) ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁"[ la vc rc ] requested bitrate :% db p sex pected bitrate :% db ps \ n " ▁, ▁s ▁-> ▁bit _ rate ▁, ▁( ▁int ▁) ▁( ▁expected _ bits ▁/ ▁( ▁( ▁double ▁) ▁all _ available _ bits ▁/ ▁s ▁-> ▁bit _ rate ▁) ▁) ▁) ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁"[ la vc rc ] estim ated target average qp :% .3 f \ n " ▁, ▁( ▁float ▁) ▁q scale _ sum ▁/ ▁rcc ▁-> ▁num _ entries ▁) ▁; ▁if ▁( ▁too big ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ INFO ▁, ▁"[ la vc rc ] Using allo f requested bitrate is not " ▁" necessary f orth is vide ow ith the se parameters .\ n " ▁) ▁; ▁} ▁else ▁if ▁( ▁too big ▁== ▁40 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"[ la vc rc ] Error : bit rat et oo low f orth is video " ▁" with the se parameters .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁fabs ▁( ▁expected _ bits ▁/ ▁all _ available _ bits ▁- ▁1.0 ▁) ▁> ▁0.01 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"[ la vc rc ] Error :2 pass curve failed t ocon ver ge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁void ▁avfilter _ filter _ samples ▁( ▁AVFilter Link ▁* ▁link ▁, ▁AVFilter Buffer Ref ▁* ▁samples ref ▁) ▁{ ▁void ▁( ▁* ▁filter _ samples ▁) ▁( ▁AVFilter Link ▁* ▁, ▁AVFilter Buffer Ref ▁* ▁) ▁; ▁AVFilter Pad ▁* ▁dst ▁= ▁link ▁-> ▁dst pad ▁; ▁int ▁i ▁; ▁FF _ D PRINTF _ START ▁( ▁NULL ▁, ▁filter _ samples ▁) ▁; ▁ff _ d log _ link ▁( ▁NULL ▁, ▁link ▁, ▁1 ▁) ▁; ▁if ▁( ▁! ▁( ▁filter _ samples ▁= ▁dst ▁-> ▁filter _ samples ▁) ▁) ▁filter _ samples ▁= ▁avfilter _ default _ filter _ samples ▁; ▁if ▁( ▁( ▁dst ▁-> ▁min _ perms ▁& ▁samples ref ▁-> ▁perms ▁) ▁!= ▁dst ▁-> ▁min _ perms ▁|| ▁dst ▁-> ▁re j _ perms ▁& ▁samples ref ▁-> ▁perms ▁) ▁{ ▁av _ log ▁( ▁link ▁-> ▁dst ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Copy ing aud iod ata in av filter ( have perms % x , need % x , reject % x )\ n " ▁, ▁samples ref ▁-> ▁perms ▁, ▁link ▁-> ▁dst pad ▁-> ▁min _ perms ▁, ▁link ▁-> ▁dst pad ▁-> ▁re j _ perms ▁) ▁; ▁link ▁-> ▁cur _ buf ▁= ▁avfilter _ default _ get _ audio _ buffer ▁( ▁link ▁, ▁dst ▁-> ▁min _ perms ▁, ▁samples ref ▁-> ▁audio ▁-> ▁nb _ samples ▁) ▁; ▁link ▁-> ▁cur _ buf ▁-> ▁pts ▁= ▁samples ref ▁-> ▁pts ▁; ▁link ▁-> ▁cur _ buf ▁-> ▁audio ▁-> ▁sample _ rate ▁= ▁samples ref ▁-> ▁audio ▁-> ▁sample _ rate ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁samples ref ▁-> ▁data ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁memcpy ▁( ▁link ▁-> ▁cur _ buf ▁-> ▁data ▁[ ▁i ▁] ▁, ▁samples ref ▁-> ▁data ▁[ ▁i ▁] ▁, ▁samples ref ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁; ▁avfilter _ unref _ buffer ▁( ▁samples ref ▁) ▁; ▁} ▁else ▁link ▁-> ▁cur _ buf ▁= ▁samples ref ▁; ▁filter _ samples ▁( ▁link ▁, ▁link ▁-> ▁cur _ buf ▁) ▁; ▁}	1
▁static ▁int ▁ff _ as f _ get _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁) ▁{ ▁ASF Context ▁* ▁as f ▁= ▁s ▁-> ▁priv _ data ▁; ▁uint 32_ t ▁packet _ length ▁, ▁pad size ▁; ▁int ▁rsize ▁= ▁8 ▁; ▁int ▁c ▁, ▁d ▁, ▁e ▁, ▁off ▁; ▁off ▁= ▁32768 ▁; ▁if ▁( ▁s ▁-> ▁packet _ size ▁> ▁0 ▁) ▁off ▁= ▁( ▁avio _ tell ▁( ▁pb ▁) ▁- ▁s ▁-> ▁data _ offset ▁) ▁% ▁s ▁-> ▁packet _ size ▁+ ▁3 ▁; ▁c ▁= ▁d ▁= ▁e ▁= ▁-1 ▁; ▁while ▁( ▁off ▁-- ▁> ▁0 ▁) ▁{ ▁c ▁= ▁d ▁; ▁d ▁= ▁e ▁; ▁e ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁if ▁( ▁c ▁== ▁0 x 82 ▁&& ▁! ▁d ▁&& ▁! ▁e ▁) ▁break ▁; ▁} ▁if ▁( ▁c ▁!= ▁0 x 82 ▁) ▁{ ▁if ▁( ▁pb ▁-> ▁error ▁== ▁AVERROR ▁( ▁EAGAIN ▁) ▁) ▁return ▁AVERROR ▁( ▁EAGAIN ▁) ▁; ▁if ▁( ▁! ▁pb ▁-> ▁eof _ reached ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" ff as fb ad header % x at :% " ▁PRId 64 ▁"\ n " ▁, ▁c ▁, ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁} ▁if ▁( ▁( ▁c ▁& ▁0 x 8 f ▁) ▁== ▁0 x 82 ▁) ▁{ ▁if ▁( ▁d ▁|| ▁e ▁) ▁{ ▁if ▁( ▁! ▁pb ▁-> ▁eof _ reached ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" ff as fb ad non zero \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁c ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁d ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁rsize ▁+= ▁3 ▁; ▁} ▁else ▁{ ▁avio _ seek ▁( ▁pb ▁, ▁-1 ▁, ▁SEEK _ CUR ▁) ▁; ▁} ▁as f ▁-> ▁packet _ flags ▁= ▁c ▁; ▁as f ▁-> ▁packet _ property ▁= ▁d ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ flags ▁>> ▁5 ▁, ▁packet _ length ▁, ▁s ▁-> ▁packet _ size ▁) ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ flags ▁>> ▁1 ▁, ▁pad size ▁, ▁0 ▁) ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ flags ▁>> ▁3 ▁, ▁pad size ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁packet _ length ▁|| ▁packet _ length ▁>= ▁( ▁1 U ▁<< ▁29 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid packet _ length % dat :% " ▁PRId 64 ▁"\ n " ▁, ▁packet _ length ▁, ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁pad size ▁>= ▁packet _ length ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid pad size % dat :% " ▁PRId 64 ▁"\ n " ▁, ▁pad size ▁, ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁return ▁-1 ▁; ▁} ▁as f ▁-> ▁packet _ timestamp ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁as f ▁-> ▁packet _ flags ▁& ▁0 x 01 ▁) ▁{ ▁as f ▁-> ▁packet _ segs iz etype ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁rsize ▁++ ▁; ▁as f ▁-> ▁packet _ segments ▁= ▁as f ▁-> ▁packet _ segs iz etype ▁& ▁0 x 3 f ▁; ▁} ▁else ▁{ ▁as f ▁-> ▁packet _ segments ▁= ▁1 ▁; ▁as f ▁-> ▁packet _ segs iz etype ▁= ▁0 x 80 ▁; ▁} ▁if ▁( ▁rsize ▁> ▁packet _ length ▁- ▁pad size ▁) ▁{ ▁as f ▁-> ▁packet _ size _ left ▁= ▁0 ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid packet header length % df orp kt len % d -% dat %" ▁PRId 64 ▁"\ n " ▁, ▁rsize ▁, ▁packet _ length ▁, ▁pad size ▁, ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁return ▁-1 ▁; ▁} ▁as f ▁-> ▁packet _ size _ left ▁= ▁packet _ length ▁- ▁pad size ▁- ▁rsize ▁; ▁if ▁( ▁packet _ length ▁< ▁as f ▁-> ▁hdr ▁. ▁min _ pkt size ▁) ▁pad size ▁+= ▁as f ▁-> ▁hdr ▁. ▁min _ pkt size ▁- ▁packet _ length ▁; ▁as f ▁-> ▁packet _ pad size ▁= ▁pad size ▁; ▁av _ d log ▁( ▁s ▁, ▁" packet : size =% dp ad size =% d left =% d \ n " ▁, ▁s ▁-> ▁packet _ size ▁, ▁as f ▁-> ▁packet _ pad size ▁, ▁as f ▁-> ▁packet _ size _ left ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁PKCS 5_ v 2_ PB KDF 2_ key iv gen ▁( ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁, ▁const ▁char ▁* ▁pass ▁, ▁int ▁passlen ▁, ▁ASN 1_ TYPE ▁* ▁param ▁, ▁const ▁EVP _ CIPHER ▁* ▁c ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁int ▁en _ de ▁) ▁{ ▁unsigned ▁char ▁* ▁salt ▁, ▁key ▁[ ▁EVP _ MAX _ KEY _ LENGTH ▁] ▁; ▁const ▁unsigned ▁char ▁* ▁pbuf ▁; ▁int ▁saltlen ▁, ▁iter ▁, ▁plen ▁; ▁int ▁rv ▁= ▁0 ▁; ▁unsigned ▁int ▁keylen ▁= ▁0 ▁; ▁int ▁prf _ nid ▁, ▁hmac _ md _ nid ▁; ▁PB KDF 2 PARAM ▁* ▁k df ▁= ▁NULL ▁; ▁const ▁EVP _ MD ▁* ▁prf md ▁; ▁if ▁( ▁EVP _ CIPHER _ CTX _ cipher ▁( ▁ctx ▁) ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKCS 5_ V 2_ PB KDF 2_ KEY IV GEN ▁, ▁EVP _ R _ NO _ CIPHER _ SET ▁) ▁; ▁goto ▁err ▁; ▁} ▁keylen ▁= ▁EVP _ CIPHER _ CTX _ key _ length ▁( ▁ctx ▁) ▁; ▁OPENSSL _ assert ▁( ▁keylen ▁<= ▁sizeof ▁key ▁) ▁; ▁if ▁( ▁! ▁param ▁|| ▁( ▁param ▁-> ▁type ▁!= ▁V _ ASN 1_ SEQUENCE ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKCS 5_ V 2_ PB KDF 2_ KEY IV GEN ▁, ▁EVP _ R _ DECODE _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁pbuf ▁= ▁param ▁-> ▁value ▁. ▁sequence ▁-> ▁data ▁; ▁plen ▁= ▁param ▁-> ▁value ▁. ▁sequence ▁-> ▁length ▁; ▁if ▁( ▁! ▁( ▁k df ▁= ▁d 2 i _ PB KDF 2 PARAM ▁( ▁NULL ▁, ▁& ▁pbuf ▁, ▁plen ▁) ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKCS 5_ V 2_ PB KDF 2_ KEY IV GEN ▁, ▁EVP _ R _ DECODE _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁keylen ▁= ▁EVP _ CIPHER _ CTX _ key _ length ▁( ▁ctx ▁) ▁; ▁if ▁( ▁k df ▁-> ▁key length ▁&& ▁( ▁ASN 1_ INTEGER _ get ▁( ▁k df ▁-> ▁key length ▁) ▁!= ▁( ▁int ▁) ▁keylen ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKCS 5_ V 2_ PB KDF 2_ KEY IV GEN ▁, ▁EVP _ R _ UNSUPPORTED _ KEY LENGTH ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁k df ▁-> ▁prf ▁) ▁prf _ nid ▁= ▁OBJ _ obj 2 nid ▁( ▁k df ▁-> ▁prf ▁-> ▁algorithm ▁) ▁; ▁else ▁prf _ nid ▁= ▁NID _ hmac With SHA 1 ▁; ▁if ▁( ▁! ▁EVP _ PBE _ find ▁( ▁EVP _ PBE _ TYPE _ PR F ▁, ▁prf _ nid ▁, ▁NULL ▁, ▁& ▁hmac _ md _ nid ▁, ▁0 ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKCS 5_ V 2_ PB KDF 2_ KEY IV GEN ▁, ▁EVP _ R _ UNSUPPORTED _ PR F ▁) ▁; ▁goto ▁err ▁; ▁} ▁prf md ▁= ▁EVP _ get _ digest b yn id ▁( ▁hmac _ md _ nid ▁) ▁; ▁if ▁( ▁prf md ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKCS 5_ V 2_ PB KDF 2_ KEY IV GEN ▁, ▁EVP _ R _ UNSUPPORTED _ PR F ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁k df ▁-> ▁salt ▁-> ▁type ▁!= ▁V _ ASN 1_ OCTET _ STRING ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKCS 5_ V 2_ PB KDF 2_ KEY IV GEN ▁, ▁EVP _ R _ UNSUPPORTED _ S ALT _ TYPE ▁) ▁; ▁goto ▁err ▁; ▁} ▁salt ▁= ▁k df ▁-> ▁salt ▁-> ▁value ▁. ▁octet _ string ▁-> ▁data ▁; ▁saltlen ▁= ▁k df ▁-> ▁salt ▁-> ▁value ▁. ▁octet _ string ▁-> ▁length ▁; ▁iter ▁= ▁ASN 1_ INTEGER _ get ▁( ▁k df ▁-> ▁iter ▁) ▁; ▁if ▁( ▁! ▁PKCS 5_ PB KDF 2_ HMAC ▁( ▁pass ▁, ▁passlen ▁, ▁salt ▁, ▁saltlen ▁, ▁iter ▁, ▁prf md ▁, ▁keylen ▁, ▁key ▁) ▁) ▁goto ▁err ▁; ▁rv ▁= ▁EVP _ Cipher Init _ ex ▁( ▁ctx ▁, ▁NULL ▁, ▁NULL ▁, ▁key ▁, ▁NULL ▁, ▁en _ de ▁) ▁; ▁err ▁: ▁OPENSSL _ cleanse ▁( ▁key ▁, ▁keylen ▁) ▁; ▁PB KDF 2 PARAM _ free ▁( ▁k df ▁) ▁; ▁return ▁rv ▁; ▁}	0
▁int ▁RAND _ DR BG _ set ▁( ▁RAND _ DR BG ▁* ▁dr bg ▁, ▁int ▁nid ▁, ▁unsigned ▁int ▁flags ▁) ▁{ ▁int ▁ret ▁= ▁1 ▁; ▁dr bg ▁-> ▁state ▁= ▁DR BG _ UN INITIAL I SED ▁; ▁dr bg ▁-> ▁flags ▁= ▁flags ▁; ▁dr bg ▁-> ▁nid ▁= ▁nid ▁; ▁switch ▁( ▁nid ▁) ▁{ ▁default ▁: ▁RAND err ▁( ▁RAND _ F _ RAND _ DR BG _ SET ▁, ▁RAND _ R _ UNSUPPORTED _ DR BG _ TYPE ▁) ▁; ▁return ▁-2 ▁; ▁case ▁0 ▁: ▁return ▁1 ▁; ▁case ▁NID _ aes _128_ ctr ▁: ▁case ▁NID _ aes _19 2_ ctr ▁: ▁case ▁NID _ aes _256_ ctr ▁: ▁ret ▁= ▁ctr _ init ▁( ▁dr bg ▁) ▁; ▁break ▁; ▁} ▁if ▁( ▁ret ▁< ▁0 ▁) ▁RAND err ▁( ▁RAND _ F _ RAND _ DR BG _ SET ▁, ▁RAND _ R _ ERROR _ INITIAL ISING _ DR BG ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁help _ main ▁( ▁int ▁argc ▁, ▁char ▁* ▁* ▁argv ▁) ▁{ ▁FUNCTION ▁* ▁fp ▁; ▁int ▁i ▁, ▁nl ▁; ▁FUNC _ TYPE ▁tp ▁; ▁char ▁* ▁prog ▁; ▁HEL PL IST _ CHOICE ▁o ▁; ▁prog ▁= ▁opt _ init ▁( ▁argc ▁, ▁argv ▁, ▁help _ options ▁) ▁; ▁while ▁( ▁( ▁o ▁= ▁opt _ next ▁( ▁) ▁) ▁!= ▁OPT _ EOF ▁) ▁{ ▁switch ▁( ▁o ▁) ▁{ ▁default ▁: ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"% s : Use - help for summary .\ n " ▁, ▁prog ▁) ▁; ▁return ▁1 ▁; ▁case ▁OPT _ HELP ▁: ▁opt _ help ▁( ▁help _ options ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁argc ▁= ▁opt _ num _ rest ▁( ▁) ▁; ▁if ▁( ▁argc ▁!= ▁0 ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Usage :% s \ n " ▁, ▁prog ▁) ▁; ▁return ▁1 ▁; ▁} ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"\ n Standard commands " ▁) ▁; ▁i ▁= ▁0 ▁; ▁tp ▁= ▁FT _ none ▁; ▁for ▁( ▁fp ▁= ▁functions ▁; ▁fp ▁-> ▁name ▁!= ▁NULL ▁; ▁fp ▁++ ▁) ▁{ ▁nl ▁= ▁0 ▁; ▁if ▁( ▁( ▁( ▁i ▁++ ▁) ▁% ▁COL UMNS ▁) ▁== ▁0 ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"\ n " ▁) ▁; ▁nl ▁= ▁1 ▁; ▁} ▁if ▁( ▁fp ▁-> ▁type ▁!= ▁tp ▁) ▁{ ▁tp ▁= ▁fp ▁-> ▁type ▁; ▁if ▁( ▁! ▁nl ▁) ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"\ n " ▁) ▁; ▁if ▁( ▁tp ▁== ▁FT _ md ▁) ▁{ ▁i ▁= ▁1 ▁; ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"\ n MessageDigest commands ( se et he ` dg st ' command form ore details )\ n " ▁) ▁; ▁} ▁else ▁if ▁( ▁tp ▁== ▁FT _ cipher ▁) ▁{ ▁i ▁= ▁1 ▁; ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"\ n Cipher commands ( se et he ` enc ' command form ore details )\ n " ▁) ▁; ▁} ▁} ▁BIO _ printf ▁( ▁bio _ err ▁, ▁FORMAT ▁, ▁fp ▁-> ▁name ▁) ▁; ▁} ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"\ n \ n " ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁void ▁ff _ rtp _ send _ data ▁( ▁AVFormatContext ▁* ▁s 1 ▁, ▁const ▁uint 8_ t ▁* ▁buf 1 ▁, ▁int ▁len ▁, ▁int ▁m ▁) ▁{ ▁RTP Mux Context ▁* ▁s ▁= ▁s 1 ▁-> ▁priv _ data ▁; ▁av _ d log ▁( ▁s 1 ▁, ▁" rtp _ send _ datas ize =% d \ n " ▁, ▁len ▁) ▁; ▁avio _ w 8 ▁( ▁s 1 ▁-> ▁pb ▁, ▁RTP _ VERSION ▁<< ▁6 ▁) ▁; ▁avio _ w 8 ▁( ▁s 1 ▁-> ▁pb ▁, ▁( ▁s ▁-> ▁payload _ type ▁& ▁0 x 7 f ▁) ▁| ▁( ▁( ▁m ▁& ▁0 x 01 ▁) ▁<< ▁7 ▁) ▁) ▁; ▁avio _ wb 16 ▁( ▁s 1 ▁-> ▁pb ▁, ▁s ▁-> ▁seq ▁) ▁; ▁avio _ wb 32 ▁( ▁s 1 ▁-> ▁pb ▁, ▁s ▁-> ▁timestamp ▁) ▁; ▁avio _ wb 32 ▁( ▁s 1 ▁-> ▁pb ▁, ▁s ▁-> ▁ss rc ▁) ▁; ▁avio _ write ▁( ▁s 1 ▁-> ▁pb ▁, ▁buf 1 ▁, ▁len ▁) ▁; ▁avio _ flush ▁( ▁s 1 ▁-> ▁pb ▁) ▁; ▁s ▁-> ▁seq ▁= ▁( ▁s ▁-> ▁seq ▁+ ▁1 ▁) ▁& ▁0 xffff ▁; ▁s ▁-> ▁octet _ count ▁+= ▁len ▁; ▁s ▁-> ▁packet _ count ▁++ ▁; ▁}	1
▁int ▁av _ image _ alloc ▁( ▁uint 8_ t ▁* ▁pointers ▁[ ▁4 ▁] ▁, ▁int ▁lines izes ▁[ ▁4 ▁] ▁, ▁int ▁w ▁, ▁int ▁h ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁int ▁align ▁) ▁{ ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁pix _ fmt ▁) ▁; ▁int ▁i ▁, ▁ret ▁; ▁uint 8_ t ▁* ▁buf ▁; ▁if ▁( ▁! ▁desc ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ check _ size ▁( ▁w ▁, ▁h ▁, ▁0 ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ fill _ lines izes ▁( ▁lines izes ▁, ▁pix _ fmt ▁, ▁align ▁> ▁7 ▁? ▁FF ALIGN ▁( ▁w ▁, ▁8 ▁) ▁: ▁w ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁lines izes ▁[ ▁i ▁] ▁= ▁FF ALIGN ▁( ▁lines izes ▁[ ▁i ▁] ▁, ▁align ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ fill _ pointers ▁( ▁pointers ▁, ▁pix _ fmt ▁, ▁h ▁, ▁NULL ▁, ▁lines izes ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁buf ▁= ▁av _ malloc ▁( ▁ret ▁+ ▁align ▁) ▁; ▁if ▁( ▁! ▁buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ fill _ pointers ▁( ▁pointers ▁, ▁pix _ fmt ▁, ▁h ▁, ▁buf ▁, ▁lines izes ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ free ▁( ▁buf ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PAL ▁|| ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PSE UD OP AL ▁) ▁avpriv _ set _ system atic _ pal 2 ▁( ▁( ▁uint 32_ t ▁* ▁) ▁pointers ▁[ ▁1 ▁] ▁, ▁pix _ fmt ▁) ▁; ▁if ▁( ▁( ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PAL ▁|| ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PSE UD OP AL ▁) ▁&& ▁pointers ▁[ ▁1 ▁] ▁- ▁pointers ▁[ ▁0 ▁] ▁> ▁lines izes ▁[ ▁0 ▁] ▁* ▁h ▁) ▁{ ▁memset ▁( ▁pointers ▁[ ▁0 ▁] ▁+ ▁lines izes ▁[ ▁0 ▁] ▁* ▁h ▁, ▁0 ▁, ▁pointers ▁[ ▁1 ▁] ▁- ▁pointers ▁[ ▁0 ▁] ▁- ▁lines izes ▁[ ▁0 ▁] ▁* ▁h ▁) ▁; ▁} ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁read _ key ▁( ▁void ▁) ▁{ ▁# if ▁HAVE _ TERM IOS _ H ▁int ▁n ▁= ▁1 ▁; ▁unsigned ▁char ▁ch ▁; ▁struct ▁timeval ▁tv ▁; ▁fd _ set ▁rf ds ▁; ▁FD _ ZERO ▁( ▁& ▁rf ds ▁) ▁; ▁FD _ SET ▁( ▁0 ▁, ▁& ▁rf ds ▁) ▁; ▁tv ▁. ▁tv _ sec ▁= ▁0 ▁; ▁tv ▁. ▁tv _ usec ▁= ▁0 ▁; ▁n ▁= ▁select ▁( ▁1 ▁, ▁& ▁rf ds ▁, ▁NULL ▁, ▁NULL ▁, ▁& ▁tv ▁) ▁; ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁n ▁= ▁read ▁( ▁0 ▁, ▁& ▁ch ▁, ▁1 ▁) ▁; ▁if ▁( ▁n ▁== ▁1 ▁) ▁return ▁ch ▁; ▁return ▁n ▁; ▁} ▁# elif ▁HAVE _ CON IO _ H ▁if ▁( ▁k bh it ▁( ▁) ▁) ▁return ▁( ▁get ch ▁( ▁) ▁) ▁; ▁# endif ▁return ▁-1 ▁; ▁}	1
▁static ▁int ▁mp sub _ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁const ▁char ▁* ▁ptr ▁= ▁p ▁-> ▁buf ▁; ▁const ▁char ▁* ▁ptr _ end ▁= ▁p ▁-> ▁buf ▁+ ▁p ▁-> ▁buf _ size ▁; ▁while ▁( ▁ptr ▁< ▁ptr _ end ▁) ▁{ ▁int ▁inc ▁; ▁if ▁( ▁! ▁memcmp ▁( ▁ptr ▁, ▁" FORMAT = TIME " ▁, ▁11 ▁) ▁) ▁return ▁AV PROBE _ SCORE _ EXTENSION ▁; ▁if ▁( ▁! ▁memcmp ▁( ▁ptr ▁, ▁" FORMAT =" ▁, ▁7 ▁) ▁) ▁return ▁AV PROBE _ SCORE _ EXTENSION ▁/ ▁3 ▁; ▁inc ▁= ▁ff _ sub title s _ next _ line ▁( ▁ptr ▁) ▁; ▁if ▁( ▁! ▁inc ▁) ▁break ▁; ▁ptr ▁+= ▁inc ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁BN _ num _ bits _ word ▁( ▁BN _ ULONG ▁l ▁) ▁{ ▁static ▁const ▁char ▁bits ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁4 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁6 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁7 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁8 ▁, ▁} ▁; ▁# if ▁defined ▁( ▁S IX TY _ FO UR _ BIT _ LONG ▁) ▁if ▁( ▁l ▁& ▁0 xffffffff 00000000 L ▁) ▁{ ▁if ▁( ▁l ▁& ▁0 xffff 000000000000 L ▁) ▁{ ▁if ▁( ▁l ▁& ▁0 xff 00000000000000 L ▁) ▁{ ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁56 ▁) ▁] ▁+ ▁56 ▁) ▁; ▁} ▁else ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁48 ▁) ▁] ▁+ ▁48 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁l ▁& ▁0 x 0000 ff 0000000000 L ▁) ▁{ ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁40 ▁) ▁] ▁+ ▁40 ▁) ▁; ▁} ▁else ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁32 ▁) ▁] ▁+ ▁32 ▁) ▁; ▁} ▁} ▁else ▁# else ▁# ifdef ▁S IX TY _ FO UR _ BIT ▁if ▁( ▁l ▁& ▁0 xffffffff 00000000 LL ▁) ▁{ ▁if ▁( ▁l ▁& ▁0 xffff 000000000000 LL ▁) ▁{ ▁if ▁( ▁l ▁& ▁0 xff 00000000000000 LL ▁) ▁{ ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁56 ▁) ▁] ▁+ ▁56 ▁) ▁; ▁} ▁else ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁48 ▁) ▁] ▁+ ▁48 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁l ▁& ▁0 x 0000 ff 0000000000 LL ▁) ▁{ ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁40 ▁) ▁] ▁+ ▁40 ▁) ▁; ▁} ▁else ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁32 ▁) ▁] ▁+ ▁32 ▁) ▁; ▁} ▁} ▁else ▁# endif ▁# endif ▁{ ▁# if ▁defined ▁( ▁TH IR TY _ TWO _ BIT ▁) ▁|| ▁defined ▁( ▁S IX TY _ FO UR _ BIT ▁) ▁|| ▁defined ▁( ▁S IX TY _ FO UR _ BIT _ LONG ▁) ▁if ▁( ▁l ▁& ▁0 xffff 0000 L ▁) ▁{ ▁if ▁( ▁l ▁& ▁0 xff 000000 L ▁) ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁24 L ▁) ▁] ▁+ ▁24 ▁) ▁; ▁else ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁16 L ▁) ▁] ▁+ ▁16 ▁) ▁; ▁} ▁else ▁# endif ▁{ ▁# if ▁defined ▁( ▁S IX TE EN _ BIT ▁) ▁|| ▁defined ▁( ▁TH IR TY _ TWO _ BIT ▁) ▁|| ▁defined ▁( ▁S IX TY _ FO UR _ BIT ▁) ▁|| ▁defined ▁( ▁S IX TY _ FO UR _ BIT _ LONG ▁) ▁if ▁( ▁l ▁& ▁0 xff 00 L ▁) ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁>> ▁8 ▁) ▁] ▁+ ▁8 ▁) ▁; ▁else ▁# endif ▁return ▁( ▁bits ▁[ ▁( ▁int ▁) ▁( ▁l ▁) ▁] ▁) ▁; ▁} ▁} ▁}	1
▁static ▁int ▁read _ header ▁( ▁Short en Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁ret ▁; ▁int ▁max nl pc ▁= ▁0 ▁; ▁if ▁( ▁get _ bits _ long ▁( ▁& ▁s ▁-> ▁gb ▁, ▁32 ▁) ▁!= ▁AV _ RB 32 ▁( ▁" aj kg " ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" missing short en magic ' aj kg '\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁lpc q offset ▁= ▁0 ▁; ▁s ▁-> ▁blocksize ▁= ▁DEFAULT _ BLOCK _ SIZE ▁; ▁s ▁-> ▁n mean ▁= ▁-1 ▁; ▁s ▁-> ▁version ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁s ▁-> ▁internal _ f type ▁= ▁get _ uint ▁( ▁s ▁, ▁TYP ESIZE ▁) ▁; ▁s ▁-> ▁channels ▁= ▁get _ uint ▁( ▁s ▁, ▁CHAN SIZE ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁channels ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" No channels report ed \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁s ▁-> ▁channels ▁> ▁MAX _ CHANNELS ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" t oom any channels :% d \ n " ▁, ▁s ▁-> ▁channels ▁) ▁; ▁s ▁-> ▁channels ▁= ▁0 ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁avctx ▁-> ▁channels ▁= ▁s ▁-> ▁channels ▁; ▁if ▁( ▁s ▁-> ▁version ▁> ▁0 ▁) ▁{ ▁int ▁skip _ bytes ▁; ▁unsigned ▁blocksize ▁; ▁blocksize ▁= ▁get _ uint ▁( ▁s ▁, ▁av _ log 2 ▁( ▁DEFAULT _ BLOCK _ SIZE ▁) ▁) ▁; ▁if ▁( ▁! ▁blocksize ▁|| ▁blocksize ▁> ▁MAX _ BLOCKSIZE ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid or unsupported blocksize :% d \ n " ▁, ▁blocksize ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁s ▁-> ▁blocksize ▁= ▁blocksize ▁; ▁max nl pc ▁= ▁get _ uint ▁( ▁s ▁, ▁LPC Q SIZE ▁) ▁; ▁if ▁( ▁max nl pc ▁> ▁1024 U ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" max nl pc is :% d \ n " ▁, ▁max nl pc ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁n mean ▁= ▁get _ uint ▁( ▁s ▁, ▁0 ▁) ▁; ▁skip _ bytes ▁= ▁get _ uint ▁( ▁s ▁, ▁NS K IP SIZE ▁) ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁skip _ bytes ▁> ▁get _ bits _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁/ ▁8 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid skip _ bytes :% d \ n " ▁, ▁skip _ bytes ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁skip _ bytes ▁; ▁i ▁++ ▁) ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁} ▁s ▁-> ▁n wrap ▁= ▁FF MAX ▁( ▁N WRAP ▁, ▁max nl pc ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁allocate _ buffers ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁init _ offset ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁s ▁-> ▁version ▁> ▁1 ▁) ▁s ▁-> ▁lpc q offset ▁= ▁V 2 LPC Q OFFSET ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁extradata _ size ▁> ▁0 ▁) ▁goto ▁end ▁; ▁if ▁( ▁get _ ur _ go lo mb _ short en ▁( ▁& ▁s ▁-> ▁gb ▁, ▁FN SIZE ▁) ▁!= ▁FN _ VER BA TIM ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" missing verb at im section at begin ning of stream \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁header _ size ▁= ▁get _ ur _ go lo mb _ short en ▁( ▁& ▁s ▁-> ▁gb ▁, ▁VER BA TIM _ CK SIZE _ SIZE ▁) ▁; ▁if ▁( ▁s ▁-> ▁header _ size ▁>= ▁OUT _ BUFFER _ SIZE ▁|| ▁s ▁-> ▁header _ size ▁< ▁CAN ON ICAL _ HEADER _ SIZE ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" header is wrong size :% d \ n " ▁, ▁s ▁-> ▁header _ size ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁header _ size ▁; ▁i ▁++ ▁) ▁s ▁-> ▁header ▁[ ▁i ▁] ▁= ▁( ▁char ▁) ▁get _ ur _ go lo mb _ short en ▁( ▁& ▁s ▁-> ▁gb ▁, ▁VER BA TIM _ BYTE _ SIZE ▁) ▁; ▁if ▁( ▁AV _ RL 32 ▁( ▁s ▁-> ▁header ▁) ▁== ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁decode _ wave _ header ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁header ▁, ▁s ▁-> ▁header _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁else ▁if ▁( ▁AV _ RL 32 ▁( ▁s ▁-> ▁header ▁) ▁== ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁decode _ a iff _ header ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁header ▁, ▁s ▁-> ▁header _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁else ▁{ ▁avpriv _ report _ missing _ feature ▁( ▁s ▁-> ▁avctx ▁, ▁" unsupported bit pack ing %" ▁PR IX 32 ▁, ▁AV _ RL 32 ▁( ▁s ▁-> ▁header ▁) ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁end ▁: ▁s ▁-> ▁cur _ chan ▁= ▁0 ▁; ▁s ▁-> ▁bit shift ▁= ▁0 ▁; ▁s ▁-> ▁got _ header ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁ENGINE ▁* ▁ENGINE _ new ▁( ▁void ▁) ▁{ ▁ENGINE ▁* ▁ret ▁; ▁ret ▁= ▁( ▁ENGINE ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁ENGINE ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁ENGINE err ▁( ▁ENGINE _ F _ ENGINE _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁memset ▁( ▁ret ▁, ▁0 ▁, ▁sizeof ▁( ▁ENGINE ▁) ▁) ▁; ▁ret ▁-> ▁struct _ ref ▁= ▁1 ▁; ▁return ▁ret ▁; ▁}	1
▁int ▁BIO _ accept ▁( ▁int ▁sock ▁, ▁char ▁* ▁* ▁addr ▁) ▁{ ▁int ▁ret ▁= ▁INVALID _ SOCKET ▁; ▁static ▁struct ▁sockaddr _ in ▁from ▁; ▁unsigned ▁long ▁l ▁; ▁unsigned ▁short ▁port ▁; ▁int ▁len ▁; ▁char ▁* ▁p ▁; ▁memset ▁( ▁( ▁char ▁* ▁) ▁& ▁from ▁, ▁0 ▁, ▁sizeof ▁( ▁from ▁) ▁) ▁; ▁len ▁= ▁sizeof ▁( ▁from ▁) ▁; ▁ret ▁= ▁accept ▁( ▁sock ▁, ▁( ▁struct ▁sockaddr ▁* ▁) ▁& ▁from ▁, ▁( ▁void ▁* ▁) ▁& ▁len ▁) ▁; ▁if ▁( ▁ret ▁== ▁INVALID _ SOCKET ▁) ▁{ ▁if ▁( ▁BIO _ sock _ should _ retry ▁( ▁ret ▁) ▁) ▁return ▁-2 ▁; ▁SYS err ▁( ▁SYS _ F _ ACCEPT ▁, ▁get _ last _ socket _ error ▁( ▁) ▁) ▁; ▁BIO err ▁( ▁BIO _ F _ BIO _ ACCEPT ▁, ▁BIO _ R _ ACCEPT _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁addr ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁l ▁= ▁ntohl ▁( ▁from ▁. ▁sin _ addr ▁. ▁s _ addr ▁) ▁; ▁port ▁= ▁ntohs ▁( ▁from ▁. ▁sin _ port ▁) ▁; ▁if ▁( ▁* ▁addr ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁p ▁= ▁OPENSSL _ malloc ▁( ▁24 ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁BIO err ▁( ▁BIO _ F _ BIO _ ACCEPT ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁end ▁; ▁} ▁* ▁addr ▁= ▁p ▁; ▁} ▁BIO _ snprintf ▁( ▁* ▁addr ▁, ▁24 ▁, ▁"% d .% d .% d .% d :% d " ▁, ▁( ▁unsigned ▁char ▁) ▁( ▁l ▁>> ▁24 L ▁) ▁& ▁0 xff ▁, ▁( ▁unsigned ▁char ▁) ▁( ▁l ▁>> ▁16 L ▁) ▁& ▁0 xff ▁, ▁( ▁unsigned ▁char ▁) ▁( ▁l ▁>> ▁8 L ▁) ▁& ▁0 xff ▁, ▁( ▁unsigned ▁char ▁) ▁( ▁l ▁) ▁& ▁0 xff ▁, ▁port ▁) ▁; ▁end ▁: ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁APP _ INFO ▁* ▁remove _ info ▁( ▁) ▁{ ▁APP _ INFO ▁tmp ▁; ▁APP _ INFO ▁* ▁ret ▁= ▁NULL ▁; ▁if ▁( ▁ami h ▁!= ▁NULL ▁) ▁{ ▁tmp ▁. ▁thread ▁= ▁CRYPTO _ thread _ id ▁( ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁( ▁APP _ INFO ▁* ▁) ▁lh _ delete ▁( ▁ami h ▁, ▁( ▁char ▁* ▁) ▁& ▁tmp ▁) ▁) ▁!= ▁NULL ▁) ▁{ ▁APP _ INFO ▁* ▁next ▁= ▁ret ▁-> ▁next ▁; ▁if ▁( ▁next ▁!= ▁NULL ▁) ▁{ ▁next ▁-> ▁references ▁++ ▁; ▁lh _ insert ▁( ▁ami h ▁, ▁( ▁char ▁* ▁) ▁next ▁) ▁; ▁} ▁# ifdef ▁L EV IT TE _ DEBUG ▁if ▁( ▁ret ▁-> ▁thread ▁!= ▁tmp ▁. ▁thread ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" remove _ info (): deleted info has other thread ID (% lu ) th ant he current thread (% lu ) !! !!\ n " ▁, ▁ret ▁-> ▁thread ▁, ▁tmp ▁. ▁thread ▁) ▁; ▁abort ▁( ▁) ▁; ▁} ▁# endif ▁if ▁( ▁-- ▁( ▁ret ▁-> ▁references ▁) ▁<= ▁0 ▁) ▁{ ▁ret ▁-> ▁next ▁= ▁NULL ▁; ▁if ▁( ▁next ▁!= ▁NULL ▁) ▁next ▁-> ▁references ▁-- ▁; ▁Free ▁( ▁ret ▁) ▁; ▁} ▁} ▁} ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁yuv 2 rgb _ write ▁( ▁uint 8_ t ▁* ▁_ dest ▁, ▁int ▁i ▁, ▁unsigned ▁Y 1 ▁, ▁unsigned ▁Y 2 ▁, ▁unsigned ▁A 1 ▁, ▁unsigned ▁A 2 ▁, ▁const ▁void ▁* ▁_ r ▁, ▁const ▁void ▁* ▁_ g ▁, ▁const ▁void ▁* ▁_ b ▁, ▁int ▁y ▁, ▁enum ▁PixelFormat ▁target ▁, ▁int ▁has Alpha ▁) ▁{ ▁if ▁( ▁target ▁== ▁PIX _ FMT _ ARGB ▁|| ▁target ▁== ▁PIX _ FMT _ RGBA ▁|| ▁target ▁== ▁PIX _ FMT _ AB GR ▁|| ▁target ▁== ▁PIX _ FMT _ B GRA ▁) ▁{ ▁uint 32_ t ▁* ▁dest ▁= ▁( ▁uint 32_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 32_ t ▁* ▁r ▁= ▁( ▁const ▁uint 32_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 32_ t ▁* ▁g ▁= ▁( ▁const ▁uint 32_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 32_ t ▁* ▁b ▁= ▁( ▁const ▁uint 32_ t ▁* ▁) ▁_ b ▁; ▁# if ▁CONFIG _ SMALL ▁int ▁sh ▁= ▁has Alpha ▁? ▁( ▁( ▁target ▁== ▁PIX _ FMT _ RGB 32_ 1 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 32_ 1 ▁) ▁? ▁0 ▁: ▁24 ▁) ▁: ▁0 ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁] ▁+ ▁( ▁has Alpha ▁? ▁A 1 ▁<< ▁sh ▁: ▁0 ▁) ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁] ▁+ ▁( ▁has Alpha ▁? ▁A 2 ▁<< ▁sh ▁: ▁0 ▁) ▁; ▁# else ▁if ▁( ▁has Alpha ▁) ▁{ ▁int ▁sh ▁= ▁( ▁target ▁== ▁PIX _ FMT _ RGB 32_ 1 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 32_ 1 ▁) ▁? ▁0 ▁: ▁24 ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁] ▁+ ▁( ▁A 1 ▁<< ▁sh ▁) ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁] ▁+ ▁( ▁A 2 ▁<< ▁sh ▁) ▁; ▁} ▁else ▁{ ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁] ▁; ▁} ▁# endif ▁} ▁else ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 24 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 24 ▁) ▁{ ▁uint 8_ t ▁* ▁dest ▁= ▁( ▁uint 8_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 8_ t ▁* ▁r ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 8_ t ▁* ▁g ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 8_ t ▁* ▁b ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ b ▁; ▁# define ▁r _ b ▁(( target == PIX _ FMT _ RGB 24 )? r : b ) ▁# define ▁b _ r ▁(( target == PIX _ FMT _ RGB 24 )? b : r ) ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁0 ▁] ▁= ▁r _ b ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁1 ▁] ▁= ▁g ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁2 ▁] ▁= ▁b _ r ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁3 ▁] ▁= ▁r _ b ▁[ ▁Y 2 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁4 ▁] ▁= ▁g ▁[ ▁Y 2 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁5 ▁] ▁= ▁b _ r ▁[ ▁Y 2 ▁] ▁; ▁# undef ▁r _ b ▁# undef ▁b _ r ▁} ▁else ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 565 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 565 ▁|| ▁target ▁== ▁PIX _ FMT _ RGB 555 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 555 ▁|| ▁target ▁== ▁PIX _ FMT _ RGB 444 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 444 ▁) ▁{ ▁uint 16_ t ▁* ▁dest ▁= ▁( ▁uint 16_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 16_ t ▁* ▁r ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 16_ t ▁* ▁g ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 16_ t ▁* ▁b ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁_ b ▁; ▁int ▁dr 1 ▁, ▁dg 1 ▁, ▁db 1 ▁, ▁dr 2 ▁, ▁dg 2 ▁, ▁db 2 ▁; ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 565 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 565 ▁) ▁{ ▁dr 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dg 1 ▁= ▁d ither _2 x 2_ 4 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁db 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dr 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dg 2 ▁= ▁d ither _2 x 2_ 4 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁db 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 555 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 555 ▁) ▁{ ▁dr 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dg 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁db 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dr 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dg 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁db 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁dr 1 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁0 ▁] ▁; ▁dg 1 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁1 ▁] ▁; ▁db 1 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁( ▁y ▁& ▁3 ▁) ▁ ^ ▁3 ▁] ▁[ ▁0 ▁] ▁; ▁dr 2 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁1 ▁] ▁; ▁dg 2 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁0 ▁] ▁; ▁db 2 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁( ▁y ▁& ▁3 ▁) ▁ ^ ▁3 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁+ ▁dr 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁+ ▁dg 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁+ ▁db 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁+ ▁dr 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁+ ▁dg 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁+ ▁db 2 ▁] ▁; ▁} ▁else ▁{ ▁uint 8_ t ▁* ▁dest ▁= ▁( ▁uint 8_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 8_ t ▁* ▁r ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 8_ t ▁* ▁g ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 8_ t ▁* ▁b ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ b ▁; ▁int ▁dr 1 ▁, ▁dg 1 ▁, ▁db 1 ▁, ▁dr 2 ▁, ▁dg 2 ▁, ▁db 2 ▁; ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 8 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 8 ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁const ▁d 64 ▁= ▁d ither _8 x 8_ 73 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁const ▁uint 8_ t ▁* ▁const ▁d 32 ▁= ▁d ither _8 x 8_ 32 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁dr 1 ▁= ▁dg 1 ▁= ▁d 32 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁db 1 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁dr 2 ▁= ▁dg 2 ▁= ▁d 32 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁db 2 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁} ▁else ▁{ ▁const ▁uint 8_ t ▁* ▁const ▁d 64 ▁= ▁d ither _8 x 8_ 73 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁const ▁uint 8_ t ▁* ▁const ▁d 128 ▁= ▁d ither _8 x 8_ 220 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁dr 1 ▁= ▁db 1 ▁= ▁d 128 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁dg 1 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁dr 2 ▁= ▁db 2 ▁= ▁d 128 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁dg 2 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁} ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 4 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 4 ▁) ▁{ ▁dest ▁[ ▁i ▁] ▁= ▁r ▁[ ▁Y 1 ▁+ ▁dr 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁+ ▁dg 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁+ ▁db 1 ▁] ▁+ ▁( ▁( ▁r ▁[ ▁Y 2 ▁+ ▁dr 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁+ ▁dg 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁+ ▁db 2 ▁] ▁) ▁<< ▁4 ▁) ▁; ▁} ▁else ▁{ ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁+ ▁dr 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁+ ▁dg 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁+ ▁db 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁+ ▁dr 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁+ ▁dg 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁+ ▁db 2 ▁] ▁; ▁} ▁} ▁}	1
▁static ▁int ▁as f _ read _ frame _ header ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁) ▁{ ▁ASF Context ▁* ▁as f ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁rsize ▁= ▁1 ▁; ▁int ▁num ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁int 64_ t ▁ts 0 ▁, ▁ts 1 ▁; ▁as f ▁-> ▁packet _ segments ▁-- ▁; ▁as f ▁-> ▁packet _ key _ frame ▁= ▁num ▁>> ▁7 ▁; ▁as f ▁-> ▁stream _ index ▁= ▁as f ▁-> ▁as fid 2 avid ▁[ ▁num ▁& ▁0 x 7 f ▁] ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ property ▁>> ▁4 ▁, ▁as f ▁-> ▁packet _ seq ▁, ▁0 ▁) ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ property ▁>> ▁2 ▁, ▁as f ▁-> ▁packet _ frag _ offset ▁, ▁0 ▁) ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ property ▁, ▁as f ▁-> ▁packet _ rep lic _ size ▁, ▁0 ▁) ▁; ▁if ▁( ▁as f ▁-> ▁packet _ rep lic _ size ▁>= ▁8 ▁) ▁{ ▁as f ▁-> ▁packet _ obj _ size ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁as f ▁-> ▁packet _ obj _ size ▁>= ▁( ▁1 ▁<< ▁24 ▁) ▁|| ▁as f ▁-> ▁packet _ obj _ size ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" packet _ obj _ size invalid \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁as f ▁-> ▁packet _ frag _ timestamp ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁as f ▁-> ▁packet _ rep lic _ size ▁>= ▁8 ▁+ ▁38 ▁+ ▁4 ▁) ▁{ ▁avio _ skip ▁( ▁pb ▁, ▁10 ▁) ▁; ▁ts 0 ▁= ▁avio _ rl 64 ▁( ▁pb ▁) ▁; ▁ts 1 ▁= ▁avio _ rl 64 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁12 ▁) ▁; ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁as f ▁-> ▁packet _ rep lic _ size ▁- ▁8 ▁- ▁38 ▁- ▁4 ▁) ▁; ▁if ▁( ▁ts 0 ▁!= ▁-1 ▁) ▁as f ▁-> ▁packet _ frag _ timestamp ▁= ▁ts 0 ▁/ ▁10000 ▁; ▁else ▁as f ▁-> ▁packet _ frag _ timestamp ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁else ▁avio _ skip ▁( ▁pb ▁, ▁as f ▁-> ▁packet _ rep lic _ size ▁- ▁8 ▁) ▁; ▁rsize ▁+= ▁as f ▁-> ▁packet _ rep lic _ size ▁; ▁} ▁else ▁if ▁( ▁as f ▁-> ▁packet _ rep lic _ size ▁== ▁1 ▁) ▁{ ▁as f ▁-> ▁packet _ time _ start ▁= ▁as f ▁-> ▁packet _ frag _ offset ▁; ▁as f ▁-> ▁packet _ frag _ offset ▁= ▁0 ▁; ▁as f ▁-> ▁packet _ frag _ timestamp ▁= ▁as f ▁-> ▁packet _ timestamp ▁; ▁as f ▁-> ▁packet _ time _ delta ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁rsize ▁++ ▁; ▁} ▁else ▁if ▁( ▁as f ▁-> ▁packet _ rep lic _ size ▁!= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" unexpected packet _ rep lic _ sizeof % d \ n " ▁, ▁as f ▁-> ▁packet _ rep lic _ size ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁as f ▁-> ▁packet _ flags ▁& ▁0 x 01 ▁) ▁{ ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ segs iz etype ▁>> ▁6 ▁, ▁as f ▁-> ▁packet _ frag _ size ▁, ▁0 ▁) ▁; ▁if ▁( ▁as f ▁-> ▁packet _ frag _ size ▁> ▁as f ▁-> ▁packet _ size _ left ▁- ▁rsize ▁) ▁{ ▁if ▁( ▁as f ▁-> ▁packet _ frag _ size ▁> ▁as f ▁-> ▁packet _ size _ left ▁- ▁rsize ▁+ ▁as f ▁-> ▁packet _ pad size ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" packet _ frag _ size is invalid (% d -% d )\ n " ▁, ▁as f ▁-> ▁packet _ size _ left ▁, ▁rsize ▁) ▁; ▁return ▁-1 ▁; ▁} ▁else ▁{ ▁int ▁diff ▁= ▁as f ▁-> ▁packet _ frag _ size ▁- ▁( ▁as f ▁-> ▁packet _ size _ left ▁- ▁rsize ▁) ▁; ▁as f ▁-> ▁packet _ size _ left ▁+= ▁diff ▁; ▁as f ▁-> ▁packet _ pad size ▁-= ▁diff ▁; ▁} ▁} ▁} ▁else ▁{ ▁as f ▁-> ▁packet _ frag _ size ▁= ▁as f ▁-> ▁packet _ size _ left ▁- ▁rsize ▁; ▁} ▁if ▁( ▁as f ▁-> ▁packet _ rep lic _ size ▁== ▁1 ▁) ▁{ ▁as f ▁-> ▁packet _ multi _ size ▁= ▁as f ▁-> ▁packet _ frag _ size ▁; ▁if ▁( ▁as f ▁-> ▁packet _ multi _ size ▁> ▁as f ▁-> ▁packet _ size _ left ▁) ▁return ▁-1 ▁; ▁} ▁as f ▁-> ▁packet _ size _ left ▁-= ▁rsize ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁read _ frame _ internal ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁AVStream ▁* ▁st ▁; ▁int ▁len ▁, ▁ret ▁, ▁i ▁; ▁av _ init _ packet ▁( ▁pkt ▁) ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁st ▁= ▁s ▁-> ▁cur _ st ▁; ▁if ▁( ▁st ▁) ▁{ ▁if ▁( ▁! ▁st ▁-> ▁need _ parsing ▁|| ▁! ▁st ▁-> ▁parser ▁) ▁{ ▁* ▁pkt ▁= ▁st ▁-> ▁cur _ pkt ▁; ▁st ▁-> ▁cur _ pkt ▁. ▁data ▁= ▁NULL ▁; ▁compute _ pkt _ fields ▁( ▁s ▁, ▁st ▁, ▁NULL ▁, ▁pkt ▁) ▁; ▁s ▁-> ▁cur _ st ▁= ▁NULL ▁; ▁if ▁( ▁( ▁s ▁-> ▁if orm at ▁-> ▁flags ▁& ▁AV FMT _ GENERIC _ INDEX ▁) ▁&& ▁( ▁pkt ▁-> ▁flags ▁& ▁AV _ PKT _ FLAG _ KEY ▁) ▁&& ▁pkt ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁ff _ reduce _ index ▁( ▁s ▁, ▁st ▁-> ▁index ▁) ▁; ▁av _ add _ index _ entry ▁( ▁st ▁, ▁pkt ▁-> ▁pos ▁, ▁pkt ▁-> ▁dts ▁, ▁0 ▁, ▁0 ▁, ▁AV INDEX _ KEY FRAME ▁) ▁; ▁} ▁break ▁; ▁} ▁else ▁if ▁( ▁st ▁-> ▁cur _ len ▁> ▁0 ▁&& ▁st ▁-> ▁discard ▁< ▁AV DISCARD _ ALL ▁) ▁{ ▁len ▁= ▁av _ parser _ parse 2 ▁( ▁st ▁-> ▁parser ▁, ▁st ▁-> ▁codec ▁, ▁& ▁pkt ▁-> ▁data ▁, ▁& ▁pkt ▁-> ▁size ▁, ▁st ▁-> ▁cur _ ptr ▁, ▁st ▁-> ▁cur _ len ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁pts ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁dts ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁pos ▁) ▁; ▁st ▁-> ▁cur _ pkt ▁. ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁st ▁-> ▁cur _ pkt ▁. ▁dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁st ▁-> ▁cur _ ptr ▁+= ▁len ▁; ▁st ▁-> ▁cur _ len ▁-= ▁len ▁; ▁if ▁( ▁pkt ▁-> ▁size ▁) ▁{ ▁got _ packet ▁: ▁pkt ▁-> ▁duration ▁= ▁0 ▁; ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁{ ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁> ▁0 ▁) ▁{ ▁pkt ▁-> ▁duration ▁= ▁av _ re scale _ q _ rnd ▁( ▁st ▁-> ▁parser ▁-> ▁duration ▁, ▁( ▁AVR ational ▁) ▁{ ▁1 ▁, ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁} ▁, ▁st ▁-> ▁time _ base ▁, ▁AV _ ROUND _ DOWN ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁num ▁!= ▁0 ▁&& ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁den ▁!= ▁0 ▁) ▁{ ▁pkt ▁-> ▁duration ▁= ▁av _ re scale _ q _ rnd ▁( ▁st ▁-> ▁parser ▁-> ▁duration ▁, ▁st ▁-> ▁codec ▁-> ▁time _ base ▁, ▁st ▁-> ▁time _ base ▁, ▁AV _ ROUND _ DOWN ▁) ▁; ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁st ▁-> ▁index ▁; ▁pkt ▁-> ▁pts ▁= ▁st ▁-> ▁parser ▁-> ▁pts ▁; ▁pkt ▁-> ▁dts ▁= ▁st ▁-> ▁parser ▁-> ▁dts ▁; ▁pkt ▁-> ▁pos ▁= ▁st ▁-> ▁parser ▁-> ▁pos ▁; ▁if ▁( ▁st ▁-> ▁parser ▁-> ▁key _ frame ▁== ▁1 ▁|| ▁( ▁st ▁-> ▁parser ▁-> ▁key _ frame ▁== ▁-1 ▁&& ▁st ▁-> ▁parser ▁-> ▁pict _ type ▁== ▁AV _ PICTURE _ TYPE _ I ▁) ▁) ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ KEY ▁; ▁if ▁( ▁pkt ▁-> ▁data ▁== ▁st ▁-> ▁cur _ pkt ▁. ▁data ▁&& ▁pkt ▁-> ▁size ▁== ▁st ▁-> ▁cur _ pkt ▁. ▁size ▁) ▁{ ▁s ▁-> ▁cur _ st ▁= ▁NULL ▁; ▁pkt ▁-> ▁destruct ▁= ▁st ▁-> ▁cur _ pkt ▁. ▁destruct ▁; ▁st ▁-> ▁cur _ pkt ▁. ▁destruct ▁= ▁NULL ▁; ▁st ▁-> ▁cur _ pkt ▁. ▁data ▁= ▁NULL ▁; ▁assert ▁( ▁st ▁-> ▁cur _ len ▁== ▁0 ▁) ▁; ▁} ▁else ▁{ ▁pkt ▁-> ▁destruct ▁= ▁NULL ▁; ▁} ▁compute _ pkt _ fields ▁( ▁s ▁, ▁st ▁, ▁st ▁-> ▁parser ▁, ▁pkt ▁) ▁; ▁if ▁( ▁( ▁s ▁-> ▁if orm at ▁-> ▁flags ▁& ▁AV FMT _ GENERIC _ INDEX ▁) ▁&& ▁pkt ▁-> ▁flags ▁& ▁AV _ PKT _ FLAG _ KEY ▁) ▁{ ▁ff _ reduce _ index ▁( ▁s ▁, ▁st ▁-> ▁index ▁) ▁; ▁av _ add _ index _ entry ▁( ▁st ▁, ▁st ▁-> ▁parser ▁-> ▁frame _ offset ▁, ▁pkt ▁-> ▁dts ▁, ▁0 ▁, ▁0 ▁, ▁AV INDEX _ KEY FRAME ▁) ▁; ▁} ▁break ▁; ▁} ▁} ▁else ▁{ ▁av _ free _ packet ▁( ▁& ▁st ▁-> ▁cur _ pkt ▁) ▁; ▁s ▁-> ▁cur _ st ▁= ▁NULL ▁; ▁} ▁} ▁else ▁{ ▁AVPacket ▁cur _ pkt ▁; ▁ret ▁= ▁av _ read _ packet ▁( ▁s ▁, ▁& ▁cur _ pkt ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ret ▁== ▁AVERROR ▁( ▁EAGAIN ▁) ▁) ▁return ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁st ▁-> ▁parser ▁&& ▁st ▁-> ▁need _ parsing ▁) ▁{ ▁av _ parser _ parse 2 ▁( ▁st ▁-> ▁parser ▁, ▁st ▁-> ▁codec ▁, ▁& ▁pkt ▁-> ▁data ▁, ▁& ▁pkt ▁-> ▁size ▁, ▁NULL ▁, ▁0 ▁, ▁AV _ NOP TS _ VALUE ▁, ▁AV _ NOP TS _ VALUE ▁, ▁AV _ NOP TS _ VALUE ▁) ▁; ▁if ▁( ▁pkt ▁-> ▁size ▁) ▁goto ▁got _ packet ▁; ▁} ▁} ▁return ▁ret ▁; ▁} ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁cur _ pkt ▁. ▁stream _ index ▁] ▁; ▁st ▁-> ▁cur _ pkt ▁= ▁cur _ pkt ▁; ▁if ▁( ▁st ▁-> ▁cur _ pkt ▁. ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁st ▁-> ▁cur _ pkt ▁. ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁st ▁-> ▁cur _ pkt ▁. ▁pts ▁< ▁st ▁-> ▁cur _ pkt ▁. ▁dts ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Invalid timestamp sstream =% d , pts =% " ▁PRId 64 ▁", dts =% " ▁PRId 64 ▁", size =% d \ n " ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁stream _ index ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁pts ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁dts ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁size ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁debug ▁& ▁FF _ F DEBUG _ TS ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" av _ read _ packet stream =% d , pts =% " ▁PRId 64 ▁", dts =% " ▁PRId 64 ▁", size =% d , duration =% d , flags =% d \ n " ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁stream _ index ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁pts ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁dts ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁size ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁duration ▁, ▁st ▁-> ▁cur _ pkt ▁. ▁flags ▁) ▁; ▁s ▁-> ▁cur _ st ▁= ▁st ▁; ▁st ▁-> ▁cur _ ptr ▁= ▁st ▁-> ▁cur _ pkt ▁. ▁data ▁; ▁st ▁-> ▁cur _ len ▁= ▁st ▁-> ▁cur _ pkt ▁. ▁size ▁; ▁if ▁( ▁st ▁-> ▁need _ parsing ▁&& ▁! ▁st ▁-> ▁parser ▁&& ▁! ▁( ▁s ▁-> ▁flags ▁& ▁AV FMT _ FLAG _ NOP ARSE ▁) ▁) ▁{ ▁st ▁-> ▁parser ▁= ▁av _ parser _ init ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁) ▁; ▁if ▁( ▁! ▁st ▁-> ▁parser ▁) ▁{ ▁st ▁-> ▁need _ parsing ▁= ▁AV STREAM _ PARSE _ NONE ▁; ▁} ▁else ▁if ▁( ▁st ▁-> ▁need _ parsing ▁== ▁AV STREAM _ PARSE _ HEADERS ▁) ▁{ ▁st ▁-> ▁parser ▁-> ▁flags ▁|= ▁PARSER _ FLAG _ COMPLETE _ FRAMES ▁; ▁} ▁else ▁if ▁( ▁st ▁-> ▁need _ parsing ▁== ▁AV STREAM _ PARSE _ FULL _ ONCE ▁) ▁{ ▁st ▁-> ▁parser ▁-> ▁flags ▁|= ▁PARSER _ FLAG _ ONCE ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁s ▁-> ▁debug ▁& ▁FF _ F DEBUG _ TS ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" read _ frame _ internal stream =% d , pts =% " ▁PRId 64 ▁", dts =% " ▁PRId 64 ▁", size =% d , duration =% d , flags =% d \ n " ▁, ▁pkt ▁-> ▁stream _ index ▁, ▁pkt ▁-> ▁pts ▁, ▁pkt ▁-> ▁dts ▁, ▁pkt ▁-> ▁size ▁, ▁pkt ▁-> ▁duration ▁, ▁pkt ▁-> ▁flags ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁Soft Float ▁sb r _ sum _ square _ c ▁( ▁int ▁( ▁* ▁x ▁) ▁[ ▁2 ▁] ▁, ▁int ▁n ▁) ▁{ ▁Soft Float ▁ret ▁; ▁int 64_ t ▁accu ▁= ▁0 ▁; ▁int ▁i ▁, ▁nz ▁, ▁round ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁av _ assert 2 ▁( ▁FF ABS ▁( ▁x ▁[ ▁i ▁+ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁>> ▁29 ▁== ▁0 ▁) ▁; ▁accu ▁+= ▁( ▁int 64_ t ▁) ▁x ▁[ ▁i ▁+ ▁0 ▁] ▁[ ▁0 ▁] ▁* ▁x ▁[ ▁i ▁+ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁av _ assert 2 ▁( ▁FF ABS ▁( ▁x ▁[ ▁i ▁+ ▁0 ▁] ▁[ ▁1 ▁] ▁) ▁>> ▁29 ▁== ▁0 ▁) ▁; ▁accu ▁+= ▁( ▁int 64_ t ▁) ▁x ▁[ ▁i ▁+ ▁0 ▁] ▁[ ▁1 ▁] ▁* ▁x ▁[ ▁i ▁+ ▁0 ▁] ▁[ ▁1 ▁] ▁; ▁av _ assert 2 ▁( ▁FF ABS ▁( ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁>> ▁29 ▁== ▁0 ▁) ▁; ▁accu ▁+= ▁( ▁int 64_ t ▁) ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁* ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁av _ assert 2 ▁( ▁FF ABS ▁( ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁>> ▁29 ▁== ▁0 ▁) ▁; ▁accu ▁+= ▁( ▁int 64_ t ▁) ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁1 ▁] ▁* ▁x ▁[ ▁i ▁+ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁i ▁= ▁( ▁int ▁) ▁( ▁accu ▁>> ▁32 ▁) ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁nz ▁= ▁1 ▁; ▁} ▁else ▁{ ▁nz ▁= ▁0 ▁; ▁while ▁( ▁FF ABS ▁( ▁i ▁) ▁< ▁0 x 40000000 ▁) ▁{ ▁i ▁<<= ▁1 ▁; ▁nz ▁++ ▁; ▁} ▁nz ▁= ▁32 ▁- ▁nz ▁; ▁} ▁round ▁= ▁1 ▁<< ▁( ▁nz ▁- ▁1 ▁) ▁; ▁i ▁= ▁( ▁int ▁) ▁( ▁( ▁accu ▁+ ▁round ▁) ▁>> ▁nz ▁) ▁; ▁i ▁>>= ▁1 ▁; ▁ret ▁= ▁av _ int 2 sf ▁( ▁i ▁, ▁15 ▁- ▁nz ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁void ▁PEM _ de k _ info ▁( ▁char ▁* ▁buf ▁, ▁const ▁char ▁* ▁type ▁, ▁int ▁len ▁, ▁char ▁* ▁str ▁) ▁{ ▁static ▁const ▁unsigned ▁char ▁map ▁[ ▁17 ▁] ▁= ▁"0123456789 ABCDEF " ▁; ▁long ▁i ▁; ▁int ▁j ▁; ▁OPENSSL _ strl cat ▁( ▁buf ▁, ▁" DE K - Info :" ▁, ▁PEM _ BUFSIZE ▁) ▁; ▁OPENSSL _ strl cat ▁( ▁buf ▁, ▁type ▁, ▁PEM _ BUFSIZE ▁) ▁; ▁OPENSSL _ strl cat ▁( ▁buf ▁, ▁"," ▁, ▁PEM _ BUFSIZE ▁) ▁; ▁j ▁= ▁strlen ▁( ▁buf ▁) ▁; ▁if ▁( ▁j ▁+ ▁( ▁len ▁* ▁2 ▁) ▁+ ▁1 ▁> ▁PEM _ BUFSIZE ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁] ▁= ▁map ▁[ ▁( ▁str ▁[ ▁i ▁] ▁>> ▁4 ▁) ▁& ▁0 x 0 f ▁] ▁; ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁map ▁[ ▁( ▁str ▁[ ▁i ▁] ▁) ▁& ▁0 x 0 f ▁] ▁; ▁} ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁] ▁= ▁' ▁\ n ▁' ▁; ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁}	0
▁static ▁int ▁Log L uv Encode Tile ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 8 ▁* ▁bp ▁, ▁tm size _ t ▁cc ▁, ▁uint 16 ▁s ▁) ▁{ ▁tm size _ t ▁row len ▁= ▁TIFF Tile Row Size ▁( ▁tif ▁) ▁; ▁if ▁( ▁row len ▁== ▁0 ▁) ▁return ▁0 ▁; ▁assert ▁( ▁cc ▁% ▁row len ▁== ▁0 ▁) ▁; ▁while ▁( ▁cc ▁&& ▁( ▁* ▁tif ▁-> ▁tif _ encoder ow ▁) ▁( ▁tif ▁, ▁bp ▁, ▁row len ▁, ▁s ▁) ▁== ▁1 ▁) ▁{ ▁bp ▁+= ▁row len ▁; ▁cc ▁-= ▁row len ▁; ▁} ▁return ▁( ▁cc ▁== ▁0 ▁) ▁; ▁}	1
▁static ▁int ▁res ample ▁( ▁Res ample Context ▁* ▁c ▁, ▁int 16_ t ▁* ▁dst ▁, ▁const ▁int 16_ t ▁* ▁src ▁, ▁int ▁* ▁consumed ▁, ▁int ▁src _ size ▁, ▁int ▁dst _ size ▁, ▁int ▁update _ ctx ▁) ▁{ ▁int ▁dst _ index ▁, ▁i ▁; ▁int ▁index ▁= ▁c ▁-> ▁index ▁; ▁int ▁frac ▁= ▁c ▁-> ▁frac ▁; ▁int ▁dst _ incr _ frac ▁= ▁c ▁-> ▁dst _ incr ▁% ▁c ▁-> ▁src _ incr ▁; ▁int ▁dst _ incr ▁= ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁int ▁comp ensation _ distance ▁= ▁c ▁-> ▁comp ensation _ distance ▁; ▁if ▁( ▁! ▁dst ▁!= ▁! ▁src ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁comp ensation _ distance ▁== ▁0 ▁&& ▁c ▁-> ▁filter _ length ▁== ▁1 ▁&& ▁c ▁-> ▁phase _ shift ▁== ▁0 ▁) ▁{ ▁int 64_ t ▁index 2 ▁= ▁( ▁( ▁int 64_ t ▁) ▁index ▁) ▁<< ▁32 ▁; ▁int 64_ t ▁incr ▁= ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁dst _ size ▁= ▁FF MIN ▁( ▁dst _ size ▁, ▁( ▁src _ size ▁- ▁1 ▁- ▁index ▁) ▁* ▁( ▁int 64_ t ▁) ▁c ▁-> ▁src _ incr ▁/ ▁c ▁-> ▁dst _ incr ▁) ▁; ▁if ▁( ▁dst ▁) ▁{ ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁dst _ size ▁; ▁dst _ index ▁++ ▁) ▁{ ▁dst ▁[ ▁dst _ index ▁] ▁= ▁src ▁[ ▁index 2 ▁>> ▁32 ▁] ▁; ▁index 2 ▁+= ▁incr ▁; ▁} ▁} ▁else ▁{ ▁dst _ index ▁= ▁dst _ size ▁; ▁} ▁index ▁+= ▁dst _ index ▁* ▁dst _ incr ▁; ▁index ▁+= ▁( ▁frac ▁+ ▁dst _ index ▁* ▁( ▁int 64_ t ▁) ▁dst _ incr _ frac ▁) ▁/ ▁c ▁-> ▁src _ incr ▁; ▁frac ▁= ▁( ▁frac ▁+ ▁dst _ index ▁* ▁( ▁int 64_ t ▁) ▁dst _ incr _ frac ▁) ▁% ▁c ▁-> ▁src _ incr ▁; ▁} ▁else ▁{ ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁dst _ size ▁; ▁dst _ index ▁++ ▁) ▁{ ▁F ELEM ▁* ▁filter ▁= ▁c ▁-> ▁filter _ bank ▁+ ▁c ▁-> ▁filter _ length ▁* ▁( ▁index ▁& ▁c ▁-> ▁phase _ mask ▁) ▁; ▁int ▁sample _ index ▁= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁if ▁( ▁! ▁dst ▁&& ▁( ▁sample _ index ▁+ ▁c ▁-> ▁filter _ length ▁> ▁src _ size ▁|| ▁- ▁sample _ index ▁>= ▁src _ size ▁) ▁) ▁break ▁; ▁if ▁( ▁dst ▁) ▁{ ▁F ELEM 2 ▁val ▁= ▁0 ▁; ▁if ▁( ▁sample _ index ▁< ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁val ▁+= ▁src ▁[ ▁FF ABS ▁( ▁sample _ index ▁+ ▁i ▁) ▁% ▁src _ size ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁} ▁else ▁if ▁( ▁sample _ index ▁+ ▁c ▁-> ▁filter _ length ▁> ▁src _ size ▁) ▁{ ▁break ▁; ▁} ▁else ▁if ▁( ▁c ▁-> ▁linear ▁) ▁{ ▁F ELEM 2 ▁v 2 ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁abs ▁( ▁sample _ index ▁+ ▁i ▁) ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁v 2 ▁+= ▁src ▁[ ▁abs ▁( ▁sample _ index ▁+ ▁i ▁) ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁+ ▁c ▁-> ▁filter _ length ▁] ▁; ▁} ▁val ▁+= ▁( ▁v 2 ▁- ▁val ▁) ▁* ▁( ▁F ELE ML ▁) ▁frac ▁/ ▁c ▁-> ▁src _ incr ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁} ▁# ifdef ▁CONFIG _ RES AMPLE _ FLT ▁dst ▁[ ▁dst _ index ▁] ▁= ▁av _ clip _ int 16 ▁( ▁l rintf ▁( ▁val ▁) ▁) ▁; ▁# else ▁val ▁= ▁( ▁val ▁+ ▁( ▁1 ▁<< ▁( ▁FILTER _ SHIFT ▁- ▁1 ▁) ▁) ▁) ▁>> ▁FILTER _ SHIFT ▁; ▁dst ▁[ ▁dst _ index ▁] ▁= ▁av _ clip _ int 16 ▁( ▁val ▁) ▁; ▁# endif ▁} ▁frac ▁+= ▁dst _ incr _ frac ▁; ▁index ▁+= ▁dst _ incr ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁if ▁( ▁dst _ index ▁+ ▁1 ▁== ▁comp ensation _ distance ▁) ▁{ ▁comp ensation _ distance ▁= ▁0 ▁; ▁dst _ incr _ frac ▁= ▁c ▁-> ▁ideal _ dst _ incr ▁% ▁c ▁-> ▁src _ incr ▁; ▁dst _ incr ▁= ▁c ▁-> ▁ideal _ dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁} ▁} ▁} ▁if ▁( ▁consumed ▁) ▁* ▁consumed ▁= ▁FF MAX ▁( ▁index ▁, ▁0 ▁) ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁if ▁( ▁update _ ctx ▁) ▁{ ▁if ▁( ▁index ▁>= ▁0 ▁) ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁if ▁( ▁comp ensation _ distance ▁) ▁{ ▁comp ensation _ distance ▁-= ▁dst _ index ▁; ▁if ▁( ▁comp ensation _ distance ▁<= ▁0 ▁) ▁return ▁AVERROR _ BUG ▁; ▁} ▁c ▁-> ▁frac ▁= ▁frac ▁; ▁c ▁-> ▁index ▁= ▁index ▁; ▁c ▁-> ▁dst _ incr ▁= ▁dst _ incr _ frac ▁+ ▁c ▁-> ▁src _ incr ▁* ▁dst _ incr ▁; ▁c ▁-> ▁comp ensation _ distance ▁= ▁comp ensation _ distance ▁; ▁} ▁return ▁dst _ index ▁; ▁}	1
▁int ▁av _ get _ packet ▁( ▁AVIO Context ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁size ▁) ▁{ ▁int ▁ret ▁; ▁if ▁( ▁s ▁-> ▁maxsize ▁> ▁0 ▁) ▁{ ▁int 64_ t ▁remaining ▁= ▁s ▁-> ▁maxsize ▁- ▁avio _ tell ▁( ▁s ▁) ▁; ▁if ▁( ▁remaining ▁>= ▁0 ▁) ▁size ▁= ▁FF MIN ▁( ▁size ▁, ▁remaining ▁) ▁; ▁} ▁ret ▁= ▁av _ new _ packet ▁( ▁pkt ▁, ▁size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁pkt ▁-> ▁pos ▁= ▁avio _ tell ▁( ▁s ▁) ▁; ▁ret ▁= ▁avio _ read ▁( ▁s ▁, ▁pkt ▁-> ▁data ▁, ▁size ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁) ▁av _ free _ packet ▁( ▁pkt ▁) ▁; ▁else ▁av _ shrink _ packet ▁( ▁pkt ▁, ▁ret ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int 64_ t ▁mk v _ write _ seek head ▁( ▁AVIO Context ▁* ▁pb ▁, ▁mk v _ seek head ▁* ▁seek head ▁) ▁{ ▁eb ml _ master ▁met ase ek ▁, ▁seek entry ▁; ▁int 64_ t ▁current pos ▁; ▁int ▁i ▁; ▁current pos ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁if ▁( ▁seek head ▁-> ▁reserved _ size ▁> ▁0 ▁) ▁{ ▁if ▁( ▁avio _ seek ▁( ▁pb ▁, ▁seek head ▁-> ▁file pos ▁, ▁SEEK _ SET ▁) ▁< ▁0 ▁) ▁{ ▁current pos ▁= ▁-1 ▁; ▁goto ▁fail ▁; ▁} ▁} ▁met ase ek ▁= ▁start _ eb ml _ master ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ SEEK HEAD ▁, ▁seek head ▁-> ▁reserved _ size ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁seek head ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁mk v _ seek head _ entry ▁* ▁entry ▁= ▁& ▁seek head ▁-> ▁entries ▁[ ▁i ▁] ▁; ▁seek entry ▁= ▁start _ eb ml _ master ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ SEEK ENTRY ▁, ▁MAX _ SEEK ENTRY _ SIZE ▁) ▁; ▁put _ eb ml _ id ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ SEEK ID ▁) ▁; ▁put _ eb ml _ num ▁( ▁pb ▁, ▁eb ml _ id _ size ▁( ▁entry ▁-> ▁element id ▁) ▁, ▁0 ▁) ▁; ▁put _ eb ml _ id ▁( ▁pb ▁, ▁entry ▁-> ▁element id ▁) ▁; ▁put _ eb ml _ uint ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ SEEK POSITION ▁, ▁entry ▁-> ▁segment pos ▁) ▁; ▁end _ eb ml _ master ▁( ▁pb ▁, ▁seek entry ▁) ▁; ▁} ▁end _ eb ml _ master ▁( ▁pb ▁, ▁met ase ek ▁) ▁; ▁if ▁( ▁seek head ▁-> ▁reserved _ size ▁> ▁0 ▁) ▁{ ▁uint 64_ t ▁remaining ▁= ▁seek head ▁-> ▁file pos ▁+ ▁seek head ▁-> ▁reserved _ size ▁- ▁avio _ tell ▁( ▁pb ▁) ▁; ▁put _ eb ml _ void ▁( ▁pb ▁, ▁remaining ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁current pos ▁, ▁SEEK _ SET ▁) ▁; ▁current pos ▁= ▁seek head ▁-> ▁file pos ▁; ▁} ▁fail ▁: ▁av _ freep ▁( ▁& ▁seek head ▁-> ▁entries ▁) ▁; ▁av _ free ▁( ▁seek head ▁) ▁; ▁return ▁current pos ▁; ▁}	1
▁static ▁void ▁encode _ cb lk ▁( ▁J peg 2000 Encoder Context ▁* ▁s ▁, ▁J peg 2000 T 1 Context ▁* ▁t 1 ▁, ▁J peg 2000 C blk ▁* ▁cb lk ▁, ▁J peg 2000 Tile ▁* ▁tile ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁band pos ▁, ▁int ▁lev ▁) ▁{ ▁int ▁pass _ t ▁= ▁2 ▁, ▁pass no ▁, ▁x ▁, ▁y ▁, ▁max ▁= ▁0 ▁, ▁nm se dec ▁, ▁bp no ▁; ▁int 64_ t ▁wm se dec ▁= ▁0 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁+ ▁2 ▁; ▁y ▁++ ▁) ▁memset ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y ▁] ▁, ▁0 ▁, ▁( ▁width ▁+ ▁2 ▁) ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁width ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁t 1 ▁-> ▁data ▁[ ▁y ▁] ▁[ ▁x ▁] ▁< ▁0 ▁) ▁{ ▁t 1 ▁-> ▁flags ▁[ ▁y ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁|= ▁JPEG 2000_ T 1_ SG N ▁; ▁t 1 ▁-> ▁data ▁[ ▁y ▁] ▁[ ▁x ▁] ▁= ▁- ▁t 1 ▁-> ▁data ▁[ ▁y ▁] ▁[ ▁x ▁] ▁; ▁} ▁max ▁= ▁FF MAX ▁( ▁max ▁, ▁t 1 ▁-> ▁data ▁[ ▁y ▁] ▁[ ▁x ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁max ▁== ▁0 ▁) ▁{ ▁cb lk ▁-> ▁non zer ob its ▁= ▁0 ▁; ▁bp no ▁= ▁0 ▁; ▁} ▁else ▁{ ▁cb lk ▁-> ▁non zer ob its ▁= ▁av _ log 2 ▁( ▁max ▁) ▁+ ▁1 ▁- ▁NM SE DEC _ FRAC BITS ▁; ▁bp no ▁= ▁cb lk ▁-> ▁non zer ob its ▁- ▁1 ▁; ▁} ▁ff _ mq c _ init enc ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁cb lk ▁-> ▁data ▁) ▁; ▁for ▁( ▁pass no ▁= ▁0 ▁; ▁bp no ▁>= ▁0 ▁; ▁pass no ▁++ ▁) ▁{ ▁nm se dec ▁= ▁0 ▁; ▁switch ▁( ▁pass _ t ▁) ▁{ ▁case ▁0 ▁: ▁encode _ sig pass ▁( ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁band pos ▁, ▁& ▁nm se dec ▁, ▁bp no ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁encode _ ref pass ▁( ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁& ▁nm se dec ▁, ▁bp no ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁encode _ cl n pass ▁( ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁band pos ▁, ▁& ▁nm se dec ▁, ▁bp no ▁) ▁; ▁break ▁; ▁} ▁cb lk ▁-> ▁passes ▁[ ▁pass no ▁] ▁. ▁rate ▁= ▁ff _ mq c _ flush _ to ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁cb lk ▁-> ▁passes ▁[ ▁pass no ▁] ▁. ▁flushed ▁, ▁& ▁cb lk ▁-> ▁passes ▁[ ▁pass no ▁] ▁. ▁flushed _ len ▁) ▁; ▁wm se dec ▁+= ▁( ▁int 64_ t ▁) ▁nm se dec ▁<< ▁( ▁2 ▁* ▁bp no ▁) ▁; ▁cb lk ▁-> ▁passes ▁[ ▁pass no ▁] ▁. ▁dist o ▁= ▁wm se dec ▁; ▁if ▁( ▁++ ▁pass _ t ▁== ▁3 ▁) ▁{ ▁pass _ t ▁= ▁0 ▁; ▁bp no ▁-- ▁; ▁} ▁} ▁cb lk ▁-> ▁np asses ▁= ▁pass no ▁; ▁cb lk ▁-> ▁nin cl passes ▁= ▁pass no ▁; ▁cb lk ▁-> ▁passes ▁[ ▁pass no ▁- ▁1 ▁] ▁. ▁rate ▁= ▁ff _ mq c _ flush _ to ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁cb lk ▁-> ▁passes ▁[ ▁pass no ▁- ▁1 ▁] ▁. ▁flushed ▁, ▁& ▁cb lk ▁-> ▁passes ▁[ ▁pass no ▁- ▁1 ▁] ▁. ▁flushed _ len ▁) ▁; ▁}	1
▁void ▁* ▁av _ realloc ▁( ▁void ▁* ▁ptr ▁, ▁FF _ INTERNAL _ MEM _ TYPE ▁size ▁) ▁{ ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁int ▁diff ▁; ▁# endif ▁if ▁( ▁size ▁> ▁( ▁INT _ MAX ▁- ▁16 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁if ▁( ▁! ▁ptr ▁) ▁return ▁av _ malloc ▁( ▁size ▁) ▁; ▁diff ▁= ▁( ▁( ▁char ▁* ▁) ▁ptr ▁) ▁[ ▁-1 ▁] ▁; ▁return ▁( ▁char ▁* ▁) ▁realloc ▁( ▁( ▁char ▁* ▁) ▁ptr ▁- ▁diff ▁, ▁size ▁+ ▁diff ▁) ▁+ ▁diff ▁; ▁# else ▁return ▁realloc ▁( ▁ptr ▁, ▁size ▁) ▁; ▁# endif ▁}	1
▁static ▁av _ cold ▁int ▁peak _ init _ writer ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁WA VM ux Context ▁* ▁wav ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVCodecContext ▁* ▁enc ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁; ▁if ▁( ▁enc ▁-> ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ PCM _ S 8 ▁&& ▁enc ▁-> ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ PCM _ S 16 LE ▁&& ▁enc ▁-> ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ PCM _ U 8 ▁&& ▁enc ▁-> ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ PCM _ U 16 LE ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁"% s codec not supported for Peak Chunk \ n " ▁, ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁-> ▁codec ▁? ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁-> ▁codec ▁-> ▁name ▁: ▁" NONE " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁wav ▁-> ▁peak _ b ps ▁= ▁av _ get _ bits _ per _ sample ▁( ▁enc ▁-> ▁codec _ id ▁) ▁/ ▁8 ▁; ▁if ▁( ▁wav ▁-> ▁peak _ b ps ▁== ▁1 ▁&& ▁wav ▁-> ▁peak _ format ▁== ▁PE AK _ FORMAT _ UINT 16 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Writing 16 bit peak for 8 bit aud iod oes not mak es ense \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁wav ▁-> ▁peak _ max pos ▁= ▁av _ malloc z ▁( ▁enc ▁-> ▁channels ▁* ▁sizeof ▁( ▁* ▁wav ▁-> ▁peak _ max pos ▁) ▁) ▁; ▁wav ▁-> ▁peak _ max neg ▁= ▁av _ malloc z ▁( ▁enc ▁-> ▁channels ▁* ▁sizeof ▁( ▁* ▁wav ▁-> ▁peak _ max neg ▁) ▁) ▁; ▁wav ▁-> ▁peak _ output ▁= ▁av _ malloc ▁( ▁PE AK _ BUFFER _ SIZE ▁) ▁; ▁if ▁( ▁! ▁wav ▁-> ▁peak _ max pos ▁|| ▁! ▁wav ▁-> ▁peak _ max neg ▁|| ▁! ▁wav ▁-> ▁peak _ output ▁) ▁goto ▁nom em ▁; ▁wav ▁-> ▁peak _ out buf _ size ▁= ▁PE AK _ BUFFER _ SIZE ▁; ▁return ▁0 ▁; ▁nom em ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Out of memory \ n " ▁) ▁; ▁peak _ free _ buffers ▁( ▁s ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁}	0
▁int ▁ff url _ alloc ▁( ▁URL Context ▁* ▁* ▁puc ▁, ▁const ▁char ▁* ▁filename ▁, ▁int ▁flags ▁, ▁const ▁AVIO Interrupt CB ▁* ▁int _ cb ▁) ▁{ ▁URL Protocol ▁* ▁up ▁= ▁NULL ▁; ▁char ▁proto _ str ▁[ ▁128 ▁] ▁, ▁proto _ nested ▁[ ▁128 ▁] ▁, ▁* ▁ptr ▁; ▁size _ t ▁proto _ len ▁= ▁str spn ▁( ▁filename ▁, ▁URL _ SCHEME _ CHARS ▁) ▁; ▁if ▁( ▁filename ▁[ ▁proto _ len ▁] ▁!= ▁' ▁' ▁|| ▁is _ dos _ path ▁( ▁filename ▁) ▁) ▁strcpy ▁( ▁proto _ str ▁, ▁" file " ▁) ▁; ▁else ▁av _ strlcpy ▁( ▁proto _ str ▁, ▁filename ▁, ▁FF MIN ▁( ▁proto _ len ▁+ ▁1 ▁, ▁sizeof ▁( ▁proto _ str ▁) ▁) ▁) ▁; ▁av _ strlcpy ▁( ▁proto _ nested ▁, ▁proto _ str ▁, ▁sizeof ▁( ▁proto _ nested ▁) ▁) ▁; ▁if ▁( ▁( ▁ptr ▁= ▁strchr ▁( ▁proto _ nested ▁, ▁' ▁' ▁) ▁) ▁) ▁* ▁ptr ▁= ▁' ▁\0 ▁' ▁; ▁while ▁( ▁up ▁= ▁ff url _ protocol _ next ▁( ▁up ▁) ▁) ▁{ ▁if ▁( ▁! ▁strcmp ▁( ▁proto _ str ▁, ▁up ▁-> ▁name ▁) ▁) ▁return ▁url _ alloc _ for _ protocol ▁( ▁puc ▁, ▁up ▁, ▁filename ▁, ▁flags ▁, ▁int _ cb ▁) ▁; ▁if ▁( ▁up ▁-> ▁flags ▁& ▁URL _ PROTOCOL _ FLAG _ NEST ED _ SCHEME ▁&& ▁! ▁strcmp ▁( ▁proto _ nested ▁, ▁up ▁-> ▁name ▁) ▁) ▁return ▁url _ alloc _ for _ protocol ▁( ▁puc ▁, ▁up ▁, ▁filename ▁, ▁flags ▁, ▁int _ cb ▁) ▁; ▁} ▁* ▁puc ▁= ▁NULL ▁; ▁return ▁AVERROR _ PROTOCOL _ NOT _ FOUND ▁; ▁}	1
▁int ▁spk ac _ main ▁( ▁int ▁argc ▁, ▁char ▁* ▁* ▁argv ▁) ▁{ ▁BIO ▁* ▁out ▁= ▁NULL ▁; ▁CONF ▁* ▁conf ▁= ▁NULL ▁; ▁ENGINE ▁* ▁e ▁= ▁NULL ▁; ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁NETSCAPE _ SP KI ▁* ▁sp ki ▁= ▁NULL ▁; ▁char ▁* ▁challenge ▁= ▁NULL ▁, ▁* ▁key file ▁= ▁NULL ▁; ▁char ▁* ▁infile ▁= ▁NULL ▁, ▁* ▁outfile ▁= ▁NULL ▁, ▁* ▁pass in arg ▁= ▁NULL ▁, ▁* ▁pass in ▁= ▁NULL ▁; ▁char ▁* ▁spk str ▁= ▁NULL ▁, ▁* ▁prog ▁; ▁const ▁char ▁* ▁spk ac ▁= ▁" SPK AC " ▁, ▁* ▁spk sect ▁= ▁" default " ▁; ▁int ▁i ▁, ▁ret ▁= ▁1 ▁, ▁verify ▁= ▁0 ▁, ▁n oo ut ▁= ▁0 ▁, ▁pubkey ▁= ▁0 ▁; ▁int ▁key format ▁= ▁FORMAT _ PEM ▁; ▁OPTION _ CHOICE ▁o ▁; ▁prog ▁= ▁opt _ init ▁( ▁argc ▁, ▁argv ▁, ▁spk ac _ options ▁) ▁; ▁while ▁( ▁( ▁o ▁= ▁opt _ next ▁( ▁) ▁) ▁!= ▁OPT _ EOF ▁) ▁{ ▁switch ▁( ▁o ▁) ▁{ ▁case ▁OPT _ EOF ▁: ▁case ▁OPT _ ERR ▁: ▁opt help ▁: ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"% s : Use - help for summary .\ n " ▁, ▁prog ▁) ▁; ▁goto ▁end ▁; ▁case ▁OPT _ HELP ▁: ▁opt _ help ▁( ▁spk ac _ options ▁) ▁; ▁ret ▁= ▁0 ▁; ▁goto ▁end ▁; ▁case ▁OPT _ IN ▁: ▁infile ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ OUT ▁: ▁outfile ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ NO OUT ▁: ▁n oo ut ▁= ▁1 ▁; ▁break ▁; ▁case ▁OPT _ PUB KEY ▁: ▁pubkey ▁= ▁1 ▁; ▁break ▁; ▁case ▁OPT _ VERIFY ▁: ▁verify ▁= ▁1 ▁; ▁break ▁; ▁case ▁OPT _ PASS IN ▁: ▁pass in arg ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ KEY ▁: ▁key file ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ KEY FORM ▁: ▁if ▁( ▁! ▁opt _ format ▁( ▁opt _ arg ▁( ▁) ▁, ▁OPT _ FMT _ ANY ▁, ▁& ▁key format ▁) ▁) ▁goto ▁opt help ▁; ▁break ▁; ▁case ▁OPT _ CH ALL EN GE ▁: ▁challenge ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ SPK AC ▁: ▁spk ac ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ SPK SECT ▁: ▁spk sect ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ ENGINE ▁: ▁e ▁= ▁setup _ engine ▁( ▁opt _ arg ▁( ▁) ▁, ▁0 ▁) ▁; ▁break ▁; ▁} ▁} ▁argc ▁= ▁opt _ num _ rest ▁( ▁) ▁; ▁if ▁( ▁argc ▁!= ▁0 ▁) ▁goto ▁opt help ▁; ▁if ▁( ▁! ▁app _ passwd ▁( ▁pass in arg ▁, ▁NULL ▁, ▁& ▁pass in ▁, ▁NULL ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Error get ting password \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁key file ▁!= ▁NULL ▁) ▁{ ▁pkey ▁= ▁load _ key ▁( ▁strcmp ▁( ▁key file ▁, ▁"-" ▁) ▁? ▁key file ▁: ▁NULL ▁, ▁key format ▁, ▁1 ▁, ▁pass in ▁, ▁e ▁, ▁" private key " ▁) ▁; ▁if ▁( ▁pkey ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁sp ki ▁= ▁NETSCAPE _ SP KI _ new ▁( ▁) ▁; ▁if ▁( ▁sp ki ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁if ▁( ▁challenge ▁!= ▁NULL ▁) ▁ASN 1_ STRING _ set ▁( ▁sp ki ▁-> ▁spk ac ▁-> ▁challenge ▁, ▁challenge ▁, ▁( ▁int ▁) ▁strlen ▁( ▁challenge ▁) ▁) ▁; ▁NETSCAPE _ SP KI _ set _ pubkey ▁( ▁sp ki ▁, ▁pkey ▁) ▁; ▁NETSCAPE _ SP KI _ sign ▁( ▁sp ki ▁, ▁pkey ▁, ▁EVP _ md 5 ▁( ▁) ▁) ▁; ▁spk str ▁= ▁NETSCAPE _ SP KI _ b 64_ encode ▁( ▁sp ki ▁) ▁; ▁if ▁( ▁spk str ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁out ▁= ▁bio _ open _ default ▁( ▁outfile ▁, ▁' ▁' ▁, ▁FORMAT _ TEXT ▁) ▁; ▁if ▁( ▁out ▁== ▁NULL ▁) ▁{ ▁OPENSSL _ free ▁( ▁spk str ▁) ▁; ▁goto ▁end ▁; ▁} ▁BIO _ printf ▁( ▁out ▁, ▁" SPK AC =% s \ n " ▁, ▁spk str ▁) ▁; ▁OPENSSL _ free ▁( ▁spk str ▁) ▁; ▁ret ▁= ▁0 ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁( ▁conf ▁= ▁app _ load _ config ▁( ▁infile ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁spk str ▁= ▁N CONF _ get _ string ▁( ▁conf ▁, ▁spk sect ▁, ▁spk ac ▁) ▁; ▁if ▁( ▁spk str ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Can ' t find SPK AC called \"% s \"\ n " ▁, ▁spk ac ▁) ▁; ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁goto ▁end ▁; ▁} ▁sp ki ▁= ▁NETSCAPE _ SP KI _ b 64_ decode ▁( ▁spk str ▁, ▁-1 ▁) ▁; ▁if ▁( ▁sp ki ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Error loading SPK AC \ n " ▁) ▁; ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁goto ▁end ▁; ▁} ▁out ▁= ▁bio _ open _ default ▁( ▁outfile ▁, ▁' ▁' ▁, ▁FORMAT _ TEXT ▁) ▁; ▁if ▁( ▁out ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁if ▁( ▁! ▁n oo ut ▁) ▁NETSCAPE _ SP KI _ print ▁( ▁out ▁, ▁sp ki ▁) ▁; ▁pkey ▁= ▁NETSCAPE _ SP KI _ get _ pubkey ▁( ▁sp ki ▁) ▁; ▁if ▁( ▁verify ▁) ▁{ ▁i ▁= ▁NETSCAPE _ SP KI _ verify ▁( ▁sp ki ▁, ▁pkey ▁) ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Signature OK \ n " ▁) ▁; ▁} ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Signature Failure \ n " ▁) ▁; ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁if ▁( ▁pubkey ▁) ▁PEM _ write _ bio _ PUB KEY ▁( ▁out ▁, ▁pkey ▁) ▁; ▁ret ▁= ▁0 ▁; ▁end ▁: ▁N CONF _ free ▁( ▁conf ▁) ▁; ▁NETSCAPE _ SP KI _ free ▁( ▁sp ki ▁) ▁; ▁BIO _ free _ all ▁( ▁out ▁) ▁; ▁EVP _ PKEY _ free ▁( ▁pkey ▁) ▁; ▁release _ engine ▁( ▁e ▁) ▁; ▁OPENSSL _ free ▁( ▁pass in ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁void ▁* ▁av _ malloc ▁( ▁size _ t ▁size ▁) ▁{ ▁void ▁* ▁ptr ▁= ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁long ▁diff ▁; ▁# endif ▁if ▁( ▁size ▁> ▁( ▁max _ alloc _ size ▁- ▁32 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁ptr ▁= ▁malloc ▁( ▁size ▁+ ▁ALIGN ▁) ▁; ▁if ▁( ▁! ▁ptr ▁) ▁return ▁ptr ▁; ▁diff ▁= ▁( ▁( ▁ ~ ▁( ▁long ▁) ▁ptr ▁) ▁& ▁( ▁ALIGN ▁- ▁1 ▁) ▁) ▁+ ▁1 ▁; ▁ptr ▁= ▁( ▁char ▁* ▁) ▁ptr ▁+ ▁diff ▁; ▁( ▁( ▁char ▁* ▁) ▁ptr ▁) ▁[ ▁-1 ▁] ▁= ▁diff ▁; ▁# elif ▁HAVE _ POSIX _ MEM ALIGN ▁if ▁( ▁size ▁) ▁if ▁( ▁posix _ memalign ▁( ▁& ▁ptr ▁, ▁ALIGN ▁, ▁size ▁) ▁) ▁ptr ▁= ▁NULL ▁; ▁# elif ▁HAVE _ ALIGNED _ MALLOC ▁ptr ▁= ▁_ aligned _ malloc ▁( ▁size ▁, ▁ALIGN ▁) ▁; ▁# elif ▁HAVE _ MEM ALIGN ▁# ifndef ▁__ D J GPP __ ▁ptr ▁= ▁mem align ▁( ▁ALIGN ▁, ▁size ▁) ▁; ▁# else ▁ptr ▁= ▁mem align ▁( ▁size ▁, ▁ALIGN ▁) ▁; ▁# endif ▁# else ▁ptr ▁= ▁malloc ▁( ▁size ▁) ▁; ▁# endif ▁if ▁( ▁! ▁ptr ▁&& ▁! ▁size ▁) ▁{ ▁size ▁= ▁1 ▁; ▁ptr ▁= ▁av _ malloc ▁( ▁1 ▁) ▁; ▁} ▁# if ▁CONFIG _ MEMORY _ POISON ING ▁if ▁( ▁ptr ▁) ▁memset ▁( ▁ptr ▁, ▁FF _ MEMORY _ POISON ▁, ▁size ▁) ▁; ▁# endif ▁return ▁ptr ▁; ▁}	1
▁static ▁int ▁crl _ inf _ cb ▁( ▁int ▁operation ▁, ▁ASN 1_ VALUE ▁* ▁* ▁pval ▁, ▁const ▁ASN 1_ ITEM ▁* ▁it ▁) ▁{ ▁X 509_ CRL _ INFO ▁* ▁a ▁= ▁( ▁X 509_ CRL _ INFO ▁* ▁) ▁* ▁pval ▁; ▁if ▁( ▁! ▁a ▁|| ▁! ▁a ▁-> ▁re voked ▁) ▁return ▁1 ▁; ▁switch ▁( ▁operation ▁) ▁{ ▁case ▁ASN 1_ OP _ D 2 I _ POST ▁: ▁sk _ X 509_ REV OKED _ set _ cmp _ func ▁( ▁a ▁-> ▁re voked ▁, ▁X 509_ REV OKED _ cmp ▁) ▁; ▁break ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁split _ field _ half _ ref _ list ▁( ▁Picture ▁* ▁dest ▁, ▁int ▁dest _ len ▁, ▁Picture ▁* ▁src ▁, ▁int ▁src _ len ▁, ▁int ▁parity ▁) ▁{ ▁int ▁same _ parity ▁= ▁1 ▁; ▁int ▁same _ i ▁= ▁0 ▁; ▁int ▁opp _ i ▁= ▁0 ▁; ▁int ▁out _ i ▁; ▁int ▁field _ output ▁; ▁for ▁( ▁out _ i ▁= ▁0 ▁; ▁out _ i ▁< ▁dest _ len ▁; ▁out _ i ▁+= ▁field _ output ▁) ▁{ ▁if ▁( ▁same _ parity ▁&& ▁same _ i ▁< ▁src _ len ▁) ▁{ ▁field _ output ▁= ▁split _ field _ copy ▁( ▁dest ▁+ ▁out _ i ▁, ▁src ▁+ ▁same _ i ▁, ▁parity ▁, ▁1 ▁) ▁; ▁same _ parity ▁= ▁! ▁field _ output ▁; ▁same _ i ▁++ ▁; ▁} ▁else ▁if ▁( ▁opp _ i ▁< ▁src _ len ▁) ▁{ ▁field _ output ▁= ▁split _ field _ copy ▁( ▁dest ▁+ ▁out _ i ▁, ▁src ▁+ ▁opp _ i ▁, ▁P ICT _ FRAME ▁- ▁parity ▁, ▁0 ▁) ▁; ▁same _ parity ▁= ▁field _ output ▁; ▁opp _ i ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁return ▁out _ i ▁; ▁}	1
▁int ▁CRYPTO _ add _ lock ▁( ▁int ▁* ▁pointer ▁, ▁int ▁amount ▁, ▁int ▁type ▁, ▁const ▁char ▁* ▁file ▁, ▁int ▁line ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁add _ lock _ callback ▁!= ▁NULL ▁) ▁{ ▁# ifdef ▁LOCK _ DEBUG ▁int ▁before ▁= ▁* ▁pointer ▁; ▁# endif ▁ret ▁= ▁add _ lock _ callback ▁( ▁pointer ▁, ▁amount ▁, ▁type ▁, ▁file ▁, ▁line ▁) ▁; ▁# ifdef ▁LOCK _ DEBUG ▁{ ▁CRYPTO _ THREAD ID ▁id ▁; ▁CRYPTO _ THREAD ID _ current ▁( ▁& ▁id ▁) ▁; ▁fprintf ▁( ▁stderr ▁, ▁" la dd :% 08 lx :% 2 d + %2 d -> %2 d % -18 s % s :% d \ n " ▁, ▁CRYPTO _ THREAD ID _ hash ▁( ▁& ▁id ▁) ▁, ▁before ▁, ▁amount ▁, ▁ret ▁, ▁CRYPTO _ get _ lock _ name ▁( ▁type ▁) ▁, ▁file ▁, ▁line ▁) ▁; ▁} ▁# endif ▁} ▁else ▁{ ▁CRYPTO _ lock ▁( ▁CRYPTO _ LOCK ▁| ▁CRYPTO _ WRITE ▁, ▁type ▁, ▁file ▁, ▁line ▁) ▁; ▁ret ▁= ▁* ▁pointer ▁+ ▁amount ▁; ▁# ifdef ▁LOCK _ DEBUG ▁{ ▁CRYPTO _ THREAD ID ▁id ▁; ▁CRYPTO _ THREAD ID _ current ▁( ▁& ▁id ▁) ▁; ▁fprintf ▁( ▁stderr ▁, ▁" la dd :% 08 lx :% 2 d + %2 d -> %2 d % -18 s % s :% d \ n " ▁, ▁CRYPTO _ THREAD ID _ hash ▁( ▁& ▁id ▁) ▁, ▁* ▁pointer ▁, ▁amount ▁, ▁ret ▁, ▁CRYPTO _ get _ lock _ name ▁( ▁type ▁) ▁, ▁file ▁, ▁line ▁) ▁; ▁} ▁# endif ▁* ▁pointer ▁= ▁ret ▁; ▁CRYPTO _ lock ▁( ▁CRYPTO _ UNLOCK ▁| ▁CRYPTO _ WRITE ▁, ▁type ▁, ▁file ▁, ▁line ▁) ▁; ▁} ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁static ▁int ▁cookie _ string ▁( ▁AV Dictionary ▁* ▁dict ▁, ▁char ▁* ▁* ▁cookies ▁) ▁{ ▁AV Dictionary Entry ▁* ▁e ▁= ▁NULL ▁; ▁int ▁len ▁= ▁1 ▁; ▁while ▁( ▁e ▁= ▁av _ dict _ get ▁( ▁dict ▁, ▁"" ▁, ▁e ▁, ▁AV _ DICT _ IGNORE _ SUFFIX ▁) ▁) ▁len ▁+= ▁strlen ▁( ▁e ▁-> ▁key ▁) ▁+ ▁strlen ▁( ▁e ▁-> ▁value ▁) ▁+ ▁1 ▁; ▁e ▁= ▁NULL ▁; ▁if ▁( ▁* ▁cookies ▁) ▁av _ free ▁( ▁* ▁cookies ▁) ▁; ▁* ▁cookies ▁= ▁av _ malloc ▁( ▁len ▁) ▁; ▁if ▁( ▁! ▁cookies ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁* ▁cookies ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁while ▁( ▁e ▁= ▁av _ dict _ get ▁( ▁dict ▁, ▁"" ▁, ▁e ▁, ▁AV _ DICT _ IGNORE _ SUFFIX ▁) ▁) ▁av _ strl cat f ▁( ▁* ▁cookies ▁, ▁len ▁, ▁"% s % s \ n " ▁, ▁e ▁-> ▁key ▁, ▁e ▁-> ▁value ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁BN _ us ub ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁) ▁{ ▁int ▁max ▁, ▁min ▁, ▁dif ▁; ▁BN _ ULONG ▁t 1 ▁, ▁t 2 ▁, ▁borrow ▁, ▁* ▁rp ▁; ▁const ▁BN _ ULONG ▁* ▁ap ▁, ▁* ▁bp ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁max ▁= ▁a ▁-> ▁top ▁; ▁min ▁= ▁b ▁-> ▁top ▁; ▁dif ▁= ▁max ▁- ▁min ▁; ▁if ▁( ▁dif ▁< ▁0 ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ US UB ▁, ▁BN _ R _ ARG 2_ LT _ ARG 3 ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁bn _ w expand ▁( ▁r ▁, ▁max ▁) ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁ap ▁= ▁a ▁-> ▁d ▁; ▁bp ▁= ▁b ▁-> ▁d ▁; ▁rp ▁= ▁r ▁-> ▁d ▁; ▁borrow ▁= ▁bn _ sub _ words ▁( ▁rp ▁, ▁ap ▁, ▁bp ▁, ▁min ▁) ▁; ▁ap ▁+= ▁min ▁; ▁rp ▁+= ▁min ▁; ▁while ▁( ▁dif ▁) ▁{ ▁dif ▁-- ▁; ▁t 1 ▁= ▁* ▁( ▁ap ▁++ ▁) ▁; ▁t 2 ▁= ▁( ▁t 1 ▁- ▁borrow ▁) ▁& ▁BN _ MASK 2 ▁; ▁* ▁( ▁rp ▁++ ▁) ▁= ▁t 2 ▁; ▁borrow ▁&= ▁( ▁t 1 ▁== ▁0 ▁) ▁; ▁} ▁r ▁-> ▁top ▁= ▁max ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁bn _ correct _ top ▁( ▁r ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁vs ink _ query _ formats ▁( ▁AVFilter Context ▁* ▁ctx ▁) ▁{ ▁Buffer Sink Context ▁* ▁buf ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFilter Formats ▁* ▁formats ▁= ▁NULL ▁; ▁unsigned ▁i ▁; ▁int ▁ret ▁; ▁CHECK _ LIST _ SIZE ▁( ▁pixel _ fmts ▁) ▁if ▁( ▁buf ▁-> ▁pixel _ fmts _ size ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁pixel _ fmts ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ format ▁( ▁& ▁formats ▁, ▁buf ▁-> ▁pixel _ fmts ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁{ ▁ff _ formats _ unref ▁( ▁& ▁formats ▁) ▁; ▁return ▁ret ▁; ▁} ▁ff _ set _ common _ formats ▁( ▁ctx ▁, ▁formats ▁) ▁; ▁} ▁else ▁{ ▁ff _ default _ query _ formats ▁( ▁ctx ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁i 2 d _ ASN 1_ SET ▁( ▁STACK ▁* ▁a ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁, ▁i 2 d _ of _ void ▁* ▁i 2 d ▁, ▁int ▁ex _ tag ▁, ▁int ▁ex _ class ▁, ▁int ▁is _ set ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁, ▁r ▁; ▁int ▁i ▁; ▁unsigned ▁char ▁* ▁p ▁; ▁unsigned ▁char ▁* ▁p Start ▁, ▁* ▁pTemp Mem ▁; ▁MY BLOB ▁* ▁rg Set Blob ▁; ▁int ▁tot Size ▁; ▁if ▁( ▁a ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁for ▁( ▁i ▁= ▁sk _ num ▁( ▁a ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁ret ▁+= ▁i 2 d ▁( ▁sk _ value ▁( ▁a ▁, ▁i ▁) ▁, ▁NULL ▁) ▁; ▁r ▁= ▁ASN 1_ object _ size ▁( ▁1 ▁, ▁ret ▁, ▁ex _ tag ▁) ▁; ▁if ▁( ▁pp ▁== ▁NULL ▁) ▁return ▁( ▁r ▁) ▁; ▁p ▁= ▁* ▁pp ▁; ▁ASN 1_ put _ object ▁( ▁& ▁p ▁, ▁1 ▁, ▁ret ▁, ▁ex _ tag ▁, ▁ex _ class ▁) ▁; ▁if ▁( ▁! ▁is _ set ▁|| ▁( ▁sk _ num ▁( ▁a ▁) ▁< ▁2 ▁) ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ num ▁( ▁a ▁) ▁; ▁i ▁++ ▁) ▁i 2 d ▁( ▁sk _ value ▁( ▁a ▁, ▁i ▁) ▁, ▁& ▁p ▁) ▁; ▁* ▁pp ▁= ▁p ▁; ▁return ▁( ▁r ▁) ▁; ▁} ▁p Start ▁= ▁p ▁; ▁rg Set Blob ▁= ▁( ▁MY BLOB ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sk _ num ▁( ▁a ▁) ▁* ▁sizeof ▁( ▁MY BLOB ▁) ▁) ▁; ▁if ▁( ▁rg Set Blob ▁== ▁NULL ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ I 2 D _ ASN 1_ SET ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ num ▁( ▁a ▁) ▁; ▁i ▁++ ▁) ▁{ ▁rg Set Blob ▁[ ▁i ▁] ▁. ▁pb Data ▁= ▁p ▁; ▁i 2 d ▁( ▁sk _ value ▁( ▁a ▁, ▁i ▁) ▁, ▁& ▁p ▁) ▁; ▁rg Set Blob ▁[ ▁i ▁] ▁. ▁cb Data ▁= ▁p ▁- ▁rg Set Blob ▁[ ▁i ▁] ▁. ▁pb Data ▁; ▁} ▁* ▁pp ▁= ▁p ▁; ▁tot Size ▁= ▁p ▁- ▁p Start ▁; ▁qsort ▁( ▁rg Set Blob ▁, ▁sk _ num ▁( ▁a ▁) ▁, ▁sizeof ▁( ▁MY BLOB ▁) ▁, ▁Set Blob Cmp ▁) ▁; ▁if ▁( ▁! ▁( ▁pTemp Mem ▁= ▁OPENSSL _ malloc ▁( ▁tot Size ▁) ▁) ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ I 2 D _ ASN 1_ SET ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁p ▁= ▁pTemp Mem ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ num ▁( ▁a ▁) ▁; ▁++ ▁i ▁) ▁{ ▁memcpy ▁( ▁p ▁, ▁rg Set Blob ▁[ ▁i ▁] ▁. ▁pb Data ▁, ▁rg Set Blob ▁[ ▁i ▁] ▁. ▁cb Data ▁) ▁; ▁p ▁+= ▁rg Set Blob ▁[ ▁i ▁] ▁. ▁cb Data ▁; ▁} ▁memcpy ▁( ▁p Start ▁, ▁pTemp Mem ▁, ▁tot Size ▁) ▁; ▁OPENSSL _ free ▁( ▁pTemp Mem ▁) ▁; ▁OPENSSL _ free ▁( ▁rg Set Blob ▁) ▁; ▁return ▁( ▁r ▁) ▁; ▁}	1
▁static ▁void ▁encode _ signal _ range ▁( ▁VC 2 Enc Context ▁* ▁s ▁) ▁{ ▁int ▁idx ▁; ▁AVCodecContext ▁* ▁avctx ▁= ▁s ▁-> ▁avctx ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁fmt ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁avctx ▁-> ▁pix _ fmt ▁) ▁; ▁const ▁int ▁depth ▁= ▁fmt ▁-> ▁comp ▁[ ▁0 ▁] ▁. ▁depth ▁; ▁if ▁( ▁depth ▁== ▁8 ▁&& ▁avctx ▁-> ▁color _ range ▁== ▁AV COL _ RANGE _ JPEG ▁) ▁{ ▁idx ▁= ▁1 ▁; ▁s ▁-> ▁bpp ▁= ▁1 ▁; ▁s ▁-> ▁diff _ offset ▁= ▁128 ▁; ▁} ▁else ▁if ▁( ▁depth ▁== ▁8 ▁&& ▁( ▁avctx ▁-> ▁color _ range ▁== ▁AV COL _ RANGE _ MPEG ▁|| ▁avctx ▁-> ▁color _ range ▁== ▁AV COL _ RANGE _ UNSPEC IFIED ▁) ▁) ▁{ ▁idx ▁= ▁2 ▁; ▁s ▁-> ▁bpp ▁= ▁1 ▁; ▁s ▁-> ▁diff _ offset ▁= ▁128 ▁; ▁} ▁else ▁if ▁( ▁depth ▁== ▁10 ▁) ▁{ ▁idx ▁= ▁3 ▁; ▁s ▁-> ▁bpp ▁= ▁2 ▁; ▁s ▁-> ▁diff _ offset ▁= ▁512 ▁; ▁} ▁else ▁{ ▁idx ▁= ▁4 ▁; ▁s ▁-> ▁bpp ▁= ▁2 ▁; ▁s ▁-> ▁diff _ offset ▁= ▁2048 ▁; ▁} ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁1 ▁, ▁! ▁s ▁-> ▁strict _ comp liance ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁strict _ comp liance ▁) ▁put _ vc 2_ ue _ uint ▁( ▁& ▁s ▁-> ▁pb ▁, ▁idx ▁) ▁; ▁}	1
▁int ▁EVP _ MD _ CTX _ reset ▁( ▁EVP _ MD _ CTX ▁* ▁ctx ▁) ▁{ ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁return ▁1 ▁; ▁if ▁( ▁ctx ▁-> ▁digest ▁&& ▁ctx ▁-> ▁digest ▁-> ▁cleanup ▁&& ▁! ▁EVP _ MD _ CTX _ test _ flags ▁( ▁ctx ▁, ▁EVP _ MD _ CTX _ FLAG _ CLEAN ED ▁) ▁) ▁ctx ▁-> ▁digest ▁-> ▁cleanup ▁( ▁ctx ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁digest ▁&& ▁ctx ▁-> ▁digest ▁-> ▁ctx _ size ▁&& ▁ctx ▁-> ▁md _ data ▁&& ▁! ▁EVP _ MD _ CTX _ test _ flags ▁( ▁ctx ▁, ▁EVP _ MD _ CTX _ FLAG _ REUSE ▁) ▁) ▁{ ▁OPENSSL _ clear _ free ▁( ▁ctx ▁-> ▁md _ data ▁, ▁ctx ▁-> ▁digest ▁-> ▁ctx _ size ▁) ▁; ▁} ▁EVP _ PKEY _ CTX _ free ▁( ▁ctx ▁-> ▁pctx ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁ENGINE _ finish ▁( ▁ctx ▁-> ▁engine ▁) ▁; ▁# endif ▁memset ▁( ▁ctx ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁ctx ▁) ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁rtp _ read ▁( ▁URL Context ▁* ▁h ▁, ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁size ▁) ▁{ ▁RTP Context ▁* ▁s ▁= ▁h ▁-> ▁priv _ data ▁; ▁struct ▁sockaddr _ storage ▁from ▁; ▁socklen _ t ▁from _ len ▁; ▁int ▁len ▁, ▁n ▁; ▁struct ▁pollfd ▁p ▁[ ▁2 ▁] ▁= ▁{ ▁{ ▁s ▁-> ▁rtp _ fd ▁, ▁POLLIN ▁, ▁0 ▁} ▁, ▁{ ▁s ▁-> ▁rt cp _ fd ▁, ▁POLLIN ▁, ▁0 ▁} ▁} ▁; ▁# if ▁0 ▁for ▁( ▁; ▁; ▁) ▁{ ▁from _ len ▁= ▁sizeof ▁( ▁from ▁) ▁; ▁len ▁= ▁recv from ▁( ▁s ▁-> ▁rtp _ fd ▁, ▁buf ▁, ▁size ▁, ▁0 ▁, ▁( ▁struct ▁sockaddr ▁* ▁) ▁& ▁from ▁, ▁& ▁from _ len ▁) ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ff _ net errno ▁( ▁) ▁== ▁FF _ NE TER ROR ▁( ▁EAGAIN ▁) ▁|| ▁ff _ net errno ▁( ▁) ▁== ▁FF _ NE TER ROR ▁( ▁EINTR ▁) ▁) ▁continue ▁; ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁} ▁break ▁; ▁} ▁# else ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁url _ interrupt _ cb ▁( ▁) ▁) ▁return ▁AVERROR ▁( ▁EINTR ▁) ▁; ▁n ▁= ▁poll ▁( ▁p ▁, ▁2 ▁, ▁100 ▁) ▁; ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁if ▁( ▁p ▁[ ▁1 ▁] ▁. ▁revents ▁& ▁POLLIN ▁) ▁{ ▁from _ len ▁= ▁sizeof ▁( ▁from ▁) ▁; ▁len ▁= ▁recv from ▁( ▁s ▁-> ▁rt cp _ fd ▁, ▁buf ▁, ▁size ▁, ▁0 ▁, ▁( ▁struct ▁sockaddr ▁* ▁) ▁& ▁from ▁, ▁& ▁from _ len ▁) ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ff _ net errno ▁( ▁) ▁== ▁FF _ NE TER ROR ▁( ▁EAGAIN ▁) ▁|| ▁ff _ net errno ▁( ▁) ▁== ▁FF _ NE TER ROR ▁( ▁EINTR ▁) ▁) ▁continue ▁; ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁} ▁break ▁; ▁} ▁if ▁( ▁p ▁[ ▁0 ▁] ▁. ▁revents ▁& ▁POLLIN ▁) ▁{ ▁from _ len ▁= ▁sizeof ▁( ▁from ▁) ▁; ▁len ▁= ▁recv from ▁( ▁s ▁-> ▁rtp _ fd ▁, ▁buf ▁, ▁size ▁, ▁0 ▁, ▁( ▁struct ▁sockaddr ▁* ▁) ▁& ▁from ▁, ▁& ▁from _ len ▁) ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ff _ net errno ▁( ▁) ▁== ▁FF _ NE TER ROR ▁( ▁EAGAIN ▁) ▁|| ▁ff _ net errno ▁( ▁) ▁== ▁FF _ NE TER ROR ▁( ▁EINTR ▁) ▁) ▁continue ▁; ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁} ▁break ▁; ▁} ▁} ▁else ▁if ▁( ▁n ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ff _ net errno ▁( ▁) ▁== ▁FF _ NE TER ROR ▁( ▁EINTR ▁) ▁) ▁continue ▁; ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁} ▁} ▁# endif ▁return ▁len ▁; ▁}	0
▁static ▁int ▁decode _ sub frame _ lpc ▁( ▁FLAC Context ▁* ▁s ▁, ▁int ▁channel ▁, ▁int ▁pred _ order ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁coeff _ prec ▁, ▁q level ▁; ▁int ▁coeffs ▁[ ▁pred _ order ▁] ▁; ▁int 32_ t ▁* ▁decoded ▁= ▁s ▁-> ▁decoded ▁[ ▁channel ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁pred _ order ▁; ▁i ▁++ ▁) ▁{ ▁decoded ▁[ ▁i ▁] ▁= ▁get _ s bits _ long ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁curr _ b ps ▁) ▁; ▁} ▁coeff _ prec ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁coeff _ prec ▁== ▁16 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid coeff precision \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁q level ▁= ▁get _ s bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁5 ▁) ▁; ▁if ▁( ▁q level ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" q level % d not supported , maybe bug g yst ream \ n " ▁, ▁q level ▁) ▁; ▁return ▁-1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁pred _ order ▁; ▁i ▁++ ▁) ▁{ ▁coeffs ▁[ ▁i ▁] ▁= ▁get _ s bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁coeff _ prec ▁) ▁; ▁} ▁if ▁( ▁decode _ residual s ▁( ▁s ▁, ▁channel ▁, ▁pred _ order ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁s ▁-> ▁bps ▁> ▁16 ▁) ▁{ ▁int 64_ t ▁sum ▁; ▁for ▁( ▁i ▁= ▁pred _ order ▁; ▁i ▁< ▁s ▁-> ▁blocksize ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁pred _ order ▁; ▁j ▁++ ▁) ▁sum ▁+= ▁( ▁int 64_ t ▁) ▁coeffs ▁[ ▁j ▁] ▁* ▁decoded ▁[ ▁i ▁- ▁j ▁- ▁1 ▁] ▁; ▁decoded ▁[ ▁i ▁] ▁+= ▁sum ▁>> ▁q level ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁pred _ order ▁; ▁i ▁< ▁s ▁-> ▁blocksize ▁- ▁1 ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁int ▁c ▁; ▁int ▁d ▁= ▁decoded ▁[ ▁i ▁- ▁pred _ order ▁] ▁; ▁int ▁s 0 ▁= ▁0 ▁, ▁s 1 ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁pred _ order ▁- ▁1 ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁) ▁{ ▁c ▁= ▁coeffs ▁[ ▁j ▁] ▁; ▁s 0 ▁+= ▁c ▁* ▁d ▁; ▁d ▁= ▁decoded ▁[ ▁i ▁- ▁j ▁] ▁; ▁s 1 ▁+= ▁c ▁* ▁d ▁; ▁} ▁c ▁= ▁coeffs ▁[ ▁0 ▁] ▁; ▁s 0 ▁+= ▁c ▁* ▁d ▁; ▁d ▁= ▁decoded ▁[ ▁i ▁] ▁+= ▁s 0 ▁>> ▁q level ▁; ▁s 1 ▁+= ▁c ▁* ▁d ▁; ▁decoded ▁[ ▁i ▁+ ▁1 ▁] ▁+= ▁s 1 ▁>> ▁q level ▁; ▁} ▁if ▁( ▁i ▁< ▁s ▁-> ▁blocksize ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁pred _ order ▁; ▁j ▁++ ▁) ▁sum ▁+= ▁coeffs ▁[ ▁j ▁] ▁* ▁decoded ▁[ ▁i ▁- ▁j ▁- ▁1 ▁] ▁; ▁decoded ▁[ ▁i ▁] ▁+= ▁sum ▁>> ▁q level ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁C ERT _ PKEY ▁* ▁ssl _ get _ server _ send _ pkey ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁C ERT ▁* ▁c ▁; ▁int ▁i ▁; ▁c ▁= ▁s ▁-> ▁cert ▁; ▁if ▁( ▁! ▁s ▁-> ▁s 3 ▁|| ▁! ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁) ▁return ▁NULL ▁; ▁ssl _ set _ masks ▁( ▁s ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁) ▁; ▁# ifdef ▁OPENSSL _ SSL _ DEBUG _ BROKEN _ PROTOCOL ▁if ▁( ▁c ▁-> ▁cert _ flags ▁& ▁SSL _ CERT _ FLAG _ BROKEN _ PROTOCOL ▁) ▁return ▁c ▁-> ▁key ▁; ▁# endif ▁i ▁= ▁ssl _ get _ server _ cert _ index ▁( ▁s ▁) ▁; ▁if ▁( ▁i ▁< ▁0 ▁) ▁return ▁NULL ▁; ▁return ▁& ▁c ▁-> ▁p keys ▁[ ▁i ▁] ▁; ▁}	1
▁static ▁hm _ fragment ▁* ▁dt ls 1_ hm _ fragment _ new ▁( ▁unsigned ▁long ▁frag _ len ▁, ▁int ▁re assembly ▁) ▁{ ▁hm _ fragment ▁* ▁frag ▁= ▁NULL ▁; ▁unsigned ▁char ▁* ▁buf ▁= ▁NULL ▁; ▁unsigned ▁char ▁* ▁bitmask ▁= ▁NULL ▁; ▁frag ▁= ▁( ▁hm _ fragment ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁hm _ fragment ▁) ▁) ▁; ▁if ▁( ▁frag ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁frag _ len ▁) ▁{ ▁buf ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁OPENSSL _ malloc ▁( ▁frag _ len ▁) ▁; ▁if ▁( ▁buf ▁== ▁NULL ▁) ▁{ ▁OPENSSL _ free ▁( ▁frag ▁) ▁; ▁return ▁NULL ▁; ▁} ▁} ▁frag ▁-> ▁fragment ▁= ▁buf ▁; ▁if ▁( ▁re assembly ▁) ▁{ ▁bitmask ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁OPENSSL _ malloc ▁( ▁RS MB LY _ BITMASK _ SIZE ▁( ▁frag _ len ▁) ▁) ▁; ▁if ▁( ▁bitmask ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁buf ▁!= ▁NULL ▁) ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁OPENSSL _ free ▁( ▁frag ▁) ▁; ▁return ▁NULL ▁; ▁} ▁memset ▁( ▁bitmask ▁, ▁0 ▁, ▁RS MB LY _ BITMASK _ SIZE ▁( ▁frag _ len ▁) ▁) ▁; ▁} ▁frag ▁-> ▁re assembly ▁= ▁bitmask ▁; ▁return ▁frag ▁; ▁}	1
▁void ▁* ▁av _ realloc ▁( ▁void ▁* ▁ptr ▁, ▁size _ t ▁size ▁) ▁{ ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁int ▁diff ▁; ▁# endif ▁if ▁( ▁size ▁> ▁( ▁INT _ MAX ▁- ▁16 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁if ▁( ▁! ▁ptr ▁) ▁return ▁av _ malloc ▁( ▁size ▁) ▁; ▁diff ▁= ▁( ▁( ▁char ▁* ▁) ▁ptr ▁) ▁[ ▁-1 ▁] ▁; ▁return ▁( ▁char ▁* ▁) ▁realloc ▁( ▁( ▁char ▁* ▁) ▁ptr ▁- ▁diff ▁, ▁size ▁+ ▁diff ▁) ▁+ ▁diff ▁; ▁# else ▁return ▁realloc ▁( ▁ptr ▁, ▁size ▁) ▁; ▁# endif ▁}	1
▁int ▁X 509_ STORE _ get _ by _ subject ▁( ▁X 509_ STORE _ CTX ▁* ▁vs ▁, ▁int ▁type ▁, ▁X 509_ NAME ▁* ▁name ▁, ▁X 509_ OBJECT ▁* ▁ret ▁) ▁{ ▁X 509_ STORE ▁* ▁ctx ▁= ▁vs ▁-> ▁ctx ▁; ▁X 509_ LOOKUP ▁* ▁lu ▁; ▁X 509_ OBJECT ▁stmp ▁, ▁* ▁tmp ▁; ▁int ▁i ▁, ▁j ▁; ▁tmp ▁= ▁X 509_ OBJECT _ ret rieve _ by _ subject ▁( ▁ctx ▁-> ▁objs ▁, ▁type ▁, ▁name ▁) ▁; ▁if ▁( ▁tmp ▁== ▁NULL ▁) ▁{ ▁for ▁( ▁i ▁= ▁vs ▁-> ▁current _ method ▁; ▁i ▁< ▁sk _ X 509_ LOOKUP _ num ▁( ▁ctx ▁-> ▁get _ cert _ methods ▁) ▁; ▁i ▁++ ▁) ▁{ ▁lu ▁= ▁sk _ X 509_ LOOKUP _ value ▁( ▁ctx ▁-> ▁get _ cert _ methods ▁, ▁i ▁) ▁; ▁j ▁= ▁X 509_ LOOKUP _ by _ subject ▁( ▁lu ▁, ▁type ▁, ▁name ▁, ▁& ▁stmp ▁) ▁; ▁if ▁( ▁j ▁< ▁0 ▁) ▁{ ▁vs ▁-> ▁current _ method ▁= ▁j ▁; ▁return ▁( ▁j ▁) ▁; ▁} ▁else ▁if ▁( ▁j ▁) ▁{ ▁tmp ▁= ▁& ▁stmp ▁; ▁break ▁; ▁} ▁} ▁vs ▁-> ▁current _ method ▁= ▁0 ▁; ▁if ▁( ▁tmp ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁} ▁ret ▁-> ▁type ▁= ▁tmp ▁-> ▁type ▁; ▁ret ▁-> ▁data ▁. ▁ptr ▁= ▁tmp ▁-> ▁data ▁. ▁ptr ▁; ▁X 509_ OBJECT _ up _ ref _ count ▁( ▁ret ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	0
▁static ▁int ▁R ENAME ▁( ▁res ample _ common ▁) ▁( ▁Res ample Context ▁* ▁c ▁, ▁DE LEM ▁* ▁dst ▁, ▁const ▁DE LEM ▁* ▁src ▁, ▁int ▁n ▁, ▁int ▁update _ ctx ▁) ▁{ ▁int ▁dst _ index ▁; ▁int ▁index ▁= ▁c ▁-> ▁index ▁; ▁int ▁frac ▁= ▁c ▁-> ▁frac ▁; ▁int ▁sample _ index ▁= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁n ▁; ▁dst _ index ▁++ ▁) ▁{ ▁F ELEM ▁* ▁filter ▁= ▁( ▁( ▁F ELEM ▁* ▁) ▁c ▁-> ▁filter _ bank ▁) ▁+ ▁c ▁-> ▁filter _ alloc ▁* ▁index ▁; ▁F ELEM 2 ▁val ▁= ▁0 ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁} ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁frac ▁+= ▁c ▁-> ▁dst _ incr _ mod ▁; ▁index ▁+= ▁c ▁-> ▁dst _ incr _ div ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁sample _ index ▁+= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁} ▁if ▁( ▁update _ ctx ▁) ▁{ ▁c ▁-> ▁frac ▁= ▁frac ▁; ▁c ▁-> ▁index ▁= ▁index ▁; ▁} ▁return ▁sample _ index ▁; ▁}	1
▁static ▁void ▁fill _ gv _ table ▁( ▁int ▁table ▁[ ▁256 ▁+ ▁2 ▁* ▁Y U VR GB _ TABLE _ HEAD ROOM ▁] ▁, ▁const ▁int ▁elem size ▁, ▁const ▁int ▁inc ▁) ▁{ ▁int ▁i ▁; ▁int ▁off ▁= ▁- ▁( ▁inc ▁>> ▁9 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁+ ▁2 ▁* ▁Y U VR GB _ TABLE _ HEAD ROOM ▁; ▁i ▁++ ▁) ▁{ ▁int 64_ t ▁cb ▁= ▁av _ clip ▁( ▁i ▁- ▁Y U VR GB _ TABLE _ HEAD ROOM ▁, ▁0 ▁, ▁255 ▁) ▁* ▁inc ▁; ▁table ▁[ ▁i ▁] ▁= ▁elem size ▁* ▁( ▁off ▁+ ▁( ▁cb ▁>> ▁16 ▁) ▁) ▁; ▁} ▁}	1
▁static ▁void ▁compute _ ch apt ers _ end ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁unsigned ▁int ▁i ▁, ▁j ▁; ▁int 64_ t ▁max _ time ▁= ▁s ▁-> ▁duration ▁+ ▁( ▁( ▁s ▁-> ▁start _ time ▁== ▁AV _ NOP TS _ VALUE ▁) ▁? ▁0 ▁: ▁s ▁-> ▁start _ time ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ ch apt ers ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁-> ▁ch apt ers ▁[ ▁i ▁] ▁-> ▁end ▁== ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁AV Ch apter ▁* ▁ch ▁= ▁s ▁-> ▁ch apt ers ▁[ ▁i ▁] ▁; ▁int 64_ t ▁end ▁= ▁max _ time ▁? ▁av _ re scale _ q ▁( ▁max _ time ▁, ▁AV _ TIME _ BASE _ Q ▁, ▁ch ▁-> ▁time _ base ▁) ▁: ▁INT 64_ MAX ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁-> ▁nb _ ch apt ers ▁; ▁j ▁++ ▁) ▁{ ▁AV Ch apter ▁* ▁ch 1 ▁= ▁s ▁-> ▁ch apt ers ▁[ ▁j ▁] ▁; ▁int 64_ t ▁next _ start ▁= ▁av _ re scale _ q ▁( ▁ch 1 ▁-> ▁start ▁, ▁ch 1 ▁-> ▁time _ base ▁, ▁ch ▁-> ▁time _ base ▁) ▁; ▁if ▁( ▁j ▁!= ▁i ▁&& ▁next _ start ▁> ▁ch ▁-> ▁start ▁&& ▁next _ start ▁< ▁end ▁) ▁end ▁= ▁next _ start ▁; ▁} ▁ch ▁-> ▁end ▁= ▁( ▁end ▁== ▁INT 64_ MAX ▁) ▁? ▁ch ▁-> ▁start ▁: ▁end ▁; ▁} ▁}	1
▁static ▁void ▁fill _ buffer ▁( ▁AVIO Context ▁* ▁s ▁) ▁{ ▁int ▁max _ buffer _ size ▁= ▁s ▁-> ▁max _ packet _ size ▁? ▁s ▁-> ▁max _ packet _ size ▁: ▁IO _ BUFFER _ SIZE ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buffer ▁+ ▁max _ buffer _ size ▁< ▁s ▁-> ▁buffer _ size ▁? ▁s ▁-> ▁buf _ end ▁: ▁s ▁-> ▁buffer ▁; ▁int ▁len ▁= ▁s ▁-> ▁buffer _ size ▁- ▁( ▁dst ▁- ▁s ▁-> ▁buffer ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁read _ packet ▁&& ▁s ▁-> ▁buf _ ptr ▁>= ▁s ▁-> ▁buf _ end ▁) ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁if ▁( ▁s ▁-> ▁eof _ reached ▁) ▁return ▁; ▁if ▁( ▁s ▁-> ▁update _ checksum ▁&& ▁dst ▁== ▁s ▁-> ▁buffer ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ end ▁> ▁s ▁-> ▁checksum _ ptr ▁) ▁s ▁-> ▁checksum ▁= ▁s ▁-> ▁update _ checksum ▁( ▁s ▁-> ▁checksum ▁, ▁s ▁-> ▁checksum _ ptr ▁, ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁checksum _ ptr ▁) ▁; ▁s ▁-> ▁checksum _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁if ▁( ▁s ▁-> ▁read _ packet ▁&& ▁s ▁-> ▁orig _ buffer _ size ▁&& ▁s ▁-> ▁buffer _ size ▁> ▁s ▁-> ▁orig _ buffer _ size ▁) ▁{ ▁if ▁( ▁dst ▁== ▁s ▁-> ▁buffer ▁&& ▁s ▁-> ▁buf _ ptr ▁!= ▁dst ▁) ▁{ ▁int ▁ret ▁= ▁ff io _ set _ buf _ size ▁( ▁s ▁, ▁s ▁-> ▁orig _ buffer _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Failed t ode crease buffers ize \ n " ▁) ▁; ▁s ▁-> ▁checksum _ ptr ▁= ▁dst ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁av _ assert 0 ▁( ▁len ▁>= ▁s ▁-> ▁orig _ buffer _ size ▁) ▁; ▁len ▁= ▁s ▁-> ▁orig _ buffer _ size ▁; ▁} ▁len ▁= ▁read _ packet _ wrapper ▁( ▁s ▁, ▁dst ▁, ▁len ▁) ▁; ▁if ▁( ▁len ▁== ▁AVERROR _ EOF ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁len ▁< ▁0 ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁s ▁-> ▁error ▁= ▁len ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pos ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁dst ▁; ▁s ▁-> ▁buf _ end ▁= ▁dst ▁+ ▁len ▁; ▁s ▁-> ▁bytes _ read ▁+= ▁len ▁; ▁} ▁}	0
▁int 64_ t ▁av _ re scale _ q _ rnd ▁( ▁int 64_ t ▁a ▁, ▁AVR ational ▁bq ▁, ▁AVR ational ▁cq ▁, ▁enum ▁AV Round ing ▁rnd ▁) ▁{ ▁int 64_ t ▁b ▁= ▁bq ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁cq ▁. ▁den ▁; ▁int 64_ t ▁c ▁= ▁cq ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁bq ▁. ▁den ▁; ▁return ▁av _ re scale _ rnd ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁rnd ▁) ▁; ▁}	1
▁AV Res ample Context ▁* ▁av _ res ample _ init ▁( ▁int ▁out _ rate ▁, ▁int ▁in _ rate ▁, ▁int ▁filter _ size ▁, ▁int ▁phase _ shift ▁, ▁int ▁linear ▁, ▁double ▁cutoff ▁) ▁{ ▁AV Res ample Context ▁* ▁c ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AV Res ample Context ▁) ▁) ▁; ▁double ▁factor ▁= ▁FF MIN ▁( ▁out _ rate ▁* ▁cutoff ▁/ ▁in _ rate ▁, ▁1.0 ▁) ▁; ▁int ▁phase _ count ▁= ▁1 ▁<< ▁phase _ shift ▁; ▁if ▁( ▁! ▁c ▁) ▁return ▁NULL ▁; ▁c ▁-> ▁phase _ shift ▁= ▁phase _ shift ▁; ▁c ▁-> ▁phase _ mask ▁= ▁phase _ count ▁- ▁1 ▁; ▁c ▁-> ▁linear ▁= ▁linear ▁; ▁c ▁-> ▁filter _ length ▁= ▁FF MAX ▁( ▁( ▁int ▁) ▁ceil ▁( ▁filter _ size ▁/ ▁factor ▁) ▁, ▁1 ▁) ▁; ▁c ▁-> ▁filter _ bank ▁= ▁av _ malloc z ▁( ▁c ▁-> ▁filter _ length ▁* ▁( ▁phase _ count ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁F ELEM ▁) ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁filter _ bank ▁) ▁goto ▁error ▁; ▁if ▁( ▁build _ filter ▁( ▁c ▁-> ▁filter _ bank ▁, ▁factor ▁, ▁c ▁-> ▁filter _ length ▁, ▁phase _ count ▁, ▁1 ▁<< ▁FILTER _ SHIFT ▁, ▁WINDOW _ TYPE ▁) ▁) ▁goto ▁error ▁; ▁memcpy ▁( ▁& ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁* ▁phase _ count ▁+ ▁1 ▁] ▁, ▁c ▁-> ▁filter _ bank ▁, ▁( ▁c ▁-> ▁filter _ length ▁- ▁1 ▁) ▁* ▁sizeof ▁( ▁F ELEM ▁) ▁) ▁; ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁* ▁phase _ count ▁] ▁= ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁- ▁1 ▁] ▁; ▁if ▁( ▁! ▁av _ reduce ▁( ▁& ▁c ▁-> ▁src _ incr ▁, ▁& ▁c ▁-> ▁dst _ incr ▁, ▁out _ rate ▁, ▁in _ rate ▁* ▁( ▁int 64_ t ▁) ▁phase _ count ▁, ▁INT 32_ MAX ▁/ ▁2 ▁) ▁) ▁goto ▁error ▁; ▁c ▁-> ▁ideal _ dst _ incr ▁= ▁c ▁-> ▁dst _ incr ▁; ▁c ▁-> ▁index ▁= ▁- ▁phase _ count ▁* ▁( ▁( ▁c ▁-> ▁filter _ length ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁return ▁c ▁; ▁error ▁: ▁av _ free ▁( ▁c ▁-> ▁filter _ bank ▁) ▁; ▁av _ free ▁( ▁c ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁int ▁pkey _ GO ST 94 cc _ decrypt ▁( ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁, ▁unsigned ▁char ▁* ▁key ▁, ▁size _ t ▁* ▁key _ len ▁, ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁size _ t ▁in _ len ▁) ▁{ ▁GOST _ KEY _ TRANSPORT ▁* ▁g kt ▁= ▁NULL ▁; ▁const ▁unsigned ▁char ▁* ▁p ▁= ▁in ▁; ▁unsigned ▁char ▁shared _ key ▁[ ▁32 ▁] ▁; ▁unsigned ▁char ▁hmac ▁[ ▁4 ▁] ▁, ▁hmac _ comp ▁[ ▁4 ▁] ▁; ▁unsigned ▁char ▁iv ▁[ ▁8 ▁] ▁; ▁int ▁i ▁; ▁const ▁struct ▁g ost _ cipher _ info ▁* ▁cipher _ info ▁; ▁g ost _ ctx ▁ctx ▁; ▁DH ▁* ▁dh ▁= ▁DH _ new ▁( ▁) ▁; ▁EVP _ PKEY ▁* ▁e ph _ key ▁; ▁EVP _ PKEY ▁* ▁priv ▁= ▁EVP _ PKEY _ CTX _ get 0_ pkey ▁( ▁pctx ▁) ▁; ▁if ▁( ▁! ▁key ▁) ▁{ ▁* ▁key _ len ▁= ▁32 ▁; ▁return ▁1 ▁; ▁} ▁dh ▁-> ▁g ▁= ▁BN _ dup ▁( ▁priv ▁-> ▁pkey ▁. ▁dsa ▁-> ▁g ▁) ▁; ▁dh ▁-> ▁p ▁= ▁BN _ dup ▁( ▁priv ▁-> ▁pkey ▁. ▁dsa ▁-> ▁p ▁) ▁; ▁dh ▁-> ▁priv _ key ▁= ▁BN _ dup ▁( ▁priv ▁-> ▁pkey ▁. ▁dsa ▁-> ▁priv _ key ▁) ▁; ▁g kt ▁= ▁d 2 i _ GO ST _ KEY _ TRANSPORT ▁( ▁NULL ▁, ▁( ▁const ▁unsigned ▁char ▁* ▁* ▁) ▁& ▁p ▁, ▁in _ len ▁) ▁; ▁if ▁( ▁! ▁g kt ▁) ▁{ ▁GOST err ▁( ▁GOST _ F _ PKEY _ GO ST 94 CC _ DECRYPT ▁, ▁GOST _ R _ ERROR _ PAR SING _ KEY _ TRANSPORT _ INFO ▁) ▁; ▁DH _ free ▁( ▁dh ▁) ▁; ▁return ▁0 ▁; ▁} ▁e ph _ key ▁= ▁X 509_ PUB KEY _ get ▁( ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁ep hem _ key ▁) ▁; ▁OPENSSL _ assert ▁( ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁e ph _ iv ▁-> ▁length ▁== ▁8 ▁) ▁; ▁memcpy ▁( ▁iv ▁, ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁e ph _ iv ▁-> ▁data ▁, ▁8 ▁) ▁; ▁OPENSSL _ assert ▁( ▁g kt ▁-> ▁key _ info ▁-> ▁i mit ▁-> ▁length ▁== ▁4 ▁) ▁; ▁memcpy ▁( ▁hmac ▁, ▁g kt ▁-> ▁key _ info ▁-> ▁i mit ▁-> ▁data ▁, ▁4 ▁) ▁; ▁i ▁= ▁make _ g ost _ shared _ key ▁( ▁dh ▁, ▁e ph _ key ▁, ▁shared _ key ▁) ▁; ▁EVP _ PKEY _ free ▁( ▁e ph _ key ▁) ▁; ▁DH _ free ▁( ▁dh ▁) ▁; ▁if ▁( ▁! ▁i ▁) ▁{ ▁GOST err ▁( ▁GOST _ F _ PKEY _ GO ST 94 CC _ DECRYPT ▁, ▁GOST _ R _ ERROR _ COMP UT ING _ SHARED _ KEY ▁) ▁; ▁GOST _ KEY _ TRANSPORT _ free ▁( ▁g kt ▁) ▁; ▁return ▁0 ▁; ▁} ▁cipher _ info ▁= ▁get _ encryption _ params ▁( ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁cipher ▁) ▁; ▁g ost _ init ▁( ▁& ▁ctx ▁, ▁cipher _ info ▁-> ▁sb lock ▁) ▁; ▁g ost _ key ▁( ▁& ▁ctx ▁, ▁shared _ key ▁) ▁; ▁if ▁( ▁! ▁decrypt _ crypto com _ key ▁( ▁key ▁, ▁* ▁key _ len ▁, ▁g kt ▁-> ▁key _ info ▁-> ▁encrypted _ key ▁-> ▁data ▁, ▁g kt ▁-> ▁key _ info ▁-> ▁encrypted _ key ▁-> ▁length ▁, ▁& ▁ctx ▁) ▁) ▁{ ▁GOST _ KEY _ TRANSPORT _ free ▁( ▁g kt ▁) ▁; ▁return ▁0 ▁; ▁} ▁GOST _ KEY _ TRANSPORT _ free ▁( ▁g kt ▁) ▁; ▁if ▁( ▁! ▁g ost _ mac ▁( ▁& ▁ctx ▁, ▁32 ▁, ▁key ▁, ▁32 ▁, ▁hmac _ comp ▁) ▁) ▁{ ▁GOST err ▁( ▁GOST _ F _ PKEY _ GO ST 94 CC _ DECRYPT ▁, ▁GOST _ R _ ERROR _ COMP UT ING _ MAC ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁memcmp ▁( ▁hmac ▁, ▁hmac _ comp ▁, ▁4 ▁) ▁!= ▁0 ▁) ▁{ ▁GOST err ▁( ▁GOST _ F _ PKEY _ GO ST 94 CC _ DECRYPT ▁, ▁GOST _ R _ SESSION _ KEY _ MAC _ DOES _ NOT _ MATCH ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁fl ac _ write _ block _ comment ▁( ▁AVIO Context ▁* ▁pb ▁, ▁AV Dictionary ▁* ▁* ▁m ▁, ▁int ▁last _ block ▁, ▁int ▁bit exact ▁) ▁{ ▁const ▁char ▁* ▁vendor ▁= ▁bit exact ▁? ▁" ff mpeg " ▁: ▁LIB AV FORMAT _ IDENT ▁; ▁int 64_ t ▁len ▁; ▁uint 8_ t ▁* ▁p ▁, ▁* ▁p 0 ▁; ▁ff _ metadata _ conv ▁( ▁m ▁, ▁ff _ vorbis comment _ metadata _ conv ▁, ▁NULL ▁) ▁; ▁len ▁= ▁ff _ vorbis comment _ length ▁( ▁* ▁m ▁, ▁vendor ▁) ▁; ▁if ▁( ▁len ▁>= ▁( ▁( ▁1 ▁<< ▁24 ▁) ▁- ▁4 ▁) ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁p 0 ▁= ▁av _ malloc ▁( ▁len ▁+ ▁4 ▁) ▁; ▁if ▁( ▁! ▁p 0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁p ▁= ▁p 0 ▁; ▁bytestream _ put _ byte ▁( ▁& ▁p ▁, ▁last _ block ▁? ▁0 x 84 ▁: ▁0 x 04 ▁) ▁; ▁bytestream _ put _ be 24 ▁( ▁& ▁p ▁, ▁len ▁) ▁; ▁ff _ vorbis comment _ write ▁( ▁& ▁p ▁, ▁m ▁, ▁vendor ▁) ▁; ▁avio _ write ▁( ▁pb ▁, ▁p 0 ▁, ▁len ▁+ ▁4 ▁) ▁; ▁av _ freep ▁( ▁& ▁p 0 ▁) ▁; ▁p ▁= ▁NULL ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁blake 2 b _ init _ param ▁( ▁BLAKE 2 B _ CTX ▁* ▁S ▁, ▁const ▁BLAKE 2 B _ PARAM ▁* ▁P ▁) ▁{ ▁size _ t ▁i ▁; ▁const ▁uint 8_ t ▁* ▁p ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁( ▁P ▁) ▁; ▁blake 2 b _ init 0 ▁( ▁S ▁) ▁; ▁OPENSSL _ assert ▁( ▁sizeof ▁( ▁BLAKE 2 B _ PARAM ▁) ▁== ▁64 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁++ ▁i ▁) ▁{ ▁S ▁-> ▁h ▁[ ▁i ▁] ▁ ^ = ▁load 64 ▁( ▁p ▁+ ▁sizeof ▁( ▁S ▁-> ▁h ▁[ ▁i ▁] ▁) ▁* ▁i ▁) ▁; ▁} ▁}	0
▁static ▁int ▁yuv 4_ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁char ▁header ▁[ ▁MAX _ YUV 4_ HEADER ▁+ ▁10 ▁] ▁; ▁char ▁* ▁tok start ▁, ▁* ▁tok end ▁, ▁* ▁header _ end ▁; ▁int ▁i ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int ▁width ▁= ▁-1 ▁, ▁height ▁= ▁-1 ▁, ▁rat en ▁= ▁0 ▁, ▁r ated ▁= ▁0 ▁, ▁aspect n ▁= ▁0 ▁, ▁aspect d ▁= ▁0 ▁; ▁enum ▁AV PixelFormat ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ NONE ▁, ▁alt _ pix _ fmt ▁= ▁AV _ PIX _ FMT _ NONE ▁; ▁enum ▁AV Ch roma Location ▁chroma _ sample _ location ▁= ▁AV CH RO MA _ LOC _ UNSPEC IFIED ▁; ▁AVStream ▁* ▁st ▁; ▁enum ▁AV Field Order ▁field _ order ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ YUV 4_ HEADER ▁; ▁i ▁++ ▁) ▁{ ▁header ▁[ ▁i ▁] ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁if ▁( ▁header ▁[ ▁i ▁] ▁== ▁' ▁\ n ▁' ▁) ▁{ ▁header ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁0 x 20 ▁; ▁header ▁[ ▁i ▁+ ▁2 ▁] ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁i ▁== ▁MAX _ YUV 4_ HEADER ▁) ▁return ▁-1 ▁; ▁if ▁( ▁strncmp ▁( ▁header ▁, ▁Y 4 M _ MAGIC ▁, ▁strlen ▁( ▁Y 4 M _ MAGIC ▁) ▁) ▁) ▁return ▁-1 ▁; ▁header _ end ▁= ▁& ▁header ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁for ▁( ▁tok start ▁= ▁& ▁header ▁[ ▁strlen ▁( ▁Y 4 M _ MAGIC ▁) ▁+ ▁1 ▁] ▁; ▁tok start ▁< ▁header _ end ▁; ▁tok start ▁++ ▁) ▁{ ▁if ▁( ▁* ▁tok start ▁== ▁0 x 20 ▁) ▁continue ▁; ▁switch ▁( ▁* ▁tok start ▁++ ▁) ▁{ ▁case ▁' ▁' ▁: ▁width ▁= ▁strtol ▁( ▁tok start ▁, ▁& ▁tok end ▁, ▁10 ▁) ▁; ▁tok start ▁= ▁tok end ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁height ▁= ▁strtol ▁( ▁tok start ▁, ▁& ▁tok end ▁, ▁10 ▁) ▁; ▁tok start ▁= ▁tok end ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁if ▁( ▁strncmp ▁( ▁"4 20 jpeg " ▁, ▁tok start ▁, ▁7 ▁) ▁== ▁0 ▁) ▁{ ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁chroma _ sample _ location ▁= ▁AV CH RO MA _ LOC _ CENTER ▁; ▁} ▁else ▁if ▁( ▁strncmp ▁( ▁"4 20 mpeg 2" ▁, ▁tok start ▁, ▁8 ▁) ▁== ▁0 ▁) ▁{ ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁chroma _ sample _ location ▁= ▁AV CH RO MA _ LOC _ LEFT ▁; ▁} ▁else ▁if ▁( ▁strncmp ▁( ▁"4 20 pal dv " ▁, ▁tok start ▁, ▁8 ▁) ▁== ▁0 ▁) ▁{ ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁chroma _ sample _ location ▁= ▁AV CH RO MA _ LOC _ TOP LEFT ▁; ▁} ▁else ▁if ▁( ▁strncmp ▁( ▁"4 20" ▁, ▁tok start ▁, ▁3 ▁) ▁== ▁0 ▁) ▁{ ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁chroma _ sample _ location ▁= ▁AV CH RO MA _ LOC _ CENTER ▁; ▁} ▁else ▁if ▁( ▁strncmp ▁( ▁"4 11" ▁, ▁tok start ▁, ▁3 ▁) ▁== ▁0 ▁) ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 411 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁" 42 2" ▁, ▁tok start ▁, ▁3 ▁) ▁== ▁0 ▁) ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 422 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁" 444 alpha " ▁, ▁tok start ▁, ▁8 ▁) ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cannot handle 4 :4 :4 : 4" ▁" YUV 4 MPEG stream .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁strncmp ▁( ▁" 44 4" ▁, ▁tok start ▁, ▁3 ▁) ▁== ▁0 ▁) ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 444 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁" mono " ▁, ▁tok start ▁, ▁4 ▁) ▁== ▁0 ▁) ▁{ ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ GRAY 8 ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" YUV 4 MPEG stream contains an unknown " ▁" pixel format .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁while ▁( ▁tok start ▁< ▁header _ end ▁&& ▁* ▁tok start ▁!= ▁0 x 20 ▁) ▁tok start ▁++ ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁switch ▁( ▁* ▁tok start ▁++ ▁) ▁{ ▁case ▁' ▁' ▁: ▁field _ order ▁= ▁AV _ FIELD _ UNKNOWN ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁field _ order ▁= ▁AV _ FIELD _ PROGRESS IVE ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁field _ order ▁= ▁AV _ FIELD _ TT ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁field _ order ▁= ▁AV _ FIELD _ BB ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" YUV 4 MPEG stream contain sm ixed " ▁" inter l aced and non - inter l aced frames .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" YUV 4 MPEG has invalid header .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁break ▁; ▁case ▁' ▁' ▁: ▁sscanf ▁( ▁tok start ▁, ▁"% d :% d " ▁, ▁& ▁rat en ▁, ▁& ▁r ated ▁) ▁; ▁while ▁( ▁tok start ▁< ▁header _ end ▁&& ▁* ▁tok start ▁!= ▁0 x 20 ▁) ▁tok start ▁++ ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁sscanf ▁( ▁tok start ▁, ▁"% d :% d " ▁, ▁& ▁aspect n ▁, ▁& ▁aspect d ▁) ▁; ▁while ▁( ▁tok start ▁< ▁header _ end ▁&& ▁* ▁tok start ▁!= ▁0 x 20 ▁) ▁tok start ▁++ ▁; ▁break ▁; ▁case ▁' ▁' ▁: ▁if ▁( ▁strncmp ▁( ▁" Y SC SS =" ▁, ▁tok start ▁, ▁6 ▁) ▁== ▁0 ▁) ▁{ ▁tok start ▁+= ▁6 ▁; ▁if ▁( ▁strncmp ▁( ▁"4 20 JPEG " ▁, ▁tok start ▁, ▁7 ▁) ▁== ▁0 ▁) ▁alt _ pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁"4 20 MPEG 2" ▁, ▁tok start ▁, ▁8 ▁) ▁== ▁0 ▁) ▁alt _ pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁"4 20 PAL DV " ▁, ▁tok start ▁, ▁8 ▁) ▁== ▁0 ▁) ▁alt _ pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁"4 11" ▁, ▁tok start ▁, ▁3 ▁) ▁== ▁0 ▁) ▁alt _ pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 411 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁" 42 2" ▁, ▁tok start ▁, ▁3 ▁) ▁== ▁0 ▁) ▁alt _ pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 422 P ▁; ▁else ▁if ▁( ▁strncmp ▁( ▁" 44 4" ▁, ▁tok start ▁, ▁3 ▁) ▁== ▁0 ▁) ▁alt _ pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 444 P ▁; ▁} ▁while ▁( ▁tok start ▁< ▁header _ end ▁&& ▁* ▁tok start ▁!= ▁0 x 20 ▁) ▁tok start ▁++ ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁width ▁== ▁-1 ▁|| ▁height ▁== ▁-1 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" YUV 4 MPEG has invalid header .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ NONE ▁) ▁{ ▁if ▁( ▁alt _ pix _ fmt ▁== ▁AV _ PIX _ FMT _ NONE ▁) ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁else ▁pix _ fmt ▁= ▁alt _ pix _ fmt ▁; ▁} ▁if ▁( ▁rat en ▁<= ▁0 ▁|| ▁r ated ▁<= ▁0 ▁) ▁{ ▁rat en ▁= ▁25 ▁; ▁r ated ▁= ▁1 ▁; ▁} ▁if ▁( ▁aspect n ▁== ▁0 ▁&& ▁aspect d ▁== ▁0 ▁) ▁{ ▁aspect d ▁= ▁1 ▁; ▁} ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁width ▁= ▁width ▁; ▁st ▁-> ▁codec ▁-> ▁height ▁= ▁height ▁; ▁av _ reduce ▁( ▁& ▁rat en ▁, ▁& ▁r ated ▁, ▁rat en ▁, ▁r ated ▁, ▁( ▁1 UL ▁<< ▁31 ▁) ▁- ▁1 ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁r ated ▁, ▁rat en ▁) ▁; ▁st ▁-> ▁avg _ frame _ rate ▁= ▁av _ inv _ q ▁( ▁st ▁-> ▁time _ base ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁pix _ fmt ▁= ▁pix _ fmt ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ VIDEO ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ RAW VIDEO ▁; ▁st ▁-> ▁sample _ aspect _ ratio ▁= ▁( ▁AVR ational ▁) ▁{ ▁aspect n ▁, ▁aspect d ▁} ▁; ▁st ▁-> ▁codec ▁-> ▁chroma _ sample _ location ▁= ▁chroma _ sample _ location ▁; ▁st ▁-> ▁codec ▁-> ▁field _ order ▁= ▁field _ order ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁sb r _ de quant ▁( ▁S pectral Band Replication ▁* ▁sb r ▁, ▁int ▁id _ aac ▁) ▁{ ▁int ▁k ▁, ▁e ▁; ▁int ▁ch ▁; ▁if ▁( ▁id _ aac ▁== ▁TYPE _ C PE ▁&& ▁sb r ▁-> ▁bs _ coup ling ▁) ▁{ ▁int ▁alpha ▁= ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁bs _ amp _ res ▁? ▁2 ▁: ▁1 ▁; ▁int ▁pan _ offset ▁= ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁bs _ amp _ res ▁? ▁12 ▁: ▁24 ▁; ▁for ▁( ▁e ▁= ▁1 ▁; ▁e ▁<= ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁bs _ num _ env ▁; ▁e ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁sb r ▁-> ▁n ▁[ ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁bs _ freq _ res ▁[ ▁e ▁] ▁] ▁; ▁k ▁++ ▁) ▁{ ▁Soft Float ▁temp 1 ▁, ▁temp 2 ▁, ▁fac ▁; ▁temp 1 ▁. ▁exp ▁= ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁env _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁. ▁mant ▁* ▁alpha ▁+ ▁14 ▁; ▁if ▁( ▁temp 1 ▁. ▁exp ▁& ▁1 ▁) ▁temp 1 ▁. ▁mant ▁= ▁7 59 25 01 25 ▁; ▁else ▁temp 1 ▁. ▁mant ▁= ▁0 x 20000000 ▁; ▁temp 1 ▁. ▁exp ▁= ▁( ▁temp 1 ▁. ▁exp ▁>> ▁1 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁temp 1 ▁. ▁exp ▁> ▁66 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" en velop escale factor overflow inde quant \ n " ▁) ▁; ▁temp 1 ▁= ▁FLOAT _1 ▁; ▁} ▁temp 2 ▁. ▁exp ▁= ▁( ▁pan _ offset ▁- ▁sb r ▁-> ▁data ▁[ ▁1 ▁] ▁. ▁env _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁. ▁mant ▁) ▁* ▁alpha ▁; ▁if ▁( ▁temp 2 ▁. ▁exp ▁& ▁1 ▁) ▁temp 2 ▁. ▁mant ▁= ▁7 59 25 01 25 ▁; ▁else ▁temp 2 ▁. ▁mant ▁= ▁0 x 20000000 ▁; ▁temp 2 ▁. ▁exp ▁= ▁( ▁temp 2 ▁. ▁exp ▁>> ▁1 ▁) ▁+ ▁1 ▁; ▁fac ▁= ▁av _ div _ sf ▁( ▁temp 1 ▁, ▁av _ add _ sf ▁( ▁FLOAT _1 ▁, ▁temp 2 ▁) ▁) ▁; ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁env _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁= ▁fac ▁; ▁sb r ▁-> ▁data ▁[ ▁1 ▁] ▁. ▁env _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁= ▁av _ mul _ sf ▁( ▁fac ▁, ▁temp 2 ▁) ▁; ▁} ▁} ▁for ▁( ▁e ▁= ▁1 ▁; ▁e ▁<= ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁bs _ num _ noise ▁; ▁e ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁sb r ▁-> ▁n _ q ▁; ▁k ▁++ ▁) ▁{ ▁Soft Float ▁temp 1 ▁, ▁temp 2 ▁, ▁fac ▁; ▁temp 1 ▁. ▁exp ▁= ▁NO ISE _ F LO OR _ OFFSET ▁- ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁noise _ f acs _ q ▁[ ▁e ▁] ▁[ ▁k ▁] ▁+ ▁2 ▁; ▁temp 1 ▁. ▁mant ▁= ▁0 x 20000000 ▁; ▁if ▁( ▁temp 1 ▁. ▁exp ▁> ▁66 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" en velop escale factor overflow inde quant \ n " ▁) ▁; ▁temp 1 ▁= ▁FLOAT _1 ▁; ▁} ▁temp 2 ▁. ▁exp ▁= ▁12 ▁- ▁sb r ▁-> ▁data ▁[ ▁1 ▁] ▁. ▁noise _ f acs _ q ▁[ ▁e ▁] ▁[ ▁k ▁] ▁+ ▁1 ▁; ▁temp 2 ▁. ▁mant ▁= ▁0 x 20000000 ▁; ▁fac ▁= ▁av _ div _ sf ▁( ▁temp 1 ▁, ▁av _ add _ sf ▁( ▁FLOAT _1 ▁, ▁temp 2 ▁) ▁) ▁; ▁sb r ▁-> ▁data ▁[ ▁0 ▁] ▁. ▁noise _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁= ▁fac ▁; ▁sb r ▁-> ▁data ▁[ ▁1 ▁] ▁. ▁noise _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁= ▁av _ mul _ sf ▁( ▁fac ▁, ▁temp 2 ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁( ▁id _ aac ▁== ▁TYPE _ C PE ▁) ▁+ ▁1 ▁; ▁ch ▁++ ▁) ▁{ ▁int ▁alpha ▁= ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁bs _ amp _ res ▁? ▁2 ▁: ▁1 ▁; ▁for ▁( ▁e ▁= ▁1 ▁; ▁e ▁<= ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁bs _ num _ env ▁; ▁e ▁++ ▁) ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁sb r ▁-> ▁n ▁[ ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁bs _ freq _ res ▁[ ▁e ▁] ▁] ▁; ▁k ▁++ ▁) ▁{ ▁Soft Float ▁temp 1 ▁; ▁temp 1 ▁. ▁exp ▁= ▁alpha ▁* ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁env _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁. ▁mant ▁+ ▁12 ▁; ▁if ▁( ▁temp 1 ▁. ▁exp ▁& ▁1 ▁) ▁temp 1 ▁. ▁mant ▁= ▁7 59 25 01 25 ▁; ▁else ▁temp 1 ▁. ▁mant ▁= ▁0 x 20000000 ▁; ▁temp 1 ▁. ▁exp ▁= ▁( ▁temp 1 ▁. ▁exp ▁>> ▁1 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁temp 1 ▁. ▁exp ▁> ▁66 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" en velop escale factor overflow inde quant \ n " ▁) ▁; ▁temp 1 ▁= ▁FLOAT _1 ▁; ▁} ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁env _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁= ▁temp 1 ▁; ▁} ▁for ▁( ▁e ▁= ▁1 ▁; ▁e ▁<= ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁bs _ num _ noise ▁; ▁e ▁++ ▁) ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁sb r ▁-> ▁n _ q ▁; ▁k ▁++ ▁) ▁{ ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁noise _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁. ▁exp ▁= ▁NO ISE _ F LO OR _ OFFSET ▁- ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁noise _ f acs _ q ▁[ ▁e ▁] ▁[ ▁k ▁] ▁+ ▁1 ▁; ▁sb r ▁-> ▁data ▁[ ▁ch ▁] ▁. ▁noise _ f acs ▁[ ▁e ▁] ▁[ ▁k ▁] ▁. ▁mant ▁= ▁0 x 20000000 ▁; ▁} ▁} ▁} ▁}	0
▁static ▁void ▁apply _ un sh arp ▁( ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁dst _ stride ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁int ▁src _ stride ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁Filter Param ▁* ▁fp ▁) ▁{ ▁uint 32_ t ▁* ▁* ▁sc ▁= ▁fp ▁-> ▁sc ▁; ▁uint 32_ t ▁sr ▁[ ▁( ▁MAX _ SIZE ▁* ▁MAX _ SIZE ▁) ▁- ▁1 ▁] ▁, ▁tmp 1 ▁, ▁tmp 2 ▁; ▁int 32_ t ▁res ▁; ▁int ▁x ▁, ▁y ▁, ▁z ▁; ▁const ▁uint 8_ t ▁* ▁src 2 ▁= ▁NULL ▁; ▁if ▁( ▁! ▁fp ▁-> ▁amount ▁) ▁{ ▁if ▁( ▁dst _ stride ▁== ▁src _ stride ▁) ▁memcpy ▁( ▁dst ▁, ▁src ▁, ▁src _ stride ▁* ▁height ▁) ▁; ▁else ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁++ ▁, ▁dst ▁+= ▁dst _ stride ▁, ▁src ▁+= ▁src _ stride ▁) ▁memcpy ▁( ▁dst ▁, ▁src ▁, ▁width ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁2 ▁* ▁fp ▁-> ▁steps _ y ▁; ▁y ▁++ ▁) ▁memset ▁( ▁sc ▁[ ▁y ▁] ▁, ▁0 ▁, ▁sizeof ▁( ▁sc ▁[ ▁y ▁] ▁[ ▁0 ▁] ▁) ▁* ▁( ▁width ▁+ ▁2 ▁* ▁fp ▁-> ▁steps _ x ▁) ▁) ▁; ▁for ▁( ▁y ▁= ▁- ▁fp ▁-> ▁steps _ y ▁; ▁y ▁< ▁height ▁+ ▁fp ▁-> ▁steps _ y ▁; ▁y ▁++ ▁) ▁{ ▁if ▁( ▁y ▁< ▁height ▁) ▁src 2 ▁= ▁src ▁; ▁memset ▁( ▁sr ▁, ▁0 ▁, ▁sizeof ▁( ▁sr ▁[ ▁0 ▁] ▁) ▁* ▁( ▁2 ▁* ▁fp ▁-> ▁steps _ x ▁- ▁1 ▁) ▁) ▁; ▁for ▁( ▁x ▁= ▁- ▁fp ▁-> ▁steps _ x ▁; ▁x ▁< ▁width ▁+ ▁fp ▁-> ▁steps _ x ▁; ▁x ▁++ ▁) ▁{ ▁tmp 1 ▁= ▁x ▁<= ▁0 ▁? ▁src 2 ▁[ ▁0 ▁] ▁: ▁x ▁>= ▁width ▁? ▁src 2 ▁[ ▁width ▁- ▁1 ▁] ▁: ▁src 2 ▁[ ▁x ▁] ▁; ▁for ▁( ▁z ▁= ▁0 ▁; ▁z ▁< ▁fp ▁-> ▁steps _ x ▁* ▁2 ▁; ▁z ▁+= ▁2 ▁) ▁{ ▁tmp 2 ▁= ▁sr ▁[ ▁z ▁+ ▁0 ▁] ▁+ ▁tmp 1 ▁; ▁sr ▁[ ▁z ▁+ ▁0 ▁] ▁= ▁tmp 1 ▁; ▁tmp 1 ▁= ▁sr ▁[ ▁z ▁+ ▁1 ▁] ▁+ ▁tmp 2 ▁; ▁sr ▁[ ▁z ▁+ ▁1 ▁] ▁= ▁tmp 2 ▁; ▁} ▁for ▁( ▁z ▁= ▁0 ▁; ▁z ▁< ▁fp ▁-> ▁steps _ y ▁* ▁2 ▁; ▁z ▁+= ▁2 ▁) ▁{ ▁tmp 2 ▁= ▁sc ▁[ ▁z ▁+ ▁0 ▁] ▁[ ▁x ▁+ ▁fp ▁-> ▁steps _ x ▁] ▁+ ▁tmp 1 ▁; ▁sc ▁[ ▁z ▁+ ▁0 ▁] ▁[ ▁x ▁+ ▁fp ▁-> ▁steps _ x ▁] ▁= ▁tmp 1 ▁; ▁tmp 1 ▁= ▁sc ▁[ ▁z ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁fp ▁-> ▁steps _ x ▁] ▁+ ▁tmp 2 ▁; ▁sc ▁[ ▁z ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁fp ▁-> ▁steps _ x ▁] ▁= ▁tmp 2 ▁; ▁} ▁if ▁( ▁x ▁>= ▁fp ▁-> ▁steps _ x ▁&& ▁y ▁>= ▁fp ▁-> ▁steps _ y ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁sr x ▁= ▁src ▁- ▁fp ▁-> ▁steps _ y ▁* ▁src _ stride ▁+ ▁x ▁- ▁fp ▁-> ▁steps _ x ▁; ▁uint 8_ t ▁* ▁ds x ▁= ▁dst ▁- ▁fp ▁-> ▁steps _ y ▁* ▁dst _ stride ▁+ ▁x ▁- ▁fp ▁-> ▁steps _ x ▁; ▁res ▁= ▁( ▁int 32_ t ▁) ▁* ▁sr x ▁+ ▁( ▁( ▁( ▁( ▁int 32_ t ▁) ▁* ▁sr x ▁- ▁( ▁int 32_ t ▁) ▁( ▁( ▁tmp 1 ▁+ ▁fp ▁-> ▁half scale ▁) ▁>> ▁fp ▁-> ▁scale bits ▁) ▁) ▁* ▁fp ▁-> ▁amount ▁) ▁>> ▁16 ▁) ▁; ▁* ▁ds x ▁= ▁av _ clip _ uint 8 ▁( ▁res ▁) ▁; ▁} ▁} ▁if ▁( ▁y ▁>= ▁0 ▁) ▁{ ▁dst ▁+= ▁dst _ stride ▁; ▁src ▁+= ▁src _ stride ▁; ▁} ▁} ▁}	0
▁static ▁int ▁read Separ ate Stri ps Into Buffer ▁( ▁TIFF ▁* ▁in ▁, ▁uint 8 ▁* ▁obuf ▁, ▁uint 32 ▁length ▁, ▁uint 32 ▁width ▁, ▁uint 16 ▁s pp ▁, ▁struct ▁dump _ opts ▁* ▁dump ▁) ▁{ ▁int ▁i ▁, ▁bytes _ per _ sample ▁, ▁bytes _ per _ pixel ▁, ▁shift _ width ▁, ▁result ▁= ▁1 ▁; ▁uint 32 ▁j ▁; ▁int 32 ▁bytes _ read ▁= ▁0 ▁; ▁uint 16 ▁bps ▁= ▁0 ▁, ▁plan ar ▁; ▁uint 32 ▁n stri ps ▁; ▁uint 32 ▁stri ps _ per _ sample ▁; ▁uint 32 ▁src _ rows ize ▁, ▁dst _ rows ize ▁, ▁rows _ processed ▁, ▁r ps ▁; ▁uint 32 ▁rows _ this _ strip ▁= ▁0 ▁; ▁ts ample _ t ▁s ▁; ▁tst rip _ t ▁strip ▁; ▁tsize _ t ▁scan lines ize ▁= ▁TIFF Scan line Size ▁( ▁in ▁) ▁; ▁tsize _ t ▁strip size ▁= ▁TIFF Strip Size ▁( ▁in ▁) ▁; ▁unsigned ▁char ▁* ▁src buff s ▁[ ▁MAX _ SAMPLES ▁] ▁; ▁unsigned ▁char ▁* ▁buff ▁= ▁NULL ▁; ▁unsigned ▁char ▁* ▁dst ▁= ▁NULL ▁; ▁if ▁( ▁obuf ▁== ▁NULL ▁) ▁{ ▁TIFF Error ▁( ▁" read Separ ate Stri ps Into Buffer " ▁, ▁" Invalid buffer argument " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁memset ▁( ▁src buff s ▁, ▁' ▁\0 ▁' ▁, ▁sizeof ▁( ▁src buff s ▁) ▁) ▁; ▁TIFF Get Field Default ed ▁( ▁in ▁, ▁TIFF TAG _ BIT SP ER SAMPLE ▁, ▁& ▁bps ▁) ▁; ▁TIFF Get Field Default ed ▁( ▁in ▁, ▁TIFF TAG _ PLAN AR CONFIG ▁, ▁& ▁plan ar ▁) ▁; ▁TIFF Get Field Default ed ▁( ▁in ▁, ▁TIFF TAG _ ROW SP ER STRIP ▁, ▁& ▁r ps ▁) ▁; ▁if ▁( ▁r ps ▁> ▁length ▁) ▁r ps ▁= ▁length ▁; ▁bytes _ per _ sample ▁= ▁( ▁bps ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁bytes _ per _ pixel ▁= ▁( ▁( ▁bps ▁* ▁s pp ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁if ▁( ▁bytes _ per _ pixel ▁< ▁( ▁bytes _ per _ sample ▁+ ▁1 ▁) ▁) ▁shift _ width ▁= ▁bytes _ per _ pixel ▁; ▁else ▁shift _ width ▁= ▁bytes _ per _ sample ▁+ ▁1 ▁; ▁src _ rows ize ▁= ▁( ▁( ▁bps ▁* ▁width ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁dst _ rows ize ▁= ▁( ▁( ▁bps ▁* ▁width ▁* ▁s pp ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁dst ▁= ▁obuf ▁; ▁if ▁( ▁( ▁dump ▁-> ▁infile ▁!= ▁NULL ▁) ▁&& ▁( ▁dump ▁-> ▁level ▁== ▁3 ▁) ▁) ▁{ ▁dump _ info ▁( ▁dump ▁-> ▁infile ▁, ▁dump ▁-> ▁format ▁, ▁"" ▁, ▁" Image width % d , length % d , Scan lines ize ,% 4 db ytes " ▁, ▁width ▁, ▁length ▁, ▁scan lines ize ▁) ▁; ▁dump _ info ▁( ▁dump ▁-> ▁infile ▁, ▁dump ▁-> ▁format ▁, ▁"" ▁, ▁" Bits pers ample % d , Samples per pixel % d , Shift width % d " ▁, ▁bps ▁, ▁s pp ▁, ▁shift _ width ▁) ▁; ▁} ▁n stri ps ▁= ▁TIFF NumberOf Stri ps ▁( ▁in ▁) ▁; ▁stri ps _ per _ sample ▁= ▁n stri ps ▁/ ▁s pp ▁; ▁if ▁( ▁( ▁size _ t ▁) ▁strip size ▁> ▁0 xFFFFFFFF U ▁- ▁3 U ▁) ▁{ ▁TIFF Error ▁( ▁" read Separ ate Stri ps Into Buffer " ▁, ▁" Integer over f lo ww hen calc ulating buffers ize ." ▁) ▁; ▁exit ▁( ▁-1 ▁) ▁; ▁} ▁for ▁( ▁s ▁= ▁0 ▁; ▁( ▁s ▁< ▁s pp ▁) ▁&& ▁( ▁s ▁< ▁MAX _ SAMPLES ▁) ▁; ▁s ▁++ ▁) ▁{ ▁src buff s ▁[ ▁s ▁] ▁= ▁NULL ▁; ▁buff ▁= ▁limit Malloc ▁( ▁strip size ▁+ ▁3 ▁) ▁; ▁if ▁( ▁! ▁buff ▁) ▁{ ▁TIFF Error ▁( ▁" read Separ ate Stri ps Into Buffer " ▁, ▁" Unable to allocate strip read buffer f ors ample % d " ▁, ▁s ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁; ▁i ▁++ ▁) ▁_ TIFF free ▁( ▁src buff s ▁[ ▁i ▁] ▁) ▁; ▁return ▁0 ▁; ▁} ▁buff ▁[ ▁strip size ▁] ▁= ▁0 ▁; ▁buff ▁[ ▁strip size ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁buff ▁[ ▁strip size ▁+ ▁2 ▁] ▁= ▁0 ▁; ▁src buff s ▁[ ▁s ▁] ▁= ▁buff ▁; ▁} ▁rows _ processed ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁( ▁j ▁< ▁stri ps _ per _ sample ▁) ▁&& ▁( ▁result ▁== ▁1 ▁) ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁s ▁= ▁0 ▁; ▁( ▁s ▁< ▁s pp ▁) ▁&& ▁( ▁s ▁< ▁MAX _ SAMPLES ▁) ▁; ▁s ▁++ ▁) ▁{ ▁buff ▁= ▁src buff s ▁[ ▁s ▁] ▁; ▁strip ▁= ▁( ▁s ▁* ▁stri ps _ per _ sample ▁) ▁+ ▁j ▁; ▁bytes _ read ▁= ▁TIFF Read Encoded Strip ▁( ▁in ▁, ▁strip ▁, ▁buff ▁, ▁strip size ▁) ▁; ▁rows _ this _ strip ▁= ▁bytes _ read ▁/ ▁src _ rows ize ▁; ▁if ▁( ▁bytes _ read ▁< ▁0 ▁&& ▁! ▁ignore ▁) ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , can ' t read strip % lu f ors ample % d " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁s ▁+ ▁1 ▁) ▁; ▁result ▁= ▁0 ▁; ▁break ▁; ▁} ▁# ifdef ▁DE VEL MODE ▁TIFF Error ▁( ▁"" ▁, ▁" Strip %2 d , read % 5 db ytes for % 4 d scan lines , shift width % d " ▁, ▁strip ▁, ▁bytes _ read ▁, ▁rows _ this _ strip ▁, ▁shift _ width ▁) ▁; ▁# endif ▁} ▁if ▁( ▁r ps ▁> ▁rows _ this _ strip ▁) ▁r ps ▁= ▁rows _ this _ strip ▁; ▁dst ▁= ▁obuf ▁+ ▁( ▁dst _ rows ize ▁* ▁rows _ processed ▁) ▁; ▁if ▁( ▁( ▁bps ▁% ▁8 ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁combine Separ ate Samples Bytes ▁( ▁src buff s ▁, ▁dst ▁, ▁width ▁, ▁r ps ▁, ▁s pp ▁, ▁bps ▁, ▁dump ▁-> ▁infile ▁, ▁dump ▁-> ▁format ▁, ▁dump ▁-> ▁level ▁) ▁) ▁{ ▁result ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁switch ▁( ▁shift _ width ▁) ▁{ ▁case ▁1 ▁: ▁if ▁( ▁combine Separ ate Samples 8 bits ▁( ▁src buff s ▁, ▁dst ▁, ▁width ▁, ▁r ps ▁, ▁s pp ▁, ▁bps ▁, ▁dump ▁-> ▁infile ▁, ▁dump ▁-> ▁format ▁, ▁dump ▁-> ▁level ▁) ▁) ▁{ ▁result ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁case ▁2 ▁: ▁if ▁( ▁combine Separ ate Samples 16 bits ▁( ▁src buff s ▁, ▁dst ▁, ▁width ▁, ▁r ps ▁, ▁s pp ▁, ▁bps ▁, ▁dump ▁-> ▁infile ▁, ▁dump ▁-> ▁format ▁, ▁dump ▁-> ▁level ▁) ▁) ▁{ ▁result ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁case ▁3 ▁: ▁if ▁( ▁combine Separ ate Samples 24 bits ▁( ▁src buff s ▁, ▁dst ▁, ▁width ▁, ▁r ps ▁, ▁s pp ▁, ▁bps ▁, ▁dump ▁-> ▁infile ▁, ▁dump ▁-> ▁format ▁, ▁dump ▁-> ▁level ▁) ▁) ▁{ ▁result ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁case ▁4 ▁: ▁case ▁5 ▁: ▁case ▁6 ▁: ▁case ▁7 ▁: ▁case ▁8 ▁: ▁if ▁( ▁combine Separ ate Samples 32 bits ▁( ▁src buff s ▁, ▁dst ▁, ▁width ▁, ▁r ps ▁, ▁s pp ▁, ▁bps ▁, ▁dump ▁-> ▁infile ▁, ▁dump ▁-> ▁format ▁, ▁dump ▁-> ▁level ▁) ▁) ▁{ ▁result ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁default ▁: ▁TIFF Error ▁( ▁" read Separ ate Stri ps Into Buffer " ▁, ▁" Unsupported bit depth :% d " ▁, ▁bps ▁) ▁; ▁result ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁( ▁rows _ processed ▁+ ▁r ps ▁) ▁> ▁length ▁) ▁{ ▁rows _ processed ▁= ▁length ▁; ▁r ps ▁= ▁length ▁- ▁rows _ processed ▁; ▁} ▁else ▁rows _ processed ▁+= ▁r ps ▁; ▁} ▁for ▁( ▁s ▁= ▁0 ▁; ▁( ▁s ▁< ▁s pp ▁) ▁&& ▁( ▁s ▁< ▁MAX _ SAMPLES ▁) ▁; ▁s ▁++ ▁) ▁{ ▁buff ▁= ▁src buff s ▁[ ▁s ▁] ▁; ▁if ▁( ▁buff ▁!= ▁NULL ▁) ▁_ TIFF free ▁( ▁buff ▁) ▁; ▁} ▁return ▁( ▁result ▁) ▁; ▁}	0
▁static ▁int ▁ogg _ restore ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁struct ▁ogg ▁* ▁ogg ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁bc ▁= ▁s ▁-> ▁pb ▁; ▁struct ▁ogg _ state ▁* ▁o st ▁= ▁ogg ▁-> ▁state ▁; ▁int ▁i ▁, ▁err ▁; ▁if ▁( ▁! ▁o st ▁) ▁return ▁0 ▁; ▁ogg ▁-> ▁state ▁= ▁o st ▁-> ▁next ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ogg ▁-> ▁n streams ▁; ▁i ▁++ ▁) ▁{ ▁av _ freep ▁( ▁& ▁ogg ▁-> ▁streams ▁[ ▁i ▁] ▁. ▁buf ▁) ▁; ▁if ▁( ▁i ▁>= ▁o st ▁-> ▁n streams ▁|| ▁! ▁o st ▁-> ▁streams ▁[ ▁i ▁] ▁. ▁private ▁) ▁{ ▁free _ stream ▁( ▁s ▁, ▁i ▁) ▁; ▁} ▁} ▁avio _ seek ▁( ▁bc ▁, ▁o st ▁-> ▁pos ▁, ▁SEEK _ SET ▁) ▁; ▁ogg ▁-> ▁page _ pos ▁= ▁-1 ▁; ▁ogg ▁-> ▁cur idx ▁= ▁o st ▁-> ▁cur idx ▁; ▁ogg ▁-> ▁n streams ▁= ▁o st ▁-> ▁n streams ▁; ▁if ▁( ▁( ▁err ▁= ▁av _ realloc p _ array ▁( ▁& ▁ogg ▁-> ▁streams ▁, ▁ogg ▁-> ▁n streams ▁, ▁sizeof ▁( ▁* ▁ogg ▁-> ▁streams ▁) ▁) ▁) ▁< ▁0 ▁) ▁{ ▁ogg ▁-> ▁n streams ▁= ▁0 ▁; ▁return ▁err ▁; ▁} ▁else ▁memcpy ▁( ▁ogg ▁-> ▁streams ▁, ▁o st ▁-> ▁streams ▁, ▁o st ▁-> ▁n streams ▁* ▁sizeof ▁( ▁* ▁ogg ▁-> ▁streams ▁) ▁) ▁; ▁av _ free ▁( ▁o st ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁put _ vc 2_ ue _ uint ▁( ▁Put Bit Context ▁* ▁pb ▁, ▁uint 32_ t ▁val ▁) ▁{ ▁int ▁i ▁; ▁int ▁p bits ▁= ▁0 ▁, ▁bits ▁= ▁0 ▁, ▁top bit ▁= ▁1 ▁, ▁maxval ▁= ▁1 ▁; ▁if ▁( ▁! ▁val ▁++ ▁) ▁{ ▁put _ bits ▁( ▁pb ▁, ▁1 ▁, ▁1 ▁) ▁; ▁return ▁; ▁} ▁while ▁( ▁val ▁> ▁maxval ▁) ▁{ ▁top bit ▁<<= ▁1 ▁; ▁maxval ▁<<= ▁1 ▁; ▁maxval ▁|= ▁1 ▁; ▁} ▁bits ▁= ▁ff _ log 2 ▁( ▁top bit ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁bits ▁; ▁i ▁++ ▁) ▁{ ▁top bit ▁>>= ▁1 ▁; ▁p bits ▁<<= ▁2 ▁; ▁if ▁( ▁val ▁& ▁top bit ▁) ▁p bits ▁|= ▁0 x 1 ▁; ▁} ▁put _ bits ▁( ▁pb ▁, ▁bits ▁* ▁2 ▁+ ▁1 ▁, ▁( ▁p bits ▁<< ▁1 ▁) ▁| ▁1 ▁) ▁; ▁}	1
▁static ▁void ▁vc 1_ inv _ trans _4 x 8_ c ▁( ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁linesize ▁, ▁DCT ELEM ▁* ▁block ▁) ▁{ ▁int ▁i ▁; ▁register ▁int ▁t 1 ▁, ▁t 2 ▁, ▁t 3 ▁, ▁t 4 ▁, ▁t 5 ▁, ▁t 6 ▁, ▁t 7 ▁, ▁t 8 ▁; ▁DCT ELEM ▁* ▁src ▁, ▁* ▁dst ▁; ▁const ▁uint 8_ t ▁* ▁cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NEG _ CR OP ▁; ▁src ▁= ▁block ▁; ▁dst ▁= ▁block ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁{ ▁t 1 ▁= ▁17 ▁* ▁( ▁src ▁[ ▁0 ▁] ▁+ ▁src ▁[ ▁2 ▁] ▁) ▁+ ▁4 ▁; ▁t 2 ▁= ▁17 ▁* ▁( ▁src ▁[ ▁0 ▁] ▁- ▁src ▁[ ▁2 ▁] ▁) ▁+ ▁4 ▁; ▁t 3 ▁= ▁22 ▁* ▁src ▁[ ▁1 ▁] ▁+ ▁10 ▁* ▁src ▁[ ▁3 ▁] ▁; ▁t 4 ▁= ▁22 ▁* ▁src ▁[ ▁3 ▁] ▁- ▁10 ▁* ▁src ▁[ ▁1 ▁] ▁; ▁dst ▁[ ▁0 ▁] ▁= ▁( ▁t 1 ▁+ ▁t 3 ▁) ▁>> ▁3 ▁; ▁dst ▁[ ▁1 ▁] ▁= ▁( ▁t 2 ▁- ▁t 4 ▁) ▁>> ▁3 ▁; ▁dst ▁[ ▁2 ▁] ▁= ▁( ▁t 2 ▁+ ▁t 4 ▁) ▁>> ▁3 ▁; ▁dst ▁[ ▁3 ▁] ▁= ▁( ▁t 1 ▁- ▁t 3 ▁) ▁>> ▁3 ▁; ▁src ▁+= ▁8 ▁; ▁dst ▁+= ▁8 ▁; ▁} ▁src ▁= ▁block ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁t 1 ▁= ▁12 ▁* ▁( ▁src ▁[ ▁0 ▁] ▁+ ▁src ▁[ ▁32 ▁] ▁) ▁+ ▁64 ▁; ▁t 2 ▁= ▁12 ▁* ▁( ▁src ▁[ ▁0 ▁] ▁- ▁src ▁[ ▁32 ▁] ▁) ▁+ ▁64 ▁; ▁t 3 ▁= ▁16 ▁* ▁src ▁[ ▁16 ▁] ▁+ ▁6 ▁* ▁src ▁[ ▁48 ▁] ▁; ▁t 4 ▁= ▁6 ▁* ▁src ▁[ ▁16 ▁] ▁- ▁16 ▁* ▁src ▁[ ▁48 ▁] ▁; ▁t 5 ▁= ▁t 1 ▁+ ▁t 3 ▁; ▁t 6 ▁= ▁t 2 ▁+ ▁t 4 ▁; ▁t 7 ▁= ▁t 2 ▁- ▁t 4 ▁; ▁t 8 ▁= ▁t 1 ▁- ▁t 3 ▁; ▁t 1 ▁= ▁16 ▁* ▁src ▁[ ▁8 ▁] ▁+ ▁15 ▁* ▁src ▁[ ▁24 ▁] ▁+ ▁9 ▁* ▁src ▁[ ▁40 ▁] ▁+ ▁4 ▁* ▁src ▁[ ▁56 ▁] ▁; ▁t 2 ▁= ▁15 ▁* ▁src ▁[ ▁8 ▁] ▁- ▁4 ▁* ▁src ▁[ ▁24 ▁] ▁- ▁16 ▁* ▁src ▁[ ▁40 ▁] ▁- ▁9 ▁* ▁src ▁[ ▁56 ▁] ▁; ▁t 3 ▁= ▁9 ▁* ▁src ▁[ ▁8 ▁] ▁- ▁16 ▁* ▁src ▁[ ▁24 ▁] ▁+ ▁4 ▁* ▁src ▁[ ▁40 ▁] ▁+ ▁15 ▁* ▁src ▁[ ▁56 ▁] ▁; ▁t 4 ▁= ▁4 ▁* ▁src ▁[ ▁8 ▁] ▁- ▁9 ▁* ▁src ▁[ ▁24 ▁] ▁+ ▁15 ▁* ▁src ▁[ ▁40 ▁] ▁- ▁16 ▁* ▁src ▁[ ▁56 ▁] ▁; ▁dest ▁[ ▁0 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁0 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 5 ▁+ ▁t 1 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁dest ▁[ ▁1 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁1 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 6 ▁+ ▁t 2 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁dest ▁[ ▁2 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁2 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 7 ▁+ ▁t 3 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁dest ▁[ ▁3 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁3 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 8 ▁+ ▁t 4 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁dest ▁[ ▁4 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁4 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 8 ▁- ▁t 4 ▁+ ▁1 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁dest ▁[ ▁5 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁5 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 7 ▁- ▁t 3 ▁+ ▁1 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁dest ▁[ ▁6 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁6 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 6 ▁- ▁t 2 ▁+ ▁1 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁dest ▁[ ▁7 ▁* ▁linesize ▁] ▁= ▁cm ▁[ ▁dest ▁[ ▁7 ▁* ▁linesize ▁] ▁+ ▁( ▁( ▁t 5 ▁- ▁t 1 ▁+ ▁1 ▁) ▁>> ▁7 ▁) ▁] ▁; ▁src ▁++ ▁; ▁dest ▁++ ▁; ▁} ▁}	1
▁static ▁inline ▁void ▁m cdc ▁( ▁uint 16_ t ▁* ▁dst ▁, ▁uint 16_ t ▁* ▁src ▁, ▁int ▁log 2 w ▁, ▁int ▁h ▁, ▁int ▁stride ▁, ▁int ▁scale ▁, ▁int ▁dc ▁) ▁{ ▁int ▁i ▁; ▁dc ▁*= ▁0 x 100 01 ▁; ▁switch ▁( ▁log 2 w ▁) ▁{ ▁case ▁0 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁; ▁i ▁++ ▁) ▁{ ▁dst ▁[ ▁0 ▁] ▁= ▁scale ▁* ▁src ▁[ ▁0 ▁] ▁+ ▁dc ▁; ▁if ▁( ▁scale ▁) ▁src ▁+= ▁stride ▁; ▁dst ▁+= ▁stride ▁; ▁} ▁break ▁; ▁case ▁1 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁; ▁i ▁++ ▁) ▁{ ▁LE _ C EN TRIC _ MUL ▁( ▁dst ▁, ▁src ▁, ▁scale ▁, ▁dc ▁) ▁; ▁if ▁( ▁scale ▁) ▁src ▁+= ▁stride ▁; ▁dst ▁+= ▁stride ▁; ▁} ▁break ▁; ▁case ▁2 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁; ▁i ▁++ ▁) ▁{ ▁LE _ C EN TRIC _ MUL ▁( ▁dst ▁, ▁src ▁, ▁scale ▁, ▁dc ▁) ▁; ▁LE _ C EN TRIC _ MUL ▁( ▁dst ▁+ ▁2 ▁, ▁src ▁+ ▁2 ▁, ▁scale ▁, ▁dc ▁) ▁; ▁if ▁( ▁scale ▁) ▁src ▁+= ▁stride ▁; ▁dst ▁+= ▁stride ▁; ▁} ▁break ▁; ▁case ▁3 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁; ▁i ▁++ ▁) ▁{ ▁LE _ C EN TRIC _ MUL ▁( ▁dst ▁, ▁src ▁, ▁scale ▁, ▁dc ▁) ▁; ▁LE _ C EN TRIC _ MUL ▁( ▁dst ▁+ ▁2 ▁, ▁src ▁+ ▁2 ▁, ▁scale ▁, ▁dc ▁) ▁; ▁LE _ C EN TRIC _ MUL ▁( ▁dst ▁+ ▁4 ▁, ▁src ▁+ ▁4 ▁, ▁scale ▁, ▁dc ▁) ▁; ▁LE _ C EN TRIC _ MUL ▁( ▁dst ▁+ ▁6 ▁, ▁src ▁+ ▁6 ▁, ▁scale ▁, ▁dc ▁) ▁; ▁if ▁( ▁scale ▁) ▁src ▁+= ▁stride ▁; ▁dst ▁+= ▁stride ▁; ▁} ▁break ▁; ▁default ▁: ▁assert ▁( ▁0 ▁) ▁; ▁} ▁}	1
▁int ▁ASN 1_ STRING _ set ▁( ▁ASN 1_ STRING ▁* ▁str ▁, ▁const ▁void ▁* ▁_ data ▁, ▁int ▁len ▁) ▁{ ▁unsigned ▁char ▁* ▁c ▁; ▁const ▁char ▁* ▁data ▁= ▁_ data ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁{ ▁if ▁( ▁data ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁else ▁len ▁= ▁strlen ▁( ▁data ▁) ▁; ▁} ▁if ▁( ▁( ▁str ▁-> ▁length ▁<= ▁len ▁) ▁|| ▁( ▁str ▁-> ▁data ▁== ▁NULL ▁) ▁) ▁{ ▁c ▁= ▁str ▁-> ▁data ▁; ▁str ▁-> ▁data ▁= ▁OPENSSL _ realloc ▁( ▁c ▁, ▁len ▁+ ▁1 ▁) ▁; ▁if ▁( ▁str ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ STRING _ SET ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁str ▁-> ▁data ▁= ▁c ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁str ▁-> ▁length ▁= ▁len ▁; ▁if ▁( ▁data ▁!= ▁NULL ▁) ▁{ ▁memcpy ▁( ▁str ▁-> ▁data ▁, ▁data ▁, ▁len ▁) ▁; ▁str ▁-> ▁data ▁[ ▁len ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁int ▁ff _ mp v _ common _ init ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁; ▁int ▁nb _ s lices ▁= ▁( ▁HAVE _ THREADS ▁&& ▁s ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁? ▁s ▁-> ▁avctx ▁-> ▁thread _ count ▁: ▁1 ▁; ▁clear _ context ▁( ▁s ▁) ▁; ▁if ▁( ▁s ▁-> ▁encoding ▁&& ▁s ▁-> ▁avctx ▁-> ▁slices ▁) ▁nb _ s lices ▁= ▁s ▁-> ▁avctx ▁-> ▁slices ▁; ▁if ▁( ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁&& ▁! ▁s ▁-> ▁progress ive _ sequence ▁) ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁2 ▁; ▁else ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁15 ▁) ▁/ ▁16 ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ NONE ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" de coding to AV _ PIX _ FMT _ NONE is not supported .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁nb _ s lices ▁> ▁MAX _ THREADS ▁|| ▁( ▁nb _ s lices ▁> ▁s ▁-> ▁mb _ height ▁&& ▁s ▁-> ▁mb _ height ▁) ▁) ▁{ ▁int ▁max _ s lices ▁; ▁if ▁( ▁s ▁-> ▁mb _ height ▁) ▁max _ s lices ▁= ▁FF MIN ▁( ▁MAX _ THREADS ▁, ▁s ▁-> ▁mb _ height ▁) ▁; ▁else ▁max _ s lices ▁= ▁MAX _ THREADS ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" t oom any threads / s lices (% d )," ▁" red uc ing to % d \ n " ▁, ▁nb _ s lices ▁, ▁max _ s lices ▁) ▁; ▁nb _ s lices ▁= ▁max _ s lices ▁; ▁} ▁if ▁( ▁( ▁s ▁-> ▁width ▁|| ▁s ▁-> ▁height ▁) ▁&& ▁av _ image _ check _ size ▁( ▁s ▁-> ▁width ▁, ▁s ▁-> ▁height ▁, ▁0 ▁, ▁s ▁-> ▁avctx ▁) ▁) ▁return ▁-1 ▁; ▁dct _ init ▁( ▁s ▁) ▁; ▁avcodec _ get _ chroma _ sub _ sample ▁( ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁, ▁& ▁s ▁-> ▁chroma _ x _ shift ▁, ▁& ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁picture ▁, ▁MAX _ PICTURE _ COUNT ▁* ▁sizeof ▁( ▁Picture ▁) ▁, ▁fail ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁) ▁goto ▁fail ▁; ▁} ▁s ▁-> ▁next _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁next _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁last _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁last _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁current _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁current _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁new _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁new _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁if ▁( ▁init _ context _ frame ▁( ▁s ▁) ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁parse _ context ▁. ▁state ▁= ▁-1 ▁; ▁s ▁-> ▁context _ initialized ▁= ▁1 ▁; ▁memset ▁( ▁s ▁-> ▁thread _ context ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁thread _ context ▁) ▁) ▁; ▁s ▁-> ▁thread _ context ▁[ ▁0 ▁] ▁= ▁s ▁; ▁if ▁( ▁nb _ s lices ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁) ▁{ ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁= ▁av _ mem dup ▁( ▁s ▁, ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁goto ▁fail ▁; ▁} ▁if ▁( ▁init _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁start _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁end _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁init _ duplicate _ context ▁( ▁s ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁start _ mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁end _ mb _ y ▁= ▁s ▁-> ▁mb _ height ▁; ▁} ▁s ▁-> ▁slice _ context _ count ▁= ▁nb _ s lices ▁; ▁return ▁0 ▁; ▁fail ▁: ▁ff _ mp v _ common _ end ▁( ▁s ▁) ▁; ▁return ▁-1 ▁; ▁}	0
▁static ▁size _ t ▁i 2 c _ i buf ▁( ▁const ▁unsigned ▁char ▁* ▁b ▁, ▁size _ t ▁blen ▁, ▁int ▁neg ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁) ▁{ ▁unsigned ▁int ▁pad ▁= ▁0 ▁; ▁size _ t ▁ret ▁, ▁i ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁pb ▁= ▁0 ▁; ▁if ▁( ▁b ▁!= ▁NULL ▁&& ▁blen ▁) ▁{ ▁ret ▁= ▁blen ▁; ▁i ▁= ▁b ▁[ ▁0 ▁] ▁; ▁if ▁( ▁! ▁neg ▁&& ▁( ▁i ▁> ▁127 ▁) ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁pb ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁neg ▁) ▁{ ▁pb ▁= ▁0 xFF ▁; ▁if ▁( ▁i ▁> ▁128 ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁128 ▁) ▁{ ▁for ▁( ▁pad ▁= ▁0 ▁, ▁i ▁= ▁1 ▁; ▁i ▁< ▁blen ▁; ▁i ▁++ ▁) ▁pad ▁|= ▁b ▁[ ▁i ▁] ▁; ▁pb ▁= ▁pad ▁!= ▁0 ▁? ▁0 xff U ▁: ▁0 ▁; ▁pad ▁= ▁pb ▁& ▁1 ▁; ▁} ▁} ▁ret ▁+= ▁pad ▁; ▁} ▁else ▁{ ▁ret ▁= ▁1 ▁; ▁blen ▁= ▁0 ▁; ▁} ▁if ▁( ▁pp ▁== ▁NULL ▁|| ▁( ▁p ▁= ▁* ▁pp ▁) ▁== ▁NULL ▁) ▁return ▁ret ▁; ▁* ▁p ▁= ▁pb ▁; ▁p ▁+= ▁pad ▁; ▁tw os _ comp lement ▁( ▁p ▁, ▁b ▁, ▁blen ▁, ▁pb ▁) ▁; ▁* ▁pp ▁+= ▁ret ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁av _ cold ▁void ▁set _ band width ▁( ▁AC 3 Encode Context ▁* ▁s ▁, ▁int ▁cutoff ▁) ▁{ ▁int ▁ch ▁, ▁bw _ code ▁; ▁if ▁( ▁cutoff ▁) ▁{ ▁int ▁fb w _ coeffs ▁; ▁cutoff ▁= ▁av _ clip ▁( ▁cutoff ▁, ▁1 ▁, ▁s ▁-> ▁sample _ rate ▁>> ▁1 ▁) ▁; ▁fb w _ coeffs ▁= ▁cutoff ▁* ▁2 ▁* ▁AC 3_ MAX _ COE FS ▁/ ▁s ▁-> ▁sample _ rate ▁; ▁bw _ code ▁= ▁av _ clip ▁( ▁( ▁fb w _ coeffs ▁- ▁73 ▁) ▁/ ▁3 ▁, ▁0 ▁, ▁60 ▁) ▁; ▁} ▁else ▁{ ▁bw _ code ▁= ▁50 ▁; ▁} ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁s ▁-> ▁fb w _ channels ▁; ▁ch ▁++ ▁) ▁{ ▁s ▁-> ▁bandwidth _ code ▁[ ▁ch ▁] ▁= ▁bw _ code ▁; ▁s ▁-> ▁nb _ co efs ▁[ ▁ch ▁] ▁= ▁bw _ code ▁* ▁3 ▁+ ▁73 ▁; ▁} ▁if ▁( ▁s ▁-> ▁l fe _ on ▁) ▁s ▁-> ▁nb _ co efs ▁[ ▁s ▁-> ▁l fe _ channel ▁] ▁= ▁7 ▁; ▁}	1
▁int ▁ssl 3_ get _ req _ cert _ type ▁( ▁SSL ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁p ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁int ▁no strict ▁= ▁1 ▁; ▁unsigned ▁long ▁alg _ k ▁, ▁alg _ a ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁cert ▁-> ▁c types ▁) ▁{ ▁memcpy ▁( ▁p ▁, ▁s ▁-> ▁cert ▁-> ▁c types ▁, ▁s ▁-> ▁cert ▁-> ▁ctype _ num ▁) ▁; ▁return ▁( ▁int ▁) ▁s ▁-> ▁cert ▁-> ▁ctype _ num ▁; ▁} ▁ssl _ set _ sig _ mask ▁( ▁& ▁alg _ a ▁, ▁s ▁, ▁SSL _ SEC OP _ SIG ALG _ MASK ▁) ▁; ▁if ▁( ▁s ▁-> ▁cert ▁-> ▁cert _ flags ▁& ▁SSL _ CERT _ FLAGS _ CHECK _ TLS _ STRICT ▁) ▁no strict ▁= ▁0 ▁; ▁alg _ k ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithm _ m key ▁; ▁# ifndef ▁OPENSSL _ NO _ GO ST ▁if ▁( ▁s ▁-> ▁version ▁>= ▁TLS 1_ VERSION ▁) ▁{ ▁if ▁( ▁alg _ k ▁& ▁SSL _ k GO ST ▁) ▁{ ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁TLS _ CT _ GO ST 94_ SIGN ▁; ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁TLS _ CT _ GO ST 01_ SIGN ▁; ▁return ▁( ▁ret ▁) ▁; ▁} ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DH ▁if ▁( ▁alg _ k ▁& ▁( ▁SSL _ k DH r ▁| ▁SSL _ k D HE ▁) ▁) ▁{ ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁no strict ▁|| ▁! ▁( ▁alg _ a ▁& ▁SSL _ a RSA ▁) ▁) ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁SSL 3_ CT _ RSA _ FIXED _ DH ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DSA ▁if ▁( ▁no strict ▁|| ▁! ▁( ▁alg _ a ▁& ▁SSL _ a DSS ▁) ▁) ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁SSL 3_ CT _ DSS _ FIXED _ DH ▁; ▁# endif ▁} ▁if ▁( ▁( ▁s ▁-> ▁version ▁== ▁SSL 3_ VERSION ▁) ▁&& ▁( ▁alg _ k ▁& ▁( ▁SSL _ k D HE ▁| ▁SSL _ k DH d ▁| ▁SSL _ k DH r ▁) ▁) ▁) ▁{ ▁# ifndef ▁OPENSSL _ NO _ RSA ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁SSL 3_ CT _ RSA _ EP H EM ER AL _ DH ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DSA ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁SSL 3_ CT _ DSS _ EP H EM ER AL _ DH ▁; ▁# endif ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁! ▁( ▁alg _ a ▁& ▁SSL _ a RSA ▁) ▁) ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁SSL 3_ CT _ RSA _ SIGN ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DSA ▁if ▁( ▁! ▁( ▁alg _ a ▁& ▁SSL _ a DSS ▁) ▁) ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁SSL 3_ CT _ DSS _ SIGN ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDH ▁if ▁( ▁( ▁alg _ k ▁& ▁( ▁SSL _ k ECDH r ▁| ▁SSL _ k EC D He ▁) ▁) ▁&& ▁( ▁s ▁-> ▁version ▁>= ▁TLS 1_ VERSION ▁) ▁) ▁{ ▁if ▁( ▁no strict ▁|| ▁! ▁( ▁alg _ a ▁& ▁SSL _ a RSA ▁) ▁) ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁TLS _ CT _ RSA _ FIXED _ ECDH ▁; ▁if ▁( ▁no strict ▁|| ▁! ▁( ▁alg _ a ▁& ▁SSL _ a ECDSA ▁) ▁) ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁TLS _ CT _ ECDSA _ FIXED _ ECDH ▁; ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDSA ▁if ▁( ▁s ▁-> ▁version ▁>= ▁TLS 1_ VERSION ▁) ▁{ ▁if ▁( ▁! ▁( ▁alg _ a ▁& ▁SSL _ a ECDSA ▁) ▁) ▁p ▁[ ▁ret ▁++ ▁] ▁= ▁TLS _ CT _ ECDSA _ SIGN ▁; ▁} ▁# endif ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁int ▁ff _ mpeg _ update _ thread _ context ▁( ▁AVCodecContext ▁* ▁dst ▁, ▁const ▁AVCodecContext ▁* ▁src ▁) ▁{ ▁int ▁i ▁, ▁ret ▁; ▁Mpeg Enc Context ▁* ▁s ▁= ▁dst ▁-> ▁priv _ data ▁, ▁* ▁s 1 ▁= ▁src ▁-> ▁priv _ data ▁; ▁if ▁( ▁dst ▁== ▁src ▁|| ▁! ▁s 1 ▁-> ▁context _ initialized ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁s ▁-> ▁context _ initialized ▁) ▁{ ▁memcpy ▁( ▁s ▁, ▁s 1 ▁, ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁s ▁-> ▁avctx ▁= ▁dst ▁; ▁s ▁-> ▁bitstream _ buffer ▁= ▁NULL ▁; ▁s ▁-> ▁bitstream _ buffer _ size ▁= ▁s ▁-> ▁allocated _ bit stream _ buffer _ size ▁= ▁0 ▁; ▁ff _ MP V _ common _ init ▁( ▁s ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁height ▁!= ▁s 1 ▁-> ▁height ▁|| ▁s ▁-> ▁width ▁!= ▁s 1 ▁-> ▁width ▁|| ▁s ▁-> ▁context _ re init ▁) ▁{ ▁int ▁err ▁; ▁s ▁-> ▁context _ re init ▁= ▁0 ▁; ▁s ▁-> ▁height ▁= ▁s 1 ▁-> ▁height ▁; ▁s ▁-> ▁width ▁= ▁s 1 ▁-> ▁width ▁; ▁if ▁( ▁( ▁err ▁= ▁ff _ MP V _ common _ frame _ size _ change ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁err ▁; ▁} ▁s ▁-> ▁avctx ▁-> ▁coded _ height ▁= ▁s 1 ▁-> ▁avctx ▁-> ▁coded _ height ▁; ▁s ▁-> ▁avctx ▁-> ▁coded _ width ▁= ▁s 1 ▁-> ▁avctx ▁-> ▁coded _ width ▁; ▁s ▁-> ▁avctx ▁-> ▁width ▁= ▁s 1 ▁-> ▁avctx ▁-> ▁width ▁; ▁s ▁-> ▁avctx ▁-> ▁height ▁= ▁s 1 ▁-> ▁avctx ▁-> ▁height ▁; ▁s ▁-> ▁coded _ picture _ number ▁= ▁s 1 ▁-> ▁coded _ picture _ number ▁; ▁s ▁-> ▁picture _ number ▁= ▁s 1 ▁-> ▁picture _ number ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁ff _ mpeg _ unref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁s 1 ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁-> ▁buf ▁[ ▁0 ▁] ▁&& ▁( ▁ret ▁= ▁ff _ mpeg _ ref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁, ▁& ▁s 1 ▁-> ▁picture ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁# define ▁UPDATE _ PICTURE ▁( ▁pic ▁) ▁\ do {\ ff _ mpeg _ unref _ picture ( s , & s -> pic );\ if ( s 1 -> pic . f -> buf [0] )\ ret = ff _ mpeg _ ref _ picture ( s , & s -> pic , & s 1 -> pic );\ else \ ret = update _ picture _ tables (& s -> pic , & s 1 -> pic );\ if ( ret < 0)\ return ret ;\ } while (0) ▁UPDATE _ PICTURE ▁( ▁current _ picture ▁) ▁; ▁UPDATE _ PICTURE ▁( ▁last _ picture ▁) ▁; ▁UPDATE _ PICTURE ▁( ▁next _ picture ▁) ▁; ▁s ▁-> ▁last _ picture _ ptr ▁= ▁RE BASE _ PICTURE ▁( ▁s 1 ▁-> ▁last _ picture _ ptr ▁, ▁s ▁, ▁s 1 ▁) ▁; ▁s ▁-> ▁current _ picture _ ptr ▁= ▁RE BASE _ PICTURE ▁( ▁s 1 ▁-> ▁current _ picture _ ptr ▁, ▁s ▁, ▁s 1 ▁) ▁; ▁s ▁-> ▁next _ picture _ ptr ▁= ▁RE BASE _ PICTURE ▁( ▁s 1 ▁-> ▁next _ picture _ ptr ▁, ▁s ▁, ▁s 1 ▁) ▁; ▁s ▁-> ▁next _ p _ frame _ d am aged ▁= ▁s 1 ▁-> ▁next _ p _ frame _ d am aged ▁; ▁s ▁-> ▁workaround _ bugs ▁= ▁s 1 ▁-> ▁workaround _ bugs ▁; ▁memcpy ▁( ▁& ▁s ▁-> ▁last _ time _ base ▁, ▁& ▁s 1 ▁-> ▁last _ time _ base ▁, ▁( ▁char ▁* ▁) ▁& ▁s 1 ▁-> ▁pb _ field _ time ▁+ ▁sizeof ▁( ▁s 1 ▁-> ▁pb _ field _ time ▁) ▁- ▁( ▁char ▁* ▁) ▁& ▁s 1 ▁-> ▁last _ time _ base ▁) ▁; ▁s ▁-> ▁max _ b _ frames ▁= ▁s 1 ▁-> ▁max _ b _ frames ▁; ▁s ▁-> ▁low _ delay ▁= ▁s 1 ▁-> ▁low _ delay ▁; ▁s ▁-> ▁dro pp able ▁= ▁s 1 ▁-> ▁dro pp able ▁; ▁s ▁-> ▁div x _ packed ▁= ▁s 1 ▁-> ▁div x _ packed ▁; ▁if ▁( ▁s 1 ▁-> ▁bitstream _ buffer ▁) ▁{ ▁if ▁( ▁s 1 ▁-> ▁bitstream _ buffer _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁> ▁s ▁-> ▁allocated _ bit stream _ buffer _ size ▁) ▁av _ fast _ malloc ▁( ▁& ▁s ▁-> ▁bitstream _ buffer ▁, ▁& ▁s ▁-> ▁allocated _ bit stream _ buffer _ size ▁, ▁s 1 ▁-> ▁allocated _ bit stream _ buffer _ size ▁) ▁; ▁s ▁-> ▁bitstream _ buffer _ size ▁= ▁s 1 ▁-> ▁bitstream _ buffer _ size ▁; ▁memcpy ▁( ▁s ▁-> ▁bitstream _ buffer ▁, ▁s 1 ▁-> ▁bitstream _ buffer ▁, ▁s 1 ▁-> ▁bitstream _ buffer _ size ▁) ▁; ▁memset ▁( ▁s ▁-> ▁bitstream _ buffer ▁+ ▁s ▁-> ▁bitstream _ buffer _ size ▁, ▁0 ▁, ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁} ▁if ▁( ▁! ▁s ▁-> ▁edge _ emu _ buffer ▁) ▁if ▁( ▁s 1 ▁-> ▁linesize ▁) ▁{ ▁if ▁( ▁frame _ size _ alloc ▁( ▁s ▁, ▁s 1 ▁-> ▁linesize ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Failed to allocate context " ▁" scratch buffers .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Context scratch buffers could not " ▁" be allocated du et oun known size .\ n " ▁) ▁; ▁return ▁AVERROR _ BUG ▁; ▁} ▁memcpy ▁( ▁& ▁s ▁-> ▁progress ive _ sequence ▁, ▁& ▁s 1 ▁-> ▁progress ive _ sequence ▁, ▁( ▁char ▁* ▁) ▁& ▁s 1 ▁-> ▁rtp _ mode ▁- ▁( ▁char ▁* ▁) ▁& ▁s 1 ▁-> ▁progress ive _ sequence ▁) ▁; ▁if ▁( ▁! ▁s 1 ▁-> ▁first _ field ▁) ▁{ ▁s ▁-> ▁last _ p ict _ type ▁= ▁s 1 ▁-> ▁pict _ type ▁; ▁if ▁( ▁s 1 ▁-> ▁current _ picture _ ptr ▁) ▁s ▁-> ▁last _ lambda _ for ▁[ ▁s 1 ▁-> ▁pict _ type ▁] ▁= ▁s 1 ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁-> ▁quality ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁end _ frame _ over ▁( ▁AVFilter Link ▁* ▁inlink ▁) ▁{ ▁AVFilter Context ▁* ▁ctx ▁= ▁inlink ▁-> ▁dst ▁; ▁Overlay Context ▁* ▁over ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFilter Buffer Ref ▁* ▁in pic ref ▁= ▁inlink ▁-> ▁cur _ buf ▁; ▁flush _ frames ▁( ▁ctx ▁) ▁; ▁in pic ref ▁-> ▁pts ▁= ▁av _ re scale _ q ▁( ▁in pic ref ▁-> ▁pts ▁, ▁ctx ▁-> ▁inputs ▁[ ▁OVER LAY ▁] ▁-> ▁time _ base ▁, ▁ctx ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁time _ base ▁) ▁; ▁ff _ buf queue _ add ▁( ▁ctx ▁, ▁& ▁over ▁-> ▁queue _ over ▁, ▁in pic ref ▁) ▁; ▁try _ push _ frame ▁( ▁ctx ▁) ▁; ▁}	0
▁static ▁int ▁parse _ m 3 d ▁( ▁AVFilter Context ▁* ▁ctx ▁, ▁FILE ▁* ▁f ▁) ▁{ ▁L UT 3 D Context ▁* ▁lut 3 d ▁= ▁ctx ▁-> ▁priv ▁; ▁float ▁scale ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁size ▁, ▁in ▁= ▁-1 ▁, ▁out ▁= ▁-1 ▁; ▁char ▁line ▁[ ▁MAX _ LINE _ SIZE ▁] ▁; ▁uint 8_ t ▁rgb _ map ▁[ ▁3 ▁] ▁= ▁{ ▁0 ▁, ▁1 ▁, ▁2 ▁} ▁; ▁while ▁( ▁fgets ▁( ▁line ▁, ▁sizeof ▁( ▁line ▁) ▁, ▁f ▁) ▁) ▁{ ▁if ▁( ▁! ▁strncmp ▁( ▁line ▁, ▁" in " ▁, ▁2 ▁) ▁) ▁in ▁= ▁strtol ▁( ▁line ▁+ ▁2 ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁line ▁, ▁" out " ▁, ▁3 ▁) ▁) ▁out ▁= ▁strtol ▁( ▁line ▁+ ▁3 ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁line ▁, ▁" values " ▁, ▁6 ▁) ▁) ▁{ ▁const ▁char ▁* ▁p ▁= ▁line ▁+ ▁6 ▁; ▁# define ▁SET _ COLOR ▁( ▁id ▁) ▁do {\ while ( av _ isspace (* p )) \ p ++ ;\ switch (* p ){ \ case ' r ': rgb _ map [ id ] =0; break ;\ case ' g ': rgb _ map [ id ] =1 ; break ;\ case ' b ': rgb _ map [ id ] = 2; break ;\ }\ while (* p & & ! av _ isspace (* p )) \ p ++ ;\ } while (0) ▁SET _ COLOR ▁( ▁0 ▁) ▁; ▁SET _ COLOR ▁( ▁1 ▁) ▁; ▁SET _ COLOR ▁( ▁2 ▁) ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁in ▁== ▁-1 ▁|| ▁out ▁== ▁-1 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" in and out must be defined \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁in ▁< ▁2 ▁|| ▁out ▁< ▁2 ▁|| ▁in ▁> ▁MAX _ LEVEL ▁* ▁MAX _ LEVEL ▁* ▁MAX _ LEVEL ▁|| ▁out ▁> ▁MAX _ LEVEL ▁* ▁MAX _ LEVEL ▁* ▁MAX _ LEVEL ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid in (% d ) or out (% d )\ n " ▁, ▁in ▁, ▁out ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁size ▁= ▁1 ▁; ▁size ▁* ▁size ▁* ▁size ▁< ▁in ▁; ▁size ▁++ ▁) ▁; ▁lut 3 d ▁-> ▁lut size ▁= ▁size ▁; ▁scale ▁= ▁1. ▁/ ▁( ▁out ▁- ▁1 ▁) ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁size ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁size ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁struct ▁rgb vec ▁* ▁vec ▁= ▁& ▁lut 3 d ▁-> ▁lut ▁[ ▁k ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁float ▁val ▁[ ▁3 ▁] ▁; ▁NEXT _ LINE ▁( ▁0 ▁) ▁; ▁if ▁( ▁sscanf ▁( ▁line ▁, ▁"% f % f % f " ▁, ▁val ▁, ▁val ▁+ ▁1 ▁, ▁val ▁+ ▁2 ▁) ▁!= ▁3 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁vec ▁-> ▁r ▁= ▁val ▁[ ▁rgb _ map ▁[ ▁0 ▁] ▁] ▁* ▁scale ▁; ▁vec ▁-> ▁g ▁= ▁val ▁[ ▁rgb _ map ▁[ ▁1 ▁] ▁] ▁* ▁scale ▁; ▁vec ▁-> ▁b ▁= ▁val ▁[ ▁rgb _ map ▁[ ▁2 ▁] ▁] ▁* ▁scale ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁dca _ sub sub frame ▁( ▁D CA Context ▁* ▁s ▁, ▁int ▁base _ channel ▁, ▁int ▁block _ index ▁) ▁{ ▁int ▁k ▁, ▁l ▁; ▁int ▁sub sub frame ▁= ▁s ▁-> ▁current _ sub sub frame ▁; ▁const ▁float ▁* ▁quant _ step _ table ▁; ▁float ▁( ▁* ▁sub band _ samples ▁) ▁[ ▁D CA _ SUB BAND S ▁] ▁[ ▁8 ▁] ▁= ▁s ▁-> ▁sub band _ samples ▁[ ▁block _ index ▁] ▁; ▁LOCAL _ ALIGNED _16 ▁( ▁int 32_ t ▁, ▁block ▁, ▁[ ▁8 ▁* ▁D CA _ SUB BAND S ▁] ▁) ▁; ▁if ▁( ▁s ▁-> ▁bit _ rate _ index ▁== ▁0 x 1 f ▁) ▁quant _ step _ table ▁= ▁loss less _ quant _ d ▁; ▁else ▁quant _ step _ table ▁= ▁loss y _ quant _ d ▁; ▁for ▁( ▁k ▁= ▁base _ channel ▁; ▁k ▁< ▁s ▁-> ▁prim _ channels ▁; ▁k ▁++ ▁) ▁{ ▁float ▁r scale ▁[ ▁D CA _ SUB BAND S ▁] ▁; ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁s ▁-> ▁vq _ start _ sub band ▁[ ▁k ▁] ▁; ▁l ▁++ ▁) ▁{ ▁int ▁m ▁; ▁int ▁ab its ▁= ▁s ▁-> ▁bit alloc ▁[ ▁k ▁] ▁[ ▁l ▁] ▁; ▁float ▁quant _ step _ size ▁= ▁quant _ step _ table ▁[ ▁ab its ▁] ▁; ▁int ▁sel ▁= ▁s ▁-> ▁quant _ index _ h uffman ▁[ ▁k ▁] ▁[ ▁ab its ▁] ▁; ▁if ▁( ▁! ▁ab its ▁) ▁{ ▁r scale ▁[ ▁l ▁] ▁= ▁0 ▁; ▁memset ▁( ▁block ▁+ ▁8 ▁* ▁l ▁, ▁0 ▁, ▁8 ▁* ▁sizeof ▁( ▁block ▁[ ▁0 ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁int ▁sfi ▁= ▁s ▁-> ▁transition _ mode ▁[ ▁k ▁] ▁[ ▁l ▁] ▁&& ▁sub sub frame ▁>= ▁s ▁-> ▁transition _ mode ▁[ ▁k ▁] ▁[ ▁l ▁] ▁; ▁r scale ▁[ ▁l ▁] ▁= ▁quant _ step _ size ▁* ▁s ▁-> ▁scale _ factor ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁sfi ▁] ▁* ▁s ▁-> ▁scale factor _ adj ▁[ ▁k ▁] ▁[ ▁sel ▁] ▁; ▁if ▁( ▁ab its ▁>= ▁11 ▁|| ▁! ▁dca _ s mpl _ bit alloc ▁[ ▁ab its ▁] ▁. ▁vlc ▁[ ▁sel ▁] ▁. ▁table ▁) ▁{ ▁if ▁( ▁ab its ▁<= ▁7 ▁) ▁{ ▁int ▁block _ code 1 ▁, ▁block _ code 2 ▁, ▁size ▁, ▁levels ▁, ▁err ▁; ▁size ▁= ▁ab its _ sizes ▁[ ▁ab its ▁- ▁1 ▁] ▁; ▁levels ▁= ▁ab its _ levels ▁[ ▁ab its ▁- ▁1 ▁] ▁; ▁block _ code 1 ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁size ▁) ▁; ▁block _ code 2 ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁size ▁) ▁; ▁err ▁= ▁decode _ block codes ▁( ▁block _ code 1 ▁, ▁block _ code 2 ▁, ▁levels ▁, ▁block ▁+ ▁8 ▁* ▁l ▁) ▁; ▁if ▁( ▁err ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" ERROR : block code look - up failed \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁m ▁= ▁0 ▁; ▁m ▁< ▁8 ▁; ▁m ▁++ ▁) ▁block ▁[ ▁8 ▁* ▁l ▁+ ▁m ▁] ▁= ▁get _ s bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁ab its ▁- ▁3 ▁) ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁m ▁= ▁0 ▁; ▁m ▁< ▁8 ▁; ▁m ▁++ ▁) ▁block ▁[ ▁8 ▁* ▁l ▁+ ▁m ▁] ▁= ▁get _ bit alloc ▁( ▁& ▁s ▁-> ▁gb ▁, ▁& ▁dca _ s mpl _ bit alloc ▁[ ▁ab its ▁] ▁, ▁sel ▁) ▁; ▁} ▁} ▁} ▁s ▁-> ▁fmt _ conv ▁. ▁int 32_ to _ float _ fmul _ array 8 ▁( ▁& ▁s ▁-> ▁fmt _ conv ▁, ▁sub band _ samples ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁, ▁block ▁, ▁r scale ▁, ▁8 ▁* ▁s ▁-> ▁vq _ start _ sub band ▁[ ▁k ▁] ▁) ▁; ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁s ▁-> ▁vq _ start _ sub band ▁[ ▁k ▁] ▁; ▁l ▁++ ▁) ▁{ ▁int ▁m ▁; ▁if ▁( ▁s ▁-> ▁prediction _ mode ▁[ ▁k ▁] ▁[ ▁l ▁] ▁) ▁{ ▁int ▁n ▁; ▁if ▁( ▁s ▁-> ▁predictor _ history ▁) ▁sub band _ samples ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁0 ▁] ▁+= ▁( ▁ad pcm _ vb ▁[ ▁s ▁-> ▁prediction _ vq ▁[ ▁k ▁] ▁[ ▁l ▁] ▁] ▁[ ▁0 ▁] ▁* ▁s ▁-> ▁sub band _ samples _ hist ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁3 ▁] ▁+ ▁ad pcm _ vb ▁[ ▁s ▁-> ▁prediction _ vq ▁[ ▁k ▁] ▁[ ▁l ▁] ▁] ▁[ ▁1 ▁] ▁* ▁s ▁-> ▁sub band _ samples _ hist ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁2 ▁] ▁+ ▁ad pcm _ vb ▁[ ▁s ▁-> ▁prediction _ vq ▁[ ▁k ▁] ▁[ ▁l ▁] ▁] ▁[ ▁2 ▁] ▁* ▁s ▁-> ▁sub band _ samples _ hist ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁1 ▁] ▁+ ▁ad pcm _ vb ▁[ ▁s ▁-> ▁prediction _ vq ▁[ ▁k ▁] ▁[ ▁l ▁] ▁] ▁[ ▁3 ▁] ▁* ▁s ▁-> ▁sub band _ samples _ hist ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁0 ▁] ▁) ▁* ▁( ▁1.0 f ▁/ ▁8192 ▁) ▁; ▁for ▁( ▁m ▁= ▁1 ▁; ▁m ▁< ▁8 ▁; ▁m ▁++ ▁) ▁{ ▁float ▁sum ▁= ▁ad pcm _ vb ▁[ ▁s ▁-> ▁prediction _ vq ▁[ ▁k ▁] ▁[ ▁l ▁] ▁] ▁[ ▁0 ▁] ▁* ▁sub band _ samples ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁m ▁- ▁1 ▁] ▁; ▁for ▁( ▁n ▁= ▁2 ▁; ▁n ▁<= ▁4 ▁; ▁n ▁++ ▁) ▁if ▁( ▁m ▁>= ▁n ▁) ▁sum ▁+= ▁ad pcm _ vb ▁[ ▁s ▁-> ▁prediction _ vq ▁[ ▁k ▁] ▁[ ▁l ▁] ▁] ▁[ ▁n ▁- ▁1 ▁] ▁* ▁sub band _ samples ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁m ▁- ▁n ▁] ▁; ▁else ▁if ▁( ▁s ▁-> ▁predictor _ history ▁) ▁sum ▁+= ▁ad pcm _ vb ▁[ ▁s ▁-> ▁prediction _ vq ▁[ ▁k ▁] ▁[ ▁l ▁] ▁] ▁[ ▁n ▁- ▁1 ▁] ▁* ▁s ▁-> ▁sub band _ samples _ hist ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁m ▁- ▁n ▁+ ▁4 ▁] ▁; ▁sub band _ samples ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁m ▁] ▁+= ▁sum ▁* ▁1.0 f ▁/ ▁8192 ▁; ▁} ▁} ▁} ▁if ▁( ▁s ▁-> ▁sub band _ activity ▁[ ▁k ▁] ▁> ▁s ▁-> ▁vq _ start _ sub band ▁[ ▁k ▁] ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁debug _ flag ▁& ▁0 x 01 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Stream with high f requencies V Q coding \ n " ▁) ▁; ▁s ▁-> ▁debug _ flag ▁|= ▁0 x 01 ▁; ▁} ▁s ▁-> ▁dc ad sp ▁. ▁decode _ hf ▁( ▁sub band _ samples ▁[ ▁k ▁] ▁, ▁s ▁-> ▁high _ freq _ vq ▁[ ▁k ▁] ▁, ▁high _ freq _ vq ▁, ▁sub sub frame ▁* ▁8 ▁, ▁s ▁-> ▁scale _ factor ▁[ ▁k ▁] ▁, ▁s ▁-> ▁vq _ start _ sub band ▁[ ▁k ▁] ▁, ▁s ▁-> ▁sub band _ activity ▁[ ▁k ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁as pf ▁|| ▁sub sub frame ▁== ▁s ▁-> ▁sub sub frames ▁[ ▁s ▁-> ▁current _ sub frame ▁] ▁- ▁1 ▁) ▁{ ▁if ▁( ▁0 xFFFF ▁== ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁16 ▁) ▁) ▁{ ▁# ifdef ▁TRACE ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Got sub frame D SYNC \ n " ▁) ▁; ▁# endif ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Did n ' t get sub frame D SYNC \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁for ▁( ▁k ▁= ▁base _ channel ▁; ▁k ▁< ▁s ▁-> ▁prim _ channels ▁; ▁k ▁++ ▁) ▁for ▁( ▁l ▁= ▁0 ▁; ▁l ▁< ▁s ▁-> ▁vq _ start _ sub band ▁[ ▁k ▁] ▁; ▁l ▁++ ▁) ▁AV _ COPY 128 ▁( ▁s ▁-> ▁sub band _ samples _ hist ▁[ ▁k ▁] ▁[ ▁l ▁] ▁, ▁& ▁sub band _ samples ▁[ ▁k ▁] ▁[ ▁l ▁] ▁[ ▁4 ▁] ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁ff _ inter leave _ packet _ per _ dts ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁out ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁flush ▁) ▁{ ▁AVPacket List ▁* ▁pk tl ▁; ▁int ▁stream _ count ▁= ▁0 ▁; ▁int ▁i ▁, ▁ret ▁; ▁if ▁( ▁pkt ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁ff _ inter leave _ add _ packet ▁( ▁s ▁, ▁pkt ▁, ▁interleave _ compare _ dts ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁s ▁-> ▁max _ inter leave _ delta ▁> ▁0 ▁&& ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁&& ▁! ▁flush ▁) ▁{ ▁AVPacket ▁* ▁top _ pkt ▁= ▁& ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁-> ▁pkt ▁; ▁int 64_ t ▁delta _ dts ▁= ▁INT 64_ MIN ▁; ▁int 64_ t ▁top _ dts ▁= ▁av _ re scale _ q ▁( ▁top _ pkt ▁-> ▁dts ▁, ▁s ▁-> ▁streams ▁[ ▁top _ pkt ▁-> ▁stream _ index ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁int 64_ t ▁last _ dts ▁; ▁const ▁AVPacket List ▁* ▁last ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁last _ in _ packet _ buffer ▁; ▁if ▁( ▁! ▁last ▁) ▁continue ▁; ▁last _ dts ▁= ▁av _ re scale _ q ▁( ▁last ▁-> ▁pkt ▁. ▁dts ▁, ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁delta _ dts ▁= ▁FF MAX ▁( ▁delta _ dts ▁, ▁last _ dts ▁- ▁top _ dts ▁) ▁; ▁stream _ count ▁++ ▁; ▁} ▁if ▁( ▁delta _ dts ▁> ▁s ▁-> ▁max _ inter leave _ delta ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Delay b et we ent he first packet and last packet int he " ▁" mux ing queue is %" ▁PRId 64 ▁"> %" ▁PRId 64 ▁": for cing output \ n " ▁, ▁delta _ dts ▁, ▁s ▁-> ▁max _ inter leave _ delta ▁) ▁; ▁flush ▁= ▁1 ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁stream _ count ▁+= ▁! ▁! ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁last _ in _ packet _ buffer ▁; ▁} ▁if ▁( ▁stream _ count ▁&& ▁( ▁s ▁-> ▁internal ▁-> ▁nb _ inter leaved _ streams ▁== ▁stream _ count ▁|| ▁flush ▁) ▁) ▁{ ▁pk tl ▁= ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁; ▁* ▁out ▁= ▁pk tl ▁-> ▁pkt ▁; ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁= ▁pk tl ▁-> ▁next ▁; ▁if ▁( ▁! ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁) ▁s ▁-> ▁internal ▁-> ▁packet _ buffer _ end ▁= ▁NULL ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁out ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁== ▁pk tl ▁) ▁s ▁-> ▁streams ▁[ ▁out ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁= ▁NULL ▁; ▁av _ freep ▁( ▁& ▁pk tl ▁) ▁; ▁return ▁1 ▁; ▁} ▁else ▁{ ▁av _ init _ packet ▁( ▁out ▁) ▁; ▁return ▁0 ▁; ▁} ▁}	1
▁static ▁int ▁mov _ write _ ct ts _ tag ▁( ▁AVIO Context ▁* ▁pb ▁, ▁MOV Track ▁* ▁track ▁) ▁{ ▁MOV St ts ▁* ▁c tt s _ entries ▁; ▁uint 32_ t ▁entries ▁= ▁0 ▁; ▁uint 32_ t ▁atom _ size ▁; ▁int ▁i ▁; ▁c tt s _ entries ▁= ▁av _ malloc _ array ▁( ▁( ▁track ▁-> ▁entry ▁+ ▁1 ▁) ▁, ▁sizeof ▁( ▁* ▁c tt s _ entries ▁) ▁) ▁; ▁if ▁( ▁! ▁c tt s _ entries ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁c tt s _ entries ▁[ ▁0 ▁] ▁. ▁count ▁= ▁1 ▁; ▁c tt s _ entries ▁[ ▁0 ▁] ▁. ▁duration ▁= ▁track ▁-> ▁cluster ▁[ ▁0 ▁] ▁. ▁cts ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁track ▁-> ▁entry ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁track ▁-> ▁cluster ▁[ ▁i ▁] ▁. ▁cts ▁== ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁duration ▁) ▁{ ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁count ▁++ ▁; ▁} ▁else ▁{ ▁entries ▁++ ▁; ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁duration ▁= ▁track ▁-> ▁cluster ▁[ ▁i ▁] ▁. ▁cts ▁; ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁count ▁= ▁1 ▁; ▁} ▁} ▁entries ▁++ ▁; ▁atom _ size ▁= ▁16 ▁+ ▁( ▁entries ▁* ▁8 ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁atom _ size ▁) ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁" ct ts " ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁entries ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁entries ▁; ▁i ▁++ ▁) ▁{ ▁avio _ wb 32 ▁( ▁pb ▁, ▁c tt s _ entries ▁[ ▁i ▁] ▁. ▁count ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁c tt s _ entries ▁[ ▁i ▁] ▁. ▁duration ▁) ▁; ▁} ▁av _ free ▁( ▁c tt s _ entries ▁) ▁; ▁return ▁atom _ size ▁; ▁}	0
▁static ▁int ▁h ls _ slice _ data _ w pp ▁( ▁H EV C Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁nal ▁, ▁int ▁length ▁) ▁{ ▁H EV CL ocal Context ▁* ▁lc ▁= ▁s ▁-> ▁H EV C lc ▁; ▁int ▁* ▁ret ▁= ▁av _ malloc _ array ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁, ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁* ▁arg ▁= ▁av _ malloc _ array ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁, ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁offset ▁; ▁int ▁start header ▁, ▁c mpt ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁, ▁res ▁= ▁0 ▁; ▁if ▁( ▁! ▁ret ▁|| ▁! ▁arg ▁) ▁{ ▁av _ free ▁( ▁ret ▁) ▁; ▁av _ free ▁( ▁arg ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁if ▁( ▁! ▁s ▁-> ▁s List ▁[ ▁1 ▁] ▁) ▁{ ▁ff _ alloc _ entries ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁H EV CL ocal Context ▁) ▁) ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁} ▁} ▁offset ▁= ▁( ▁lc ▁-> ▁gb ▁. ▁index ▁>> ▁3 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁, ▁c mpt ▁= ▁0 ▁, ▁start header ▁= ▁offset ▁+ ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁0 ▁] ▁; ▁j ▁< ▁s ▁-> ▁skipped _ bytes ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁>= ▁offset ▁&& ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁< ▁start header ▁) ▁{ ▁start header ▁-- ▁; ▁c mpt ▁++ ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁{ ▁offset ▁+= ▁( ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁- ▁1 ▁] ▁- ▁c mpt ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁, ▁c mpt ▁= ▁0 ▁, ▁start header ▁= ▁offset ▁+ ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁] ▁; ▁j ▁< ▁s ▁-> ▁skipped _ bytes ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁>= ▁offset ▁&& ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁< ▁start header ▁) ▁{ ▁start header ▁-- ▁; ▁c mpt ▁++ ▁; ▁} ▁} ▁s ▁-> ▁sh ▁. ▁size ▁[ ▁i ▁- ▁1 ▁] ▁= ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁] ▁- ▁c mpt ▁; ▁s ▁-> ▁sh ▁. ▁offset ▁[ ▁i ▁- ▁1 ▁] ▁= ▁offset ▁; ▁} ▁if ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁!= ▁0 ▁) ▁{ ▁offset ▁+= ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁- ▁c mpt ▁; ▁s ▁-> ▁sh ▁. ▁size ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁= ▁length ▁- ▁offset ▁; ▁s ▁-> ▁sh ▁. ▁offset ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁= ▁offset ▁; ▁} ▁s ▁-> ▁data ▁= ▁nal ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁-> ▁first _ qp _ group ▁= ▁1 ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁-> ▁qp _ y ▁= ▁s ▁-> ▁s List ▁[ ▁0 ▁] ▁-> ▁H EV C lc ▁-> ▁qp _ y ▁; ▁memcpy ▁( ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁} ▁avpriv _ atomic _ int _ set ▁( ▁& ▁s ▁-> ▁w pp _ err ▁, ▁0 ▁) ▁; ▁ff _ reset _ entries ▁( ▁s ▁-> ▁avctx ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁{ ▁arg ▁[ ▁i ▁] ▁= ▁i ▁; ▁ret ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁if ▁( ▁s ▁-> ▁pps ▁-> ▁entropy _ coding _ sync _ enabled _ flag ▁) ▁s ▁-> ▁avctx ▁-> ▁execute 2 ▁( ▁s ▁-> ▁avctx ▁, ▁( ▁void ▁* ▁) ▁h ls _ decode _ entry _ w pp ▁, ▁arg ▁, ▁ret ▁, ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁res ▁+= ▁ret ▁[ ▁i ▁] ▁; ▁av _ free ▁( ▁ret ▁) ▁; ▁av _ free ▁( ▁arg ▁) ▁; ▁return ▁res ▁; ▁}	0
▁static ▁int ▁do _ print _ item ▁( ▁const ▁TEST _ PACKAGE ▁* ▁package ▁) ▁{ ▁# define ▁DATA _ BUF _ SIZE ▁256 ▁const ▁ASN 1_ ITEM ▁* ▁i ▁= ▁ASN 1_ ITEM _ ptr ▁( ▁package ▁-> ▁asn 1_ type ▁) ▁; ▁ASN 1_ VALUE ▁* ▁o ▁; ▁int ▁ret ▁; ▁OPENSSL _ assert ▁( ▁package ▁-> ▁encode _ expect ations _ elem _ size ▁<= ▁DATA _ BUF _ SIZE ▁) ▁; ▁if ▁( ▁( ▁o ▁= ▁OPENSSL _ malloc ▁( ▁DATA _ BUF _ SIZE ▁) ▁) ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁( ▁void ▁) ▁RAND _ bytes ▁( ▁( ▁unsigned ▁char ▁* ▁) ▁o ▁, ▁( ▁int ▁) ▁package ▁-> ▁encode _ expect ations _ elem _ size ▁) ▁; ▁ret ▁= ▁ASN 1_ item _ print ▁( ▁bio _ err ▁, ▁o ▁, ▁0 ▁, ▁i ▁, ▁NULL ▁) ▁; ▁OPENSSL _ free ▁( ▁o ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁rm _ read _ audio _ stream _ info ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁, ▁AVStream ▁* ▁st ▁, ▁RM Stream ▁* ▁ast ▁, ▁int ▁read _ all ▁) ▁{ ▁char ▁buf ▁[ ▁256 ▁] ▁; ▁uint 32_ t ▁version ▁; ▁int ▁ret ▁; ▁version ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁version ▁== ▁3 ▁) ▁{ ▁int ▁header _ size ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁int 64_ t ▁startp os ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁14 ▁) ▁; ▁rm _ read _ metadata ▁( ▁s ▁, ▁0 ▁) ▁; ▁if ▁( ▁( ▁startp os ▁+ ▁header _ size ▁) ▁>= ▁avio _ tell ▁( ▁pb ▁) ▁+ ▁2 ▁) ▁{ ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁get _ str 8 ▁( ▁pb ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁} ▁if ▁( ▁( ▁startp os ▁+ ▁header _ size ▁) ▁> ▁avio _ tell ▁( ▁pb ▁) ▁) ▁avio _ skip ▁( ▁pb ▁, ▁header _ size ▁+ ▁startp os ▁- ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁= ▁8000 ▁; ▁st ▁-> ▁codec ▁-> ▁channels ▁= ▁1 ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁CODEC _ ID _ RA _1 44 ▁; ▁ast ▁-> ▁de int _ id ▁= ▁DE INT _ ID _ INT 0 ▁; ▁} ▁else ▁{ ▁int ▁flavor ▁, ▁sub _ packet _ h ▁, ▁coded _ frames ize ▁, ▁sub _ packet _ size ▁; ▁int ▁codec data _ length ▁; ▁avio _ skip ▁( ▁pb ▁, ▁2 ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁flavor ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁ast ▁-> ▁coded _ frames ize ▁= ▁coded _ frames ize ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁ast ▁-> ▁sub _ packet _ h ▁= ▁sub _ packet _ h ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁block _ align ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁ast ▁-> ▁sub _ packet _ size ▁= ▁sub _ packet _ size ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁version ▁== ▁5 ▁) ▁{ ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁} ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁channels ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁version ▁== ▁5 ▁) ▁{ ▁ast ▁-> ▁de int _ id ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ read ▁( ▁pb ▁, ▁buf ▁, ▁4 ▁) ▁; ▁buf ▁[ ▁4 ▁] ▁= ▁0 ▁; ▁} ▁else ▁{ ▁get _ str 8 ▁( ▁pb ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁ast ▁-> ▁de int _ id ▁= ▁AV _ RL 32 ▁( ▁buf ▁) ▁; ▁get _ str 8 ▁( ▁pb ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁} ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁= ▁AV _ RL 32 ▁( ▁buf ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁ff _ codec _ get _ id ▁( ▁ff _ rm _ codec _ tags ▁, ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁) ▁; ▁switch ▁( ▁ast ▁-> ▁de int _ id ▁) ▁{ ▁case ▁DE INT _ ID _ GEN R ▁: ▁case ▁DE INT _ ID _ INT 0 ▁: ▁case ▁DE INT _ ID _ INT 4 ▁: ▁case ▁DE INT _ ID _ SI PR ▁: ▁case ▁DE INT _ ID _ V BR S ▁: ▁case ▁DE INT _ ID _ V BR F ▁: ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁NULL ▁, ▁0 ▁, ▁" Unknown inter le aver % X \ n " ▁, ▁ast ▁-> ▁de int _ id ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁switch ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁) ▁{ ▁case ▁CODEC _ ID _ AC 3 ▁: ▁st ▁-> ▁need _ parsing ▁= ▁AV STREAM _ PARSE _ FULL ▁; ▁break ▁; ▁case ▁CODEC _ ID _ RA _2 88 ▁: ▁st ▁-> ▁codec ▁-> ▁extradata _ size ▁= ▁0 ▁; ▁ast ▁-> ▁audio _ frames ize ▁= ▁st ▁-> ▁codec ▁-> ▁block _ align ▁; ▁st ▁-> ▁codec ▁-> ▁block _ align ▁= ▁coded _ frames ize ▁; ▁if ▁( ▁ast ▁-> ▁audio _ frames ize ▁>= ▁UINT _ MAX ▁/ ▁sub _ packet _ h ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" ast -> audio _ frames ize * sub _ packet _ htool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁av _ new _ packet ▁( ▁& ▁ast ▁-> ▁pkt ▁, ▁ast ▁-> ▁audio _ frames ize ▁* ▁sub _ packet _ h ▁) ▁; ▁break ▁; ▁case ▁CODEC _ ID _ COOK ▁: ▁case ▁CODEC _ ID _ ATR AC 3 ▁: ▁case ▁CODEC _ ID _ SI PR ▁: ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁if ▁( ▁version ▁== ▁5 ▁) ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁codec data _ length ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁codec data _ length ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁<= ▁( ▁unsigned ▁) ▁codec data _ length ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" codec data _ len gt htool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁ast ▁-> ▁audio _ frames ize ▁= ▁st ▁-> ▁codec ▁-> ▁block _ align ▁; ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ SI PR ▁) ▁{ ▁if ▁( ▁flavor ▁> ▁3 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" bad SI PR file flavor % d \ n " ▁, ▁flavor ▁) ▁; ▁return ▁-1 ▁; ▁} ▁st ▁-> ▁codec ▁-> ▁block _ align ▁= ▁ff _ sip r _ sub pk _ size ▁[ ▁flavor ▁] ▁; ▁} ▁else ▁{ ▁if ▁( ▁sub _ packet _ size ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" sub _ packet _ size is invalid \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁st ▁-> ▁codec ▁-> ▁block _ align ▁= ▁ast ▁-> ▁sub _ packet _ size ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁rm _ read _ extr adata ▁( ▁pb ▁, ▁st ▁-> ▁codec ▁, ▁codec data _ length ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁ast ▁-> ▁audio _ frames ize ▁>= ▁UINT _ MAX ▁/ ▁sub _ packet _ h ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" rm -> audio _ frames ize * sub _ packet _ htool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁av _ new _ packet ▁( ▁& ▁ast ▁-> ▁pkt ▁, ▁ast ▁-> ▁audio _ frames ize ▁* ▁sub _ packet _ h ▁) ▁; ▁break ▁; ▁case ▁CODEC _ ID _ A AC ▁: ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁if ▁( ▁version ▁== ▁5 ▁) ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁codec data _ length ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁codec data _ length ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁<= ▁( ▁unsigned ▁) ▁codec data _ length ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" codec data _ len gt htool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁codec data _ length ▁>= ▁1 ▁) ▁{ ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁rm _ read _ extr adata ▁( ▁pb ▁, ▁st ▁-> ▁codec ▁, ▁codec data _ length ▁- ▁1 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁break ▁; ▁default ▁: ▁av _ strlcpy ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ name ▁, ▁buf ▁, ▁sizeof ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ name ▁) ▁) ▁; ▁} ▁if ▁( ▁read _ all ▁) ▁{ ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁rm _ read _ metadata ▁( ▁s ▁, ▁0 ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁test _ bad mod ▁( ▁) ▁{ ▁BIGNUM ▁* ▁a ▁= ▁BN _ new ▁( ▁) ▁; ▁BIGNUM ▁* ▁b ▁= ▁BN _ new ▁( ▁) ▁; ▁BIGNUM ▁* ▁zero ▁= ▁BN _ new ▁( ▁) ▁; ▁BN _ M ONT _ CTX ▁* ▁m ont ▁= ▁BN _ M ONT _ CTX _ new ▁( ▁) ▁; ▁int ▁st ▁= ▁0 ▁; ▁if ▁( ▁a ▁== ▁NULL ▁|| ▁b ▁== ▁NULL ▁|| ▁zero ▁== ▁NULL ▁|| ▁m ont ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁BN _ zero ▁( ▁zero ▁) ▁; ▁if ▁( ▁BN _ div ▁( ▁a ▁, ▁b ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁zero ▁, ▁ctx ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Division by zeros uc ce eded !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁BN _ mod _ mul ▁( ▁a ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁zero ▁, ▁ctx ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ mod _ mul with zer om od ul uss uc ce eded !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁BN _ mod _ exp ▁( ▁a ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁zero ▁, ▁ctx ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ mod _ exp with zer om od ul uss uc ce eded !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁BN _ mod _ exp _ mont ▁( ▁a ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁zero ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ mod _ exp _ mont with zer om od ul uss uc ce eded !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁BN _ mod _ exp _ mont _ const time ▁( ▁a ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁zero ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ mod _ exp _ mont _ const tim ew ith zer om od ul uss uc ce eded !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁zero ▁, ▁ctx ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ M ONT _ CTX _ sets uc ce eded for zer om od ulus !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁! ▁BN _ set _ word ▁( ▁b ▁, ▁16 ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁b ▁, ▁ctx ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ M ONT _ CTX _ sets uc ce eded fore ven mod ulus !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁BN _ mod _ exp _ mont ▁( ▁a ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁b ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ mod _ exp _ mont wit he ven mod ul uss uc ce eded !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁if ▁( ▁BN _ mod _ exp _ mont _ const time ▁( ▁a ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁b ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" BN _ mod _ exp _ mont _ const tim ew it he ven mod ul uss uc ce eded !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁st ▁= ▁1 ▁; ▁err ▁: ▁BN _ free ▁( ▁a ▁) ▁; ▁BN _ free ▁( ▁b ▁) ▁; ▁BN _ free ▁( ▁zero ▁) ▁; ▁BN _ M ONT _ CTX _ free ▁( ▁m ont ▁) ▁; ▁return ▁st ▁; ▁}	0
▁int ▁av _ frame _ ref ▁( ▁AVFrame ▁* ▁dst ▁, ▁const ▁AVFrame ▁* ▁src ▁) ▁{ ▁int ▁i ▁, ▁ret ▁= ▁0 ▁; ▁dst ▁-> ▁format ▁= ▁src ▁-> ▁format ▁; ▁dst ▁-> ▁width ▁= ▁src ▁-> ▁width ▁; ▁dst ▁-> ▁height ▁= ▁src ▁-> ▁height ▁; ▁dst ▁-> ▁channels ▁= ▁src ▁-> ▁channels ▁; ▁dst ▁-> ▁channel _ layout ▁= ▁src ▁-> ▁channel _ layout ▁; ▁dst ▁-> ▁nb _ samples ▁= ▁src ▁-> ▁nb _ samples ▁; ▁ret ▁= ▁frame _ copy _ props ▁( ▁dst ▁, ▁src ▁, ▁0 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁! ▁src ▁-> ▁buf ▁[ ▁0 ▁] ▁) ▁{ ▁ret ▁= ▁av _ frame _ get _ buffer ▁( ▁dst ▁, ▁32 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ret ▁= ▁av _ frame _ copy ▁( ▁dst ▁, ▁src ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁av _ frame _ unref ▁( ▁dst ▁) ▁; ▁return ▁ret ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁src ▁-> ▁buf ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁src ▁-> ▁buf ▁[ ▁i ▁] ▁) ▁continue ▁; ▁dst ▁-> ▁buf ▁[ ▁i ▁] ▁= ▁av _ buffer _ ref ▁( ▁src ▁-> ▁buf ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁! ▁dst ▁-> ▁buf ▁[ ▁i ▁] ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁} ▁if ▁( ▁src ▁-> ▁extended _ buf ▁) ▁{ ▁dst ▁-> ▁extended _ buf ▁= ▁av _ malloc z _ array ▁( ▁sizeof ▁( ▁* ▁dst ▁-> ▁extended _ buf ▁) ▁, ▁src ▁-> ▁nb _ extended _ buf ▁) ▁; ▁if ▁( ▁! ▁dst ▁-> ▁extended _ buf ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁dst ▁-> ▁nb _ extended _ buf ▁= ▁src ▁-> ▁nb _ extended _ buf ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁src ▁-> ▁nb _ extended _ buf ▁; ▁i ▁++ ▁) ▁{ ▁dst ▁-> ▁extended _ buf ▁[ ▁i ▁] ▁= ▁av _ buffer _ ref ▁( ▁src ▁-> ▁extended _ buf ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁! ▁dst ▁-> ▁extended _ buf ▁[ ▁i ▁] ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁} ▁} ▁if ▁( ▁src ▁-> ▁extended _ data ▁!= ▁src ▁-> ▁data ▁) ▁{ ▁int ▁ch ▁= ▁src ▁-> ▁channels ▁; ▁if ▁( ▁! ▁ch ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁goto ▁fail ▁; ▁} ▁CHECK _ CHANNELS _ CON SIST ENCY ▁( ▁src ▁) ▁; ▁dst ▁-> ▁extended _ data ▁= ▁av _ malloc _ array ▁( ▁sizeof ▁( ▁* ▁dst ▁-> ▁extended _ data ▁) ▁, ▁ch ▁) ▁; ▁if ▁( ▁! ▁dst ▁-> ▁extended _ data ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁memcpy ▁( ▁dst ▁-> ▁extended _ data ▁, ▁src ▁-> ▁extended _ data ▁, ▁sizeof ▁( ▁* ▁src ▁-> ▁extended _ data ▁) ▁* ▁ch ▁) ▁; ▁} ▁else ▁dst ▁-> ▁extended _ data ▁= ▁dst ▁-> ▁data ▁; ▁memcpy ▁( ▁dst ▁-> ▁data ▁, ▁src ▁-> ▁data ▁, ▁sizeof ▁( ▁src ▁-> ▁data ▁) ▁) ▁; ▁memcpy ▁( ▁dst ▁-> ▁linesize ▁, ▁src ▁-> ▁linesize ▁, ▁sizeof ▁( ▁src ▁-> ▁linesize ▁) ▁) ▁; ▁return ▁0 ▁; ▁fail ▁: ▁av _ frame _ unref ▁( ▁dst ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁find _ headers _ search _ validate ▁( ▁FLAC Parse Context ▁* ▁f pc ▁, ▁int ▁offset ▁) ▁{ ▁FLAC FrameInfo ▁fi ▁; ▁uint 8_ t ▁* ▁header _ buf ▁; ▁int ▁size ▁= ▁0 ▁; ▁header _ buf ▁= ▁fl ac _ fifo _ read _ wrap ▁( ▁f pc ▁, ▁offset ▁, ▁MAX _ FRAME _ HEADER _ SIZE ▁, ▁& ▁f pc ▁-> ▁wrap _ buf ▁, ▁& ▁f pc ▁-> ▁wrap _ buf _ allocated _ size ▁) ▁; ▁if ▁( ▁frame _ header _ is _ valid ▁( ▁f pc ▁-> ▁avctx ▁, ▁header _ buf ▁, ▁& ▁fi ▁) ▁) ▁{ ▁FL ACH e ader Marker ▁* ▁* ▁end _ handle ▁= ▁& ▁f pc ▁-> ▁headers ▁; ▁int ▁i ▁; ▁size ▁= ▁0 ▁; ▁while ▁( ▁* ▁end _ handle ▁) ▁{ ▁end _ handle ▁= ▁& ▁( ▁* ▁end _ handle ▁) ▁-> ▁next ▁; ▁size ▁++ ▁; ▁} ▁* ▁end _ handle ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁* ▁end _ handle ▁) ▁) ▁; ▁if ▁( ▁! ▁* ▁end _ handle ▁) ▁{ ▁av _ log ▁( ▁f pc ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" couldn ' t allocate FL ACH e ader Marker \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁( ▁* ▁end _ handle ▁) ▁-> ▁fi ▁= ▁fi ▁; ▁( ▁* ▁end _ handle ▁) ▁-> ▁offset ▁= ▁offset ▁; ▁( ▁* ▁end _ handle ▁) ▁-> ▁link _ pen alty ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁int ▁) ▁* ▁FLAC _ MAX _ SEQUENTIAL _ HEADERS ▁) ▁; ▁if ▁( ▁! ▁( ▁* ▁end _ handle ▁) ▁-> ▁link _ pen alty ▁) ▁{ ▁av _ freep ▁( ▁end _ handle ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FLAC _ MAX _ SEQUENTIAL _ HEADERS ▁; ▁i ▁++ ▁) ▁( ▁* ▁end _ handle ▁) ▁-> ▁link _ pen alty ▁[ ▁i ▁] ▁= ▁FLAC _ HEADER _ NOT _ PEN AL IZED _ Y ET ▁; ▁f pc ▁-> ▁nb _ headers _ found ▁++ ▁; ▁size ▁++ ▁; ▁} ▁return ▁size ▁; ▁}	0
▁uint 64 ▁_ TIFF Multiply 64 ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 64 ▁first ▁, ▁uint 64 ▁second ▁, ▁const ▁char ▁* ▁where ▁) ▁{ ▁uint 64 ▁bytes ▁= ▁first ▁* ▁second ▁; ▁if ▁( ▁second ▁&& ▁bytes ▁/ ▁second ▁!= ▁first ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁where ▁, ▁" Integer overflow in % s " ▁, ▁where ▁) ▁; ▁bytes ▁= ▁0 ▁; ▁} ▁return ▁bytes ▁; ▁}	1
▁int ▁tls _ collect _ extensions ▁( ▁SSL ▁* ▁s ▁, ▁PACKET ▁* ▁packet ▁, ▁unsigned ▁int ▁context ▁, ▁RAW _ EXTENSION ▁* ▁* ▁res ▁, ▁size _ t ▁* ▁len ▁, ▁int ▁init ▁) ▁{ ▁PACKET ▁extensions ▁= ▁* ▁packet ▁; ▁size _ t ▁i ▁= ▁0 ▁; ▁size _ t ▁num _ ext s ▁; ▁custom _ ext _ methods ▁* ▁exts ▁= ▁& ▁s ▁-> ▁cert ▁-> ▁cust ext ▁; ▁RAW _ EXTENSION ▁* ▁raw _ extensions ▁= ▁NULL ▁; ▁const ▁EXTENSION _ DEFINITION ▁* ▁th ise xd ▁; ▁* ▁res ▁= ▁NULL ▁; ▁if ▁( ▁( ▁context ▁& ▁SSL _ EXT _ CLIENT _ HELLO ▁) ▁!= ▁0 ▁) ▁custom _ ext _ init ▁( ▁& ▁s ▁-> ▁cert ▁-> ▁cust ext ▁) ▁; ▁num _ ext s ▁= ▁OSSL _ NE LEM ▁( ▁ext _ defs ▁) ▁+ ▁( ▁exts ▁!= ▁NULL ▁? ▁exts ▁-> ▁meth s _ count ▁: ▁0 ▁) ▁; ▁raw _ extensions ▁= ▁OPENSSL _ zalloc ▁( ▁num _ ext s ▁* ▁sizeof ▁( ▁* ▁raw _ extensions ▁) ▁) ▁; ▁if ▁( ▁raw _ extensions ▁== ▁NULL ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS _ COL LECT _ EXTENSIONS ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁i ▁= ▁0 ▁; ▁while ▁( ▁PACKET _ remaining ▁( ▁& ▁extensions ▁) ▁> ▁0 ▁) ▁{ ▁unsigned ▁int ▁type ▁, ▁idx ▁; ▁PACKET ▁extension ▁; ▁RAW _ EXTENSION ▁* ▁th ise x ▁; ▁if ▁( ▁! ▁PACKET _ get _ net _2 ▁( ▁& ▁extensions ▁, ▁& ▁type ▁) ▁|| ▁! ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁& ▁extensions ▁, ▁& ▁extension ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ DECODE _ ERROR ▁, ▁SSL _ F _ TLS _ COL LECT _ EXTENSIONS ▁, ▁SSL _ R _ BAD _ EXTENSION ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁verify _ extension ▁( ▁s ▁, ▁context ▁, ▁type ▁, ▁exts ▁, ▁raw _ extensions ▁, ▁& ▁th ise x ▁) ▁|| ▁( ▁th ise x ▁!= ▁NULL ▁&& ▁th ise x ▁-> ▁present ▁== ▁1 ▁) ▁|| ▁( ▁type ▁== ▁TL SE XT _ TYPE _ ps k ▁&& ▁( ▁context ▁& ▁SSL _ EXT _ CLIENT _ HELLO ▁) ▁!= ▁0 ▁&& ▁PACKET _ remaining ▁( ▁& ▁extensions ▁) ▁!= ▁0 ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁, ▁SSL _ F _ TLS _ COL LECT _ EXTENSIONS ▁, ▁SSL _ R _ BAD _ EXTENSION ▁) ▁; ▁goto ▁err ▁; ▁} ▁idx ▁= ▁th ise x ▁- ▁raw _ extensions ▁; ▁if ▁( ▁idx ▁< ▁OSSL _ NE LEM ▁( ▁ext _ defs ▁) ▁&& ▁( ▁context ▁& ▁( ▁SSL _ EXT _ CLIENT _ HELLO ▁| ▁SSL _ EXT _ TLS 1_ 3_ CERTIFICATE _ REQUEST ▁| ▁SSL _ EXT _ TLS 1_ 3_ NEW _ SESSION _ TICK ET ▁) ▁) ▁== ▁0 ▁&& ▁type ▁!= ▁TL SE XT _ TYPE _ cookie ▁&& ▁type ▁!= ▁TL SE XT _ TYPE _ re neg ot iate ▁&& ▁type ▁!= ▁TL SE XT _ TYPE _ signed _ certificate _ timestamp ▁&& ▁( ▁s ▁-> ▁ext ▁. ▁ext flags ▁[ ▁idx ▁] ▁& ▁SSL _ EXT _ FLAG _ SENT ▁) ▁== ▁0 ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ UNSUPPORTED _ EXTENSION ▁, ▁SSL _ F _ TLS _ COL LECT _ EXTENSIONS ▁, ▁SSL _ R _ UN SOL IC IT ED _ EXTENSION ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁th ise x ▁!= ▁NULL ▁) ▁{ ▁th ise x ▁-> ▁data ▁= ▁extension ▁; ▁th ise x ▁-> ▁present ▁= ▁1 ▁; ▁th ise x ▁-> ▁type ▁= ▁type ▁; ▁th ise x ▁-> ▁received _ order ▁= ▁i ▁++ ▁; ▁if ▁( ▁s ▁-> ▁ext ▁. ▁debug _ cb ▁) ▁s ▁-> ▁ext ▁. ▁debug _ cb ▁( ▁s ▁, ▁! ▁s ▁-> ▁server ▁, ▁th ise x ▁-> ▁type ▁, ▁PACKET _ data ▁( ▁& ▁th ise x ▁-> ▁data ▁) ▁, ▁PACKET _ remaining ▁( ▁& ▁th ise x ▁-> ▁data ▁) ▁, ▁s ▁-> ▁ext ▁. ▁debug _ arg ▁) ▁; ▁} ▁} ▁if ▁( ▁init ▁) ▁{ ▁for ▁( ▁th ise xd ▁= ▁ext _ defs ▁, ▁i ▁= ▁0 ▁; ▁i ▁< ▁OSSL _ NE LEM ▁( ▁ext _ defs ▁) ▁; ▁i ▁++ ▁, ▁th ise xd ▁++ ▁) ▁{ ▁if ▁( ▁th ise xd ▁-> ▁init ▁!= ▁NULL ▁&& ▁( ▁th ise xd ▁-> ▁context ▁& ▁context ▁) ▁!= ▁0 ▁&& ▁extension _ is _ re levant ▁( ▁s ▁, ▁th ise xd ▁-> ▁context ▁, ▁context ▁) ▁&& ▁! ▁th ise xd ▁-> ▁init ▁( ▁s ▁, ▁context ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁} ▁} ▁* ▁res ▁= ▁raw _ extensions ▁; ▁if ▁( ▁len ▁!= ▁NULL ▁) ▁* ▁len ▁= ▁num _ ext s ▁; ▁return ▁1 ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁raw _ extensions ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁void ▁* ▁ev p _ generic _ fetch ▁( ▁OPENSSL _ CTX ▁* ▁lib ctx ▁, ▁int ▁operation _ id ▁, ▁const ▁char ▁* ▁algorithm ▁, ▁const ▁char ▁* ▁properties ▁, ▁void ▁* ▁( ▁* ▁new _ method ▁) ▁( ▁int ▁nid ▁, ▁const ▁OSSL _ DISPATCH ▁* ▁fns ▁, ▁OSSL _ PROVIDER ▁* ▁prov ▁) ▁, ▁int ▁( ▁* ▁up ref _ method ▁) ▁( ▁void ▁* ▁) ▁, ▁void ▁( ▁* ▁free _ method ▁) ▁( ▁void ▁* ▁) ▁, ▁int ▁( ▁* ▁nid _ method ▁) ▁( ▁void ▁* ▁) ▁) ▁{ ▁OSSL _ METHOD _ STORE ▁* ▁store ▁= ▁get _ default _ method _ store ▁( ▁lib ctx ▁) ▁; ▁int ▁nid ▁= ▁OBJ _ sn 2 nid ▁( ▁algorithm ▁) ▁; ▁void ▁* ▁method ▁= ▁NULL ▁; ▁if ▁( ▁store ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁nid ▁== ▁NID _ undef ▁|| ▁! ▁ossl _ method _ store _ cache _ get ▁( ▁store ▁, ▁nid ▁, ▁properties ▁, ▁& ▁method ▁) ▁) ▁{ ▁OSSL _ METHOD _ CON STRUCT _ METHOD ▁m cm ▁= ▁{ ▁alloc _ tmp _ method _ store ▁, ▁de alloc _ tmp _ method _ store ▁, ▁get _ method _ from _ store ▁, ▁put _ method _ in _ store ▁, ▁construct _ method ▁, ▁destruct _ method ▁} ▁; ▁struct ▁method _ data _ st ▁m cm data ▁; ▁m cm data ▁. ▁nid ▁= ▁nid ▁; ▁m cm data ▁. ▁m cm ▁= ▁& ▁m cm ▁; ▁m cm data ▁. ▁method _ from _ dispatch ▁= ▁new _ method ▁; ▁m cm data ▁. ▁destruct _ method ▁= ▁free _ method ▁; ▁m cm data ▁. ▁refcnt _ up _ method ▁= ▁up ref _ method ▁; ▁m cm data ▁. ▁destruct _ method ▁= ▁free _ method ▁; ▁m cm data ▁. ▁nid _ method ▁= ▁nid _ method ▁; ▁method ▁= ▁ossl _ method _ construct ▁( ▁lib ctx ▁, ▁operation _ id ▁, ▁algorithm ▁, ▁properties ▁, ▁0 ▁, ▁& ▁m cm ▁, ▁& ▁m cm data ▁) ▁; ▁ossl _ method _ store _ cache _ set ▁( ▁store ▁, ▁nid ▁, ▁properties ▁, ▁method ▁) ▁; ▁} ▁else ▁{ ▁up ref _ method ▁( ▁method ▁) ▁; ▁} ▁return ▁method ▁; ▁}	0
▁int 64_ t ▁av _ gcd ▁( ▁int 64_ t ▁a ▁, ▁int 64_ t ▁b ▁) ▁{ ▁int ▁za ▁, ▁zb ▁, ▁k ▁; ▁int 64_ t ▁u ▁, ▁v ▁; ▁if ▁( ▁a ▁== ▁0 ▁) ▁return ▁b ▁; ▁if ▁( ▁b ▁== ▁0 ▁) ▁return ▁a ▁; ▁za ▁= ▁ff _ ct z ll ▁( ▁a ▁) ▁; ▁zb ▁= ▁ff _ ct z ll ▁( ▁b ▁) ▁; ▁k ▁= ▁FF MIN ▁( ▁za ▁, ▁zb ▁) ▁; ▁u ▁= ▁l labs ▁( ▁a ▁>> ▁za ▁) ▁; ▁v ▁= ▁l labs ▁( ▁b ▁>> ▁zb ▁) ▁; ▁while ▁( ▁u ▁!= ▁v ▁) ▁{ ▁if ▁( ▁u ▁> ▁v ▁) ▁F FS W AP ▁( ▁int 64_ t ▁, ▁v ▁, ▁u ▁) ▁; ▁v ▁-= ▁u ▁; ▁v ▁>>= ▁ff _ ct z ll ▁( ▁v ▁) ▁; ▁} ▁return ▁u ▁<< ▁k ▁; ▁}	0
▁int ▁n _ ssl 3_ mac ▁( ▁SSL ▁* ▁ssl ▁, ▁unsigned ▁char ▁* ▁md ▁, ▁int ▁send ▁) ▁{ ▁SSL 3_ RECORD ▁* ▁rec ▁; ▁unsigned ▁char ▁* ▁mac _ sec ▁, ▁* ▁seq ▁; ▁EVP _ MD _ CTX ▁md _ ctx ▁; ▁const ▁EVP _ MD _ CTX ▁* ▁hash ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁rec _ char ▁; ▁size _ t ▁md _ size ▁, ▁orig _ len ▁; ▁int ▁np ad ▁; ▁int ▁t ▁; ▁if ▁( ▁send ▁) ▁{ ▁rec ▁= ▁& ▁( ▁ssl ▁-> ▁s 3 ▁-> ▁w rec ▁) ▁; ▁mac _ sec ▁= ▁& ▁( ▁ssl ▁-> ▁s 3 ▁-> ▁write _ mac _ secret ▁[ ▁0 ▁] ▁) ▁; ▁seq ▁= ▁& ▁( ▁ssl ▁-> ▁s 3 ▁-> ▁write _ sequence ▁[ ▁0 ▁] ▁) ▁; ▁hash ▁= ▁ssl ▁-> ▁write _ hash ▁; ▁} ▁else ▁{ ▁rec ▁= ▁& ▁( ▁ssl ▁-> ▁s 3 ▁-> ▁r rec ▁) ▁; ▁mac _ sec ▁= ▁& ▁( ▁ssl ▁-> ▁s 3 ▁-> ▁read _ mac _ secret ▁[ ▁0 ▁] ▁) ▁; ▁seq ▁= ▁& ▁( ▁ssl ▁-> ▁s 3 ▁-> ▁read _ sequence ▁[ ▁0 ▁] ▁) ▁; ▁hash ▁= ▁ssl ▁-> ▁read _ hash ▁; ▁} ▁t ▁= ▁EVP _ MD _ CTX _ size ▁( ▁hash ▁) ▁; ▁if ▁( ▁t ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁md _ size ▁= ▁t ▁; ▁np ad ▁= ▁( ▁48 ▁/ ▁md _ size ▁) ▁* ▁md _ size ▁; ▁orig _ len ▁= ▁rec ▁-> ▁length ▁+ ▁md _ size ▁+ ▁( ▁( ▁unsigned ▁int ▁) ▁rec ▁-> ▁type ▁>> ▁8 ▁) ▁; ▁rec ▁-> ▁type ▁&= ▁0 xff ▁; ▁if ▁( ▁! ▁send ▁&& ▁EVP _ CIPHER _ CTX _ mode ▁( ▁ssl ▁-> ▁enc _ read _ ctx ▁) ▁== ▁EVP _ C IPH _ CBC _ MODE ▁&& ▁ssl 3_ cbc _ record _ digest _ supported ▁( ▁hash ▁) ▁) ▁{ ▁unsigned ▁char ▁header ▁[ ▁75 ▁] ▁; ▁unsigned ▁j ▁= ▁0 ▁; ▁memcpy ▁( ▁header ▁+ ▁j ▁, ▁mac _ sec ▁, ▁md _ size ▁) ▁; ▁j ▁+= ▁md _ size ▁; ▁memcpy ▁( ▁header ▁+ ▁j ▁, ▁ssl 3_ pad _1 ▁, ▁np ad ▁) ▁; ▁j ▁+= ▁np ad ▁; ▁memcpy ▁( ▁header ▁+ ▁j ▁, ▁seq ▁, ▁8 ▁) ▁; ▁j ▁+= ▁8 ▁; ▁header ▁[ ▁j ▁++ ▁] ▁= ▁rec ▁-> ▁type ▁; ▁header ▁[ ▁j ▁++ ▁] ▁= ▁rec ▁-> ▁length ▁>> ▁8 ▁; ▁header ▁[ ▁j ▁++ ▁] ▁= ▁rec ▁-> ▁length ▁& ▁0 xff ▁; ▁ssl 3_ cbc _ digest _ record ▁( ▁hash ▁, ▁md ▁, ▁& ▁md _ size ▁, ▁header ▁, ▁rec ▁-> ▁input ▁, ▁rec ▁-> ▁length ▁+ ▁md _ size ▁, ▁orig _ len ▁, ▁mac _ sec ▁, ▁md _ size ▁, ▁1 ▁) ▁; ▁} ▁else ▁{ ▁unsigned ▁int ▁md _ size _ u ▁; ▁EVP _ MD _ CTX _ init ▁( ▁& ▁md _ ctx ▁) ▁; ▁EVP _ MD _ CTX _ copy _ ex ▁( ▁& ▁md _ ctx ▁, ▁hash ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁mac _ sec ▁, ▁md _ size ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁ssl 3_ pad _1 ▁, ▁np ad ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁seq ▁, ▁8 ▁) ▁; ▁rec _ char ▁= ▁rec ▁-> ▁type ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁& ▁rec _ char ▁, ▁1 ▁) ▁; ▁p ▁= ▁md ▁; ▁s 2 n ▁( ▁rec ▁-> ▁length ▁, ▁p ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁md ▁, ▁2 ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁rec ▁-> ▁input ▁, ▁rec ▁-> ▁length ▁) ▁; ▁EVP _ Digest Final _ ex ▁( ▁& ▁md _ ctx ▁, ▁md ▁, ▁NULL ▁) ▁; ▁EVP _ MD _ CTX _ copy _ ex ▁( ▁& ▁md _ ctx ▁, ▁hash ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁mac _ sec ▁, ▁md _ size ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁ssl 3_ pad _2 ▁, ▁np ad ▁) ▁; ▁EVP _ DigestUpdate ▁( ▁& ▁md _ ctx ▁, ▁md ▁, ▁md _ size ▁) ▁; ▁EVP _ Digest Final _ ex ▁( ▁& ▁md _ ctx ▁, ▁md ▁, ▁& ▁md _ size _ u ▁) ▁; ▁md _ size ▁= ▁md _ size _ u ▁; ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁md _ ctx ▁) ▁; ▁} ▁ssl 3_ record _ sequence _ update ▁( ▁seq ▁) ▁; ▁return ▁( ▁md _ size ▁) ▁; ▁}	0
▁void ▁ngx _ http _ finalize _ request ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ int _ t ▁rc ▁) ▁{ ▁ngx _ connection _ t ▁* ▁c ▁; ▁ngx _ http _ request _ t ▁* ▁pr ▁; ▁ngx _ http _ core _ loc _ conf _ t ▁* ▁cl cf ▁; ▁c ▁= ▁r ▁-> ▁connection ▁; ▁ngx _ log _ debug 5 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" http final iz ere quest :% d ,\" % V ? % V \" a :% d , c :% d " ▁, ▁rc ▁, ▁& ▁r ▁-> ▁uri ▁, ▁& ▁r ▁-> ▁args ▁, ▁r ▁== ▁c ▁-> ▁data ▁, ▁r ▁-> ▁main ▁-> ▁count ▁) ▁; ▁if ▁( ▁rc ▁== ▁NGX _ DONE ▁) ▁{ ▁ngx _ http _ finalize _ connection ▁( ▁r ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁rc ▁== ▁NGX _ OK ▁&& ▁r ▁-> ▁filter _ finalize ▁) ▁{ ▁c ▁-> ▁error ▁= ▁1 ▁; ▁} ▁if ▁( ▁rc ▁== ▁NGX _ DECL INED ▁) ▁{ ▁r ▁-> ▁content _ handler ▁= ▁NULL ▁; ▁r ▁-> ▁write _ event _ handler ▁= ▁ngx _ http _ core _ run _ ph ases ▁; ▁ngx _ http _ core _ run _ ph ases ▁( ▁r ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁r ▁!= ▁r ▁-> ▁main ▁&& ▁r ▁-> ▁post _ sub request ▁) ▁{ ▁rc ▁= ▁r ▁-> ▁post _ sub request ▁-> ▁handler ▁( ▁r ▁, ▁r ▁-> ▁post _ sub request ▁-> ▁data ▁, ▁rc ▁) ▁; ▁} ▁if ▁( ▁rc ▁== ▁NGX _ ERROR ▁|| ▁rc ▁== ▁NGX _ HTTP _ REQUEST _ TIME _ OUT ▁|| ▁rc ▁== ▁NGX _ HTTP _ CLIENT _ CLOSED _ REQUEST ▁|| ▁c ▁-> ▁error ▁) ▁{ ▁if ▁( ▁ngx _ http _ post _ action ▁( ▁r ▁) ▁== ▁NGX _ OK ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁r ▁-> ▁main ▁-> ▁blocked ▁) ▁{ ▁r ▁-> ▁write _ event _ handler ▁= ▁ngx _ http _ request _ final izer ▁; ▁} ▁ngx _ http _ terminate _ request ▁( ▁r ▁, ▁rc ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁rc ▁>= ▁NGX _ HTTP _ SPECIAL _ RESPONSE ▁|| ▁rc ▁== ▁NGX _ HTTP _ CREATED ▁|| ▁rc ▁== ▁NGX _ HTTP _ NO _ CONTENT ▁) ▁{ ▁if ▁( ▁rc ▁== ▁NGX _ HTTP _ CLOSE ▁) ▁{ ▁ngx _ http _ terminate _ request ▁( ▁r ▁, ▁rc ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁r ▁== ▁r ▁-> ▁main ▁) ▁{ ▁if ▁( ▁c ▁-> ▁read ▁-> ▁timer _ set ▁) ▁{ ▁ngx _ del _ timer ▁( ▁c ▁-> ▁read ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁write ▁-> ▁timer _ set ▁) ▁{ ▁ngx _ del _ timer ▁( ▁c ▁-> ▁write ▁) ▁; ▁} ▁} ▁c ▁-> ▁read ▁-> ▁handler ▁= ▁ngx _ http _ request _ handler ▁; ▁c ▁-> ▁write ▁-> ▁handler ▁= ▁ngx _ http _ request _ handler ▁; ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁ngx _ http _ special _ response _ handler ▁( ▁r ▁, ▁rc ▁) ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁r ▁!= ▁r ▁-> ▁main ▁) ▁{ ▁if ▁( ▁r ▁-> ▁buffered ▁|| ▁r ▁-> ▁post pon ed ▁) ▁{ ▁if ▁( ▁ngx _ http _ set _ write _ handler ▁( ▁r ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁ngx _ http _ terminate _ request ▁( ▁r ▁, ▁0 ▁) ▁; ▁} ▁return ▁; ▁} ▁pr ▁= ▁r ▁-> ▁parent ▁; ▁if ▁( ▁r ▁== ▁c ▁-> ▁data ▁) ▁{ ▁r ▁-> ▁main ▁-> ▁count ▁-- ▁; ▁r ▁-> ▁main ▁-> ▁sub requests ▁++ ▁; ▁if ▁( ▁! ▁r ▁-> ▁logged ▁) ▁{ ▁cl cf ▁= ▁ngx _ http _ get _ module _ loc _ conf ▁( ▁r ▁, ▁ngx _ http _ core _ module ▁) ▁; ▁if ▁( ▁cl cf ▁-> ▁log _ sub request ▁) ▁{ ▁ngx _ http _ log _ request ▁( ▁r ▁) ▁; ▁} ▁r ▁-> ▁logged ▁= ▁1 ▁; ▁} ▁else ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ALERT ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" sub request : \"% V ? % V \" log ged again " ▁, ▁& ▁r ▁-> ▁uri ▁, ▁& ▁r ▁-> ▁args ▁) ▁; ▁} ▁r ▁-> ▁done ▁= ▁1 ▁; ▁if ▁( ▁pr ▁-> ▁post pon ed ▁&& ▁pr ▁-> ▁post pon ed ▁-> ▁request ▁== ▁r ▁) ▁{ ▁pr ▁-> ▁post pon ed ▁= ▁pr ▁-> ▁post pon ed ▁-> ▁next ▁; ▁} ▁c ▁-> ▁data ▁= ▁pr ▁; ▁} ▁else ▁{ ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" http final iz en on - act iver e quest : \"% V ? % V \"" ▁, ▁& ▁r ▁-> ▁uri ▁, ▁& ▁r ▁-> ▁args ▁) ▁; ▁r ▁-> ▁write _ event _ handler ▁= ▁ngx _ http _ request _ final izer ▁; ▁if ▁( ▁r ▁-> ▁wait ed ▁) ▁{ ▁r ▁-> ▁done ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁ngx _ http _ post _ request ▁( ▁pr ▁, ▁NULL ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁r ▁-> ▁main ▁-> ▁count ▁++ ▁; ▁ngx _ http _ terminate _ request ▁( ▁r ▁, ▁0 ▁) ▁; ▁return ▁; ▁} ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" http wake parent request : \"% V ? % V \"" ▁, ▁& ▁pr ▁-> ▁uri ▁, ▁& ▁pr ▁-> ▁args ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁r ▁-> ▁buffered ▁|| ▁c ▁-> ▁buffered ▁|| ▁r ▁-> ▁post pon ed ▁|| ▁r ▁-> ▁blocked ▁) ▁{ ▁if ▁( ▁ngx _ http _ set _ write _ handler ▁( ▁r ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁ngx _ http _ terminate _ request ▁( ▁r ▁, ▁0 ▁) ▁; ▁} ▁return ▁; ▁} ▁if ▁( ▁r ▁!= ▁c ▁-> ▁data ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ALERT ▁, ▁c ▁-> ▁log ▁, ▁0 ▁, ▁" http final iz en on - act iver e quest : \"% V ? % V \"" ▁, ▁& ▁r ▁-> ▁uri ▁, ▁& ▁r ▁-> ▁args ▁) ▁; ▁return ▁; ▁} ▁r ▁-> ▁done ▁= ▁1 ▁; ▁r ▁-> ▁write _ event _ handler ▁= ▁ngx _ http _ request _ empty _ handler ▁; ▁if ▁( ▁! ▁r ▁-> ▁post _ action ▁) ▁{ ▁r ▁-> ▁request _ complete ▁= ▁1 ▁; ▁} ▁if ▁( ▁ngx _ http _ post _ action ▁( ▁r ▁) ▁== ▁NGX _ OK ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁c ▁-> ▁read ▁-> ▁timer _ set ▁) ▁{ ▁ngx _ del _ timer ▁( ▁c ▁-> ▁read ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁write ▁-> ▁timer _ set ▁) ▁{ ▁c ▁-> ▁write ▁-> ▁delayed ▁= ▁0 ▁; ▁ngx _ del _ timer ▁( ▁c ▁-> ▁write ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁read ▁-> ▁eof ▁) ▁{ ▁ngx _ http _ close _ request ▁( ▁r ▁, ▁0 ▁) ▁; ▁return ▁; ▁} ▁ngx _ http _ finalize _ connection ▁( ▁r ▁) ▁; ▁}	1
▁static ▁void ▁FUNC ▁( ▁trans quant _ bypass 8 x 8 ▁) ▁( ▁uint 8_ t ▁* ▁_ dst ▁, ▁int 16_ t ▁* ▁coeffs ▁, ▁ptrdiff _ t ▁stride ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁pixel ▁* ▁dst ▁= ▁( ▁pixel ▁* ▁) ▁_ dst ▁; ▁stride ▁/= ▁sizeof ▁( ▁pixel ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁8 ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁8 ▁; ▁x ▁++ ▁) ▁{ ▁dst ▁[ ▁x ▁] ▁+= ▁* ▁coeffs ▁; ▁coeffs ▁++ ▁; ▁} ▁dst ▁+= ▁stride ▁; ▁} ▁}	1
▁static ▁ngx _ http _ up stream _ rr _ peer _ t ▁* ▁ngx _ http _ up stream _ get _ peer ▁( ▁ngx _ http _ up stream _ rr _ peer _ data _ t ▁* ▁r rp ▁) ▁{ ▁time _ t ▁now ▁; ▁uintptr _ t ▁m ▁; ▁ngx _ int _ t ▁total ▁; ▁ngx _ uint _ t ▁i ▁, ▁n ▁; ▁ngx _ http _ up stream _ rr _ peer _ t ▁* ▁peer ▁, ▁* ▁best ▁; ▁now ▁= ▁ngx _ time ▁( ▁) ▁; ▁best ▁= ▁NULL ▁; ▁total ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁r rp ▁-> ▁peers ▁-> ▁number ▁; ▁i ▁++ ▁) ▁{ ▁n ▁= ▁i ▁/ ▁( ▁8 ▁* ▁sizeof ▁( ▁uintptr _ t ▁) ▁) ▁; ▁m ▁= ▁( ▁uintptr _ t ▁) ▁1 ▁<< ▁i ▁% ▁( ▁8 ▁* ▁sizeof ▁( ▁uintptr _ t ▁) ▁) ▁; ▁if ▁( ▁r rp ▁-> ▁tried ▁[ ▁n ▁] ▁& ▁m ▁) ▁{ ▁continue ▁; ▁} ▁peer ▁= ▁& ▁r rp ▁-> ▁peers ▁-> ▁peer ▁[ ▁i ▁] ▁; ▁if ▁( ▁peer ▁-> ▁down ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁peer ▁-> ▁max _ fails ▁&& ▁peer ▁-> ▁fails ▁>= ▁peer ▁-> ▁max _ fails ▁&& ▁now ▁- ▁peer ▁-> ▁checked ▁<= ▁peer ▁-> ▁fail _ timeout ▁) ▁{ ▁continue ▁; ▁} ▁peer ▁-> ▁current _ weight ▁+= ▁peer ▁-> ▁effective _ weight ▁; ▁total ▁+= ▁peer ▁-> ▁effective _ weight ▁; ▁if ▁( ▁peer ▁-> ▁effective _ weight ▁< ▁peer ▁-> ▁weight ▁) ▁{ ▁peer ▁-> ▁effective _ weight ▁++ ▁; ▁} ▁if ▁( ▁best ▁== ▁NULL ▁|| ▁peer ▁-> ▁current _ weight ▁> ▁best ▁-> ▁current _ weight ▁) ▁{ ▁best ▁= ▁peer ▁; ▁} ▁} ▁if ▁( ▁best ▁== ▁NULL ▁) ▁{ ▁return ▁NULL ▁; ▁} ▁i ▁= ▁best ▁- ▁& ▁r rp ▁-> ▁peers ▁-> ▁peer ▁[ ▁0 ▁] ▁; ▁r rp ▁-> ▁current ▁= ▁i ▁; ▁n ▁= ▁i ▁/ ▁( ▁8 ▁* ▁sizeof ▁( ▁uintptr _ t ▁) ▁) ▁; ▁m ▁= ▁( ▁uintptr _ t ▁) ▁1 ▁<< ▁i ▁% ▁( ▁8 ▁* ▁sizeof ▁( ▁uintptr _ t ▁) ▁) ▁; ▁r rp ▁-> ▁tried ▁[ ▁n ▁] ▁|= ▁m ▁; ▁best ▁-> ▁current _ weight ▁-= ▁total ▁; ▁best ▁-> ▁checked ▁= ▁now ▁; ▁return ▁best ▁; ▁}	0
▁static ▁int ▁aac _ decode _ frame ▁( ▁AVCodecContext ▁* ▁av c context ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁AAC Context ▁* ▁ac ▁= ▁av c context ▁-> ▁priv _ data ▁; ▁Get Bit Context ▁gb ▁; ▁enum ▁Raw Data Block Type ▁elem _ type ▁; ▁int ▁err ▁, ▁elem _ id ▁, ▁data _ size _ tmp ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁if ▁( ▁show _ bits ▁( ▁& ▁gb ▁, ▁12 ▁) ▁== ▁0 xfff ▁) ▁{ ▁if ▁( ▁( ▁err ▁= ▁parse _ ad ts _ frame _ header ▁( ▁ac ▁, ▁& ▁gb ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁av c context ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error de coding A AC frame header .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁} ▁while ▁( ▁( ▁elem _ type ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁3 ▁) ▁) ▁!= ▁TYPE _ END ▁) ▁{ ▁elem _ id ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁err ▁= ▁-1 ▁; ▁if ▁( ▁elem _ type ▁== ▁TYPE _ S CE ▁&& ▁elem _ id ▁== ▁1 ▁&& ▁! ▁ac ▁-> ▁che ▁[ ▁TYPE _ S CE ▁] ▁[ ▁elem _ id ▁] ▁&& ▁ac ▁-> ▁che ▁[ ▁TYPE _ L FE ▁] ▁[ ▁0 ▁] ▁) ▁{ ▁ac ▁-> ▁che ▁[ ▁TYPE _ S CE ▁] ▁[ ▁elem _ id ▁] ▁= ▁ac ▁-> ▁che ▁[ ▁TYPE _ L FE ▁] ▁[ ▁0 ▁] ▁; ▁ac ▁-> ▁che ▁[ ▁TYPE _ L FE ▁] ▁[ ▁0 ▁] ▁= ▁NULL ▁; ▁} ▁if ▁( ▁elem _ type ▁< ▁TYPE _ DSE ▁) ▁{ ▁if ▁( ▁! ▁ac ▁-> ▁che ▁[ ▁elem _ type ▁] ▁[ ▁elem _ id ▁] ▁) ▁return ▁-1 ▁; ▁if ▁( ▁elem _ type ▁!= ▁TYPE _ CCE ▁) ▁ac ▁-> ▁che ▁[ ▁elem _ type ▁] ▁[ ▁elem _ id ▁] ▁-> ▁coup ▁. ▁coup ling _ point ▁= ▁4 ▁; ▁} ▁switch ▁( ▁elem _ type ▁) ▁{ ▁case ▁TYPE _ S CE ▁: ▁err ▁= ▁decode _ ics ▁( ▁ac ▁, ▁& ▁ac ▁-> ▁che ▁[ ▁TYPE _ S CE ▁] ▁[ ▁elem _ id ▁] ▁-> ▁ch ▁[ ▁0 ▁] ▁, ▁& ▁gb ▁, ▁0 ▁, ▁0 ▁) ▁; ▁break ▁; ▁case ▁TYPE _ C PE ▁: ▁err ▁= ▁decode _ c pe ▁( ▁ac ▁, ▁& ▁gb ▁, ▁elem _ id ▁) ▁; ▁break ▁; ▁case ▁TYPE _ CCE ▁: ▁err ▁= ▁decode _ cce ▁( ▁ac ▁, ▁& ▁gb ▁, ▁ac ▁-> ▁che ▁[ ▁TYPE _ CCE ▁] ▁[ ▁elem _ id ▁] ▁) ▁; ▁break ▁; ▁case ▁TYPE _ L FE ▁: ▁err ▁= ▁decode _ ics ▁( ▁ac ▁, ▁& ▁ac ▁-> ▁che ▁[ ▁TYPE _ L FE ▁] ▁[ ▁elem _ id ▁] ▁-> ▁ch ▁[ ▁0 ▁] ▁, ▁& ▁gb ▁, ▁0 ▁, ▁0 ▁) ▁; ▁break ▁; ▁case ▁TYPE _ DSE ▁: ▁skip _ data _ stream _ element ▁( ▁& ▁gb ▁) ▁; ▁err ▁= ▁0 ▁; ▁break ▁; ▁case ▁TYPE _ P CE ▁: ▁{ ▁enum ▁Channel Position ▁new _ che _ pos ▁[ ▁4 ▁] ▁[ ▁MAX _ ELEM _ ID ▁] ▁; ▁memset ▁( ▁new _ che _ pos ▁, ▁0 ▁, ▁4 ▁* ▁MAX _ ELEM _ ID ▁* ▁sizeof ▁( ▁new _ che _ pos ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁( ▁err ▁= ▁decode _ p ce ▁( ▁ac ▁, ▁new _ che _ pos ▁, ▁& ▁gb ▁) ▁) ▁) ▁break ▁; ▁err ▁= ▁output _ configure ▁( ▁ac ▁, ▁ac ▁-> ▁che _ pos ▁, ▁new _ che _ pos ▁) ▁; ▁break ▁; ▁} ▁case ▁TYPE _ FIL ▁: ▁if ▁( ▁elem _ id ▁== ▁15 ▁) ▁elem _ id ▁+= ▁get _ bits ▁( ▁& ▁gb ▁, ▁8 ▁) ▁- ▁1 ▁; ▁while ▁( ▁elem _ id ▁> ▁0 ▁) ▁elem _ id ▁-= ▁decode _ extension _ payload ▁( ▁ac ▁, ▁& ▁gb ▁, ▁elem _ id ▁) ▁; ▁err ▁= ▁0 ▁; ▁break ▁; ▁default ▁: ▁err ▁= ▁-1 ▁; ▁break ▁; ▁} ▁if ▁( ▁err ▁) ▁return ▁err ▁; ▁} ▁s pectral _ to _ sample ▁( ▁ac ▁) ▁; ▁if ▁( ▁! ▁ac ▁-> ▁is _ saved ▁) ▁{ ▁ac ▁-> ▁is _ saved ▁= ▁1 ▁; ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁buf _ size ▁; ▁} ▁data _ size _ tmp ▁= ▁1024 ▁* ▁av c context ▁-> ▁channels ▁* ▁sizeof ▁( ▁int 16_ t ▁) ▁; ▁if ▁( ▁* ▁data _ size ▁< ▁data _ size _ tmp ▁) ▁{ ▁av _ log ▁( ▁av c context ▁, ▁AV _ LOG _ ERROR ▁, ▁" Output buff ert oo small (% d ) ort ry ing too utput too man ys amples (% d ) f orth is frame .\ n " ▁, ▁* ▁data _ size ▁, ▁data _ size _ tmp ▁) ▁; ▁return ▁-1 ▁; ▁} ▁* ▁data _ size ▁= ▁data _ size _ tmp ▁; ▁ac ▁-> ▁dsp ▁. ▁float _ to _ int 16_ inter leave ▁( ▁data ▁, ▁( ▁const ▁float ▁* ▁* ▁) ▁ac ▁-> ▁output _ data ▁, ▁1024 ▁, ▁av c context ▁-> ▁channels ▁) ▁; ▁return ▁buf _ size ▁; ▁}	0
▁static ▁int ▁write _ manifest ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁final ▁) ▁{ ▁D ASH Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁out ▁; ▁char ▁temp _ filename ▁[ ▁1024 ▁] ▁; ▁int ▁ret ▁, ▁i ▁; ▁AV Dictionary Entry ▁* ▁title ▁= ▁av _ dict _ get ▁( ▁s ▁-> ▁metadata ▁, ▁" title " ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁snprintf ▁( ▁temp _ filename ▁, ▁sizeof ▁( ▁temp _ filename ▁) ▁, ▁"% s . tmp " ▁, ▁s ▁-> ▁filename ▁) ▁; ▁ret ▁= ▁avio _ open 2 ▁( ▁& ▁out ▁, ▁temp _ filename ▁, ▁AVIO _ FLAG _ WRITE ▁, ▁& ▁s ▁-> ▁interrupt _ callback ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unable too pen % s for writing \ n " ▁, ▁temp _ filename ▁) ▁; ▁return ▁ret ▁; ▁} ▁avio _ printf ▁( ▁out ▁, ▁"<? xml version =\"1.0\" encoding =\" utf -8 \" ? >\ n " ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"< MP D xmlns : x si =\" http :// www . w 3. org /2001/ XMLSchema - instance \"\ n " ▁"\ tx ml ns =\" urn : mpeg : dash : schema : mp d : 201 1 \"\ n " ▁"\ tx ml ns : x link =\" http :// www . w 3. org /1 999 / x link \"\ n " ▁"\ tx si : schema Location =\" urn : mpeg : D ASH : schema : MP D : 201 1 http :// standard s . iso . org / it tf / Public ly Available Standard s / MPEG - D ASH _ schema _ files / D ASH - MP D . xsd \"\ n " ▁"\ tpro files =\" urn : mpeg : dash : profile : is off - live : 201 1 \"\ n " ▁"\ t type =\"% s \"\ n " ▁, ▁final ▁? ▁" static " ▁: ▁" dynamic " ▁) ▁; ▁if ▁( ▁final ▁) ▁{ ▁avio _ printf ▁( ▁out ▁, ▁"\ tm edia Presentation Duration =\"" ▁) ▁; ▁write _ time ▁( ▁out ▁, ▁c ▁-> ▁total _ duration ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\" \ n " ▁) ▁; ▁} ▁else ▁{ ▁int ▁update _ period ▁= ▁c ▁-> ▁last _ duration ▁/ ▁AV _ TIME _ BASE ▁; ▁if ▁( ▁c ▁-> ▁use _ template ▁&& ▁! ▁c ▁-> ▁use _ timeline ▁) ▁update _ period ▁= ▁500 ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t minimum Update Period =\" PT % d S \"\ n " ▁, ▁update _ period ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ ts u ggested Presentation Delay =\" PT % d S \"\ n " ▁, ▁c ▁-> ▁last _ duration ▁/ ▁AV _ TIME _ BASE ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁availability _ start _ time ▁[ ▁0 ▁] ▁&& ▁s ▁-> ▁nb _ streams ▁> ▁0 ▁&& ▁c ▁-> ▁streams ▁[ ▁0 ▁] ▁. ▁nb _ segments ▁> ▁0 ▁) ▁{ ▁time _ t ▁t ▁= ▁time ▁( ▁NULL ▁) ▁; ▁struct ▁tm ▁* ▁pt m ▁, ▁tm buf ▁; ▁pt m ▁= ▁gmt ime _ r ▁( ▁& ▁t ▁, ▁& ▁tm buf ▁) ▁; ▁if ▁( ▁pt m ▁) ▁{ ▁if ▁( ▁! ▁strftime ▁( ▁c ▁-> ▁availability _ start _ time ▁, ▁sizeof ▁( ▁c ▁-> ▁availability _ start _ time ▁) ▁, ▁"% Y -% m -% d T % H :% M :% S " ▁, ▁pt m ▁) ▁) ▁c ▁-> ▁availability _ start _ time ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁} ▁if ▁( ▁c ▁-> ▁availability _ start _ time ▁[ ▁0 ▁] ▁) ▁avio _ printf ▁( ▁out ▁, ▁"\ t availability StartTime =\"% s \"\ n " ▁, ▁c ▁-> ▁availability _ start _ time ▁) ▁; ▁if ▁( ▁c ▁-> ▁window _ size ▁&& ▁c ▁-> ▁use _ template ▁) ▁{ ▁avio _ printf ▁( ▁out ▁, ▁"\ t time Shift Buffer Depth =\"" ▁) ▁; ▁write _ time ▁( ▁out ▁, ▁c ▁-> ▁last _ duration ▁* ▁c ▁-> ▁window _ size ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\" \ n " ▁) ▁; ▁} ▁} ▁avio _ printf ▁( ▁out ▁, ▁"\ t min Buffer Time =\"" ▁) ▁; ▁write _ time ▁( ▁out ▁, ▁c ▁-> ▁last _ duration ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ "> \ n " ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t < Program Information >\ n " ▁) ▁; ▁if ▁( ▁title ▁) ▁{ ▁char ▁* ▁escaped ▁= ▁xm le scape ▁( ▁title ▁-> ▁value ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t < Title >% s </ Title >\ n " ▁, ▁escaped ▁) ▁; ▁av _ free ▁( ▁escaped ▁) ▁; ▁} ▁avio _ printf ▁( ▁out ▁, ▁"\ t </ Program Information >\ n " ▁) ▁; ▁if ▁( ▁c ▁-> ▁window _ size ▁&& ▁s ▁-> ▁nb _ streams ▁> ▁0 ▁&& ▁c ▁-> ▁streams ▁[ ▁0 ▁] ▁. ▁nb _ segments ▁> ▁0 ▁&& ▁! ▁c ▁-> ▁use _ template ▁) ▁{ ▁OutputStream ▁* ▁os ▁= ▁& ▁c ▁-> ▁streams ▁[ ▁0 ▁] ▁; ▁int ▁start _ index ▁= ▁FF MAX ▁( ▁os ▁-> ▁nb _ segments ▁- ▁c ▁-> ▁window _ size ▁, ▁0 ▁) ▁; ▁int 64_ t ▁start _ time ▁= ▁av _ re scale _ q ▁( ▁os ▁-> ▁segments ▁[ ▁start _ index ▁] ▁-> ▁time ▁, ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t < Period start =\"" ▁) ▁; ▁write _ time ▁( ▁out ▁, ▁start _ time ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ "> \ n " ▁) ▁; ▁} ▁else ▁{ ▁avio _ printf ▁( ▁out ▁, ▁"\ t < Period start =\" PT 0 .0 S \">\ n " ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁has _ video ▁) ▁{ ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t < Adapt ation Set id =\" video \" segment Alignment =\" true \" bit stream Switch ing =\" true \">\ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁OutputStream ▁* ▁os ▁= ▁& ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁codec ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁continue ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t \ t < Representation id =\"% d \" m imeType =\" video / mp 4 \" codecs =\"% s \"% sw idth =\"% d \" height =\"% d \">\ n " ▁, ▁i ▁, ▁os ▁-> ▁codec _ str ▁, ▁os ▁-> ▁bandwidth _ str ▁, ▁st ▁-> ▁codec ▁-> ▁width ▁, ▁st ▁-> ▁codec ▁-> ▁height ▁) ▁; ▁output _ segment _ list ▁( ▁& ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁, ▁out ▁, ▁c ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t \ t </ Representation >\ n " ▁) ▁; ▁} ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t </ Adapt ation Set >\ n " ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁has _ audio ▁) ▁{ ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t < Adapt ation Set id =\" audio \" segment Alignment =\" true \" bit stream Switch ing =\" true \">\ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁OutputStream ▁* ▁os ▁= ▁& ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁codec ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁continue ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t \ t < Representation id =\"% d \" m imeType =\" audio / mp 4 \" codecs =\"% s \"% sa udio Sampling Rate =\"% d \">\ n " ▁, ▁i ▁, ▁os ▁-> ▁codec _ str ▁, ▁os ▁-> ▁bandwidth _ str ▁, ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t \ t \ t < Audio Channel Configurations c heme Id Uri =\" urn : mpeg : dash : 23 003 : 3: audio _ channel _ configuration : 201 1\" value =\"% d \" /> \ n " ▁, ▁st ▁-> ▁codec ▁-> ▁channels ▁) ▁; ▁output _ segment _ list ▁( ▁& ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁, ▁out ▁, ▁c ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t \ t </ Representation >\ n " ▁) ▁; ▁} ▁avio _ printf ▁( ▁out ▁, ▁"\ t \ t </ Adapt ation Set >\ n " ▁) ▁; ▁} ▁avio _ printf ▁( ▁out ▁, ▁"\ t </ Period >\ n " ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"</ MP D >\ n " ▁) ▁; ▁avio _ flush ▁( ▁out ▁) ▁; ▁avio _ close ▁( ▁out ▁) ▁; ▁return ▁ff _ rename ▁( ▁temp _ filename ▁, ▁s ▁-> ▁filename ▁, ▁s ▁) ▁; ▁}	1
▁int ▁ASN 1_ get _ object ▁( ▁const ▁unsigned ▁char ▁* ▁* ▁pp ▁, ▁long ▁* ▁p length ▁, ▁int ▁* ▁pt ag ▁, ▁int ▁* ▁p class ▁, ▁long ▁o max ▁) ▁{ ▁int ▁i ▁, ▁ret ▁; ▁long ▁l ▁; ▁const ▁unsigned ▁char ▁* ▁p ▁= ▁* ▁pp ▁; ▁int ▁tag ▁, ▁x class ▁, ▁inf ▁; ▁long ▁max ▁= ▁o max ▁; ▁if ▁( ▁! ▁max ▁) ▁goto ▁err ▁; ▁ret ▁= ▁( ▁* ▁p ▁& ▁V _ ASN 1_ CON STRUCT ED ▁) ▁; ▁x class ▁= ▁( ▁* ▁p ▁& ▁V _ ASN 1_ PRIVATE ▁) ▁; ▁i ▁= ▁* ▁p ▁& ▁V _ ASN 1_ PRIMITIVE _ TAG ▁; ▁if ▁( ▁i ▁== ▁V _ ASN 1_ PRIMITIVE _ TAG ▁) ▁{ ▁p ▁++ ▁; ▁if ▁( ▁-- ▁max ▁== ▁0 ▁) ▁goto ▁err ▁; ▁l ▁= ▁0 ▁; ▁while ▁( ▁* ▁p ▁& ▁0 x 80 ▁) ▁{ ▁l ▁<<= ▁7 L ▁; ▁l ▁|= ▁* ▁( ▁p ▁++ ▁) ▁& ▁0 x 7 f ▁; ▁if ▁( ▁-- ▁max ▁== ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁l ▁> ▁( ▁INT _ MAX ▁>> ▁7 L ▁) ▁) ▁goto ▁err ▁; ▁} ▁l ▁<<= ▁7 L ▁; ▁l ▁|= ▁* ▁( ▁p ▁++ ▁) ▁& ▁0 x 7 f ▁; ▁tag ▁= ▁( ▁int ▁) ▁l ▁; ▁if ▁( ▁-- ▁max ▁== ▁0 ▁) ▁goto ▁err ▁; ▁} ▁else ▁{ ▁tag ▁= ▁i ▁; ▁p ▁++ ▁; ▁if ▁( ▁-- ▁max ▁== ▁0 ▁) ▁goto ▁err ▁; ▁} ▁* ▁pt ag ▁= ▁tag ▁; ▁* ▁p class ▁= ▁x class ▁; ▁if ▁( ▁! ▁asn 1_ get _ length ▁( ▁& ▁p ▁, ▁& ▁inf ▁, ▁p length ▁, ▁( ▁int ▁) ▁max ▁) ▁) ▁goto ▁err ▁; ▁# if ▁0 ▁fprintf ▁( ▁stderr ▁, ▁" p =% d + * p length =% ld > om ax =% ld + * pp =% d (% d >% d )\ n " ▁, ▁( ▁int ▁) ▁p ▁, ▁* ▁p length ▁, ▁o max ▁, ▁( ▁int ▁) ▁* ▁pp ▁, ▁( ▁int ▁) ▁( ▁p ▁+ ▁* ▁p length ▁) ▁, ▁( ▁int ▁) ▁( ▁o max ▁+ ▁* ▁pp ▁) ▁) ▁; ▁# endif ▁if ▁( ▁* ▁p length ▁> ▁( ▁o max ▁- ▁( ▁p ▁- ▁* ▁pp ▁) ▁) ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ GET _ OBJECT ▁, ▁ASN 1_ R _ TOO _ LONG ▁) ▁; ▁ret ▁|= ▁0 x 80 ▁; ▁} ▁* ▁pp ▁= ▁p ▁; ▁return ▁( ▁ret ▁| ▁inf ▁) ▁; ▁err ▁: ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ GET _ OBJECT ▁, ▁ASN 1_ R _ HEADER _ TOO _ LONG ▁) ▁; ▁return ▁( ▁0 x 80 ▁) ▁; ▁}	1
▁static ▁void ▁discard _ script _ output ▁( ▁apr _ bucket _ b rig ade ▁* ▁bb ▁) ▁{ ▁apr _ bucket ▁* ▁e ▁; ▁const ▁char ▁* ▁buf ▁; ▁apr _ size _ t ▁len ▁; ▁apr _ status _ t ▁rv ▁; ▁for ▁( ▁e ▁= ▁APR _ BR IG ADE _ FIRST ▁( ▁bb ▁) ▁; ▁e ▁!= ▁APR _ BR IG ADE _ SENT IN EL ▁( ▁bb ▁) ▁; ▁e ▁= ▁APR _ BUCKET _ NEXT ▁( ▁e ▁) ▁) ▁{ ▁if ▁( ▁APR _ BUCKET _ IS _ E OS ▁( ▁e ▁) ▁) ▁{ ▁break ▁; ▁} ▁rv ▁= ▁apr _ bucket _ read ▁( ▁e ▁, ▁& ▁buf ▁, ▁& ▁len ▁, ▁APR _ BLOCK _ READ ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁break ▁; ▁} ▁} ▁}	1
▁static ▁int ▁handle _ packets ▁( ▁Mpeg TS Context ▁* ▁ts ▁, ▁int ▁nb _ packets ▁) ▁{ ▁AVFormatContext ▁* ▁s ▁= ▁ts ▁-> ▁stream ▁; ▁uint 8_ t ▁packet ▁[ ▁TS _ PACKET _ SIZE ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁] ▁; ▁int ▁packet _ num ▁, ▁ret ▁= ▁0 ▁; ▁if ▁( ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁!= ▁ts ▁-> ▁last _ pos ▁) ▁{ ▁int ▁i ▁; ▁av _ d log ▁( ▁ts ▁-> ▁stream ▁, ▁" Skipping after seek \ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ PID _ MAX ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ts ▁-> ▁pids ▁[ ▁i ▁] ▁) ▁{ ▁if ▁( ▁ts ▁-> ▁pids ▁[ ▁i ▁] ▁-> ▁type ▁== ▁M PEG TS _ P ES ▁) ▁{ ▁P ES Context ▁* ▁p es ▁= ▁ts ▁-> ▁pids ▁[ ▁i ▁] ▁-> ▁u ▁. ▁p es _ filter ▁. ▁opaque ▁; ▁av _ freep ▁( ▁& ▁p es ▁-> ▁buffer ▁) ▁; ▁p es ▁-> ▁data _ index ▁= ▁0 ▁; ▁p es ▁-> ▁state ▁= ▁M PEG TS _ SKIP ▁; ▁} ▁ts ▁-> ▁pids ▁[ ▁i ▁] ▁-> ▁last _ cc ▁= ▁-1 ▁; ▁} ▁} ▁} ▁ts ▁-> ▁stop _ parse ▁= ▁0 ▁; ▁packet _ num ▁= ▁0 ▁; ▁memset ▁( ▁packet ▁+ ▁TS _ PACKET _ SIZE ▁, ▁0 ▁, ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁ts ▁-> ▁stop _ parse ▁> ▁0 ▁) ▁break ▁; ▁packet _ num ▁++ ▁; ▁if ▁( ▁nb _ packets ▁!= ▁0 ▁&& ▁packet _ num ▁>= ▁nb _ packets ▁) ▁break ▁; ▁ret ▁= ▁read _ packet ▁( ▁s ▁, ▁packet ▁, ▁ts ▁-> ▁raw _ packet _ size ▁) ▁; ▁if ▁( ▁ret ▁!= ▁0 ▁) ▁break ▁; ▁ret ▁= ▁handle _ packet ▁( ▁ts ▁, ▁packet ▁) ▁; ▁if ▁( ▁ret ▁!= ▁0 ▁) ▁break ▁; ▁} ▁ts ▁-> ▁last _ pos ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁asn 1_ put _ length ▁( ▁unsigned ▁char ▁* ▁* ▁pp ▁, ▁int ▁length ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁= ▁* ▁pp ▁; ▁int ▁i ▁, ▁l ▁; ▁if ▁( ▁length ▁<= ▁127 ▁) ▁* ▁( ▁p ▁++ ▁) ▁= ▁( ▁unsigned ▁char ▁) ▁length ▁; ▁else ▁{ ▁l ▁= ▁length ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁l ▁> ▁0 ▁; ▁i ▁++ ▁) ▁l ▁>>= ▁8 ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁i ▁| ▁0 x 80 ▁; ▁l ▁= ▁i ▁; ▁while ▁( ▁i ▁-- ▁> ▁0 ▁) ▁{ ▁p ▁[ ▁i ▁] ▁= ▁length ▁& ▁0 xff ▁; ▁length ▁>>= ▁8 ▁; ▁} ▁p ▁+= ▁l ▁; ▁} ▁* ▁pp ▁= ▁p ▁; ▁}	1
▁int ▁test _ k ron ▁( ▁BIO ▁* ▁bp ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁, ▁* ▁r ▁, ▁* ▁t ▁; ▁int ▁i ▁; ▁int ▁legend re ▁, ▁kr one cker ▁; ▁int ▁ret ▁= ▁0 ▁; ▁a ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁= ▁BN _ new ▁( ▁) ▁; ▁r ▁= ▁BN _ new ▁( ▁) ▁; ▁t ▁= ▁BN _ new ▁( ▁) ▁; ▁if ▁( ▁a ▁== ▁NULL ▁|| ▁b ▁== ▁NULL ▁|| ▁r ▁== ▁NULL ▁|| ▁t ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁# if ▁0 ▁if ▁( ▁! ▁BN _ generate _ prime ▁( ▁b ▁, ▁512 ▁, ▁0 ▁, ▁NULL ▁, ▁NULL ▁, ▁gen prime _ cb ▁, ▁NULL ▁) ▁) ▁goto ▁err ▁; ▁# else ▁BN _ set _ word ▁( ▁b ▁, ▁655 37 ▁) ▁; ▁# endif ▁putc ▁( ▁' ▁\ n ▁' ▁, ▁stderr ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num 0 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁BN _ rand ▁( ▁a ▁, ▁512 ▁, ▁0 ▁, ▁0 ▁) ▁) ▁goto ▁err ▁; ▁a ▁-> ▁neg ▁= ▁rand _ neg ▁( ▁) ▁; ▁if ▁( ▁! ▁BN _ copy ▁( ▁t ▁, ▁b ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ sub _ word ▁( ▁t ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ rshift 1 ▁( ▁t ▁, ▁t ▁) ▁) ▁goto ▁err ▁; ▁# if ▁1 ▁if ▁( ▁! ▁BN _ mod _ exp ▁( ▁r ▁, ▁a ▁, ▁t ▁, ▁b ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁# elif ▁0 ▁if ▁( ▁! ▁BN _ mod _ exp _ re cp ▁( ▁r ▁, ▁a ▁, ▁t ▁, ▁b ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁# else ▁if ▁( ▁! ▁BN _ mod _ exp _ simple ▁( ▁r ▁, ▁a ▁, ▁t ▁, ▁b ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁# endif ▁if ▁( ▁BN _ is _ word ▁( ▁r ▁, ▁1 ▁) ▁) ▁legend re ▁= ▁1 ▁; ▁else ▁{ ▁if ▁( ▁! ▁BN _ add _ word ▁( ▁r ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁0 ▁!= ▁BN _ cmp ▁( ▁r ▁, ▁b ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Legend res ymbol comp utation failed \ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁legend re ▁= ▁-1 ▁; ▁} ▁kr one cker ▁= ▁BN _ kr one cker ▁( ▁a ▁, ▁b ▁, ▁ctx ▁) ▁; ▁if ▁( ▁kr one cker ▁< ▁-1 ▁) ▁goto ▁err ▁; ▁if ▁( ▁legend re ▁!= ▁kr one cker ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" leg end re ! = kr one cker ; a =" ▁) ▁; ▁BN _ print _ fp ▁( ▁stderr ▁, ▁a ▁) ▁; ▁fprintf ▁( ▁stderr ▁, ▁", a =" ▁) ▁; ▁BN _ print _ fp ▁( ▁stderr ▁, ▁b ▁) ▁; ▁fprintf ▁( ▁stderr ▁, ▁"\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁putc ▁( ▁' ▁' ▁, ▁stderr ▁) ▁; ▁fflush ▁( ▁stderr ▁) ▁; ▁} ▁putc ▁( ▁' ▁\ n ▁' ▁, ▁stderr ▁) ▁; ▁fflush ▁( ▁stderr ▁) ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁a ▁!= ▁NULL ▁) ▁BN _ free ▁( ▁a ▁) ▁; ▁if ▁( ▁b ▁!= ▁NULL ▁) ▁BN _ free ▁( ▁b ▁) ▁; ▁if ▁( ▁r ▁!= ▁NULL ▁) ▁BN _ free ▁( ▁r ▁) ▁; ▁if ▁( ▁t ▁!= ▁NULL ▁) ▁BN _ free ▁( ▁t ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁read _ packets ▁( ▁Writer Context ▁* ▁w ▁, ▁AVFormatContext ▁* ▁fmt _ ctx ▁) ▁{ ▁int ▁i ▁, ▁ret ▁= ▁0 ▁; ▁int 64_ t ▁cur _ ts ▁= ▁fmt _ ctx ▁-> ▁start _ time ▁; ▁if ▁( ▁read _ interval s _ nb ▁== ▁0 ▁) ▁{ ▁Read Interval ▁interval ▁= ▁( ▁Read Interval ▁) ▁{ ▁. ▁has _ start ▁= ▁0 ▁, ▁. ▁has _ end ▁= ▁0 ▁} ▁; ▁ret ▁= ▁read _ interval _ packets ▁( ▁w ▁, ▁fmt _ ctx ▁, ▁& ▁interval ▁, ▁& ▁cur _ ts ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁read _ interval s _ nb ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁= ▁read _ interval _ packets ▁( ▁w ▁, ▁fmt _ ctx ▁, ▁& ▁read _ interval s ▁[ ▁i ▁] ▁, ▁& ▁cur _ ts ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁break ▁; ▁} ▁} ▁}	1
▁static ▁int ▁test _ div _ rec ip ▁( ▁) ▁{ ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁, ▁* ▁c ▁, ▁* ▁d ▁, ▁* ▁e ▁; ▁BN _ RE CP _ CTX ▁* ▁recp ▁; ▁int ▁i ▁; ▁recp ▁= ▁BN _ RE CP _ CTX _ new ▁( ▁) ▁; ▁a ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁= ▁BN _ new ▁( ▁) ▁; ▁c ▁= ▁BN _ new ▁( ▁) ▁; ▁d ▁= ▁BN _ new ▁( ▁) ▁; ▁e ▁= ▁BN _ new ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NUM 0 ▁+ ▁NUM 1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁< ▁NUM 1 ▁) ▁{ ▁BN _ bn test _ rand ▁( ▁a ▁, ▁400 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁BN _ copy ▁( ▁b ▁, ▁a ▁) ▁; ▁BN _ lshift ▁( ▁a ▁, ▁a ▁, ▁i ▁) ▁; ▁BN _ add _ word ▁( ▁a ▁, ▁i ▁) ▁; ▁} ▁else ▁BN _ bn test _ rand ▁( ▁b ▁, ▁50 ▁+ ▁3 ▁* ▁( ▁i ▁- ▁NUM 1 ▁) ▁, ▁0 ▁, ▁0 ▁) ▁; ▁a ▁-> ▁neg ▁= ▁rand _ neg ▁( ▁) ▁; ▁b ▁-> ▁neg ▁= ▁rand _ neg ▁( ▁) ▁; ▁BN _ RE CP _ CTX _ set ▁( ▁recp ▁, ▁b ▁, ▁ctx ▁) ▁; ▁BN _ div _ re cp ▁( ▁d ▁, ▁c ▁, ▁a ▁, ▁recp ▁, ▁ctx ▁) ▁; ▁BN _ mul ▁( ▁e ▁, ▁d ▁, ▁b ▁, ▁ctx ▁) ▁; ▁BN _ add ▁( ▁d ▁, ▁e ▁, ▁c ▁) ▁; ▁BN _ sub ▁( ▁d ▁, ▁d ▁, ▁a ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ zero ▁( ▁d ▁) ▁) ▁{ ▁printf ▁( ▁" Rec ip rocal division test failed !\ n " ▁) ▁; ▁printf ▁( ▁" a =" ▁) ▁; ▁BN _ print _ fp ▁( ▁stdout ▁, ▁a ▁) ▁; ▁printf ▁( ▁"\ nb =" ▁) ▁; ▁BN _ print _ fp ▁( ▁stdout ▁, ▁b ▁) ▁; ▁printf ▁( ▁"\ n " ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁BN _ free ▁( ▁a ▁) ▁; ▁BN _ free ▁( ▁b ▁) ▁; ▁BN _ free ▁( ▁c ▁) ▁; ▁BN _ free ▁( ▁d ▁) ▁; ▁BN _ free ▁( ▁e ▁) ▁; ▁BN _ RE CP _ CTX _ free ▁( ▁recp ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁void ▁mm _ decode _ intra ▁( ▁M m Context ▁* ▁s ▁, ▁int ▁half _ h oriz ▁, ▁int ▁half _ vert ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁int ▁i ▁, ▁x ▁, ▁y ▁; ▁i ▁= ▁0 ▁; ▁x ▁= ▁0 ▁; ▁y ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁buf _ size ▁) ▁{ ▁int ▁run _ length ▁, ▁color ▁; ▁if ▁( ▁y ▁>= ▁s ▁-> ▁avctx ▁-> ▁height ▁) ▁return ▁; ▁if ▁( ▁buf ▁[ ▁i ▁] ▁& ▁0 x 80 ▁) ▁{ ▁run _ length ▁= ▁1 ▁; ▁color ▁= ▁buf ▁[ ▁i ▁] ▁; ▁i ▁++ ▁; ▁} ▁else ▁{ ▁run _ length ▁= ▁( ▁buf ▁[ ▁i ▁] ▁& ▁0 x 7 f ▁) ▁+ ▁2 ▁; ▁color ▁= ▁buf ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁i ▁+= ▁2 ▁; ▁} ▁if ▁( ▁half _ h oriz ▁) ▁run _ length ▁*= ▁2 ▁; ▁if ▁( ▁color ▁) ▁{ ▁memset ▁( ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁0 ▁] ▁+ ▁y ▁* ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁+ ▁x ▁, ▁color ▁, ▁run _ length ▁) ▁; ▁if ▁( ▁half _ vert ▁) ▁memset ▁( ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁0 ▁] ▁+ ▁( ▁y ▁+ ▁1 ▁) ▁* ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁+ ▁x ▁, ▁color ▁, ▁run _ length ▁) ▁; ▁} ▁x ▁+= ▁run _ length ▁; ▁if ▁( ▁x ▁>= ▁s ▁-> ▁avctx ▁-> ▁width ▁) ▁{ ▁x ▁= ▁0 ▁; ▁y ▁+= ▁1 ▁+ ▁half _ vert ▁; ▁} ▁} ▁}	0
▁tm size _ t ▁TIFF Read Encoded Tile ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁tile ▁, ▁void ▁* ▁buf ▁, ▁tm size _ t ▁size ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Read Encoded Tile " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁tm size _ t ▁tile size ▁= ▁tif ▁-> ▁tif _ tile size ▁; ▁if ▁( ▁! ▁TIFF Check Read ▁( ▁tif ▁, ▁1 ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁if ▁( ▁tile ▁>= ▁td ▁-> ▁td _ n stri ps ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁"% lu : Tile out of range , max % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁tile ▁, ▁( ▁unsigned ▁long ▁) ▁td ▁-> ▁td _ n stri ps ▁) ▁; ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁} ▁if ▁( ▁td ▁-> ▁td _ compression ▁== ▁COMPRESS ION _ NONE ▁&& ▁size ▁!= ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁&& ▁size ▁>= ▁tile size ▁&& ▁! ▁is Mapped ▁( ▁tif ▁) ▁&& ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NOR EAD RAW ▁) ▁== ▁0 ▁) ▁) ▁{ ▁if ▁( ▁TIFF Read Raw Tile 1 ▁( ▁tif ▁, ▁tile ▁, ▁buf ▁, ▁tile size ▁, ▁module ▁) ▁!= ▁tile size ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁if ▁( ▁! ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁&& ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁== ▁0 ▁) ▁TIFF Reverse Bits ▁( ▁buf ▁, ▁tile size ▁) ▁; ▁( ▁* ▁tif ▁-> ▁tif _ post decode ▁) ▁( ▁tif ▁, ▁buf ▁, ▁tile size ▁) ▁; ▁return ▁( ▁tile size ▁) ▁; ▁} ▁if ▁( ▁size ▁== ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁size ▁= ▁tile size ▁; ▁else ▁if ▁( ▁size ▁> ▁tile size ▁) ▁size ▁= ▁tile size ▁; ▁if ▁( ▁TIFF Fill Tile ▁( ▁tif ▁, ▁tile ▁) ▁&& ▁( ▁* ▁tif ▁-> ▁tif _ decode tile ▁) ▁( ▁tif ▁, ▁( ▁uint 8 ▁* ▁) ▁buf ▁, ▁size ▁, ▁( ▁uint 16 ▁) ▁( ▁tile ▁/ ▁td ▁-> ▁td _ stri ps per image ▁) ▁) ▁) ▁{ ▁( ▁* ▁tif ▁-> ▁tif _ post decode ▁) ▁( ▁tif ▁, ▁( ▁uint 8 ▁* ▁) ▁buf ▁, ▁size ▁) ▁; ▁return ▁( ▁size ▁) ▁; ▁} ▁else ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁}	0
▁int ▁TIFF Fill Strip ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁strip ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Fill Strip " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁if ▁( ▁! ▁_ TIFF Fill Stri les ▁( ▁tif ▁) ▁|| ▁! ▁tif ▁-> ▁tif _ dir ▁. ▁td _ strip byte count ▁) ▁return ▁0 ▁; ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NOR EAD RAW ▁) ▁== ▁0 ▁) ▁{ ▁uint 64 ▁byte count ▁= ▁td ▁-> ▁td _ strip byte count ▁[ ▁strip ▁] ▁; ▁if ▁( ▁( ▁int 64 ▁) ▁byte count ▁<= ▁0 ▁) ▁{ ▁# if ▁defined ▁( ▁__ WIN 32__ ▁) ▁&& ▁( ▁defined ▁( ▁_ MSC _ VER ▁) ▁|| ▁defined ▁( ▁__ MINGW 32__ ▁) ▁) ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Invalid strip byte count % I 64 u , strip % lu " ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁) ▁; ▁# else ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Invalid strip byte count % llu , strip % lu " ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁) ▁; ▁# endif ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁byte count ▁> ▁1024 ▁* ▁1024 ▁) ▁{ ▁tm size _ t ▁strip size ▁= ▁TIFF Strip Size ▁( ▁tif ▁) ▁; ▁if ▁( ▁strip size ▁!= ▁0 ▁&& ▁( ▁byte count ▁- ▁4096 ▁) ▁/ ▁10 ▁> ▁( ▁uint 64 ▁) ▁strip size ▁) ▁{ ▁uint 64 ▁new byte count ▁= ▁( ▁uint 64 ▁) ▁strip size ▁* ▁10 ▁+ ▁4096 ▁; ▁if ▁( ▁( ▁int 64 ▁) ▁new byte count ▁>= ▁0 ▁) ▁{ ▁# if ▁defined ▁( ▁__ WIN 32__ ▁) ▁&& ▁( ▁defined ▁( ▁_ MSC _ VER ▁) ▁|| ▁defined ▁( ▁__ MINGW 32__ ▁) ▁) ▁TIFF Warning Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Tool argest rip byte count % I 64 u , strip % lu . Limit ing to % I 64 u " ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁new byte count ▁) ▁; ▁# else ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Tool argest rip byte count % llu , strip % lu . Limit ing to % llu " ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁new byte count ▁) ▁; ▁# endif ▁byte count ▁= ▁new byte count ▁; ▁} ▁} ▁} ▁if ▁( ▁is Mapped ▁( ▁tif ▁) ▁) ▁{ ▁if ▁( ▁byte count ▁> ▁( ▁uint 64 ▁) ▁tif ▁-> ▁tif _ size ▁|| ▁td ▁-> ▁td _ strip offset ▁[ ▁strip ▁] ▁> ▁( ▁uint 64 ▁) ▁tif ▁-> ▁tif _ size ▁- ▁byte count ▁) ▁{ ▁# if ▁defined ▁( ▁__ WIN 32__ ▁) ▁&& ▁( ▁defined ▁( ▁_ MSC _ VER ▁) ▁|| ▁defined ▁( ▁__ MINGW 32__ ▁) ▁) ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Read error on strip % lu ;" ▁" got % I 64 uby tes , expected % I 64 u " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁tif ▁-> ▁tif _ size ▁- ▁td ▁-> ▁td _ strip offset ▁[ ▁strip ▁] ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁byte count ▁) ▁; ▁# else ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Read error on strip % lu ;" ▁" got % ll uby tes , expected % llu " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁tif ▁-> ▁tif _ size ▁- ▁td ▁-> ▁td _ strip offset ▁[ ▁strip ▁] ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁byte count ▁) ▁; ▁# endif ▁tif ▁-> ▁tif _ cur strip ▁= ▁NO STRIP ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁if ▁( ▁is Mapped ▁( ▁tif ▁) ▁&& ▁( ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁|| ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁) ▁) ▁{ ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ MY BUFFER ▁) ▁&& ▁tif ▁-> ▁tif _ raw data ▁) ▁{ ▁_ TIFF free ▁( ▁tif ▁-> ▁tif _ raw data ▁) ▁; ▁tif ▁-> ▁tif _ raw data ▁= ▁NULL ▁; ▁tif ▁-> ▁tif _ raw datas ize ▁= ▁0 ▁; ▁} ▁tif ▁-> ▁tif _ flags ▁&= ▁ ~ ▁TIFF _ MY BUFFER ▁; ▁tif ▁-> ▁tif _ raw datas ize ▁= ▁( ▁tm size _ t ▁) ▁byte count ▁; ▁tif ▁-> ▁tif _ raw data ▁= ▁tif ▁-> ▁tif _ base ▁+ ▁( ▁tm size _ t ▁) ▁td ▁-> ▁td _ strip offset ▁[ ▁strip ▁] ▁; ▁tif ▁-> ▁tif _ raw data off ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ raw datal o aded ▁= ▁( ▁tm size _ t ▁) ▁byte count ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ BUFFER MMAP ▁; ▁} ▁else ▁{ ▁tm size _ t ▁byte count m ▁; ▁byte count m ▁= ▁( ▁tm size _ t ▁) ▁byte count ▁; ▁if ▁( ▁( ▁uint 64 ▁) ▁byte count m ▁!= ▁byte count ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Integer overflow " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁byte count m ▁> ▁tif ▁-> ▁tif _ raw datas ize ▁) ▁{ ▁tif ▁-> ▁tif _ cur strip ▁= ▁NO STRIP ▁; ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ MY BUFFER ▁) ▁== ▁0 ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Dat ab uff ert oo small to hold strip % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁if ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ BUFFER MMAP ▁) ▁{ ▁tif ▁-> ▁tif _ cur strip ▁= ▁NO STRIP ▁; ▁tif ▁-> ▁tif _ raw data ▁= ▁NULL ▁; ▁tif ▁-> ▁tif _ raw datas ize ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ flags ▁&= ▁ ~ ▁TIFF _ BUFFER MMAP ▁; ▁} ▁if ▁( ▁is Mapped ▁( ▁tif ▁) ▁) ▁{ ▁if ▁( ▁byte count m ▁> ▁tif ▁-> ▁tif _ raw datas ize ▁&& ▁! ▁TIFF Read Buffer Setup ▁( ▁tif ▁, ▁0 ▁, ▁byte count m ▁) ▁) ▁{ ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁TIFF Read Raw Strip 1 ▁( ▁tif ▁, ▁strip ▁, ▁tif ▁-> ▁tif _ raw data ▁, ▁byte count m ▁, ▁module ▁) ▁!= ▁byte count m ▁) ▁{ ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁TIFF Read Raw Strip Or Tile 2 ▁( ▁tif ▁, ▁strip ▁, ▁1 ▁, ▁byte count m ▁, ▁module ▁) ▁!= ▁byte count m ▁) ▁{ ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁tif ▁-> ▁tif _ raw data off ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ raw datal o aded ▁= ▁byte count m ▁; ▁if ▁( ▁! ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁&& ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁== ▁0 ▁) ▁TIFF Reverse Bits ▁( ▁tif ▁-> ▁tif _ raw data ▁, ▁byte count m ▁) ▁; ▁} ▁} ▁return ▁( ▁TIFF Start Strip ▁( ▁tif ▁, ▁strip ▁) ▁) ▁; ▁}	1
▁static ▁int ▁decode _ n al _ se i _ pic _ timing ▁( ▁H EV C SE I Context ▁* ▁s ▁, ▁Get Bit Context ▁* ▁gb ▁, ▁const ▁H EV C Param Sets ▁* ▁ps ▁, ▁void ▁* ▁log ctx ▁, ▁int ▁size ▁) ▁{ ▁H EV C SE IP icture Timing ▁* ▁h ▁= ▁& ▁s ▁-> ▁picture _ timing ▁; ▁H EV C SP S ▁* ▁sps ▁; ▁if ▁( ▁! ▁ps ▁-> ▁sps _ list ▁[ ▁s ▁-> ▁active _ seq _ parameter _ set _ id ▁] ▁) ▁return ▁( ▁AVERROR ▁( ▁ENOMEM ▁) ▁) ▁; ▁sps ▁= ▁( ▁H EV C SP S ▁* ▁) ▁ps ▁-> ▁sps _ list ▁[ ▁s ▁-> ▁active _ seq _ parameter _ set _ id ▁] ▁-> ▁data ▁; ▁if ▁( ▁sps ▁-> ▁v ui ▁. ▁frame _ field _ info _ present _ flag ▁) ▁{ ▁int ▁pic _ struct ▁= ▁get _ bits ▁( ▁gb ▁, ▁4 ▁) ▁; ▁h ▁-> ▁picture _ struct ▁= ▁AV _ PICTURE _ STRUCTURE _ UNKNOWN ▁; ▁if ▁( ▁pic _ struct ▁== ▁2 ▁) ▁{ ▁av _ log ▁( ▁log ctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" BOTTOM Field \ n " ▁) ▁; ▁h ▁-> ▁picture _ struct ▁= ▁AV _ PICTURE _ STRUCTURE _ BOTTOM _ FIELD ▁; ▁} ▁else ▁if ▁( ▁pic _ struct ▁== ▁1 ▁) ▁{ ▁av _ log ▁( ▁log ctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" TOP Field \ n " ▁) ▁; ▁h ▁-> ▁picture _ struct ▁= ▁AV _ PICTURE _ STRUCTURE _ TOP _ FIELD ▁; ▁} ▁get _ bits ▁( ▁gb ▁, ▁2 ▁) ▁; ▁get _ bits ▁( ▁gb ▁, ▁1 ▁) ▁; ▁skip _ bits 1 ▁( ▁gb ▁) ▁; ▁size ▁-- ▁; ▁} ▁skip _ bits _ long ▁( ▁gb ▁, ▁8 ▁* ▁size ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁vp 3_ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁V p 3 Decode Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁Get Bit Context ▁gb ▁; ▁static ▁int ▁counter ▁= ▁0 ▁; ▁int ▁i ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁if ▁( ▁s ▁-> ▁the ora ▁&& ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Header packet passed tof rame decoder , sk ipping \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁keyframe ▁= ▁! ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁the ora ▁) ▁skip _ bits ▁( ▁& ▁gb ▁, ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁s ▁-> ▁last _ q ps ▁[ ▁i ▁] ▁= ▁s ▁-> ▁q ps ▁[ ▁i ▁] ▁; ▁s ▁-> ▁nq ps ▁= ▁0 ▁; ▁do ▁{ ▁s ▁-> ▁q ps ▁[ ▁s ▁-> ▁nq ps ▁++ ▁] ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁6 ▁) ▁; ▁} ▁while ▁( ▁s ▁-> ▁the ora ▁>= ▁0 x 03 0200 ▁&& ▁s ▁-> ▁nq ps ▁< ▁3 ▁&& ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁s ▁-> ▁nq ps ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁s ▁-> ▁q ps ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ P ICT _ INFO ▁) ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ INFO ▁, ▁" VP 3 % s frame #% d : Q index =% d \ n " ▁, ▁s ▁-> ▁keyframe ▁? ▁" key " ▁: ▁"" ▁, ▁counter ▁, ▁s ▁-> ▁q ps ▁[ ▁0 ▁] ▁) ▁; ▁counter ▁++ ▁; ▁if ▁( ▁s ▁-> ▁q ps ▁[ ▁0 ▁] ▁!= ▁s ▁-> ▁last _ q ps ▁[ ▁0 ▁] ▁) ▁init _ loop _ filter ▁( ▁s ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nq ps ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁-> ▁q ps ▁[ ▁i ▁] ▁!= ▁s ▁-> ▁last _ q ps ▁[ ▁i ▁] ▁|| ▁s ▁-> ▁q ps ▁[ ▁0 ▁] ▁!= ▁s ▁-> ▁last _ q ps ▁[ ▁0 ▁] ▁) ▁init _ de quant izer ▁( ▁s ▁, ▁i ▁) ▁; ▁if ▁( ▁avctx ▁-> ▁skip _ frame ▁>= ▁AV DISCARD _ NON KEY ▁&& ▁! ▁s ▁-> ▁keyframe ▁) ▁return ▁buf _ size ▁; ▁if ▁( ▁s ▁-> ▁keyframe ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁the ora ▁) ▁{ ▁skip _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁skip _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁if ▁( ▁s ▁-> ▁version ▁) ▁{ ▁s ▁-> ▁version ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁5 ▁) ▁; ▁if ▁( ▁counter ▁== ▁1 ▁) ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" VP version :% d \ n " ▁, ▁s ▁-> ▁version ▁) ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁version ▁|| ▁s ▁-> ▁the ora ▁) ▁{ ▁if ▁( ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁) ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Warning , unsupported key frame coding type ? !\ n " ▁) ▁; ▁skip _ bits ▁( ▁& ▁gb ▁, ▁2 ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁== ▁s ▁-> ▁golden _ frame ▁. ▁data ▁[ ▁0 ▁] ▁) ▁{ ▁if ▁( ▁s ▁-> ▁golden _ frame ▁. ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁golden _ frame ▁) ▁; ▁s ▁-> ▁last _ frame ▁= ▁s ▁-> ▁golden _ frame ▁; ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁golden _ frame ▁. ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁golden _ frame ▁) ▁; ▁if ▁( ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁last _ frame ▁) ▁; ▁} ▁s ▁-> ▁golden _ frame ▁. ▁reference ▁= ▁3 ▁; ▁if ▁( ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁golden _ frame ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" vp 3: get _ buffer () failed \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁current _ frame ▁= ▁s ▁-> ▁golden _ frame ▁; ▁if ▁( ▁! ▁s ▁-> ▁pixel _ addresses _ initialized ▁) ▁{ ▁vp 3_ calculate _ pixel _ addresses ▁( ▁s ▁) ▁; ▁s ▁-> ▁pixel _ addresses _ initialized ▁= ▁1 ▁; ▁} ▁} ▁else ▁{ ▁s ▁-> ▁current _ frame ▁. ▁reference ▁= ▁3 ▁; ▁if ▁( ▁! ▁s ▁-> ▁pixel _ addresses _ initialized ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" vp 3: first f ram en ot ak ey frame \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁current _ frame ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" vp 3: get _ buffer () failed \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁} ▁s ▁-> ▁current _ frame ▁. ▁q scale _ table ▁= ▁s ▁-> ▁q scale _ table ▁; ▁s ▁-> ▁current _ frame ▁. ▁q stride ▁= ▁0 ▁; ▁init _ frame ▁( ▁s ▁, ▁& ▁gb ▁) ▁; ▁if ▁( ▁unpack _ super blocks ▁( ▁s ▁, ▁& ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" error in unpack _ super blocks \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁unpack _ modes ▁( ▁s ▁, ▁& ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" error in unpack _ modes \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁unpack _ vectors ▁( ▁s ▁, ▁& ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" error in unpack _ vectors \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁unpack _ block _ qp is ▁( ▁s ▁, ▁& ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" error in unpack _ block _ qp is \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁unpack _ dct _ coeffs ▁( ▁s ▁, ▁& ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" error in unpack _ dct _ coeffs \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁macro block _ height ▁; ▁i ▁++ ▁) ▁render _ slice ▁( ▁s ▁, ▁i ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁row ▁= ▁( ▁s ▁-> ▁height ▁>> ▁( ▁3 ▁+ ▁! ▁! ▁i ▁) ▁) ▁- ▁1 ▁; ▁apply _ loop _ filter ▁( ▁s ▁, ▁i ▁, ▁row ▁, ▁row ▁+ ▁1 ▁) ▁; ▁} ▁* ▁data _ size ▁= ▁sizeof ▁( ▁AVFrame ▁) ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁s ▁-> ▁current _ frame ▁; ▁if ▁( ▁( ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁) ▁&& ▁( ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁!= ▁s ▁-> ▁golden _ frame ▁. ▁data ▁[ ▁0 ▁] ▁) ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁last _ frame ▁) ▁; ▁s ▁-> ▁last _ frame ▁= ▁s ▁-> ▁current _ frame ▁; ▁s ▁-> ▁current _ frame ▁. ▁data ▁[ ▁0 ▁] ▁= ▁NULL ▁; ▁return ▁buf _ size ▁; ▁}	0
▁static ▁int ▁asn 1_ get _ int 64 ▁( ▁int 64_ t ▁* ▁pr ▁, ▁const ▁unsigned ▁char ▁* ▁b ▁, ▁size _ t ▁blen ▁, ▁int ▁neg ▁) ▁{ ▁uint 64_ t ▁r ▁; ▁if ▁( ▁asn 1_ get _ uint 64 ▁( ▁& ▁r ▁, ▁b ▁, ▁blen ▁) ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁neg ▁) ▁{ ▁if ▁( ▁r ▁<= ▁INT 64_ MAX ▁) ▁{ ▁* ▁pr ▁= ▁- ▁( ▁int 64_ t ▁) ▁r ▁; ▁} ▁else ▁if ▁( ▁r ▁== ▁ABS _ INT 64_ MIN ▁) ▁{ ▁* ▁pr ▁= ▁( ▁int 64_ t ▁) ▁( ▁0 ▁- ▁r ▁) ▁; ▁} ▁else ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ GET _ INT 64 ▁, ▁ASN 1_ R _ TOO _ SMALL ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁r ▁<= ▁INT 64_ MAX ▁) ▁{ ▁* ▁pr ▁= ▁( ▁int 64_ t ▁) ▁r ▁; ▁} ▁else ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ GET _ INT 64 ▁, ▁ASN 1_ R _ TOO _ LARGE ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁bm v _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁BM V Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁type ▁, ▁err ▁; ▁while ▁( ▁c ▁-> ▁get _ next ▁) ▁{ ▁if ▁( ▁s ▁-> ▁pb ▁-> ▁eof _ reached ▁) ▁return ▁AVERROR _ EOF ▁; ▁type ▁= ▁avio _ r 8 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁if ▁( ▁type ▁== ▁BM V _ NOP ▁) ▁continue ▁; ▁if ▁( ▁type ▁== ▁BM V _ END ▁) ▁return ▁AVERROR _ EOF ▁; ▁c ▁-> ▁size ▁= ▁avio _ rl 24 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁size ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁( ▁err ▁= ▁av _ realloc p ▁( ▁& ▁c ▁-> ▁packet ▁, ▁c ▁-> ▁size ▁+ ▁1 ▁) ▁) ▁< ▁0 ▁) ▁return ▁err ▁; ▁c ▁-> ▁packet ▁[ ▁0 ▁] ▁= ▁type ▁; ▁if ▁( ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁c ▁-> ▁packet ▁+ ▁1 ▁, ▁c ▁-> ▁size ▁) ▁!= ▁c ▁-> ▁size ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁if ▁( ▁type ▁& ▁BM V _ AUDIO ▁) ▁{ ▁int ▁audio _ size ▁= ▁c ▁-> ▁packet ▁[ ▁1 ▁] ▁* ▁65 ▁+ ▁1 ▁; ▁if ▁( ▁audio _ size ▁>= ▁c ▁-> ▁size ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Report ed aud ios ize % dis big ger than packet size (% d )\ n " ▁, ▁audio _ size ▁, ▁c ▁-> ▁size ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁audio _ size ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁c ▁-> ▁packet ▁+ ▁1 ▁, ▁pkt ▁-> ▁size ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁1 ▁; ▁pkt ▁-> ▁pts ▁= ▁c ▁-> ▁audio _ pos ▁; ▁pkt ▁-> ▁duration ▁= ▁c ▁-> ▁packet ▁[ ▁1 ▁] ▁* ▁32 ▁; ▁c ▁-> ▁audio _ pos ▁+= ▁pkt ▁-> ▁duration ▁; ▁c ▁-> ▁get _ next ▁= ▁0 ▁; ▁return ▁pkt ▁-> ▁size ▁; ▁} ▁else ▁break ▁; ▁} ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁c ▁-> ▁size ▁+ ▁1 ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁c ▁-> ▁get _ next ▁= ▁1 ▁; ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁c ▁-> ▁packet ▁, ▁pkt ▁-> ▁size ▁) ▁; ▁return ▁pkt ▁-> ▁size ▁; ▁}	1
▁int ▁av _ image _ fill _ lines izes ▁( ▁int ▁lines izes ▁[ ▁4 ▁] ▁, ▁enum ▁PixelFormat ▁pix _ fmt ▁, ▁int ▁width ▁) ▁{ ▁int ▁i ▁, ▁ret ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁& ▁av _ pix _ fmt _ descriptors ▁[ ▁pix _ fmt ▁] ▁; ▁int ▁max _ step ▁[ ▁4 ▁] ▁; ▁int ▁max _ step _ comp ▁[ ▁4 ▁] ▁; ▁memset ▁( ▁lines izes ▁, ▁0 ▁, ▁4 ▁* ▁sizeof ▁( ▁lines izes ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁pix _ fmt ▁>= ▁PIX _ FMT _ NB ▁|| ▁desc ▁-> ▁flags ▁& ▁PIX _ FMT _ HW ACCEL ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁av _ image _ fill _ max _ pix steps ▁( ▁max _ step ▁, ▁max _ step _ comp ▁, ▁desc ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁image _ get _ lines ize ▁( ▁width ▁, ▁i ▁, ▁max _ step ▁[ ▁i ▁] ▁, ▁max _ step _ comp ▁[ ▁i ▁] ▁, ▁desc ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁lines izes ▁[ ▁i ▁] ▁= ▁ret ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁X 509_ cmp ▁( ▁const ▁X 509 ▁* ▁a ▁, ▁const ▁X 509 ▁* ▁b ▁) ▁{ ▁int ▁rv ▁; ▁X 509_ check _ p urpose ▁( ▁( ▁X 509 ▁* ▁) ▁a ▁, ▁-1 ▁, ▁0 ▁) ▁; ▁X 509_ check _ p urpose ▁( ▁( ▁X 509 ▁* ▁) ▁b ▁, ▁-1 ▁, ▁0 ▁) ▁; ▁rv ▁= ▁memcmp ▁( ▁a ▁-> ▁sha 1_ hash ▁, ▁b ▁-> ▁sha 1_ hash ▁, ▁SHA _ DIGEST _ LENGTH ▁) ▁; ▁if ▁( ▁rv ▁) ▁return ▁rv ▁; ▁if ▁( ▁! ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁modified ▁&& ▁! ▁b ▁-> ▁cert _ info ▁. ▁enc ▁. ▁modified ▁) ▁{ ▁rv ▁= ▁( ▁int ▁) ▁( ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁- ▁b ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁) ▁; ▁if ▁( ▁rv ▁) ▁return ▁rv ▁; ▁return ▁memcmp ▁( ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁enc ▁, ▁b ▁-> ▁cert _ info ▁. ▁enc ▁. ▁enc ▁, ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁) ▁; ▁} ▁return ▁rv ▁; ▁}	1
▁static ▁int ▁mk v _ write _ trail er ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁Mat ro sk a Mux Context ▁* ▁mk v ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int 64_ t ▁current pos ▁, ▁c ues pos ▁; ▁int ▁ret ▁; ▁if ▁( ▁mk v ▁-> ▁cur _ audio _ pkt ▁. ▁size ▁> ▁0 ▁) ▁{ ▁ret ▁= ▁mk v _ write _ packet _ internal ▁( ▁s ▁, ▁& ▁mk v ▁-> ▁cur _ audio _ pkt ▁, ▁0 ▁) ▁; ▁av _ free _ packet ▁( ▁& ▁mk v ▁-> ▁cur _ audio _ pkt ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Could not writ ec ached aud iop acket ret :% d \ n " ▁, ▁ret ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁if ▁( ▁mk v ▁-> ▁dyn _ bc ▁) ▁{ ▁end _ eb ml _ master ▁( ▁mk v ▁-> ▁dyn _ bc ▁, ▁mk v ▁-> ▁cluster ▁) ▁; ▁mk v _ flush _ dyn buf ▁( ▁s ▁) ▁; ▁} ▁else ▁if ▁( ▁mk v ▁-> ▁cluster _ pos ▁!= ▁-1 ▁) ▁{ ▁end _ eb ml _ master ▁( ▁pb ▁, ▁mk v ▁-> ▁cluster ▁) ▁; ▁} ▁if ▁( ▁mk v ▁-> ▁mode ▁!= ▁MODE _ WEB M ▁) ▁{ ▁ret ▁= ▁mk v _ write _ ch apt ers ▁( ▁s ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁pb ▁-> ▁seek able ▁) ▁{ ▁if ▁( ▁mk v ▁-> ▁c ues ▁-> ▁num _ entries ▁) ▁{ ▁if ▁( ▁mk v ▁-> ▁reserve _ c ues _ space ▁) ▁{ ▁int 64_ t ▁c ues _ end ▁; ▁current pos ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁mk v ▁-> ▁c ues _ pos ▁, ▁SEEK _ SET ▁) ▁; ▁c ues pos ▁= ▁mk v _ write _ c ues ▁( ▁s ▁, ▁mk v ▁-> ▁c ues ▁, ▁mk v ▁-> ▁tracks ▁, ▁s ▁-> ▁nb _ streams ▁) ▁; ▁c ues _ end ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁if ▁( ▁c ues _ end ▁> ▁c ues pos ▁+ ▁mk v ▁-> ▁reserve _ c ues _ space ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Ins ufficient sp acer es erved for c ues :% d " ▁"( needed :% " ▁PRId 64 ▁" ).\ n " ▁, ▁mk v ▁-> ▁reserve _ c ues _ space ▁, ▁c ues _ end ▁- ▁c ues pos ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁c ues _ end ▁< ▁c ues pos ▁+ ▁mk v ▁-> ▁reserve _ c ues _ space ▁) ▁put _ eb ml _ void ▁( ▁pb ▁, ▁mk v ▁-> ▁reserve _ c ues _ space ▁- ▁( ▁c ues _ end ▁- ▁c ues pos ▁) ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁current pos ▁, ▁SEEK _ SET ▁) ▁; ▁} ▁else ▁{ ▁c ues pos ▁= ▁mk v _ write _ c ues ▁( ▁s ▁, ▁mk v ▁-> ▁c ues ▁, ▁mk v ▁-> ▁tracks ▁, ▁s ▁-> ▁nb _ streams ▁) ▁; ▁} ▁ret ▁= ▁mk v _ add _ seek head _ entry ▁( ▁mk v ▁-> ▁main _ seek head ▁, ▁MAT RO SK A _ ID _ C UES ▁, ▁c ues pos ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁mk v _ write _ seek head ▁( ▁pb ▁, ▁mk v ▁) ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" end duration =% " ▁PRIu 64 ▁"\ n " ▁, ▁mk v ▁-> ▁duration ▁) ▁; ▁current pos ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁mk v ▁-> ▁duration _ offset ▁, ▁SEEK _ SET ▁) ▁; ▁put _ eb ml _ float ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ DURATION ▁, ▁mk v ▁-> ▁duration ▁) ▁; ▁if ▁( ▁mk v ▁-> ▁stream _ d urations ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁++ ▁i ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁double ▁duration _ sec ▁= ▁mk v ▁-> ▁stream _ d urations ▁[ ▁i ▁] ▁* ▁av _ q 2 d ▁( ▁st ▁-> ▁time _ base ▁) ▁; ▁char ▁duration _ string ▁[ ▁20 ▁] ▁= ▁"" ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" stream % d end duration =% " ▁PRIu 64 ▁"\ n " ▁, ▁i ▁, ▁mk v ▁-> ▁stream _ d urations ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁! ▁mk v ▁-> ▁is _ live ▁&& ▁mk v ▁-> ▁stream _ duration _ offsets ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁avio _ seek ▁( ▁pb ▁, ▁mk v ▁-> ▁stream _ duration _ offsets ▁[ ▁i ▁] ▁, ▁SEEK _ SET ▁) ▁; ▁snprintf ▁( ▁duration _ string ▁, ▁20 ▁, ▁"%02 d :%02 d :% 01 2. 9 f " ▁, ▁( ▁int ▁) ▁duration _ sec ▁/ ▁3600 ▁, ▁( ▁( ▁int ▁) ▁duration _ sec ▁/ ▁60 ▁) ▁% ▁60 ▁, ▁fmod ▁( ▁duration _ sec ▁, ▁60 ▁) ▁) ▁; ▁put _ eb ml _ binary ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ TAG STRING ▁, ▁duration _ string ▁, ▁20 ▁) ▁; ▁} ▁} ▁} ▁avio _ seek ▁( ▁pb ▁, ▁current pos ▁, ▁SEEK _ SET ▁) ▁; ▁} ▁if ▁( ▁! ▁mk v ▁-> ▁is _ live ▁) ▁{ ▁end _ eb ml _ master ▁( ▁pb ▁, ▁mk v ▁-> ▁segment ▁) ▁; ▁} ▁mk v _ free ▁( ▁mk v ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁STACK _ OF ▁( ▁X 509 ▁) ▁* ▁load _ un trusted ▁( ▁char ▁* ▁cert file ▁) ▁{ ▁STACK _ OF ▁( ▁X 509_ INFO ▁) ▁* ▁sk ▁= ▁NULL ▁; ▁STACK _ OF ▁( ▁X 509 ▁) ▁* ▁stack ▁= ▁NULL ▁, ▁* ▁ret ▁= ▁NULL ▁; ▁BIO ▁* ▁in ▁= ▁NULL ▁; ▁X 509_ INFO ▁* ▁xi ▁; ▁if ▁( ▁! ▁( ▁stack ▁= ▁sk _ X 509_ new _ null ▁( ▁) ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" memory allocation failure \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁( ▁in ▁= ▁BIO _ new _ file ▁( ▁cert file ▁, ▁" r " ▁) ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" error open ing the file ,% s \ n " ▁, ▁cert file ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁( ▁sk ▁= ▁PEM _ X 509_ INFO _ read _ bio ▁( ▁in ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" error reading the file ,% s \ n " ▁, ▁cert file ▁) ▁; ▁goto ▁end ▁; ▁} ▁while ▁( ▁sk _ X 509_ INFO _ num ▁( ▁sk ▁) ▁) ▁{ ▁xi ▁= ▁sk _ X 509_ INFO _ shift ▁( ▁sk ▁) ▁; ▁if ▁( ▁xi ▁-> ▁x 509 ▁!= ▁NULL ▁) ▁{ ▁sk _ X 509_ push ▁( ▁stack ▁, ▁xi ▁-> ▁x 509 ▁) ▁; ▁xi ▁-> ▁x 509 ▁= ▁NULL ▁; ▁} ▁X 509_ INFO _ free ▁( ▁xi ▁) ▁; ▁} ▁if ▁( ▁! ▁sk _ X 509_ num ▁( ▁stack ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" noc ertificates in file ,% s \ n " ▁, ▁cert file ▁) ▁; ▁sk _ X 509_ free ▁( ▁stack ▁) ▁; ▁goto ▁end ▁; ▁} ▁ret ▁= ▁stack ▁; ▁end ▁: ▁BIO _ free ▁( ▁in ▁) ▁; ▁sk _ X 509_ INFO _ free ▁( ▁sk ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁void ▁ff _ configure _ buffers _ for _ index ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int 64_ t ▁time _ tol erance ▁) ▁{ ▁int ▁ist 1 ▁, ▁ist 2 ▁; ▁int 64_ t ▁pos _ delta ▁= ▁0 ▁; ▁const ▁char ▁* ▁proto ▁= ▁avio _ find _ protocol _ name ▁( ▁s ▁-> ▁filename ▁) ▁; ▁if ▁( ▁! ▁( ▁strcmp ▁( ▁proto ▁, ▁" file " ▁) ▁&& ▁strcmp ▁( ▁proto ▁, ▁" pipe " ▁) ▁&& ▁strcmp ▁( ▁proto ▁, ▁" cache " ▁) ▁) ▁) ▁return ▁; ▁for ▁( ▁ist 1 ▁= ▁0 ▁; ▁ist 1 ▁< ▁s ▁-> ▁nb _ streams ▁; ▁ist 1 ▁++ ▁) ▁{ ▁AVStream ▁* ▁st 1 ▁= ▁s ▁-> ▁streams ▁[ ▁ist 1 ▁] ▁; ▁for ▁( ▁ist 2 ▁= ▁0 ▁; ▁ist 2 ▁< ▁s ▁-> ▁nb _ streams ▁; ▁ist 2 ▁++ ▁) ▁{ ▁AVStream ▁* ▁st 2 ▁= ▁s ▁-> ▁streams ▁[ ▁ist 2 ▁] ▁; ▁int ▁i 1 ▁, ▁i 2 ▁; ▁if ▁( ▁ist 1 ▁== ▁ist 2 ▁) ▁continue ▁; ▁for ▁( ▁i 1 ▁= ▁i 2 ▁= ▁0 ▁; ▁i 1 ▁< ▁st 1 ▁-> ▁nb _ index _ entries ▁; ▁i 1 ▁++ ▁) ▁{ ▁AV Index Entry ▁* ▁e 1 ▁= ▁& ▁st 1 ▁-> ▁index _ entries ▁[ ▁i 1 ▁] ▁; ▁int 64_ t ▁e 1_ pts ▁= ▁av _ re scale _ q ▁( ▁e 1 ▁-> ▁timestamp ▁, ▁st 1 ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁for ▁( ▁; ▁i 2 ▁< ▁st 2 ▁-> ▁nb _ index _ entries ▁; ▁i 2 ▁++ ▁) ▁{ ▁AV Index Entry ▁* ▁e 2 ▁= ▁& ▁st 2 ▁-> ▁index _ entries ▁[ ▁i 2 ▁] ▁; ▁int 64_ t ▁e 2_ pts ▁= ▁av _ re scale _ q ▁( ▁e 2 ▁-> ▁timestamp ▁, ▁st 2 ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁if ▁( ▁e 2_ pts ▁- ▁e 1_ pts ▁< ▁time _ tol erance ▁) ▁continue ▁; ▁pos _ delta ▁= ▁FF MAX ▁( ▁pos _ delta ▁, ▁e 1 ▁-> ▁pos ▁- ▁e 2 ▁-> ▁pos ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁pos _ delta ▁*= ▁2 ▁; ▁if ▁( ▁s ▁-> ▁pb ▁-> ▁buffer _ size ▁< ▁pos _ delta ▁&& ▁pos _ delta ▁< ▁( ▁1 ▁<< ▁24 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" Re config uring buffer st os ize %" ▁PRId 64 ▁"\ n " ▁, ▁pos _ delta ▁) ▁; ▁ff io _ set _ buf _ size ▁( ▁s ▁-> ▁pb ▁, ▁pos _ delta ▁) ▁; ▁s ▁-> ▁pb ▁-> ▁short _ seek _ threshold ▁= ▁FF MAX ▁( ▁s ▁-> ▁pb ▁-> ▁short _ seek _ threshold ▁, ▁pos _ delta ▁/ ▁2 ▁) ▁; ▁} ▁}	1
▁static ▁int ▁rand _ add ▁( ▁const ▁void ▁* ▁buf ▁, ▁int ▁num ▁, ▁double ▁add ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁st _ idx ▁; ▁long ▁md _ c ▁[ ▁2 ▁] ▁; ▁unsigned ▁char ▁local _ md ▁[ ▁SHA _ DIGEST _ LENGTH ▁] ▁; ▁EVP _ MD _ CTX ▁* ▁m ▁; ▁int ▁do _ not _ lock ▁; ▁int ▁rv ▁= ▁0 ▁; ▁OSSL _ RAND _ STATE ▁* ▁sp ▁= ▁& ▁global _ state ▁; ▁if ▁( ▁! ▁num ▁) ▁return ▁1 ▁; ▁m ▁= ▁EVP _ MD _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁m ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁RUN _ ONCE ▁( ▁& ▁ossl _ rand _ init ▁, ▁do _ oss l _ rand _ init ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁crypto _ lock _ rand ▁) ▁{ ▁CRYPTO _ THREAD _ ID ▁cur ▁= ▁CRYPTO _ THREAD _ get _ current _ id ▁( ▁) ▁; ▁CRYPTO _ THREAD _ read _ lock ▁( ▁rand _ tmp _ lock ▁) ▁; ▁do _ not _ lock ▁= ▁CRYPTO _ THREAD _ compare _ id ▁( ▁locking _ thread id ▁, ▁cur ▁) ▁; ▁CRYPTO _ THREAD _ unlock ▁( ▁rand _ tmp _ lock ▁) ▁; ▁} ▁else ▁do _ not _ lock ▁= ▁0 ▁; ▁if ▁( ▁! ▁do _ not _ lock ▁) ▁CRYPTO _ THREAD _ write _ lock ▁( ▁rand _ lock ▁) ▁; ▁st _ idx ▁= ▁sp ▁-> ▁index ▁; ▁md _ c ▁[ ▁0 ▁] ▁= ▁sp ▁-> ▁md _ count ▁[ ▁0 ▁] ▁; ▁md _ c ▁[ ▁1 ▁] ▁= ▁sp ▁-> ▁md _ count ▁[ ▁1 ▁] ▁; ▁memcpy ▁( ▁local _ md ▁, ▁sp ▁-> ▁md ▁, ▁sizeof ▁( ▁sp ▁-> ▁md ▁) ▁) ▁; ▁sp ▁-> ▁index ▁+= ▁num ▁; ▁if ▁( ▁sp ▁-> ▁index ▁>= ▁STATE _ SIZE ▁) ▁{ ▁sp ▁-> ▁index ▁%= ▁STATE _ SIZE ▁; ▁sp ▁-> ▁num ▁= ▁STATE _ SIZE ▁; ▁} ▁else ▁if ▁( ▁sp ▁-> ▁num ▁< ▁STATE _ SIZE ▁) ▁{ ▁if ▁( ▁sp ▁-> ▁index ▁> ▁sp ▁-> ▁num ▁) ▁sp ▁-> ▁num ▁= ▁sp ▁-> ▁index ▁; ▁} ▁sp ▁-> ▁md _ count ▁[ ▁1 ▁] ▁+= ▁( ▁num ▁/ ▁SHA _ DIGEST _ LENGTH ▁) ▁+ ▁( ▁num ▁% ▁SHA _ DIGEST _ LENGTH ▁> ▁0 ▁) ▁; ▁if ▁( ▁! ▁do _ not _ lock ▁) ▁CRYPTO _ THREAD _ unlock ▁( ▁rand _ lock ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁; ▁i ▁+= ▁SHA _ DIGEST _ LENGTH ▁) ▁{ ▁j ▁= ▁( ▁num ▁- ▁i ▁) ▁; ▁j ▁= ▁( ▁j ▁> ▁SHA _ DIGEST _ LENGTH ▁) ▁? ▁SHA _ DIGEST _ LENGTH ▁: ▁j ▁; ▁if ▁( ▁! ▁EVP _ Digest Init _ ex ▁( ▁m ▁, ▁EVP _ sha 1 ▁( ▁) ▁, ▁NULL ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EVP _ DigestUpdate ▁( ▁m ▁, ▁local _ md ▁, ▁SHA _ DIGEST _ LENGTH ▁) ▁) ▁goto ▁err ▁; ▁k ▁= ▁( ▁st _ idx ▁+ ▁j ▁) ▁- ▁STATE _ SIZE ▁; ▁if ▁( ▁k ▁> ▁0 ▁) ▁{ ▁if ▁( ▁! ▁EVP _ DigestUpdate ▁( ▁m ▁, ▁& ▁sp ▁-> ▁state ▁[ ▁st _ idx ▁] ▁, ▁j ▁- ▁k ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EVP _ DigestUpdate ▁( ▁m ▁, ▁& ▁sp ▁-> ▁state ▁[ ▁0 ▁] ▁, ▁k ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁if ▁( ▁! ▁EVP _ DigestUpdate ▁( ▁m ▁, ▁& ▁sp ▁-> ▁state ▁[ ▁st _ idx ▁] ▁, ▁j ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EVP _ DigestUpdate ▁( ▁m ▁, ▁buf ▁, ▁j ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EVP _ DigestUpdate ▁( ▁m ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁md _ c ▁, ▁sizeof ▁( ▁md _ c ▁) ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EVP _ Digest Final _ ex ▁( ▁m ▁, ▁local _ md ▁, ▁NULL ▁) ▁) ▁goto ▁err ▁; ▁md _ c ▁[ ▁1 ▁] ▁++ ▁; ▁buf ▁= ▁( ▁const ▁char ▁* ▁) ▁buf ▁+ ▁j ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁j ▁; ▁k ▁++ ▁) ▁{ ▁sp ▁-> ▁state ▁[ ▁st _ idx ▁++ ▁] ▁ ^ = ▁local _ md ▁[ ▁k ▁] ▁; ▁if ▁( ▁st _ idx ▁>= ▁STATE _ SIZE ▁) ▁st _ idx ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁! ▁do _ not _ lock ▁) ▁CRYPTO _ THREAD _ write _ lock ▁( ▁rand _ lock ▁) ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁( ▁int ▁) ▁sizeof ▁( ▁sp ▁-> ▁md ▁) ▁; ▁k ▁++ ▁) ▁{ ▁sp ▁-> ▁md ▁[ ▁k ▁] ▁ ^ = ▁local _ md ▁[ ▁k ▁] ▁; ▁} ▁if ▁( ▁randomness ▁< ▁RANDOM NESS _ NEEDED ▁) ▁randomness ▁+= ▁add ▁; ▁if ▁( ▁! ▁do _ not _ lock ▁) ▁CRYPTO _ THREAD _ unlock ▁( ▁rand _ lock ▁) ▁; ▁rv ▁= ▁1 ▁; ▁err ▁: ▁EVP _ MD _ CTX _ free ▁( ▁m ▁) ▁; ▁return ▁rv ▁; ▁}	1
▁static ▁inline ▁int ▁w nv 1_ get _ code ▁( ▁W NV 1 Context ▁* ▁w ▁, ▁int ▁base _ value ▁) ▁{ ▁int ▁v ▁= ▁get _ vlc 2 ▁( ▁& ▁w ▁-> ▁gb ▁, ▁code _ vlc ▁. ▁table ▁, ▁CODE _ V LC _ BITS ▁, ▁1 ▁) ▁; ▁if ▁( ▁v ▁== ▁15 ▁) ▁return ▁ff _ reverse ▁[ ▁get _ bits ▁( ▁& ▁w ▁-> ▁gb ▁, ▁8 ▁- ▁w ▁-> ▁shift ▁) ▁] ▁; ▁else ▁return ▁base _ value ▁+ ▁( ▁( ▁v ▁- ▁7 U ▁) ▁<< ▁w ▁-> ▁shift ▁) ▁; ▁}	0
▁static ▁uint 64_ t ▁calc _ rice _ params ▁( ▁R ice Context ▁* ▁rc ▁, ▁int ▁p min ▁, ▁int ▁p max ▁, ▁int 32_ t ▁* ▁data ▁, ▁int ▁n ▁, ▁int ▁pred _ order ▁) ▁{ ▁int ▁i ▁; ▁uint 64_ t ▁bits ▁[ ▁MAX _ PARTITION _ ORDER ▁+ ▁1 ▁] ▁; ▁int ▁opt _ p order ▁; ▁R ice Context ▁tmp _ rc ▁; ▁uint 64_ t ▁sums ▁[ ▁MAX _ PARTITION _ ORDER ▁+ ▁1 ▁] ▁[ ▁MAX _ PARTITIONS ▁] ▁= ▁{ ▁{ ▁0 ▁} ▁} ▁; ▁assert ▁( ▁p min ▁>= ▁0 ▁&& ▁p min ▁<= ▁MAX _ PARTITION _ ORDER ▁) ▁; ▁assert ▁( ▁p max ▁>= ▁0 ▁&& ▁p max ▁<= ▁MAX _ PARTITION _ ORDER ▁) ▁; ▁assert ▁( ▁p min ▁<= ▁p max ▁) ▁; ▁tmp _ rc ▁. ▁coding _ mode ▁= ▁rc ▁-> ▁coding _ mode ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁rc ▁-> ▁udata ▁[ ▁i ▁] ▁= ▁( ▁2 ▁* ▁data ▁[ ▁i ▁] ▁) ▁ ^ ▁( ▁data ▁[ ▁i ▁] ▁>> ▁31 ▁) ▁; ▁calc _ sum s ▁( ▁p min ▁, ▁p max ▁, ▁rc ▁-> ▁udata ▁, ▁n ▁, ▁pred _ order ▁, ▁sums ▁) ▁; ▁opt _ p order ▁= ▁p min ▁; ▁bits ▁[ ▁p min ▁] ▁= ▁UINT 32_ MAX ▁; ▁for ▁( ▁i ▁= ▁p min ▁; ▁i ▁<= ▁p max ▁; ▁i ▁++ ▁) ▁{ ▁bits ▁[ ▁i ▁] ▁= ▁calc _ opt imal _ rice _ params ▁( ▁& ▁tmp _ rc ▁, ▁i ▁, ▁sums ▁[ ▁i ▁] ▁, ▁n ▁, ▁pred _ order ▁) ▁; ▁if ▁( ▁bits ▁[ ▁i ▁] ▁<= ▁bits ▁[ ▁opt _ p order ▁] ▁) ▁{ ▁opt _ p order ▁= ▁i ▁; ▁* ▁rc ▁= ▁tmp _ rc ▁; ▁} ▁} ▁return ▁bits ▁[ ▁opt _ p order ▁] ▁; ▁}	0
▁MSG _ PROCESS _ RETURN ▁tls _ process _ new _ session _ ticket ▁( ▁SSL ▁* ▁s ▁, ▁PACKET ▁* ▁pkt ▁) ▁{ ▁unsigned ▁int ▁tick len ▁; ▁unsigned ▁long ▁ticket _ l ifetime _ hint ▁, ▁age _ add ▁= ▁0 ▁; ▁unsigned ▁int ▁sess _ len ▁; ▁RAW _ EXTENSION ▁* ▁exts ▁= ▁NULL ▁; ▁PACKET ▁nonce ▁; ▁PACKET _ null _ init ▁( ▁& ▁nonce ▁) ▁; ▁if ▁( ▁! ▁PACKET _ get _ net _4 ▁( ▁pkt ▁, ▁& ▁ticket _ l ifetime _ hint ▁) ▁|| ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁&& ▁( ▁! ▁PACKET _ get _ net _4 ▁( ▁pkt ▁, ▁& ▁age _ add ▁) ▁|| ▁! ▁PACKET _ get _ length _ pref ixed _1 ▁( ▁pkt ▁, ▁& ▁nonce ▁) ▁) ▁) ▁|| ▁! ▁PACKET _ get _ net _2 ▁( ▁pkt ▁, ▁& ▁tick len ▁) ▁|| ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁? ▁( ▁tick len ▁== ▁0 ▁|| ▁PACKET _ remaining ▁( ▁pkt ▁) ▁< ▁tick len ▁) ▁: ▁PACKET _ remaining ▁( ▁pkt ▁) ▁!= ▁tick len ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ DECODE _ ERROR ▁, ▁SSL _ F _ TLS _ PROCESS _ NEW _ SESSION _ TICK ET ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁tick len ▁== ▁0 ▁) ▁return ▁MSG _ PROCESS _ CONTINUE _ READ ING ▁; ▁if ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁|| ▁s ▁-> ▁session ▁-> ▁session _ id _ length ▁> ▁0 ▁) ▁{ ▁SSL _ SESSION ▁* ▁new _ sess ▁; ▁if ▁( ▁( ▁new _ sess ▁= ▁ssl _ session _ dup ▁( ▁s ▁-> ▁session ▁, ▁0 ▁) ▁) ▁== ▁0 ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS _ PROCESS _ NEW _ SESSION _ TICK ET ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁session _ cache _ mode ▁& ▁SSL _ S ESS _ CACHE _ CLIENT ▁) ▁!= ▁0 ▁&& ▁! ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁{ ▁SSL _ CTX _ remove _ session ▁( ▁s ▁-> ▁session _ ctx ▁, ▁s ▁-> ▁session ▁) ▁; ▁} ▁SSL _ SESSION _ free ▁( ▁s ▁-> ▁session ▁) ▁; ▁s ▁-> ▁session ▁= ▁new _ sess ▁; ▁} ▁s ▁-> ▁session ▁-> ▁time ▁= ▁( ▁long ▁) ▁time ▁( ▁NULL ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick ▁) ▁; ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick ▁= ▁NULL ▁; ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick len ▁= ▁0 ▁; ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick ▁= ▁OPENSSL _ malloc ▁( ▁tick len ▁) ▁; ▁if ▁( ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick ▁== ▁NULL ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS _ PROCESS _ NEW _ SESSION _ TICK ET ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁PACKET _ copy _ bytes ▁( ▁pkt ▁, ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick ▁, ▁tick len ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ DECODE _ ERROR ▁, ▁SSL _ F _ TLS _ PROCESS _ NEW _ SESSION _ TICK ET ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁err ▁; ▁} ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick _ l ifetime _ hint ▁= ▁ticket _ l ifetime _ hint ▁; ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick _ age _ add ▁= ▁age _ add ▁; ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick len ▁= ▁tick len ▁; ▁if ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁{ ▁PACKET ▁ext pkt ▁; ▁if ▁( ▁! ▁PACKET _ as _ length _ pref ixed _2 ▁( ▁pkt ▁, ▁& ▁ext pkt ▁) ▁|| ▁PACKET _ remaining ▁( ▁pkt ▁) ▁!= ▁0 ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ DECODE _ ERROR ▁, ▁SSL _ F _ TLS _ PROCESS _ NEW _ SESSION _ TICK ET ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁tls _ collect _ extensions ▁( ▁s ▁, ▁& ▁ext pkt ▁, ▁SSL _ EXT _ TLS 1_ 3_ NEW _ SESSION _ TICK ET ▁, ▁& ▁exts ▁, ▁NULL ▁, ▁1 ▁) ▁|| ▁! ▁tls _ parse _ all _ extensions ▁( ▁s ▁, ▁SSL _ EXT _ TLS 1_ 3_ NEW _ SESSION _ TICK ET ▁, ▁exts ▁, ▁NULL ▁, ▁0 ▁, ▁1 ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁} ▁if ▁( ▁! ▁EVP _ Digest ▁( ▁s ▁-> ▁session ▁-> ▁ext ▁. ▁tick ▁, ▁tick len ▁, ▁s ▁-> ▁session ▁-> ▁session _ id ▁, ▁& ▁sess _ len ▁, ▁EVP _ sha 256 ▁( ▁) ▁, ▁NULL ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS _ PROCESS _ NEW _ SESSION _ TICK ET ▁, ▁ERR _ R _ EVP _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s ▁-> ▁session ▁-> ▁session _ id _ length ▁= ▁sess _ len ▁; ▁s ▁-> ▁session ▁-> ▁not _ res um able ▁= ▁0 ▁; ▁if ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁{ ▁const ▁EVP _ MD ▁* ▁md ▁= ▁ssl _ handshake _ md ▁( ▁s ▁) ▁; ▁int ▁hash len i ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁size _ t ▁hash len ▁; ▁static ▁const ▁unsigned ▁char ▁nonce _ label ▁[ ▁] ▁= ▁" res umption " ▁; ▁if ▁( ▁! ▁ossl _ assert ▁( ▁hash len i ▁>= ▁0 ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS _ PROCESS _ NEW _ SESSION _ TICK ET ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁hash len ▁= ▁( ▁size _ t ▁) ▁hash len i ▁; ▁if ▁( ▁! ▁tls 13_ h kdf _ expand ▁( ▁s ▁, ▁md ▁, ▁s ▁-> ▁res umption _ master _ secret ▁, ▁nonce _ label ▁, ▁sizeof ▁( ▁nonce _ label ▁) ▁- ▁1 ▁, ▁PACKET _ data ▁( ▁& ▁nonce ▁) ▁, ▁PACKET _ remaining ▁( ▁& ▁nonce ▁) ▁, ▁s ▁-> ▁session ▁-> ▁master _ key ▁, ▁hash len ▁, ▁1 ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁s ▁-> ▁session ▁-> ▁master _ key _ length ▁= ▁hash len ▁; ▁OPENSSL _ free ▁( ▁exts ▁) ▁; ▁ssl _ update _ cache ▁( ▁s ▁, ▁SSL _ S ESS _ CACHE _ CLIENT ▁) ▁; ▁return ▁MSG _ PROCESS _ FINISHED _ READ ING ▁; ▁} ▁return ▁MSG _ PROCESS _ CONTINUE _ READ ING ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁exts ▁) ▁; ▁return ▁MSG _ PROCESS _ ERROR ▁; ▁}	0
▁int ▁ssl _ get _ prev _ session ▁( ▁SSL ▁* ▁s ▁, ▁CLIENT HELLO _ MSG ▁* ▁hello ▁) ▁{ ▁SSL _ SESSION ▁* ▁ret ▁= ▁NULL ▁; ▁int ▁fatal ▁= ▁0 ▁; ▁int ▁try _ session _ cache ▁= ▁0 ▁; ▁int ▁r ▁; ▁if ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁{ ▁int ▁al ▁; ▁if ▁( ▁! ▁tls _ parse _ extension ▁( ▁s ▁, ▁TL SE XT _ IDX _ ps k ▁, ▁EXT _ CLIENT _ HELLO ▁, ▁hello ▁-> ▁pre _ proc _ ext s ▁, ▁NULL ▁, ▁0 ▁, ▁& ▁al ▁) ▁) ▁return ▁-1 ▁; ▁ret ▁= ▁s ▁-> ▁session ▁; ▁} ▁else ▁{ ▁r ▁= ▁tls _ get _ ticket _ from _ client ▁( ▁s ▁, ▁hello ▁, ▁& ▁ret ▁) ▁; ▁switch ▁( ▁r ▁) ▁{ ▁case ▁-1 ▁: ▁fatal ▁= ▁1 ▁; ▁goto ▁err ▁; ▁case ▁0 ▁: ▁case ▁1 ▁: ▁try _ session _ cache ▁= ▁1 ▁; ▁break ▁; ▁case ▁2 ▁: ▁case ▁3 ▁: ▁break ▁; ▁default ▁: ▁abort ▁( ▁) ▁; ▁} ▁} ▁if ▁( ▁try _ session _ cache ▁&& ▁ret ▁== ▁NULL ▁&& ▁! ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁session _ cache _ mode ▁& ▁SSL _ S ESS _ CACHE _ NO _ INTERNAL _ LOOKUP ▁) ▁) ▁{ ▁SSL _ SESSION ▁data ▁; ▁data ▁. ▁ssl _ version ▁= ▁s ▁-> ▁version ▁; ▁memset ▁( ▁data ▁. ▁session _ id ▁, ▁0 ▁, ▁sizeof ▁( ▁data ▁. ▁session _ id ▁) ▁) ▁; ▁memcpy ▁( ▁data ▁. ▁session _ id ▁, ▁hello ▁-> ▁session _ id ▁, ▁hello ▁-> ▁session _ id _ len ▁) ▁; ▁data ▁. ▁session _ id _ length ▁= ▁hello ▁-> ▁session _ id _ len ▁; ▁CRYPTO _ THREAD _ read _ lock ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁lock ▁) ▁; ▁ret ▁= ▁lh _ SSL _ SESSION _ ret rieve ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁sessions ▁, ▁& ▁data ▁) ▁; ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁{ ▁SSL _ SESSION _ up _ ref ▁( ▁ret ▁) ▁; ▁} ▁CRYPTO _ THREAD _ unlock ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁lock ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ miss ▁++ ▁; ▁} ▁if ▁( ▁try _ session _ cache ▁&& ▁ret ▁== ▁NULL ▁&& ▁s ▁-> ▁session _ ctx ▁-> ▁get _ session _ cb ▁!= ▁NULL ▁) ▁{ ▁int ▁copy ▁= ▁1 ▁; ▁ret ▁= ▁s ▁-> ▁session _ ctx ▁-> ▁get _ session _ cb ▁( ▁s ▁, ▁hello ▁-> ▁session _ id ▁, ▁hello ▁-> ▁session _ id _ len ▁, ▁& ▁copy ▁) ▁; ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁{ ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ cb _ hit ▁++ ▁; ▁if ▁( ▁copy ▁) ▁SSL _ SESSION _ up _ ref ▁( ▁ret ▁) ▁; ▁if ▁( ▁! ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁session _ cache _ mode ▁& ▁SSL _ S ESS _ CACHE _ NO _ INTERNAL _ STORE ▁) ▁) ▁{ ▁if ▁( ▁SSL _ CTX _ add _ session ▁( ▁s ▁-> ▁session _ ctx ▁, ▁ret ▁) ▁) ▁goto ▁err ▁; ▁} ▁} ▁} ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁ret ▁-> ▁ssl _ version ▁!= ▁s ▁-> ▁version ▁) ▁goto ▁err ▁; ▁if ▁( ▁ret ▁-> ▁sid _ ctx _ length ▁!= ▁s ▁-> ▁sid _ ctx _ length ▁|| ▁memcmp ▁( ▁ret ▁-> ▁sid _ ctx ▁, ▁s ▁-> ▁sid _ ctx ▁, ▁ret ▁-> ▁sid _ ctx _ length ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁s ▁-> ▁verify _ mode ▁& ▁SSL _ VERIFY _ PEER ▁) ▁&& ▁s ▁-> ▁sid _ ctx _ length ▁== ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ GET _ PREV _ SESSION ▁, ▁SSL _ R _ SESSION _ ID _ CONTEXT _ UN INITIALIZED ▁) ▁; ▁fatal ▁= ▁1 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁ret ▁-> ▁cipher ▁== ▁NULL ▁) ▁{ ▁unsigned ▁char ▁buf ▁[ ▁5 ▁] ▁, ▁* ▁p ▁; ▁unsigned ▁long ▁l ▁; ▁p ▁= ▁buf ▁; ▁l ▁= ▁ret ▁-> ▁cipher _ id ▁; ▁l 2 n ▁( ▁l ▁, ▁p ▁) ▁; ▁if ▁( ▁( ▁ret ▁-> ▁ssl _ version ▁>> ▁8 ▁) ▁>= ▁SSL 3_ VERSION _ MAJOR ▁) ▁ret ▁-> ▁cipher ▁= ▁ssl _ get _ cipher _ by _ char ▁( ▁s ▁, ▁& ▁( ▁buf ▁[ ▁2 ▁] ▁) ▁) ▁; ▁else ▁ret ▁-> ▁cipher ▁= ▁ssl _ get _ cipher _ by _ char ▁( ▁s ▁, ▁& ▁( ▁buf ▁[ ▁1 ▁] ▁) ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cipher ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁ret ▁-> ▁timeout ▁< ▁( ▁long ▁) ▁( ▁time ▁( ▁NULL ▁) ▁- ▁ret ▁-> ▁time ▁) ▁) ▁{ ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ timeout ▁++ ▁; ▁if ▁( ▁try _ session _ cache ▁) ▁{ ▁SSL _ CTX _ remove _ session ▁( ▁s ▁-> ▁session _ ctx ▁, ▁ret ▁) ▁; ▁} ▁goto ▁err ▁; ▁} ▁if ▁( ▁ret ▁-> ▁flags ▁& ▁SSL _ S ESS _ FLAG _ EXT MS ▁) ▁{ ▁if ▁( ▁! ▁( ▁s ▁-> ▁s 3 ▁-> ▁flags ▁& ▁TLS 1_ FLAGS _ RECE IVED _ EXT MS ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ GET _ PREV _ SESSION ▁, ▁SSL _ R _ IN CON SISTENT _ EXT MS ▁) ▁; ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ FATAL ▁, ▁SSL _ AD _ HAND SHAKE _ FAILURE ▁) ▁; ▁fatal ▁= ▁1 ▁; ▁goto ▁err ▁; ▁} ▁} ▁else ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁flags ▁& ▁TLS 1_ FLAGS _ RECE IVED _ EXT MS ▁) ▁{ ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁{ ▁SSL _ SESSION _ free ▁( ▁s ▁-> ▁session ▁) ▁; ▁s ▁-> ▁session ▁= ▁ret ▁; ▁} ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ hit ▁++ ▁; ▁s ▁-> ▁verify _ result ▁= ▁s ▁-> ▁session ▁-> ▁verify _ result ▁; ▁return ▁1 ▁; ▁err ▁: ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁{ ▁SSL _ SESSION _ free ▁( ▁ret ▁) ▁; ▁if ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁s ▁-> ▁session ▁= ▁NULL ▁; ▁if ▁( ▁! ▁try _ session _ cache ▁) ▁{ ▁s ▁-> ▁ext ▁. ▁ticket _ expected ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁fatal ▁) ▁return ▁-1 ▁; ▁else ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁m xf _ set _ audio _ pts ▁( ▁MX F Context ▁* ▁m xf ▁, ▁AVCodecContext ▁* ▁codec ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁MX F Track ▁* ▁track ▁= ▁m xf ▁-> ▁fc ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁priv _ data ▁; ▁pkt ▁-> ▁pts ▁= ▁track ▁-> ▁sample _ count ▁; ▁if ▁( ▁codec ▁-> ▁channels ▁<= ▁0 ▁|| ▁av _ get _ bits _ per _ sample ▁( ▁codec ▁-> ▁codec _ id ▁) ▁<= ▁0 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁track ▁-> ▁sample _ count ▁+= ▁pkt ▁-> ▁size ▁/ ▁( ▁codec ▁-> ▁channels ▁* ▁( ▁int 64_ t ▁) ▁av _ get _ bits _ per _ sample ▁( ▁codec ▁-> ▁codec _ id ▁) ▁/ ▁8 ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁jac os ub _ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁const ▁char ▁* ▁ptr ▁= ▁p ▁-> ▁buf ▁; ▁const ▁char ▁* ▁ptr _ end ▁= ▁p ▁-> ▁buf ▁+ ▁p ▁-> ▁buf _ size ▁; ▁if ▁( ▁AV _ RB 24 ▁( ▁ptr ▁) ▁== ▁0 xEF BB BF ▁) ▁ptr ▁+= ▁3 ▁; ▁while ▁( ▁ptr ▁< ▁ptr _ end ▁) ▁{ ▁while ▁( ▁j ss _ whitespace ▁( ▁* ▁ptr ▁) ▁) ▁ptr ▁++ ▁; ▁if ▁( ▁* ▁ptr ▁!= ▁' ▁' ▁&& ▁* ▁ptr ▁!= ▁' ▁\ n ▁' ▁) ▁{ ▁if ▁( ▁timed _ line ▁( ▁ptr ▁) ▁) ▁return ▁AV PROBE _ SCORE _ EXTENSION ▁+ ▁1 ▁; ▁return ▁0 ▁; ▁} ▁ptr ▁+= ▁ff _ sub title s _ next _ line ▁( ▁ptr ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁lag _ decode _ zero _ run _ line ▁( ▁L ag arith Context ▁* ▁l ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁const ▁uint 8_ t ▁* ▁src _ end ▁, ▁int ▁width ▁, ▁int ▁esc _ count ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁count ▁; ▁uint 8_ t ▁zero _ run ▁= ▁0 ▁; ▁const ▁uint 8_ t ▁* ▁src _ start ▁= ▁src ▁; ▁uint 8_ t ▁mask 1 ▁= ▁- ▁( ▁esc _ count ▁< ▁2 ▁) ▁; ▁uint 8_ t ▁mask 2 ▁= ▁- ▁( ▁esc _ count ▁< ▁3 ▁) ▁; ▁uint 8_ t ▁* ▁end ▁= ▁dst ▁+ ▁( ▁width ▁- ▁2 ▁) ▁; ▁avpriv _ request _ sample ▁( ▁l ▁-> ▁avctx ▁, ▁" zero _ run _ line " ▁) ▁; ▁memset ▁( ▁dst ▁, ▁0 ▁, ▁width ▁) ▁; ▁output _ zeros ▁: ▁if ▁( ▁l ▁-> ▁zeros _ rem ▁) ▁{ ▁count ▁= ▁FF MIN ▁( ▁l ▁-> ▁zeros _ rem ▁, ▁width ▁- ▁i ▁) ▁; ▁if ▁( ▁end ▁- ▁dst ▁< ▁count ▁) ▁{ ▁av _ log ▁( ▁l ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" T oom any zeros remaining .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁memset ▁( ▁dst ▁, ▁0 ▁, ▁count ▁) ▁; ▁l ▁-> ▁zeros _ rem ▁-= ▁count ▁; ▁dst ▁+= ▁count ▁; ▁} ▁while ▁( ▁dst ▁< ▁end ▁) ▁{ ▁i ▁= ▁0 ▁; ▁while ▁( ▁! ▁zero _ run ▁&& ▁dst ▁+ ▁i ▁< ▁end ▁) ▁{ ▁i ▁++ ▁; ▁if ▁( ▁i ▁+ ▁2 ▁>= ▁src _ end ▁- ▁src ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁zero _ run ▁= ▁! ▁( ▁src ▁[ ▁i ▁] ▁| ▁( ▁src ▁[ ▁i ▁+ ▁1 ▁] ▁& ▁mask 1 ▁) ▁| ▁( ▁src ▁[ ▁i ▁+ ▁2 ▁] ▁& ▁mask 2 ▁) ▁) ▁; ▁} ▁if ▁( ▁zero _ run ▁) ▁{ ▁zero _ run ▁= ▁0 ▁; ▁i ▁+= ▁esc _ count ▁; ▁memcpy ▁( ▁dst ▁, ▁src ▁, ▁i ▁) ▁; ▁dst ▁+= ▁i ▁; ▁l ▁-> ▁zeros _ rem ▁= ▁lag _ calc _ zero _ run ▁( ▁src ▁[ ▁i ▁] ▁) ▁; ▁src ▁+= ▁i ▁+ ▁1 ▁; ▁goto ▁output _ zeros ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁dst ▁, ▁src ▁, ▁i ▁) ▁; ▁src ▁+= ▁i ▁; ▁dst ▁+= ▁i ▁; ▁} ▁} ▁return ▁src ▁- ▁src _ start ▁; ▁}	0
▁X 509_ VERIFY _ PARAM ▁* ▁X 509_ VERIFY _ PARAM _ new ▁( ▁void ▁) ▁{ ▁X 509_ VERIFY _ PARAM ▁* ▁param ▁; ▁param ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁X 509_ VERIFY _ PARAM ▁) ▁) ▁; ▁memset ▁( ▁param ▁, ▁0 ▁, ▁sizeof ▁( ▁X 509_ VERIFY _ PARAM ▁) ▁) ▁; ▁x 509_ verify _ param _ zero ▁( ▁param ▁) ▁; ▁return ▁param ▁; ▁}	1
▁static ▁int ▁r ac _ get _ model 256_ sym ▁( ▁Range Coder ▁* ▁c ▁, ▁Model 256 ▁* ▁m ▁) ▁{ ▁int ▁prob ▁, ▁prob 2 ▁, ▁helper ▁, ▁val ▁; ▁int ▁start ▁, ▁end ▁; ▁int ▁ss ym ▁; ▁prob 2 ▁= ▁c ▁-> ▁range ▁; ▁c ▁-> ▁range ▁>>= ▁MODEL _ SCALE ▁; ▁helper ▁= ▁c ▁-> ▁low ▁/ ▁c ▁-> ▁range ▁; ▁ss ym ▁= ▁helper ▁>> ▁MODEL 256_ SEC _ SCALE ▁; ▁val ▁= ▁m ▁-> ▁secondary ▁[ ▁ss ym ▁] ▁; ▁end ▁= ▁start ▁= ▁m ▁-> ▁secondary ▁[ ▁ss ym ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁while ▁( ▁end ▁> ▁val ▁+ ▁1 ▁) ▁{ ▁ss ym ▁= ▁( ▁end ▁+ ▁val ▁) ▁>> ▁1 ▁; ▁if ▁( ▁m ▁-> ▁freqs ▁[ ▁ss ym ▁] ▁<= ▁helper ▁) ▁{ ▁end ▁= ▁start ▁; ▁val ▁= ▁ss ym ▁; ▁} ▁else ▁{ ▁end ▁= ▁( ▁end ▁+ ▁val ▁) ▁>> ▁1 ▁; ▁start ▁= ▁ss ym ▁; ▁} ▁} ▁prob ▁= ▁m ▁-> ▁freqs ▁[ ▁val ▁] ▁* ▁c ▁-> ▁range ▁; ▁if ▁( ▁val ▁!= ▁255 ▁) ▁prob 2 ▁= ▁m ▁-> ▁freqs ▁[ ▁val ▁+ ▁1 ▁] ▁* ▁c ▁-> ▁range ▁; ▁c ▁-> ▁low ▁-= ▁prob ▁; ▁c ▁-> ▁range ▁= ▁prob 2 ▁- ▁prob ▁; ▁if ▁( ▁c ▁-> ▁range ▁< ▁R AC _ BOTTOM ▁) ▁r ac _ normal ise ▁( ▁c ▁) ▁; ▁model 256_ update ▁( ▁m ▁, ▁val ▁) ▁; ▁return ▁val ▁; ▁}	1
▁int ▁TIFF Write Scan line ▁( ▁TIFF ▁* ▁tif ▁, ▁void ▁* ▁buf ▁, ▁uint 32 ▁row ▁, ▁uint 16 ▁sample ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Write Scan line " ▁; ▁register ▁TIFF Directory ▁* ▁td ▁; ▁int ▁status ▁, ▁image gre w ▁= ▁0 ▁; ▁uint 32 ▁strip ▁; ▁if ▁( ▁! ▁WRITE CHECK STR IPS ▁( ▁tif ▁, ▁module ▁) ▁) ▁return ▁( ▁-1 ▁) ▁; ▁if ▁( ▁! ▁BUFFER CHECK ▁( ▁tif ▁) ▁) ▁return ▁( ▁-1 ▁) ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ BUF 4 WRITE ▁; ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁if ▁( ▁row ▁>= ▁td ▁-> ▁td _ image length ▁) ▁{ ▁if ▁( ▁td ▁-> ▁td _ planar config ▁== ▁PLAN AR CONFIG _ SEPAR ATE ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Cannot change \" Image Length \" when using separate planes " ▁) ▁; ▁return ▁( ▁-1 ▁) ▁; ▁} ▁td ▁-> ▁td _ image length ▁= ▁row ▁+ ▁1 ▁; ▁image gre w ▁= ▁1 ▁; ▁} ▁if ▁( ▁td ▁-> ▁td _ planar config ▁== ▁PLAN AR CONFIG _ SEPAR ATE ▁) ▁{ ▁if ▁( ▁sample ▁>= ▁td ▁-> ▁td _ samples per pixel ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁"% lu : Sample out of range , max % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁sample ▁, ▁( ▁unsigned ▁long ▁) ▁td ▁-> ▁td _ samples per pixel ▁) ▁; ▁return ▁( ▁-1 ▁) ▁; ▁} ▁strip ▁= ▁sample ▁* ▁td ▁-> ▁td _ stri ps per image ▁+ ▁row ▁/ ▁td ▁-> ▁td _ rows per strip ▁; ▁} ▁else ▁strip ▁= ▁row ▁/ ▁td ▁-> ▁td _ rows per strip ▁; ▁if ▁( ▁strip ▁>= ▁td ▁-> ▁td _ n stri ps ▁&& ▁! ▁TIFF Grow Stri ps ▁( ▁tif ▁, ▁1 ▁, ▁module ▁) ▁) ▁return ▁( ▁-1 ▁) ▁; ▁if ▁( ▁strip ▁!= ▁tif ▁-> ▁tif _ cur strip ▁) ▁{ ▁if ▁( ▁! ▁TI FFF lush Data ▁( ▁tif ▁) ▁) ▁return ▁( ▁-1 ▁) ▁; ▁tif ▁-> ▁tif _ cur strip ▁= ▁strip ▁; ▁if ▁( ▁strip ▁>= ▁td ▁-> ▁td _ stri ps per image ▁&& ▁image gre w ▁) ▁td ▁-> ▁td _ stri ps per image ▁= ▁TIFF how many _32 ▁( ▁td ▁-> ▁td _ image length ▁, ▁td ▁-> ▁td _ rows per strip ▁) ▁; ▁if ▁( ▁td ▁-> ▁td _ stri ps per image ▁== ▁0 ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Z er ost ri ps per image " ▁) ▁; ▁return ▁( ▁-1 ▁) ▁; ▁} ▁tif ▁-> ▁tif _ row ▁= ▁( ▁strip ▁% ▁td ▁-> ▁td _ stri ps per image ▁) ▁* ▁td ▁-> ▁td _ rows per strip ▁; ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ CODER SETUP ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁! ▁( ▁* ▁tif ▁-> ▁tif _ setup encode ▁) ▁( ▁tif ▁) ▁) ▁return ▁( ▁-1 ▁) ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ CODER SETUP ▁; ▁} ▁tif ▁-> ▁tif _ raw cc ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ raw cp ▁= ▁tif ▁-> ▁tif _ raw data ▁; ▁if ▁( ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁> ▁0 ▁) ▁{ ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ cur off ▁= ▁0 ▁; ▁} ▁if ▁( ▁! ▁( ▁* ▁tif ▁-> ▁tif _ pre encode ▁) ▁( ▁tif ▁, ▁sample ▁) ▁) ▁return ▁( ▁-1 ▁) ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ POST ENCODE ▁; ▁} ▁if ▁( ▁row ▁!= ▁tif ▁-> ▁tif _ row ▁) ▁{ ▁if ▁( ▁row ▁< ▁tif ▁-> ▁tif _ row ▁) ▁{ ▁tif ▁-> ▁tif _ row ▁= ▁( ▁strip ▁% ▁td ▁-> ▁td _ stri ps per image ▁) ▁* ▁td ▁-> ▁td _ rows per strip ▁; ▁tif ▁-> ▁tif _ raw cp ▁= ▁tif ▁-> ▁tif _ raw data ▁; ▁} ▁if ▁( ▁! ▁( ▁* ▁tif ▁-> ▁tif _ seek ▁) ▁( ▁tif ▁, ▁row ▁- ▁tif ▁-> ▁tif _ row ▁) ▁) ▁return ▁( ▁-1 ▁) ▁; ▁tif ▁-> ▁tif _ row ▁= ▁row ▁; ▁} ▁tif ▁-> ▁tif _ post decode ▁( ▁tif ▁, ▁( ▁uint 8 ▁* ▁) ▁buf ▁, ▁tif ▁-> ▁tif _ scan lines ize ▁) ▁; ▁status ▁= ▁( ▁* ▁tif ▁-> ▁tif _ encoder ow ▁) ▁( ▁tif ▁, ▁( ▁uint 8 ▁* ▁) ▁buf ▁, ▁tif ▁-> ▁tif _ scan lines ize ▁, ▁sample ▁) ▁; ▁tif ▁-> ▁tif _ row ▁= ▁row ▁+ ▁1 ▁; ▁return ▁( ▁status ▁) ▁; ▁}	0
▁static ▁int ▁pkey _ g ost 01 cp _ keygen ▁( ▁EVP _ PKEY _ CTX ▁* ▁ctx ▁, ▁EVP _ PKEY ▁* ▁pkey ▁) ▁{ ▁struct ▁g ost _ pm eth _ data ▁* ▁data ▁= ▁EVP _ PKEY _ CTX _ get _ data ▁( ▁ctx ▁) ▁; ▁EC _ KEY ▁* ▁ec ▁= ▁NULL ▁; ▁if ▁( ▁data ▁-> ▁sign _ param _ nid ▁== ▁NID _ undef ▁) ▁{ ▁GOST err ▁( ▁GOST _ F _ PKEY _ GO ST 01_ KEY GEN ▁, ▁GOST _ R _ NO _ PARAMETERS _ SET ▁) ▁; ▁return ▁0 ▁; ▁} ▁ec ▁= ▁EC _ KEY _ new ▁( ▁) ▁; ▁if ▁( ▁! ▁fill _ GO ST 200 1_ params ▁( ▁ec ▁, ▁data ▁-> ▁sign _ param _ nid ▁) ▁) ▁{ ▁EC _ KEY _ free ▁( ▁ec ▁) ▁; ▁return ▁0 ▁; ▁} ▁g ost 200 1_ keygen ▁( ▁ec ▁) ▁; ▁EVP _ PKEY _ assign ▁( ▁pkey ▁, ▁NID _ id _ G ost R 34 10 _2 001 ▁, ▁ec ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁int ▁TIFF Fill Strip ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁strip ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Fill Strip " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NOR EAD RAW ▁) ▁== ▁0 ▁) ▁{ ▁uint 64 ▁byte count ▁= ▁TIFF Get Stri le ByteCount ▁( ▁tif ▁, ▁strip ▁) ▁; ▁if ▁( ▁byte count ▁== ▁0 ▁|| ▁byte count ▁> ▁( ▁uint 64 ▁) ▁TIFF _ INT 64_ MAX ▁) ▁{ ▁# if ▁defined ▁( ▁__ WIN 32__ ▁) ▁&& ▁( ▁defined ▁( ▁_ MSC _ VER ▁) ▁|| ▁defined ▁( ▁__ MINGW 32__ ▁) ▁) ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Invalid strip byte count % I 64 u , strip % lu " ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁) ▁; ▁# else ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Invalid strip byte count % llu , strip % lu " ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁) ▁; ▁# endif ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁byte count ▁> ▁1024 ▁* ▁1024 ▁) ▁{ ▁tm size _ t ▁strip size ▁= ▁TIFF Strip Size ▁( ▁tif ▁) ▁; ▁if ▁( ▁strip size ▁!= ▁0 ▁&& ▁( ▁byte count ▁- ▁4096 ▁) ▁/ ▁10 ▁> ▁( ▁uint 64 ▁) ▁strip size ▁) ▁{ ▁uint 64 ▁new byte count ▁= ▁( ▁uint 64 ▁) ▁strip size ▁* ▁10 ▁+ ▁4096 ▁; ▁if ▁( ▁new byte count ▁== ▁0 ▁|| ▁new byte count ▁> ▁( ▁uint 64 ▁) ▁TIFF _ INT 64_ MAX ▁) ▁{ ▁# if ▁defined ▁( ▁__ WIN 32__ ▁) ▁&& ▁( ▁defined ▁( ▁_ MSC _ VER ▁) ▁|| ▁defined ▁( ▁__ MINGW 32__ ▁) ▁) ▁TIFF Warning Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Tool argest rip byte count % I 64 u , strip % lu . Limit ing to % I 64 u " ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁new byte count ▁) ▁; ▁# else ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Tool argest rip byte count % llu , strip % lu . Limit ing to % llu " ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁byte count ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁new byte count ▁) ▁; ▁# endif ▁byte count ▁= ▁new byte count ▁; ▁} ▁} ▁} ▁if ▁( ▁is Mapped ▁( ▁tif ▁) ▁) ▁{ ▁if ▁( ▁byte count ▁> ▁( ▁uint 64 ▁) ▁tif ▁-> ▁tif _ size ▁|| ▁TIFF Get Stri le Offset ▁( ▁tif ▁, ▁strip ▁) ▁> ▁( ▁uint 64 ▁) ▁tif ▁-> ▁tif _ size ▁- ▁byte count ▁) ▁{ ▁# if ▁defined ▁( ▁__ WIN 32__ ▁) ▁&& ▁( ▁defined ▁( ▁_ MSC _ VER ▁) ▁|| ▁defined ▁( ▁__ MINGW 32__ ▁) ▁) ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Read error on strip % lu ;" ▁" got % I 64 uby tes , expected % I 64 u " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁tif ▁-> ▁tif _ size ▁- ▁TIFF Get Stri le Offset ▁( ▁tif ▁, ▁strip ▁) ▁, ▁( ▁unsigned ▁__ int 64 ▁) ▁byte count ▁) ▁; ▁# else ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Read error on strip % lu ;" ▁" got % ll uby tes , expected % llu " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁tif ▁-> ▁tif _ size ▁- ▁TIFF Get Stri le Offset ▁( ▁tif ▁, ▁strip ▁) ▁, ▁( ▁unsigned ▁long ▁long ▁) ▁byte count ▁) ▁; ▁# endif ▁tif ▁-> ▁tif _ cur strip ▁= ▁NO STRIP ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁if ▁( ▁is Mapped ▁( ▁tif ▁) ▁&& ▁( ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁|| ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁) ▁) ▁{ ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ MY BUFFER ▁) ▁&& ▁tif ▁-> ▁tif _ raw data ▁) ▁{ ▁_ TIFF free ▁( ▁tif ▁-> ▁tif _ raw data ▁) ▁; ▁tif ▁-> ▁tif _ raw data ▁= ▁NULL ▁; ▁tif ▁-> ▁tif _ raw datas ize ▁= ▁0 ▁; ▁} ▁tif ▁-> ▁tif _ flags ▁&= ▁ ~ ▁TIFF _ MY BUFFER ▁; ▁tif ▁-> ▁tif _ raw datas ize ▁= ▁( ▁tm size _ t ▁) ▁byte count ▁; ▁tif ▁-> ▁tif _ raw data ▁= ▁tif ▁-> ▁tif _ base ▁+ ▁( ▁tm size _ t ▁) ▁TIFF Get Stri le Offset ▁( ▁tif ▁, ▁strip ▁) ▁; ▁tif ▁-> ▁tif _ raw data off ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ raw datal o aded ▁= ▁( ▁tm size _ t ▁) ▁byte count ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ BUFFER MMAP ▁; ▁} ▁else ▁{ ▁tm size _ t ▁byte count m ▁; ▁byte count m ▁= ▁( ▁tm size _ t ▁) ▁byte count ▁; ▁if ▁( ▁( ▁uint 64 ▁) ▁byte count m ▁!= ▁byte count ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Integer overflow " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁byte count m ▁> ▁tif ▁-> ▁tif _ raw datas ize ▁) ▁{ ▁tif ▁-> ▁tif _ cur strip ▁= ▁NO STRIP ▁; ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ MY BUFFER ▁) ▁== ▁0 ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Dat ab uff ert oo small to hold strip % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁if ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ BUFFER MMAP ▁) ▁{ ▁tif ▁-> ▁tif _ cur strip ▁= ▁NO STRIP ▁; ▁tif ▁-> ▁tif _ raw data ▁= ▁NULL ▁; ▁tif ▁-> ▁tif _ raw datas ize ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ flags ▁&= ▁ ~ ▁TIFF _ BUFFER MMAP ▁; ▁} ▁if ▁( ▁is Mapped ▁( ▁tif ▁) ▁) ▁{ ▁if ▁( ▁byte count m ▁> ▁tif ▁-> ▁tif _ raw datas ize ▁&& ▁! ▁TIFF Read Buffer Setup ▁( ▁tif ▁, ▁0 ▁, ▁byte count m ▁) ▁) ▁{ ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁TIFF Read Raw Strip 1 ▁( ▁tif ▁, ▁strip ▁, ▁tif ▁-> ▁tif _ raw data ▁, ▁byte count m ▁, ▁module ▁) ▁!= ▁byte count m ▁) ▁{ ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁TIFF Read Raw Strip Or Tile 2 ▁( ▁tif ▁, ▁strip ▁, ▁1 ▁, ▁byte count m ▁, ▁module ▁) ▁!= ▁byte count m ▁) ▁{ ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁tif ▁-> ▁tif _ raw data off ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ raw datal o aded ▁= ▁byte count m ▁; ▁if ▁( ▁! ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁&& ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁== ▁0 ▁) ▁TIFF Reverse Bits ▁( ▁tif ▁-> ▁tif _ raw data ▁, ▁byte count m ▁) ▁; ▁} ▁} ▁return ▁( ▁TIFF Start Strip ▁( ▁tif ▁, ▁strip ▁) ▁) ▁; ▁}	0
▁static ▁void ▁vc 1_ loop _ filter ▁( ▁uint 8_ t ▁* ▁src ▁, ▁int ▁step ▁, ▁int ▁stride ▁, ▁int ▁len ▁, ▁int ▁pq ▁) ▁{ ▁int ▁i ▁; ▁int ▁filt 3 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁+= ▁4 ▁) ▁{ ▁filt 3 ▁= ▁vc 1_ filter _ line ▁( ▁src ▁+ ▁2 ▁* ▁step ▁, ▁stride ▁, ▁pq ▁) ▁; ▁if ▁( ▁filt 3 ▁) ▁{ ▁vc 1_ filter _ line ▁( ▁src ▁+ ▁0 ▁* ▁step ▁, ▁stride ▁, ▁pq ▁) ▁; ▁vc 1_ filter _ line ▁( ▁src ▁+ ▁1 ▁* ▁step ▁, ▁stride ▁, ▁pq ▁) ▁; ▁vc 1_ filter _ line ▁( ▁src ▁+ ▁3 ▁* ▁step ▁, ▁stride ▁, ▁pq ▁) ▁; ▁} ▁src ▁+= ▁step ▁* ▁4 ▁; ▁} ▁}	1
▁int ▁ff _ rd ft _ init ▁( ▁RD FT Context ▁* ▁s ▁, ▁int ▁nbits ▁, ▁enum ▁RDF Transform Type ▁trans ▁) ▁{ ▁int ▁n ▁= ▁1 ▁<< ▁nbits ▁; ▁int ▁ret ▁; ▁s ▁-> ▁nbits ▁= ▁nbits ▁; ▁s ▁-> ▁inverse ▁= ▁trans ▁== ▁ID FT _ C 2 R ▁|| ▁trans ▁== ▁D FT _ C 2 R ▁; ▁s ▁-> ▁sign _ con vention ▁= ▁trans ▁== ▁ID FT _ R 2 C ▁|| ▁trans ▁== ▁D FT _ C 2 R ▁? ▁1 ▁: ▁-1 ▁; ▁s ▁-> ▁negative _ sin ▁= ▁trans ▁== ▁D FT _ C 2 R ▁|| ▁trans ▁== ▁D FT _ R 2 C ▁; ▁if ▁( ▁nbits ▁< ▁4 ▁|| ▁nbits ▁> ▁16 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ fft _ init ▁( ▁& ▁s ▁-> ▁fft ▁, ▁nbits ▁- ▁1 ▁, ▁trans ▁== ▁ID FT _ C 2 R ▁|| ▁trans ▁== ▁ID FT _ R 2 C ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ff _ init _ ff _ cos _ tabs ▁( ▁nbits ▁) ▁; ▁s ▁-> ▁t cos ▁= ▁ff _ cos _ tabs ▁[ ▁nbits ▁] ▁; ▁s ▁-> ▁ts in ▁= ▁ff _ cos _ tabs ▁[ ▁nbits ▁] ▁+ ▁( ▁n ▁>> ▁2 ▁) ▁; ▁s ▁-> ▁rd ft _ calc ▁= ▁rd ft _ calc _ c ▁; ▁if ▁( ▁ARCH _ ARM ▁) ▁ff _ rd ft _ init _ arm ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁unsigned ▁t get _ long ▁( ▁Get Byte Context ▁* ▁gb ▁, ▁int ▁le ▁) ▁{ ▁unsigned ▁v ▁= ▁le ▁? ▁bytestream 2_ get _ le 32 ▁( ▁gb ▁) ▁: ▁bytestream 2_ get _ be 32 ▁( ▁gb ▁) ▁; ▁return ▁v ▁; ▁}	0
▁int ▁ff _ cc itt _ unpack ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁int ▁src size ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁height ▁, ▁int ▁stride ▁, ▁enum ▁T iff Comp r ▁compr ▁, ▁int ▁opts ▁) ▁{ ▁int ▁j ▁; ▁Get Bit Context ▁gb ▁; ▁int ▁* ▁runs ▁, ▁* ▁ref ▁= ▁NULL ▁, ▁* ▁run end ▁; ▁int ▁ret ▁; ▁int ▁run size ▁= ▁avctx ▁-> ▁width ▁+ ▁2 ▁; ▁int ▁err ▁= ▁0 ▁; ▁runs ▁= ▁av _ malloc ▁( ▁run size ▁* ▁sizeof ▁( ▁runs ▁[ ▁0 ▁] ▁) ▁) ▁; ▁ref ▁= ▁av _ malloc ▁( ▁run size ▁* ▁sizeof ▁( ▁ref ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁! ▁runs ▁|| ▁! ▁ref ▁) ▁{ ▁err ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁ref ▁[ ▁0 ▁] ▁= ▁avctx ▁-> ▁width ▁; ▁ref ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁ref ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁src ▁, ▁src size ▁* ▁8 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁height ▁; ▁j ▁++ ▁) ▁{ ▁run end ▁= ▁runs ▁+ ▁run size ▁; ▁if ▁( ▁compr ▁== ▁TIFF _ G 4 ▁) ▁{ ▁ret ▁= ▁decode _ group 3_2 d _ line ▁( ▁avctx ▁, ▁& ▁gb ▁, ▁avctx ▁-> ▁width ▁, ▁runs ▁, ▁run end ▁, ▁ref ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁err ▁= ▁-1 ▁; ▁goto ▁fail ▁; ▁} ▁} ▁else ▁{ ▁int ▁g 3 d 1 ▁= ▁( ▁compr ▁== ▁TIFF _ G 3 ▁) ▁&& ▁! ▁( ▁opts ▁& ▁1 ▁) ▁; ▁if ▁( ▁compr ▁!= ▁TIFF _ CC ITT _ R LE ▁&& ▁find _ group 3_ sync marker ▁( ▁& ▁gb ▁, ▁src size ▁* ▁8 ▁) ▁< ▁0 ▁) ▁break ▁; ▁if ▁( ▁compr ▁== ▁TIFF _ CC ITT _ R LE ▁|| ▁g 3 d 1 ▁|| ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁) ▁ret ▁= ▁decode _ group 3_ 1 d _ line ▁( ▁avctx ▁, ▁& ▁gb ▁, ▁avctx ▁-> ▁width ▁, ▁runs ▁, ▁run end ▁) ▁; ▁else ▁ret ▁= ▁decode _ group 3_2 d _ line ▁( ▁avctx ▁, ▁& ▁gb ▁, ▁avctx ▁-> ▁width ▁, ▁runs ▁, ▁run end ▁, ▁ref ▁) ▁; ▁if ▁( ▁compr ▁== ▁TIFF _ CC ITT _ R LE ▁) ▁align _ get _ bits ▁( ▁& ▁gb ▁) ▁; ▁} ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁put _ line ▁( ▁dst ▁, ▁stride ▁, ▁avctx ▁-> ▁width ▁, ▁ref ▁) ▁; ▁} ▁else ▁{ ▁put _ line ▁( ▁dst ▁, ▁stride ▁, ▁avctx ▁-> ▁width ▁, ▁runs ▁) ▁; ▁F FS W AP ▁( ▁int ▁* ▁, ▁runs ▁, ▁ref ▁) ▁; ▁} ▁dst ▁+= ▁stride ▁; ▁} ▁fail ▁: ▁av _ free ▁( ▁runs ▁) ▁; ▁av _ free ▁( ▁ref ▁) ▁; ▁return ▁err ▁; ▁}	0
▁static ▁int ▁mem _ write ▁( ▁BIO ▁* ▁b ▁, ▁const ▁char ▁* ▁in ▁, ▁int ▁inl ▁) ▁{ ▁int ▁ret ▁= ▁-1 ▁; ▁int ▁blen ▁; ▁BIO _ BUF _ MEM ▁* ▁bbm ▁= ▁( ▁BIO _ BUF _ MEM ▁* ▁) ▁b ▁-> ▁ptr ▁; ▁if ▁( ▁in ▁== ▁NULL ▁) ▁{ ▁BIO err ▁( ▁BIO _ F _ MEM _ WRITE ▁, ▁BIO _ R _ NULL _ PARAMETER ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁b ▁-> ▁flags ▁& ▁BIO _ FLAGS _ MEM _ RDONLY ▁) ▁{ ▁BIO err ▁( ▁BIO _ F _ MEM _ WRITE ▁, ▁BIO _ R _ WRITE _ TO _ READ _ ONLY _ BIO ▁) ▁; ▁goto ▁end ▁; ▁} ▁BIO _ clear _ retry _ flags ▁( ▁b ▁) ▁; ▁blen ▁= ▁bbm ▁-> ▁read p ▁-> ▁length ▁; ▁mem _ buf _ sync ▁( ▁b ▁) ▁; ▁if ▁( ▁BUF _ MEM _ grow _ clean ▁( ▁bbm ▁-> ▁buf ▁, ▁blen ▁+ ▁inl ▁) ▁== ▁0 ▁) ▁goto ▁end ▁; ▁memcpy ▁( ▁bbm ▁-> ▁buf ▁-> ▁data ▁+ ▁blen ▁, ▁in ▁, ▁inl ▁) ▁; ▁* ▁bbm ▁-> ▁read p ▁= ▁* ▁bbm ▁-> ▁buf ▁; ▁ret ▁= ▁inl ▁; ▁end ▁: ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁const ▁char ▁* ▁log _ cookie ▁( ▁request _ rec ▁* ▁r ▁, ▁char ▁* ▁a ▁) ▁{ ▁const ▁char ▁* ▁cookies _ entry ▁; ▁if ▁( ▁( ▁cookies _ entry ▁= ▁apr _ table _ get ▁( ▁r ▁-> ▁headers _ in ▁, ▁" Cookie " ▁) ▁) ▁) ▁{ ▁char ▁* ▁cookie ▁, ▁* ▁last 1 ▁, ▁* ▁last 2 ▁; ▁char ▁* ▁cookies ▁= ▁apr _ p strdup ▁( ▁r ▁-> ▁pool ▁, ▁cookies _ entry ▁) ▁; ▁while ▁( ▁( ▁cookie ▁= ▁apr _ strto k ▁( ▁cookies ▁, ▁";" ▁, ▁& ▁last 1 ▁) ▁) ▁) ▁{ ▁char ▁* ▁name ▁= ▁apr _ strto k ▁( ▁cookie ▁, ▁"=" ▁, ▁& ▁last 2 ▁) ▁; ▁char ▁* ▁value ▁= ▁last 2 ▁; ▁if ▁( ▁name ▁&& ▁* ▁name ▁&& ▁value ▁&& ▁* ▁value ▁) ▁{ ▁char ▁* ▁last ▁= ▁value ▁- ▁2 ▁; ▁name ▁+= ▁str spn ▁( ▁name ▁, ▁"\ t " ▁) ▁; ▁while ▁( ▁last ▁>= ▁name ▁&& ▁apr _ isspace ▁( ▁* ▁last ▁) ▁) ▁{ ▁* ▁last ▁= ▁' ▁\0 ▁' ▁; ▁-- ▁last ▁; ▁} ▁if ▁( ▁! ▁strcasecmp ▁( ▁name ▁, ▁a ▁) ▁) ▁{ ▁last ▁= ▁last 1 ▁- ▁( ▁* ▁last 1 ▁? ▁2 ▁: ▁1 ▁) ▁; ▁value ▁+= ▁str spn ▁( ▁value ▁, ▁"\ t " ▁) ▁; ▁while ▁( ▁last ▁>= ▁value ▁&& ▁apr _ isspace ▁( ▁* ▁last ▁) ▁) ▁{ ▁* ▁last ▁= ▁' ▁\0 ▁' ▁; ▁-- ▁last ▁; ▁} ▁return ▁ap _ escape _ log item ▁( ▁r ▁-> ▁pool ▁, ▁value ▁) ▁; ▁} ▁} ▁cookies ▁= ▁NULL ▁; ▁} ▁} ▁return ▁NULL ▁; ▁}	0
▁int ▁av _ grow _ packet ▁( ▁AVPacket ▁* ▁pkt ▁, ▁int ▁grow _ by ▁) ▁{ ▁int ▁new _ size ▁; ▁av _ assert 0 ▁( ▁( ▁unsigned ▁) ▁pkt ▁-> ▁size ▁<= ▁INT _ MAX ▁- ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁grow _ by ▁> ▁INT _ MAX ▁- ▁( ▁pkt ▁-> ▁size ▁+ ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁) ▁return ▁-1 ▁; ▁new _ size ▁= ▁pkt ▁-> ▁size ▁+ ▁grow _ by ▁+ ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁; ▁if ▁( ▁pkt ▁-> ▁buf ▁) ▁{ ▁size _ t ▁data _ offset ▁; ▁uint 8_ t ▁* ▁old _ data ▁= ▁pkt ▁-> ▁data ▁; ▁if ▁( ▁pkt ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁data _ offset ▁= ▁0 ▁; ▁pkt ▁-> ▁data ▁= ▁pkt ▁-> ▁buf ▁-> ▁data ▁; ▁} ▁else ▁{ ▁data _ offset ▁= ▁pkt ▁-> ▁data ▁- ▁pkt ▁-> ▁buf ▁-> ▁data ▁; ▁if ▁( ▁data _ offset ▁> ▁INT _ MAX ▁- ▁new _ size ▁) ▁return ▁-1 ▁; ▁} ▁if ▁( ▁new _ size ▁+ ▁data _ offset ▁> ▁pkt ▁-> ▁buf ▁-> ▁size ▁) ▁{ ▁int ▁ret ▁= ▁av _ buffer _ realloc ▁( ▁& ▁pkt ▁-> ▁buf ▁, ▁new _ size ▁+ ▁data _ offset ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁pkt ▁-> ▁data ▁= ▁old _ data ▁; ▁return ▁ret ▁; ▁} ▁pkt ▁-> ▁data ▁= ▁pkt ▁-> ▁buf ▁-> ▁data ▁+ ▁data _ offset ▁; ▁} ▁} ▁else ▁{ ▁pkt ▁-> ▁buf ▁= ▁av _ buffer _ alloc ▁( ▁new _ size ▁) ▁; ▁if ▁( ▁! ▁pkt ▁-> ▁buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁pkt ▁-> ▁size ▁> ▁0 ▁) ▁memcpy ▁( ▁pkt ▁-> ▁buf ▁-> ▁data ▁, ▁pkt ▁-> ▁data ▁, ▁pkt ▁-> ▁size ▁) ▁; ▁pkt ▁-> ▁data ▁= ▁pkt ▁-> ▁buf ▁-> ▁data ▁; ▁} ▁pkt ▁-> ▁size ▁+= ▁grow _ by ▁; ▁memset ▁( ▁pkt ▁-> ▁data ▁+ ▁pkt ▁-> ▁size ▁, ▁0 ▁, ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁do _ dt ls 1_ write ▁( ▁SSL ▁* ▁s ▁, ▁int ▁type ▁, ▁const ▁unsigned ▁char ▁* ▁buf ▁, ▁unsigned ▁int ▁len ▁, ▁int ▁create _ empty _ fragment ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁, ▁* ▁p seq ▁; ▁int ▁i ▁, ▁mac _ size ▁, ▁clear ▁= ▁0 ▁; ▁int ▁prefix _ len ▁= ▁0 ▁; ▁SSL 3_ RECORD ▁* ▁wr ▁; ▁SSL 3_ BUFFER ▁* ▁wb ▁; ▁SSL _ SESSION ▁* ▁sess ▁; ▁int ▁bs ▁; ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁wbuf ▁. ▁left ▁!= ▁0 ▁) ▁{ ▁OPENSSL _ assert ▁( ▁0 ▁) ▁; ▁return ▁( ▁ssl 3_ write _ pending ▁( ▁s ▁, ▁type ▁, ▁buf ▁, ▁len ▁) ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁alert _ dispatch ▁) ▁{ ▁i ▁= ▁s ▁-> ▁method ▁-> ▁ssl _ dispatch _ alert ▁( ▁s ▁) ▁; ▁if ▁( ▁i ▁<= ▁0 ▁) ▁return ▁( ▁i ▁) ▁; ▁} ▁if ▁( ▁len ▁== ▁0 ▁&& ▁! ▁create _ empty _ fragment ▁) ▁return ▁0 ▁; ▁wr ▁= ▁& ▁( ▁s ▁-> ▁s 3 ▁-> ▁w rec ▁) ▁; ▁wb ▁= ▁& ▁( ▁s ▁-> ▁s 3 ▁-> ▁wbuf ▁) ▁; ▁sess ▁= ▁s ▁-> ▁session ▁; ▁if ▁( ▁( ▁sess ▁== ▁NULL ▁) ▁|| ▁( ▁s ▁-> ▁enc _ write _ ctx ▁== ▁NULL ▁) ▁|| ▁( ▁EVP _ MD _ CTX _ md ▁( ▁s ▁-> ▁write _ hash ▁) ▁== ▁NULL ▁) ▁) ▁clear ▁= ▁1 ▁; ▁if ▁( ▁clear ▁) ▁mac _ size ▁= ▁0 ▁; ▁else ▁mac _ size ▁= ▁EVP _ MD _ CTX _ size ▁( ▁s ▁-> ▁write _ hash ▁) ▁; ▁# if ▁0 ▁if ▁( ▁! ▁clear ▁&& ▁! ▁create _ empty _ fragment ▁&& ▁! ▁s ▁-> ▁s 3 ▁-> ▁empty _ fragment _ done ▁&& ▁SSL _ version ▁( ▁s ▁) ▁!= ▁DTLS 1_ VERSION ▁) ▁{ ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁need _ empty _ frag ments ▁&& ▁type ▁== ▁SSL 3_ RT _ APPLICATION _ DATA ▁) ▁{ ▁prefix _ len ▁= ▁s ▁-> ▁method ▁-> ▁do _ ssl _ write ▁( ▁s ▁, ▁type ▁, ▁buf ▁, ▁0 ▁, ▁1 ▁) ▁; ▁if ▁( ▁prefix _ len ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁wbuf ▁. ▁len ▁< ▁( ▁size _ t ▁) ▁prefix _ len ▁+ ▁SSL 3_ RT _ MAX _ PACKET _ SIZE ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ DO _ DT LS 1_ WRITE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁s ▁-> ▁s 3 ▁-> ▁empty _ fragment _ done ▁= ▁1 ▁; ▁} ▁# endif ▁p ▁= ▁wb ▁-> ▁buf ▁+ ▁prefix _ len ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁type ▁& ▁0 xff ▁; ▁wr ▁-> ▁type ▁= ▁type ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁( ▁s ▁-> ▁version ▁>> ▁8 ▁) ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁s ▁-> ▁version ▁& ▁0 xff ▁; ▁p seq ▁= ▁p ▁; ▁p ▁+= ▁10 ▁; ▁if ▁( ▁s ▁-> ▁enc _ write _ ctx ▁&& ▁( ▁EVP _ CIPHER _ mode ▁( ▁s ▁-> ▁enc _ write _ ctx ▁-> ▁cipher ▁) ▁& ▁EVP _ C IPH _ CBC _ MODE ▁) ▁) ▁bs ▁= ▁EVP _ CIPHER _ block _ size ▁( ▁s ▁-> ▁enc _ write _ ctx ▁-> ▁cipher ▁) ▁; ▁else ▁bs ▁= ▁0 ▁; ▁wr ▁-> ▁data ▁= ▁p ▁+ ▁bs ▁; ▁wr ▁-> ▁length ▁= ▁( ▁int ▁) ▁len ▁; ▁wr ▁-> ▁input ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁buf ▁; ▁if ▁( ▁s ▁-> ▁compress ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁ssl 3_ do _ compress ▁( ▁s ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ DO _ DT LS 1_ WRITE ▁, ▁SSL _ R _ COMPRESSION _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁else ▁{ ▁memcpy ▁( ▁wr ▁-> ▁data ▁, ▁wr ▁-> ▁input ▁, ▁wr ▁-> ▁length ▁) ▁; ▁wr ▁-> ▁input ▁= ▁wr ▁-> ▁data ▁; ▁} ▁if ▁( ▁mac _ size ▁!= ▁0 ▁) ▁{ ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁mac ▁( ▁s ▁, ▁& ▁( ▁p ▁[ ▁wr ▁-> ▁length ▁+ ▁bs ▁] ▁) ▁, ▁1 ▁) ▁; ▁wr ▁-> ▁length ▁+= ▁mac _ size ▁; ▁} ▁wr ▁-> ▁input ▁= ▁p ▁; ▁wr ▁-> ▁data ▁= ▁p ▁; ▁wr ▁-> ▁length ▁+= ▁bs ▁; ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁enc ▁( ▁s ▁, ▁1 ▁) ▁; ▁s 2 n ▁( ▁s ▁-> ▁d 1 ▁-> ▁w _ epoch ▁, ▁p seq ▁) ▁; ▁memcpy ▁( ▁p seq ▁, ▁& ▁( ▁s ▁-> ▁s 3 ▁-> ▁write _ sequence ▁[ ▁2 ▁] ▁) ▁, ▁6 ▁) ▁; ▁p seq ▁+= ▁6 ▁; ▁s 2 n ▁( ▁wr ▁-> ▁length ▁, ▁p seq ▁) ▁; ▁wr ▁-> ▁type ▁= ▁type ▁; ▁wr ▁-> ▁length ▁+= ▁DTLS 1_ RT _ HEADER _ LENGTH ▁; ▁# if ▁0 ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁|| ▁type ▁== ▁SSL 3_ RT _ CHANGE _ CIPHER _ SPEC ▁) ▁dt ls 1_ buffer _ record ▁( ▁s ▁, ▁wr ▁-> ▁data ▁, ▁wr ▁-> ▁length ▁, ▁* ▁( ▁( ▁PQ _64 BIT ▁* ▁) ▁& ▁( ▁s ▁-> ▁s 3 ▁-> ▁write _ sequence ▁[ ▁0 ▁] ▁) ▁) ▁) ▁; ▁# endif ▁ssl 3_ record _ sequence _ update ▁( ▁& ▁( ▁s ▁-> ▁s 3 ▁-> ▁write _ sequence ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁create _ empty _ fragment ▁) ▁{ ▁return ▁wr ▁-> ▁length ▁; ▁} ▁wb ▁-> ▁left ▁= ▁prefix _ len ▁+ ▁wr ▁-> ▁length ▁; ▁wb ▁-> ▁offset ▁= ▁0 ▁; ▁s ▁-> ▁s 3 ▁-> ▁w pend _ tot ▁= ▁len ▁; ▁s ▁-> ▁s 3 ▁-> ▁w pend _ buf ▁= ▁buf ▁; ▁s ▁-> ▁s 3 ▁-> ▁w pend _ type ▁= ▁type ▁; ▁s ▁-> ▁s 3 ▁-> ▁w pend _ ret ▁= ▁len ▁; ▁return ▁ssl 3_ write _ pending ▁( ▁s ▁, ▁type ▁, ▁buf ▁, ▁len ▁) ▁; ▁err ▁: ▁return ▁-1 ▁; ▁}	1
▁static ▁void ▁fill _ buffer ▁( ▁Byte IO Context ▁* ▁s ▁) ▁{ ▁int ▁len ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁eof _ reached ▁) ▁return ▁; ▁if ▁( ▁s ▁-> ▁update _ checksum ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ end ▁> ▁s ▁-> ▁checksum _ ptr ▁) ▁s ▁-> ▁checksum ▁= ▁s ▁-> ▁update _ checksum ▁( ▁s ▁-> ▁checksum ▁, ▁s ▁-> ▁checksum _ ptr ▁, ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁checksum _ ptr ▁) ▁; ▁s ▁-> ▁checksum _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁if ▁( ▁s ▁-> ▁read _ packet ▁) ▁len ▁= ▁s ▁-> ▁read _ packet ▁( ▁s ▁-> ▁opaque ▁, ▁s ▁-> ▁buffer ▁, ▁s ▁-> ▁buffer _ size ▁) ▁; ▁if ▁( ▁len ▁<= ▁0 ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁s ▁-> ▁error ▁= ▁len ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pos ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁s ▁-> ▁buf _ end ▁= ▁s ▁-> ▁buffer ▁+ ▁len ▁; ▁} ▁}	1
▁static ▁void ▁FUNC ▁( ▁trans quant _ bypass 4 x 4 ▁) ▁( ▁uint 8_ t ▁* ▁_ dst ▁, ▁int 16_ t ▁* ▁coeffs ▁, ▁ptrdiff _ t ▁stride ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁pixel ▁* ▁dst ▁= ▁( ▁pixel ▁* ▁) ▁_ dst ▁; ▁stride ▁/= ▁sizeof ▁( ▁pixel ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁4 ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁4 ▁; ▁x ▁++ ▁) ▁{ ▁dst ▁[ ▁x ▁] ▁= ▁av _ clip _ pixel ▁( ▁dst ▁[ ▁x ▁] ▁+ ▁* ▁coeffs ▁) ▁; ▁coeffs ▁++ ▁; ▁} ▁dst ▁+= ▁stride ▁; ▁} ▁}	0
▁static ▁int ▁encode _ rgb _ frame ▁( ▁FF V 1 Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁src ▁[ ▁3 ▁] ▁, ▁int ▁w ▁, ▁int ▁h ▁, ▁int ▁stride ▁[ ▁3 ▁] ▁) ▁{ ▁int ▁x ▁, ▁y ▁, ▁p ▁, ▁i ▁; ▁const ▁int ▁ring _ size ▁= ▁s ▁-> ▁avctx ▁-> ▁context _ model ▁? ▁3 ▁: ▁2 ▁; ▁int 16_ t ▁* ▁sample ▁[ ▁4 ▁] ▁[ ▁3 ▁] ▁; ▁int ▁l bd ▁= ▁s ▁-> ▁bits _ per _ raw _ sample ▁<= ▁8 ▁; ▁int ▁bits ▁= ▁s ▁-> ▁bits _ per _ raw _ sample ▁> ▁0 ▁? ▁s ▁-> ▁bits _ per _ raw _ sample ▁: ▁8 ▁; ▁int ▁offset ▁= ▁1 ▁<< ▁bits ▁; ▁s ▁-> ▁run _ index ▁= ▁0 ▁; ▁memset ▁( ▁s ▁-> ▁sample _ buffer ▁, ▁0 ▁, ▁ring _ size ▁* ▁MAX _ PLAN ES ▁* ▁( ▁w ▁+ ▁6 ▁) ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁sample _ buffer ▁) ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁h ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ring _ size ▁; ▁i ▁++ ▁) ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁MAX _ PLAN ES ▁; ▁p ▁++ ▁) ▁sample ▁[ ▁p ▁] ▁[ ▁i ▁] ▁= ▁s ▁-> ▁sample _ buffer ▁+ ▁p ▁* ▁ring _ size ▁* ▁( ▁w ▁+ ▁6 ▁) ▁+ ▁( ▁( ▁h ▁+ ▁i ▁- ▁y ▁) ▁% ▁ring _ size ▁) ▁* ▁( ▁w ▁+ ▁6 ▁) ▁+ ▁3 ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁w ▁; ▁x ▁++ ▁) ▁{ ▁int ▁b ▁, ▁g ▁, ▁r ▁, ▁av _ uninit ▁( ▁a ▁) ▁; ▁if ▁( ▁l bd ▁) ▁{ ▁unsigned ▁v ▁= ▁* ▁( ▁( ▁uint 32_ t ▁* ▁) ▁( ▁src ▁[ ▁0 ▁] ▁+ ▁x ▁* ▁4 ▁+ ▁stride ▁[ ▁0 ▁] ▁* ▁y ▁) ▁) ▁; ▁b ▁= ▁v ▁& ▁0 xFF ▁; ▁g ▁= ▁( ▁v ▁>> ▁8 ▁) ▁& ▁0 xFF ▁; ▁r ▁= ▁( ▁v ▁>> ▁16 ▁) ▁& ▁0 xFF ▁; ▁a ▁= ▁v ▁>> ▁24 ▁; ▁} ▁else ▁{ ▁b ▁= ▁* ▁( ▁( ▁uint 16_ t ▁* ▁) ▁( ▁src ▁[ ▁0 ▁] ▁+ ▁x ▁* ▁2 ▁+ ▁stride ▁[ ▁0 ▁] ▁* ▁y ▁) ▁) ▁; ▁g ▁= ▁* ▁( ▁( ▁uint 16_ t ▁* ▁) ▁( ▁src ▁[ ▁1 ▁] ▁+ ▁x ▁* ▁2 ▁+ ▁stride ▁[ ▁1 ▁] ▁* ▁y ▁) ▁) ▁; ▁r ▁= ▁* ▁( ▁( ▁uint 16_ t ▁* ▁) ▁( ▁src ▁[ ▁2 ▁] ▁+ ▁x ▁* ▁2 ▁+ ▁stride ▁[ ▁2 ▁] ▁* ▁y ▁) ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁slice _ coding _ mode ▁!= ▁1 ▁) ▁{ ▁b ▁-= ▁g ▁; ▁r ▁-= ▁g ▁; ▁g ▁+= ▁( ▁b ▁+ ▁r ▁) ▁>> ▁2 ▁; ▁b ▁+= ▁offset ▁; ▁r ▁+= ▁offset ▁; ▁} ▁sample ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁x ▁] ▁= ▁g ▁; ▁sample ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁x ▁] ▁= ▁b ▁; ▁sample ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁[ ▁x ▁] ▁= ▁r ▁; ▁sample ▁[ ▁3 ▁] ▁[ ▁0 ▁] ▁[ ▁x ▁] ▁= ▁a ▁; ▁} ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁3 ▁+ ▁s ▁-> ▁transparency ▁; ▁p ▁++ ▁) ▁{ ▁int ▁ret ▁; ▁sample ▁[ ▁p ▁] ▁[ ▁0 ▁] ▁[ ▁-1 ▁] ▁= ▁sample ▁[ ▁p ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁sample ▁[ ▁p ▁] ▁[ ▁1 ▁] ▁[ ▁w ▁] ▁= ▁sample ▁[ ▁p ▁] ▁[ ▁1 ▁] ▁[ ▁w ▁- ▁1 ▁] ▁; ▁if ▁( ▁l bd ▁&& ▁s ▁-> ▁slice _ coding _ mode ▁== ▁0 ▁) ▁ret ▁= ▁encode _ line ▁( ▁s ▁, ▁w ▁, ▁sample ▁[ ▁p ▁] ▁, ▁( ▁p ▁+ ▁1 ▁) ▁/ ▁2 ▁, ▁9 ▁) ▁; ▁else ▁ret ▁= ▁encode _ line ▁( ▁s ▁, ▁w ▁, ▁sample ▁[ ▁p ▁] ▁, ▁( ▁p ▁+ ▁1 ▁) ▁/ ▁2 ▁, ▁bits ▁+ ▁( ▁s ▁-> ▁slice _ coding _ mode ▁!= ▁1 ▁) ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁vc 1_ loop _ filter _ ib lk ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁int ▁pq ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁if ▁( ▁! ▁s ▁-> ▁first _ slice _ line ▁) ▁s ▁-> ▁dsp ▁. ▁vc 1_ loop _ filter ▁( ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁, ▁1 ▁, ▁s ▁-> ▁linesize ▁, ▁16 ▁, ▁pq ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁vc 1_ loop _ filter ▁( ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁+ ▁8 ▁* ▁s ▁-> ▁linesize ▁, ▁1 ▁, ▁s ▁-> ▁linesize ▁, ▁16 ▁, ▁pq ▁) ▁; ▁for ▁( ▁i ▁= ▁! ▁s ▁-> ▁mb _ x ▁* ▁8 ▁; ▁i ▁< ▁16 ▁; ▁i ▁+= ▁8 ▁) ▁s ▁-> ▁dsp ▁. ▁vc 1_ loop _ filter ▁( ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁+ ▁i ▁, ▁s ▁-> ▁linesize ▁, ▁1 ▁, ▁16 ▁, ▁pq ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁first _ slice _ line ▁) ▁s ▁-> ▁dsp ▁. ▁vc 1_ loop _ filter ▁( ▁s ▁-> ▁dest ▁[ ▁j ▁+ ▁1 ▁] ▁, ▁1 ▁, ▁s ▁-> ▁uv lines ize ▁, ▁8 ▁, ▁pq ▁) ▁; ▁if ▁( ▁s ▁-> ▁mb _ x ▁) ▁s ▁-> ▁dsp ▁. ▁vc 1_ loop _ filter ▁( ▁s ▁-> ▁dest ▁[ ▁j ▁+ ▁1 ▁] ▁, ▁s ▁-> ▁uv lines ize ▁, ▁1 ▁, ▁8 ▁, ▁pq ▁) ▁; ▁} ▁}	0
▁static ▁av _ noinline ▁void ▁FUNC ▁( ▁hl _ decode _ mb _ 444 ▁) ▁( ▁const ▁H 264 Context ▁* ▁h ▁, ▁H 264 Slice Context ▁* ▁sl ▁) ▁{ ▁const ▁int ▁mb _ x ▁= ▁sl ▁-> ▁mb _ x ▁; ▁const ▁int ▁mb _ y ▁= ▁sl ▁-> ▁mb _ y ▁; ▁const ▁int ▁mb _ xy ▁= ▁sl ▁-> ▁mb _ xy ▁; ▁const ▁int ▁mb _ type ▁= ▁h ▁-> ▁cur _ pic ▁. ▁mb _ type ▁[ ▁mb _ xy ▁] ▁; ▁uint 8_ t ▁* ▁dest ▁[ ▁3 ▁] ▁; ▁int ▁linesize ▁; ▁int ▁i ▁, ▁j ▁, ▁p ▁; ▁const ▁int ▁* ▁block _ offset ▁= ▁& ▁h ▁-> ▁block _ offset ▁[ ▁0 ▁] ▁; ▁const ▁int ▁transform _ bypass ▁= ▁! ▁SIMPLE ▁&& ▁( ▁sl ▁-> ▁q scale ▁== ▁0 ▁&& ▁h ▁-> ▁ps ▁. ▁sps ▁-> ▁transform _ bypass ▁) ▁; ▁const ▁int ▁plane _ count ▁= ▁( ▁SIMPLE ▁|| ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁h ▁-> ▁flags ▁& ▁AV _ CODEC _ FLAG _ GRAY ▁) ▁) ▁? ▁3 ▁: ▁1 ▁; ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁plane _ count ▁; ▁p ▁++ ▁) ▁{ ▁dest ▁[ ▁p ▁] ▁= ▁h ▁-> ▁cur _ pic ▁. ▁f ▁-> ▁data ▁[ ▁p ▁] ▁+ ▁( ▁( ▁mb _ x ▁<< ▁PIXEL _ SHIFT ▁) ▁+ ▁mb _ y ▁* ▁sl ▁-> ▁linesize ▁) ▁* ▁16 ▁; ▁h ▁-> ▁v dsp ▁. ▁prefetch ▁( ▁dest ▁[ ▁p ▁] ▁+ ▁( ▁sl ▁-> ▁mb _ x ▁& ▁3 ▁) ▁* ▁4 ▁* ▁sl ▁-> ▁linesize ▁+ ▁( ▁64 ▁<< ▁PIXEL _ SHIFT ▁) ▁, ▁sl ▁-> ▁linesize ▁, ▁4 ▁) ▁; ▁} ▁h ▁-> ▁list _ counts ▁[ ▁mb _ xy ▁] ▁= ▁sl ▁-> ▁list _ count ▁; ▁if ▁( ▁! ▁SIMPLE ▁&& ▁MB _ FIELD ▁( ▁sl ▁) ▁) ▁{ ▁linesize ▁= ▁sl ▁-> ▁mb _ lines ize ▁= ▁sl ▁-> ▁mb _ uv lines ize ▁= ▁sl ▁-> ▁linesize ▁* ▁2 ▁; ▁block _ offset ▁= ▁& ▁h ▁-> ▁block _ offset ▁[ ▁48 ▁] ▁; ▁if ▁( ▁mb _ y ▁& ▁1 ▁) ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁3 ▁; ▁p ▁++ ▁) ▁dest ▁[ ▁p ▁] ▁-= ▁sl ▁-> ▁linesize ▁* ▁15 ▁; ▁if ▁( ▁FRAME _ MB AFF ▁( ▁h ▁) ▁) ▁{ ▁int ▁list ▁; ▁for ▁( ▁list ▁= ▁0 ▁; ▁list ▁< ▁sl ▁-> ▁list _ count ▁; ▁list ▁++ ▁) ▁{ ▁if ▁( ▁! ▁US ES _ LIST ▁( ▁mb _ type ▁, ▁list ▁) ▁) ▁continue ▁; ▁if ▁( ▁IS _16 X 16 ▁( ▁mb _ type ▁) ▁) ▁{ ▁int 8_ t ▁* ▁ref ▁= ▁& ▁sl ▁-> ▁ref _ cache ▁[ ▁list ▁] ▁[ ▁scan 8 ▁[ ▁0 ▁] ▁] ▁; ▁fill _ rectangle ▁( ▁ref ▁, ▁4 ▁, ▁4 ▁, ▁8 ▁, ▁( ▁16 ▁+ ▁* ▁ref ▁) ▁ ^ ▁( ▁sl ▁-> ▁mb _ y ▁& ▁1 ▁) ▁, ▁1 ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁i ▁+= ▁4 ▁) ▁{ ▁int ▁ref ▁= ▁sl ▁-> ▁ref _ cache ▁[ ▁list ▁] ▁[ ▁scan 8 ▁[ ▁i ▁] ▁] ▁; ▁if ▁( ▁ref ▁>= ▁0 ▁) ▁fill _ rectangle ▁( ▁& ▁sl ▁-> ▁ref _ cache ▁[ ▁list ▁] ▁[ ▁scan 8 ▁[ ▁i ▁] ▁] ▁, ▁2 ▁, ▁2 ▁, ▁8 ▁, ▁( ▁16 ▁+ ▁ref ▁) ▁ ^ ▁( ▁sl ▁-> ▁mb _ y ▁& ▁1 ▁) ▁, ▁1 ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁else ▁{ ▁linesize ▁= ▁sl ▁-> ▁mb _ lines ize ▁= ▁sl ▁-> ▁mb _ uv lines ize ▁= ▁sl ▁-> ▁linesize ▁; ▁} ▁if ▁( ▁! ▁SIMPLE ▁&& ▁IS _ INTR A _ PCM ▁( ▁mb _ type ▁) ▁) ▁{ ▁if ▁( ▁PIXEL _ SHIFT ▁) ▁{ ▁const ▁int ▁bit _ depth ▁= ▁h ▁-> ▁ps ▁. ▁sps ▁-> ▁bit _ depth _ l uma ▁; ▁Get Bit Context ▁gb ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁in tra _ pcm _ ptr ▁, ▁768 ▁* ▁bit _ depth ▁) ▁; ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁plane _ count ▁; ▁p ▁++ ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁i ▁++ ▁) ▁{ ▁uint 16_ t ▁* ▁tmp ▁= ▁( ▁uint 16_ t ▁* ▁) ▁( ▁dest ▁[ ▁p ▁] ▁+ ▁i ▁* ▁linesize ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁tmp ▁[ ▁j ▁] ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁bit _ depth ▁) ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁plane _ count ▁; ▁p ▁++ ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁i ▁++ ▁) ▁memcpy ▁( ▁dest ▁[ ▁p ▁] ▁+ ▁i ▁* ▁linesize ▁, ▁sl ▁-> ▁in tra _ pcm _ ptr ▁+ ▁p ▁* ▁256 ▁+ ▁i ▁* ▁16 ▁, ▁16 ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁IS _ INTR A ▁( ▁mb _ type ▁) ▁) ▁{ ▁if ▁( ▁sl ▁-> ▁de blocking _ filter ▁) ▁x chg _ mb _ border ▁( ▁h ▁, ▁sl ▁, ▁dest ▁[ ▁0 ▁] ▁, ▁dest ▁[ ▁1 ▁] ▁, ▁dest ▁[ ▁2 ▁] ▁, ▁linesize ▁, ▁linesize ▁, ▁1 ▁, ▁1 ▁, ▁SIMPLE ▁, ▁PIXEL _ SHIFT ▁) ▁; ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁plane _ count ▁; ▁p ▁++ ▁) ▁hl _ decode _ mb _ predict _ l uma ▁( ▁h ▁, ▁sl ▁, ▁mb _ type ▁, ▁SIMPLE ▁, ▁transform _ bypass ▁, ▁PIXEL _ SHIFT ▁, ▁block _ offset ▁, ▁linesize ▁, ▁dest ▁[ ▁p ▁] ▁, ▁p ▁) ▁; ▁if ▁( ▁sl ▁-> ▁de blocking _ filter ▁) ▁x chg _ mb _ border ▁( ▁h ▁, ▁sl ▁, ▁dest ▁[ ▁0 ▁] ▁, ▁dest ▁[ ▁1 ▁] ▁, ▁dest ▁[ ▁2 ▁] ▁, ▁linesize ▁, ▁linesize ▁, ▁0 ▁, ▁1 ▁, ▁SIMPLE ▁, ▁PIXEL _ SHIFT ▁) ▁; ▁} ▁else ▁{ ▁FUNC ▁( ▁hl _ motion _ 444 ▁) ▁( ▁h ▁, ▁sl ▁, ▁dest ▁[ ▁0 ▁] ▁, ▁dest ▁[ ▁1 ▁] ▁, ▁dest ▁[ ▁2 ▁] ▁, ▁h ▁-> ▁q pel _ put ▁, ▁h ▁-> ▁h 264 chroma ▁. ▁put _ h 264_ chroma _ pixels _ tab ▁, ▁h ▁-> ▁q pel _ avg ▁, ▁h ▁-> ▁h 264 chroma ▁. ▁avg _ h 264_ chroma _ pixels _ tab ▁, ▁h ▁-> ▁h 264 dsp ▁. ▁weight _ h 264_ pixels _ tab ▁, ▁h ▁-> ▁h 264 dsp ▁. ▁bi weight _ h 264_ pixels _ tab ▁) ▁; ▁} ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁plane _ count ▁; ▁p ▁++ ▁) ▁hl _ decode _ mb _ idct _ l uma ▁( ▁h ▁, ▁sl ▁, ▁mb _ type ▁, ▁SIMPLE ▁, ▁transform _ bypass ▁, ▁PIXEL _ SHIFT ▁, ▁block _ offset ▁, ▁linesize ▁, ▁dest ▁[ ▁p ▁] ▁, ▁p ▁) ▁; ▁} ▁}	0
▁static ▁ngx _ int _ t ▁ngx _ http _ up stream _ cache ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ http _ up stream _ t ▁* ▁u ▁) ▁{ ▁ngx _ int _ t ▁rc ▁; ▁ngx _ http _ cache _ t ▁* ▁c ▁; ▁ngx _ http _ file _ cache _ t ▁* ▁cache ▁; ▁c ▁= ▁r ▁-> ▁cache ▁; ▁if ▁( ▁c ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁( ▁r ▁-> ▁method ▁& ▁u ▁-> ▁conf ▁-> ▁cache _ methods ▁) ▁) ▁{ ▁return ▁NGX _ DECL INED ▁; ▁} ▁rc ▁= ▁ngx _ http _ up stream _ cache _ get ▁( ▁r ▁, ▁u ▁, ▁& ▁cache ▁) ▁; ▁if ▁( ▁rc ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁rc ▁; ▁} ▁if ▁( ▁r ▁-> ▁method ▁& ▁NGX _ HTTP _ HEAD ▁) ▁{ ▁u ▁-> ▁method ▁= ▁ngx _ http _ core _ get _ method ▁; ▁} ▁if ▁( ▁ngx _ http _ file _ cache _ new ▁( ▁r ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁if ▁( ▁u ▁-> ▁create _ key ▁( ▁r ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁ngx _ http _ file _ cache _ create _ key ▁( ▁r ▁) ▁; ▁if ▁( ▁r ▁-> ▁cache ▁-> ▁header _ start ▁+ ▁256 ▁>= ▁u ▁-> ▁conf ▁-> ▁buffer _ size ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁"% V _ buffer _ size % uz is not en ough for cache key ," ▁" it should be in crease d to at least % uz " ▁, ▁& ▁u ▁-> ▁conf ▁-> ▁module ▁, ▁u ▁-> ▁conf ▁-> ▁buffer _ size ▁, ▁ngx _ align ▁( ▁r ▁-> ▁cache ▁-> ▁header _ start ▁+ ▁256 ▁, ▁1024 ▁) ▁) ▁; ▁r ▁-> ▁cache ▁= ▁NULL ▁; ▁return ▁NGX _ DECL INED ▁; ▁} ▁u ▁-> ▁cache able ▁= ▁1 ▁; ▁c ▁= ▁r ▁-> ▁cache ▁; ▁c ▁-> ▁body _ start ▁= ▁u ▁-> ▁conf ▁-> ▁buffer _ size ▁; ▁c ▁-> ▁min _ uses ▁= ▁u ▁-> ▁conf ▁-> ▁cache _ min _ uses ▁; ▁c ▁-> ▁file _ cache ▁= ▁cache ▁; ▁switch ▁( ▁ngx _ http _ test _ predicates ▁( ▁r ▁, ▁u ▁-> ▁conf ▁-> ▁cache _ bypass ▁) ▁) ▁{ ▁case ▁NGX _ ERROR ▁: ▁return ▁NGX _ ERROR ▁; ▁case ▁NGX _ DECL INED ▁: ▁u ▁-> ▁cache _ status ▁= ▁NGX _ HTTP _ CACHE _ BYPASS ▁; ▁return ▁NGX _ DECL INED ▁; ▁default ▁: ▁break ▁; ▁} ▁c ▁-> ▁lock ▁= ▁u ▁-> ▁conf ▁-> ▁cache _ lock ▁; ▁c ▁-> ▁lock _ timeout ▁= ▁u ▁-> ▁conf ▁-> ▁cache _ lock _ timeout ▁; ▁c ▁-> ▁lock _ age ▁= ▁u ▁-> ▁conf ▁-> ▁cache _ lock _ age ▁; ▁u ▁-> ▁cache _ status ▁= ▁NGX _ HTTP _ CACHE _ MISS ▁; ▁} ▁rc ▁= ▁ngx _ http _ file _ cache _ open ▁( ▁r ▁) ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" http up stream cache :% i " ▁, ▁rc ▁) ▁; ▁switch ▁( ▁rc ▁) ▁{ ▁case ▁NGX _ HTTP _ CACHE _ UPDAT ING ▁: ▁if ▁( ▁u ▁-> ▁conf ▁-> ▁cache _ use _ st ale ▁& ▁NGX _ HTTP _ UP STREAM _ FT _ UPDAT ING ▁) ▁{ ▁u ▁-> ▁cache _ status ▁= ▁rc ▁; ▁rc ▁= ▁NGX _ OK ▁; ▁} ▁else ▁{ ▁rc ▁= ▁NGX _ HTTP _ CACHE _ ST ALE ▁; ▁} ▁break ▁; ▁case ▁NGX _ OK ▁: ▁u ▁-> ▁cache _ status ▁= ▁NGX _ HTTP _ CACHE _ HIT ▁; ▁} ▁switch ▁( ▁rc ▁) ▁{ ▁case ▁NGX _ OK ▁: ▁return ▁NGX _ OK ▁; ▁case ▁NGX _ HTTP _ CACHE _ ST ALE ▁: ▁c ▁-> ▁valid _ sec ▁= ▁0 ▁; ▁u ▁-> ▁buffer ▁. ▁start ▁= ▁NULL ▁; ▁u ▁-> ▁cache _ status ▁= ▁NGX _ HTTP _ CACHE _ EXPIRED ▁; ▁break ▁; ▁case ▁NGX _ DECL INED ▁: ▁if ▁( ▁( ▁size _ t ▁) ▁( ▁u ▁-> ▁buffer ▁. ▁end ▁- ▁u ▁-> ▁buffer ▁. ▁start ▁) ▁< ▁u ▁-> ▁conf ▁-> ▁buffer _ size ▁) ▁{ ▁u ▁-> ▁buffer ▁. ▁start ▁= ▁NULL ▁; ▁} ▁else ▁{ ▁u ▁-> ▁buffer ▁. ▁pos ▁= ▁u ▁-> ▁buffer ▁. ▁start ▁+ ▁c ▁-> ▁header _ start ▁; ▁u ▁-> ▁buffer ▁. ▁last ▁= ▁u ▁-> ▁buffer ▁. ▁pos ▁; ▁} ▁break ▁; ▁case ▁NGX _ HTTP _ CACHE _ SC AR CE ▁: ▁u ▁-> ▁cache able ▁= ▁0 ▁; ▁break ▁; ▁case ▁NGX _ AGAIN ▁: ▁return ▁NGX _ BUSY ▁; ▁case ▁NGX _ ERROR ▁: ▁return ▁NGX _ ERROR ▁; ▁default ▁: ▁u ▁-> ▁cache _ status ▁= ▁NGX _ HTTP _ CACHE _ HIT ▁; ▁return ▁rc ▁; ▁} ▁r ▁-> ▁cached ▁= ▁0 ▁; ▁return ▁NGX _ DECL INED ▁; ▁}	0
▁int ▁tls _ collect _ extensions ▁( ▁SSL ▁* ▁s ▁, ▁PACKET ▁* ▁packet ▁, ▁unsigned ▁int ▁context ▁, ▁RAW _ EXTENSION ▁* ▁* ▁res ▁, ▁int ▁* ▁al ▁) ▁{ ▁PACKET ▁extensions ▁= ▁* ▁packet ▁; ▁size _ t ▁i ▁= ▁0 ▁, ▁idx ▁; ▁int ▁found ▁= ▁0 ▁; ▁custom _ ext _ methods ▁* ▁exts ▁= ▁NULL ▁; ▁RAW _ EXTENSION ▁* ▁raw _ extensions ▁= ▁NULL ▁; ▁if ▁( ▁( ▁context ▁& ▁EXT _ CLIENT _ HELLO ▁) ▁!= ▁0 ▁) ▁{ ▁exts ▁= ▁& ▁s ▁-> ▁cert ▁-> ▁srv _ ext ▁; ▁custom _ ext _ init ▁( ▁& ▁s ▁-> ▁cert ▁-> ▁srv _ ext ▁) ▁; ▁} ▁else ▁if ▁( ▁( ▁context ▁& ▁EXT _ TLS 1_ 2_ SERVER _ HELLO ▁) ▁!= ▁0 ▁) ▁{ ▁exts ▁= ▁& ▁s ▁-> ▁cert ▁-> ▁cli _ ext ▁; ▁} ▁raw _ extensions ▁= ▁OPENSSL _ zalloc ▁( ▁( ▁OSSL _ NE LEM ▁( ▁ext _ defs ▁) ▁+ ▁( ▁exts ▁!= ▁NULL ▁? ▁exts ▁-> ▁meth s _ count ▁: ▁0 ▁) ▁) ▁* ▁sizeof ▁( ▁RAW _ EXTENSION ▁) ▁) ▁; ▁if ▁( ▁raw _ extensions ▁== ▁NULL ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ COL LECT _ EXTENSIONS ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁while ▁( ▁PACKET _ remaining ▁( ▁& ▁extensions ▁) ▁> ▁0 ▁) ▁{ ▁unsigned ▁int ▁type ▁; ▁PACKET ▁extension ▁; ▁if ▁( ▁! ▁PACKET _ get _ net _2 ▁( ▁& ▁extensions ▁, ▁& ▁type ▁) ▁|| ▁! ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁& ▁extensions ▁, ▁& ▁extension ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ COL LECT _ EXTENSIONS ▁, ▁SSL _ R _ BAD _ EXTENSION ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁verify _ extension ▁( ▁s ▁, ▁context ▁, ▁type ▁, ▁exts ▁, ▁& ▁found ▁, ▁& ▁idx ▁) ▁|| ▁( ▁found ▁== ▁1 ▁&& ▁raw _ extensions ▁[ ▁idx ▁] ▁. ▁present ▁== ▁1 ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ COL LECT _ EXTENSIONS ▁, ▁SSL _ R _ BAD _ EXTENSION ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁found ▁) ▁{ ▁raw _ extensions ▁[ ▁idx ▁] ▁. ▁data ▁= ▁extension ▁; ▁raw _ extensions ▁[ ▁idx ▁] ▁. ▁present ▁= ▁1 ▁; ▁raw _ extensions ▁[ ▁idx ▁] ▁. ▁type ▁= ▁type ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁OSSL _ NE LEM ▁( ▁ext _ defs ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ext _ defs ▁[ ▁i ▁] ▁. ▁init _ ext ▁!= ▁NULL ▁&& ▁( ▁ext _ defs ▁[ ▁i ▁] ▁. ▁context ▁& ▁context ▁) ▁!= ▁0 ▁&& ▁extension _ is _ re levant ▁( ▁s ▁, ▁ext _ defs ▁[ ▁i ▁] ▁. ▁context ▁, ▁context ▁) ▁&& ▁! ▁ext _ defs ▁[ ▁i ▁] ▁. ▁init _ ext ▁( ▁s ▁, ▁context ▁) ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁goto ▁err ▁; ▁} ▁} ▁* ▁res ▁= ▁raw _ extensions ▁; ▁return ▁1 ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁raw _ extensions ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁ngx _ http _ up stream _ finalize _ request ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ http _ up stream _ t ▁* ▁u ▁, ▁ngx _ int _ t ▁rc ▁) ▁{ ▁ngx _ uint _ t ▁flush ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" finalize http up stream request :% i " ▁, ▁rc ▁) ▁; ▁if ▁( ▁u ▁-> ▁cleanup ▁== ▁NULL ▁) ▁{ ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁NGX _ DONE ▁) ▁; ▁return ▁; ▁} ▁* ▁u ▁-> ▁cleanup ▁= ▁NULL ▁; ▁u ▁-> ▁cleanup ▁= ▁NULL ▁; ▁if ▁( ▁u ▁-> ▁resolved ▁&& ▁u ▁-> ▁resolved ▁-> ▁ctx ▁) ▁{ ▁ngx _ resolve _ name _ done ▁( ▁u ▁-> ▁resolved ▁-> ▁ctx ▁) ▁; ▁u ▁-> ▁resolved ▁-> ▁ctx ▁= ▁NULL ▁; ▁} ▁if ▁( ▁u ▁-> ▁state ▁&& ▁u ▁-> ▁state ▁-> ▁response _ time ▁) ▁{ ▁u ▁-> ▁state ▁-> ▁response _ time ▁= ▁ngx _ current _ msec ▁- ▁u ▁-> ▁state ▁-> ▁response _ time ▁; ▁if ▁( ▁u ▁-> ▁pipe ▁&& ▁u ▁-> ▁pipe ▁-> ▁read _ length ▁) ▁{ ▁u ▁-> ▁state ▁-> ▁bytes _ received ▁+= ▁u ▁-> ▁pipe ▁-> ▁read _ length ▁- ▁u ▁-> ▁pipe ▁-> ▁pr ere ad _ size ▁; ▁u ▁-> ▁state ▁-> ▁response _ length ▁= ▁u ▁-> ▁pipe ▁-> ▁read _ length ▁; ▁} ▁} ▁u ▁-> ▁finalize _ request ▁( ▁r ▁, ▁rc ▁) ▁; ▁if ▁( ▁u ▁-> ▁peer ▁. ▁free ▁&& ▁u ▁-> ▁peer ▁. ▁sockaddr ▁) ▁{ ▁u ▁-> ▁peer ▁. ▁free ▁( ▁& ▁u ▁-> ▁peer ▁, ▁u ▁-> ▁peer ▁. ▁data ▁, ▁0 ▁) ▁; ▁u ▁-> ▁peer ▁. ▁sockaddr ▁= ▁NULL ▁; ▁} ▁if ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁) ▁{ ▁# if ▁( ▁NGX _ HTTP _ SSL ▁) ▁if ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁ssl ▁) ▁{ ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁ssl ▁-> ▁no _ wait _ shutdown ▁= ▁1 ▁; ▁( ▁void ▁) ▁ngx _ ssl _ shutdown ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁) ▁; ▁} ▁# endif ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" close http up stream connection :% d " ▁, ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁fd ▁) ▁; ▁if ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁pool ▁) ▁{ ▁ngx _ destroy _ pool ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁pool ▁) ▁; ▁} ▁ngx _ close _ connection ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁) ▁; ▁} ▁u ▁-> ▁peer ▁. ▁connection ▁= ▁NULL ▁; ▁if ▁( ▁u ▁-> ▁pipe ▁&& ▁u ▁-> ▁pipe ▁-> ▁temp _ file ▁) ▁{ ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" http up stream temp fd :% d " ▁, ▁u ▁-> ▁pipe ▁-> ▁temp _ file ▁-> ▁file ▁. ▁fd ▁) ▁; ▁} ▁if ▁( ▁u ▁-> ▁store ▁&& ▁u ▁-> ▁pipe ▁&& ▁u ▁-> ▁pipe ▁-> ▁temp _ file ▁&& ▁u ▁-> ▁pipe ▁-> ▁temp _ file ▁-> ▁file ▁. ▁fd ▁!= ▁NGX _ INVALID _ FILE ▁) ▁{ ▁if ▁( ▁ngx _ delete _ file ▁( ▁u ▁-> ▁pipe ▁-> ▁temp _ file ▁-> ▁file ▁. ▁name ▁. ▁data ▁) ▁== ▁NGX _ FILE _ ERROR ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁ngx _ errno ▁, ▁ngx _ delete _ file _ n ▁"\"% s \" failed " ▁, ▁u ▁-> ▁pipe ▁-> ▁temp _ file ▁-> ▁file ▁. ▁name ▁. ▁data ▁) ▁; ▁} ▁} ▁# if ▁( ▁NGX _ HTTP _ CACHE ▁) ▁if ▁( ▁r ▁-> ▁cache ▁) ▁{ ▁if ▁( ▁u ▁-> ▁cache able ▁) ▁{ ▁if ▁( ▁rc ▁== ▁NGX _ HTTP _ BAD _ GATE WAY ▁|| ▁rc ▁== ▁NGX _ HTTP _ GATE WAY _ TIME _ OUT ▁) ▁{ ▁time _ t ▁valid ▁; ▁valid ▁= ▁ngx _ http _ file _ cache _ valid ▁( ▁u ▁-> ▁conf ▁-> ▁cache _ valid ▁, ▁rc ▁) ▁; ▁if ▁( ▁valid ▁) ▁{ ▁r ▁-> ▁cache ▁-> ▁valid _ sec ▁= ▁ngx _ time ▁( ▁) ▁+ ▁valid ▁; ▁r ▁-> ▁cache ▁-> ▁error ▁= ▁rc ▁; ▁} ▁} ▁} ▁ngx _ http _ file _ cache _ free ▁( ▁r ▁-> ▁cache ▁, ▁u ▁-> ▁pipe ▁-> ▁temp _ file ▁) ▁; ▁} ▁# endif ▁if ▁( ▁r ▁-> ▁sub request _ in _ memory ▁&& ▁u ▁-> ▁headers _ in ▁. ▁status _ n ▁>= ▁NGX _ HTTP _ SPECIAL _ RESPONSE ▁) ▁{ ▁u ▁-> ▁buffer ▁. ▁last ▁= ▁u ▁-> ▁buffer ▁. ▁pos ▁; ▁} ▁r ▁-> ▁read _ event _ handler ▁= ▁ngx _ http _ block _ reading ▁; ▁if ▁( ▁rc ▁== ▁NGX _ DECL INED ▁) ▁{ ▁return ▁; ▁} ▁r ▁-> ▁connection ▁-> ▁log ▁-> ▁action ▁= ▁" s ending to client " ▁; ▁if ▁( ▁! ▁u ▁-> ▁header _ sent ▁|| ▁rc ▁== ▁NGX _ HTTP _ REQUEST _ TIME _ OUT ▁|| ▁rc ▁== ▁NGX _ HTTP _ CLIENT _ CLOSED _ REQUEST ▁) ▁{ ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁rc ▁) ▁; ▁return ▁; ▁} ▁flush ▁= ▁0 ▁; ▁if ▁( ▁rc ▁>= ▁NGX _ HTTP _ SPECIAL _ RESPONSE ▁) ▁{ ▁rc ▁= ▁NGX _ ERROR ▁; ▁flush ▁= ▁1 ▁; ▁} ▁if ▁( ▁r ▁-> ▁header _ only ▁|| ▁( ▁u ▁-> ▁pipe ▁&& ▁u ▁-> ▁pipe ▁-> ▁downstream _ error ▁) ▁) ▁{ ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁rc ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁rc ▁== ▁0 ▁) ▁{ ▁rc ▁= ▁ngx _ http _ send _ special ▁( ▁r ▁, ▁NGX _ HTTP _ LAST ▁) ▁; ▁} ▁else ▁if ▁( ▁flush ▁) ▁{ ▁r ▁-> ▁keep alive ▁= ▁0 ▁; ▁rc ▁= ▁ngx _ http _ send _ special ▁( ▁r ▁, ▁NGX _ HTTP _ FLUSH ▁) ▁; ▁} ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁rc ▁) ▁; ▁}	0
▁AP _ DECLARE ▁( ▁apr _ status _ t ▁) ▁ap _ r get line _ core ▁( ▁char ▁* ▁* ▁s ▁, ▁apr _ size _ t ▁n ▁, ▁apr _ size _ t ▁* ▁read ▁, ▁request _ rec ▁* ▁r ▁, ▁int ▁flags ▁, ▁apr _ bucket _ b rig ade ▁* ▁bb ▁) ▁{ ▁apr _ status _ t ▁rv ▁; ▁apr _ bucket ▁* ▁e ▁; ▁apr _ size _ t ▁bytes _ handled ▁= ▁0 ▁, ▁current _ alloc ▁= ▁0 ▁; ▁char ▁* ▁pos ▁, ▁* ▁last _ char ▁= ▁* ▁s ▁; ▁int ▁do _ alloc ▁= ▁( ▁* ▁s ▁== ▁NULL ▁) ▁, ▁saw _ e os ▁= ▁0 ▁; ▁int ▁fold ▁= ▁flags ▁& ▁AP _ GET LINE _ F OLD ▁; ▁int ▁cr lf ▁= ▁flags ▁& ▁AP _ GET LINE _ CR LF ▁; ▁if ▁( ▁last _ char ▁) ▁* ▁last _ char ▁= ▁' ▁\0 ▁' ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁apr _ b rig ade _ cleanup ▁( ▁bb ▁) ▁; ▁rv ▁= ▁ap _ get _ b rig ade ▁( ▁r ▁-> ▁proto _ input _ filters ▁, ▁bb ▁, ▁AP _ MODE _ GET LINE ▁, ▁APR _ BLOCK _ READ ▁, ▁0 ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁rv ▁; ▁} ▁if ▁( ▁APR _ BR IG ADE _ EMPTY ▁( ▁bb ▁) ▁) ▁{ ▁return ▁APR _ EG ENER AL ▁; ▁} ▁for ▁( ▁e ▁= ▁APR _ BR IG ADE _ FIRST ▁( ▁bb ▁) ▁; ▁e ▁!= ▁APR _ BR IG ADE _ SENT IN EL ▁( ▁bb ▁) ▁; ▁e ▁= ▁APR _ BUCKET _ NEXT ▁( ▁e ▁) ▁) ▁{ ▁const ▁char ▁* ▁str ▁; ▁apr _ size _ t ▁len ▁; ▁if ▁( ▁APR _ BUCKET _ IS _ E OS ▁( ▁e ▁) ▁) ▁{ ▁saw _ e os ▁= ▁1 ▁; ▁break ▁; ▁} ▁rv ▁= ▁apr _ bucket _ read ▁( ▁e ▁, ▁& ▁str ▁, ▁& ▁len ▁, ▁APR _ BLOCK _ READ ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁rv ▁; ▁} ▁if ▁( ▁len ▁== ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁n ▁< ▁bytes _ handled ▁+ ▁len ▁) ▁{ ▁* ▁read ▁= ▁bytes _ handled ▁; ▁if ▁( ▁* ▁s ▁) ▁{ ▁if ▁( ▁bytes _ handled ▁> ▁0 ▁) ▁{ ▁( ▁* ▁s ▁) ▁[ ▁bytes _ handled ▁- ▁1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁else ▁{ ▁( ▁* ▁s ▁) ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁} ▁return ▁APR _ ENO SPC ▁; ▁} ▁if ▁( ▁do _ alloc ▁) ▁{ ▁if ▁( ▁! ▁* ▁s ▁) ▁{ ▁current _ alloc ▁= ▁len ▁; ▁* ▁s ▁= ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁current _ alloc ▁) ▁; ▁} ▁else ▁if ▁( ▁bytes _ handled ▁+ ▁len ▁> ▁current _ alloc ▁) ▁{ ▁apr _ size _ t ▁new _ size ▁= ▁current _ alloc ▁* ▁2 ▁; ▁char ▁* ▁new _ buffer ▁; ▁if ▁( ▁bytes _ handled ▁+ ▁len ▁> ▁new _ size ▁) ▁{ ▁new _ size ▁= ▁( ▁bytes _ handled ▁+ ▁len ▁) ▁* ▁2 ▁; ▁} ▁new _ buffer ▁= ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁new _ size ▁) ▁; ▁memcpy ▁( ▁new _ buffer ▁, ▁* ▁s ▁, ▁bytes _ handled ▁) ▁; ▁current _ alloc ▁= ▁new _ size ▁; ▁* ▁s ▁= ▁new _ buffer ▁; ▁} ▁} ▁pos ▁= ▁* ▁s ▁+ ▁bytes _ handled ▁; ▁memcpy ▁( ▁pos ▁, ▁str ▁, ▁len ▁) ▁; ▁last _ char ▁= ▁pos ▁+ ▁len ▁- ▁1 ▁; ▁bytes _ handled ▁+= ▁len ▁; ▁} ▁if ▁( ▁last _ char ▁&& ▁( ▁* ▁last _ char ▁== ▁APR _ ASCII _ LF ▁) ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁last _ char ▁<= ▁* ▁s ▁|| ▁last _ char ▁[ ▁-1 ▁] ▁!= ▁APR _ ASCII _ CR ▁) ▁{ ▁* ▁last _ char ▁= ▁' ▁\0 ▁' ▁; ▁bytes _ handled ▁= ▁last _ char ▁- ▁* ▁s ▁; ▁* ▁read ▁= ▁bytes _ handled ▁; ▁return ▁APR _ EINVAL ▁; ▁} ▁if ▁( ▁last _ char ▁> ▁* ▁s ▁&& ▁last _ char ▁[ ▁-1 ▁] ▁== ▁APR _ ASCII _ CR ▁) ▁{ ▁last _ char ▁-- ▁; ▁} ▁* ▁last _ char ▁= ▁' ▁\0 ▁' ▁; ▁bytes _ handled ▁= ▁last _ char ▁- ▁* ▁s ▁; ▁if ▁( ▁fold ▁&& ▁bytes _ handled ▁&& ▁! ▁saw _ e os ▁) ▁{ ▁for ▁( ▁; ▁; ▁) ▁{ ▁const ▁char ▁* ▁str ▁; ▁apr _ size _ t ▁len ▁; ▁char ▁c ▁; ▁apr _ b rig ade _ cleanup ▁( ▁bb ▁) ▁; ▁rv ▁= ▁ap _ get _ b rig ade ▁( ▁r ▁-> ▁proto _ input _ filters ▁, ▁bb ▁, ▁AP _ MODE _ SPEC UL ATIVE ▁, ▁APR _ BLOCK _ READ ▁, ▁1 ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁rv ▁; ▁} ▁if ▁( ▁APR _ BR IG ADE _ EMPTY ▁( ▁bb ▁) ▁) ▁{ ▁break ▁; ▁} ▁e ▁= ▁APR _ BR IG ADE _ FIRST ▁( ▁bb ▁) ▁; ▁if ▁( ▁APR _ BUCKET _ IS _ E OS ▁( ▁e ▁) ▁) ▁{ ▁break ▁; ▁} ▁rv ▁= ▁apr _ bucket _ read ▁( ▁e ▁, ▁& ▁str ▁, ▁& ▁len ▁, ▁APR _ BLOCK _ READ ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁apr _ b rig ade _ cleanup ▁( ▁bb ▁) ▁; ▁return ▁rv ▁; ▁} ▁c ▁= ▁* ▁str ▁; ▁if ▁( ▁c ▁== ▁APR _ ASCII _ BLANK ▁|| ▁c ▁== ▁APR _ ASCII _ TAB ▁) ▁{ ▁if ▁( ▁bytes _ handled ▁>= ▁n ▁) ▁{ ▁* ▁read ▁= ▁n ▁; ▁( ▁* ▁s ▁) ▁[ ▁n ▁- ▁1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁return ▁APR _ ENO SPC ▁; ▁} ▁else ▁{ ▁apr _ size _ t ▁next _ size ▁, ▁next _ len ▁; ▁char ▁* ▁tmp ▁; ▁if ▁( ▁do _ alloc ▁) ▁{ ▁tmp ▁= ▁NULL ▁; ▁} ▁else ▁{ ▁tmp ▁= ▁last _ char ▁; ▁} ▁next _ size ▁= ▁n ▁- ▁bytes _ handled ▁; ▁rv ▁= ▁ap _ r get line _ core ▁( ▁& ▁tmp ▁, ▁next _ size ▁, ▁& ▁next _ len ▁, ▁r ▁, ▁0 ▁, ▁bb ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁rv ▁; ▁} ▁if ▁( ▁do _ alloc ▁&& ▁next _ len ▁> ▁0 ▁) ▁{ ▁char ▁* ▁new _ buffer ▁; ▁apr _ size _ t ▁new _ size ▁= ▁bytes _ handled ▁+ ▁next _ len ▁+ ▁1 ▁; ▁new _ buffer ▁= ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁new _ size ▁) ▁; ▁memcpy ▁( ▁new _ buffer ▁, ▁* ▁s ▁, ▁bytes _ handled ▁) ▁; ▁memcpy ▁( ▁new _ buffer ▁+ ▁bytes _ handled ▁, ▁tmp ▁, ▁next _ len ▁+ ▁1 ▁) ▁; ▁* ▁s ▁= ▁new _ buffer ▁; ▁} ▁last _ char ▁+= ▁next _ len ▁; ▁bytes _ handled ▁+= ▁next _ len ▁; ▁} ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁} ▁* ▁read ▁= ▁bytes _ handled ▁; ▁if ▁( ▁strlen ▁( ▁* ▁s ▁) ▁< ▁bytes _ handled ▁) ▁{ ▁return ▁APR _ EINVAL ▁; ▁} ▁return ▁APR _ SUCCESS ▁; ▁}	0
▁const ▁STACK _ OF ▁( ▁X 509_ NAME ▁) ▁* ▁get _ ca _ names ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁const ▁STACK _ OF ▁( ▁X 509_ NAME ▁) ▁* ▁ca _ sk ▁= ▁NULL ▁; ▁; ▁if ▁( ▁s ▁-> ▁server ▁) ▁{ ▁ca _ sk ▁= ▁SSL _ get _ client _ CA _ list ▁( ▁s ▁) ▁; ▁if ▁( ▁ca _ sk ▁!= ▁NULL ▁&& ▁sk _ X 509_ NAME _ num ▁( ▁ca _ sk ▁) ▁== ▁0 ▁) ▁ca _ sk ▁= ▁NULL ▁; ▁} ▁if ▁( ▁ca _ sk ▁== ▁NULL ▁) ▁ca _ sk ▁= ▁SSL _ get 0_ CA _ list ▁( ▁s ▁) ▁; ▁return ▁ca _ sk ▁; ▁}	0
▁static ▁HAND SHAKE _ RESULT ▁* ▁do _ handshake _ internal ▁( ▁SSL _ CTX ▁* ▁server _ ctx ▁, ▁SSL _ CTX ▁* ▁server 2_ ctx ▁, ▁SSL _ CTX ▁* ▁client _ ctx ▁, ▁const ▁SSL _ TEST _ CTX ▁* ▁test _ ctx ▁, ▁SSL _ SESSION ▁* ▁session _ in ▁, ▁SSL _ SESSION ▁* ▁* ▁session _ out ▁) ▁{ ▁SSL ▁* ▁server ▁, ▁* ▁client ▁; ▁BIO ▁* ▁client _ to _ server ▁, ▁* ▁server _ to _ client ▁; ▁HAND SHAKE _ EX _ DATA ▁server _ ex _ data ▁, ▁client _ ex _ data ▁; ▁CTX _ DATA ▁client _ ctx _ data ▁, ▁server _ ctx _ data ▁, ▁server 2_ ctx _ data ▁; ▁HAND SHAKE _ RESULT ▁* ▁ret ▁= ▁HAND SHAKE _ RESULT _ new ▁( ▁) ▁; ▁int ▁client _ turn ▁= ▁1 ▁, ▁shutdown ▁= ▁0 ▁; ▁peer _ status _ t ▁client _ status ▁= ▁PE ER _ RETRY ▁, ▁server _ status ▁= ▁PE ER _ RETRY ▁; ▁handshake _ status _ t ▁status ▁= ▁HAND SHAKE _ RETRY ▁; ▁unsigned ▁char ▁* ▁tick ▁= ▁NULL ▁; ▁size _ t ▁tick _ len ▁= ▁0 ▁; ▁SSL _ SESSION ▁* ▁sess ▁= ▁NULL ▁; ▁const ▁unsigned ▁char ▁* ▁proto ▁= ▁NULL ▁; ▁unsigned ▁int ▁proto _ len ▁= ▁0 ▁; ▁memset ▁( ▁& ▁server _ ctx _ data ▁, ▁0 ▁, ▁sizeof ▁( ▁server _ ctx _ data ▁) ▁) ▁; ▁memset ▁( ▁& ▁server 2_ ctx _ data ▁, ▁0 ▁, ▁sizeof ▁( ▁server 2_ ctx _ data ▁) ▁) ▁; ▁memset ▁( ▁& ▁client _ ctx _ data ▁, ▁0 ▁, ▁sizeof ▁( ▁client _ ctx _ data ▁) ▁) ▁; ▁configure _ handshake _ ctx ▁( ▁server _ ctx ▁, ▁server 2_ ctx ▁, ▁client _ ctx ▁, ▁test _ ctx ▁, ▁& ▁server _ ctx _ data ▁, ▁& ▁server 2_ ctx _ data ▁, ▁& ▁client _ ctx _ data ▁) ▁; ▁server ▁= ▁SSL _ new ▁( ▁server _ ctx ▁) ▁; ▁client ▁= ▁SSL _ new ▁( ▁client _ ctx ▁) ▁; ▁OPENSSL _ assert ▁( ▁server ▁!= ▁NULL ▁&& ▁client ▁!= ▁NULL ▁) ▁; ▁configure _ handshake _ ssl ▁( ▁server ▁, ▁client ▁, ▁test _ ctx ▁) ▁; ▁if ▁( ▁session _ in ▁!= ▁NULL ▁) ▁{ ▁OPENSSL _ assert ▁( ▁SSL _ CTX _ add _ session ▁( ▁server _ ctx ▁, ▁session _ in ▁) ▁) ▁; ▁OPENSSL _ assert ▁( ▁SSL _ set _ session ▁( ▁client ▁, ▁session _ in ▁) ▁) ▁; ▁} ▁memset ▁( ▁& ▁server _ ex _ data ▁, ▁0 ▁, ▁sizeof ▁( ▁server _ ex _ data ▁) ▁) ▁; ▁memset ▁( ▁& ▁client _ ex _ data ▁, ▁0 ▁, ▁sizeof ▁( ▁client _ ex _ data ▁) ▁) ▁; ▁ret ▁-> ▁result ▁= ▁SSL _ TEST _ INTERNAL _ ERROR ▁; ▁client _ to _ server ▁= ▁BIO _ new ▁( ▁BIO _ s _ mem ▁( ▁) ▁) ▁; ▁server _ to _ client ▁= ▁BIO _ new ▁( ▁BIO _ s _ mem ▁( ▁) ▁) ▁; ▁OPENSSL _ assert ▁( ▁client _ to _ server ▁!= ▁NULL ▁&& ▁server _ to _ client ▁!= ▁NULL ▁) ▁; ▁BIO _ set _ nb io ▁( ▁client _ to _ server ▁, ▁1 ▁) ▁; ▁BIO _ set _ nb io ▁( ▁server _ to _ client ▁, ▁1 ▁) ▁; ▁SSL _ set _ connect _ state ▁( ▁client ▁) ▁; ▁SSL _ set _ accept _ state ▁( ▁server ▁) ▁; ▁SSL _ set _ bio ▁( ▁client ▁, ▁server _ to _ client ▁, ▁client _ to _ server ▁) ▁; ▁OPENSSL _ assert ▁( ▁BIO _ up _ ref ▁( ▁server _ to _ client ▁) ▁> ▁0 ▁) ▁; ▁OPENSSL _ assert ▁( ▁BIO _ up _ ref ▁( ▁client _ to _ server ▁) ▁> ▁0 ▁) ▁; ▁SSL _ set _ bio ▁( ▁server ▁, ▁client _ to _ server ▁, ▁server _ to _ client ▁) ▁; ▁ex _ data _ idx ▁= ▁SSL _ get _ ex _ new _ index ▁( ▁0 ▁, ▁" ex data " ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁OPENSSL _ assert ▁( ▁ex _ data _ idx ▁>= ▁0 ▁) ▁; ▁OPENSSL _ assert ▁( ▁SSL _ set _ ex _ data ▁( ▁server ▁, ▁ex _ data _ idx ▁, ▁& ▁server _ ex _ data ▁) ▁== ▁1 ▁) ▁; ▁OPENSSL _ assert ▁( ▁SSL _ set _ ex _ data ▁( ▁client ▁, ▁ex _ data _ idx ▁, ▁& ▁client _ ex _ data ▁) ▁== ▁1 ▁) ▁; ▁SSL _ set _ info _ callback ▁( ▁server ▁, ▁& ▁info _ cb ▁) ▁; ▁SSL _ set _ info _ callback ▁( ▁client ▁, ▁& ▁info _ cb ▁) ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁client _ turn ▁) ▁{ ▁client _ status ▁= ▁do _ handshake _ step ▁( ▁client ▁, ▁shutdown ▁) ▁; ▁status ▁= ▁handshake _ status ▁( ▁client _ status ▁, ▁server _ status ▁, ▁1 ▁) ▁; ▁} ▁else ▁{ ▁server _ status ▁= ▁do _ handshake _ step ▁( ▁server ▁, ▁shutdown ▁) ▁; ▁status ▁= ▁handshake _ status ▁( ▁server _ status ▁, ▁client _ status ▁, ▁0 ▁) ▁; ▁} ▁switch ▁( ▁status ▁) ▁{ ▁case ▁HAND SHAKE _ SUCCESS ▁: ▁if ▁( ▁shutdown ▁) ▁{ ▁ret ▁-> ▁result ▁= ▁SSL _ TEST _ SUCCESS ▁; ▁goto ▁err ▁; ▁} ▁else ▁{ ▁client _ status ▁= ▁server _ status ▁= ▁PE ER _ RETRY ▁; ▁shutdown ▁= ▁1 ▁; ▁client _ turn ▁= ▁1 ▁; ▁break ▁; ▁} ▁case ▁CLIENT _ ERROR ▁: ▁ret ▁-> ▁result ▁= ▁SSL _ TEST _ CLIENT _ FAIL ▁; ▁goto ▁err ▁; ▁case ▁SERVER _ ERROR ▁: ▁ret ▁-> ▁result ▁= ▁SSL _ TEST _ SERVER _ FAIL ▁; ▁goto ▁err ▁; ▁case ▁INTERNAL _ ERROR ▁: ▁ret ▁-> ▁result ▁= ▁SSL _ TEST _ INTERNAL _ ERROR ▁; ▁goto ▁err ▁; ▁case ▁HAND SHAKE _ RETRY ▁: ▁client _ turn ▁ ^ = ▁1 ▁; ▁break ▁; ▁} ▁} ▁err ▁: ▁ret ▁-> ▁server _ alert _ sent ▁= ▁server _ ex _ data ▁. ▁alert _ sent ▁; ▁ret ▁-> ▁server _ alert _ received ▁= ▁client _ ex _ data ▁. ▁alert _ received ▁; ▁ret ▁-> ▁client _ alert _ sent ▁= ▁client _ ex _ data ▁. ▁alert _ sent ▁; ▁ret ▁-> ▁client _ alert _ received ▁= ▁server _ ex _ data ▁. ▁alert _ received ▁; ▁ret ▁-> ▁server _ protocol ▁= ▁SSL _ version ▁( ▁server ▁) ▁; ▁ret ▁-> ▁client _ protocol ▁= ▁SSL _ version ▁( ▁client ▁) ▁; ▁ret ▁-> ▁server name ▁= ▁server _ ex _ data ▁. ▁server name ▁; ▁if ▁( ▁( ▁sess ▁= ▁SSL _ get 0_ session ▁( ▁client ▁) ▁) ▁!= ▁NULL ▁) ▁SSL _ SESSION _ get 0_ ticket ▁( ▁sess ▁, ▁& ▁tick ▁, ▁& ▁tick _ len ▁) ▁; ▁if ▁( ▁tick ▁== ▁NULL ▁|| ▁tick _ len ▁== ▁0 ▁) ▁ret ▁-> ▁session _ ticket ▁= ▁SSL _ TEST _ SESSION _ TICK ET _ NO ▁; ▁else ▁ret ▁-> ▁session _ ticket ▁= ▁SSL _ TEST _ SESSION _ TICK ET _ YES ▁; ▁ret ▁-> ▁session _ ticket _ do _ not _ call ▁= ▁server _ ex _ data ▁. ▁session _ ticket _ do _ not _ call ▁; ▁SSL _ get 0_ next _ proto _ neg ot iated ▁( ▁client ▁, ▁& ▁proto ▁, ▁& ▁proto _ len ▁) ▁; ▁ret ▁-> ▁client _ np n _ neg ot iated ▁= ▁dup _ str ▁( ▁proto ▁, ▁proto _ len ▁) ▁; ▁SSL _ get 0_ next _ proto _ neg ot iated ▁( ▁server ▁, ▁& ▁proto ▁, ▁& ▁proto _ len ▁) ▁; ▁ret ▁-> ▁server _ np n _ neg ot iated ▁= ▁dup _ str ▁( ▁proto ▁, ▁proto _ len ▁) ▁; ▁SSL _ get 0_ al pn _ selected ▁( ▁client ▁, ▁& ▁proto ▁, ▁& ▁proto _ len ▁) ▁; ▁ret ▁-> ▁client _ al pn _ neg ot iated ▁= ▁dup _ str ▁( ▁proto ▁, ▁proto _ len ▁) ▁; ▁SSL _ get 0_ al pn _ selected ▁( ▁server ▁, ▁& ▁proto ▁, ▁& ▁proto _ len ▁) ▁; ▁ret ▁-> ▁server _ al pn _ neg ot iated ▁= ▁dup _ str ▁( ▁proto ▁, ▁proto _ len ▁) ▁; ▁ret ▁-> ▁client _ res umed ▁= ▁SSL _ session _ re used ▁( ▁client ▁) ▁; ▁ret ▁-> ▁server _ res umed ▁= ▁SSL _ session _ re used ▁( ▁server ▁) ▁; ▁if ▁( ▁session _ out ▁!= ▁NULL ▁) ▁* ▁session _ out ▁= ▁SSL _ get 1_ session ▁( ▁client ▁) ▁; ▁ctx _ data _ free _ data ▁( ▁& ▁server _ ctx _ data ▁) ▁; ▁ctx _ data _ free _ data ▁( ▁& ▁server 2_ ctx _ data ▁) ▁; ▁ctx _ data _ free _ data ▁( ▁& ▁client _ ctx _ data ▁) ▁; ▁SSL _ free ▁( ▁server ▁) ▁; ▁SSL _ free ▁( ▁client ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁rate _ control ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁arg ▁) ▁{ ▁Slice Args ▁* ▁slice _ dat ▁= ▁arg ▁; ▁VC 2 Enc Context ▁* ▁s ▁= ▁slice _ dat ▁-> ▁ctx ▁; ▁const ▁int ▁sx ▁= ▁slice _ dat ▁-> ▁x ▁; ▁const ▁int ▁sy ▁= ▁slice _ dat ▁-> ▁y ▁; ▁const ▁int ▁top ▁= ▁slice _ dat ▁-> ▁bits _ ceil ▁; ▁const ▁int ▁bottom ▁= ▁slice _ dat ▁-> ▁bits _ floor ▁; ▁int ▁quant _ buf ▁[ ▁2 ▁] ▁= ▁{ ▁-1 ▁, ▁-1 ▁} ▁; ▁int ▁quant ▁= ▁slice _ dat ▁-> ▁quant _ idx ▁, ▁step ▁= ▁1 ▁; ▁int ▁bits _ last ▁, ▁bits ▁= ▁count _ hq _ slice ▁( ▁s ▁, ▁slice _ dat ▁-> ▁cache ▁, ▁sx ▁, ▁sy ▁, ▁quant ▁) ▁; ▁while ▁( ▁( ▁bits ▁> ▁top ▁) ▁|| ▁( ▁bits ▁< ▁bottom ▁) ▁) ▁{ ▁const ▁int ▁signed _ step ▁= ▁bits ▁> ▁top ▁? ▁+ ▁step ▁: ▁- ▁step ▁; ▁quant ▁= ▁av _ clip ▁( ▁quant ▁+ ▁signed _ step ▁, ▁0 ▁, ▁s ▁-> ▁q _ ceil ▁- ▁1 ▁) ▁; ▁bits ▁= ▁count _ hq _ slice ▁( ▁s ▁, ▁slice _ dat ▁-> ▁cache ▁, ▁sx ▁, ▁sy ▁, ▁quant ▁) ▁; ▁if ▁( ▁quant _ buf ▁[ ▁1 ▁] ▁== ▁quant ▁) ▁{ ▁quant ▁= ▁FF MAX ▁( ▁quant _ buf ▁[ ▁0 ▁] ▁, ▁quant ▁) ▁; ▁bits ▁= ▁quant ▁== ▁quant _ buf ▁[ ▁0 ▁] ▁? ▁bits _ last ▁: ▁bits ▁; ▁break ▁; ▁} ▁step ▁= ▁av _ clip ▁( ▁step ▁/ ▁2 ▁, ▁1 ▁, ▁( ▁s ▁-> ▁q _ ceil ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁quant _ buf ▁[ ▁1 ▁] ▁= ▁quant _ buf ▁[ ▁0 ▁] ▁; ▁quant _ buf ▁[ ▁0 ▁] ▁= ▁quant ▁; ▁bits _ last ▁= ▁bits ▁; ▁} ▁slice _ dat ▁-> ▁quant _ idx ▁= ▁av _ clip ▁( ▁quant ▁, ▁0 ▁, ▁s ▁-> ▁q _ ceil ▁- ▁1 ▁) ▁; ▁slice _ dat ▁-> ▁bytes ▁= ▁FF ALIGN ▁( ▁( ▁bits ▁>> ▁3 ▁) ▁, ▁s ▁-> ▁size _ scaler ▁) ▁+ ▁4 ▁+ ▁s ▁-> ▁prefix _ bytes ▁; ▁slice _ dat ▁-> ▁bytes _ left ▁= ▁s ▁-> ▁slice _ max _ bytes ▁- ▁slice _ dat ▁-> ▁bytes ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁d xt ory _ decode _ v 2_ 565 ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVFrame ▁* ▁pic ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁int ▁src _ size ▁, ▁int ▁is _5 65 ▁) ▁{ ▁Get Byte Context ▁gb ▁; ▁Get Bit Context ▁gb 2 ▁; ▁int ▁ns lices ▁, ▁slice ▁, ▁slice _ height ▁; ▁uint 32_ t ▁off ▁, ▁slice _ size ▁; ▁uint 8_ t ▁* ▁dst ▁; ▁int ▁ret ▁; ▁bytestream 2_ init ▁( ▁& ▁gb ▁, ▁src ▁, ▁src _ size ▁) ▁; ▁ns lices ▁= ▁bytestream 2_ get _ le 16 ▁( ▁& ▁gb ▁) ▁; ▁off ▁= ▁FF ALIGN ▁( ▁ns lices ▁* ▁4 ▁+ ▁2 ▁, ▁16 ▁) ▁; ▁if ▁( ▁src _ size ▁< ▁off ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" nos lic edata \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁! ▁ns lices ▁|| ▁avctx ▁-> ▁height ▁% ▁ns lices ▁) ▁{ ▁avpriv _ request _ sample ▁( ▁avctx ▁, ▁"% ds lices for % dx % d " ▁, ▁ns lices ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁slice _ height ▁= ▁avctx ▁-> ▁height ▁/ ▁ns lices ▁; ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ RGB 24 ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁pic ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁dst ▁= ▁pic ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁slice ▁= ▁0 ▁; ▁slice ▁< ▁ns lices ▁; ▁slice ▁++ ▁) ▁{ ▁slice _ size ▁= ▁bytestream 2_ get _ le 32 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁slice _ size ▁> ▁src _ size ▁- ▁off ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid s lices ize %" ▁PRIu 32 ▁"( only %" ▁PRIu 32 ▁" bytesleft )\ n " ▁, ▁slice _ size ▁, ▁src _ size ▁- ▁off ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁slice _ size ▁<= ▁16 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid s lices ize %" ▁PRIu 32 ▁"\ n " ▁, ▁slice _ size ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁AV _ RL 32 ▁( ▁src ▁+ ▁off ▁) ▁!= ▁slice _ size ▁- ▁16 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" S lices izes mismatch : got %" ▁PRIu 32 ▁" inst ead of %" ▁PRIu 32 ▁"\ n " ▁, ▁AV _ RL 32 ▁( ▁src ▁+ ▁off ▁) ▁, ▁slice _ size ▁- ▁16 ▁) ▁; ▁} ▁init _ get _ bits ▁( ▁& ▁gb 2 ▁, ▁src ▁+ ▁off ▁+ ▁16 ▁, ▁( ▁slice _ size ▁- ▁16 ▁) ▁* ▁8 ▁) ▁; ▁dx 2_ decode _ slice _5 65 ▁( ▁& ▁gb 2 ▁, ▁avctx ▁-> ▁width ▁, ▁slice _ height ▁, ▁dst ▁, ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁, ▁is _5 65 ▁) ▁; ▁dst ▁+= ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁* ▁slice _ height ▁; ▁off ▁+= ▁slice _ size ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁inline ▁int ▁available _ samples ▁( ▁AVFrame ▁* ▁out ▁) ▁{ ▁int ▁samples ▁; ▁int ▁bytes _ per _ sample ▁= ▁av _ get _ bytes _ per _ sample ▁( ▁out ▁-> ▁format ▁) ▁; ▁if ▁( ▁! ▁bytes _ per _ sample ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁samples ▁= ▁out ▁-> ▁linesize ▁[ ▁0 ▁] ▁/ ▁bytes _ per _ sample ▁; ▁if ▁( ▁av _ sample _ fmt _ is _ planar ▁( ▁out ▁-> ▁format ▁) ▁) ▁{ ▁return ▁samples ▁; ▁} ▁else ▁{ ▁int ▁channels ▁= ▁av _ get _ channel _ layout _ nb _ channels ▁( ▁out ▁-> ▁channel _ layout ▁) ▁; ▁return ▁samples ▁/ ▁channels ▁; ▁} ▁}	0
▁static ▁Code Book ▁unpack _ code book ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁unsigned ▁depth ▁, ▁unsigned ▁size ▁) ▁{ ▁unsigned ▁i ▁, ▁j ▁; ▁Code Book ▁cb ▁= ▁{ ▁0 ▁} ▁; ▁if ▁( ▁size ▁>= ▁INT _ MAX ▁/ ▁34 ▁|| ▁get _ bits _ left ▁( ▁gb ▁) ▁< ▁size ▁* ▁34 ▁) ▁return ▁cb ▁; ▁if ▁( ▁size ▁>= ▁INT _ MAX ▁/ ▁sizeof ▁( ▁Macro Block ▁) ▁) ▁return ▁cb ▁; ▁cb ▁. ▁blocks ▁= ▁av _ malloc ▁( ▁size ▁? ▁size ▁* ▁sizeof ▁( ▁Macro Block ▁) ▁: ▁1 ▁) ▁; ▁if ▁( ▁! ▁cb ▁. ▁blocks ▁) ▁return ▁cb ▁; ▁cb ▁. ▁depth ▁= ▁depth ▁; ▁cb ▁. ▁size ▁= ▁size ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁mask _ bits ▁= ▁get _ bits ▁( ▁gb ▁, ▁4 ▁) ▁; ▁unsigned ▁color 0 ▁= ▁get _ bits ▁( ▁gb ▁, ▁15 ▁) ▁; ▁unsigned ▁color 1 ▁= ▁get _ bits ▁( ▁gb ▁, ▁15 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁mask _ bits ▁& ▁( ▁1 ▁<< ▁j ▁) ▁) ▁cb ▁. ▁blocks ▁[ ▁i ▁] ▁. ▁pixels ▁[ ▁j ▁] ▁= ▁color 1 ▁; ▁else ▁cb ▁. ▁blocks ▁[ ▁i ▁] ▁. ▁pixels ▁[ ▁j ▁] ▁= ▁color 0 ▁; ▁} ▁} ▁return ▁cb ▁; ▁}	0
▁static ▁int ▁test _ client _ hello ▁( ▁int ▁curr test ▁) ▁{ ▁SSL _ CTX ▁* ▁ctx ▁; ▁SSL ▁* ▁con ▁= ▁NULL ▁; ▁BIO ▁* ▁rb io ▁; ▁BIO ▁* ▁w bio ▁; ▁long ▁len ▁; ▁unsigned ▁char ▁* ▁data ▁; ▁PACKET ▁pkt ▁= ▁{ ▁0 ▁} ▁, ▁pkt 2 ▁= ▁{ ▁0 ▁} ▁, ▁pkt 3 ▁= ▁{ ▁0 ▁} ▁; ▁char ▁* ▁dummy tick ▁= ▁" HelloWorld !" ▁; ▁unsigned ▁int ▁type ▁= ▁0 ▁; ▁int ▁test result ▁= ▁0 ▁; ▁size _ t ▁msglen ▁; ▁BIO ▁* ▁sess bio ▁= ▁NULL ▁; ▁SSL _ SESSION ▁* ▁sess ▁= ▁NULL ▁; ▁# ifdef ▁OPENSSL _ NO _ TLS 1_ 3 ▁if ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING _ AND _ PS K ▁) ▁return ▁1 ▁; ▁# endif ▁ctx ▁= ▁SSL _ CTX _ new ▁( ▁TLS _ method ▁( ▁) ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁ctx ▁) ▁) ▁goto ▁end ▁; ▁switch ▁( ▁curr test ▁) ▁{ ▁case ▁TEST _ SET _ SESSION _ TICK _ DATA _ VER _ NEG ▁: ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ TLS 1_ 3 ▁) ▁&& ▁defined ▁( ▁OPENSSL _ NO _ TLS 1_2 ▁) ▁return ▁1 ▁; ▁# else ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ CTX _ set _ max _ proto _ version ▁( ▁ctx ▁, ▁TLS 1_ 2_ VERSION ▁) ▁) ▁) ▁goto ▁end ▁; ▁# endif ▁break ▁; ▁case ▁TEST _ ADD _ PADDING _ AND _ PS K ▁: ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ CTX _ set _ cipher _ list ▁( ▁ctx ▁, ▁"" ▁) ▁) ▁) ▁goto ▁end ▁; ▁case ▁TEST _ ADD _ PADDING ▁: ▁case ▁TEST _ PADDING _ NOT _ NEEDED ▁: ▁SSL _ CTX _ set _ options ▁( ▁ctx ▁, ▁SSL _ OP _ TL SE XT _ PADDING ▁) ▁; ▁SSL _ CTX _ clear _ options ▁( ▁ctx ▁, ▁SSL _ OP _ ENABLE _ MIDDLE BOX _ COMPAT ▁) ▁; ▁if ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING ▁) ▁{ ▁if ▁( ▁! ▁TEST _ false ▁( ▁SSL _ CTX _ set _ al pn _ protos ▁( ▁ctx ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁al pn _ pro ts ▁, ▁sizeof ▁( ▁al pn _ pro ts ▁) ▁- ▁1 ▁) ▁) ▁) ▁goto ▁end ▁; ▁} ▁else ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ CTX _ set _ cipher _ list ▁( ▁ctx ▁, ▁" AES 128 - SHA : TLS 13 - AES - 128 - GCM - SHA 256" ▁) ▁) ▁) ▁{ ▁goto ▁end ▁; ▁} ▁break ▁; ▁default ▁: ▁goto ▁end ▁; ▁} ▁con ▁= ▁SSL _ new ▁( ▁ctx ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁con ▁) ▁) ▁goto ▁end ▁; ▁if ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING _ AND _ PS K ▁) ▁{ ▁sess bio ▁= ▁BIO _ new _ file ▁( ▁session file ▁, ▁" r " ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁sess bio ▁) ▁) ▁{ ▁TEST _ info ▁( ▁" Unable t oop ense ssion . pem " ▁) ▁; ▁goto ▁end ▁; ▁} ▁sess ▁= ▁PEM _ read _ bio _ SSL _ SESSION ▁( ▁sess bio ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁sess ▁) ▁) ▁{ ▁TEST _ info ▁( ▁" Unable to load SSL _ SESSION " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ SESSION _ set _ time ▁( ▁sess ▁, ▁( ▁long ▁) ▁time ▁( ▁NULL ▁) ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁SSL _ set _ session ▁( ▁con ▁, ▁sess ▁) ▁) ▁) ▁goto ▁end ▁; ▁} ▁rb io ▁= ▁BIO _ new ▁( ▁BIO _ s _ mem ▁( ▁) ▁) ▁; ▁w bio ▁= ▁BIO _ new ▁( ▁BIO _ s _ mem ▁( ▁) ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁rb io ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁w bio ▁) ▁) ▁{ ▁BIO _ free ▁( ▁rb io ▁) ▁; ▁BIO _ free ▁( ▁w bio ▁) ▁; ▁goto ▁end ▁; ▁} ▁SSL _ set _ bio ▁( ▁con ▁, ▁rb io ▁, ▁w bio ▁) ▁; ▁SSL _ set _ connect _ state ▁( ▁con ▁) ▁; ▁if ▁( ▁curr test ▁== ▁TEST _ SET _ SESSION _ TICK _ DATA _ VER _ NEG ▁) ▁{ ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ set _ session _ ticket _ ext ▁( ▁con ▁, ▁dummy tick ▁, ▁strlen ▁( ▁dummy tick ▁) ▁) ▁) ▁) ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁TEST _ int _ le ▁( ▁SSL _ connect ▁( ▁con ▁) ▁, ▁0 ▁) ▁) ▁{ ▁goto ▁end ▁; ▁} ▁len ▁= ▁BIO _ get _ mem _ data ▁( ▁w bio ▁, ▁( ▁char ▁* ▁* ▁) ▁& ▁data ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁PACKET _ buf _ init ▁( ▁& ▁pkt ▁, ▁data ▁, ▁len ▁) ▁) ▁|| ▁! ▁PACKET _ forward ▁( ▁& ▁pkt ▁, ▁SSL 3_ RT _ HEADER _ LENGTH ▁) ▁) ▁goto ▁end ▁; ▁msglen ▁= ▁PACKET _ remaining ▁( ▁& ▁pkt ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁PACKET _ forward ▁( ▁& ▁pkt ▁, ▁SSL 3_ HM _ HEADER _ LENGTH ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ forward ▁( ▁& ▁pkt ▁, ▁CLIENT _ VERSION _ LEN ▁+ ▁SSL 3_ RANDOM _ SIZE ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _1 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _1 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ as _ length _ pref ixed _2 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁) ▁goto ▁end ▁; ▁while ▁( ▁PACKET _ remaining ▁( ▁& ▁pkt 2 ▁) ▁) ▁{ ▁if ▁( ▁! ▁TEST _ true ▁( ▁PACKET _ get _ net _2 ▁( ▁& ▁pkt 2 ▁, ▁& ▁type ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁& ▁pkt 2 ▁, ▁& ▁pkt 3 ▁) ▁) ▁) ▁goto ▁end ▁; ▁if ▁( ▁type ▁== ▁TL SE XT _ TYPE _ session _ ticket ▁) ▁{ ▁if ▁( ▁curr test ▁== ▁TEST _ SET _ SESSION _ TICK _ DATA _ VER _ NEG ▁) ▁{ ▁if ▁( ▁TEST _ true ▁( ▁PACKET _ equal ▁( ▁& ▁pkt 3 ▁, ▁dummy tick ▁, ▁strlen ▁( ▁dummy tick ▁) ▁) ▁) ▁) ▁{ ▁test result ▁= ▁1 ▁; ▁} ▁goto ▁end ▁; ▁} ▁} ▁if ▁( ▁type ▁== ▁TL SE XT _ TYPE _ padding ▁) ▁{ ▁if ▁( ▁! ▁TEST _ false ▁( ▁curr test ▁== ▁TEST _ PADDING _ NOT _ NEEDED ▁) ▁) ▁goto ▁end ▁; ▁else ▁if ▁( ▁TEST _ true ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING ▁|| ▁curr test ▁== ▁TEST _ ADD _ PADDING _ AND _ PS K ▁) ▁) ▁test result ▁= ▁TEST _ true ▁( ▁msglen ▁== ▁F 5_ WORKAROUND _ MAX _ MSG _ LEN ▁) ▁; ▁} ▁} ▁if ▁( ▁curr test ▁== ▁TEST _ PADDING _ NOT _ NEEDED ▁) ▁test result ▁= ▁1 ▁; ▁end ▁: ▁SSL _ free ▁( ▁con ▁) ▁; ▁SSL _ CTX _ free ▁( ▁ctx ▁) ▁; ▁SSL _ SESSION _ free ▁( ▁sess ▁) ▁; ▁BIO _ free ▁( ▁sess bio ▁) ▁; ▁return ▁test result ▁; ▁}	0
▁static ▁int ▁encode _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁W MAC ode c Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁flags 1 ▁, ▁flags 2 ▁; ▁uint 8_ t ▁* ▁extradata ▁; ▁s ▁-> ▁avctx ▁= ▁avctx ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁> ▁MAX _ CHANNELS ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" t oom any channels : got % i , need % ior f ew er " ▁, ▁avctx ▁-> ▁channels ▁, ▁MAX _ CHANNELS ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁sample _ rate ▁> ▁48000 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" sampler ate ist oo high :% d > 48 kHz " ▁, ▁avctx ▁-> ▁sample _ rate ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁bit _ rate ▁< ▁24 ▁* ▁1000 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" bit rat et oo low : got % i , need 24 000 or h igher \ n " ▁, ▁avctx ▁-> ▁bit _ rate ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁flags 1 ▁= ▁0 ▁; ▁flags 2 ▁= ▁1 ▁; ▁if ▁( ▁avctx ▁-> ▁codec ▁-> ▁id ▁== ▁CODEC _ ID _ W MA V 1 ▁) ▁{ ▁extradata ▁= ▁av _ malloc ▁( ▁4 ▁) ▁; ▁avctx ▁-> ▁extradata _ size ▁= ▁4 ▁; ▁AV _ WL 16 ▁( ▁extradata ▁, ▁flags 1 ▁) ▁; ▁AV _ WL 16 ▁( ▁extradata ▁+ ▁2 ▁, ▁flags 2 ▁) ▁; ▁} ▁else ▁if ▁( ▁avctx ▁-> ▁codec ▁-> ▁id ▁== ▁CODEC _ ID _ W MA V 2 ▁) ▁{ ▁extradata ▁= ▁av _ malloc z ▁( ▁10 ▁) ▁; ▁avctx ▁-> ▁extradata _ size ▁= ▁10 ▁; ▁AV _ WL 32 ▁( ▁extradata ▁, ▁flags 1 ▁) ▁; ▁AV _ WL 16 ▁( ▁extradata ▁+ ▁4 ▁, ▁flags 2 ▁) ▁; ▁} ▁else ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁avctx ▁-> ▁extradata ▁= ▁extradata ▁; ▁s ▁-> ▁use _ exp _ vlc ▁= ▁flags 2 ▁& ▁0 x 0001 ▁; ▁s ▁-> ▁use _ bit _ re serv o ir ▁= ▁flags 2 ▁& ▁0 x 0002 ▁; ▁s ▁-> ▁use _ variable _ block _ len ▁= ▁flags 2 ▁& ▁0 x 0004 ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁== ▁2 ▁) ▁s ▁-> ▁ms _ stereo ▁= ▁1 ▁; ▁ff _ w ma _ init ▁( ▁avctx ▁, ▁flags 2 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ block _ sizes ▁; ▁i ▁++ ▁) ▁ff _ md ct _ init ▁( ▁& ▁s ▁-> ▁md ct _ ctx ▁[ ▁i ▁] ▁, ▁s ▁-> ▁frame _ len _ bits ▁- ▁i ▁+ ▁1 ▁, ▁0 ▁, ▁1.0 ▁) ▁; ▁s ▁-> ▁block _ align ▁= ▁avctx ▁-> ▁bit _ rate ▁* ▁( ▁int 64_ t ▁) ▁s ▁-> ▁frame _ len ▁/ ▁( ▁avctx ▁-> ▁sample _ rate ▁* ▁8 ▁) ▁; ▁s ▁-> ▁block _ align ▁= ▁FF MIN ▁( ▁s ▁-> ▁block _ align ▁, ▁MAX _ CODED _ SUPER FRAME _ SIZE ▁) ▁; ▁avctx ▁-> ▁block _ align ▁= ▁s ▁-> ▁block _ align ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁avctx ▁-> ▁block _ align ▁* ▁8 LL ▁* ▁avctx ▁-> ▁sample _ rate ▁/ ▁s ▁-> ▁frame _ len ▁; ▁avctx ▁-> ▁frame _ size ▁= ▁avctx ▁-> ▁delay ▁= ▁s ▁-> ▁frame _ len ▁; ▁# if ▁FF _ API _ OLD _ ENCODE _ AUDIO ▁avctx ▁-> ▁coded _ frame ▁= ▁& ▁s ▁-> ▁frame ▁; ▁avcodec _ get _ frame _ defaults ▁( ▁avctx ▁-> ▁coded _ frame ▁) ▁; ▁# endif ▁return ▁0 ▁; ▁}	1
▁OPENSSL _ STACK ▁* ▁OPENSSL _ sk _ dup ▁( ▁const ▁OPENSSL _ STACK ▁* ▁sk ▁) ▁{ ▁OPENSSL _ STACK ▁* ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁ret ▁) ▁) ▁) ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁* ▁ret ▁= ▁* ▁sk ▁; ▁if ▁( ▁sk ▁-> ▁num ▁== ▁0 ▁) ▁{ ▁ret ▁-> ▁data ▁= ▁NULL ▁; ▁ret ▁-> ▁num _ alloc ▁= ▁0 ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁data ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁ret ▁-> ▁data ▁) ▁* ▁sk ▁-> ▁num _ alloc ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁memcpy ▁( ▁ret ▁-> ▁data ▁, ▁sk ▁-> ▁data ▁, ▁sizeof ▁( ▁void ▁* ▁) ▁* ▁sk ▁-> ▁num ▁) ▁; ▁return ▁ret ▁; ▁err ▁: ▁OPENSSL _ sk _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁int ▁do _ re voke ▁( ▁X 509 ▁* ▁x 509 ▁, ▁CA _ DB ▁* ▁db ▁, ▁int ▁type ▁, ▁char ▁* ▁value ▁) ▁{ ▁ASN 1_ UTC TIME ▁* ▁tm ▁= ▁NULL ▁; ▁char ▁* ▁row ▁[ ▁DB _ NUMBER ▁] ▁, ▁* ▁* ▁r row ▁, ▁* ▁* ▁i row ▁; ▁char ▁* ▁rev _ str ▁= ▁NULL ▁; ▁BIGNUM ▁* ▁bn ▁= ▁NULL ▁; ▁int ▁ok ▁= ▁-1 ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁DB _ NUMBER ▁; ▁i ▁++ ▁) ▁row ▁[ ▁i ▁] ▁= ▁NULL ▁; ▁row ▁[ ▁DB _ name ▁] ▁= ▁X 509_ NAME _ on eline ▁( ▁X 509_ get _ subject _ name ▁( ▁x 509 ▁) ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁bn ▁= ▁ASN 1_ INTEGER _ to _ BN ▁( ▁X 509_ get _ serial Number ▁( ▁x 509 ▁) ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁bn ▁) ▁goto ▁end ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁bn ▁) ▁) ▁row ▁[ ▁DB _ serial ▁] ▁= ▁OPENSSL _ strdup ▁( ▁" 00" ▁) ▁; ▁else ▁row ▁[ ▁DB _ serial ▁] ▁= ▁BN _ bn 2 hex ▁( ▁bn ▁) ▁; ▁BN _ free ▁( ▁bn ▁) ▁; ▁if ▁( ▁( ▁row ▁[ ▁DB _ name ▁] ▁== ▁NULL ▁) ▁|| ▁( ▁row ▁[ ▁DB _ serial ▁] ▁== ▁NULL ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Memory allocation failure \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁r row ▁= ▁TXT _ DB _ get _ by _ index ▁( ▁db ▁-> ▁db ▁, ▁DB _ serial ▁, ▁row ▁) ▁; ▁if ▁( ▁r row ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Adding Entry with serial number % sto DB for % s \ n " ▁, ▁row ▁[ ▁DB _ serial ▁] ▁, ▁row ▁[ ▁DB _ name ▁] ▁) ▁; ▁row ▁[ ▁DB _ type ▁] ▁= ▁OPENSSL _ strdup ▁( ▁" V " ▁) ▁; ▁tm ▁= ▁X 509_ get _ not After ▁( ▁x 509 ▁) ▁; ▁row ▁[ ▁DB _ exp _ date ▁] ▁= ▁app _ malloc ▁( ▁tm ▁-> ▁length ▁+ ▁1 ▁, ▁" row exp _ data " ▁) ▁; ▁memcpy ▁( ▁row ▁[ ▁DB _ exp _ date ▁] ▁, ▁tm ▁-> ▁data ▁, ▁tm ▁-> ▁length ▁) ▁; ▁row ▁[ ▁DB _ exp _ date ▁] ▁[ ▁tm ▁-> ▁length ▁] ▁= ▁' ▁\0 ▁' ▁; ▁row ▁[ ▁DB _ rev _ date ▁] ▁= ▁NULL ▁; ▁row ▁[ ▁DB _ file ▁] ▁= ▁OPENSSL _ strdup ▁( ▁" unknown " ▁) ▁; ▁i row ▁= ▁app _ malloc ▁( ▁sizeof ▁( ▁* ▁i row ▁) ▁* ▁( ▁DB _ NUMBER ▁+ ▁1 ▁) ▁, ▁" row ptr " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁DB _ NUMBER ▁; ▁i ▁++ ▁) ▁{ ▁i row ▁[ ▁i ▁] ▁= ▁row ▁[ ▁i ▁] ▁; ▁row ▁[ ▁i ▁] ▁= ▁NULL ▁; ▁} ▁i row ▁[ ▁DB _ NUMBER ▁] ▁= ▁NULL ▁; ▁if ▁( ▁! ▁TXT _ DB _ insert ▁( ▁db ▁-> ▁db ▁, ▁i row ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" failed tou pd ated atabase \ n " ▁) ▁; ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" TXT _ DB error number % ld \ n " ▁, ▁db ▁-> ▁db ▁-> ▁error ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁type ▁== ▁-1 ▁) ▁ok ▁= ▁1 ▁; ▁else ▁ok ▁= ▁do _ re voke ▁( ▁x 509 ▁, ▁db ▁, ▁type ▁, ▁value ▁) ▁; ▁goto ▁end ▁; ▁} ▁else ▁if ▁( ▁index _ name _ cmp _ n ocon st ▁( ▁row ▁, ▁r row ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" ERROR : named oes not match % s \ n " ▁, ▁row ▁[ ▁DB _ name ▁] ▁) ▁; ▁goto ▁end ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁-1 ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" ERROR : Already present , serial number % s \ n " ▁, ▁row ▁[ ▁DB _ serial ▁] ▁) ▁; ▁goto ▁end ▁; ▁} ▁else ▁if ▁( ▁r row ▁[ ▁DB _ type ▁] ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" ERROR : Already re voked , serial number % s \ n " ▁, ▁row ▁[ ▁DB _ serial ▁] ▁) ▁; ▁goto ▁end ▁; ▁} ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Re vok ing Certificate % s .\ n " ▁, ▁r row ▁[ ▁DB _ serial ▁] ▁) ▁; ▁rev _ str ▁= ▁make _ re vocation _ str ▁( ▁type ▁, ▁value ▁) ▁; ▁if ▁( ▁! ▁rev _ str ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Error in re vocation arguments \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁r row ▁[ ▁DB _ type ▁] ▁[ ▁0 ▁] ▁= ▁' ▁' ▁; ▁r row ▁[ ▁DB _ type ▁] ▁[ ▁1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁r row ▁[ ▁DB _ rev _ date ▁] ▁= ▁rev _ str ▁; ▁} ▁ok ▁= ▁1 ▁; ▁end ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁DB _ NUMBER ▁; ▁i ▁++ ▁) ▁{ ▁OPENSSL _ free ▁( ▁row ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁( ▁ok ▁) ▁; ▁}	0
▁static ▁void ▁new _ video _ stream ▁( ▁AVFormatContext ▁* ▁oc ▁, ▁int ▁file _ idx ▁) ▁{ ▁AVStream ▁* ▁st ▁; ▁AV OutputStream ▁* ▁o st ▁; ▁AVCodecContext ▁* ▁video _ enc ▁; ▁enum ▁Codec ID ▁codec _ id ▁; ▁AVCodec ▁* ▁codec ▁= ▁NULL ▁; ▁st ▁= ▁av _ new _ stream ▁( ▁oc ▁, ▁oc ▁-> ▁nb _ streams ▁< ▁nb _ stream id _ map ▁? ▁stream id _ map ▁[ ▁oc ▁-> ▁nb _ streams ▁] ▁: ▁0 ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Could not alloc stream \ n " ▁) ▁; ▁ffmpeg _ exit ▁( ▁1 ▁) ▁; ▁} ▁o st ▁= ▁new _ output _ stream ▁( ▁oc ▁, ▁file _ idx ▁) ▁; ▁output _ codecs ▁= ▁grow _ array ▁( ▁output _ codecs ▁, ▁sizeof ▁( ▁* ▁output _ codecs ▁) ▁, ▁& ▁nb _ output _ codecs ▁, ▁nb _ output _ codecs ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁video _ stream _ copy ▁) ▁{ ▁if ▁( ▁video _ codec _ name ▁) ▁{ ▁codec _ id ▁= ▁find _ codec _ or _ die ▁( ▁video _ codec _ name ▁, ▁AVMEDIA _ TYPE _ VIDEO ▁, ▁1 ▁, ▁avcodec _ opts ▁[ ▁AVMEDIA _ TYPE _ VIDEO ▁] ▁-> ▁strict _ std _ comp liance ▁) ▁; ▁codec ▁= ▁avcodec _ find _ encoder _ by _ name ▁( ▁video _ codec _ name ▁) ▁; ▁output _ codecs ▁[ ▁nb _ output _ codecs ▁- ▁1 ▁] ▁= ▁codec ▁; ▁} ▁else ▁{ ▁codec _ id ▁= ▁av _ guess _ codec ▁( ▁oc ▁-> ▁of orm at ▁, ▁NULL ▁, ▁oc ▁-> ▁filename ▁, ▁NULL ▁, ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁; ▁codec ▁= ▁avcodec _ find _ encoder ▁( ▁codec _ id ▁) ▁; ▁} ▁} ▁avcodec _ get _ context _ defaults 3 ▁( ▁st ▁-> ▁codec ▁, ▁codec ▁) ▁; ▁o st ▁-> ▁bitstream _ filters ▁= ▁video _ bit stream _ filters ▁; ▁video _ bit stream _ filters ▁= ▁NULL ▁; ▁avcodec _ thread _ init ▁( ▁st ▁-> ▁codec ▁, ▁thread _ count ▁) ▁; ▁video _ enc ▁= ▁st ▁-> ▁codec ▁; ▁if ▁( ▁video _ codec _ tag ▁) ▁video _ enc ▁-> ▁codec _ tag ▁= ▁video _ codec _ tag ▁; ▁if ▁( ▁( ▁video _ global _ header ▁& ▁1 ▁) ▁|| ▁( ▁video _ global _ header ▁== ▁0 ▁&& ▁( ▁oc ▁-> ▁of orm at ▁-> ▁flags ▁& ▁AV FMT _ GLOBAL HEADER ▁) ▁) ▁) ▁{ ▁video _ enc ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ GLOBAL _ HEADER ▁; ▁avcodec _ opts ▁[ ▁AVMEDIA _ TYPE _ VIDEO ▁] ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ GLOBAL _ HEADER ▁; ▁} ▁if ▁( ▁video _ global _ header ▁& ▁2 ▁) ▁{ ▁video _ enc ▁-> ▁flags 2 ▁|= ▁CODEC _ FLAG 2_ LOCAL _ HEADER ▁; ▁avcodec _ opts ▁[ ▁AVMEDIA _ TYPE _ VIDEO ▁] ▁-> ▁flags 2 ▁|= ▁CODEC _ FLAG 2_ LOCAL _ HEADER ▁; ▁} ▁if ▁( ▁video _ stream _ copy ▁) ▁{ ▁st ▁-> ▁stream _ copy ▁= ▁1 ▁; ▁video _ enc ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ VIDEO ▁; ▁video _ enc ▁-> ▁sample _ aspect _ ratio ▁= ▁st ▁-> ▁sample _ aspect _ ratio ▁= ▁av _ d 2 q ▁( ▁frame _ aspect _ ratio ▁* ▁frame _ height ▁/ ▁frame _ width ▁, ▁255 ▁) ▁; ▁} ▁else ▁{ ▁const ▁char ▁* ▁p ▁; ▁int ▁i ▁; ▁AVR ational ▁fps ▁= ▁frame _ rate ▁. ▁num ▁? ▁frame _ rate ▁: ▁( ▁AVR ational ▁) ▁{ ▁25 ▁, ▁1 ▁} ▁; ▁video _ enc ▁-> ▁codec _ id ▁= ▁codec _ id ▁; ▁set _ context _ opts ▁( ▁video _ enc ▁, ▁avcodec _ opts ▁[ ▁AVMEDIA _ TYPE _ VIDEO ▁] ▁, ▁AV _ OPT _ FLAG _ VIDEO _ PARAM ▁| ▁AV _ OPT _ FLAG _ ENCODING _ PARAM ▁, ▁codec ▁) ▁; ▁if ▁( ▁codec ▁&& ▁codec ▁-> ▁supported _ f ram er ates ▁&& ▁! ▁force _ fps ▁) ▁fps ▁= ▁codec ▁-> ▁supported _ f ram er ates ▁[ ▁av _ find _ ne arest _ q _ idx ▁( ▁fps ▁, ▁codec ▁-> ▁supported _ f ram er ates ▁) ▁] ▁; ▁video _ enc ▁-> ▁time _ base ▁. ▁den ▁= ▁fps ▁. ▁num ▁; ▁video _ enc ▁-> ▁time _ base ▁. ▁num ▁= ▁fps ▁. ▁den ▁; ▁video _ enc ▁-> ▁width ▁= ▁frame _ width ▁; ▁video _ enc ▁-> ▁height ▁= ▁frame _ height ▁; ▁video _ enc ▁-> ▁sample _ aspect _ ratio ▁= ▁av _ d 2 q ▁( ▁frame _ aspect _ ratio ▁* ▁video _ enc ▁-> ▁height ▁/ ▁video _ enc ▁-> ▁width ▁, ▁255 ▁) ▁; ▁video _ enc ▁-> ▁pix _ fmt ▁= ▁frame _ pix _ fmt ▁; ▁st ▁-> ▁sample _ aspect _ ratio ▁= ▁video _ enc ▁-> ▁sample _ aspect _ ratio ▁; ▁choose _ pixel _ fmt ▁( ▁st ▁, ▁codec ▁) ▁; ▁if ▁( ▁in tra _ only ▁) ▁video _ enc ▁-> ▁g op _ size ▁= ▁0 ▁; ▁if ▁( ▁video _ q scale ▁|| ▁same _ quality ▁) ▁{ ▁video _ enc ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ Q SCALE ▁; ▁video _ enc ▁-> ▁global _ quality ▁= ▁st ▁-> ▁quality ▁= ▁FF _ QP 2 L AMBDA ▁* ▁video _ q scale ▁; ▁} ▁if ▁( ▁in tra _ matrix ▁) ▁video _ enc ▁-> ▁in tra _ matrix ▁= ▁in tra _ matrix ▁; ▁if ▁( ▁inter _ matrix ▁) ▁video _ enc ▁-> ▁inter _ matrix ▁= ▁inter _ matrix ▁; ▁p ▁= ▁video _ rc _ override _ string ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁p ▁; ▁i ▁++ ▁) ▁{ ▁int ▁start ▁, ▁end ▁, ▁q ▁; ▁int ▁e ▁= ▁sscanf ▁( ▁p ▁, ▁"% d ,% d ,% d " ▁, ▁& ▁start ▁, ▁& ▁end ▁, ▁& ▁q ▁) ▁; ▁if ▁( ▁e ▁!= ▁3 ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" error parsing rc _ override \ n " ▁) ▁; ▁ffmpeg _ exit ▁( ▁1 ▁) ▁; ▁} ▁video _ enc ▁-> ▁rc _ override ▁= ▁av _ realloc ▁( ▁video _ enc ▁-> ▁rc _ override ▁, ▁sizeof ▁( ▁R c Override ▁) ▁* ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁video _ enc ▁-> ▁rc _ override ▁[ ▁i ▁] ▁. ▁start _ frame ▁= ▁start ▁; ▁video _ enc ▁-> ▁rc _ override ▁[ ▁i ▁] ▁. ▁end _ frame ▁= ▁end ▁; ▁if ▁( ▁q ▁> ▁0 ▁) ▁{ ▁video _ enc ▁-> ▁rc _ override ▁[ ▁i ▁] ▁. ▁q scale ▁= ▁q ▁; ▁video _ enc ▁-> ▁rc _ override ▁[ ▁i ▁] ▁. ▁quality _ factor ▁= ▁1.0 ▁; ▁} ▁else ▁{ ▁video _ enc ▁-> ▁rc _ override ▁[ ▁i ▁] ▁. ▁q scale ▁= ▁0 ▁; ▁video _ enc ▁-> ▁rc _ override ▁[ ▁i ▁] ▁. ▁quality _ factor ▁= ▁- ▁q ▁/ ▁100.0 ▁; ▁} ▁p ▁= ▁strchr ▁( ▁p ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁p ▁) ▁p ▁++ ▁; ▁} ▁video _ enc ▁-> ▁rc _ override _ count ▁= ▁i ▁; ▁if ▁( ▁! ▁video _ enc ▁-> ▁rc _ initial _ buffer _ occ upancy ▁) ▁video _ enc ▁-> ▁rc _ initial _ buffer _ occ upancy ▁= ▁video _ enc ▁-> ▁rc _ buffer _ size ▁* ▁3 ▁/ ▁4 ▁; ▁video _ enc ▁-> ▁me _ threshold ▁= ▁me _ threshold ▁; ▁video _ enc ▁-> ▁in tra _ dc _ precision ▁= ▁in tra _ dc _ precision ▁- ▁8 ▁; ▁if ▁( ▁do _ ps nr ▁) ▁video _ enc ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ PS NR ▁; ▁if ▁( ▁do _ pass ▁) ▁{ ▁if ▁( ▁do _ pass ▁== ▁1 ▁) ▁{ ▁video _ enc ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ PASS 1 ▁; ▁} ▁else ▁{ ▁video _ enc ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ PASS 2 ▁; ▁} ▁} ▁if ▁( ▁forced _ key _ frames ▁) ▁parse _ forced _ key _ frames ▁( ▁forced _ key _ frames ▁, ▁o st ▁, ▁video _ enc ▁) ▁; ▁} ▁if ▁( ▁video _ language ▁) ▁{ ▁av _ metadata _ set 2 ▁( ▁& ▁st ▁-> ▁metadata ▁, ▁" language " ▁, ▁video _ language ▁, ▁0 ▁) ▁; ▁av _ freep ▁( ▁& ▁video _ language ▁) ▁; ▁} ▁video _ disable ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁video _ codec _ name ▁) ▁; ▁av _ freep ▁( ▁& ▁forced _ key _ frames ▁) ▁; ▁video _ stream _ copy ▁= ▁0 ▁; ▁frame _ pix _ fmt ▁= ▁PIX _ FMT _ NONE ▁; ▁}	1
▁static ▁inline ▁int ▁ff _ insert _ in pad ▁( ▁AVFilter Context ▁* ▁f ▁, ▁unsigned ▁index ▁, ▁AVFilter Pad ▁* ▁p ▁) ▁{ ▁int ▁ret ▁= ▁ff _ insert _ pad ▁( ▁index ▁, ▁& ▁f ▁-> ▁nb _ inputs ▁, ▁offsetof ▁( ▁AVFilter Link ▁, ▁dst pad ▁) ▁, ▁& ▁f ▁-> ▁input _ pads ▁, ▁& ▁f ▁-> ▁inputs ▁, ▁p ▁) ▁; ▁# if ▁FF _ API _ FOO _ COUNT ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁f ▁-> ▁input _ count ▁= ▁f ▁-> ▁nb _ inputs ▁; ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁# endif ▁return ▁ret ▁; ▁}	0
▁int ▁BN _ add _ word ▁( ▁BIGNUM ▁* ▁a ▁, ▁BN _ ULONG ▁w ▁) ▁{ ▁BN _ ULONG ▁l ▁; ▁int ▁i ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁w ▁&= ▁BN _ MASK 2 ▁; ▁if ▁( ▁! ▁w ▁) ▁return ▁1 ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁a ▁) ▁) ▁return ▁BN _ set _ word ▁( ▁a ▁, ▁w ▁) ▁; ▁if ▁( ▁a ▁-> ▁neg ▁) ▁{ ▁a ▁-> ▁neg ▁= ▁0 ▁; ▁i ▁= ▁BN _ sub _ word ▁( ▁a ▁, ▁w ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ zero ▁( ▁a ▁) ▁) ▁a ▁-> ▁neg ▁= ▁! ▁( ▁a ▁-> ▁neg ▁) ▁; ▁return ▁( ▁i ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁w ▁!= ▁0 ▁&& ▁i ▁< ▁a ▁-> ▁top ▁; ▁i ▁++ ▁) ▁{ ▁a ▁-> ▁d ▁[ ▁i ▁] ▁= ▁l ▁= ▁( ▁a ▁-> ▁d ▁[ ▁i ▁] ▁+ ▁w ▁) ▁& ▁BN _ MASK 2 ▁; ▁w ▁= ▁( ▁w ▁> ▁l ▁) ▁? ▁1 ▁: ▁0 ▁; ▁} ▁if ▁( ▁w ▁&& ▁i ▁== ▁a ▁-> ▁top ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁a ▁, ▁a ▁-> ▁top ▁+ ▁1 ▁) ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁a ▁-> ▁top ▁++ ▁; ▁a ▁-> ▁d ▁[ ▁i ▁] ▁= ▁w ▁; ▁} ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	0
▁static ▁int ▁ready _ code book ▁( ▁vorbis _ enc _ code book ▁* ▁cb ▁) ▁{ ▁int ▁i ▁; ▁ff _ vorbis _ len 2 vlc ▁( ▁cb ▁-> ▁lens ▁, ▁cb ▁-> ▁code words ▁, ▁cb ▁-> ▁n entries ▁) ▁; ▁if ▁( ▁! ▁cb ▁-> ▁lookup ▁) ▁{ ▁cb ▁-> ▁pow 2 ▁= ▁cb ▁-> ▁dim entions ▁= ▁NULL ▁; ▁} ▁else ▁{ ▁int ▁vals ▁= ▁cb _ lookup _ vals ▁( ▁cb ▁-> ▁lookup ▁, ▁cb ▁-> ▁ndim entions ▁, ▁cb ▁-> ▁n entries ▁) ▁; ▁cb ▁-> ▁dim entions ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁float ▁) ▁* ▁cb ▁-> ▁n entries ▁* ▁cb ▁-> ▁ndim entions ▁) ▁; ▁cb ▁-> ▁pow 2 ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁float ▁) ▁* ▁cb ▁-> ▁n entries ▁) ▁; ▁if ▁( ▁! ▁cb ▁-> ▁dim entions ▁|| ▁! ▁cb ▁-> ▁pow 2 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁cb ▁-> ▁n entries ▁; ▁i ▁++ ▁) ▁{ ▁float ▁last ▁= ▁0 ▁; ▁int ▁j ▁; ▁int ▁div ▁= ▁1 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁cb ▁-> ▁ndim entions ▁; ▁j ▁++ ▁) ▁{ ▁int ▁off ▁; ▁if ▁( ▁cb ▁-> ▁lookup ▁== ▁1 ▁) ▁off ▁= ▁( ▁i ▁/ ▁div ▁) ▁% ▁vals ▁; ▁else ▁off ▁= ▁i ▁* ▁cb ▁-> ▁ndim entions ▁+ ▁j ▁; ▁cb ▁-> ▁dim entions ▁[ ▁i ▁* ▁cb ▁-> ▁ndim entions ▁+ ▁j ▁] ▁= ▁last ▁+ ▁cb ▁-> ▁min ▁+ ▁cb ▁-> ▁quant list ▁[ ▁off ▁] ▁* ▁cb ▁-> ▁delta ▁; ▁if ▁( ▁cb ▁-> ▁seq _ p ▁) ▁last ▁= ▁cb ▁-> ▁dim entions ▁[ ▁i ▁* ▁cb ▁-> ▁ndim entions ▁+ ▁j ▁] ▁; ▁cb ▁-> ▁pow 2 ▁[ ▁i ▁] ▁+= ▁cb ▁-> ▁dim entions ▁[ ▁i ▁* ▁cb ▁-> ▁ndim entions ▁+ ▁j ▁] ▁* ▁cb ▁-> ▁dim entions ▁[ ▁i ▁* ▁cb ▁-> ▁ndim entions ▁+ ▁j ▁] ▁; ▁div ▁*= ▁vals ▁; ▁} ▁cb ▁-> ▁pow 2 ▁[ ▁i ▁] ▁/= ▁2. ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁final ▁( ▁const ▁short ▁* ▁i 1 ▁, ▁const ▁short ▁* ▁i 2 ▁, ▁void ▁* ▁out ▁, ▁int ▁* ▁statbuf ▁, ▁int ▁len ▁) ▁{ ▁int ▁x ▁, ▁i ▁; ▁unsigned ▁short ▁int ▁work ▁[ ▁50 ▁] ▁; ▁short ▁* ▁ptr ▁= ▁work ▁; ▁memcpy ▁( ▁work ▁, ▁statbuf ▁, ▁20 ▁) ▁; ▁memcpy ▁( ▁work ▁+ ▁10 ▁, ▁i 2 ▁, ▁len ▁* ▁2 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sum ▁= ▁0 ▁; ▁int ▁new _ val ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁10 ▁; ▁x ▁++ ▁) ▁sum ▁+= ▁i 1 ▁[ ▁9 ▁- ▁x ▁] ▁* ▁ptr ▁[ ▁x ▁] ▁; ▁sum ▁>>= ▁12 ▁; ▁new _ val ▁= ▁ptr ▁[ ▁10 ▁] ▁- ▁sum ▁; ▁if ▁( ▁new _ val ▁< ▁-32 768 ▁|| ▁new _ val ▁> ▁32767 ▁) ▁{ ▁memset ▁( ▁out ▁, ▁0 ▁, ▁len ▁* ▁2 ▁) ▁; ▁memset ▁( ▁statbuf ▁, ▁0 ▁, ▁20 ▁) ▁; ▁return ▁; ▁} ▁ptr ▁[ ▁10 ▁] ▁= ▁new _ val ▁; ▁ptr ▁++ ▁; ▁} ▁memcpy ▁( ▁out ▁, ▁work ▁+ ▁10 ▁, ▁len ▁* ▁2 ▁) ▁; ▁memcpy ▁( ▁statbuf ▁, ▁work ▁+ ▁40 ▁, ▁20 ▁) ▁; ▁}	0
▁int ▁ff v 1_ init _ slice _ contexts ▁( ▁FF V 1 Context ▁* ▁f ▁) ▁{ ▁int ▁i ▁; ▁f ▁-> ▁slice _ count ▁= ▁f ▁-> ▁num _ h _ s lices ▁* ▁f ▁-> ▁num _ v _ s lices ▁; ▁if ▁( ▁f ▁-> ▁slice _ count ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid number ofs lices \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁f ▁-> ▁slice _ count ▁; ▁i ▁++ ▁) ▁{ ▁FF V 1 Context ▁* ▁fs ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁fs ▁) ▁) ▁; ▁int ▁sx ▁= ▁i ▁% ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁sy ▁= ▁i ▁/ ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁s xs ▁= ▁f ▁-> ▁avctx ▁-> ▁width ▁* ▁sx ▁/ ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁s xe ▁= ▁f ▁-> ▁avctx ▁-> ▁width ▁* ▁( ▁sx ▁+ ▁1 ▁) ▁/ ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁sys ▁= ▁f ▁-> ▁avctx ▁-> ▁height ▁* ▁sy ▁/ ▁f ▁-> ▁num _ v _ s lices ▁; ▁int ▁sy e ▁= ▁f ▁-> ▁avctx ▁-> ▁height ▁* ▁( ▁sy ▁+ ▁1 ▁) ▁/ ▁f ▁-> ▁num _ v _ s lices ▁; ▁f ▁-> ▁slice _ context ▁[ ▁i ▁] ▁= ▁fs ▁; ▁memcpy ▁( ▁fs ▁, ▁f ▁, ▁sizeof ▁( ▁* ▁fs ▁) ▁) ▁; ▁memset ▁( ▁fs ▁-> ▁rc _ stat 2 ▁, ▁0 ▁, ▁sizeof ▁( ▁fs ▁-> ▁rc _ stat 2 ▁) ▁) ▁; ▁fs ▁-> ▁slice _ width ▁= ▁s xe ▁- ▁s xs ▁; ▁fs ▁-> ▁slice _ height ▁= ▁sy e ▁- ▁sys ▁; ▁fs ▁-> ▁slice _ x ▁= ▁s xs ▁; ▁fs ▁-> ▁slice _ y ▁= ▁sys ▁; ▁fs ▁-> ▁sample _ buffer ▁= ▁av _ malloc ▁( ▁3 ▁* ▁MAX _ PLAN ES ▁* ▁( ▁fs ▁-> ▁width ▁+ ▁6 ▁) ▁* ▁sizeof ▁( ▁* ▁fs ▁-> ▁sample _ buffer ▁) ▁) ▁; ▁if ▁( ▁! ▁fs ▁-> ▁sample _ buffer ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁poll _ filters ▁( ▁void ▁) ▁{ ▁AVFilter Buffer Ref ▁* ▁pic ref ▁; ▁AVFrame ▁* ▁filtered _ frame ▁= ▁NULL ▁; ▁int ▁i ▁, ▁frame _ size ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁OutputFile ▁* ▁of ▁= ▁output _ files ▁[ ▁o st ▁-> ▁file _ index ▁] ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁! ▁o st ▁-> ▁filter ▁|| ▁o st ▁-> ▁is _ p ast _ recording _ time ▁) ▁continue ▁; ▁if ▁( ▁! ▁o st ▁-> ▁filtered _ frame ▁&& ▁! ▁( ▁o st ▁-> ▁filtered _ frame ▁= ▁avcodec _ alloc _ frame ▁( ▁) ▁) ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁else ▁avcodec _ get _ frame _ defaults ▁( ▁o st ▁-> ▁filtered _ frame ▁) ▁; ▁filtered _ frame ▁= ▁o st ▁-> ▁filtered _ frame ▁; ▁while ▁( ▁ret ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁o st ▁-> ▁enc ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁! ▁( ▁o st ▁-> ▁enc ▁-> ▁capabilities ▁& ▁CODEC _ CAP _ VARIABLE _ FRAME _ SIZE ▁) ▁) ▁ret ▁= ▁av _ buffers ink _ read _ samples ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁frame _ size ▁) ▁; ▁else ▁ret ▁= ▁av _ buffers ink _ read ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁break ▁; ▁avfilter _ copy _ buf _ props ▁( ▁filtered _ frame ▁, ▁pic ref ▁) ▁; ▁if ▁( ▁o st ▁-> ▁enc ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁filtered _ frame ▁-> ▁pts ▁= ▁av _ re scale _ q ▁( ▁pic ref ▁-> ▁pts ▁, ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁else ▁if ▁( ▁pic ref ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁filtered _ frame ▁-> ▁pts ▁= ▁av _ re scale _ q ▁( ▁pic ref ▁-> ▁pts ▁, ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁time _ base ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁) ▁- ▁av _ re scale _ q ▁( ▁of ▁-> ▁start _ time ▁, ▁AV _ TIME _ BASE _ Q ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁) ▁; ▁if ▁( ▁of ▁-> ▁start _ time ▁&& ▁filtered _ frame ▁-> ▁pts ▁< ▁of ▁-> ▁start _ time ▁) ▁return ▁0 ▁; ▁switch ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁if ▁( ▁! ▁o st ▁-> ▁frame _ aspect _ ratio ▁) ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁sample _ aspect _ ratio ▁= ▁pic ref ▁-> ▁video ▁-> ▁pixel _ aspect ▁; ▁do _ video _ out ▁( ▁of ▁-> ▁ctx ▁, ▁o st ▁, ▁filtered _ frame ▁, ▁& ▁frame _ size ▁, ▁same _ quant ▁? ▁o st ▁-> ▁last _ quality ▁: ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁global _ quality ▁) ▁; ▁if ▁( ▁v stats _ filename ▁&& ▁frame _ size ▁) ▁do _ video _ stats ▁( ▁of ▁-> ▁ctx ▁, ▁o st ▁, ▁frame _ size ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁do _ audio _ out ▁( ▁of ▁-> ▁ctx ▁, ▁o st ▁, ▁filtered _ frame ▁) ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁} ▁avfilter _ unref _ buffer ▁( ▁pic ref ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁inline ▁int ▁ff _ fast _ malloc ▁( ▁void ▁* ▁ptr ▁, ▁unsigned ▁int ▁* ▁size ▁, ▁size _ t ▁min _ size ▁, ▁int ▁zero _ realloc ▁) ▁{ ▁void ▁* ▁val ▁; ▁memcpy ▁( ▁& ▁val ▁, ▁ptr ▁, ▁sizeof ▁( ▁val ▁) ▁) ▁; ▁if ▁( ▁min _ size ▁<= ▁* ▁size ▁) ▁{ ▁av _ assert 0 ▁( ▁val ▁|| ▁! ▁min _ size ▁) ▁; ▁return ▁0 ▁; ▁} ▁min _ size ▁= ▁FF MAX ▁( ▁min _ size ▁+ ▁min _ size ▁/ ▁16 ▁+ ▁32 ▁, ▁min _ size ▁) ▁; ▁av _ freep ▁( ▁ptr ▁) ▁; ▁val ▁= ▁zero _ realloc ▁? ▁av _ malloc z ▁( ▁min _ size ▁) ▁: ▁av _ malloc ▁( ▁min _ size ▁) ▁; ▁memcpy ▁( ▁ptr ▁, ▁& ▁val ▁, ▁sizeof ▁( ▁val ▁) ▁) ▁; ▁if ▁( ▁! ▁val ▁) ▁min _ size ▁= ▁0 ▁; ▁* ▁size ▁= ▁min _ size ▁; ▁return ▁1 ▁; ▁}	1
▁void ▁TIFF Reverse Bits ▁( ▁uint 8 ▁* ▁cp ▁, ▁tm size _ t ▁n ▁) ▁{ ▁for ▁( ▁; ▁n ▁> ▁8 ▁; ▁n ▁-= ▁8 ▁) ▁{ ▁cp ▁[ ▁0 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁0 ▁] ▁] ▁; ▁cp ▁[ ▁1 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁1 ▁] ▁] ▁; ▁cp ▁[ ▁2 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁2 ▁] ▁] ▁; ▁cp ▁[ ▁3 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁3 ▁] ▁] ▁; ▁cp ▁[ ▁4 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁4 ▁] ▁] ▁; ▁cp ▁[ ▁5 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁5 ▁] ▁] ▁; ▁cp ▁[ ▁6 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁6 ▁] ▁] ▁; ▁cp ▁[ ▁7 ▁] ▁= ▁TIFF BitRevTable ▁[ ▁cp ▁[ ▁7 ▁] ▁] ▁; ▁cp ▁+= ▁8 ▁; ▁} ▁while ▁( ▁n ▁-- ▁> ▁0 ▁) ▁{ ▁* ▁cp ▁= ▁TIFF BitRevTable ▁[ ▁* ▁cp ▁] ▁; ▁cp ▁++ ▁; ▁} ▁}	1
▁static ▁int ▁encode _ alpha _ plane ▁( ▁Pro res Context ▁* ▁ctx ▁, ▁Put Bit Context ▁* ▁pb ▁, ▁int ▁mbs _ per _ slice ▁, ▁uint 16_ t ▁* ▁blocks ▁, ▁int ▁quant ▁) ▁{ ▁const ▁int ▁ab its ▁= ▁ctx ▁-> ▁alpha _ bits ▁; ▁const ▁int ▁mask ▁= ▁( ▁1 ▁<< ▁ab its ▁) ▁- ▁1 ▁; ▁const ▁int ▁num _ coeffs ▁= ▁mbs _ per _ slice ▁* ▁256 ▁; ▁int ▁saved _ pos ▁= ▁put _ bits _ count ▁( ▁pb ▁) ▁; ▁int ▁prev ▁= ▁mask ▁, ▁cur ▁; ▁int ▁idx ▁= ▁0 ▁; ▁int ▁run ▁= ▁0 ▁; ▁cur ▁= ▁blocks ▁[ ▁idx ▁++ ▁] ▁; ▁put _ alpha _ diff ▁( ▁pb ▁, ▁cur ▁, ▁prev ▁, ▁ab its ▁) ▁; ▁prev ▁= ▁cur ▁; ▁do ▁{ ▁cur ▁= ▁blocks ▁[ ▁idx ▁++ ▁] ▁; ▁if ▁( ▁cur ▁!= ▁prev ▁) ▁{ ▁put _ alpha _ run ▁( ▁pb ▁, ▁run ▁) ▁; ▁put _ alpha _ diff ▁( ▁pb ▁, ▁cur ▁, ▁prev ▁, ▁ab its ▁) ▁; ▁prev ▁= ▁cur ▁; ▁run ▁= ▁0 ▁; ▁} ▁else ▁{ ▁run ▁++ ▁; ▁} ▁} ▁while ▁( ▁idx ▁< ▁num _ coeffs ▁) ▁; ▁if ▁( ▁run ▁) ▁put _ alpha _ run ▁( ▁pb ▁, ▁run ▁) ▁; ▁flush _ put _ bits ▁( ▁pb ▁) ▁; ▁return ▁( ▁put _ bits _ count ▁( ▁pb ▁) ▁- ▁saved _ pos ▁) ▁>> ▁3 ▁; ▁}	1
▁static ▁void ▁decode _ n al _ se i _ frame _ pack ing _ ar range ment ▁( ▁H EV C Context ▁* ▁s ▁) ▁{ ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁H EV C lc ▁-> ▁gb ▁; ▁int ▁cancel ▁; ▁int ▁qu inc un x ▁= ▁0 ▁; ▁int ▁content ▁= ▁-1 ▁; ▁int ▁type ▁= ▁-1 ▁; ▁get _ ue _ go lo mb ▁( ▁gb ▁) ▁; ▁cancel ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁if ▁( ▁cancel ▁== ▁0 ▁) ▁{ ▁type ▁= ▁get _ bits ▁( ▁gb ▁, ▁7 ▁) ▁; ▁qu inc un x ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁content ▁= ▁get _ bits ▁( ▁gb ▁, ▁6 ▁) ▁; ▁skip _ bits ▁( ▁gb ▁, ▁6 ▁) ▁; ▁if ▁( ▁qu inc un x ▁== ▁0 ▁&& ▁type ▁!= ▁5 ▁) ▁skip _ bits ▁( ▁gb ▁, ▁16 ▁) ▁; ▁skip _ bits ▁( ▁gb ▁, ▁8 ▁) ▁; ▁skip _ bits 1 ▁( ▁gb ▁) ▁; ▁} ▁skip _ bits 1 ▁( ▁gb ▁) ▁; ▁s ▁-> ▁se i _ frame _ pack ing _ present ▁= ▁( ▁cancel ▁== ▁0 ▁) ▁; ▁s ▁-> ▁frame _ pack ing _ ar range ment _ type ▁= ▁type ▁; ▁s ▁-> ▁content _ interpret ation _ type ▁= ▁content ▁; ▁s ▁-> ▁qu inc un x _ sub sampling ▁= ▁qu inc un x ▁; ▁}	0
▁static ▁apr _ status _ t ▁send _ b rig ade _ non blocking ▁( ▁apr _ socket _ t ▁* ▁s ▁, ▁apr _ bucket _ b rig ade ▁* ▁bb ▁, ▁core _ output _ filter _ ctx _ t ▁* ▁ctx ▁, ▁conn _ rec ▁* ▁c ▁) ▁{ ▁apr _ status _ t ▁rv ▁= ▁APR _ SUCCESS ▁; ▁core _ server _ config ▁* ▁conf ▁= ▁ap _ get _ core _ module _ config ▁( ▁c ▁-> ▁base _ server ▁-> ▁module _ config ▁) ▁; ▁apr _ size _ t ▁nvec ▁= ▁0 ▁, ▁nbytes ▁= ▁0 ▁; ▁apr _ bucket ▁* ▁bucket ▁, ▁* ▁next ▁; ▁const ▁char ▁* ▁data ▁; ▁apr _ size _ t ▁length ▁; ▁for ▁( ▁bucket ▁= ▁APR _ BR IG ADE _ FIRST ▁( ▁bb ▁) ▁; ▁bucket ▁!= ▁APR _ BR IG ADE _ SENT IN EL ▁( ▁bb ▁) ▁; ▁bucket ▁= ▁next ▁) ▁{ ▁next ▁= ▁APR _ BUCKET _ NEXT ▁( ▁bucket ▁) ▁; ▁# if ▁APR _ HAS _ SEND FILE ▁if ▁( ▁can _ send file _ bucket ▁( ▁bucket ▁) ▁) ▁{ ▁if ▁( ▁nvec ▁> ▁0 ▁) ▁{ ▁( ▁void ▁) ▁apr _ socket _ opt _ set ▁( ▁s ▁, ▁APR _ TCP _ NOP USH ▁, ▁1 ▁) ▁; ▁rv ▁= ▁write v _ non blocking ▁( ▁s ▁, ▁bb ▁, ▁ctx ▁, ▁nbytes ▁, ▁nvec ▁, ▁c ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁goto ▁cleanup ▁; ▁} ▁nbytes ▁= ▁0 ▁; ▁nvec ▁= ▁0 ▁; ▁} ▁rv ▁= ▁send file _ non blocking ▁( ▁s ▁, ▁bucket ▁, ▁ctx ▁, ▁c ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁goto ▁cleanup ▁; ▁} ▁continue ▁; ▁} ▁# endif ▁if ▁( ▁bucket ▁-> ▁length ▁) ▁{ ▁rv ▁= ▁apr _ bucket _ read ▁( ▁bucket ▁, ▁& ▁data ▁, ▁& ▁length ▁, ▁APR _ NONBLOCK _ READ ▁) ▁; ▁if ▁( ▁APR _ STATUS _ IS _ E AGAIN ▁( ▁rv ▁) ▁) ▁{ ▁if ▁( ▁nvec ▁) ▁{ ▁rv ▁= ▁write v _ non blocking ▁( ▁s ▁, ▁bb ▁, ▁ctx ▁, ▁nbytes ▁, ▁nvec ▁, ▁c ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁goto ▁cleanup ▁; ▁} ▁nbytes ▁= ▁0 ▁; ▁nvec ▁= ▁0 ▁; ▁} ▁( ▁void ▁) ▁apr _ socket _ opt _ set ▁( ▁s ▁, ▁APR _ TCP _ NOP USH ▁, ▁0 ▁) ▁; ▁rv ▁= ▁apr _ bucket _ read ▁( ▁bucket ▁, ▁& ▁data ▁, ▁& ▁length ▁, ▁APR _ BLOCK _ READ ▁) ▁; ▁} ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁goto ▁cleanup ▁; ▁} ▁next ▁= ▁APR _ BUCKET _ NEXT ▁( ▁bucket ▁) ▁; ▁} ▁if ▁( ▁! ▁bucket ▁-> ▁length ▁) ▁{ ▁if ▁( ▁! ▁nvec ▁) ▁{ ▁apr _ bucket _ delete ▁( ▁bucket ▁) ▁; ▁} ▁continue ▁; ▁} ▁if ▁( ▁nvec ▁== ▁ctx ▁-> ▁nvec ▁) ▁{ ▁if ▁( ▁nvec ▁== ▁NV EC _ MAX ▁) ▁{ ▁( ▁void ▁) ▁apr _ socket _ opt _ set ▁( ▁s ▁, ▁APR _ TCP _ NOP USH ▁, ▁1 ▁) ▁; ▁rv ▁= ▁write v _ non blocking ▁( ▁s ▁, ▁bb ▁, ▁ctx ▁, ▁nbytes ▁, ▁nvec ▁, ▁c ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁goto ▁cleanup ▁; ▁} ▁nbytes ▁= ▁0 ▁; ▁nvec ▁= ▁0 ▁; ▁} ▁else ▁{ ▁struct ▁iovec ▁* ▁new vec ▁; ▁apr _ size _ t ▁new n ▁= ▁nvec ▁* ▁2 ▁; ▁if ▁( ▁new n ▁< ▁NV EC _ MIN ▁) ▁{ ▁new n ▁= ▁NV EC _ MIN ▁; ▁} ▁else ▁if ▁( ▁new n ▁> ▁NV EC _ MAX ▁) ▁{ ▁new n ▁= ▁NV EC _ MAX ▁; ▁} ▁new vec ▁= ▁apr _ palloc ▁( ▁c ▁-> ▁pool ▁, ▁new n ▁* ▁sizeof ▁( ▁struct ▁iovec ▁) ▁) ▁; ▁if ▁( ▁nvec ▁) ▁{ ▁memcpy ▁( ▁new vec ▁, ▁ctx ▁-> ▁vec ▁, ▁nvec ▁* ▁sizeof ▁( ▁struct ▁iovec ▁) ▁) ▁; ▁} ▁ctx ▁-> ▁vec ▁= ▁new vec ▁; ▁ctx ▁-> ▁nvec ▁= ▁new n ▁; ▁} ▁} ▁nbytes ▁+= ▁length ▁; ▁ctx ▁-> ▁vec ▁[ ▁nvec ▁] ▁. ▁iov _ base ▁= ▁( ▁void ▁* ▁) ▁data ▁; ▁ctx ▁-> ▁vec ▁[ ▁nvec ▁] ▁. ▁iov _ len ▁= ▁length ▁; ▁nvec ▁++ ▁; ▁if ▁( ▁nbytes ▁>= ▁conf ▁-> ▁flush _ max _ threshold ▁&& ▁next ▁!= ▁APR _ BR IG ADE _ SENT IN EL ▁( ▁bb ▁) ▁&& ▁! ▁is _ in _ memory _ bucket ▁( ▁next ▁) ▁) ▁{ ▁( ▁void ▁) ▁apr _ socket _ opt _ set ▁( ▁s ▁, ▁APR _ TCP _ NOP USH ▁, ▁1 ▁) ▁; ▁rv ▁= ▁write v _ non blocking ▁( ▁s ▁, ▁bb ▁, ▁ctx ▁, ▁nbytes ▁, ▁nvec ▁, ▁c ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁goto ▁cleanup ▁; ▁} ▁nbytes ▁= ▁0 ▁; ▁nvec ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁nvec ▁> ▁0 ▁) ▁{ ▁rv ▁= ▁write v _ non blocking ▁( ▁s ▁, ▁bb ▁, ▁ctx ▁, ▁nbytes ▁, ▁nvec ▁, ▁c ▁) ▁; ▁} ▁cleanup ▁: ▁( ▁void ▁) ▁apr _ socket _ opt _ set ▁( ▁s ▁, ▁APR _ TCP _ NOP USH ▁, ▁0 ▁) ▁; ▁return ▁rv ▁; ▁}	0
▁static ▁void ▁do _ sub title _ out ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AV OutputStream ▁* ▁o st ▁, ▁AV InputStream ▁* ▁ist ▁, ▁AV Subtitle ▁* ▁sub ▁, ▁int 64_ t ▁pts ▁) ▁{ ▁static ▁uint 8_ t ▁* ▁subtitle _ out ▁= ▁NULL ▁; ▁int ▁subtitle _ out _ max _ size ▁= ▁65536 ▁; ▁int ▁subtitle _ out _ size ▁, ▁nb ▁, ▁i ▁; ▁AVCodecContext ▁* ▁enc ▁; ▁AVPacket ▁pkt ▁; ▁if ▁( ▁pts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Subtitle packet sm ust have a pts \ n " ▁) ▁; ▁if ▁( ▁exit _ on _ error ▁) ▁av _ exit ▁( ▁1 ▁) ▁; ▁return ▁; ▁} ▁enc ▁= ▁o st ▁-> ▁st ▁-> ▁codec ▁; ▁if ▁( ▁! ▁subtitle _ out ▁) ▁{ ▁subtitle _ out ▁= ▁av _ malloc ▁( ▁subtitle _ out _ max _ size ▁) ▁; ▁} ▁if ▁( ▁enc ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ D VB _ SUBTITLE ▁) ▁nb ▁= ▁2 ▁; ▁else ▁nb ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb ▁; ▁i ▁++ ▁) ▁{ ▁subtitle _ out _ size ▁= ▁avcodec _ encode _ sub title ▁( ▁enc ▁, ▁subtitle _ out ▁, ▁subtitle _ out _ max _ size ▁, ▁sub ▁) ▁; ▁av _ init _ packet ▁( ▁& ▁pkt ▁) ▁; ▁pkt ▁. ▁stream _ index ▁= ▁o st ▁-> ▁index ▁; ▁pkt ▁. ▁data ▁= ▁subtitle _ out ▁; ▁pkt ▁. ▁size ▁= ▁subtitle _ out _ size ▁; ▁pkt ▁. ▁pts ▁= ▁av _ re scale _ q ▁( ▁pts ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁o st ▁-> ▁st ▁-> ▁time _ base ▁) ▁; ▁if ▁( ▁enc ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ D VB _ SUBTITLE ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁pkt ▁. ▁pts ▁+= ▁90 ▁* ▁sub ▁-> ▁start _ display _ time ▁; ▁else ▁pkt ▁. ▁pts ▁+= ▁90 ▁* ▁sub ▁-> ▁end _ display _ time ▁; ▁} ▁write _ frame ▁( ▁s ▁, ▁& ▁pkt ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁, ▁bitstream _ filters ▁[ ▁o st ▁-> ▁file _ index ▁] ▁[ ▁pkt ▁. ▁stream _ index ▁] ▁) ▁; ▁} ▁}	1
▁OSSL _ PARAM ▁OSSL _ PARAM _ construct _ end ▁( ▁void ▁) ▁{ ▁OSSL _ PARAM ▁end ▁= ▁OSSL _ PARAM _ END ▁; ▁return ▁end ▁; ▁}	1
▁static ▁int ▁dts _ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁* ▁bufp ▁; ▁uint 32_ t ▁state ▁= ▁-1 ▁; ▁int ▁markers ▁[ ▁4 ▁* ▁16 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁ex ss _ mark ers ▁= ▁0 ▁, ▁ex ss _ next pos ▁= ▁0 ▁; ▁int ▁sum ▁, ▁max ▁, ▁pos ▁, ▁ret ▁, ▁i ▁; ▁int 64_ t ▁diff ▁= ▁0 ▁; ▁uint 8_ t ▁hdr ▁[ ▁D CA _ CORE _ FRAME _ HEADER _ SIZE ▁+ ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁pos ▁= ▁FF MIN ▁( ▁4096 ▁, ▁p ▁-> ▁buf _ size ▁) ▁; ▁pos ▁< ▁p ▁-> ▁buf _ size ▁- ▁2 ▁; ▁pos ▁+= ▁2 ▁) ▁{ ▁int ▁marker ▁, ▁wide _ hdr ▁, ▁hdr _ size ▁, ▁frames ize ▁; ▁DC AC ore Frame Header ▁h ▁; ▁Get Bit Context ▁gb ▁; ▁bufp ▁= ▁buf ▁= ▁p ▁-> ▁buf ▁+ ▁pos ▁; ▁state ▁= ▁( ▁state ▁<< ▁16 ▁) ▁| ▁bytestream _ get _ be 16 ▁( ▁& ▁bufp ▁) ▁; ▁if ▁( ▁pos ▁>= ▁4 ▁) ▁diff ▁+= ▁FF ABS ▁( ▁( ▁( ▁int 16_ t ▁) ▁AV _ RL 16 ▁( ▁buf ▁) ▁) ▁- ▁( ▁int 16_ t ▁) ▁AV _ RL 16 ▁( ▁buf ▁- ▁4 ▁) ▁) ▁; ▁if ▁( ▁state ▁== ▁D CA _ SYNC WORD _ SUB STREAM ▁) ▁{ ▁if ▁( ▁pos ▁< ▁ex ss _ next pos ▁) ▁continue ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁- ▁2 ▁, ▁96 ▁) ▁; ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁42 ▁) ▁; ▁wide _ hdr ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁hdr _ size ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁8 ▁+ ▁4 ▁* ▁wide _ hdr ▁) ▁+ ▁1 ▁; ▁frames ize ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁16 ▁+ ▁4 ▁* ▁wide _ hdr ▁) ▁+ ▁1 ▁; ▁if ▁( ▁hdr _ size ▁& ▁3 ▁|| ▁frames ize ▁& ▁3 ▁) ▁continue ▁; ▁if ▁( ▁hdr _ size ▁< ▁16 ▁|| ▁frames ize ▁< ▁hdr _ size ▁) ▁continue ▁; ▁if ▁( ▁pos ▁- ▁2 ▁+ ▁hdr _ size ▁> ▁p ▁-> ▁buf _ size ▁) ▁continue ▁; ▁if ▁( ▁av _ crc ▁( ▁av _ crc _ get _ table ▁( ▁AV _ CRC _16_ CC ITT ▁) ▁, ▁0 xffff ▁, ▁buf ▁+ ▁3 ▁, ▁hdr _ size ▁- ▁5 ▁) ▁) ▁continue ▁; ▁if ▁( ▁pos ▁== ▁ex ss _ next pos ▁) ▁ex ss _ mark ers ▁++ ▁; ▁else ▁ex ss _ mark ers ▁= ▁FF MAX ▁( ▁1 ▁, ▁ex ss _ mark ers ▁- ▁1 ▁) ▁; ▁ex ss _ next pos ▁= ▁pos ▁+ ▁frames ize ▁; ▁continue ▁; ▁} ▁if ▁( ▁state ▁== ▁D CA _ SYNC WORD _ CORE _ BE ▁&& ▁( ▁bytestream _ get _ be 16 ▁( ▁& ▁bufp ▁) ▁& ▁0 xFC 00 ▁) ▁== ▁0 xFC 00 ▁) ▁marker ▁= ▁0 ▁; ▁else ▁if ▁( ▁state ▁== ▁D CA _ SYNC WORD _ CORE _ LE ▁&& ▁( ▁bytestream _ get _ be 16 ▁( ▁& ▁bufp ▁) ▁& ▁0 x 00 FC ▁) ▁== ▁0 x 00 FC ▁) ▁marker ▁= ▁1 ▁; ▁else ▁if ▁( ▁state ▁== ▁D CA _ SYNC WORD _ CORE _14 B _ BE ▁&& ▁( ▁bytestream _ get _ be 16 ▁( ▁& ▁bufp ▁) ▁& ▁0 xFFF 0 ▁) ▁== ▁0 x 07 F 0 ▁) ▁marker ▁= ▁2 ▁; ▁else ▁if ▁( ▁state ▁== ▁D CA _ SYNC WORD _ CORE _14 B _ LE ▁&& ▁( ▁bytestream _ get _ be 16 ▁( ▁& ▁bufp ▁) ▁& ▁0 xF 0 FF ▁) ▁== ▁0 xF 007 ▁) ▁marker ▁= ▁3 ▁; ▁else ▁continue ▁; ▁if ▁( ▁( ▁ret ▁= ▁avpriv _ d ca _ convert _ bit stream ▁( ▁buf ▁- ▁2 ▁, ▁D CA _ CORE _ FRAME _ HEADER _ SIZE ▁, ▁hdr ▁, ▁D CA _ CORE _ FRAME _ HEADER _ SIZE ▁) ▁) ▁< ▁0 ▁) ▁continue ▁; ▁if ▁( ▁init _ get _ bits 8 ▁( ▁& ▁gb ▁, ▁hdr ▁, ▁ret ▁) ▁< ▁0 ▁) ▁continue ▁; ▁if ▁( ▁avpriv _ d ca _ parse _ core _ frame _ header ▁( ▁& ▁gb ▁, ▁& ▁h ▁) ▁< ▁0 ▁) ▁continue ▁; ▁marker ▁+= ▁4 ▁* ▁h ▁. ▁sr _ code ▁; ▁markers ▁[ ▁marker ▁] ▁++ ▁; ▁} ▁if ▁( ▁ex ss _ mark ers ▁> ▁3 ▁) ▁return ▁AV PROBE _ SCORE _ EXTENSION ▁+ ▁1 ▁; ▁sum ▁= ▁max ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁markers ▁) ▁; ▁i ▁++ ▁) ▁{ ▁sum ▁+= ▁markers ▁[ ▁i ▁] ▁; ▁if ▁( ▁markers ▁[ ▁max ▁] ▁< ▁markers ▁[ ▁i ▁] ▁) ▁max ▁= ▁i ▁; ▁} ▁if ▁( ▁markers ▁[ ▁max ▁] ▁> ▁3 ▁&& ▁p ▁-> ▁buf _ size ▁/ ▁markers ▁[ ▁max ▁] ▁< ▁32 ▁* ▁1024 ▁&& ▁markers ▁[ ▁max ▁] ▁* ▁4 ▁> ▁sum ▁* ▁3 ▁&& ▁diff ▁/ ▁p ▁-> ▁buf _ size ▁> ▁200 ▁) ▁return ▁AV PROBE _ SCORE _ EXTENSION ▁+ ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁inline ▁void ▁writer _ print _ section _ footer ▁( ▁Writer Context ▁* ▁w ctx ▁) ▁{ ▁int ▁section _ id ▁= ▁w ctx ▁-> ▁section ▁[ ▁w ctx ▁-> ▁level ▁] ▁-> ▁id ▁; ▁int ▁parent _ section _ id ▁= ▁w ctx ▁-> ▁level ▁? ▁w ctx ▁-> ▁section ▁[ ▁w ctx ▁-> ▁level ▁- ▁1 ▁] ▁-> ▁id ▁: ▁SECTION _ ID _ NONE ▁; ▁if ▁( ▁parent _ section _ id ▁!= ▁SECTION _ ID _ NONE ▁) ▁w ctx ▁-> ▁nb _ item ▁[ ▁w ctx ▁-> ▁level ▁- ▁1 ▁] ▁++ ▁; ▁if ▁( ▁parent _ section _ id ▁== ▁SECTION _ ID _ PACKET S _ AND _ FRAMES ▁) ▁{ ▁if ▁( ▁section _ id ▁== ▁SECTION _ ID _ PACKET ▁) ▁w ctx ▁-> ▁nb _ section _ packet ▁++ ▁; ▁else ▁w ctx ▁-> ▁nb _ section _ frame ▁++ ▁; ▁} ▁if ▁( ▁w ctx ▁-> ▁writer ▁-> ▁print _ section _ footer ▁) ▁w ctx ▁-> ▁writer ▁-> ▁print _ section _ footer ▁( ▁w ctx ▁) ▁; ▁w ctx ▁-> ▁level ▁-- ▁; ▁}	1
▁static ▁void ▁smp te bars _ fill _ picture ▁( ▁AVFilter Context ▁* ▁ctx ▁, ▁AVFrame ▁* ▁pic ref ▁) ▁{ ▁Test SourceContext ▁* ▁test ▁= ▁ctx ▁-> ▁priv ▁; ▁int ▁r _ w ▁, ▁r _ h ▁, ▁w _ h ▁, ▁p _ w ▁, ▁p _ h ▁, ▁i ▁, ▁tmp ▁, ▁x ▁= ▁0 ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁pix desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁pic ref ▁-> ▁format ▁) ▁; ▁r _ w ▁= ▁FF ALIGN ▁( ▁( ▁test ▁-> ▁w ▁+ ▁6 ▁) ▁/ ▁7 ▁, ▁1 ▁<< ▁pix desc ▁-> ▁log 2_ chroma _ w ▁) ▁; ▁r _ h ▁= ▁FF ALIGN ▁( ▁test ▁-> ▁h ▁* ▁2 ▁/ ▁3 ▁, ▁1 ▁<< ▁pix desc ▁-> ▁log 2_ chroma _ h ▁) ▁; ▁w _ h ▁= ▁FF ALIGN ▁( ▁test ▁-> ▁h ▁* ▁3 ▁/ ▁4 ▁- ▁r _ h ▁, ▁1 ▁<< ▁pix desc ▁-> ▁log 2_ chroma _ h ▁) ▁; ▁p _ w ▁= ▁FF ALIGN ▁( ▁r _ w ▁* ▁5 ▁/ ▁4 ▁, ▁1 ▁<< ▁pix desc ▁-> ▁log 2_ chroma _ w ▁) ▁; ▁p _ h ▁= ▁test ▁-> ▁h ▁- ▁w _ h ▁- ▁r _ h ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁7 ▁; ▁i ▁++ ▁) ▁{ ▁draw _ bar ▁( ▁test ▁, ▁r ain bow ▁[ ▁i ▁] ▁, ▁x ▁, ▁0 ▁, ▁r _ w ▁, ▁r _ h ▁, ▁pic ref ▁) ▁; ▁draw _ bar ▁( ▁test ▁, ▁w ob n air ▁[ ▁i ▁] ▁, ▁x ▁, ▁r _ h ▁, ▁r _ w ▁, ▁w _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁r _ w ▁; ▁} ▁x ▁= ▁0 ▁; ▁draw _ bar ▁( ▁test ▁, ▁i _ pixel ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁p _ w ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁p _ w ▁; ▁draw _ bar ▁( ▁test ▁, ▁white ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁p _ w ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁p _ w ▁; ▁draw _ bar ▁( ▁test ▁, ▁q _ pixel ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁p _ w ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁p _ w ▁; ▁tmp ▁= ▁FF ALIGN ▁( ▁5 ▁* ▁r _ w ▁- ▁x ▁, ▁1 ▁<< ▁pix desc ▁-> ▁log 2_ chroma _ w ▁) ▁; ▁draw _ bar ▁( ▁test ▁, ▁black ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁tmp ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁tmp ▁; ▁tmp ▁= ▁FF ALIGN ▁( ▁r _ w ▁/ ▁3 ▁, ▁1 ▁<< ▁pix desc ▁-> ▁log 2_ chroma _ w ▁) ▁; ▁draw _ bar ▁( ▁test ▁, ▁neg 4 ire ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁tmp ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁tmp ▁; ▁draw _ bar ▁( ▁test ▁, ▁black ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁tmp ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁tmp ▁; ▁draw _ bar ▁( ▁test ▁, ▁pos 4 ire ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁tmp ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁x ▁+= ▁tmp ▁; ▁draw _ bar ▁( ▁test ▁, ▁black ▁, ▁x ▁, ▁r _ h ▁+ ▁w _ h ▁, ▁test ▁-> ▁w ▁- ▁x ▁, ▁p _ h ▁, ▁pic ref ▁) ▁; ▁}	0
▁int ▁ff _ mpeg 4 audio _ get _ config ▁( ▁M PEG 4 Audio Config ▁* ▁c ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁Get Bit Context ▁gb ▁; ▁int ▁specific _ config _ bit index ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁c ▁-> ▁object _ type ▁= ▁get _ object _ type ▁( ▁& ▁gb ▁) ▁; ▁c ▁-> ▁sample _ rate ▁= ▁get _ sample _ rate ▁( ▁& ▁gb ▁, ▁& ▁c ▁-> ▁sampling _ index ▁) ▁; ▁c ▁-> ▁chan _ config ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁if ▁( ▁c ▁-> ▁chan _ config ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁ff _ mpeg 4 audio _ channels ▁) ▁) ▁c ▁-> ▁channels ▁= ▁ff _ mpeg 4 audio _ channels ▁[ ▁c ▁-> ▁chan _ config ▁] ▁; ▁c ▁-> ▁sb r ▁= ▁-1 ▁; ▁if ▁( ▁c ▁-> ▁object _ type ▁== ▁A OT _ S BR ▁|| ▁( ▁c ▁-> ▁object _ type ▁== ▁A OT _ PS ▁&& ▁! ▁( ▁show _ bits ▁( ▁& ▁gb ▁, ▁3 ▁) ▁& ▁0 x 03 ▁&& ▁! ▁( ▁show _ bits ▁( ▁& ▁gb ▁, ▁9 ▁) ▁& ▁0 x 3 F ▁) ▁) ▁) ▁) ▁{ ▁c ▁-> ▁ext _ object _ type ▁= ▁A OT _ S BR ▁; ▁c ▁-> ▁sb r ▁= ▁1 ▁; ▁c ▁-> ▁ext _ sample _ rate ▁= ▁get _ sample _ rate ▁( ▁& ▁gb ▁, ▁& ▁c ▁-> ▁ext _ sampling _ index ▁) ▁; ▁c ▁-> ▁object _ type ▁= ▁get _ object _ type ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁c ▁-> ▁object _ type ▁== ▁A OT _ ER _ BS AC ▁) ▁c ▁-> ▁ext _ chan _ config ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁} ▁else ▁{ ▁c ▁-> ▁ext _ object _ type ▁= ▁A OT _ NULL ▁; ▁c ▁-> ▁ext _ sample _ rate ▁= ▁0 ▁; ▁} ▁specific _ config _ bit index ▁= ▁get _ bits _ count ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁c ▁-> ▁object _ type ▁== ▁A OT _ AL S ▁) ▁{ ▁skip _ bits ▁( ▁& ▁gb ▁, ▁5 ▁) ▁; ▁if ▁( ▁show _ bits _ long ▁( ▁& ▁gb ▁, ▁24 ▁) ▁!= ▁M KB ET AG ▁( ▁' ▁\0 ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁24 ▁) ▁; ▁specific _ config _ bit index ▁= ▁get _ bits _ count ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁parse _ config _ AL S ▁( ▁& ▁gb ▁, ▁c ▁) ▁) ▁return ▁-1 ▁; ▁} ▁if ▁( ▁c ▁-> ▁ext _ object _ type ▁!= ▁A OT _ S BR ▁) ▁{ ▁while ▁( ▁get _ bits _ left ▁( ▁& ▁gb ▁) ▁> ▁15 ▁) ▁{ ▁if ▁( ▁show _ bits ▁( ▁& ▁gb ▁, ▁11 ▁) ▁== ▁0 x 2 b 7 ▁) ▁{ ▁get _ bits ▁( ▁& ▁gb ▁, ▁11 ▁) ▁; ▁c ▁-> ▁ext _ object _ type ▁= ▁get _ object _ type ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁c ▁-> ▁ext _ object _ type ▁== ▁A OT _ S BR ▁&& ▁( ▁c ▁-> ▁sb r ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁) ▁== ▁1 ▁) ▁c ▁-> ▁ext _ sample _ rate ▁= ▁get _ sample _ rate ▁( ▁& ▁gb ▁, ▁& ▁c ▁-> ▁ext _ sampling _ index ▁) ▁; ▁break ▁; ▁} ▁else ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁} ▁} ▁return ▁specific _ config _ bit index ▁; ▁}	0
▁static ▁void ▁update _ od ml _ entry ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁stream _ index ▁, ▁int 64_ t ▁ix ▁, ▁int ▁size ▁) ▁{ ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁AV I Context ▁* ▁avi ▁= ▁s ▁-> ▁priv _ data ▁; ▁AV I Stream ▁* ▁av ist ▁= ▁s ▁-> ▁streams ▁[ ▁stream _ index ▁] ▁-> ▁priv _ data ▁; ▁int 64_ t ▁pos ▁; ▁int ▁au _ by ter ate ▁, ▁au _ ssize ▁, ▁au _ scale ▁; ▁avio _ flush ▁( ▁pb ▁) ▁; ▁pos ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁av ist ▁-> ▁indexes ▁. ▁indx _ start ▁- ▁8 ▁, ▁SEEK _ SET ▁) ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁" ind x " ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁8 ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁avi ▁-> ▁ri ff _ id ▁- ▁av ist ▁-> ▁indexes ▁. ▁master _ od ml _ ri ff _ id _ base ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁16 ▁* ▁( ▁avi ▁-> ▁ri ff _ id ▁- ▁av ist ▁-> ▁indexes ▁. ▁master _ od ml _ ri ff _ id _ base ▁) ▁) ▁; ▁avio _ wl 64 ▁( ▁pb ▁, ▁ix ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁size ▁) ▁; ▁ff _ parse _ specific _ params ▁( ▁s ▁-> ▁streams ▁[ ▁stream _ index ▁] ▁, ▁& ▁au _ by ter ate ▁, ▁& ▁au _ ssize ▁, ▁& ▁au _ scale ▁) ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁stream _ index ▁] ▁-> ▁codec ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁au _ ssize ▁> ▁0 ▁) ▁{ ▁uint 32_ t ▁audio _ se gm _ size ▁= ▁( ▁av ist ▁-> ▁audio _ strm _ length ▁- ▁av ist ▁-> ▁indexes ▁. ▁audio _ strm _ offset ▁) ▁; ▁if ▁( ▁( ▁audio _ se gm _ size ▁% ▁au _ ssize ▁> ▁0 ▁) ▁&& ▁! ▁av ist ▁-> ▁sample _ requested ▁) ▁{ ▁avpriv _ request _ sample ▁( ▁s ▁, ▁" Open D ML index duration for aud iop acket swith partial frames " ▁) ▁; ▁av ist ▁-> ▁sample _ requested ▁= ▁1 ▁; ▁} ▁avio _ wl 32 ▁( ▁pb ▁, ▁audio _ se gm _ size ▁/ ▁au _ ssize ▁) ▁; ▁} ▁else ▁avio _ wl 32 ▁( ▁pb ▁, ▁av ist ▁-> ▁indexes ▁. ▁entry ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁pos ▁, ▁SEEK _ SET ▁) ▁; ▁}	0
▁static ▁int ▁link _ filter _ in outs ▁( ▁AVFilter Context ▁* ▁filt _ ctx ▁, ▁AVFilter InOut ▁* ▁* ▁curr _ inputs ▁, ▁AVFilter InOut ▁* ▁* ▁open _ inputs ▁, ▁AV Class ▁* ▁log _ ctx ▁) ▁{ ▁int ▁pad ▁= ▁filt _ ctx ▁-> ▁input _ count ▁, ▁ret ▁; ▁while ▁( ▁pad ▁-- ▁) ▁{ ▁AVFilter InOut ▁* ▁p ▁= ▁* ▁curr _ inputs ▁; ▁if ▁( ▁! ▁p ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Not en ough input ss pec ified fort he \"% s \" filter .\ n " ▁, ▁filt _ ctx ▁-> ▁filter ▁-> ▁name ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁* ▁curr _ inputs ▁= ▁( ▁* ▁curr _ inputs ▁) ▁-> ▁next ▁; ▁if ▁( ▁p ▁-> ▁filter ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁link _ filter ▁( ▁p ▁-> ▁filter ▁, ▁p ▁-> ▁pad _ idx ▁, ▁filt _ ctx ▁, ▁pad ▁, ▁log _ ctx ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁av _ free ▁( ▁p ▁-> ▁name ▁) ▁; ▁av _ free ▁( ▁p ▁) ▁; ▁} ▁else ▁{ ▁p ▁-> ▁filter ▁= ▁filt _ ctx ▁; ▁p ▁-> ▁pad _ idx ▁= ▁pad ▁; ▁insert _ inout ▁( ▁open _ inputs ▁, ▁p ▁) ▁; ▁} ▁} ▁if ▁( ▁* ▁curr _ inputs ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" T oom any input ss pec ified fort he \"% s \" filter .\ n " ▁, ▁filt _ ctx ▁-> ▁filter ▁-> ▁name ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁pad ▁= ▁filt _ ctx ▁-> ▁output _ count ▁; ▁while ▁( ▁pad ▁-- ▁) ▁{ ▁AVFilter InOut ▁* ▁curr link n ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter InOut ▁) ▁) ▁; ▁if ▁( ▁! ▁curr link n ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁curr link n ▁-> ▁filter ▁= ▁filt _ ctx ▁; ▁curr link n ▁-> ▁pad _ idx ▁= ▁pad ▁; ▁insert _ inout ▁( ▁curr _ inputs ▁, ▁curr link n ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁APR _ INLINE ▁void ▁* ▁index _ to _ bytes ▁( ▁ap _ e queue _ t ▁* ▁eq ▁, ▁apr _ uint 32_ t ▁idx ▁) ▁{ ▁apr _ size _ t ▁offset ▁= ▁idx ▁* ▁eq ▁-> ▁elem _ size ▁; ▁return ▁( ▁void ▁* ▁) ▁& ▁eq ▁-> ▁bytes ▁[ ▁offset ▁] ▁; ▁}	1
▁static ▁av _ always _ inline ▁void ▁yuv 2 rgb _ write ▁( ▁uint 8_ t ▁* ▁_ dest ▁, ▁int ▁i ▁, ▁int ▁Y 1 ▁, ▁int ▁Y 2 ▁, ▁int ▁U ▁, ▁int ▁V ▁, ▁int ▁A 1 ▁, ▁int ▁A 2 ▁, ▁const ▁void ▁* ▁_ r ▁, ▁const ▁void ▁* ▁_ g ▁, ▁const ▁void ▁* ▁_ b ▁, ▁int ▁y ▁, ▁enum ▁PixelFormat ▁target ▁, ▁int ▁has Alpha ▁) ▁{ ▁if ▁( ▁target ▁== ▁PIX _ FMT _ ARGB ▁|| ▁target ▁== ▁PIX _ FMT _ RGBA ▁|| ▁target ▁== ▁PIX _ FMT _ AB GR ▁|| ▁target ▁== ▁PIX _ FMT _ B GRA ▁) ▁{ ▁uint 32_ t ▁* ▁dest ▁= ▁( ▁uint 32_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 32_ t ▁* ▁r ▁= ▁( ▁const ▁uint 32_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 32_ t ▁* ▁g ▁= ▁( ▁const ▁uint 32_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 32_ t ▁* ▁b ▁= ▁( ▁const ▁uint 32_ t ▁* ▁) ▁_ b ▁; ▁# if ▁CONFIG _ SMALL ▁int ▁sh ▁= ▁has Alpha ▁? ▁( ▁( ▁target ▁== ▁PIX _ FMT _ RGB 32_ 1 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 32_ 1 ▁) ▁? ▁0 ▁: ▁24 ▁) ▁: ▁0 ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁] ▁+ ▁( ▁has Alpha ▁? ▁A 1 ▁<< ▁sh ▁: ▁0 ▁) ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁] ▁+ ▁( ▁has Alpha ▁? ▁A 2 ▁<< ▁sh ▁: ▁0 ▁) ▁; ▁# else ▁if ▁( ▁has Alpha ▁) ▁{ ▁int ▁sh ▁= ▁( ▁target ▁== ▁PIX _ FMT _ RGB 32_ 1 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 32_ 1 ▁) ▁? ▁0 ▁: ▁24 ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁] ▁+ ▁( ▁A 1 ▁<< ▁sh ▁) ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁] ▁+ ▁( ▁A 2 ▁<< ▁sh ▁) ▁; ▁} ▁else ▁{ ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁] ▁; ▁} ▁# endif ▁} ▁else ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 24 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 24 ▁) ▁{ ▁uint 8_ t ▁* ▁dest ▁= ▁( ▁uint 8_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 8_ t ▁* ▁r ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 8_ t ▁* ▁g ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 8_ t ▁* ▁b ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ b ▁; ▁# define ▁r _ b ▁(( target == PIX _ FMT _ RGB 24 )? r : b ) ▁# define ▁b _ r ▁(( target == PIX _ FMT _ RGB 24 )? b : r ) ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁0 ▁] ▁= ▁r _ b ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁1 ▁] ▁= ▁g ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁2 ▁] ▁= ▁b _ r ▁[ ▁Y 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁3 ▁] ▁= ▁r _ b ▁[ ▁Y 2 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁4 ▁] ▁= ▁g ▁[ ▁Y 2 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁6 ▁+ ▁5 ▁] ▁= ▁b _ r ▁[ ▁Y 2 ▁] ▁; ▁# undef ▁r _ b ▁# undef ▁b _ r ▁} ▁else ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 565 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 565 ▁|| ▁target ▁== ▁PIX _ FMT _ RGB 555 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 555 ▁|| ▁target ▁== ▁PIX _ FMT _ RGB 444 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 444 ▁) ▁{ ▁uint 16_ t ▁* ▁dest ▁= ▁( ▁uint 16_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 16_ t ▁* ▁r ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 16_ t ▁* ▁g ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 16_ t ▁* ▁b ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁_ b ▁; ▁int ▁dr 1 ▁, ▁dg 1 ▁, ▁db 1 ▁, ▁dr 2 ▁, ▁dg 2 ▁, ▁db 2 ▁; ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 565 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 565 ▁) ▁{ ▁dr 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dg 1 ▁= ▁d ither _2 x 2_ 4 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁db 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dr 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dg 2 ▁= ▁d ither _2 x 2_ 4 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁db 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 555 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 555 ▁) ▁{ ▁dr 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dg 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁db 1 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁dr 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁dg 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁y ▁& ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁db 2 ▁= ▁d ither _2 x 2_ 8 ▁[ ▁( ▁y ▁& ▁1 ▁) ▁ ^ ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁dr 1 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁0 ▁] ▁; ▁dg 1 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁1 ▁] ▁; ▁db 1 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁( ▁y ▁& ▁3 ▁) ▁ ^ ▁3 ▁] ▁[ ▁0 ▁] ▁; ▁dr 2 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁1 ▁] ▁; ▁dg 2 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁y ▁& ▁3 ▁] ▁[ ▁0 ▁] ▁; ▁db 2 ▁= ▁d ither _4 x 4_ 16 ▁[ ▁( ▁y ▁& ▁3 ▁) ▁ ^ ▁3 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁+ ▁dr 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁+ ▁dg 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁+ ▁db 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁+ ▁dr 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁+ ▁dg 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁+ ▁db 2 ▁] ▁; ▁} ▁else ▁{ ▁uint 8_ t ▁* ▁dest ▁= ▁( ▁uint 8_ t ▁* ▁) ▁_ dest ▁; ▁const ▁uint 8_ t ▁* ▁r ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ r ▁; ▁const ▁uint 8_ t ▁* ▁g ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ g ▁; ▁const ▁uint 8_ t ▁* ▁b ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁_ b ▁; ▁int ▁dr 1 ▁, ▁dg 1 ▁, ▁db 1 ▁, ▁dr 2 ▁, ▁dg 2 ▁, ▁db 2 ▁; ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 8 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 8 ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁const ▁d 64 ▁= ▁d ither _8 x 8_ 73 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁const ▁uint 8_ t ▁* ▁const ▁d 32 ▁= ▁d ither _8 x 8_ 32 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁dr 1 ▁= ▁dg 1 ▁= ▁d 32 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁db 1 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁dr 2 ▁= ▁dg 2 ▁= ▁d 32 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁db 2 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁} ▁else ▁{ ▁const ▁uint 8_ t ▁* ▁const ▁d 64 ▁= ▁d ither _8 x 8_ 73 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁const ▁uint 8_ t ▁* ▁const ▁d 128 ▁= ▁d ither _8 x 8_ 220 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁dr 1 ▁= ▁db 1 ▁= ▁d 128 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁dg 1 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁0 ▁) ▁& ▁7 ▁] ▁; ▁dr 2 ▁= ▁db 2 ▁= ▁d 128 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁dg 2 ▁= ▁d 64 ▁[ ▁( ▁i ▁* ▁2 ▁+ ▁1 ▁) ▁& ▁7 ▁] ▁; ▁} ▁if ▁( ▁target ▁== ▁PIX _ FMT _ RGB 4 ▁|| ▁target ▁== ▁PIX _ FMT _ BGR 4 ▁) ▁{ ▁dest ▁[ ▁i ▁] ▁= ▁r ▁[ ▁Y 1 ▁+ ▁dr 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁+ ▁dg 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁+ ▁db 1 ▁] ▁+ ▁( ▁( ▁r ▁[ ▁Y 2 ▁+ ▁dr 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁+ ▁dg 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁+ ▁db 2 ▁] ▁) ▁<< ▁4 ▁) ▁; ▁} ▁else ▁{ ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁0 ▁] ▁= ▁r ▁[ ▁Y 1 ▁+ ▁dr 1 ▁] ▁+ ▁g ▁[ ▁Y 1 ▁+ ▁dg 1 ▁] ▁+ ▁b ▁[ ▁Y 1 ▁+ ▁db 1 ▁] ▁; ▁dest ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁r ▁[ ▁Y 2 ▁+ ▁dr 2 ▁] ▁+ ▁g ▁[ ▁Y 2 ▁+ ▁dg 2 ▁] ▁+ ▁b ▁[ ▁Y 2 ▁+ ▁db 2 ▁] ▁; ▁} ▁} ▁}	1
▁static ▁int ▁apple http _ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AV Format Parameters ▁* ▁ap ▁) ▁{ ▁Apple HTTP Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁ret ▁= ▁0 ▁, ▁i ▁, ▁j ▁, ▁stream _ offset ▁= ▁0 ▁; ▁if ▁( ▁( ▁ret ▁= ▁parse _ playlist ▁( ▁c ▁, ▁s ▁-> ▁filename ▁, ▁NULL ▁, ▁s ▁-> ▁pb ▁) ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁if ▁( ▁c ▁-> ▁n _ variants ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" Empty playlist \ n " ▁) ▁; ▁ret ▁= ▁AVERROR _ EOF ▁; ▁goto ▁fail ▁; ▁} ▁if ▁( ▁c ▁-> ▁n _ variants ▁> ▁1 ▁|| ▁c ▁-> ▁variants ▁[ ▁0 ▁] ▁-> ▁n _ segments ▁== ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁n _ variants ▁; ▁i ▁++ ▁) ▁{ ▁struct ▁variant ▁* ▁v ▁= ▁c ▁-> ▁variants ▁[ ▁i ▁] ▁; ▁if ▁( ▁( ▁ret ▁= ▁parse _ playlist ▁( ▁c ▁, ▁v ▁-> ▁url ▁, ▁v ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁} ▁} ▁if ▁( ▁c ▁-> ▁variants ▁[ ▁0 ▁] ▁-> ▁n _ segments ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" Empty playlist \ n " ▁) ▁; ▁ret ▁= ▁AVERROR _ EOF ▁; ▁goto ▁fail ▁; ▁} ▁if ▁( ▁c ▁-> ▁finished ▁) ▁{ ▁int ▁duration ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁variants ▁[ ▁0 ▁] ▁-> ▁n _ segments ▁; ▁i ▁++ ▁) ▁duration ▁+= ▁c ▁-> ▁variants ▁[ ▁0 ▁] ▁-> ▁segments ▁[ ▁i ▁] ▁-> ▁duration ▁; ▁s ▁-> ▁duration ▁= ▁duration ▁* ▁AV _ TIME _ BASE ▁; ▁} ▁c ▁-> ▁min _ end _ seq ▁= ▁INT _ MAX ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁n _ variants ▁; ▁i ▁++ ▁) ▁{ ▁struct ▁variant ▁* ▁v ▁= ▁c ▁-> ▁variants ▁[ ▁i ▁] ▁; ▁if ▁( ▁v ▁-> ▁n _ segments ▁== ▁0 ▁) ▁continue ▁; ▁c ▁-> ▁max _ start _ seq ▁= ▁FF MAX ▁( ▁c ▁-> ▁max _ start _ seq ▁, ▁v ▁-> ▁start _ seq _ no ▁) ▁; ▁c ▁-> ▁min _ end _ seq ▁= ▁FF MIN ▁( ▁c ▁-> ▁min _ end _ seq ▁, ▁v ▁-> ▁start _ seq _ no ▁+ ▁v ▁-> ▁n _ segments ▁) ▁; ▁ret ▁= ▁av _ open _ input _ file ▁( ▁& ▁v ▁-> ▁ctx ▁, ▁v ▁-> ▁segments ▁[ ▁0 ▁] ▁-> ▁url ▁, ▁NULL ▁, ▁0 ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁url _ fclose ▁( ▁v ▁-> ▁ctx ▁-> ▁pb ▁) ▁; ▁v ▁-> ▁ctx ▁-> ▁pb ▁= ▁NULL ▁; ▁v ▁-> ▁stream _ offset ▁= ▁stream _ offset ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁v ▁-> ▁ctx ▁-> ▁nb _ streams ▁; ▁j ▁++ ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁av _ new _ stream ▁( ▁s ▁, ▁i ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁avcodec _ copy _ context ▁( ▁st ▁-> ▁codec ▁, ▁v ▁-> ▁ctx ▁-> ▁streams ▁[ ▁j ▁] ▁-> ▁codec ▁) ▁; ▁} ▁stream _ offset ▁+= ▁v ▁-> ▁ctx ▁-> ▁nb _ streams ▁; ▁} ▁c ▁-> ▁last _ packet _ dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁c ▁-> ▁cur _ seq _ no ▁= ▁c ▁-> ▁max _ start _ seq ▁; ▁if ▁( ▁! ▁c ▁-> ▁finished ▁&& ▁c ▁-> ▁min _ end _ seq ▁- ▁c ▁-> ▁max _ start _ seq ▁> ▁3 ▁) ▁c ▁-> ▁cur _ seq _ no ▁= ▁c ▁-> ▁min _ end _ seq ▁- ▁2 ▁; ▁return ▁0 ▁; ▁fail ▁: ▁free _ variant _ list ▁( ▁c ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁ogg _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁* ▁sid ▁, ▁int ▁* ▁d start ▁, ▁int ▁* ▁dsize ▁, ▁int 64_ t ▁* ▁f pos ▁) ▁{ ▁struct ▁ogg ▁* ▁ogg ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁idx ▁, ▁i ▁, ▁ret ▁; ▁struct ▁ogg _ stream ▁* ▁os ▁; ▁int ▁complete ▁= ▁0 ▁; ▁int ▁seg p ▁= ▁0 ▁, ▁psize ▁= ▁0 ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ TRACE ▁, ▁" ogg _ packet : cur idx =% i \ n " ▁, ▁ogg ▁-> ▁cur idx ▁) ▁; ▁if ▁( ▁sid ▁) ▁* ▁sid ▁= ▁-1 ▁; ▁do ▁{ ▁idx ▁= ▁ogg ▁-> ▁cur idx ▁; ▁while ▁( ▁idx ▁< ▁0 ▁) ▁{ ▁ret ▁= ▁ogg _ read _ page ▁( ▁s ▁, ▁& ▁idx ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁os ▁= ▁ogg ▁-> ▁streams ▁+ ▁idx ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ TRACE ▁, ▁" ogg _ packet : idx =% dp start =% dp size =% d seg p =% dn segs =% d \ n " ▁, ▁idx ▁, ▁os ▁-> ▁p start ▁, ▁os ▁-> ▁psize ▁, ▁os ▁-> ▁seg p ▁, ▁os ▁-> ▁n segs ▁) ▁; ▁if ▁( ▁! ▁os ▁-> ▁codec ▁) ▁{ ▁if ▁( ▁os ▁-> ▁header ▁< ▁0 ▁) ▁{ ▁os ▁-> ▁codec ▁= ▁ogg _ find _ codec ▁( ▁os ▁-> ▁buf ▁, ▁os ▁-> ▁buf pos ▁) ▁; ▁if ▁( ▁! ▁os ▁-> ▁codec ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Codec not found \ n " ▁) ▁; ▁os ▁-> ▁header ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁} ▁else ▁{ ▁return ▁0 ▁; ▁} ▁} ▁seg p ▁= ▁os ▁-> ▁seg p ▁; ▁psize ▁= ▁os ▁-> ▁psize ▁; ▁while ▁( ▁os ▁-> ▁seg p ▁< ▁os ▁-> ▁n segs ▁) ▁{ ▁int ▁ss ▁= ▁os ▁-> ▁segments ▁[ ▁os ▁-> ▁seg p ▁++ ▁] ▁; ▁os ▁-> ▁psize ▁+= ▁ss ▁; ▁if ▁( ▁ss ▁< ▁255 ▁) ▁{ ▁complete ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁complete ▁&& ▁os ▁-> ▁seg p ▁== ▁os ▁-> ▁n segs ▁) ▁{ ▁ogg ▁-> ▁cur idx ▁= ▁-1 ▁; ▁os ▁-> ▁incomplete ▁= ▁! ▁! ▁os ▁-> ▁psize ▁; ▁} ▁} ▁while ▁( ▁! ▁complete ▁) ▁; ▁if ▁( ▁os ▁-> ▁gran ule ▁== ▁-1 ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Page at %" ▁PRId 64 ▁" ism issing gran ule \ n " ▁, ▁os ▁-> ▁page _ pos ▁) ▁; ▁ogg ▁-> ▁cur idx ▁= ▁idx ▁; ▁os ▁-> ▁incomplete ▁= ▁0 ▁; ▁if ▁( ▁os ▁-> ▁header ▁) ▁{ ▁os ▁-> ▁header ▁= ▁os ▁-> ▁codec ▁-> ▁header ▁( ▁s ▁, ▁idx ▁) ▁; ▁if ▁( ▁! ▁os ▁-> ▁header ▁) ▁{ ▁os ▁-> ▁seg p ▁= ▁seg p ▁; ▁os ▁-> ▁psize ▁= ▁psize ▁; ▁ogg ▁-> ▁headers ▁= ▁1 ▁; ▁if ▁( ▁! ▁s ▁-> ▁internal ▁-> ▁data _ offset ▁) ▁s ▁-> ▁internal ▁-> ▁data _ offset ▁= ▁os ▁-> ▁sync _ pos ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ogg ▁-> ▁n streams ▁; ▁i ▁++ ▁) ▁{ ▁struct ▁ogg _ stream ▁* ▁cur _ os ▁= ▁ogg ▁-> ▁streams ▁+ ▁i ▁; ▁if ▁( ▁cur _ os ▁-> ▁incomplete ▁) ▁s ▁-> ▁internal ▁-> ▁data _ offset ▁= ▁FF MIN ▁( ▁s ▁-> ▁internal ▁-> ▁data _ offset ▁, ▁cur _ os ▁-> ▁sync _ pos ▁) ▁; ▁} ▁} ▁else ▁{ ▁os ▁-> ▁nb _ header ▁++ ▁; ▁os ▁-> ▁p start ▁+= ▁os ▁-> ▁psize ▁; ▁os ▁-> ▁psize ▁= ▁0 ▁; ▁} ▁} ▁else ▁{ ▁os ▁-> ▁p flags ▁= ▁0 ▁; ▁os ▁-> ▁pd uration ▁= ▁0 ▁; ▁if ▁( ▁os ▁-> ▁codec ▁&& ▁os ▁-> ▁codec ▁-> ▁packet ▁) ▁os ▁-> ▁codec ▁-> ▁packet ▁( ▁s ▁, ▁idx ▁) ▁; ▁if ▁( ▁sid ▁) ▁* ▁sid ▁= ▁idx ▁; ▁if ▁( ▁d start ▁) ▁* ▁d start ▁= ▁os ▁-> ▁p start ▁; ▁if ▁( ▁dsize ▁) ▁* ▁dsize ▁= ▁os ▁-> ▁psize ▁; ▁if ▁( ▁f pos ▁) ▁* ▁f pos ▁= ▁os ▁-> ▁sync _ pos ▁; ▁os ▁-> ▁p start ▁+= ▁os ▁-> ▁psize ▁; ▁os ▁-> ▁psize ▁= ▁0 ▁; ▁if ▁( ▁os ▁-> ▁p start ▁== ▁os ▁-> ▁buf pos ▁) ▁os ▁-> ▁buf pos ▁= ▁os ▁-> ▁p start ▁= ▁0 ▁; ▁os ▁-> ▁sync _ pos ▁= ▁os ▁-> ▁page _ pos ▁; ▁} ▁os ▁-> ▁page _ end ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁os ▁-> ▁seg p ▁; ▁i ▁< ▁os ▁-> ▁n segs ▁; ▁i ▁++ ▁) ▁if ▁( ▁os ▁-> ▁segments ▁[ ▁i ▁] ▁< ▁255 ▁) ▁{ ▁os ▁-> ▁page _ end ▁= ▁0 ▁; ▁break ▁; ▁} ▁if ▁( ▁os ▁-> ▁seg p ▁== ▁os ▁-> ▁n segs ▁) ▁ogg ▁-> ▁cur idx ▁= ▁-1 ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁decode _ cl n pass ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁J peg 2000 T 1 Context ▁* ▁t 1 ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁bp no ▁, ▁int ▁band no ▁, ▁int ▁seg _ symbols ▁, ▁int ▁vert _ ca us al _ ctx _ cst y _ symbol ▁) ▁{ ▁int ▁mask ▁= ▁3 ▁<< ▁( ▁bp no ▁- ▁1 ▁) ▁, ▁y 0 ▁, ▁x ▁, ▁y ▁, ▁run len ▁, ▁dec ▁; ▁for ▁( ▁y 0 ▁= ▁0 ▁; ▁y 0 ▁< ▁height ▁; ▁y 0 ▁+= ▁4 ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁width ▁; ▁x ▁++ ▁) ▁{ ▁if ▁( ▁y 0 ▁+ ▁3 ▁< ▁height ▁&& ▁! ▁( ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y 0 ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁& ▁( ▁JPEG 2000_ T 1_ SIG _ NB ▁| ▁JPEG 2000_ T 1_ VIS ▁| ▁JPEG 2000_ T 1_ SIG ▁) ▁) ▁|| ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y 0 ▁+ ▁2 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁& ▁( ▁JPEG 2000_ T 1_ SIG _ NB ▁| ▁JPEG 2000_ T 1_ VIS ▁| ▁JPEG 2000_ T 1_ SIG ▁) ▁) ▁|| ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y 0 ▁+ ▁3 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁& ▁( ▁JPEG 2000_ T 1_ SIG _ NB ▁| ▁JPEG 2000_ T 1_ VIS ▁| ▁JPEG 2000_ T 1_ SIG ▁) ▁) ▁|| ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y 0 ▁+ ▁4 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁& ▁( ▁JPEG 2000_ T 1_ SIG _ NB ▁| ▁JPEG 2000_ T 1_ VIS ▁| ▁JPEG 2000_ T 1_ SIG ▁) ▁) ▁) ▁) ▁{ ▁if ▁( ▁! ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁MQ C _ CX _ RL ▁) ▁) ▁continue ▁; ▁run len ▁= ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁MQ C _ CX _ UNI ▁) ▁; ▁run len ▁= ▁( ▁run len ▁<< ▁1 ▁) ▁| ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁MQ C _ CX _ UNI ▁) ▁; ▁dec ▁= ▁1 ▁; ▁} ▁else ▁{ ▁run len ▁= ▁0 ▁; ▁dec ▁= ▁0 ▁; ▁} ▁for ▁( ▁y ▁= ▁y 0 ▁+ ▁run len ▁; ▁y ▁< ▁y 0 ▁+ ▁4 ▁&& ▁y ▁< ▁height ▁; ▁y ▁++ ▁) ▁{ ▁if ▁( ▁! ▁dec ▁) ▁{ ▁if ▁( ▁! ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁& ▁( ▁JPEG 2000_ T 1_ SIG ▁| ▁JPEG 2000_ T 1_ VIS ▁) ▁) ▁) ▁{ ▁int ▁flags _ mask ▁= ▁-1 ▁; ▁if ▁( ▁vert _ ca us al _ ctx _ cst y _ symbol ▁&& ▁y ▁== ▁y 0 ▁+ ▁3 ▁) ▁flags _ mask ▁&= ▁ ~ ▁( ▁JPEG 2000_ T 1_ SIG _ S ▁| ▁JPEG 2000_ T 1_ SIG _ SW ▁| ▁JPEG 2000_ T 1_ SIG _ SE ▁) ▁; ▁dec ▁= ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁ff _ jpeg 2000_ get sig ctx no ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁& ▁flags _ mask ▁, ▁band no ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁dec ▁) ▁{ ▁int ▁xor bit ▁; ▁int ▁ctx no ▁= ▁ff _ jpeg 2000_ get sg n ctx no ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁, ▁& ▁xor bit ▁) ▁; ▁t 1 ▁-> ▁data ▁[ ▁y ▁] ▁[ ▁x ▁] ▁= ▁( ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁ctx no ▁) ▁ ^ ▁xor bit ▁) ▁? ▁- ▁mask ▁: ▁mask ▁; ▁ff _ jpeg 2000_ set _ sign ific ance ▁( ▁t 1 ▁, ▁x ▁, ▁y ▁, ▁t 1 ▁-> ▁data ▁[ ▁y ▁] ▁[ ▁x ▁] ▁< ▁0 ▁) ▁; ▁} ▁dec ▁= ▁0 ▁; ▁t 1 ▁-> ▁flags ▁[ ▁y ▁+ ▁1 ▁] ▁[ ▁x ▁+ ▁1 ▁] ▁&= ▁ ~ ▁JPEG 2000_ T 1_ VIS ▁; ▁} ▁} ▁} ▁if ▁( ▁seg _ symbols ▁) ▁{ ▁int ▁val ▁; ▁val ▁= ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁MQ C _ CX _ UNI ▁) ▁; ▁val ▁= ▁( ▁val ▁<< ▁1 ▁) ▁+ ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁MQ C _ CX _ UNI ▁) ▁; ▁val ▁= ▁( ▁val ▁<< ▁1 ▁) ▁+ ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁MQ C _ CX _ UNI ▁) ▁; ▁val ▁= ▁( ▁val ▁<< ▁1 ▁) ▁+ ▁ff _ mq c _ decode ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁t 1 ▁-> ▁mqc ▁. ▁cx _ states ▁+ ▁MQ C _ CX _ UNI ▁) ▁; ▁if ▁( ▁val ▁!= ▁0 xa ▁) ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Segment ations ymbol value inc orrect \ n " ▁) ▁; ▁} ▁}	1
▁int ▁read _ file ▁( ▁const ▁char ▁* ▁filename ▁, ▁char ▁* ▁* ▁bufptr ▁, ▁size _ t ▁* ▁size ▁) ▁{ ▁int ▁ret ▁; ▁FILE ▁* ▁f ▁= ▁fopen ▁( ▁filename ▁, ▁" rb " ▁) ▁; ▁if ▁( ▁! ▁f ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cannot read file ' % s ' :% s \ n " ▁, ▁filename ▁, ▁strerror ▁( ▁errno ▁) ▁) ▁; ▁return ▁AVERROR ▁( ▁errno ▁) ▁; ▁} ▁fseek ▁( ▁f ▁, ▁0 ▁, ▁SEEK _ END ▁) ▁; ▁* ▁size ▁= ▁ftell ▁( ▁f ▁) ▁; ▁fseek ▁( ▁f ▁, ▁0 ▁, ▁SEEK _ SET ▁) ▁; ▁* ▁bufptr ▁= ▁av _ malloc ▁( ▁* ▁size ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁* ▁bufptr ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Could not allocate file buffer \ n " ▁) ▁; ▁fclose ▁( ▁f ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁ret ▁= ▁fread ▁( ▁* ▁bufptr ▁, ▁1 ▁, ▁* ▁size ▁, ▁f ▁) ▁; ▁if ▁( ▁ret ▁< ▁* ▁size ▁) ▁{ ▁av _ free ▁( ▁* ▁bufptr ▁) ▁; ▁if ▁( ▁ferror ▁( ▁f ▁) ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error wh il ere ading file ' % s ' :% s \ n " ▁, ▁filename ▁, ▁strerror ▁( ▁errno ▁) ▁) ▁; ▁ret ▁= ▁AVERROR ▁( ▁errno ▁) ▁; ▁} ▁else ▁ret ▁= ▁AVERROR _ EOF ▁; ▁} ▁else ▁{ ▁ret ▁= ▁0 ▁; ▁( ▁* ▁bufptr ▁) ▁[ ▁* ▁size ▁++ ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁fclose ▁( ▁f ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁opus _ decode _ packet ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame _ ptr ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁Op us Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁frame ▁= ▁data ▁; ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁int ▁coded _ samples ▁= ▁0 ▁; ▁int ▁decoded _ samples ▁= ▁0 ▁; ▁int ▁i ▁, ▁ret ▁; ▁int ▁delayed _ samples ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁Op us Stream Context ▁* ▁s ▁= ▁& ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁s ▁-> ▁out ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁out ▁[ ▁1 ▁] ▁= ▁NULL ▁; ▁delayed _ samples ▁= ▁FF MAX ▁( ▁delayed _ samples ▁, ▁s ▁-> ▁delayed _ samples ▁) ▁; ▁} ▁if ▁( ▁buf ▁) ▁{ ▁Op us Packet ▁* ▁pkt ▁= ▁& ▁c ▁-> ▁streams ▁[ ▁0 ▁] ▁. ▁packet ▁; ▁ret ▁= ▁ff _ opus _ parse _ packet ▁( ▁pkt ▁, ▁buf ▁, ▁buf _ size ▁, ▁c ▁-> ▁nb _ streams ▁> ▁1 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error parsing the packet header .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁coded _ samples ▁+= ▁pkt ▁-> ▁frame _ count ▁* ▁pkt ▁-> ▁frame _ duration ▁; ▁c ▁-> ▁streams ▁[ ▁0 ▁] ▁. ▁silk _ sampler ate ▁= ▁get _ sil k _ sampler ate ▁( ▁pkt ▁-> ▁config ▁) ▁; ▁} ▁frame ▁-> ▁nb _ samples ▁= ▁coded _ samples ▁+ ▁delayed _ samples ▁; ▁if ▁( ▁! ▁frame ▁-> ▁nb _ samples ▁) ▁{ ▁* ▁got _ frame _ ptr ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁frame ▁, ▁0 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁frame ▁-> ▁nb _ samples ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁Channel Map ▁* ▁map ▁= ▁& ▁c ▁-> ▁channel _ maps ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁map ▁-> ▁copy ▁) ▁c ▁-> ▁streams ▁[ ▁map ▁-> ▁stream _ idx ▁] ▁. ▁out ▁[ ▁map ▁-> ▁channel _ idx ▁] ▁= ▁( ▁float ▁* ▁) ▁frame ▁-> ▁extended _ data ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁. ▁out _ size ▁= ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁Op us Stream Context ▁* ▁s ▁= ▁& ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁i ▁&& ▁buf ▁) ▁{ ▁ret ▁= ▁ff _ opus _ parse _ packet ▁( ▁& ▁s ▁-> ▁packet ▁, ▁buf ▁, ▁buf _ size ▁, ▁i ▁!= ▁c ▁-> ▁nb _ streams ▁- ▁1 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error parsing the packet header .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁coded _ samples ▁!= ▁s ▁-> ▁packet ▁. ▁frame _ count ▁* ▁s ▁-> ▁packet ▁. ▁frame _ duration ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Mismatch ing code ds ample count in substream % d .\ n " ▁, ▁i ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁silk _ sampler ate ▁= ▁get _ sil k _ sampler ate ▁( ▁s ▁-> ▁packet ▁. ▁config ▁) ▁; ▁} ▁ret ▁= ▁opus _ decode _ sub packet ▁( ▁& ▁c ▁-> ▁streams ▁[ ▁i ▁] ▁, ▁buf ▁, ▁s ▁-> ▁packet ▁. ▁data _ size ▁, ▁coded _ samples ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁decoded _ samples ▁&& ▁ret ▁!= ▁decoded _ samples ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Different numbers of decode ds amples " ▁" in am ulti - channel stream \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁decoded _ samples ▁= ▁ret ▁; ▁buf ▁+= ▁s ▁-> ▁packet ▁. ▁packet _ size ▁; ▁buf _ size ▁-= ▁s ▁-> ▁packet ▁. ▁packet _ size ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁Channel Map ▁* ▁map ▁= ▁& ▁c ▁-> ▁channel _ maps ▁[ ▁i ▁] ▁; ▁if ▁( ▁map ▁-> ▁copy ▁) ▁{ ▁memcpy ▁( ▁frame ▁-> ▁extended _ data ▁[ ▁i ▁] ▁, ▁frame ▁-> ▁extended _ data ▁[ ▁map ▁-> ▁copy _ idx ▁] ▁, ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁map ▁-> ▁sil ence ▁) ▁{ ▁memset ▁( ▁frame ▁-> ▁extended _ data ▁[ ▁i ▁] ▁, ▁0 ▁, ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁gain _ i ▁) ▁{ ▁c ▁-> ▁f dsp ▁-> ▁vector _ fmul _ scalar ▁( ▁( ▁float ▁* ▁) ▁frame ▁-> ▁extended _ data ▁[ ▁i ▁] ▁, ▁( ▁float ▁* ▁) ▁frame ▁-> ▁extended _ data ▁[ ▁i ▁] ▁, ▁c ▁-> ▁gain ▁, ▁FF ALIGN ▁( ▁decoded _ samples ▁, ▁8 ▁) ▁) ▁; ▁} ▁} ▁frame ▁-> ▁nb _ samples ▁= ▁decoded _ samples ▁; ▁* ▁got _ frame _ ptr ▁= ▁! ▁! ▁decoded _ samples ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁}	0
▁int ▁ASN 1_ BIT _ STRING _ set _ bit ▁( ▁ASN 1_ BIT _ STRING ▁* ▁a ▁, ▁int ▁n ▁, ▁int ▁value ▁) ▁{ ▁int ▁w ▁, ▁v ▁, ▁iv ▁; ▁unsigned ▁char ▁* ▁c ▁; ▁w ▁= ▁n ▁/ ▁8 ▁; ▁v ▁= ▁1 ▁<< ▁( ▁7 ▁- ▁( ▁n ▁& ▁0 x 07 ▁) ▁) ▁; ▁iv ▁= ▁ ~ ▁v ▁; ▁a ▁-> ▁flags ▁&= ▁ ~ ▁( ▁ASN 1_ STRING _ FLAG _ BITS _ LEFT ▁| ▁0 x 07 ▁) ▁; ▁if ▁( ▁a ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁if ▁( ▁( ▁a ▁-> ▁length ▁< ▁( ▁w ▁+ ▁1 ▁) ▁) ▁|| ▁( ▁a ▁-> ▁data ▁== ▁NULL ▁) ▁) ▁{ ▁if ▁( ▁! ▁value ▁) ▁return ▁( ▁1 ▁) ▁; ▁if ▁( ▁a ▁-> ▁data ▁== ▁NULL ▁) ▁c ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁OPENSSL _ malloc ▁( ▁w ▁+ ▁1 ▁) ▁; ▁else ▁c ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁OPENSSL _ realloc ▁( ▁a ▁-> ▁data ▁, ▁w ▁+ ▁1 ▁) ▁; ▁if ▁( ▁c ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁if ▁( ▁w ▁+ ▁1 ▁- ▁a ▁-> ▁length ▁> ▁0 ▁) ▁memset ▁( ▁c ▁+ ▁a ▁-> ▁length ▁, ▁0 ▁, ▁w ▁+ ▁1 ▁- ▁a ▁-> ▁length ▁) ▁; ▁a ▁-> ▁data ▁= ▁c ▁; ▁a ▁-> ▁length ▁= ▁w ▁+ ▁1 ▁; ▁} ▁a ▁-> ▁data ▁[ ▁w ▁] ▁= ▁( ▁( ▁a ▁-> ▁data ▁[ ▁w ▁] ▁) ▁& ▁iv ▁) ▁| ▁v ▁; ▁while ▁( ▁( ▁a ▁-> ▁length ▁> ▁0 ▁) ▁&& ▁( ▁a ▁-> ▁data ▁[ ▁a ▁-> ▁length ▁- ▁1 ▁] ▁== ▁0 ▁) ▁) ▁a ▁-> ▁length ▁-- ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	0
▁static ▁int ▁decode _ frame _ header ▁( ▁N UT Context ▁* ▁n ut ▁, ▁int 64_ t ▁* ▁pts ▁, ▁int ▁* ▁stream _ id ▁, ▁uint 8_ t ▁* ▁header _ idx ▁, ▁int ▁frame _ code ▁) ▁{ ▁AVFormatContext ▁* ▁s ▁= ▁n ut ▁-> ▁av f ▁; ▁AVIO Context ▁* ▁bc ▁= ▁s ▁-> ▁pb ▁; ▁Stream Context ▁* ▁stc ▁; ▁int ▁size ▁, ▁flags ▁, ▁size _ mul ▁, ▁pts _ delta ▁, ▁i ▁, ▁reserved _ count ▁; ▁uint 64_ t ▁tmp ▁; ▁if ▁( ▁avio _ tell ▁( ▁bc ▁) ▁> ▁n ut ▁-> ▁last _ sync point _ pos ▁+ ▁n ut ▁-> ▁max _ distance ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Last frame must have be end am aged %" ▁PRId 64 ▁"> %" ▁PRId 64 ▁"+ % d \ n " ▁, ▁avio _ tell ▁( ▁bc ▁) ▁, ▁n ut ▁-> ▁last _ sync point _ pos ▁, ▁n ut ▁-> ▁max _ distance ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁flags ▁= ▁n ut ▁-> ▁frame _ code ▁[ ▁frame _ code ▁] ▁. ▁flags ▁; ▁size _ mul ▁= ▁n ut ▁-> ▁frame _ code ▁[ ▁frame _ code ▁] ▁. ▁size _ mul ▁; ▁size ▁= ▁n ut ▁-> ▁frame _ code ▁[ ▁frame _ code ▁] ▁. ▁size _ lsb ▁; ▁* ▁stream _ id ▁= ▁n ut ▁-> ▁frame _ code ▁[ ▁frame _ code ▁] ▁. ▁stream _ id ▁; ▁pts _ delta ▁= ▁n ut ▁-> ▁frame _ code ▁[ ▁frame _ code ▁] ▁. ▁pts _ delta ▁; ▁reserved _ count ▁= ▁n ut ▁-> ▁frame _ code ▁[ ▁frame _ code ▁] ▁. ▁reserved _ count ▁; ▁* ▁header _ idx ▁= ▁n ut ▁-> ▁frame _ code ▁[ ▁frame _ code ▁] ▁. ▁header _ idx ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ INVALID ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ CODED ▁) ▁flags ▁ ^ = ▁ff io _ read _ var len ▁( ▁bc ▁) ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ STREAM _ ID ▁) ▁{ ▁GET _ V ▁( ▁* ▁stream _ id ▁, ▁tmp ▁< ▁s ▁-> ▁nb _ streams ▁) ▁; ▁} ▁stc ▁= ▁& ▁n ut ▁-> ▁stream ▁[ ▁* ▁stream _ id ▁] ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ CODED _ PT S ▁) ▁{ ▁int ▁coded _ pts ▁= ▁ff io _ read _ var len ▁( ▁bc ▁) ▁; ▁if ▁( ▁coded _ pts ▁< ▁( ▁1 ▁<< ▁stc ▁-> ▁msb _ pts _ shift ▁) ▁) ▁{ ▁* ▁pts ▁= ▁ff _ lsb 2 full ▁( ▁stc ▁, ▁coded _ pts ▁) ▁; ▁} ▁else ▁* ▁pts ▁= ▁coded _ pts ▁- ▁( ▁1 LL ▁<< ▁stc ▁-> ▁msb _ pts _ shift ▁) ▁; ▁} ▁else ▁* ▁pts ▁= ▁stc ▁-> ▁last _ pts ▁+ ▁pts _ delta ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ SIZE _ MSB ▁) ▁size ▁+= ▁size _ mul ▁* ▁ff io _ read _ var len ▁( ▁bc ▁) ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ MATCH _ TIME ▁) ▁get _ s ▁( ▁bc ▁) ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ HEADER _ IDX ▁) ▁* ▁header _ idx ▁= ▁ff io _ read _ var len ▁( ▁bc ▁) ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ RESERVED ▁) ▁reserved _ count ▁= ▁ff io _ read _ var len ▁( ▁bc ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁reserved _ count ▁; ▁i ▁++ ▁) ▁ff io _ read _ var len ▁( ▁bc ▁) ▁; ▁if ▁( ▁* ▁header _ idx ▁>= ▁( ▁unsigned ▁) ▁n ut ▁-> ▁header _ count ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" header _ idx invalid \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁size ▁> ▁4096 ▁) ▁* ▁header _ idx ▁= ▁0 ▁; ▁size ▁-= ▁n ut ▁-> ▁header _ len ▁[ ▁* ▁header _ idx ▁] ▁; ▁if ▁( ▁flags ▁& ▁FLAG _ CHECKSUM ▁) ▁{ ▁avio _ rb 32 ▁( ▁bc ▁) ▁; ▁} ▁else ▁if ▁( ▁size ▁> ▁2 ▁* ▁n ut ▁-> ▁max _ distance ▁|| ▁FF ABS ▁( ▁stc ▁-> ▁last _ pts ▁- ▁* ▁pts ▁) ▁> ▁stc ▁-> ▁max _ pts _ distance ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" frames ize > 2 max _ distance and noc heck sum \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁stc ▁-> ▁last _ pts ▁= ▁* ▁pts ▁; ▁stc ▁-> ▁last _ flags ▁= ▁flags ▁; ▁return ▁size ▁; ▁}	0
▁int ▁R ENAME ▁( ▁sw ri _ res ample ▁) ▁( ▁Res ample Context ▁* ▁c ▁, ▁DE LEM ▁* ▁dst ▁, ▁const ▁DE LEM ▁* ▁src ▁, ▁int ▁* ▁consumed ▁, ▁int ▁src _ size ▁, ▁int ▁dst _ size ▁, ▁int ▁update _ ctx ▁) ▁{ ▁int ▁dst _ index ▁, ▁i ▁; ▁int ▁index ▁= ▁c ▁-> ▁index ▁; ▁int ▁frac ▁= ▁c ▁-> ▁frac ▁; ▁int ▁dst _ incr _ frac ▁= ▁c ▁-> ▁dst _ incr ▁% ▁c ▁-> ▁src _ incr ▁; ▁int ▁dst _ incr ▁= ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁av _ assert 1 ▁( ▁c ▁-> ▁filter _ shift ▁== ▁FILTER _ SHIFT ▁) ▁; ▁av _ assert 1 ▁( ▁c ▁-> ▁fe lem _ size ▁== ▁sizeof ▁( ▁F ELEM ▁) ▁) ▁; ▁if ▁( ▁c ▁-> ▁filter _ length ▁== ▁1 ▁&& ▁c ▁-> ▁phase _ shift ▁== ▁0 ▁) ▁{ ▁int 64_ t ▁index 2 ▁= ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁c ▁-> ▁frac ▁/ ▁c ▁-> ▁src _ incr ▁+ ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁index ▁; ▁int 64_ t ▁incr ▁= ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁int ▁new _ size ▁= ▁( ▁src _ size ▁* ▁( ▁int 64_ t ▁) ▁c ▁-> ▁src _ incr ▁- ▁frac ▁+ ▁c ▁-> ▁dst _ incr ▁- ▁1 ▁) ▁/ ▁c ▁-> ▁dst _ incr ▁; ▁dst _ size ▁= ▁FF MIN ▁( ▁dst _ size ▁, ▁new _ size ▁) ▁; ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁dst _ size ▁; ▁dst _ index ▁++ ▁) ▁{ ▁dst ▁[ ▁dst _ index ▁] ▁= ▁src ▁[ ▁index 2 ▁>> ▁32 ▁] ▁; ▁index 2 ▁+= ▁incr ▁; ▁} ▁index ▁+= ▁dst _ index ▁* ▁dst _ incr ▁; ▁index ▁+= ▁( ▁frac ▁+ ▁dst _ index ▁* ▁( ▁int 64_ t ▁) ▁dst _ incr _ frac ▁) ▁/ ▁c ▁-> ▁src _ incr ▁; ▁frac ▁= ▁( ▁frac ▁+ ▁dst _ index ▁* ▁( ▁int 64_ t ▁) ▁dst _ incr _ frac ▁) ▁% ▁c ▁-> ▁src _ incr ▁; ▁av _ assert 2 ▁( ▁index ▁>= ▁0 ▁) ▁; ▁* ▁consumed ▁= ▁index ▁; ▁index ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁index ▁>= ▁0 ▁) ▁{ ▁int 64_ t ▁end _ index ▁= ▁( ▁1 LL ▁+ ▁src _ size ▁- ▁c ▁-> ▁filter _ length ▁) ▁<< ▁c ▁-> ▁phase _ shift ▁; ▁int 64_ t ▁delta _ frac ▁= ▁( ▁end _ index ▁- ▁index ▁) ▁* ▁c ▁-> ▁src _ incr ▁- ▁c ▁-> ▁frac ▁; ▁int ▁delta _ n ▁= ▁( ▁delta _ frac ▁+ ▁c ▁-> ▁dst _ incr ▁- ▁1 ▁) ▁/ ▁c ▁-> ▁dst _ incr ▁; ▁int ▁n ▁= ▁FF MIN ▁( ▁dst _ size ▁, ▁delta _ n ▁) ▁; ▁int ▁sample _ index ▁; ▁if ▁( ▁! ▁c ▁-> ▁linear ▁) ▁{ ▁sample _ index ▁= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁n ▁; ▁dst _ index ▁++ ▁) ▁{ ▁F ELEM ▁* ▁filter ▁= ▁( ▁( ▁F ELEM ▁* ▁) ▁c ▁-> ▁filter _ bank ▁) ▁+ ▁c ▁-> ▁filter _ alloc ▁* ▁index ▁; ▁# ifdef ▁COMMON _ CORE ▁COMMON _ CORE ▁# else ▁F ELEM 2 ▁val ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁} ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁# endif ▁frac ▁+= ▁dst _ incr _ frac ▁; ▁index ▁+= ▁dst _ incr ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁sample _ index ▁+= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁} ▁} ▁else ▁{ ▁sample _ index ▁= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁n ▁; ▁dst _ index ▁++ ▁) ▁{ ▁F ELEM ▁* ▁filter ▁= ▁( ▁( ▁F ELEM ▁* ▁) ▁c ▁-> ▁filter _ bank ▁) ▁+ ▁c ▁-> ▁filter _ alloc ▁* ▁index ▁; ▁F ELEM 2 ▁val ▁= ▁0 ▁, ▁v 2 ▁= ▁0 ▁; ▁# ifdef ▁LINE AR _ CORE ▁LINE AR _ CORE ▁# else ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁v 2 ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁+ ▁c ▁-> ▁filter _ alloc ▁] ▁; ▁} ▁# endif ▁val ▁+= ▁( ▁v 2 ▁- ▁val ▁) ▁* ▁( ▁F ELE ML ▁) ▁frac ▁/ ▁c ▁-> ▁src _ incr ▁; ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁frac ▁+= ▁dst _ incr _ frac ▁; ▁index ▁+= ▁dst _ incr ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁sample _ index ▁+= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁} ▁} ▁* ▁consumed ▁= ▁sample _ index ▁; ▁} ▁else ▁{ ▁int ▁sample _ index ▁= ▁0 ▁; ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁dst _ size ▁; ▁dst _ index ▁++ ▁) ▁{ ▁F ELEM ▁* ▁filter ▁; ▁F ELEM 2 ▁val ▁= ▁0 ▁; ▁sample _ index ▁+= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁filter ▁= ▁( ▁( ▁F ELEM ▁* ▁) ▁c ▁-> ▁filter _ bank ▁) ▁+ ▁c ▁-> ▁filter _ alloc ▁* ▁index ▁; ▁if ▁( ▁sample _ index ▁+ ▁c ▁-> ▁filter _ length ▁> ▁src _ size ▁|| ▁- ▁sample _ index ▁>= ▁src _ size ▁) ▁{ ▁break ▁; ▁} ▁else ▁if ▁( ▁sample _ index ▁< ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁val ▁+= ▁src ▁[ ▁FF ABS ▁( ▁sample _ index ▁+ ▁i ▁) ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁} ▁else ▁if ▁( ▁c ▁-> ▁linear ▁) ▁{ ▁F ELEM 2 ▁v 2 ▁= ▁0 ▁; ▁# ifdef ▁LINE AR _ CORE ▁LINE AR _ CORE ▁# else ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁v 2 ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁+ ▁c ▁-> ▁filter _ alloc ▁] ▁; ▁} ▁# endif ▁val ▁+= ▁( ▁v 2 ▁- ▁val ▁) ▁* ▁( ▁F ELE ML ▁) ▁frac ▁/ ▁c ▁-> ▁src _ incr ▁; ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁} ▁else ▁{ ▁# ifdef ▁COMMON _ CORE ▁COMMON _ CORE ▁# else ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁} ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁# endif ▁} ▁frac ▁+= ▁dst _ incr _ frac ▁; ▁index ▁+= ▁dst _ incr ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁} ▁* ▁consumed ▁= ▁FF MAX ▁( ▁sample _ index ▁, ▁0 ▁) ▁; ▁index ▁+= ▁FF MIN ▁( ▁sample _ index ▁, ▁0 ▁) ▁<< ▁c ▁-> ▁phase _ shift ▁; ▁} ▁if ▁( ▁update _ ctx ▁) ▁{ ▁c ▁-> ▁frac ▁= ▁frac ▁; ▁c ▁-> ▁index ▁= ▁index ▁; ▁} ▁return ▁dst _ index ▁; ▁}	1
▁static ▁inline ▁void ▁MP V _ motion _ low res ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁dir ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁h 264_ chroma _ mc _ func ▁* ▁pix _ op ▁) ▁{ ▁int ▁mx ▁, ▁my ▁; ▁int ▁mb _ x ▁, ▁mb _ y ▁, ▁i ▁; ▁const ▁int ▁low res ▁= ▁s ▁-> ▁avctx ▁-> ▁low res ▁; ▁const ▁int ▁block _ s ▁= ▁8 ▁>> ▁low res ▁; ▁mb _ x ▁= ▁s ▁-> ▁mb _ x ▁; ▁mb _ y ▁= ▁s ▁-> ▁mb _ y ▁; ▁switch ▁( ▁s ▁-> ▁mv _ type ▁) ▁{ ▁case ▁MV _ TYPE _16 X 16 ▁: ▁mpeg _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁2 ▁* ▁block _ s ▁, ▁mb _ y ▁) ▁; ▁break ▁; ▁case ▁MV _ TYPE _8 X 8 ▁: ▁mx ▁= ▁0 ▁; ▁my ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁h pel _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁+ ▁( ▁( ▁i ▁& ▁1 ▁) ▁+ ▁( ▁i ▁>> ▁1 ▁) ▁* ▁s ▁-> ▁linesize ▁) ▁* ▁block _ s ▁, ▁ref _ picture ▁[ ▁0 ▁] ▁, ▁0 ▁, ▁0 ▁, ▁( ▁2 ▁* ▁mb _ x ▁+ ▁( ▁i ▁& ▁1 ▁) ▁) ▁* ▁block _ s ▁, ▁( ▁2 ▁* ▁mb _ y ▁+ ▁( ▁i ▁>> ▁1 ▁) ▁) ▁* ▁block _ s ▁, ▁s ▁-> ▁width ▁, ▁s ▁-> ▁height ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁low res ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁low res ▁, ▁block _ s ▁, ▁block _ s ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁) ▁; ▁mx ▁+= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁my ▁+= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁chroma _4 mv _ motion _ low res ▁( ▁s ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁mx ▁, ▁my ▁) ▁; ▁break ▁; ▁case ▁MV _ TYPE _ FIELD ▁: ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁{ ▁mpeg _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁1 ▁, ▁0 ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁block _ s ▁, ▁mb _ y ▁) ▁; ▁mpeg _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁1 ▁, ▁1 ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁1 ▁] ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁, ▁block _ s ▁, ▁mb _ y ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁picture _ structure ▁!= ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁+ ▁1 ▁&& ▁s ▁-> ▁pict _ type ▁!= ▁AV _ PICTURE _ TYPE _ B ▁&& ▁! ▁s ▁-> ▁first _ field ▁) ▁{ ▁ref _ picture ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁data ▁; ▁} ▁mpeg _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁0 ▁, ▁0 ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁2 ▁* ▁block _ s ▁, ▁mb _ y ▁>> ▁1 ▁) ▁; ▁} ▁break ▁; ▁case ▁MV _ TYPE _16 X 8 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁uint 8_ t ▁* ▁* ▁ref 2 picture ▁; ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁|| ▁s ▁-> ▁pict _ type ▁== ▁AV _ PICTURE _ TYPE _ B ▁|| ▁s ▁-> ▁first _ field ▁) ▁{ ▁ref 2 picture ▁= ▁ref _ picture ▁; ▁} ▁else ▁{ ▁ref 2 picture ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁data ▁; ▁} ▁mpeg _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁0 ▁, ▁0 ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁, ▁ref 2 picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+ ▁2 ▁* ▁block _ s ▁* ▁i ▁, ▁block _ s ▁, ▁mb _ y ▁>> ▁1 ▁) ▁; ▁dest _ y ▁+= ▁2 ▁* ▁block _ s ▁* ▁s ▁-> ▁linesize ▁; ▁dest _ cb ▁+= ▁( ▁2 ▁* ▁block _ s ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁* ▁s ▁-> ▁uv lines ize ▁; ▁dest _ cr ▁+= ▁( ▁2 ▁* ▁block _ s ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁* ▁s ▁-> ▁uv lines ize ▁; ▁} ▁break ▁; ▁case ▁MV _ TYPE _ DM V ▁: ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁mpeg _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁1 ▁, ▁j ▁, ▁j ▁ ^ ▁i ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁+ ▁j ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁+ ▁j ▁] ▁[ ▁1 ▁] ▁, ▁block _ s ▁, ▁mb _ y ▁) ▁; ▁} ▁pix _ op ▁= ▁s ▁-> ▁h 264 chroma ▁. ▁avg _ h 264_ chroma _ pixels _ tab ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁mpeg _ motion _ low res ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁0 ▁, ▁0 ▁, ▁s ▁-> ▁picture _ structure ▁!= ▁i ▁+ ▁1 ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁] ▁[ ▁1 ▁] ▁, ▁2 ▁* ▁block _ s ▁, ▁mb _ y ▁>> ▁1 ▁) ▁; ▁pix _ op ▁= ▁s ▁-> ▁h 264 chroma ▁. ▁avg _ h 264_ chroma _ pixels _ tab ▁; ▁if ▁( ▁! ▁s ▁-> ▁first _ field ▁) ▁{ ▁ref _ picture ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁data ▁; ▁} ▁} ▁} ▁break ▁; ▁default ▁: ▁av _ assert 2 ▁( ▁0 ▁) ▁; ▁} ▁}	1
▁int ▁av _ image _ get _ lines ize ▁( ▁enum ▁PixelFormat ▁pix _ fmt ▁, ▁int ▁width ▁, ▁int ▁plane ▁) ▁{ ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁& ▁av _ pix _ fmt _ descriptors ▁[ ▁pix _ fmt ▁] ▁; ▁int ▁max _ step ▁[ ▁4 ▁] ▁; ▁int ▁max _ step _ comp ▁[ ▁4 ▁] ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁pix _ fmt ▁>= ▁PIX _ FMT _ NB ▁|| ▁desc ▁-> ▁flags ▁& ▁PIX _ FMT _ HW ACCEL ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁av _ image _ fill _ max _ pix steps ▁( ▁max _ step ▁, ▁max _ step _ comp ▁, ▁desc ▁) ▁; ▁return ▁image _ get _ lines ize ▁( ▁width ▁, ▁plane ▁, ▁max _ step ▁[ ▁plane ▁] ▁, ▁max _ step _ comp ▁[ ▁plane ▁] ▁, ▁desc ▁) ▁; ▁}	0
▁void ▁ff _ af _ queue _ remove ▁( ▁Audio Frame Queue ▁* ▁af q ▁, ▁int ▁nb _ samples ▁, ▁int 64_ t ▁* ▁pts ▁, ▁int 64_ t ▁* ▁duration ▁) ▁{ ▁int 64_ t ▁out _ pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁int ▁removed _ samples ▁= ▁0 ▁; ▁int ▁i ▁; ▁if ▁( ▁af q ▁-> ▁frame _ count ▁|| ▁af q ▁-> ▁frame _ alloc ▁) ▁{ ▁if ▁( ▁af q ▁-> ▁frames ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁out _ pts ▁= ▁af q ▁-> ▁frames ▁-> ▁pts ▁; ▁} ▁if ▁( ▁! ▁af q ▁-> ▁frame _ count ▁) ▁av _ log ▁( ▁af q ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Trying t ore move % ds amples , but the queue ise mpty \ n " ▁, ▁nb _ samples ▁) ▁; ▁if ▁( ▁pts ▁) ▁* ▁pts ▁= ▁ff _ samples _ to _ time _ base ▁( ▁af q ▁-> ▁avctx ▁, ▁out _ pts ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁nb _ samples ▁&& ▁i ▁< ▁af q ▁-> ▁frame _ count ▁; ▁i ▁++ ▁) ▁{ ▁int ▁n ▁= ▁FF MIN ▁( ▁af q ▁-> ▁frames ▁[ ▁i ▁] ▁. ▁duration ▁, ▁nb _ samples ▁) ▁; ▁af q ▁-> ▁frames ▁[ ▁i ▁] ▁. ▁duration ▁-= ▁n ▁; ▁nb _ samples ▁-= ▁n ▁; ▁removed _ samples ▁+= ▁n ▁; ▁if ▁( ▁af q ▁-> ▁frames ▁[ ▁i ▁] ▁. ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁af q ▁-> ▁frames ▁[ ▁i ▁] ▁. ▁pts ▁+= ▁n ▁; ▁} ▁af q ▁-> ▁remaining _ samples ▁-= ▁removed _ samples ▁; ▁i ▁-= ▁i ▁&& ▁af q ▁-> ▁frames ▁[ ▁i ▁- ▁1 ▁] ▁. ▁duration ▁; ▁memmove ▁( ▁af q ▁-> ▁frames ▁, ▁af q ▁-> ▁frames ▁+ ▁i ▁, ▁sizeof ▁( ▁* ▁af q ▁-> ▁frames ▁) ▁* ▁( ▁af q ▁-> ▁frame _ count ▁- ▁i ▁) ▁) ▁; ▁af q ▁-> ▁frame _ count ▁-= ▁i ▁; ▁if ▁( ▁nb _ samples ▁) ▁{ ▁av _ assert 0 ▁( ▁! ▁af q ▁-> ▁frame _ count ▁) ▁; ▁av _ assert 0 ▁( ▁af q ▁-> ▁remaining _ samples ▁== ▁af q ▁-> ▁remaining _ delay ▁) ▁; ▁if ▁( ▁af q ▁-> ▁frames ▁&& ▁af q ▁-> ▁frames ▁[ ▁0 ▁] ▁. ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁af q ▁-> ▁frames ▁[ ▁0 ▁] ▁. ▁pts ▁+= ▁nb _ samples ▁; ▁av _ log ▁( ▁af q ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Trying t ore move % dm ores ample st han there are int he queue \ n " ▁, ▁nb _ samples ▁) ▁; ▁} ▁if ▁( ▁duration ▁) ▁* ▁duration ▁= ▁ff _ samples _ to _ time _ base ▁( ▁af q ▁-> ▁avctx ▁, ▁removed _ samples ▁) ▁; ▁}	1
▁static ▁av _ cold ▁int ▁init ▁( ▁AVFilter Context ▁* ▁ctx ▁) ▁{ ▁HD CD Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv ▁; ▁int ▁c ▁; ▁s ▁-> ▁sample _ count ▁= ▁0 ▁; ▁s ▁-> ▁fctx ▁= ▁ctx ▁; ▁s ▁-> ▁bad _ config ▁= ▁0 ▁; ▁hd cd _ detect _ reset ▁( ▁& ▁s ▁-> ▁detect ▁) ▁; ▁for ▁( ▁c ▁= ▁0 ▁; ▁c ▁< ▁HD CD _ MAX _ CHANNELS ▁; ▁c ▁++ ▁) ▁{ ▁hd cd _ reset ▁( ▁& ▁s ▁-> ▁state ▁[ ▁c ▁] ▁, ▁44100 ▁, ▁s ▁-> ▁cdt _ ms ▁) ▁; ▁} ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" CD T period :% dms (% us amples @ 44 100 Hz )\ n " ▁, ▁s ▁-> ▁cdt _ ms ▁, ▁s ▁-> ▁state ▁[ ▁0 ▁] ▁. ▁su st ain _ reset ▁) ▁; ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" Process mode :% s \ n " ▁, ▁( ▁s ▁-> ▁process _ stereo ▁) ▁? ▁" process stereo channel sto gether " ▁: ▁" pro ces se ach channel separ ately " ▁) ▁; ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" Force PE :% s \ n " ▁, ▁( ▁s ▁-> ▁force _ pe ▁) ▁? ▁" on " ▁: ▁" off " ▁) ▁; ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" An alyz em ode : [% d ] % s \ n " ▁, ▁s ▁-> ▁analyze _ mode ▁, ▁an a _ mode _ str ▁[ ▁s ▁-> ▁analyze _ mode ▁] ▁) ▁; ▁if ▁( ▁s ▁-> ▁disable _ aut ocon vert ▁) ▁avfilter _ graph _ set _ auto _ convert ▁( ▁ctx ▁-> ▁graph ▁, ▁AV FILTER _ AUTO _ CONVERT _ NONE ▁) ▁; ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" Auto - convert :% s ( requested :% s )\ n " ▁, ▁( ▁ctx ▁-> ▁graph ▁-> ▁disable _ auto _ convert ▁) ▁? ▁" disabled " ▁: ▁" enabled " ▁, ▁( ▁s ▁-> ▁disable _ aut ocon vert ▁) ▁? ▁" disable " ▁: ▁" don ot disable " ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁apc _ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁AVStream ▁* ▁st ▁; ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ AD PCM _ I MA _ AP C ▁; ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁ff _ get _ extr adata ▁( ▁s ▁, ▁st ▁-> ▁codecpar ▁, ▁pb ▁, ▁2 ▁* ▁4 ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁avio _ rl 32 ▁( ▁pb ▁) ▁) ▁{ ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁2 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ STEREO ▁; ▁} ▁else ▁{ ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁1 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ MONO ▁; ▁} ▁st ▁-> ▁codecpar ▁-> ▁bits _ per _ coded _ sample ▁= ▁4 ▁; ▁st ▁-> ▁codecpar ▁-> ▁bit _ rate ▁= ▁( ▁int 64_ t ▁) ▁st ▁-> ▁codecpar ▁-> ▁bits _ per _ coded _ sample ▁* ▁st ▁-> ▁codecpar ▁-> ▁channels ▁* ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁; ▁st ▁-> ▁codecpar ▁-> ▁block _ align ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁check _ pes ▁( ▁uint 8_ t ▁* ▁p ▁, ▁uint 8_ t ▁* ▁end ▁) ▁{ ▁int ▁p es 1 ▁; ▁int ▁p es 2 ▁= ▁( ▁p ▁[ ▁3 ▁] ▁& ▁0 xC 0 ▁) ▁== ▁0 x 80 ▁&& ▁( ▁p ▁[ ▁4 ▁] ▁& ▁0 xC 0 ▁) ▁!= ▁0 x 40 ▁&& ▁( ▁( ▁p ▁[ ▁4 ▁] ▁& ▁0 xC 0 ▁) ▁== ▁0 x 00 ▁|| ▁( ▁p ▁[ ▁4 ▁] ▁& ▁0 xC 0 ▁) ▁>> ▁2 ▁== ▁( ▁p ▁[ ▁6 ▁] ▁& ▁0 xF 0 ▁) ▁) ▁; ▁for ▁( ▁p ▁+= ▁3 ▁; ▁p ▁< ▁end ▁&& ▁* ▁p ▁== ▁0 xFF ▁; ▁p ▁++ ▁) ▁; ▁if ▁( ▁( ▁* ▁p ▁& ▁0 xC 0 ▁) ▁== ▁0 x 40 ▁) ▁p ▁+= ▁2 ▁; ▁if ▁( ▁( ▁* ▁p ▁& ▁0 xF 0 ▁) ▁== ▁0 x 20 ▁) ▁{ ▁p es 1 ▁= ▁p ▁[ ▁0 ▁] ▁& ▁p ▁[ ▁2 ▁] ▁& ▁p ▁[ ▁4 ▁] ▁& ▁1 ▁; ▁p ▁+= ▁5 ▁; ▁} ▁else ▁if ▁( ▁( ▁* ▁p ▁& ▁0 xF 0 ▁) ▁== ▁0 x 30 ▁) ▁{ ▁p es 1 ▁= ▁p ▁[ ▁0 ▁] ▁& ▁p ▁[ ▁2 ▁] ▁& ▁p ▁[ ▁4 ▁] ▁& ▁p ▁[ ▁5 ▁] ▁& ▁p ▁[ ▁7 ▁] ▁& ▁p ▁[ ▁9 ▁] ▁& ▁1 ▁; ▁p ▁+= ▁10 ▁; ▁} ▁else ▁p es 1 ▁= ▁* ▁p ▁== ▁0 x 0 F ▁; ▁return ▁p es 1 ▁|| ▁p es 2 ▁; ▁}	1
▁int ▁engine _ unlocked _ finish ▁( ▁ENGINE ▁* ▁e ▁, ▁int ▁unlock _ for _ handlers ▁) ▁{ ▁int ▁to _ return ▁= ▁1 ▁; ▁e ▁-> ▁funct _ ref ▁-- ▁; ▁engine _ ref _ debug ▁( ▁e ▁, ▁1 ▁, ▁-1 ▁) ▁; ▁if ▁( ▁( ▁e ▁-> ▁funct _ ref ▁== ▁0 ▁) ▁&& ▁e ▁-> ▁finish ▁) ▁{ ▁if ▁( ▁unlock _ for _ handlers ▁) ▁CRYPTO _ w _ unlock ▁( ▁CRYPTO _ LOCK _ ENGINE ▁) ▁; ▁to _ return ▁= ▁e ▁-> ▁finish ▁( ▁e ▁) ▁; ▁if ▁( ▁unlock _ for _ handlers ▁) ▁CRYPTO _ w _ lock ▁( ▁CRYPTO _ LOCK _ ENGINE ▁) ▁; ▁if ▁( ▁! ▁to _ return ▁) ▁return ▁0 ▁; ▁} ▁# ifdef ▁REF _ CHECK ▁if ▁( ▁e ▁-> ▁funct _ ref ▁< ▁0 ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" ENGINE _ finish , bad functional reference count \ n " ▁) ▁; ▁abort ▁( ▁) ▁; ▁} ▁# endif ▁if ▁( ▁! ▁engine _ free _ util ▁( ▁e ▁, ▁0 ▁) ▁) ▁{ ▁ENGINE err ▁( ▁ENGINE _ F _ ENGINE _ FINISH ▁, ▁ENGINE _ R _ FINISH _ FAILED ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁to _ return ▁; ▁}	1
▁static ▁int ▁decode _ dc _ progress ive ▁( ▁MJ peg Decode Context ▁* ▁s ▁, ▁int 16_ t ▁* ▁block ▁, ▁int ▁component ▁, ▁int ▁dc _ index ▁, ▁uint 16_ t ▁* ▁quant _ matrix ▁, ▁int ▁Al ▁) ▁{ ▁unsigned ▁val ▁; ▁s ▁-> ▁b dsp ▁. ▁clear _ block ▁( ▁block ▁) ▁; ▁val ▁= ▁m jpeg _ decode _ dc ▁( ▁s ▁, ▁dc _ index ▁) ▁; ▁if ▁( ▁val ▁== ▁0 xfffff ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" err ord c \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁val ▁= ▁( ▁val ▁* ▁( ▁quant _ matrix ▁[ ▁0 ▁] ▁<< ▁Al ▁) ▁) ▁+ ▁s ▁-> ▁last _ dc ▁[ ▁component ▁] ▁; ▁s ▁-> ▁last _ dc ▁[ ▁component ▁] ▁= ▁val ▁; ▁block ▁[ ▁0 ▁] ▁= ▁val ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁c ine p ak _ decode _ vectors ▁( ▁C ine p ak Context ▁* ▁s ▁, ▁cv id _ strip ▁* ▁strip ▁, ▁int ▁chunk _ id ▁, ▁int ▁size ▁, ▁const ▁uint 8_ t ▁* ▁data ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁e od ▁= ▁( ▁data ▁+ ▁size ▁) ▁; ▁uint 32_ t ▁flag ▁, ▁mask ▁; ▁uint 8_ t ▁* ▁cb 0 ▁, ▁* ▁cb 1 ▁, ▁* ▁cb 2 ▁, ▁* ▁cb 3 ▁; ▁unsigned ▁int ▁x ▁, ▁y ▁; ▁char ▁* ▁ip 0 ▁, ▁* ▁ip 1 ▁, ▁* ▁ip 2 ▁, ▁* ▁ip 3 ▁; ▁flag ▁= ▁0 ▁; ▁mask ▁= ▁0 ▁; ▁for ▁( ▁y ▁= ▁strip ▁-> ▁y 1 ▁; ▁y ▁< ▁strip ▁-> ▁y 2 ▁; ▁y ▁+= ▁4 ▁) ▁{ ▁ip 0 ▁= ▁ip 1 ▁= ▁ip 2 ▁= ▁ip 3 ▁= ▁s ▁-> ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁( ▁s ▁-> ▁palette _ video ▁? ▁strip ▁-> ▁x 1 ▁: ▁strip ▁-> ▁x 1 ▁* ▁3 ▁) ▁+ ▁( ▁y ▁* ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁- ▁y ▁> ▁1 ▁) ▁{ ▁ip 1 ▁= ▁ip 0 ▁+ ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁- ▁y ▁> ▁2 ▁) ▁{ ▁ip 2 ▁= ▁ip 1 ▁+ ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁- ▁y ▁> ▁3 ▁) ▁{ ▁ip 3 ▁= ▁ip 2 ▁+ ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁} ▁} ▁} ▁for ▁( ▁x ▁= ▁strip ▁-> ▁x 1 ▁; ▁x ▁< ▁strip ▁-> ▁x 2 ▁; ▁x ▁+= ▁4 ▁) ▁{ ▁if ▁( ▁( ▁chunk _ id ▁& ▁0 x 01 ▁) ▁&& ▁! ▁( ▁mask ▁>>= ▁1 ▁) ▁) ▁{ ▁if ▁( ▁( ▁data ▁+ ▁4 ▁) ▁> ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁flag ▁= ▁AV _ RB 32 ▁( ▁data ▁) ▁; ▁data ▁+= ▁4 ▁; ▁mask ▁= ▁0 x 80000000 ▁; ▁} ▁if ▁( ▁! ▁( ▁chunk _ id ▁& ▁0 x 01 ▁) ▁|| ▁( ▁flag ▁& ▁mask ▁) ▁) ▁{ ▁if ▁( ▁! ▁( ▁chunk _ id ▁& ▁0 x 02 ▁) ▁&& ▁! ▁( ▁mask ▁>>= ▁1 ▁) ▁) ▁{ ▁if ▁( ▁( ▁data ▁+ ▁4 ▁) ▁> ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁flag ▁= ▁AV _ RB 32 ▁( ▁data ▁) ▁; ▁data ▁+= ▁4 ▁; ▁mask ▁= ▁0 x 80000000 ▁; ▁} ▁if ▁( ▁( ▁chunk _ id ▁& ▁0 x 02 ▁) ▁|| ▁( ▁ ~ ▁flag ▁& ▁mask ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁p ▁; ▁if ▁( ▁data ▁>= ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁p ▁= ▁strip ▁-> ▁v 1_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁if ▁( ▁s ▁-> ▁palette _ video ▁) ▁{ ▁ip 3 ▁[ ▁0 ▁] ▁= ▁ip 3 ▁[ ▁1 ▁] ▁= ▁ip 2 ▁[ ▁0 ▁] ▁= ▁ip 2 ▁[ ▁1 ▁] ▁= ▁p ▁[ ▁6 ▁] ▁; ▁ip 3 ▁[ ▁2 ▁] ▁= ▁ip 3 ▁[ ▁3 ▁] ▁= ▁ip 2 ▁[ ▁2 ▁] ▁= ▁ip 2 ▁[ ▁3 ▁] ▁= ▁p ▁[ ▁9 ▁] ▁; ▁ip 1 ▁[ ▁0 ▁] ▁= ▁ip 1 ▁[ ▁1 ▁] ▁= ▁ip 0 ▁[ ▁0 ▁] ▁= ▁ip 0 ▁[ ▁1 ▁] ▁= ▁p ▁[ ▁0 ▁] ▁; ▁ip 1 ▁[ ▁2 ▁] ▁= ▁ip 1 ▁[ ▁3 ▁] ▁= ▁ip 0 ▁[ ▁2 ▁] ▁= ▁ip 0 ▁[ ▁3 ▁] ▁= ▁p ▁[ ▁3 ▁] ▁; ▁} ▁else ▁{ ▁p ▁+= ▁6 ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁p ▁+= ▁3 ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁p ▁-= ▁9 ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁p ▁+= ▁3 ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁flag ▁& ▁mask ▁) ▁{ ▁if ▁( ▁( ▁data ▁+ ▁4 ▁) ▁> ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁cb 0 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁cb 1 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁cb 2 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁cb 3 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁if ▁( ▁s ▁-> ▁palette _ video ▁) ▁{ ▁uint 8_ t ▁* ▁p ▁; ▁p ▁= ▁ip 3 ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁9 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 3 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁= ▁cb 3 ▁[ ▁9 ▁] ▁; ▁p ▁= ▁ip 2 ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁3 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 3 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁= ▁cb 3 ▁[ ▁3 ▁] ▁; ▁p ▁= ▁ip 1 ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁9 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 1 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁= ▁cb 1 ▁[ ▁9 ▁] ▁; ▁p ▁= ▁ip 0 ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁3 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 1 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁= ▁cb 1 ▁[ ▁3 ▁] ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁ip 3 ▁+ ▁0 ▁, ▁cb 2 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁6 ▁, ▁cb 3 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁0 ▁, ▁cb 2 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁6 ▁, ▁cb 3 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁0 ▁, ▁cb 0 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁6 ▁, ▁cb 1 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁0 ▁, ▁cb 0 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁6 ▁, ▁cb 1 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁s ▁-> ▁palette _ video ▁) ▁{ ▁ip 0 ▁+= ▁4 ▁; ▁ip 1 ▁+= ▁4 ▁; ▁ip 2 ▁+= ▁4 ▁; ▁ip 3 ▁+= ▁4 ▁; ▁} ▁else ▁{ ▁ip 0 ▁+= ▁12 ▁; ▁ip 1 ▁+= ▁12 ▁; ▁ip 2 ▁+= ▁12 ▁; ▁ip 3 ▁+= ▁12 ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁BN _ is _ prime _ fast test _ ex ▁( ▁const ▁BIGNUM ▁* ▁a ▁, ▁int ▁checks ▁, ▁BN _ CTX ▁* ▁ctx _ passed ▁, ▁int ▁do _ tri al _ division ▁, ▁BN _ GENCB ▁* ▁cb ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁ret ▁= ▁-1 ▁; ▁int ▁k ▁; ▁BN _ CTX ▁* ▁ctx ▁= ▁NULL ▁; ▁BIGNUM ▁* ▁A 1 ▁, ▁* ▁A 1_ odd ▁, ▁* ▁A 3 ▁, ▁* ▁check ▁; ▁BN _ M ONT _ CTX ▁* ▁m ont ▁= ▁NULL ▁; ▁if ▁( ▁BN _ is _ word ▁( ▁a ▁, ▁2 ▁) ▁|| ▁BN _ is _ word ▁( ▁a ▁, ▁3 ▁) ▁) ▁return ▁1 ▁; ▁if ▁( ▁! ▁BN _ is _ odd ▁( ▁a ▁) ▁|| ▁BN _ cmp ▁( ▁a ▁, ▁BN _ value _ one ▁( ▁) ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁checks ▁== ▁BN _ prime _ checks ▁) ▁checks ▁= ▁BN _ prime _ checks _ for _ size ▁( ▁BN _ num _ bits ▁( ▁a ▁) ▁) ▁; ▁if ▁( ▁do _ tri al _ division ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁NU MP R IM ES ▁; ▁i ▁++ ▁) ▁{ ▁BN _ ULONG ▁mod ▁= ▁BN _ mod _ word ▁( ▁a ▁, ▁primes ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁mod ▁== ▁( ▁BN _ ULONG ▁) ▁- ▁1 ▁) ▁goto ▁err ▁; ▁if ▁( ▁mod ▁== ▁0 ▁) ▁return ▁BN _ is _ word ▁( ▁a ▁, ▁primes ▁[ ▁i ▁] ▁) ▁; ▁} ▁if ▁( ▁! ▁BN _ GENCB _ call ▁( ▁cb ▁, ▁1 ▁, ▁-1 ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁ctx _ passed ▁!= ▁NULL ▁) ▁ctx ▁= ▁ctx _ passed ▁; ▁else ▁if ▁( ▁( ▁ctx ▁= ▁BN _ CTX _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁A 1 ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁A 3 ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁A 1_ odd ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁check ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁check ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ copy ▁( ▁A 1 ▁, ▁a ▁) ▁|| ▁! ▁BN _ sub _ word ▁( ▁A 1 ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ copy ▁( ▁A 3 ▁, ▁a ▁) ▁|| ▁! ▁BN _ sub _ word ▁( ▁A 3 ▁, ▁3 ▁) ▁) ▁goto ▁err ▁; ▁k ▁= ▁1 ▁; ▁while ▁( ▁! ▁BN _ is _ bit _ set ▁( ▁A 1 ▁, ▁k ▁) ▁) ▁k ▁++ ▁; ▁if ▁( ▁! ▁BN _ rshift ▁( ▁A 1_ odd ▁, ▁A 1 ▁, ▁k ▁) ▁) ▁goto ▁err ▁; ▁m ont ▁= ▁BN _ M ONT _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁m ont ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁a ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁checks ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁BN _ priv _ rand _ range ▁( ▁check ▁, ▁A 3 ▁) ▁|| ▁! ▁BN _ add _ word ▁( ▁check ▁, ▁2 ▁) ▁) ▁goto ▁err ▁; ▁j ▁= ▁witness ▁( ▁check ▁, ▁a ▁, ▁A 1 ▁, ▁A 1_ odd ▁, ▁k ▁, ▁ctx ▁, ▁m ont ▁) ▁; ▁if ▁( ▁j ▁== ▁-1 ▁) ▁goto ▁err ▁; ▁if ▁( ▁j ▁) ▁{ ▁ret ▁= ▁0 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ GENCB _ call ▁( ▁cb ▁, ▁1 ▁, ▁i ▁) ▁) ▁goto ▁err ▁; ▁} ▁ret ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁ctx ▁!= ▁NULL ▁) ▁{ ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁if ▁( ▁ctx _ passed ▁== ▁NULL ▁) ▁BN _ CTX _ free ▁( ▁ctx ▁) ▁; ▁} ▁BN _ M ONT _ CTX _ free ▁( ▁m ont ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁BN _ rshift 1 ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁) ▁{ ▁BN _ ULONG ▁* ▁ap ▁, ▁* ▁rp ▁, ▁t ▁, ▁c ▁; ▁int ▁i ▁, ▁j ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁a ▁) ▁) ▁{ ▁BN _ zero ▁( ▁r ▁) ▁; ▁return ▁1 ▁; ▁} ▁i ▁= ▁a ▁-> ▁top ▁; ▁ap ▁= ▁a ▁-> ▁d ▁; ▁j ▁= ▁i ▁- ▁( ▁ap ▁[ ▁i ▁- ▁1 ▁] ▁== ▁1 ▁) ▁; ▁if ▁( ▁a ▁!= ▁r ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁r ▁, ▁j ▁) ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁r ▁-> ▁neg ▁= ▁a ▁-> ▁neg ▁; ▁} ▁rp ▁= ▁r ▁-> ▁d ▁; ▁t ▁= ▁ap ▁[ ▁-- ▁i ▁] ▁; ▁c ▁= ▁( ▁t ▁& ▁1 ▁) ▁? ▁BN _ T BIT ▁: ▁0 ▁; ▁if ▁( ▁t ▁>>= ▁1 ▁) ▁rp ▁[ ▁i ▁] ▁= ▁t ▁; ▁while ▁( ▁i ▁> ▁0 ▁) ▁{ ▁t ▁= ▁ap ▁[ ▁-- ▁i ▁] ▁; ▁rp ▁[ ▁i ▁] ▁= ▁( ▁( ▁t ▁>> ▁1 ▁) ▁& ▁BN _ MASK 2 ▁) ▁| ▁c ▁; ▁c ▁= ▁( ▁t ▁& ▁1 ▁) ▁? ▁BN _ T BIT ▁: ▁0 ▁; ▁} ▁r ▁-> ▁top ▁= ▁j ▁; ▁if ▁( ▁! ▁r ▁-> ▁top ▁) ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁adx _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁AD X Demux er Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVCodecContext ▁* ▁avctx ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁; ▁int ▁ret ▁, ▁size ▁; ▁size ▁= ▁BLOCK _ SIZE ▁* ▁avctx ▁-> ▁channels ▁; ▁pkt ▁-> ▁pos ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁ret ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁size ▁) ▁; ▁if ▁( ▁ret ▁!= ▁size ▁) ▁{ ▁av _ free _ packet ▁( ▁pkt ▁) ▁; ▁return ▁ret ▁< ▁0 ▁? ▁ret ▁: ▁AVERROR ▁( ▁EIO ▁) ▁; ▁} ▁if ▁( ▁AV _ RB 16 ▁( ▁pkt ▁-> ▁data ▁) ▁& ▁0 x 8000 ▁) ▁{ ▁av _ free _ packet ▁( ▁pkt ▁) ▁; ▁return ▁AVERROR _ EOF ▁; ▁} ▁pkt ▁-> ▁size ▁= ▁size ▁; ▁pkt ▁-> ▁duration ▁= ▁1 ▁; ▁pkt ▁-> ▁pts ▁= ▁( ▁pkt ▁-> ▁pos ▁- ▁c ▁-> ▁header _ size ▁) ▁/ ▁size ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁alloc _ sequence _ buffers ▁( ▁Dir ac Context ▁* ▁s ▁) ▁{ ▁int ▁sb width ▁= ▁DIV RND UP ▁( ▁s ▁-> ▁source ▁. ▁width ▁, ▁4 ▁) ▁; ▁int ▁sb height ▁= ▁DIV RND UP ▁( ▁s ▁-> ▁source ▁. ▁height ▁, ▁4 ▁) ▁; ▁int ▁i ▁, ▁w ▁, ▁h ▁, ▁top _ padding ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁max _ xb len ▁= ▁MAX _ BLOCKSIZE ▁>> ▁( ▁i ▁? ▁s ▁-> ▁chroma _ x _ shift ▁: ▁0 ▁) ▁; ▁int ▁max _ y b len ▁= ▁MAX _ BLOCKSIZE ▁>> ▁( ▁i ▁? ▁s ▁-> ▁chroma _ y _ shift ▁: ▁0 ▁) ▁; ▁w ▁= ▁s ▁-> ▁source ▁. ▁width ▁>> ▁( ▁i ▁? ▁s ▁-> ▁chroma _ x _ shift ▁: ▁0 ▁) ▁; ▁h ▁= ▁s ▁-> ▁source ▁. ▁height ▁>> ▁( ▁i ▁? ▁s ▁-> ▁chroma _ y _ shift ▁: ▁0 ▁) ▁; ▁top _ padding ▁= ▁FF MAX ▁( ▁1 ▁<< ▁MAX _ D WT _ LEVELS ▁, ▁max _ y b len ▁/ ▁2 ▁) ▁; ▁w ▁= ▁FF ALIGN ▁( ▁CALC _ PADDING ▁( ▁w ▁, ▁MAX _ D WT _ LEVELS ▁) ▁, ▁8 ▁) ▁; ▁h ▁= ▁top _ padding ▁+ ▁CALC _ PADDING ▁( ▁h ▁, ▁MAX _ D WT _ LEVELS ▁) ▁+ ▁max _ y b len ▁/ ▁2 ▁; ▁s ▁-> ▁plane ▁[ ▁i ▁] ▁. ▁id wt _ buf _ base ▁= ▁av _ malloc z _ array ▁( ▁( ▁w ▁+ ▁max _ xb len ▁) ▁, ▁h ▁* ▁sizeof ▁( ▁ID W TE LEM ▁) ▁) ▁; ▁s ▁-> ▁plane ▁[ ▁i ▁] ▁. ▁id wt _ tmp ▁= ▁av _ malloc _ array ▁( ▁( ▁w ▁+ ▁16 ▁) ▁, ▁sizeof ▁( ▁ID W TE LEM ▁) ▁) ▁; ▁s ▁-> ▁plane ▁[ ▁i ▁] ▁. ▁id wt _ buf ▁= ▁s ▁-> ▁plane ▁[ ▁i ▁] ▁. ▁id wt _ buf _ base ▁+ ▁top _ padding ▁* ▁w ▁; ▁if ▁( ▁! ▁s ▁-> ▁plane ▁[ ▁i ▁] ▁. ▁id wt _ buf _ base ▁|| ▁! ▁s ▁-> ▁plane ▁[ ▁i ▁] ▁. ▁id wt _ tmp ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁w ▁= ▁s ▁-> ▁source ▁. ▁width ▁; ▁h ▁= ▁s ▁-> ▁source ▁. ▁height ▁; ▁s ▁-> ▁sb split ▁= ▁av _ malloc _ array ▁( ▁sb width ▁, ▁sb height ▁) ▁; ▁s ▁-> ▁bl motion ▁= ▁av _ malloc _ array ▁( ▁sb width ▁, ▁sb height ▁* ▁16 ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁bl motion ▁) ▁) ▁; ▁s ▁-> ▁edge _ emu _ buffer _ base ▁= ▁av _ malloc _ array ▁( ▁( ▁w ▁+ ▁64 ▁) ▁, ▁MAX _ BLOCKSIZE ▁) ▁; ▁s ▁-> ▁m ct mp ▁= ▁av _ malloc _ array ▁( ▁( ▁w ▁+ ▁64 ▁+ ▁MAX _ BLOCKSIZE ▁) ▁, ▁( ▁h ▁+ ▁MAX _ BLOCKSIZE ▁) ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁m ct mp ▁) ▁) ▁; ▁s ▁-> ▁mc scratch ▁= ▁av _ malloc _ array ▁( ▁( ▁w ▁+ ▁64 ▁) ▁, ▁MAX _ BLOCKSIZE ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁sb split ▁|| ▁! ▁s ▁-> ▁bl motion ▁|| ▁! ▁s ▁-> ▁m ct mp ▁|| ▁! ▁s ▁-> ▁mc scratch ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁g 72 6_ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁G 726 Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int 16_ t ▁* ▁samples ▁= ▁data ▁; ▁Get Bit Context ▁gb ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁while ▁( ▁get _ bits _ count ▁( ▁& ▁gb ▁) ▁+ ▁c ▁-> ▁code _ size ▁<= ▁buf _ size ▁* ▁8 ▁) ▁* ▁samples ▁++ ▁= ▁g 72 6_ decode ▁( ▁c ▁, ▁get _ bits ▁( ▁& ▁gb ▁, ▁c ▁-> ▁code _ size ▁) ▁) ▁; ▁if ▁( ▁buf _ size ▁* ▁8 ▁!= ▁get _ bits _ count ▁( ▁& ▁gb ▁) ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Frame invalid ly split , missing parser ?\ n " ▁) ▁; ▁* ▁data _ size ▁= ▁( ▁uint 8_ t ▁* ▁) ▁samples ▁- ▁( ▁uint 8_ t ▁* ▁) ▁data ▁; ▁return ▁buf _ size ▁; ▁}	1
▁static ▁int ▁decode _ p _ frame ▁( ▁Four X Context ▁* ▁f ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁length ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁const ▁int ▁width ▁= ▁f ▁-> ▁avctx ▁-> ▁width ▁; ▁const ▁int ▁height ▁= ▁f ▁-> ▁avctx ▁-> ▁height ▁; ▁uint 16_ t ▁* ▁src ▁= ▁( ▁uint 16_ t ▁* ▁) ▁f ▁-> ▁last _ picture ▁. ▁data ▁[ ▁0 ▁] ▁; ▁uint 16_ t ▁* ▁dst ▁= ▁( ▁uint 16_ t ▁* ▁) ▁f ▁-> ▁current _ picture ▁. ▁data ▁[ ▁0 ▁] ▁; ▁const ▁int ▁stride ▁= ▁f ▁-> ▁current _ picture ▁. ▁linesize ▁[ ▁0 ▁] ▁>> ▁1 ▁; ▁unsigned ▁int ▁bitstream _ size ▁, ▁bytestream _ size ▁, ▁word stream _ size ▁, ▁extra ▁; ▁if ▁( ▁f ▁-> ▁version ▁> ▁1 ▁) ▁{ ▁extra ▁= ▁20 ▁; ▁bitstream _ size ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁8 ▁) ▁; ▁word stream _ size ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁12 ▁) ▁; ▁bytestream _ size ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁16 ▁) ▁; ▁} ▁else ▁{ ▁extra ▁= ▁0 ▁; ▁bitstream _ size ▁= ▁AV _ RL 16 ▁( ▁buf ▁- ▁4 ▁) ▁; ▁word stream _ size ▁= ▁AV _ RL 16 ▁( ▁buf ▁- ▁2 ▁) ▁; ▁bytestream _ size ▁= ▁FF MAX ▁( ▁length ▁- ▁bitstream _ size ▁- ▁word stream _ size ▁, ▁0 ▁) ▁; ▁} ▁if ▁( ▁bitstream _ size ▁+ ▁bytestream _ size ▁+ ▁word stream _ size ▁+ ▁extra ▁!= ▁length ▁|| ▁bitstream _ size ▁> ▁( ▁1 ▁<< ▁26 ▁) ▁|| ▁bytestream _ size ▁> ▁( ▁1 ▁<< ▁26 ▁) ▁|| ▁word stream _ size ▁> ▁( ▁1 ▁<< ▁26 ▁) ▁) ▁{ ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" length s % d % d % d % d \ n " ▁, ▁bitstream _ size ▁, ▁bytestream _ size ▁, ▁word stream _ size ▁, ▁bitstream _ size ▁+ ▁bytestream _ size ▁+ ▁word stream _ size ▁- ▁length ▁) ▁; ▁return ▁-1 ▁; ▁} ▁av _ fast _ malloc ▁( ▁& ▁f ▁-> ▁bitstream _ buffer ▁, ▁& ▁f ▁-> ▁bitstream _ buffer _ size ▁, ▁bitstream _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁f ▁-> ▁bitstream _ buffer ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁f ▁-> ▁dsp ▁. ▁bswap _ buf ▁( ▁f ▁-> ▁bitstream _ buffer ▁, ▁( ▁const ▁uint 32_ t ▁* ▁) ▁( ▁buf ▁+ ▁extra ▁) ▁, ▁bitstream _ size ▁/ ▁4 ▁) ▁; ▁memset ▁( ▁( ▁uint 8_ t ▁* ▁) ▁f ▁-> ▁bitstream _ buffer ▁+ ▁bitstream _ size ▁, ▁0 ▁, ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁init _ get _ bits ▁( ▁& ▁f ▁-> ▁gb ▁, ▁f ▁-> ▁bitstream _ buffer ▁, ▁8 ▁* ▁bitstream _ size ▁) ▁; ▁f ▁-> ▁word stream ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁( ▁buf ▁+ ▁extra ▁+ ▁bitstream _ size ▁) ▁; ▁f ▁-> ▁bytestream ▁= ▁buf ▁+ ▁extra ▁+ ▁bitstream _ size ▁+ ▁word stream _ size ▁; ▁init _ mv ▁( ▁f ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁width ▁; ▁x ▁+= ▁8 ▁) ▁{ ▁decode _ p _ block ▁( ▁f ▁, ▁dst ▁+ ▁x ▁, ▁src ▁+ ▁x ▁, ▁3 ▁, ▁3 ▁, ▁stride ▁) ▁; ▁} ▁src ▁+= ▁8 ▁* ▁stride ▁; ▁dst ▁+= ▁8 ▁* ▁stride ▁; ▁} ▁if ▁( ▁bitstream _ size ▁!= ▁( ▁get _ bits _ count ▁( ▁& ▁f ▁-> ▁gb ▁) ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁4 ▁|| ▁( ▁( ▁( ▁const ▁char ▁* ▁) ▁f ▁-> ▁word stream ▁- ▁( ▁const ▁char ▁* ▁) ▁buf ▁+ ▁2 ▁) ▁& ▁ ~ ▁2 ▁) ▁!= ▁extra ▁+ ▁bitstream _ size ▁+ ▁word stream _ size ▁|| ▁( ▁( ▁( ▁const ▁char ▁* ▁) ▁f ▁-> ▁bytestream ▁- ▁( ▁const ▁char ▁* ▁) ▁buf ▁+ ▁3 ▁) ▁& ▁ ~ ▁3 ▁) ▁!= ▁extra ▁+ ▁bitstream _ size ▁+ ▁word stream _ size ▁+ ▁bytestream _ size ▁) ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"% d % td % t db ytes left \ n " ▁, ▁bitstream _ size ▁- ▁( ▁get _ bits _ count ▁( ▁& ▁f ▁-> ▁gb ▁) ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁4 ▁, ▁- ▁( ▁( ▁( ▁const ▁char ▁* ▁) ▁f ▁-> ▁bytestream ▁- ▁( ▁const ▁char ▁* ▁) ▁buf ▁+ ▁3 ▁) ▁& ▁ ~ ▁3 ▁) ▁+ ▁( ▁extra ▁+ ▁bitstream _ size ▁+ ▁word stream _ size ▁+ ▁bytestream _ size ▁) ▁, ▁- ▁( ▁( ▁( ▁const ▁char ▁* ▁) ▁f ▁-> ▁word stream ▁- ▁( ▁const ▁char ▁* ▁) ▁buf ▁+ ▁2 ▁) ▁& ▁ ~ ▁2 ▁) ▁+ ▁( ▁extra ▁+ ▁bitstream _ size ▁+ ▁word stream _ size ▁) ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁const ▁SSL _ CIPHER ▁* ▁ssl 3_ choose _ cipher ▁( ▁SSL ▁* ▁s ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁clnt ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁sr vr ▁) ▁{ ▁const ▁SSL _ CIPHER ▁* ▁c ▁, ▁* ▁ret ▁= ▁NULL ▁; ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁prio ▁, ▁* ▁allow ▁; ▁int ▁i ▁, ▁ii ▁, ▁ok ▁; ▁unsigned ▁long ▁alg _ k ▁= ▁0 ▁, ▁alg _ a ▁= ▁0 ▁, ▁mask _ k ▁= ▁0 ▁, ▁mask _ a ▁= ▁0 ▁; ▁# ifndef ▁OPENSSL _ NO _ CH ACHA ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁prio _ chacha ▁= ▁NULL ▁; ▁# endif ▁# ifdef ▁C IPHER _ DEBUG ▁fprintf ▁( ▁stderr ▁, ▁" Server has % df rom % p :\ n " ▁, ▁sk _ SSL _ CIPHER _ num ▁( ▁sr vr ▁) ▁, ▁( ▁void ▁* ▁) ▁sr vr ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁sr vr ▁) ▁; ▁++ ▁i ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁sr vr ▁, ▁i ▁) ▁; ▁fprintf ▁( ▁stderr ▁, ▁"% p :% s \ n " ▁, ▁( ▁void ▁* ▁) ▁c ▁, ▁c ▁-> ▁name ▁) ▁; ▁} ▁fprintf ▁( ▁stderr ▁, ▁" Client sent % df rom % p :\ n " ▁, ▁sk _ SSL _ CIPHER _ num ▁( ▁clnt ▁) ▁, ▁( ▁void ▁* ▁) ▁clnt ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁clnt ▁) ▁; ▁++ ▁i ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁clnt ▁, ▁i ▁) ▁; ▁fprintf ▁( ▁stderr ▁, ▁"% p :% s \ n " ▁, ▁( ▁void ▁* ▁) ▁c ▁, ▁c ▁-> ▁name ▁) ▁; ▁} ▁# endif ▁if ▁( ▁tls 1_ su it eb ▁( ▁s ▁) ▁) ▁{ ▁prio ▁= ▁sr vr ▁; ▁allow ▁= ▁clnt ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁options ▁& ▁SSL _ OP _ CIPHER _ SERVER _ PRE FERENCE ▁) ▁{ ▁prio ▁= ▁sr vr ▁; ▁allow ▁= ▁clnt ▁; ▁# ifndef ▁OPENSSL _ NO _ CH ACHA ▁if ▁( ▁s ▁-> ▁options ▁& ▁SSL _ OP _ PRI OR IT IZE _ CH ACHA ▁&& ▁sk _ SSL _ CIPHER _ num ▁( ▁clnt ▁) ▁> ▁0 ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁clnt ▁, ▁0 ▁) ▁; ▁if ▁( ▁c ▁-> ▁algorithm _ enc ▁== ▁SSL _ CH ACHA 20 POLY 1305 ▁) ▁{ ▁int ▁num ▁= ▁sk _ SSL _ CIPHER _ num ▁( ▁sr vr ▁) ▁; ▁int ▁found ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁sr vr ▁, ▁i ▁) ▁; ▁if ▁( ▁c ▁-> ▁algorithm _ enc ▁== ▁SSL _ CH ACHA 20 POLY 1305 ▁) ▁{ ▁found ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁found ▁) ▁{ ▁prio _ chacha ▁= ▁sk _ SSL _ CIPHER _ new _ null ▁( ▁) ▁; ▁if ▁( ▁prio _ chacha ▁!= ▁NULL ▁) ▁{ ▁sk _ SSL _ CIPHER _ push ▁( ▁prio _ chacha ▁, ▁c ▁) ▁; ▁for ▁( ▁i ▁++ ▁; ▁i ▁< ▁num ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁sr vr ▁, ▁i ▁) ▁; ▁if ▁( ▁c ▁-> ▁algorithm _ enc ▁== ▁SSL _ CH ACHA 20 POLY 1305 ▁) ▁sk _ SSL _ CIPHER _ push ▁( ▁prio _ chacha ▁, ▁c ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁sr vr ▁, ▁i ▁) ▁; ▁if ▁( ▁c ▁-> ▁algorithm _ enc ▁!= ▁SSL _ CH ACHA 20 POLY 1305 ▁) ▁sk _ SSL _ CIPHER _ push ▁( ▁prio _ chacha ▁, ▁c ▁) ▁; ▁} ▁prio ▁= ▁prio _ chacha ▁; ▁} ▁} ▁} ▁} ▁# endif ▁} ▁else ▁{ ▁prio ▁= ▁clnt ▁; ▁allow ▁= ▁sr vr ▁; ▁} ▁if ▁( ▁! ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁{ ▁tls 1_ set _ cert _ valid ity ▁( ▁s ▁) ▁; ▁ssl _ set _ masks ▁( ▁s ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁prio ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁prio ▁, ▁i ▁) ▁; ▁if ▁( ▁! ▁SSL _ IS _ DT LS ▁( ▁s ▁) ▁&& ▁( ▁( ▁s ▁-> ▁version ▁< ▁c ▁-> ▁min _ tls ▁) ▁|| ▁( ▁s ▁-> ▁version ▁> ▁c ▁-> ▁max _ tls ▁) ▁) ▁) ▁continue ▁; ▁if ▁( ▁SSL _ IS _ DT LS ▁( ▁s ▁) ▁&& ▁( ▁DTLS _ VERSION _ LT ▁( ▁s ▁-> ▁version ▁, ▁c ▁-> ▁min _ dt ls ▁) ▁|| ▁DTLS _ VERSION _ GT ▁( ▁s ▁-> ▁version ▁, ▁c ▁-> ▁max _ dt ls ▁) ▁) ▁) ▁continue ▁; ▁if ▁( ▁! ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁{ ▁mask _ k ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁mask _ k ▁; ▁mask _ a ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁mask _ a ▁; ▁# ifndef ▁OPENSSL _ NO _ SR P ▁if ▁( ▁s ▁-> ▁sr p _ ctx ▁. ▁sr p _ Mask ▁& ▁SSL _ k SR P ▁) ▁{ ▁mask _ k ▁|= ▁SSL _ k SR P ▁; ▁mask _ a ▁|= ▁SSL _ a SR P ▁; ▁} ▁# endif ▁alg _ k ▁= ▁c ▁-> ▁algorithm _ m key ▁; ▁alg _ a ▁= ▁c ▁-> ▁algorithm _ auth ▁; ▁# ifndef ▁OPENSSL _ NO _ PS K ▁if ▁( ▁( ▁alg _ k ▁& ▁SSL _ PS K ▁) ▁&& ▁s ▁-> ▁p sk _ server _ callback ▁== ▁NULL ▁) ▁continue ▁; ▁# endif ▁ok ▁= ▁( ▁alg _ k ▁& ▁mask _ k ▁) ▁&& ▁( ▁alg _ a ▁& ▁mask _ a ▁) ▁; ▁# ifdef ▁C IPHER _ DEBUG ▁fprintf ▁( ▁stderr ▁, ▁"% d :[ %08 lX :% 08 lX :% 08 lX :% 08 lX ] % p :% s \ n " ▁, ▁ok ▁, ▁alg _ k ▁, ▁alg _ a ▁, ▁mask _ k ▁, ▁mask _ a ▁, ▁( ▁void ▁* ▁) ▁c ▁, ▁c ▁-> ▁name ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁alg _ k ▁& ▁SSL _ k EC D HE ▁) ▁ok ▁= ▁ok ▁&& ▁tls 1_ check _ ec _ tmp _ key ▁( ▁s ▁, ▁c ▁-> ▁id ▁) ▁; ▁# endif ▁if ▁( ▁! ▁ok ▁) ▁continue ▁; ▁} ▁ii ▁= ▁sk _ SSL _ CIPHER _ find ▁( ▁allow ▁, ▁c ▁) ▁; ▁if ▁( ▁ii ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁! ▁ssl _ security ▁( ▁s ▁, ▁SSL _ SEC OP _ CIPHER _ SHARED ▁, ▁c ▁-> ▁strength _ bits ▁, ▁0 ▁, ▁( ▁void ▁* ▁) ▁c ▁) ▁) ▁continue ▁; ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ EC ▁) ▁if ▁( ▁( ▁alg _ k ▁& ▁SSL _ k EC D HE ▁) ▁&& ▁( ▁alg _ a ▁& ▁SSL _ a ECDSA ▁) ▁&& ▁s ▁-> ▁s 3 ▁-> ▁is _ prob ably _ s af ari ▁) ▁{ ▁if ▁( ▁! ▁ret ▁) ▁ret ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁allow ▁, ▁ii ▁) ▁; ▁continue ▁; ▁} ▁# endif ▁ret ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁allow ▁, ▁ii ▁) ▁; ▁break ▁; ▁} ▁} ▁# ifndef ▁OPENSSL _ NO _ CH ACHA ▁sk _ SSL _ CIPHER _ free ▁( ▁prio _ chacha ▁) ▁; ▁# endif ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁rm _ assemble _ video _ frame ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁, ▁R MD emux Context ▁* ▁rm ▁, ▁RM Stream ▁* ▁vst ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁len ▁, ▁int ▁* ▁p seq ▁, ▁int 64_ t ▁* ▁timestamp ▁) ▁{ ▁int ▁hdr ▁; ▁int ▁seq ▁= ▁0 ▁, ▁pic _ num ▁= ▁0 ▁, ▁len 2 ▁= ▁0 ▁, ▁pos ▁= ▁0 ▁; ▁int ▁type ▁; ▁hdr ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁len ▁-- ▁; ▁type ▁= ▁hdr ▁>> ▁6 ▁; ▁if ▁( ▁type ▁!= ▁3 ▁) ▁{ ▁seq ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁len ▁-- ▁; ▁} ▁if ▁( ▁type ▁!= ▁1 ▁) ▁{ ▁len 2 ▁= ▁get _ num ▁( ▁pb ▁, ▁& ▁len ▁) ▁; ▁pos ▁= ▁get _ num ▁( ▁pb ▁, ▁& ▁len ▁) ▁; ▁pic _ num ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁len ▁-- ▁; ▁} ▁if ▁( ▁len ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁rm ▁-> ▁remaining _ len ▁= ▁len ▁; ▁if ▁( ▁type ▁& ▁1 ▁) ▁{ ▁if ▁( ▁type ▁== ▁3 ▁) ▁{ ▁len ▁= ▁len 2 ▁; ▁* ▁timestamp ▁= ▁pos ▁; ▁} ▁if ▁( ▁rm ▁-> ▁remaining _ len ▁< ▁len ▁) ▁return ▁-1 ▁; ▁rm ▁-> ▁remaining _ len ▁-= ▁len ▁; ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁len ▁+ ▁9 ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁pkt ▁-> ▁data ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁AV _ WL 32 ▁( ▁pkt ▁-> ▁data ▁+ ▁1 ▁, ▁1 ▁) ▁; ▁AV _ WL 32 ▁( ▁pkt ▁-> ▁data ▁+ ▁5 ▁, ▁0 ▁) ▁; ▁avio _ read ▁( ▁pb ▁, ▁pkt ▁-> ▁data ▁+ ▁9 ▁, ▁len ▁) ▁; ▁return ▁0 ▁; ▁} ▁* ▁p seq ▁= ▁seq ▁; ▁if ▁( ▁( ▁seq ▁& ▁0 x 7 F ▁) ▁== ▁1 ▁|| ▁vst ▁-> ▁cur pic _ num ▁!= ▁pic _ num ▁) ▁{ ▁vst ▁-> ▁slices ▁= ▁( ▁( ▁hdr ▁& ▁0 x 3 F ▁) ▁<< ▁1 ▁) ▁+ ▁1 ▁; ▁vst ▁-> ▁video bufsize ▁= ▁len 2 ▁+ ▁8 ▁* ▁vst ▁-> ▁slices ▁+ ▁1 ▁; ▁av _ free _ packet ▁( ▁& ▁vst ▁-> ▁pkt ▁) ▁; ▁if ▁( ▁av _ new _ packet ▁( ▁& ▁vst ▁-> ▁pkt ▁, ▁vst ▁-> ▁video bufsize ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁vst ▁-> ▁video buf pos ▁= ▁8 ▁* ▁vst ▁-> ▁slices ▁+ ▁1 ▁; ▁vst ▁-> ▁cur _ slice ▁= ▁0 ▁; ▁vst ▁-> ▁cur pic _ num ▁= ▁pic _ num ▁; ▁vst ▁-> ▁pk tp os ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁} ▁if ▁( ▁type ▁== ▁2 ▁) ▁len ▁= ▁FF MIN ▁( ▁len ▁, ▁pos ▁) ▁; ▁if ▁( ▁++ ▁vst ▁-> ▁cur _ slice ▁> ▁vst ▁-> ▁slices ▁) ▁return ▁1 ▁; ▁AV _ WL 32 ▁( ▁vst ▁-> ▁pkt ▁. ▁data ▁- ▁7 ▁+ ▁8 ▁* ▁vst ▁-> ▁cur _ slice ▁, ▁1 ▁) ▁; ▁AV _ WL 32 ▁( ▁vst ▁-> ▁pkt ▁. ▁data ▁- ▁3 ▁+ ▁8 ▁* ▁vst ▁-> ▁cur _ slice ▁, ▁vst ▁-> ▁video buf pos ▁- ▁8 ▁* ▁vst ▁-> ▁slices ▁- ▁1 ▁) ▁; ▁if ▁( ▁vst ▁-> ▁video buf pos ▁+ ▁len ▁> ▁vst ▁-> ▁video bufsize ▁) ▁return ▁1 ▁; ▁if ▁( ▁avio _ read ▁( ▁pb ▁, ▁vst ▁-> ▁pkt ▁. ▁data ▁+ ▁vst ▁-> ▁video buf pos ▁, ▁len ▁) ▁!= ▁len ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁vst ▁-> ▁video buf pos ▁+= ▁len ▁; ▁rm ▁-> ▁remaining _ len ▁-= ▁len ▁; ▁if ▁( ▁type ▁== ▁2 ▁|| ▁vst ▁-> ▁video buf pos ▁== ▁vst ▁-> ▁video bufsize ▁) ▁{ ▁vst ▁-> ▁pkt ▁. ▁data ▁[ ▁0 ▁] ▁= ▁vst ▁-> ▁cur _ slice ▁- ▁1 ▁; ▁* ▁pkt ▁= ▁vst ▁-> ▁pkt ▁; ▁vst ▁-> ▁pkt ▁. ▁data ▁= ▁NULL ▁; ▁vst ▁-> ▁pkt ▁. ▁size ▁= ▁0 ▁; ▁if ▁( ▁vst ▁-> ▁slices ▁!= ▁vst ▁-> ▁cur _ slice ▁) ▁memmove ▁( ▁pkt ▁-> ▁data ▁+ ▁1 ▁+ ▁8 ▁* ▁vst ▁-> ▁cur _ slice ▁, ▁pkt ▁-> ▁data ▁+ ▁1 ▁+ ▁8 ▁* ▁vst ▁-> ▁slices ▁, ▁vst ▁-> ▁video buf pos ▁- ▁1 ▁- ▁8 ▁* ▁vst ▁-> ▁slices ▁) ▁; ▁pkt ▁-> ▁size ▁= ▁vst ▁-> ▁video buf pos ▁+ ▁8 ▁* ▁( ▁vst ▁-> ▁cur _ slice ▁- ▁vst ▁-> ▁slices ▁) ▁; ▁pkt ▁-> ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁pkt ▁-> ▁pos ▁= ▁vst ▁-> ▁pk tp os ▁; ▁vst ▁-> ▁slices ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁process _ frame ▁( ▁F FF rame Sync ▁* ▁fs ▁) ▁{ ▁AVFilter Context ▁* ▁ctx ▁= ▁fs ▁-> ▁parent ▁; ▁L UT 2 Context ▁* ▁s ▁= ▁fs ▁-> ▁opaque ▁; ▁AVFilter Link ▁* ▁out link ▁= ▁ctx ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁AVFrame ▁* ▁out ▁, ▁* ▁src x ▁= ▁NULL ▁, ▁* ▁src y ▁= ▁NULL ▁; ▁int ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ frames ync 2_ get _ frame ▁( ▁& ▁s ▁-> ▁fs ▁, ▁0 ▁, ▁& ▁src x ▁, ▁0 ▁) ▁) ▁< ▁0 ▁|| ▁( ▁ret ▁= ▁ff _ frames ync 2_ get _ frame ▁( ▁& ▁s ▁-> ▁fs ▁, ▁1 ▁, ▁& ▁src y ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁ctx ▁-> ▁is _ disabled ▁|| ▁! ▁src y ▁) ▁{ ▁out ▁= ▁av _ frame _ clone ▁( ▁src x ▁) ▁; ▁if ▁( ▁! ▁out ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁else ▁{ ▁out ▁= ▁ff _ get _ video _ buffer ▁( ▁out link ▁, ▁out link ▁-> ▁w ▁, ▁out link ▁-> ▁h ▁) ▁; ▁if ▁( ▁! ▁out ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁av _ frame _ copy _ props ▁( ▁out ▁, ▁src x ▁) ▁; ▁s ▁-> ▁lut 2 ▁( ▁s ▁, ▁out ▁, ▁src x ▁, ▁src y ▁) ▁; ▁} ▁out ▁-> ▁pts ▁= ▁av _ re scale _ q ▁( ▁s ▁-> ▁fs ▁. ▁pts ▁, ▁s ▁-> ▁fs ▁. ▁time _ base ▁, ▁out link ▁-> ▁time _ base ▁) ▁; ▁return ▁ff _ filter _ frame ▁( ▁out link ▁, ▁out ▁) ▁; ▁}	0
▁int ▁i 2 d _ ASN 1_ OBJECT ▁( ▁ASN 1_ OBJECT ▁* ▁a ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁; ▁if ▁( ▁( ▁a ▁== ▁NULL ▁) ▁|| ▁( ▁a ▁-> ▁data ▁== ▁NULL ▁) ▁) ▁return ▁( ▁0 ▁) ▁; ▁if ▁( ▁pp ▁== ▁NULL ▁) ▁return ▁( ▁ASN 1_ object _ size ▁( ▁0 ▁, ▁a ▁-> ▁length ▁, ▁V _ ASN 1_ OBJECT ▁) ▁) ▁; ▁p ▁= ▁* ▁pp ▁; ▁ASN 1_ put _ object ▁( ▁& ▁p ▁, ▁0 ▁, ▁a ▁-> ▁length ▁, ▁V _ ASN 1_ OBJECT ▁, ▁V _ ASN 1_ UNIVERSAL ▁) ▁; ▁memcpy ▁( ▁p ▁, ▁a ▁-> ▁data ▁, ▁a ▁-> ▁length ▁) ▁; ▁p ▁+= ▁a ▁-> ▁length ▁; ▁* ▁pp ▁= ▁p ▁; ▁return ▁( ▁a ▁-> ▁length ▁) ▁; ▁}	1
▁static ▁int ▁set _ string _ image _ size ▁( ▁void ▁* ▁obj ▁, ▁const ▁AV Option ▁* ▁o ▁, ▁const ▁char ▁* ▁val ▁, ▁int ▁* ▁dst ▁) ▁{ ▁int ▁ret ▁; ▁if ▁( ▁! ▁val ▁|| ▁! ▁strcmp ▁( ▁val ▁, ▁" none " ▁) ▁) ▁{ ▁dst ▁[ ▁0 ▁] ▁= ▁dst ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁ret ▁= ▁av _ parse _ video _ size ▁( ▁dst ▁, ▁dst ▁+ ▁1 ▁, ▁val ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁av _ log ▁( ▁obj ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unable top arse option value \"% s \" as images ize \ n " ▁, ▁val ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁void ▁add _ pixels _ clamp ed 4_ c ▁( ▁const ▁DCT ELEM ▁* ▁block ▁, ▁uint 8_ t ▁* ▁restrict ▁pixels ▁, ▁int ▁line _ size ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁pixels ▁[ ▁0 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁pixels ▁[ ▁0 ▁] ▁+ ▁block ▁[ ▁0 ▁] ▁) ▁; ▁pixels ▁[ ▁1 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁pixels ▁[ ▁1 ▁] ▁+ ▁block ▁[ ▁1 ▁] ▁) ▁; ▁pixels ▁[ ▁2 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁pixels ▁[ ▁2 ▁] ▁+ ▁block ▁[ ▁2 ▁] ▁) ▁; ▁pixels ▁[ ▁3 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁pixels ▁[ ▁3 ▁] ▁+ ▁block ▁[ ▁3 ▁] ▁) ▁; ▁pixels ▁+= ▁line _ size ▁; ▁block ▁+= ▁8 ▁; ▁} ▁}	0
▁uint 8_ t ▁* ▁av _ packet _ get _ side _ data ▁( ▁AVPacket ▁* ▁pkt ▁, ▁enum ▁AVPacket Side DataType ▁type ▁, ▁int ▁* ▁size ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁pkt ▁-> ▁side _ data _ elems ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁type ▁== ▁type ▁) ▁{ ▁if ▁( ▁size ▁) ▁* ▁size ▁= ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁size ▁; ▁return ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁data ▁; ▁} ▁} ▁return ▁NULL ▁; ▁}	1
▁static ▁av _ cold ▁int ▁vp 8_ decode _ free ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁vp 8_ decode _ flush _ impl ▁( ▁avctx ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁) ▁; ▁release _ queued _ seg maps ▁( ▁avctx ▁-> ▁priv _ data ▁, ▁1 ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁execute _ cert _ test ▁( ▁CT _ TEST _ FIXTURE ▁fixture ▁) ▁{ ▁int ▁success ▁= ▁0 ▁; ▁X 509 ▁* ▁cert ▁= ▁NULL ▁, ▁* ▁issuer ▁= ▁NULL ▁; ▁STACK _ OF ▁( ▁SCT ▁) ▁* ▁sct s ▁= ▁NULL ▁; ▁SCT ▁* ▁sct ▁= ▁NULL ▁; ▁char ▁expected _ s ct _ text ▁[ ▁CT _ TEST _ MAX _ FILE _ SIZE ▁] ▁; ▁int ▁sct _ text _ len ▁= ▁0 ▁; ▁unsigned ▁char ▁* ▁tls _ s ct _ list ▁= ▁NULL ▁; ▁size _ t ▁tls _ s ct _ list _ len ▁= ▁0 ▁; ▁CT _ POLICY _ EVAL _ CTX ▁* ▁ct _ policy _ ctx ▁= ▁CT _ POLICY _ EVAL _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁fixture ▁. ▁sct _ text _ file ▁!= ▁NULL ▁) ▁{ ▁sct _ text _ len ▁= ▁read _ text _ file ▁( ▁fixture ▁. ▁sct _ dir ▁, ▁fixture ▁. ▁sct _ text _ file ▁, ▁expected _ s ct _ text ▁, ▁CT _ TEST _ MAX _ FILE _ SIZE ▁- ▁1 ▁) ▁; ▁if ▁( ▁sct _ text _ len ▁< ▁0 ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Test data fil en ot found :% s \ n " ▁, ▁fixture ▁. ▁sct _ text _ file ▁) ▁; ▁goto ▁end ▁; ▁} ▁expected _ s ct _ text ▁[ ▁sct _ text _ len ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁CT _ POLICY _ EVAL _ CTX _ set _ shared _ CT LOG _ STORE ▁( ▁ct _ policy _ ctx ▁, ▁fixture ▁. ▁ct log _ store ▁) ▁; ▁CT _ POLICY _ EVAL _ CTX _ set _ time ▁( ▁ct _ policy _ ctx ▁, ▁fixture ▁. ▁epoch _ time _ in _ ms ▁) ▁; ▁if ▁( ▁fixture ▁. ▁certificate _ file ▁!= ▁NULL ▁) ▁{ ▁int ▁sct _ extension _ index ▁; ▁X 509_ EXTENSION ▁* ▁sct _ extension ▁= ▁NULL ▁; ▁cert ▁= ▁load _ pem _ cert ▁( ▁fixture ▁. ▁certs _ dir ▁, ▁fixture ▁. ▁certificate _ file ▁) ▁; ▁if ▁( ▁cert ▁== ▁NULL ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Unable to load certificate :% s \ n " ▁, ▁fixture ▁. ▁certificate _ file ▁) ▁; ▁goto ▁end ▁; ▁} ▁CT _ POLICY _ EVAL _ CTX _ set 1_ cert ▁( ▁ct _ policy _ ctx ▁, ▁cert ▁) ▁; ▁if ▁( ▁fixture ▁. ▁issuer _ file ▁!= ▁NULL ▁) ▁{ ▁issuer ▁= ▁load _ pem _ cert ▁( ▁fixture ▁. ▁certs _ dir ▁, ▁fixture ▁. ▁issuer _ file ▁) ▁; ▁if ▁( ▁issuer ▁== ▁NULL ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Unable to load iss uer certificate :% s \ n " ▁, ▁fixture ▁. ▁issuer _ file ▁) ▁; ▁goto ▁end ▁; ▁} ▁CT _ POLICY _ EVAL _ CTX _ set 1_ iss uer ▁( ▁ct _ policy _ ctx ▁, ▁issuer ▁) ▁; ▁} ▁sct _ extension _ index ▁= ▁X 509_ get _ ext _ by _ NID ▁( ▁cert ▁, ▁NID _ ct _ prec ert _ s cts ▁, ▁-1 ▁) ▁; ▁sct _ extension ▁= ▁X 509_ get _ ext ▁( ▁cert ▁, ▁sct _ extension _ index ▁) ▁; ▁if ▁( ▁fixture ▁. ▁expected _ s ct _ count ▁> ▁0 ▁) ▁{ ▁if ▁( ▁sct _ extension ▁== ▁NULL ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" SC Text ension not found in :% s \ n " ▁, ▁fixture ▁. ▁certificate _ file ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁fixture ▁. ▁sct _ text _ file ▁&& ▁compare _ extension _ print out ▁( ▁sct _ extension ▁, ▁expected _ s ct _ text ▁) ▁) ▁{ ▁goto ▁end ▁; ▁} ▁if ▁( ▁fixture ▁. ▁test _ valid ity ▁) ▁{ ▁int ▁i ▁; ▁sct s ▁= ▁X 509 V 3_ EXT _ d 2 i ▁( ▁sct _ extension ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SCT _ num ▁( ▁sct s ▁) ▁; ▁++ ▁i ▁) ▁{ ▁SCT ▁* ▁sct _ i ▁= ▁sk _ SCT _ value ▁( ▁sct s ▁, ▁i ▁) ▁; ▁if ▁( ▁! ▁SCT _ set _ source ▁( ▁sct _ i ▁, ▁SCT _ SOURCE _ X 509 V 3_ EXTENSION ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Error setting SCT s ourc eto X 509 v 3 extension \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁if ▁( ▁! ▁assert _ valid ity ▁( ▁fixture ▁, ▁sct s ▁, ▁ct _ policy _ ctx ▁) ▁) ▁goto ▁end ▁; ▁} ▁} ▁else ▁if ▁( ▁sct _ extension ▁!= ▁NULL ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Expected no SCT s , but found SC Text ension in :% s \ n " ▁, ▁fixture ▁. ▁certificate _ file ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁if ▁( ▁fixture ▁. ▁tls _ s ct _ list ▁!= ▁NULL ▁) ▁{ ▁const ▁unsigned ▁char ▁* ▁p ▁= ▁fixture ▁. ▁tls _ s ct _ list ▁; ▁if ▁( ▁o 2 i _ SCT _ LIST ▁( ▁& ▁sct s ▁, ▁& ▁p ▁, ▁fixture ▁. ▁tls _ s ct _ list _ len ▁) ▁== ▁NULL ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Failed t ode code SCT s from TLS format \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁fixture ▁. ▁test _ valid ity ▁&& ▁cert ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁assert _ valid ity ▁( ▁fixture ▁, ▁sct s ▁, ▁ct _ policy _ ctx ▁) ▁) ▁goto ▁end ▁; ▁} ▁if ▁( ▁fixture ▁. ▁sct _ text _ file ▁&& ▁compare _ s ct _ list _ print out ▁( ▁sct s ▁, ▁expected _ s ct _ text ▁) ▁) ▁{ ▁goto ▁end ▁; ▁} ▁tls _ s ct _ list _ len ▁= ▁i 2 o _ SCT _ LIST ▁( ▁sct s ▁, ▁& ▁tls _ s ct _ list ▁) ▁; ▁if ▁( ▁tls _ s ct _ list _ len ▁!= ▁fixture ▁. ▁tls _ s ct _ list _ len ▁|| ▁memcmp ▁( ▁fixture ▁. ▁tls _ s ct _ list ▁, ▁tls _ s ct _ list ▁, ▁tls _ s ct _ list _ len ▁) ▁!= ▁0 ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Failed to encode SCT s into TLS format correct ly \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁success ▁= ▁1 ▁; ▁end ▁: ▁X 509_ free ▁( ▁cert ▁) ▁; ▁X 509_ free ▁( ▁issuer ▁) ▁; ▁SCT _ LIST _ free ▁( ▁sct s ▁) ▁; ▁SCT _ free ▁( ▁sct ▁) ▁; ▁CT _ POLICY _ EVAL _ CTX _ free ▁( ▁ct _ policy _ ctx ▁) ▁; ▁OPENSSL _ free ▁( ▁tls _ s ct _ list ▁) ▁; ▁return ▁success ▁; ▁}	1
▁int ▁ff _ m jpeg _ decode _ s os ▁( ▁MJ peg Decode Context ▁* ▁s ▁) ▁{ ▁int ▁len ▁, ▁nb _ components ▁, ▁i ▁, ▁h ▁, ▁v ▁, ▁predictor ▁, ▁point _ transform ▁; ▁int ▁index ▁, ▁id ▁; ▁const ▁int ▁block _ size ▁= ▁s ▁-> ▁loss less ▁? ▁1 ▁: ▁8 ▁; ▁int ▁i lv ▁, ▁prev _ shift ▁; ▁len ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁16 ▁) ▁; ▁nb _ components ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁if ▁( ▁len ▁!= ▁6 ▁+ ▁2 ▁* ▁nb _ components ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" decode _ s os : invalid len (% d )\ n " ▁, ▁len ▁) ▁; ▁return ▁-1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ components ▁; ▁i ▁++ ▁) ▁{ ▁id ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁- ▁1 ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" component :% d \ n " ▁, ▁id ▁) ▁; ▁for ▁( ▁index ▁= ▁0 ▁; ▁index ▁< ▁s ▁-> ▁nb _ components ▁; ▁index ▁++ ▁) ▁if ▁( ▁id ▁== ▁s ▁-> ▁component _ id ▁[ ▁index ▁] ▁) ▁break ▁; ▁if ▁( ▁index ▁== ▁s ▁-> ▁nb _ components ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" decode _ s os : index (% d ) out of components \ n " ▁, ▁index ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁comp _ index ▁[ ▁i ▁] ▁= ▁index ▁; ▁s ▁-> ▁nb _ blocks ▁[ ▁i ▁] ▁= ▁s ▁-> ▁h _ count ▁[ ▁index ▁] ▁* ▁s ▁-> ▁v _ count ▁[ ▁index ▁] ▁; ▁s ▁-> ▁h _ s count ▁[ ▁i ▁] ▁= ▁s ▁-> ▁h _ count ▁[ ▁index ▁] ▁; ▁s ▁-> ▁v _ s count ▁[ ▁i ▁] ▁= ▁s ▁-> ▁v _ count ▁[ ▁index ▁] ▁; ▁s ▁-> ▁dc _ index ▁[ ▁i ▁] ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁; ▁s ▁-> ▁ac _ index ▁[ ▁i ▁] ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁; ▁if ▁( ▁s ▁-> ▁dc _ index ▁[ ▁i ▁] ▁< ▁0 ▁|| ▁s ▁-> ▁ac _ index ▁[ ▁i ▁] ▁< ▁0 ▁|| ▁s ▁-> ▁dc _ index ▁[ ▁i ▁] ▁>= ▁4 ▁|| ▁s ▁-> ▁ac _ index ▁[ ▁i ▁] ▁>= ▁4 ▁) ▁goto ▁out _ of _ range ▁; ▁if ▁( ▁! ▁s ▁-> ▁vl cs ▁[ ▁0 ▁] ▁[ ▁s ▁-> ▁dc _ index ▁[ ▁i ▁] ▁] ▁. ▁table ▁|| ▁! ▁s ▁-> ▁vl cs ▁[ ▁1 ▁] ▁[ ▁s ▁-> ▁ac _ index ▁[ ▁i ▁] ▁] ▁. ▁table ▁) ▁goto ▁out _ of _ range ▁; ▁} ▁predictor ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁i lv ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁prev _ shift ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁; ▁point _ transform ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ components ▁; ▁i ▁++ ▁) ▁s ▁-> ▁last _ dc ▁[ ▁i ▁] ▁= ▁1024 ▁; ▁if ▁( ▁nb _ components ▁> ▁1 ▁) ▁{ ▁s ▁-> ▁mb _ width ▁= ▁( ▁s ▁-> ▁width ▁+ ▁s ▁-> ▁h _ max ▁* ▁block _ size ▁- ▁1 ▁) ▁/ ▁( ▁s ▁-> ▁h _ max ▁* ▁block _ size ▁) ▁; ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁s ▁-> ▁v _ max ▁* ▁block _ size ▁- ▁1 ▁) ▁/ ▁( ▁s ▁-> ▁v _ max ▁* ▁block _ size ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁s ▁-> ▁ls ▁) ▁{ ▁h ▁= ▁s ▁-> ▁h _ max ▁/ ▁s ▁-> ▁h _ s count ▁[ ▁0 ▁] ▁; ▁v ▁= ▁s ▁-> ▁v _ max ▁/ ▁s ▁-> ▁v _ s count ▁[ ▁0 ▁] ▁; ▁s ▁-> ▁mb _ width ▁= ▁( ▁s ▁-> ▁width ▁+ ▁h ▁* ▁block _ size ▁- ▁1 ▁) ▁/ ▁( ▁h ▁* ▁block _ size ▁) ▁; ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁v ▁* ▁block _ size ▁- ▁1 ▁) ▁/ ▁( ▁v ▁* ▁block _ size ▁) ▁; ▁s ▁-> ▁nb _ blocks ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁s ▁-> ▁h _ s count ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁s ▁-> ▁v _ s count ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁} ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ P ICT _ INFO ▁) ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁"% s % sp :% d >> :% d il v :% db its :% d % s \ n " ▁, ▁s ▁-> ▁loss less ▁? ▁" loss less " ▁: ▁" sequ enc ial D CT " ▁, ▁s ▁-> ▁rgb ▁? ▁" RGB " ▁: ▁"" ▁, ▁predictor ▁, ▁point _ transform ▁, ▁i lv ▁, ▁s ▁-> ▁bits ▁, ▁s ▁-> ▁p eg asus _ r ct ▁? ▁" PR CT " ▁: ▁( ▁s ▁-> ▁r ct ▁? ▁" R CT " ▁: ▁"" ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁s ▁-> ▁m j pb _ sk ipt os od ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁if ▁( ▁s ▁-> ▁loss less ▁) ▁{ ▁if ▁( ▁CONFIG _ JPEG LS _ DECODER ▁&& ▁s ▁-> ▁ls ▁) ▁{ ▁if ▁( ▁ff _ jpeg ls _ decode _ picture ▁( ▁s ▁, ▁predictor ▁, ▁point _ transform ▁, ▁i lv ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁rgb ▁) ▁{ ▁if ▁( ▁l jpeg _ decode _ rgb _ scan ▁( ▁s ▁, ▁predictor ▁, ▁point _ transform ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁l jpeg _ decode _ yuv _ scan ▁( ▁s ▁, ▁predictor ▁, ▁point _ transform ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁progress ive ▁&& ▁predictor ▁) ▁{ ▁if ▁( ▁m jpeg _ decode _ scan _ progress ive _ ac ▁( ▁s ▁, ▁predictor ▁, ▁i lv ▁, ▁prev _ shift ▁, ▁point _ transform ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁m jpeg _ decode _ scan ▁( ▁s ▁, ▁nb _ components ▁, ▁prev _ shift ▁, ▁point _ transform ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁} ▁e mm s _ c ▁( ▁) ▁; ▁return ▁0 ▁; ▁out _ of _ range ▁: ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" decode _ s os : ac / dc index out of range \ n " ▁) ▁; ▁return ▁-1 ▁; ▁}	1
▁static ▁void ▁build _ SYS _ str _ reasons ▁( ▁void ▁) ▁{ ▁static ▁char ▁strerror _ pool ▁[ ▁SPACE _ SYS _ STR _ REASON S ▁] ▁; ▁char ▁* ▁cur ▁= ▁strerror _ pool ▁; ▁size _ t ▁cnt ▁= ▁0 ▁; ▁static ▁int ▁init ▁= ▁1 ▁; ▁int ▁i ▁; ▁CRYPTO _ THREAD _ write _ lock ▁( ▁err _ string _ lock ▁) ▁; ▁if ▁( ▁! ▁init ▁) ▁{ ▁CRYPTO _ THREAD _ unlock ▁( ▁err _ string _ lock ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁NUM _ SYS _ STR _ REASON S ▁; ▁i ▁++ ▁) ▁{ ▁ERR _ STRING _ DATA ▁* ▁str ▁= ▁& ▁SYS _ str _ reasons ▁[ ▁i ▁- ▁1 ▁] ▁; ▁str ▁-> ▁error ▁= ▁ERR _ PACK ▁( ▁ERR _ LIB _ SYS ▁, ▁0 ▁, ▁i ▁) ▁; ▁if ▁( ▁str ▁-> ▁string ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁openssl _ strerror _ r ▁( ▁i ▁, ▁cur ▁, ▁sizeof ▁( ▁strerror _ pool ▁) ▁- ▁cnt ▁) ▁) ▁{ ▁size _ t ▁l ▁= ▁strlen ▁( ▁cur ▁) ▁+ ▁1 ▁; ▁str ▁-> ▁string ▁= ▁cur ▁; ▁cnt ▁+= ▁l ▁; ▁if ▁( ▁cnt ▁> ▁sizeof ▁( ▁strerror _ pool ▁) ▁) ▁cnt ▁= ▁sizeof ▁( ▁strerror _ pool ▁) ▁; ▁cur ▁+= ▁l ▁; ▁} ▁} ▁if ▁( ▁str ▁-> ▁string ▁== ▁NULL ▁) ▁str ▁-> ▁string ▁= ▁" unknown " ▁; ▁} ▁init ▁= ▁0 ▁; ▁CRYPTO _ THREAD _ unlock ▁( ▁err _ string _ lock ▁) ▁; ▁err _ load _ strings ▁( ▁SYS _ str _ reasons ▁) ▁; ▁}	1
▁static ▁int ▁ssl _ add _ cert _ to _ buf ▁( ▁BUF _ MEM ▁* ▁buf ▁, ▁unsigned ▁long ▁* ▁l ▁, ▁X 509 ▁* ▁x ▁) ▁{ ▁int ▁n ▁; ▁unsigned ▁char ▁* ▁p ▁; ▁n ▁= ▁i 2 d _ X 509 ▁( ▁x ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁BUF _ MEM _ grow _ clean ▁( ▁buf ▁, ▁( ▁int ▁) ▁( ▁n ▁+ ▁( ▁* ▁l ▁) ▁+ ▁3 ▁) ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ ADD _ CERT _ TO _ BUF ▁, ▁ERR _ R _ BUF _ LIB ▁) ▁; ▁return ▁0 ▁; ▁} ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁( ▁buf ▁-> ▁data ▁[ ▁* ▁l ▁] ▁) ▁; ▁l 2 n 3 ▁( ▁n ▁, ▁p ▁) ▁; ▁i 2 d _ X 509 ▁( ▁x ▁, ▁& ▁p ▁) ▁; ▁* ▁l ▁+= ▁n ▁+ ▁3 ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁decode _ packet ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁J peg 2000 Coding Style ▁* ▁co dst y ▁, ▁J peg 2000 Res Level ▁* ▁r level ▁, ▁int ▁prec no ▁, ▁int ▁lay no ▁, ▁uint 8_ t ▁* ▁exp n ▁, ▁int ▁num g bits ▁) ▁{ ▁int ▁band no ▁, ▁cb lk ny ▁, ▁cb lk nx ▁, ▁cb lk no ▁, ▁ret ▁; ▁if ▁( ▁! ▁( ▁ret ▁= ▁get _ bits ▁( ▁s ▁, ▁1 ▁) ▁) ▁) ▁{ ▁j 2 k _ flush ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁for ▁( ▁band no ▁= ▁0 ▁; ▁band no ▁< ▁r level ▁-> ▁nb ands ▁; ▁band no ▁++ ▁) ▁{ ▁J peg 2000 Band ▁* ▁band ▁= ▁r level ▁-> ▁band ▁+ ▁band no ▁; ▁J peg 2000 Prec ▁* ▁prec ▁= ▁band ▁-> ▁prec ▁+ ▁prec no ▁; ▁int ▁pos ▁= ▁0 ▁; ▁if ▁( ▁band ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁band ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁|| ▁band ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁== ▁band ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁continue ▁; ▁for ▁( ▁cb lk ny ▁= ▁prec ▁-> ▁yi 0 ▁; ▁cb lk ny ▁< ▁prec ▁-> ▁yi 1 ▁; ▁cb lk ny ▁++ ▁) ▁for ▁( ▁cb lk nx ▁= ▁prec ▁-> ▁xi 0 ▁, ▁cb lk no ▁= ▁cb lk ny ▁* ▁band ▁-> ▁cb lk nx ▁+ ▁cb lk nx ▁; ▁cb lk nx ▁< ▁prec ▁-> ▁xi 1 ▁; ▁cb lk nx ▁++ ▁, ▁cb lk no ▁++ ▁, ▁pos ▁++ ▁) ▁{ ▁J peg 2000 C blk ▁* ▁cb lk ▁= ▁band ▁-> ▁cb lk ▁+ ▁cb lk no ▁; ▁int ▁in cl ▁, ▁new passes ▁, ▁l len ▁; ▁if ▁( ▁cb lk ▁-> ▁np asses ▁) ▁in cl ▁= ▁get _ bits ▁( ▁s ▁, ▁1 ▁) ▁; ▁else ▁in cl ▁= ▁tag _ tree _ decode ▁( ▁s ▁, ▁prec ▁-> ▁cb lk in cl ▁+ ▁pos ▁, ▁lay no ▁+ ▁1 ▁) ▁== ▁lay no ▁; ▁if ▁( ▁! ▁in cl ▁) ▁continue ▁; ▁else ▁if ▁( ▁in cl ▁< ▁0 ▁) ▁return ▁in cl ▁; ▁if ▁( ▁! ▁cb lk ▁-> ▁np asses ▁) ▁cb lk ▁-> ▁non zer ob its ▁= ▁exp n ▁[ ▁band no ▁] ▁+ ▁num g bits ▁- ▁1 ▁- ▁tag _ tree _ decode ▁( ▁s ▁, ▁prec ▁-> ▁zer ob its ▁+ ▁pos ▁, ▁100 ▁) ▁; ▁if ▁( ▁( ▁new passes ▁= ▁get np asses ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁new passes ▁; ▁if ▁( ▁( ▁l len ▁= ▁get l block inc ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁l len ▁; ▁cb lk ▁-> ▁l block ▁+= ▁l len ▁; ▁if ▁( ▁( ▁ret ▁= ▁get _ bits ▁( ▁s ▁, ▁av _ log 2 ▁( ▁new passes ▁) ▁+ ▁cb lk ▁-> ▁l block ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁cb lk ▁-> ▁length inc ▁= ▁ret ▁; ▁cb lk ▁-> ▁np asses ▁+= ▁new passes ▁; ▁} ▁} ▁j 2 k _ flush ▁( ▁s ▁) ▁; ▁if ▁( ▁co dst y ▁-> ▁cst y ▁& ▁JPEG 2000_ C STY _ EP H ▁) ▁{ ▁if ▁( ▁bytestream 2_ peek _ be 16 ▁( ▁& ▁s ▁-> ▁g ▁) ▁== ▁JPEG 2000_ EP H ▁) ▁{ ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁g ▁, ▁2 ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" EP H marker not found .\ n " ▁) ▁; ▁} ▁} ▁for ▁( ▁band no ▁= ▁0 ▁; ▁band no ▁< ▁r level ▁-> ▁nb ands ▁; ▁band no ▁++ ▁) ▁{ ▁J peg 2000 Band ▁* ▁band ▁= ▁r level ▁-> ▁band ▁+ ▁band no ▁; ▁int ▁yi ▁, ▁cb lk nw ▁= ▁band ▁-> ▁prec ▁[ ▁prec no ▁] ▁. ▁xi 1 ▁- ▁band ▁-> ▁prec ▁[ ▁prec no ▁] ▁. ▁xi 0 ▁; ▁for ▁( ▁yi ▁= ▁band ▁-> ▁prec ▁[ ▁prec no ▁] ▁. ▁yi 0 ▁; ▁yi ▁< ▁band ▁-> ▁prec ▁[ ▁prec no ▁] ▁. ▁yi 1 ▁; ▁yi ▁++ ▁) ▁{ ▁int ▁xi ▁; ▁for ▁( ▁xi ▁= ▁band ▁-> ▁prec ▁[ ▁prec no ▁] ▁. ▁xi 0 ▁; ▁xi ▁< ▁band ▁-> ▁prec ▁[ ▁prec no ▁] ▁. ▁xi 1 ▁; ▁xi ▁++ ▁) ▁{ ▁J peg 2000 C blk ▁* ▁cb lk ▁= ▁band ▁-> ▁cb lk ▁+ ▁yi ▁* ▁cb lk nw ▁+ ▁xi ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁g ▁) ▁< ▁cb lk ▁-> ▁length inc ▁|| ▁sizeof ▁( ▁cb lk ▁-> ▁data ▁) ▁< ▁cb lk ▁-> ▁length inc ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁bytestream 2_ get _ buffer u ▁( ▁& ▁s ▁-> ▁g ▁, ▁cb lk ▁-> ▁data ▁, ▁cb lk ▁-> ▁length inc ▁) ▁; ▁cb lk ▁-> ▁length ▁+= ▁cb lk ▁-> ▁length inc ▁; ▁cb lk ▁-> ▁length inc ▁= ▁0 ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁GENERAL _ NAME _ print ▁( ▁BIO ▁* ▁out ▁, ▁GENERAL _ NAME ▁* ▁gen ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁; ▁int ▁i ▁; ▁switch ▁( ▁gen ▁-> ▁type ▁) ▁{ ▁case ▁GEN _ OTHER NAME ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" oth ername :< unsupported >" ▁) ▁; ▁break ▁; ▁case ▁GEN _ X 400 ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" X 400 Name :< unsupported >" ▁) ▁; ▁break ▁; ▁case ▁GEN _ ED IP AR TY ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" E di Party Name :< unsupported >" ▁) ▁; ▁break ▁; ▁case ▁GEN _ EMAIL ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" email :% s " ▁, ▁gen ▁-> ▁d ▁. ▁ia 5 ▁-> ▁data ▁) ▁; ▁break ▁; ▁case ▁GEN _ DNS ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" DNS :% s " ▁, ▁gen ▁-> ▁d ▁. ▁ia 5 ▁-> ▁data ▁) ▁; ▁break ▁; ▁case ▁GEN _ URI ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" URI :% s " ▁, ▁gen ▁-> ▁d ▁. ▁ia 5 ▁-> ▁data ▁) ▁; ▁break ▁; ▁case ▁GEN _ DIR NAME ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" Dir Name :" ▁) ▁; ▁X 509_ NAME _ print _ ex ▁( ▁out ▁, ▁gen ▁-> ▁d ▁. ▁dir n ▁, ▁0 ▁, ▁X N _ FLAG _ ON ELINE ▁) ▁; ▁break ▁; ▁case ▁GEN _ IP ADD ▁: ▁p ▁= ▁gen ▁-> ▁d ▁. ▁ip ▁-> ▁data ▁; ▁if ▁( ▁gen ▁-> ▁d ▁. ▁ip ▁-> ▁length ▁== ▁4 ▁) ▁BIO _ printf ▁( ▁out ▁, ▁" IPAddress :% d .% d .% d .% d " ▁, ▁p ▁[ ▁0 ▁] ▁, ▁p ▁[ ▁1 ▁] ▁, ▁p ▁[ ▁2 ▁] ▁, ▁p ▁[ ▁3 ▁] ▁) ▁; ▁else ▁if ▁( ▁gen ▁-> ▁d ▁. ▁ip ▁-> ▁length ▁== ▁16 ▁) ▁{ ▁BIO _ printf ▁( ▁out ▁, ▁" IPAddress " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁{ ▁BIO _ printf ▁( ▁out ▁, ▁" :% X " ▁, ▁p ▁[ ▁0 ▁] ▁<< ▁8 ▁| ▁p ▁[ ▁1 ▁] ▁) ▁; ▁p ▁+= ▁2 ▁; ▁} ▁BIO _ puts ▁( ▁out ▁, ▁"\ n " ▁) ▁; ▁} ▁else ▁{ ▁BIO _ printf ▁( ▁out ▁, ▁" IPAddress :< invalid >" ▁) ▁; ▁break ▁; ▁} ▁break ▁; ▁case ▁GEN _ R ID ▁: ▁BIO _ printf ▁( ▁out ▁, ▁" Registered ID :" ▁) ▁; ▁i 2 a _ ASN 1_ OBJECT ▁( ▁out ▁, ▁gen ▁-> ▁d ▁. ▁rid ▁) ▁; ▁break ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁authz _ tl se xt _ cb ▁( ▁SSL ▁* ▁s ▁, ▁unsigned ▁short ▁ext _ type ▁, ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁unsigned ▁short ▁inlen ▁, ▁int ▁* ▁al ▁, ▁void ▁* ▁arg ▁) ▁{ ▁if ▁( ▁TL SE XT _ TYPE _ server _ auth z ▁== ▁ext _ type ▁) ▁{ ▁server _ provided _ server _ auth z ▁= ▁( ▁memchr ▁( ▁in ▁, ▁TL SE XT _ AUTH Z DATA FORMAT _ dt cp ▁, ▁inlen ▁) ▁!= ▁NULL ▁) ▁; ▁} ▁if ▁( ▁TL SE XT _ TYPE _ client _ auth z ▁== ▁ext _ type ▁) ▁{ ▁server _ provided _ client _ auth z ▁= ▁( ▁memchr ▁( ▁in ▁, ▁TL SE XT _ AUTH Z DATA FORMAT _ dt cp ▁, ▁inlen ▁) ▁!= ▁NULL ▁) ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁int ▁BN _ GF 2 m _ mod _ inv ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁p ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁BIGNUM ▁* ▁b ▁, ▁* ▁c ▁= ▁NULL ▁, ▁* ▁u ▁= ▁NULL ▁, ▁* ▁v ▁= ▁NULL ▁, ▁* ▁tmp ▁; ▁int ▁ret ▁= ▁0 ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁p ▁) ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁if ▁( ▁( ▁b ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁c ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁u ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁v ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ GF 2 m _ mod ▁( ▁u ▁, ▁a ▁, ▁p ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁u ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ copy ▁( ▁v ▁, ▁p ▁) ▁) ▁goto ▁err ▁; ▁# if ▁0 ▁if ▁( ▁! ▁BN _ one ▁( ▁b ▁) ▁) ▁goto ▁err ▁; ▁while ▁( ▁1 ▁) ▁{ ▁while ▁( ▁! ▁BN _ is _ odd ▁( ▁u ▁) ▁) ▁{ ▁if ▁( ▁BN _ is _ zero ▁( ▁u ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ rshift 1 ▁( ▁u ▁, ▁u ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ is _ odd ▁( ▁b ▁) ▁) ▁{ ▁if ▁( ▁! ▁BN _ GF 2 m _ add ▁( ▁b ▁, ▁b ▁, ▁p ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ rshift 1 ▁( ▁b ▁, ▁b ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁BN _ abs _ is _ word ▁( ▁u ▁, ▁1 ▁) ▁) ▁break ▁; ▁if ▁( ▁BN _ num _ bits ▁( ▁u ▁) ▁< ▁BN _ num _ bits ▁( ▁v ▁) ▁) ▁{ ▁tmp ▁= ▁u ▁; ▁u ▁= ▁v ▁; ▁v ▁= ▁tmp ▁; ▁tmp ▁= ▁b ▁; ▁b ▁= ▁c ▁; ▁c ▁= ▁tmp ▁; ▁} ▁if ▁( ▁! ▁BN _ GF 2 m _ add ▁( ▁u ▁, ▁u ▁, ▁v ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ GF 2 m _ add ▁( ▁b ▁, ▁b ▁, ▁c ▁) ▁) ▁goto ▁err ▁; ▁} ▁# else ▁{ ▁int ▁i ▁; ▁int ▁ub its ▁= ▁BN _ num _ bits ▁( ▁u ▁) ▁; ▁int ▁v bits ▁= ▁BN _ num _ bits ▁( ▁v ▁) ▁; ▁int ▁top ▁= ▁p ▁-> ▁top ▁; ▁BN _ ULONG ▁* ▁udp ▁, ▁* ▁b dp ▁, ▁* ▁v dp ▁, ▁* ▁cdp ▁; ▁if ▁( ▁! ▁bn _ w expand ▁( ▁u ▁, ▁top ▁) ▁) ▁goto ▁err ▁; ▁udp ▁= ▁u ▁-> ▁d ▁; ▁for ▁( ▁i ▁= ▁u ▁-> ▁top ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁udp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁u ▁-> ▁top ▁= ▁top ▁; ▁if ▁( ▁! ▁bn _ w expand ▁( ▁b ▁, ▁top ▁) ▁) ▁goto ▁err ▁; ▁b dp ▁= ▁b ▁-> ▁d ▁; ▁b dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁b dp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁b ▁-> ▁top ▁= ▁top ▁; ▁if ▁( ▁! ▁bn _ w expand ▁( ▁c ▁, ▁top ▁) ▁) ▁goto ▁err ▁; ▁cdp ▁= ▁c ▁-> ▁d ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁cdp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁c ▁-> ▁top ▁= ▁top ▁; ▁v dp ▁= ▁v ▁-> ▁d ▁; ▁while ▁( ▁1 ▁) ▁{ ▁while ▁( ▁ub its ▁&& ▁! ▁( ▁udp ▁[ ▁0 ▁] ▁& ▁1 ▁) ▁) ▁{ ▁BN _ ULONG ▁u 0 ▁, ▁u 1 ▁, ▁b 0 ▁, ▁b 1 ▁, ▁mask ▁; ▁u 0 ▁= ▁udp ▁[ ▁0 ▁] ▁; ▁b 0 ▁= ▁b dp ▁[ ▁0 ▁] ▁; ▁mask ▁= ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁b 0 ▁& ▁1 ▁) ▁; ▁b 0 ▁ ^ = ▁p ▁-> ▁d ▁[ ▁0 ▁] ▁& ▁mask ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁u 1 ▁= ▁udp ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁udp ▁[ ▁i ▁] ▁= ▁( ▁( ▁u 0 ▁>> ▁1 ▁) ▁| ▁( ▁u 1 ▁<< ▁( ▁BN _ BITS 2 ▁- ▁1 ▁) ▁) ▁) ▁& ▁BN _ MASK 2 ▁; ▁u 0 ▁= ▁u 1 ▁; ▁b 1 ▁= ▁b dp ▁[ ▁i ▁+ ▁1 ▁] ▁ ^ ▁( ▁p ▁-> ▁d ▁[ ▁i ▁+ ▁1 ▁] ▁& ▁mask ▁) ▁; ▁b dp ▁[ ▁i ▁] ▁= ▁( ▁( ▁b 0 ▁>> ▁1 ▁) ▁| ▁( ▁b 1 ▁<< ▁( ▁BN _ BITS 2 ▁- ▁1 ▁) ▁) ▁) ▁& ▁BN _ MASK 2 ▁; ▁b 0 ▁= ▁b 1 ▁; ▁} ▁udp ▁[ ▁i ▁] ▁= ▁u 0 ▁>> ▁1 ▁; ▁b dp ▁[ ▁i ▁] ▁= ▁b 0 ▁>> ▁1 ▁; ▁ub its ▁-- ▁; ▁} ▁if ▁( ▁ub its ▁<= ▁BN _ BITS 2 ▁) ▁{ ▁if ▁( ▁udp ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁udp ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁break ▁; ▁} ▁if ▁( ▁ub its ▁< ▁v bits ▁) ▁{ ▁i ▁= ▁ub its ▁; ▁ub its ▁= ▁v bits ▁; ▁v bits ▁= ▁i ▁; ▁tmp ▁= ▁u ▁; ▁u ▁= ▁v ▁; ▁v ▁= ▁tmp ▁; ▁tmp ▁= ▁b ▁; ▁b ▁= ▁c ▁; ▁c ▁= ▁tmp ▁; ▁udp ▁= ▁v dp ▁; ▁v dp ▁= ▁v ▁-> ▁d ▁; ▁b dp ▁= ▁cdp ▁; ▁cdp ▁= ▁c ▁-> ▁d ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁{ ▁udp ▁[ ▁i ▁] ▁ ^ = ▁v dp ▁[ ▁i ▁] ▁; ▁b dp ▁[ ▁i ▁] ▁ ^ = ▁cdp ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁ub its ▁== ▁v bits ▁) ▁{ ▁BN _ ULONG ▁ul ▁; ▁int ▁ut op ▁= ▁( ▁ub its ▁- ▁1 ▁) ▁/ ▁BN _ BITS 2 ▁; ▁while ▁( ▁( ▁ul ▁= ▁udp ▁[ ▁ut op ▁] ▁) ▁== ▁0 ▁&& ▁ut op ▁) ▁ut op ▁-- ▁; ▁ub its ▁= ▁ut op ▁* ▁BN _ BITS 2 ▁+ ▁BN _ num _ bits _ word ▁( ▁ul ▁) ▁; ▁} ▁} ▁bn _ correct _ top ▁( ▁b ▁) ▁; ▁} ▁# endif ▁if ▁( ▁! ▁BN _ copy ▁( ▁r ▁, ▁b ▁) ▁) ▁goto ▁err ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁# ifdef ▁BN _ DEBUG ▁bn _ correct _ top ▁( ▁c ▁) ▁; ▁bn _ correct _ top ▁( ▁u ▁) ▁; ▁bn _ correct _ top ▁( ▁v ▁) ▁; ▁# endif ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁asn 1_ get _ length ▁( ▁const ▁unsigned ▁char ▁* ▁* ▁pp ▁, ▁int ▁* ▁inf ▁, ▁long ▁* ▁rl ▁, ▁int ▁max ▁) ▁{ ▁const ▁unsigned ▁char ▁* ▁p ▁= ▁* ▁pp ▁; ▁unsigned ▁long ▁ret ▁= ▁0 ▁; ▁unsigned ▁int ▁i ▁; ▁if ▁( ▁max ▁-- ▁< ▁1 ▁) ▁return ▁( ▁0 ▁) ▁; ▁if ▁( ▁* ▁p ▁== ▁0 x 80 ▁) ▁{ ▁* ▁inf ▁= ▁1 ▁; ▁ret ▁= ▁0 ▁; ▁p ▁++ ▁; ▁} ▁else ▁{ ▁* ▁inf ▁= ▁0 ▁; ▁i ▁= ▁* ▁p ▁& ▁0 x 7 f ▁; ▁if ▁( ▁* ▁( ▁p ▁++ ▁) ▁& ▁0 x 80 ▁) ▁{ ▁if ▁( ▁i ▁> ▁sizeof ▁( ▁long ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁max ▁-- ▁== ▁0 ▁) ▁return ▁( ▁0 ▁) ▁; ▁while ▁( ▁i ▁-- ▁> ▁0 ▁) ▁{ ▁ret ▁<<= ▁8 L ▁; ▁ret ▁|= ▁* ▁( ▁p ▁++ ▁) ▁; ▁if ▁( ▁max ▁-- ▁== ▁0 ▁) ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁else ▁ret ▁= ▁i ▁; ▁} ▁if ▁( ▁ret ▁> ▁LONG _ MAX ▁) ▁return ▁0 ▁; ▁* ▁pp ▁= ▁p ▁; ▁* ▁rl ▁= ▁( ▁long ▁) ▁ret ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁int 64_ t ▁read _ ts ▁( ▁const ▁char ▁* ▁s ▁) ▁{ ▁int ▁hh ▁, ▁mm ▁, ▁ss ▁, ▁ms ▁; ▁if ▁( ▁sscanf ▁( ▁s ▁, ▁"% u :% u :% u .% u " ▁, ▁& ▁hh ▁, ▁& ▁mm ▁, ▁& ▁ss ▁, ▁& ▁ms ▁) ▁== ▁4 ▁) ▁return ▁( ▁hh ▁* ▁3600 ▁+ ▁mm ▁* ▁60 ▁+ ▁ss ▁) ▁* ▁1000 ▁+ ▁ms ▁; ▁if ▁( ▁sscanf ▁( ▁s ▁, ▁"% u :% u .% u " ▁, ▁& ▁mm ▁, ▁& ▁ss ▁, ▁& ▁ms ▁) ▁== ▁3 ▁) ▁return ▁( ▁mm ▁* ▁60 ▁+ ▁ss ▁) ▁* ▁1000 ▁+ ▁ms ▁; ▁return ▁AV _ NOP TS _ VALUE ▁; ▁}	1
▁static ▁int ▁fill _ filter _ caches ▁( ▁H 264 Context ▁* ▁h ▁, ▁int ▁mb _ type ▁) ▁{ ▁Mpeg Enc Context ▁* ▁const ▁s ▁= ▁& ▁h ▁-> ▁s ▁; ▁const ▁int ▁mb _ xy ▁= ▁h ▁-> ▁mb _ xy ▁; ▁int ▁top _ xy ▁, ▁left _ xy ▁[ ▁2 ▁] ▁; ▁int ▁top _ type ▁, ▁left _ type ▁[ ▁2 ▁] ▁; ▁uint 8_ t ▁* ▁nnz ▁; ▁uint 8_ t ▁* ▁nnz _ cache ▁; ▁top _ xy ▁= ▁mb _ xy ▁- ▁( ▁s ▁-> ▁mb _ stride ▁<< ▁MB _ FIELD ▁) ▁; ▁left _ xy ▁[ ▁1 ▁] ▁= ▁left _ xy ▁[ ▁0 ▁] ▁= ▁mb _ xy ▁- ▁1 ▁; ▁if ▁( ▁FRAME _ MB AFF ▁) ▁{ ▁const ▁int ▁left _ mb _ field _ flag ▁= ▁IS _ INTER L ACED ▁( ▁s ▁-> ▁current _ picture ▁. ▁mb _ type ▁[ ▁mb _ xy ▁- ▁1 ▁] ▁) ▁; ▁const ▁int ▁curr _ mb _ field _ flag ▁= ▁IS _ INTER L ACED ▁( ▁mb _ type ▁) ▁; ▁if ▁( ▁s ▁-> ▁mb _ y ▁& ▁1 ▁) ▁{ ▁if ▁( ▁left _ mb _ field _ flag ▁!= ▁curr _ mb _ field _ flag ▁) ▁{ ▁left _ xy ▁[ ▁0 ▁] ▁-= ▁s ▁-> ▁mb _ stride ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁curr _ mb _ field _ flag ▁) ▁{ ▁top _ xy ▁+= ▁s ▁-> ▁mb _ stride ▁& ▁( ▁( ▁( ▁s ▁-> ▁current _ picture ▁. ▁mb _ type ▁[ ▁top _ xy ▁] ▁>> ▁7 ▁) ▁& ▁1 ▁) ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁left _ mb _ field _ flag ▁!= ▁curr _ mb _ field _ flag ▁) ▁{ ▁left _ xy ▁[ ▁1 ▁] ▁+= ▁s ▁-> ▁mb _ stride ▁; ▁} ▁} ▁} ▁h ▁-> ▁top _ mb _ xy ▁= ▁top _ xy ▁; ▁h ▁-> ▁left _ mb _ xy ▁[ ▁0 ▁] ▁= ▁left _ xy ▁[ ▁0 ▁] ▁; ▁h ▁-> ▁left _ mb _ xy ▁[ ▁1 ▁] ▁= ▁left _ xy ▁[ ▁1 ▁] ▁; ▁{ ▁int ▁qp _ thresh ▁= ▁h ▁-> ▁qp _ thresh ▁; ▁int ▁qp ▁= ▁s ▁-> ▁current _ picture ▁. ▁q scale _ table ▁[ ▁mb _ xy ▁] ▁; ▁if ▁( ▁qp ▁<= ▁qp _ thresh ▁&& ▁( ▁left _ xy ▁[ ▁0 ▁] ▁< ▁0 ▁|| ▁( ▁( ▁qp ▁+ ▁s ▁-> ▁current _ picture ▁. ▁q scale _ table ▁[ ▁left _ xy ▁[ ▁0 ▁] ▁] ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁<= ▁qp _ thresh ▁) ▁&& ▁( ▁top _ xy ▁< ▁0 ▁|| ▁( ▁( ▁qp ▁+ ▁s ▁-> ▁current _ picture ▁. ▁q scale _ table ▁[ ▁top _ xy ▁] ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁<= ▁qp _ thresh ▁) ▁) ▁{ ▁if ▁( ▁! ▁FRAME _ MB AFF ▁) ▁return ▁1 ▁; ▁if ▁( ▁( ▁left _ xy ▁[ ▁0 ▁] ▁< ▁0 ▁|| ▁( ▁( ▁qp ▁+ ▁s ▁-> ▁current _ picture ▁. ▁q scale _ table ▁[ ▁left _ xy ▁[ ▁1 ▁] ▁] ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁<= ▁qp _ thresh ▁) ▁&& ▁( ▁top _ xy ▁< ▁s ▁-> ▁mb _ stride ▁|| ▁( ▁( ▁qp ▁+ ▁s ▁-> ▁current _ picture ▁. ▁q scale _ table ▁[ ▁top _ xy ▁- ▁s ▁-> ▁mb _ stride ▁] ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁<= ▁qp _ thresh ▁) ▁) ▁return ▁1 ▁; ▁} ▁} ▁top _ type ▁= ▁s ▁-> ▁current _ picture ▁. ▁mb _ type ▁[ ▁top _ xy ▁] ▁; ▁left _ type ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁mb _ type ▁[ ▁left _ xy ▁[ ▁0 ▁] ▁] ▁; ▁left _ type ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁mb _ type ▁[ ▁left _ xy ▁[ ▁1 ▁] ▁] ▁; ▁if ▁( ▁h ▁-> ▁de blocking _ filter ▁== ▁2 ▁) ▁{ ▁if ▁( ▁h ▁-> ▁slice _ table ▁[ ▁top _ xy ▁] ▁!= ▁h ▁-> ▁slice _ num ▁) ▁top _ type ▁= ▁0 ▁; ▁if ▁( ▁h ▁-> ▁slice _ table ▁[ ▁left _ xy ▁[ ▁0 ▁] ▁] ▁!= ▁h ▁-> ▁slice _ num ▁) ▁left _ type ▁[ ▁0 ▁] ▁= ▁left _ type ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁} ▁else ▁{ ▁if ▁( ▁h ▁-> ▁slice _ table ▁[ ▁top _ xy ▁] ▁== ▁0 xFFFF ▁) ▁top _ type ▁= ▁0 ▁; ▁if ▁( ▁h ▁-> ▁slice _ table ▁[ ▁left _ xy ▁[ ▁0 ▁] ▁] ▁== ▁0 xFFFF ▁) ▁left _ type ▁[ ▁0 ▁] ▁= ▁left _ type ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁} ▁h ▁-> ▁top _ type ▁= ▁top _ type ▁; ▁h ▁-> ▁left _ type ▁[ ▁0 ▁] ▁= ▁left _ type ▁[ ▁0 ▁] ▁; ▁h ▁-> ▁left _ type ▁[ ▁1 ▁] ▁= ▁left _ type ▁[ ▁1 ▁] ▁; ▁if ▁( ▁IS _ INTR A ▁( ▁mb _ type ▁) ▁) ▁return ▁0 ▁; ▁fill _ filter _ caches _ inter ▁( ▁h ▁, ▁s ▁, ▁mb _ type ▁, ▁top _ xy ▁, ▁left _ xy ▁, ▁top _ type ▁, ▁left _ type ▁, ▁mb _ xy ▁, ▁0 ▁) ▁; ▁if ▁( ▁h ▁-> ▁list _ count ▁== ▁2 ▁) ▁fill _ filter _ caches _ inter ▁( ▁h ▁, ▁s ▁, ▁mb _ type ▁, ▁top _ xy ▁, ▁left _ xy ▁, ▁top _ type ▁, ▁left _ type ▁, ▁mb _ xy ▁, ▁1 ▁) ▁; ▁nnz ▁= ▁h ▁-> ▁non _ zero _ count ▁[ ▁mb _ xy ▁] ▁; ▁nnz _ cache ▁= ▁h ▁-> ▁non _ zero _ count _ cache ▁; ▁AV _ COPY 32 ▁( ▁& ▁nnz _ cache ▁[ ▁4 ▁+ ▁8 ▁* ▁1 ▁] ▁, ▁& ▁nnz ▁[ ▁0 ▁] ▁) ▁; ▁AV _ COPY 32 ▁( ▁& ▁nnz _ cache ▁[ ▁4 ▁+ ▁8 ▁* ▁2 ▁] ▁, ▁& ▁nnz ▁[ ▁4 ▁] ▁) ▁; ▁AV _ COPY 32 ▁( ▁& ▁nnz _ cache ▁[ ▁4 ▁+ ▁8 ▁* ▁3 ▁] ▁, ▁& ▁nnz ▁[ ▁8 ▁] ▁) ▁; ▁AV _ COPY 32 ▁( ▁& ▁nnz _ cache ▁[ ▁4 ▁+ ▁8 ▁* ▁4 ▁] ▁, ▁& ▁nnz ▁[ ▁12 ▁] ▁) ▁; ▁h ▁-> ▁cb p ▁= ▁h ▁-> ▁cb p _ table ▁[ ▁mb _ xy ▁] ▁; ▁if ▁( ▁top _ type ▁) ▁{ ▁nnz ▁= ▁h ▁-> ▁non _ zero _ count ▁[ ▁top _ xy ▁] ▁; ▁AV _ COPY 32 ▁( ▁& ▁nnz _ cache ▁[ ▁4 ▁+ ▁8 ▁* ▁0 ▁] ▁, ▁& ▁nnz ▁[ ▁3 ▁* ▁4 ▁] ▁) ▁; ▁} ▁if ▁( ▁left _ type ▁[ ▁0 ▁] ▁) ▁{ ▁nnz ▁= ▁h ▁-> ▁non _ zero _ count ▁[ ▁left _ xy ▁[ ▁0 ▁] ▁] ▁; ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁1 ▁] ▁= ▁nnz ▁[ ▁3 ▁+ ▁0 ▁* ▁4 ▁] ▁; ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁2 ▁] ▁= ▁nnz ▁[ ▁3 ▁+ ▁1 ▁* ▁4 ▁] ▁; ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁3 ▁] ▁= ▁nnz ▁[ ▁3 ▁+ ▁2 ▁* ▁4 ▁] ▁; ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁4 ▁] ▁= ▁nnz ▁[ ▁3 ▁+ ▁3 ▁* ▁4 ▁] ▁; ▁} ▁if ▁( ▁! ▁C AB AC ▁&& ▁h ▁-> ▁pps ▁. ▁transform _8 x 8_ mode ▁) ▁{ ▁if ▁( ▁IS _8 x 8 D CT ▁( ▁top _ type ▁) ▁) ▁{ ▁nnz _ cache ▁[ ▁4 ▁+ ▁8 ▁* ▁0 ▁] ▁= ▁nnz _ cache ▁[ ▁5 ▁+ ▁8 ▁* ▁0 ▁] ▁= ▁( ▁h ▁-> ▁cb p _ table ▁[ ▁top _ xy ▁] ▁& ▁0 x 4000 ▁) ▁>> ▁12 ▁; ▁nnz _ cache ▁[ ▁6 ▁+ ▁8 ▁* ▁0 ▁] ▁= ▁nnz _ cache ▁[ ▁7 ▁+ ▁8 ▁* ▁0 ▁] ▁= ▁( ▁h ▁-> ▁cb p _ table ▁[ ▁top _ xy ▁] ▁& ▁0 x 8000 ▁) ▁>> ▁12 ▁; ▁} ▁if ▁( ▁IS _8 x 8 D CT ▁( ▁left _ type ▁[ ▁0 ▁] ▁) ▁) ▁{ ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁1 ▁] ▁= ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁2 ▁] ▁= ▁( ▁h ▁-> ▁cb p _ table ▁[ ▁left _ xy ▁[ ▁0 ▁] ▁] ▁& ▁0 x 2000 ▁) ▁>> ▁12 ▁; ▁} ▁if ▁( ▁IS _8 x 8 D CT ▁( ▁left _ type ▁[ ▁1 ▁] ▁) ▁) ▁{ ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁3 ▁] ▁= ▁nnz _ cache ▁[ ▁3 ▁+ ▁8 ▁* ▁4 ▁] ▁= ▁( ▁h ▁-> ▁cb p _ table ▁[ ▁left _ xy ▁[ ▁1 ▁] ▁] ▁& ▁0 x 8000 ▁) ▁>> ▁12 ▁; ▁} ▁if ▁( ▁IS _8 x 8 D CT ▁( ▁mb _ type ▁) ▁) ▁{ ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁0 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁1 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁2 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁3 ▁] ▁] ▁= ▁( ▁h ▁-> ▁cb p ▁& ▁0 x 1000 ▁) ▁>> ▁12 ▁; ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁0 ▁+ ▁4 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁1 ▁+ ▁4 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁2 ▁+ ▁4 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁3 ▁+ ▁4 ▁] ▁] ▁= ▁( ▁h ▁-> ▁cb p ▁& ▁0 x 2000 ▁) ▁>> ▁12 ▁; ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁0 ▁+ ▁8 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁1 ▁+ ▁8 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁2 ▁+ ▁8 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁3 ▁+ ▁8 ▁] ▁] ▁= ▁( ▁h ▁-> ▁cb p ▁& ▁0 x 4000 ▁) ▁>> ▁12 ▁; ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁0 ▁+ ▁12 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁1 ▁+ ▁12 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁2 ▁+ ▁12 ▁] ▁] ▁= ▁nnz _ cache ▁[ ▁scan 8 ▁[ ▁3 ▁+ ▁12 ▁] ▁] ▁= ▁( ▁h ▁-> ▁cb p ▁& ▁0 x 8000 ▁) ▁>> ▁12 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁inline ▁void ▁skip _ bits _ long ▁( ▁Get Bit Context ▁* ▁s ▁, ▁int ▁n ▁) ▁{ ▁# if ▁UN CHECKED _ BIT STREAM _ READER ▁s ▁-> ▁index ▁+= ▁n ▁; ▁# else ▁s ▁-> ▁index ▁+= ▁av _ clip ▁( ▁n ▁, ▁- ▁s ▁-> ▁index ▁, ▁s ▁-> ▁size _ in _ bits _ plus 8 ▁- ▁s ▁-> ▁index ▁) ▁; ▁# endif ▁}	1
▁static ▁int ▁vorbis _ encode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁avpkt ▁, ▁const ▁AVFrame ▁* ▁frame ▁, ▁int ▁* ▁got _ packet _ ptr ▁) ▁{ ▁vorbis _ enc _ context ▁* ▁v enc ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁ret ▁, ▁need _ more ▁; ▁int ▁samples ▁= ▁0 ▁, ▁frame _ size ▁= ▁1 ▁<< ▁( ▁v enc ▁-> ▁log 2_ blocksize ▁[ ▁1 ▁] ▁- ▁1 ▁) ▁; ▁vorbis _ enc _ mode ▁* ▁mode ▁; ▁vorbis _ enc _ mapping ▁* ▁mapping ▁; ▁Put Bit Context ▁pb ▁; ▁if ▁( ▁frame ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁ff _ af _ queue _ add ▁( ▁& ▁v enc ▁-> ▁af q ▁, ▁frame ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ff _ buf queue _ add ▁( ▁avctx ▁, ▁& ▁v enc ▁-> ▁buf queue ▁, ▁av _ frame _ clone ▁( ▁frame ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁v enc ▁-> ▁af q ▁. ▁remaining _ samples ▁) ▁return ▁0 ▁; ▁need _ more ▁= ▁v enc ▁-> ▁buf queue ▁. ▁available ▁* ▁avctx ▁-> ▁frame _ size ▁< ▁frame _ size ▁; ▁need _ more ▁= ▁frame ▁&& ▁need _ more ▁; ▁if ▁( ▁need _ more ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁frame ▁) ▁{ ▁if ▁( ▁v enc ▁-> ▁buf queue ▁. ▁available ▁* ▁avctx ▁-> ▁frame _ size ▁< ▁frame _ size ▁) ▁{ ▁int ▁frames _ needed ▁= ▁( ▁frame _ size ▁/ ▁avctx ▁-> ▁frame _ size ▁) ▁- ▁v enc ▁-> ▁buf queue ▁. ▁available ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁frames _ needed ▁; ▁i ▁++ ▁) ▁{ ▁AVFrame ▁* ▁empty ▁= ▁spawn _ empty _ frame ▁( ▁avctx ▁, ▁v enc ▁-> ▁channels ▁) ▁; ▁if ▁( ▁! ▁empty ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁ff _ buf queue _ add ▁( ▁avctx ▁, ▁& ▁v enc ▁-> ▁buf queue ▁, ▁empty ▁) ▁; ▁} ▁} ▁} ▁move _ audio ▁( ▁v enc ▁, ▁v enc ▁-> ▁scratch ▁, ▁& ▁samples ▁, ▁avctx ▁-> ▁frame _ size ▁) ▁; ▁if ▁( ▁! ▁apply _ window _ and _ md ct ▁( ▁v enc ▁, ▁v enc ▁-> ▁scratch ▁, ▁samples ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ alloc _ packet 2 ▁( ▁avctx ▁, ▁avpkt ▁, ▁8192 ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁init _ put _ bits ▁( ▁& ▁pb ▁, ▁avpkt ▁-> ▁data ▁, ▁avpkt ▁-> ▁size ▁) ▁; ▁if ▁( ▁pb ▁. ▁size _ in _ bits ▁- ▁put _ bits _ count ▁( ▁& ▁pb ▁) ▁< ▁1 ▁+ ▁ilog ▁( ▁v enc ▁-> ▁n modes ▁- ▁1 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" output buffer ist oo small \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁put _ bits ▁( ▁& ▁pb ▁, ▁1 ▁, ▁0 ▁) ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁ilog ▁( ▁v enc ▁-> ▁n modes ▁- ▁1 ▁) ▁, ▁0 ▁) ▁; ▁mode ▁= ▁& ▁v enc ▁-> ▁modes ▁[ ▁0 ▁] ▁; ▁mapping ▁= ▁& ▁v enc ▁-> ▁mappings ▁[ ▁mode ▁-> ▁mapping ▁] ▁; ▁if ▁( ▁mode ▁-> ▁block flag ▁) ▁{ ▁put _ bits ▁( ▁& ▁pb ▁, ▁1 ▁, ▁0 ▁) ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁1 ▁, ▁0 ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁v enc ▁-> ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁vorbis _ enc _ floor ▁* ▁fc ▁= ▁& ▁v enc ▁-> ▁flo ors ▁[ ▁mapping ▁-> ▁floor ▁[ ▁mapping ▁-> ▁mux ▁[ ▁i ▁] ▁] ▁] ▁; ▁uint 16_ t ▁post s ▁[ ▁MAX _ F LO OR _ VALUES ▁] ▁; ▁floor _ fit ▁( ▁v enc ▁, ▁fc ▁, ▁& ▁v enc ▁-> ▁coeffs ▁[ ▁i ▁* ▁samples ▁] ▁, ▁post s ▁, ▁samples ▁) ▁; ▁if ▁( ▁floor _ encode ▁( ▁v enc ▁, ▁fc ▁, ▁& ▁pb ▁, ▁post s ▁, ▁& ▁v enc ▁-> ▁floor ▁[ ▁i ▁* ▁samples ▁] ▁, ▁samples ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" output buffer ist oo small \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁v enc ▁-> ▁channels ▁* ▁samples ▁; ▁i ▁++ ▁) ▁v enc ▁-> ▁coeffs ▁[ ▁i ▁] ▁/= ▁v enc ▁-> ▁floor ▁[ ▁i ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁mapping ▁-> ▁coup ling _ steps ▁; ▁i ▁++ ▁) ▁{ ▁float ▁* ▁mag ▁= ▁v enc ▁-> ▁coeffs ▁+ ▁mapping ▁-> ▁magnitude ▁[ ▁i ▁] ▁* ▁samples ▁; ▁float ▁* ▁ang ▁= ▁v enc ▁-> ▁coeffs ▁+ ▁mapping ▁-> ▁angle ▁[ ▁i ▁] ▁* ▁samples ▁; ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁samples ▁; ▁j ▁++ ▁) ▁{ ▁float ▁a ▁= ▁ang ▁[ ▁j ▁] ▁; ▁ang ▁[ ▁j ▁] ▁-= ▁mag ▁[ ▁j ▁] ▁; ▁if ▁( ▁mag ▁[ ▁j ▁] ▁> ▁0 ▁) ▁ang ▁[ ▁j ▁] ▁= ▁- ▁ang ▁[ ▁j ▁] ▁; ▁if ▁( ▁ang ▁[ ▁j ▁] ▁< ▁0 ▁) ▁mag ▁[ ▁j ▁] ▁= ▁a ▁; ▁} ▁} ▁if ▁( ▁residue _ encode ▁( ▁v enc ▁, ▁& ▁v enc ▁-> ▁resid ues ▁[ ▁mapping ▁-> ▁residue ▁[ ▁mapping ▁-> ▁mux ▁[ ▁0 ▁] ▁] ▁] ▁, ▁& ▁pb ▁, ▁v enc ▁-> ▁coeffs ▁, ▁samples ▁, ▁v enc ▁-> ▁channels ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" output buffer ist oo small \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁flush _ put _ bits ▁( ▁& ▁pb ▁) ▁; ▁avpkt ▁-> ▁size ▁= ▁put _ bits _ count ▁( ▁& ▁pb ▁) ▁>> ▁3 ▁; ▁ff _ af _ queue _ remove ▁( ▁& ▁v enc ▁-> ▁af q ▁, ▁frame _ size ▁, ▁& ▁avpkt ▁-> ▁pts ▁, ▁& ▁avpkt ▁-> ▁duration ▁) ▁; ▁if ▁( ▁frame _ size ▁> ▁avpkt ▁-> ▁duration ▁) ▁{ ▁uint 8_ t ▁* ▁side ▁= ▁av _ packet _ new _ side _ data ▁( ▁avpkt ▁, ▁AV _ PKT _ DATA _ SKIP _ SAMPLES ▁, ▁10 ▁) ▁; ▁if ▁( ▁! ▁side ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁AV _ WL 32 ▁( ▁& ▁side ▁[ ▁4 ▁] ▁, ▁frame _ size ▁- ▁avpkt ▁-> ▁duration ▁) ▁; ▁} ▁* ▁got _ packet _ ptr ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁sk _ reserve ▁( ▁OPENSSL _ STACK ▁* ▁st ▁, ▁int ▁n ▁, ▁int ▁exact ▁) ▁{ ▁const ▁void ▁* ▁* ▁tmp data ▁; ▁int ▁num _ alloc ▁; ▁if ▁( ▁n ▁> ▁max _ nodes ▁- ▁st ▁-> ▁num ▁) ▁return ▁0 ▁; ▁num _ alloc ▁= ▁st ▁-> ▁num ▁+ ▁n ▁; ▁if ▁( ▁num _ alloc ▁< ▁min _ nodes ▁) ▁num _ alloc ▁= ▁min _ nodes ▁; ▁if ▁( ▁st ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁st ▁-> ▁data ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁void ▁* ▁) ▁* ▁num _ alloc ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁return ▁0 ▁; ▁} ▁st ▁-> ▁num _ alloc ▁= ▁num _ alloc ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁! ▁exact ▁) ▁{ ▁if ▁( ▁num _ alloc ▁<= ▁st ▁-> ▁num _ alloc ▁) ▁return ▁1 ▁; ▁num _ alloc ▁= ▁compute _ grow th ▁( ▁num _ alloc ▁, ▁st ▁-> ▁num _ alloc ▁) ▁; ▁if ▁( ▁num _ alloc ▁== ▁0 ▁) ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁num _ alloc ▁== ▁st ▁-> ▁num _ alloc ▁) ▁{ ▁return ▁1 ▁; ▁} ▁tmp data ▁= ▁OPENSSL _ realloc ▁( ▁( ▁void ▁* ▁) ▁st ▁-> ▁data ▁, ▁sizeof ▁( ▁void ▁* ▁) ▁* ▁num _ alloc ▁) ▁; ▁if ▁( ▁tmp data ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁st ▁-> ▁data ▁= ▁tmp data ▁; ▁st ▁-> ▁num _ alloc ▁= ▁num _ alloc ▁; ▁return ▁1 ▁; ▁}	1
▁void ▁ff _ ace lp _ interpolate ▁( ▁int 16_ t ▁* ▁out ▁, ▁const ▁int 16_ t ▁* ▁in ▁, ▁const ▁int 16_ t ▁* ▁filter _ coeffs ▁, ▁int ▁precision ▁, ▁int ▁frac _ pos ▁, ▁int ▁filter _ length ▁, ▁int ▁length ▁) ▁{ ▁int ▁n ▁, ▁i ▁; ▁assert ▁( ▁frac _ pos ▁>= ▁0 ▁&& ▁frac _ pos ▁< ▁precision ▁) ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁length ▁; ▁n ▁++ ▁) ▁{ ▁int ▁idx ▁= ▁0 ▁; ▁int ▁v ▁= ▁0 x 4000 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁filter _ length ▁; ▁) ▁{ ▁v ▁+= ▁in ▁[ ▁n ▁+ ▁i ▁] ▁* ▁filter _ coeffs ▁[ ▁idx ▁+ ▁frac _ pos ▁] ▁; ▁idx ▁+= ▁precision ▁; ▁i ▁++ ▁; ▁v ▁+= ▁in ▁[ ▁n ▁- ▁i ▁] ▁* ▁filter _ coeffs ▁[ ▁idx ▁- ▁frac _ pos ▁] ▁; ▁} ▁if ▁( ▁av _ clip _ int 16 ▁( ▁v ▁>> ▁15 ▁) ▁!= ▁( ▁v ▁>> ▁15 ▁) ▁) ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" overflow that w ould need clip ing in ff _ ace lp _ interpolate ()\ n " ▁) ▁; ▁out ▁[ ▁n ▁] ▁= ▁v ▁>> ▁15 ▁; ▁} ▁}	1
▁static ▁int ▁decode _ low delay ▁( ▁Dir ac Context ▁* ▁s ▁) ▁{ ▁AVCodecContext ▁* ▁avctx ▁= ▁s ▁-> ▁avctx ▁; ▁int ▁slice _ x ▁, ▁slice _ y ▁, ▁bytes ▁, ▁bufsize ▁; ▁const ▁uint 8_ t ▁* ▁buf ▁; ▁struct ▁low delay _ slice ▁* ▁slices ▁; ▁int ▁slice _ num ▁= ▁0 ▁; ▁slices ▁= ▁av _ malloc z _ array ▁( ▁s ▁-> ▁low delay ▁. ▁num _ x ▁, ▁s ▁-> ▁low delay ▁. ▁num _ y ▁* ▁sizeof ▁( ▁struct ▁low delay _ slice ▁) ▁) ▁; ▁if ▁( ▁! ▁slices ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁align _ get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁buf ▁= ▁s ▁-> ▁gb ▁. ▁buffer ▁+ ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁/ ▁8 ▁; ▁bufsize ▁= ▁get _ bits _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁for ▁( ▁slice _ y ▁= ▁0 ▁; ▁bufsize ▁> ▁0 ▁&& ▁slice _ y ▁< ▁s ▁-> ▁low delay ▁. ▁num _ y ▁; ▁slice _ y ▁++ ▁) ▁for ▁( ▁slice _ x ▁= ▁0 ▁; ▁bufsize ▁> ▁0 ▁&& ▁slice _ x ▁< ▁s ▁-> ▁low delay ▁. ▁num _ x ▁; ▁slice _ x ▁++ ▁) ▁{ ▁bytes ▁= ▁( ▁slice _ num ▁+ ▁1 ▁) ▁* ▁s ▁-> ▁low delay ▁. ▁bytes ▁. ▁num ▁/ ▁s ▁-> ▁low delay ▁. ▁bytes ▁. ▁den ▁- ▁slice _ num ▁* ▁s ▁-> ▁low delay ▁. ▁bytes ▁. ▁num ▁/ ▁s ▁-> ▁low delay ▁. ▁bytes ▁. ▁den ▁; ▁slices ▁[ ▁slice _ num ▁] ▁. ▁bytes ▁= ▁bytes ▁; ▁slices ▁[ ▁slice _ num ▁] ▁. ▁slice _ x ▁= ▁slice _ x ▁; ▁slices ▁[ ▁slice _ num ▁] ▁. ▁slice _ y ▁= ▁slice _ y ▁; ▁init _ get _ bits ▁( ▁& ▁slices ▁[ ▁slice _ num ▁] ▁. ▁gb ▁, ▁buf ▁, ▁bufsize ▁) ▁; ▁slice _ num ▁++ ▁; ▁buf ▁+= ▁bytes ▁; ▁bufsize ▁-= ▁bytes ▁* ▁8 ▁; ▁} ▁avctx ▁-> ▁execute ▁( ▁avctx ▁, ▁decode _ low delay _ slice ▁, ▁slices ▁, ▁NULL ▁, ▁slice _ num ▁, ▁sizeof ▁( ▁struct ▁low delay _ slice ▁) ▁) ▁; ▁in tra _ dc _ pred iction ▁( ▁& ▁s ▁-> ▁plane ▁[ ▁0 ▁] ▁. ▁band ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁in tra _ dc _ pred iction ▁( ▁& ▁s ▁-> ▁plane ▁[ ▁1 ▁] ▁. ▁band ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁in tra _ dc _ pred iction ▁( ▁& ▁s ▁-> ▁plane ▁[ ▁2 ▁] ▁. ▁band ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁av _ free ▁( ▁slices ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁mov _ read _ tr un ▁( ▁MOV Context ▁* ▁c ▁, ▁AVIO Context ▁* ▁pb ▁, ▁MOV Atom ▁atom ▁) ▁{ ▁MOV Fragment ▁* ▁frag ▁= ▁& ▁c ▁-> ▁fragment ▁; ▁AVStream ▁* ▁st ▁= ▁NULL ▁; ▁MOV Stream Context ▁* ▁sc ▁; ▁MOV St ts ▁* ▁c tt s _ data ▁; ▁uint 64_ t ▁offset ▁; ▁int 64_ t ▁dts ▁; ▁int ▁data _ offset ▁= ▁0 ▁; ▁unsigned ▁entries ▁, ▁first _ sample _ flags ▁= ▁frag ▁-> ▁flags ▁; ▁int ▁flags ▁, ▁distance ▁, ▁i ▁, ▁found _ key frame ▁= ▁0 ▁, ▁err ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁fc ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁c ▁-> ▁fc ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁id ▁== ▁frag ▁-> ▁track _ id ▁) ▁{ ▁st ▁= ▁c ▁-> ▁fc ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁st ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" could not find cor respon ding track id % d \ n " ▁, ▁frag ▁-> ▁track _ id ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁sc ▁= ▁st ▁-> ▁priv _ data ▁; ▁if ▁( ▁sc ▁-> ▁pseudo _ stream _ id ▁+ ▁1 ▁!= ▁frag ▁-> ▁st sd _ id ▁&& ▁sc ▁-> ▁pseudo _ stream _ id ▁!= ▁-1 ▁) ▁return ▁0 ▁; ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁flags ▁= ▁avio _ rb 24 ▁( ▁pb ▁) ▁; ▁entries ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" flags 0 x % x entries % d \ n " ▁, ▁flags ▁, ▁entries ▁) ▁; ▁if ▁( ▁! ▁sc ▁-> ▁c tt s _ count ▁&& ▁sc ▁-> ▁sample _ count ▁) ▁{ ▁c tt s _ data ▁= ▁av _ realloc ▁( ▁NULL ▁, ▁sizeof ▁( ▁* ▁sc ▁-> ▁c tt s _ data ▁) ▁) ▁; ▁if ▁( ▁! ▁c tt s _ data ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁sc ▁-> ▁c tt s _ data ▁= ▁c tt s _ data ▁; ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ count ▁] ▁. ▁count ▁= ▁sc ▁-> ▁sample _ count ▁; ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ count ▁] ▁. ▁duration ▁= ▁0 ▁; ▁sc ▁-> ▁c tt s _ count ▁++ ▁; ▁} ▁if ▁( ▁( ▁uint 64_ t ▁) ▁entries ▁+ ▁sc ▁-> ▁c tt s _ count ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁* ▁sc ▁-> ▁c tt s _ data ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁( ▁err ▁= ▁av _ realloc p _ array ▁( ▁& ▁sc ▁-> ▁c tt s _ data ▁, ▁entries ▁+ ▁sc ▁-> ▁c tt s _ count ▁, ▁sizeof ▁( ▁* ▁sc ▁-> ▁c tt s _ data ▁) ▁) ▁) ▁< ▁0 ▁) ▁{ ▁sc ▁-> ▁c tt s _ count ▁= ▁0 ▁; ▁return ▁err ▁; ▁} ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ DATA _ OFFSET ▁) ▁data _ offset ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ FIRST _ SAMPLE _ FLAGS ▁) ▁first _ sample _ flags ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁dts ▁= ▁sc ▁-> ▁track _ end ▁- ▁sc ▁-> ▁time _ offset ▁; ▁offset ▁= ▁frag ▁-> ▁base _ data _ offset ▁+ ▁data _ offset ▁; ▁distance ▁= ▁0 ▁; ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" first sample flags 0 x % x \ n " ▁, ▁first _ sample _ flags ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁entries ▁&& ▁! ▁pb ▁-> ▁eof _ reached ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁sample _ size ▁= ▁frag ▁-> ▁size ▁; ▁int ▁sample _ flags ▁= ▁i ▁? ▁frag ▁-> ▁flags ▁: ▁first _ sample _ flags ▁; ▁unsigned ▁sample _ duration ▁= ▁frag ▁-> ▁duration ▁; ▁int ▁keyframe ▁= ▁0 ▁; ▁int ▁sample _ cts ▁= ▁0 ▁; ▁int 64_ t ▁cts ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ DURATION ▁) ▁sample _ duration ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ SIZE ▁) ▁sample _ size ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ FLAGS ▁) ▁sample _ flags ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ CTS ▁) ▁sample _ cts ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ count ▁] ▁. ▁count ▁= ▁1 ▁; ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ count ▁] ▁. ▁duration ▁= ▁sample _ cts ▁; ▁mov _ update _ dts _ shift ▁( ▁sc ▁, ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ count ▁] ▁. ▁duration ▁) ▁; ▁if ▁( ▁frag ▁-> ▁time ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁if ▁( ▁c ▁-> ▁use _ mf ra _ for ▁== ▁FF _ MOV _ FLAG _ M FR A _ PT S ▁) ▁{ ▁int 64_ t ▁pts ▁= ▁frag ▁-> ▁time ▁; ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ DEBUG ▁, ▁" found frag time %" ▁PRId 64 ▁" sc -> dts _ shift % dct ts . duration % d " ▁" sc -> time _ offset %" ▁PRId 64 ▁" flags & MOV _ TR UN _ SAMPLE _ CTS % d \ n " ▁, ▁pts ▁, ▁sc ▁-> ▁dts _ shift ▁, ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ count ▁] ▁. ▁duration ▁, ▁sc ▁-> ▁time _ offset ▁, ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ CTS ▁) ▁; ▁dts ▁= ▁pts ▁- ▁sc ▁-> ▁dts _ shift ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ CTS ▁) ▁{ ▁dts ▁-= ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ count ▁] ▁. ▁duration ▁; ▁} ▁else ▁{ ▁dts ▁-= ▁sc ▁-> ▁time _ offset ▁; ▁} ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ DEBUG ▁, ▁" calc ulated int od ts %" ▁PRId 64 ▁"\ n " ▁, ▁dts ▁) ▁; ▁} ▁else ▁{ ▁dts ▁= ▁frag ▁-> ▁time ▁; ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ DEBUG ▁, ▁" found frag time %" ▁PRId 64 ▁", using it ford ts \ n " ▁, ▁dts ▁) ▁; ▁} ▁frag ▁-> ▁time ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁cts ▁= ▁dts ▁+ ▁sample _ cts ▁; ▁sc ▁-> ▁c tt s _ count ▁++ ▁; ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁keyframe ▁= ▁1 ▁; ▁else ▁if ▁( ▁! ▁found _ key frame ▁) ▁keyframe ▁= ▁found _ key frame ▁= ▁! ▁( ▁sample _ flags ▁& ▁( ▁MOV _ FRAG _ SAMPLE _ FLAG _ IS _ NON _ SYNC ▁| ▁MOV _ FRAG _ SAMPLE _ FLAG _ DEPEND S _ YES ▁) ▁) ▁; ▁if ▁( ▁keyframe ▁) ▁distance ▁= ▁0 ▁; ▁err ▁= ▁av _ add _ index _ entry ▁( ▁st ▁, ▁offset ▁, ▁INT 64_ MAX ▁/ ▁2 ▁, ▁sample _ size ▁, ▁distance ▁, ▁keyframe ▁? ▁AV INDEX _ KEY FRAME ▁: ▁0 ▁) ▁; ▁if ▁( ▁err ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" Failed to add index entry \ n " ▁) ▁; ▁} ▁else ▁st ▁-> ▁index _ entries ▁[ ▁st ▁-> ▁nb _ index _ entries ▁- ▁1 ▁] ▁. ▁timestamp ▁= ▁cts ▁; ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" AV Index stream % d , sample % d , offset %" ▁PRIx 64 ▁", cts %" ▁PRId 64 ▁"," ▁" size % d , distance % d , key frame % d \ n " ▁, ▁st ▁-> ▁index ▁, ▁sc ▁-> ▁sample _ count ▁+ ▁i ▁, ▁offset ▁, ▁cts ▁, ▁sample _ size ▁, ▁distance ▁, ▁keyframe ▁) ▁; ▁distance ▁++ ▁; ▁dts ▁+= ▁sample _ duration ▁; ▁offset ▁+= ▁sample _ size ▁; ▁sc ▁-> ▁data _ size ▁+= ▁sample _ size ▁; ▁sc ▁-> ▁duration _ for _ fps ▁+= ▁sample _ duration ▁; ▁sc ▁-> ▁nb _ frames _ for _ fps ▁++ ▁; ▁} ▁if ▁( ▁pb ▁-> ▁eof _ reached ▁) ▁return ▁AVERROR _ EOF ▁; ▁frag ▁-> ▁implicit _ offset ▁= ▁offset ▁; ▁st ▁-> ▁duration ▁= ▁sc ▁-> ▁track _ end ▁= ▁dts ▁+ ▁sc ▁-> ▁time _ offset ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁memp acket _ test _ new ▁( ▁BIO ▁* ▁bio ▁) ▁{ ▁ME MP ACKET _ TEST _ CTX ▁* ▁ctx ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁ctx ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁ctx ▁) ▁) ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁ctx ▁-> ▁pkts ▁= ▁sk _ ME MP ACKET _ new _ null ▁( ▁) ▁) ▁) ▁{ ▁OPENSSL _ free ▁( ▁ctx ▁) ▁; ▁return ▁0 ▁; ▁} ▁ctx ▁-> ▁dro pe poch ▁= ▁0 ▁; ▁ctx ▁-> ▁dro prec ▁= ▁-1 ▁; ▁BIO _ set _ init ▁( ▁bio ▁, ▁1 ▁) ▁; ▁BIO _ set _ data ▁( ▁bio ▁, ▁ctx ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁decode _ frame _ mp 3 on 4 ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame _ ptr ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁MP 3 On 4 Decode Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁M PA Decode Context ▁* ▁m ▁; ▁int ▁fsize ▁, ▁len ▁= ▁buf _ size ▁, ▁out _ size ▁= ▁0 ▁; ▁uint 32_ t ▁header ▁; ▁OUT _ INT ▁* ▁out _ samples ▁; ▁OUT _ INT ▁* ▁outptr ▁, ▁* ▁bp ▁; ▁int ▁fr ▁, ▁j ▁, ▁n ▁, ▁ch ▁, ▁ret ▁; ▁s ▁-> ▁frame ▁-> ▁nb _ samples ▁= ▁M PA _ FRAME _ SIZE ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁s ▁-> ▁frame ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁out _ samples ▁= ▁( ▁OUT _ INT ▁* ▁) ▁s ▁-> ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁if ▁( ▁buf _ size ▁< ▁HEADER _ SIZE ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁outptr ▁= ▁s ▁-> ▁frames ▁== ▁1 ▁? ▁out _ samples ▁: ▁s ▁-> ▁decoded _ buf ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁0 ▁; ▁ch ▁= ▁0 ▁; ▁for ▁( ▁fr ▁= ▁0 ▁; ▁fr ▁< ▁s ▁-> ▁frames ▁; ▁fr ▁++ ▁) ▁{ ▁fsize ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁>> ▁4 ▁; ▁fsize ▁= ▁FF MIN 3 ▁( ▁fsize ▁, ▁len ▁, ▁M PA _ MAX _ CODED _ FRAME _ SIZE ▁) ▁; ▁m ▁= ▁s ▁-> ▁mp 3 dec ctx ▁[ ▁fr ▁] ▁; ▁assert ▁( ▁m ▁!= ▁NULL ▁) ▁; ▁if ▁( ▁fsize ▁< ▁HEADER _ SIZE ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Frames izes m aller than headers ize \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁header ▁= ▁( ▁AV _ RB 32 ▁( ▁buf ▁) ▁& ▁0 x 000 fffff ▁) ▁| ▁s ▁-> ▁sync word ▁; ▁if ▁( ▁ff _ mp a _ check _ header ▁( ▁header ▁) ▁< ▁0 ▁) ▁break ▁; ▁avpriv _ mpe ga udio _ decode _ header ▁( ▁( ▁M PA Decode Header ▁* ▁) ▁m ▁, ▁header ▁) ▁; ▁if ▁( ▁ch ▁+ ▁m ▁-> ▁nb _ channels ▁> ▁avctx ▁-> ▁channels ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" frame channel co un te xce eds codec " ▁" channel count \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ch ▁+= ▁m ▁-> ▁nb _ channels ▁; ▁out _ size ▁+= ▁mp _ decode _ frame ▁( ▁m ▁, ▁outptr ▁, ▁buf ▁, ▁fsize ▁) ▁; ▁buf ▁+= ▁fsize ▁; ▁len ▁-= ▁fsize ▁; ▁if ▁( ▁s ▁-> ▁frames ▁> ▁1 ▁) ▁{ ▁n ▁= ▁m ▁-> ▁avctx ▁-> ▁frame _ size ▁* ▁m ▁-> ▁nb _ channels ▁; ▁bp ▁= ▁out _ samples ▁+ ▁s ▁-> ▁coff ▁[ ▁fr ▁] ▁; ▁if ▁( ▁m ▁-> ▁nb _ channels ▁== ▁1 ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁* ▁bp ▁= ▁s ▁-> ▁decoded _ buf ▁[ ▁j ▁] ▁; ▁bp ▁+= ▁avctx ▁-> ▁channels ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁bp ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁decoded _ buf ▁[ ▁j ▁++ ▁] ▁; ▁bp ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁decoded _ buf ▁[ ▁j ▁] ▁; ▁bp ▁+= ▁avctx ▁-> ▁channels ▁; ▁} ▁} ▁} ▁avctx ▁-> ▁bit _ rate ▁+= ▁m ▁-> ▁bit _ rate ▁; ▁} ▁avctx ▁-> ▁sample _ rate ▁= ▁s ▁-> ▁mp 3 dec ctx ▁[ ▁0 ▁] ▁-> ▁sample _ rate ▁; ▁s ▁-> ▁frame ▁-> ▁nb _ samples ▁= ▁out _ size ▁/ ▁( ▁avctx ▁-> ▁channels ▁* ▁sizeof ▁( ▁OUT _ INT ▁) ▁) ▁; ▁* ▁got _ frame _ ptr ▁= ▁1 ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁* ▁s ▁-> ▁frame ▁; ▁return ▁buf _ size ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁filter _ mb _ row ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁t data ▁, ▁int ▁job nr ▁, ▁int ▁thread nr ▁, ▁int ▁is _ vp 7 ▁) ▁{ ▁VP 8 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁VP 8 Thread Data ▁* ▁td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁thread nr ▁] ▁; ▁int ▁mb _ x ▁, ▁mb _ y ▁= ▁atomic _ load ▁( ▁& ▁td ▁-> ▁thread _ mb _ pos ▁) ▁>> ▁16 ▁, ▁num _ jobs ▁= ▁s ▁-> ▁num _ jobs ▁; ▁AVFrame ▁* ▁cur frame ▁= ▁s ▁-> ▁cur frame ▁-> ▁tf ▁. ▁f ▁; ▁VP 8 Macro block ▁* ▁mb ▁; ▁VP 8 Thread Data ▁* ▁prev _ td ▁, ▁* ▁next _ td ▁; ▁uint 8_ t ▁* ▁dst ▁[ ▁3 ▁] ▁= ▁{ ▁cur frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁16 ▁* ▁mb _ y ▁* ▁s ▁-> ▁linesize ▁, ▁cur frame ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁, ▁cur frame ▁-> ▁data ▁[ ▁2 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁} ▁; ▁if ▁( ▁s ▁-> ▁mb _ layout ▁== ▁1 ▁) ▁mb ▁= ▁s ▁-> ▁macro blocks _ base ▁+ ▁( ▁( ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁* ▁( ▁mb _ y ▁+ ▁1 ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mb ▁= ▁s ▁-> ▁macro blocks ▁+ ▁( ▁s ▁-> ▁mb _ height ▁- ▁mb _ y ▁- ▁1 ▁) ▁* ▁2 ▁; ▁if ▁( ▁mb _ y ▁== ▁0 ▁) ▁prev _ td ▁= ▁td ▁; ▁else ▁prev _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁num _ jobs ▁- ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁if ▁( ▁mb _ y ▁== ▁s ▁-> ▁mb _ height ▁- ▁1 ▁) ▁next _ td ▁= ▁td ▁; ▁else ▁next _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁mb _ x ▁++ ▁, ▁mb ▁++ ▁) ▁{ ▁VP 8 Filter Strength ▁* ▁f ▁= ▁& ▁td ▁-> ▁filter _ strength ▁[ ▁mb _ x ▁] ▁; ▁if ▁( ▁prev _ td ▁!= ▁td ▁) ▁check _ thread _ pos ▁( ▁td ▁, ▁prev _ td ▁, ▁( ▁mb _ x ▁+ ▁1 ▁) ▁+ ▁( ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁) ▁, ▁mb _ y ▁- ▁1 ▁) ▁; ▁if ▁( ▁next _ td ▁!= ▁td ▁) ▁if ▁( ▁next _ td ▁!= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁0 ▁] ▁) ▁check _ thread _ pos ▁( ▁td ▁, ▁next _ td ▁, ▁mb _ x ▁+ ▁1 ▁, ▁mb _ y ▁+ ▁1 ▁) ▁; ▁if ▁( ▁num _ jobs ▁== ▁1 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁filter ▁. ▁simple ▁) ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁NULL ▁, ▁NULL ▁, ▁s ▁-> ▁linesize ▁, ▁0 ▁, ▁1 ▁) ▁; ▁else ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁dst ▁[ ▁1 ▁] ▁, ▁dst ▁[ ▁2 ▁] ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁uv lines ize ▁, ▁0 ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁filter ▁. ▁simple ▁) ▁filter _ mb _ simple ▁( ▁s ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁f ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁else ▁filter _ mb ▁( ▁s ▁, ▁dst ▁, ▁f ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁is _ vp 7 ▁) ▁; ▁dst ▁[ ▁0 ▁] ▁+= ▁16 ▁; ▁dst ▁[ ▁1 ▁] ▁+= ▁8 ▁; ▁dst ▁[ ▁2 ▁] ▁+= ▁8 ▁; ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁( ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁) ▁+ ▁mb _ x ▁) ▁; ▁} ▁}	0
▁char ▁* ▁lh _ delete ▁( ▁L HASH ▁* ▁lh ▁, ▁char ▁* ▁data ▁) ▁{ ▁unsigned ▁long ▁hash ▁; ▁L HASH _ NODE ▁* ▁nn ▁, ▁* ▁* ▁rn ▁; ▁char ▁* ▁ret ▁; ▁lh ▁-> ▁error ▁= ▁0 ▁; ▁rn ▁= ▁get rn ▁( ▁lh ▁, ▁data ▁, ▁& ▁hash ▁) ▁; ▁if ▁( ▁* ▁rn ▁== ▁NULL ▁) ▁{ ▁lh ▁-> ▁num _ no _ delete ▁++ ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁else ▁{ ▁nn ▁= ▁* ▁rn ▁; ▁* ▁rn ▁= ▁nn ▁-> ▁next ▁; ▁ret ▁= ▁nn ▁-> ▁data ▁; ▁Free ▁( ▁( ▁char ▁* ▁) ▁nn ▁) ▁; ▁lh ▁-> ▁num _ delete ▁++ ▁; ▁} ▁lh ▁-> ▁num _ items ▁-- ▁; ▁if ▁( ▁( ▁lh ▁-> ▁num _ nodes ▁> ▁MIN _ NODES ▁) ▁&& ▁( ▁lh ▁-> ▁down _ load ▁>= ▁( ▁lh ▁-> ▁num _ items ▁* ▁L H _ LOAD _ MULT ▁/ ▁lh ▁-> ▁num _ nodes ▁) ▁) ▁) ▁contract ▁( ▁lh ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁static ▁int ▁mov _ read _ tr un ▁( ▁MOV Context ▁* ▁c ▁, ▁AVIO Context ▁* ▁pb ▁, ▁MOV Atom ▁atom ▁) ▁{ ▁MOV Fragment ▁* ▁frag ▁= ▁& ▁c ▁-> ▁fragment ▁; ▁AVStream ▁* ▁st ▁= ▁NULL ▁; ▁MOV Stream Context ▁* ▁sc ▁; ▁MOV St ts ▁* ▁c tt s _ data ▁; ▁uint 64_ t ▁offset ▁; ▁int 64_ t ▁dts ▁; ▁int ▁data _ offset ▁= ▁0 ▁; ▁unsigned ▁entries ▁, ▁first _ sample _ flags ▁= ▁frag ▁-> ▁flags ▁; ▁int ▁flags ▁, ▁distance ▁, ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁fc ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁c ▁-> ▁fc ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁id ▁== ▁frag ▁-> ▁track _ id ▁) ▁{ ▁st ▁= ▁c ▁-> ▁fc ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁st ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" could not find cor respon ding track id % u \ n " ▁, ▁frag ▁-> ▁track _ id ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁sc ▁= ▁st ▁-> ▁priv _ data ▁; ▁if ▁( ▁sc ▁-> ▁pseudo _ stream _ id ▁+ ▁1 ▁!= ▁frag ▁-> ▁st sd _ id ▁&& ▁sc ▁-> ▁pseudo _ stream _ id ▁!= ▁-1 ▁) ▁return ▁0 ▁; ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁flags ▁= ▁avio _ rb 24 ▁( ▁pb ▁) ▁; ▁entries ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ TRACE ▁, ▁" flags 0 x % x entries % u \ n " ▁, ▁flags ▁, ▁entries ▁) ▁; ▁if ▁( ▁( ▁uint 64_ t ▁) ▁entries ▁+ ▁sc ▁-> ▁c tt s _ count ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁* ▁sc ▁-> ▁c tt s _ data ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ DATA _ OFFSET ▁) ▁data _ offset ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ FIRST _ SAMPLE _ FLAGS ▁) ▁first _ sample _ flags ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁dts ▁= ▁sc ▁-> ▁track _ end ▁- ▁sc ▁-> ▁time _ offset ▁; ▁offset ▁= ▁frag ▁-> ▁base _ data _ offset ▁+ ▁data _ offset ▁; ▁distance ▁= ▁0 ▁; ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ TRACE ▁, ▁" first sample flags 0 x % x \ n " ▁, ▁first _ sample _ flags ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁entries ▁&& ▁! ▁pb ▁-> ▁eof _ reached ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁sample _ size ▁= ▁frag ▁-> ▁size ▁; ▁int ▁sample _ flags ▁= ▁i ▁? ▁frag ▁-> ▁flags ▁: ▁first _ sample _ flags ▁; ▁unsigned ▁sample _ duration ▁= ▁frag ▁-> ▁duration ▁; ▁unsigned ▁c tt s _ duration ▁= ▁0 ▁; ▁int ▁keyframe ▁= ▁0 ▁; ▁int ▁c tt s _ index ▁= ▁0 ▁; ▁int ▁old _ nb _ index _ entries ▁= ▁st ▁-> ▁nb _ index _ entries ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ DURATION ▁) ▁sample _ duration ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ SIZE ▁) ▁sample _ size ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ FLAGS ▁) ▁sample _ flags ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ CTS ▁) ▁c tt s _ duration ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁mov _ update _ dts _ shift ▁( ▁sc ▁, ▁c tt s _ duration ▁) ▁; ▁if ▁( ▁frag ▁-> ▁time ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁if ▁( ▁c ▁-> ▁use _ mf ra _ for ▁== ▁FF _ MOV _ FLAG _ M FR A _ PT S ▁) ▁{ ▁int 64_ t ▁pts ▁= ▁frag ▁-> ▁time ▁; ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ DEBUG ▁, ▁" found frag time %" ▁PRId 64 ▁" sc -> dts _ shift % dct ts . duration % d " ▁" sc -> time _ offset %" ▁PRId 64 ▁" flags & MOV _ TR UN _ SAMPLE _ CTS % d \ n " ▁, ▁pts ▁, ▁sc ▁-> ▁dts _ shift ▁, ▁c tt s _ duration ▁, ▁sc ▁-> ▁time _ offset ▁, ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ CTS ▁) ▁; ▁dts ▁= ▁pts ▁- ▁sc ▁-> ▁dts _ shift ▁; ▁if ▁( ▁flags ▁& ▁MOV _ TR UN _ SAMPLE _ CTS ▁) ▁{ ▁dts ▁-= ▁c tt s _ duration ▁; ▁} ▁else ▁{ ▁dts ▁-= ▁sc ▁-> ▁time _ offset ▁; ▁} ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ DEBUG ▁, ▁" calc ulated int od ts %" ▁PRId 64 ▁"\ n " ▁, ▁dts ▁) ▁; ▁} ▁else ▁{ ▁dts ▁= ▁frag ▁-> ▁time ▁- ▁sc ▁-> ▁time _ offset ▁; ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ DEBUG ▁, ▁" found frag time %" ▁PRId 64 ▁", using it ford ts \ n " ▁, ▁dts ▁) ▁; ▁} ▁frag ▁-> ▁time ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁if ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁keyframe ▁= ▁1 ▁; ▁else ▁keyframe ▁= ▁! ▁( ▁sample _ flags ▁& ▁( ▁MOV _ FRAG _ SAMPLE _ FLAG _ IS _ NON _ SYNC ▁| ▁MOV _ FRAG _ SAMPLE _ FLAG _ DEPEND S _ YES ▁) ▁) ▁; ▁if ▁( ▁keyframe ▁) ▁distance ▁= ▁0 ▁; ▁c tt s _ index ▁= ▁av _ add _ index _ entry ▁( ▁st ▁, ▁offset ▁, ▁dts ▁, ▁sample _ size ▁, ▁distance ▁, ▁keyframe ▁? ▁AV INDEX _ KEY FRAME ▁: ▁0 ▁) ▁; ▁if ▁( ▁c tt s _ index ▁>= ▁0 ▁&& ▁old _ nb _ index _ entries ▁< ▁st ▁-> ▁nb _ index _ entries ▁) ▁{ ▁unsigned ▁int ▁size _ needed ▁= ▁st ▁-> ▁nb _ index _ entries ▁* ▁sizeof ▁( ▁* ▁sc ▁-> ▁c tt s _ data ▁) ▁; ▁unsigned ▁int ▁request _ size ▁= ▁size _ needed ▁> ▁sc ▁-> ▁c tt s _ allocated _ size ▁? ▁FF MAX ▁( ▁size _ needed ▁, ▁2 ▁* ▁sc ▁-> ▁c tt s _ allocated _ size ▁) ▁: ▁size _ needed ▁; ▁unsigned ▁int ▁old _ ct ts _ size ▁= ▁sc ▁-> ▁c tt s _ allocated _ size ▁; ▁c tt s _ data ▁= ▁av _ fast _ realloc ▁( ▁sc ▁-> ▁c tt s _ data ▁, ▁& ▁sc ▁-> ▁c tt s _ allocated _ size ▁, ▁request _ size ▁) ▁; ▁if ▁( ▁! ▁c tt s _ data ▁) ▁{ ▁av _ freep ▁( ▁& ▁sc ▁-> ▁c tt s _ data ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁sc ▁-> ▁c tt s _ data ▁= ▁c tt s _ data ▁; ▁memset ▁( ▁( ▁uint 8_ t ▁* ▁) ▁( ▁sc ▁-> ▁c tt s _ data ▁) ▁+ ▁old _ ct ts _ size ▁, ▁0 ▁, ▁sc ▁-> ▁c tt s _ allocated _ size ▁- ▁old _ ct ts _ size ▁) ▁; ▁if ▁( ▁c tt s _ index ▁!= ▁old _ nb _ index _ entries ▁) ▁{ ▁memmove ▁( ▁sc ▁-> ▁c tt s _ data ▁+ ▁c tt s _ index ▁+ ▁1 ▁, ▁sc ▁-> ▁c tt s _ data ▁+ ▁c tt s _ index ▁, ▁sizeof ▁( ▁* ▁sc ▁-> ▁c tt s _ data ▁) ▁* ▁( ▁sc ▁-> ▁c tt s _ count ▁- ▁c tt s _ index ▁) ▁) ▁; ▁if ▁( ▁c tt s _ index ▁<= ▁sc ▁-> ▁current _ sample ▁) ▁{ ▁sc ▁-> ▁current _ sample ▁++ ▁; ▁} ▁} ▁sc ▁-> ▁c tt s _ data ▁[ ▁c tt s _ index ▁] ▁. ▁count ▁= ▁1 ▁; ▁sc ▁-> ▁c tt s _ data ▁[ ▁c tt s _ index ▁] ▁. ▁duration ▁= ▁c tt s _ duration ▁; ▁sc ▁-> ▁c tt s _ count ▁++ ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" Failed to add index entry \ n " ▁) ▁; ▁} ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ TRACE ▁, ▁" AV Index stream % d , sample % d , offset %" ▁PRIx 64 ▁", dts %" ▁PRId 64 ▁"," ▁" size % u , distance % d , key frame % d \ n " ▁, ▁st ▁-> ▁index ▁, ▁c tt s _ index ▁, ▁offset ▁, ▁dts ▁, ▁sample _ size ▁, ▁distance ▁, ▁keyframe ▁) ▁; ▁distance ▁++ ▁; ▁dts ▁+= ▁sample _ duration ▁; ▁offset ▁+= ▁sample _ size ▁; ▁sc ▁-> ▁data _ size ▁+= ▁sample _ size ▁; ▁sc ▁-> ▁duration _ for _ fps ▁+= ▁sample _ duration ▁; ▁sc ▁-> ▁nb _ frames _ for _ fps ▁++ ▁; ▁} ▁if ▁( ▁pb ▁-> ▁eof _ reached ▁) ▁return ▁AVERROR _ EOF ▁; ▁frag ▁-> ▁implicit _ offset ▁= ▁offset ▁; ▁sc ▁-> ▁track _ end ▁= ▁dts ▁+ ▁sc ▁-> ▁time _ offset ▁; ▁if ▁( ▁st ▁-> ▁duration ▁< ▁sc ▁-> ▁track _ end ▁) ▁st ▁-> ▁duration ▁= ▁sc ▁-> ▁track _ end ▁; ▁return ▁0 ▁; ▁}	0
▁void ▁OPENSSL _ L H _ free ▁( ▁OPENSSL _ L HASH ▁* ▁lh ▁) ▁{ ▁unsigned ▁int ▁i ▁; ▁OPENSSL _ L H _ NODE ▁* ▁n ▁, ▁* ▁nn ▁; ▁if ▁( ▁lh ▁== ▁NULL ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁lh ▁-> ▁num _ nodes ▁; ▁i ▁++ ▁) ▁{ ▁n ▁= ▁lh ▁-> ▁b ▁[ ▁i ▁] ▁; ▁while ▁( ▁n ▁!= ▁NULL ▁) ▁{ ▁nn ▁= ▁n ▁-> ▁next ▁; ▁OPENSSL _ free ▁( ▁n ▁) ▁; ▁n ▁= ▁nn ▁; ▁} ▁} ▁OPENSSL _ free ▁( ▁lh ▁-> ▁b ▁) ▁; ▁OPENSSL _ free ▁( ▁lh ▁) ▁; ▁}	1
▁AV Res ample Context ▁* ▁sw r _ res ample _ init ▁( ▁AV Res ample Context ▁* ▁c ▁, ▁int ▁out _ rate ▁, ▁int ▁in _ rate ▁, ▁int ▁filter _ size ▁, ▁int ▁phase _ shift ▁, ▁int ▁linear ▁, ▁double ▁cutoff ▁) ▁{ ▁double ▁factor ▁= ▁FF MIN ▁( ▁out _ rate ▁* ▁cutoff ▁/ ▁in _ rate ▁, ▁1.0 ▁) ▁; ▁int ▁phase _ count ▁= ▁1 ▁<< ▁phase _ shift ▁; ▁if ▁( ▁! ▁c ▁|| ▁c ▁-> ▁phase _ shift ▁!= ▁phase _ shift ▁|| ▁c ▁-> ▁linear ▁!= ▁linear ▁|| ▁c ▁-> ▁factor ▁!= ▁factor ▁|| ▁c ▁-> ▁filter _ length ▁!= ▁FF MAX ▁( ▁( ▁int ▁) ▁ceil ▁( ▁filter _ size ▁/ ▁factor ▁) ▁, ▁1 ▁) ▁) ▁{ ▁c ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AV Res ample Context ▁) ▁) ▁; ▁if ▁( ▁! ▁c ▁) ▁return ▁NULL ▁; ▁c ▁-> ▁phase _ shift ▁= ▁phase _ shift ▁; ▁c ▁-> ▁phase _ mask ▁= ▁phase _ count ▁- ▁1 ▁; ▁c ▁-> ▁linear ▁= ▁linear ▁; ▁c ▁-> ▁factor ▁= ▁factor ▁; ▁c ▁-> ▁filter _ length ▁= ▁FF MAX ▁( ▁( ▁int ▁) ▁ceil ▁( ▁filter _ size ▁/ ▁factor ▁) ▁, ▁1 ▁) ▁; ▁c ▁-> ▁filter _ bank ▁= ▁av _ malloc z ▁( ▁c ▁-> ▁filter _ length ▁* ▁( ▁phase _ count ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁F ELEM ▁) ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁filter _ bank ▁) ▁goto ▁error ▁; ▁if ▁( ▁build _ filter ▁( ▁c ▁-> ▁filter _ bank ▁, ▁factor ▁, ▁c ▁-> ▁filter _ length ▁, ▁phase _ count ▁, ▁1 ▁<< ▁FILTER _ SHIFT ▁, ▁WINDOW _ TYPE ▁) ▁) ▁goto ▁error ▁; ▁memcpy ▁( ▁& ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁* ▁phase _ count ▁+ ▁1 ▁] ▁, ▁c ▁-> ▁filter _ bank ▁, ▁( ▁c ▁-> ▁filter _ length ▁- ▁1 ▁) ▁* ▁sizeof ▁( ▁F ELEM ▁) ▁) ▁; ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁* ▁phase _ count ▁] ▁= ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁- ▁1 ▁] ▁; ▁} ▁c ▁-> ▁comp ensation _ distance ▁= ▁0 ▁; ▁if ▁( ▁! ▁av _ reduce ▁( ▁& ▁c ▁-> ▁src _ incr ▁, ▁& ▁c ▁-> ▁dst _ incr ▁, ▁out _ rate ▁, ▁in _ rate ▁* ▁( ▁int 64_ t ▁) ▁phase _ count ▁, ▁INT 32_ MAX ▁/ ▁2 ▁) ▁) ▁goto ▁error ▁; ▁c ▁-> ▁ideal _ dst _ incr ▁= ▁c ▁-> ▁dst _ incr ▁; ▁c ▁-> ▁index ▁= ▁- ▁phase _ count ▁* ▁( ▁( ▁c ▁-> ▁filter _ length ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁c ▁-> ▁frac ▁= ▁0 ▁; ▁return ▁c ▁; ▁error ▁: ▁av _ free ▁( ▁c ▁-> ▁filter _ bank ▁) ▁; ▁av _ free ▁( ▁c ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁config _ output ▁( ▁AVFilter Link ▁* ▁out link ▁) ▁{ ▁out link ▁-> ▁flags ▁|= ▁FF _ LINK _ FLAG _ REQUEST _ LOOP ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁ff m _ seek ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁stream _ index ▁, ▁int 64_ t ▁wanted _ pts ▁, ▁int ▁flags ▁) ▁{ ▁FF M Context ▁* ▁ff m ▁= ▁s ▁-> ▁priv _ data ▁; ▁int 64_ t ▁pos _ min ▁, ▁pos _ max ▁, ▁pos ▁; ▁int 64_ t ▁pts _ min ▁, ▁pts _ max ▁, ▁pts ▁; ▁double ▁pos 1 ▁; ▁av _ d log ▁( ▁s ▁, ▁" w anted _ pts =% 0. 6 f \ n " ▁, ▁wanted _ pts ▁/ ▁1000000.0 ▁) ▁; ▁if ▁( ▁ff m ▁-> ▁write _ index ▁&& ▁ff m ▁-> ▁write _ index ▁< ▁ff m ▁-> ▁file _ size ▁) ▁{ ▁if ▁( ▁get _ dts ▁( ▁s ▁, ▁FF M _ PACKET _ SIZE ▁) ▁< ▁wanted _ pts ▁) ▁{ ▁pos _ min ▁= ▁FF M _ PACKET _ SIZE ▁; ▁pos _ max ▁= ▁ff m ▁-> ▁write _ index ▁- ▁FF M _ PACKET _ SIZE ▁; ▁} ▁else ▁{ ▁pos _ min ▁= ▁ff m ▁-> ▁write _ index ▁; ▁pos _ max ▁= ▁ff m ▁-> ▁file _ size ▁- ▁FF M _ PACKET _ SIZE ▁; ▁} ▁} ▁else ▁{ ▁pos _ min ▁= ▁FF M _ PACKET _ SIZE ▁; ▁pos _ max ▁= ▁ff m ▁-> ▁file _ size ▁- ▁FF M _ PACKET _ SIZE ▁; ▁} ▁while ▁( ▁pos _ min ▁<= ▁pos _ max ▁) ▁{ ▁pts _ min ▁= ▁get _ dts ▁( ▁s ▁, ▁pos _ min ▁) ▁; ▁pts _ max ▁= ▁get _ dts ▁( ▁s ▁, ▁pos _ max ▁) ▁; ▁if ▁( ▁pts _ min ▁> ▁wanted _ pts ▁|| ▁pts _ max ▁<= ▁wanted _ pts ▁) ▁{ ▁pos ▁= ▁pts _ min ▁> ▁wanted _ pts ▁? ▁pos _ min ▁: ▁pos _ max ▁; ▁goto ▁found ▁; ▁} ▁pos 1 ▁= ▁( ▁double ▁) ▁( ▁pos _ max ▁- ▁pos _ min ▁) ▁* ▁( ▁double ▁) ▁( ▁wanted _ pts ▁- ▁pts _ min ▁) ▁/ ▁( ▁double ▁) ▁( ▁pts _ max ▁- ▁pts _ min ▁) ▁; ▁pos ▁= ▁( ▁( ▁( ▁int 64_ t ▁) ▁pos 1 ▁) ▁/ ▁FF M _ PACKET _ SIZE ▁) ▁* ▁FF M _ PACKET _ SIZE ▁; ▁if ▁( ▁pos ▁<= ▁pos _ min ▁) ▁pos ▁= ▁pos _ min ▁; ▁else ▁if ▁( ▁pos ▁>= ▁pos _ max ▁) ▁pos ▁= ▁pos _ max ▁; ▁pts ▁= ▁get _ dts ▁( ▁s ▁, ▁pos ▁) ▁; ▁if ▁( ▁pts ▁== ▁wanted _ pts ▁) ▁{ ▁goto ▁found ▁; ▁} ▁else ▁if ▁( ▁pts ▁> ▁wanted _ pts ▁) ▁{ ▁pos _ max ▁= ▁pos ▁- ▁FF M _ PACKET _ SIZE ▁; ▁} ▁else ▁{ ▁pos _ min ▁= ▁pos ▁+ ▁FF M _ PACKET _ SIZE ▁; ▁} ▁} ▁pos ▁= ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁) ▁? ▁pos _ min ▁: ▁pos _ max ▁; ▁found ▁: ▁if ▁( ▁ff m _ seek 1 ▁( ▁s ▁, ▁pos ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁ff m ▁-> ▁read _ state ▁= ▁READ _ HEADER ▁; ▁ff m ▁-> ▁packet _ ptr ▁= ▁ff m ▁-> ▁packet ▁; ▁ff m ▁-> ▁packet _ end ▁= ▁ff m ▁-> ▁packet ▁; ▁ff m ▁-> ▁first _ packet ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁find _ image _ range ▁( ▁int ▁* ▁p first _ index ▁, ▁int ▁* ▁p last _ index ▁, ▁const ▁char ▁* ▁path ▁, ▁int ▁max _ start ▁) ▁{ ▁char ▁buf ▁[ ▁1024 ▁] ▁; ▁int ▁range ▁, ▁last _ index ▁, ▁range 1 ▁, ▁first _ index ▁; ▁for ▁( ▁first _ index ▁= ▁max _ start ▁; ▁first _ index ▁< ▁max _ start ▁+ ▁5 ▁; ▁first _ index ▁++ ▁) ▁{ ▁if ▁( ▁av _ get _ frame _ filename ▁( ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁, ▁path ▁, ▁first _ index ▁) ▁< ▁0 ▁) ▁{ ▁* ▁p first _ index ▁= ▁* ▁p last _ index ▁= ▁1 ▁; ▁if ▁( ▁avio _ check ▁( ▁buf ▁, ▁AVIO _ FLAG _ READ ▁) ▁> ▁0 ▁) ▁return ▁0 ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁avio _ check ▁( ▁buf ▁, ▁AVIO _ FLAG _ READ ▁) ▁> ▁0 ▁) ▁break ▁; ▁} ▁if ▁( ▁first _ index ▁== ▁5 ▁) ▁goto ▁fail ▁; ▁last _ index ▁= ▁first _ index ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁range ▁= ▁0 ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁! ▁range ▁) ▁range 1 ▁= ▁1 ▁; ▁else ▁range 1 ▁= ▁2 ▁* ▁range ▁; ▁if ▁( ▁av _ get _ frame _ filename ▁( ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁, ▁path ▁, ▁last _ index ▁+ ▁range 1 ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁if ▁( ▁avio _ check ▁( ▁buf ▁, ▁AVIO _ FLAG _ READ ▁) ▁<= ▁0 ▁) ▁break ▁; ▁range ▁= ▁range 1 ▁; ▁if ▁( ▁range ▁>= ▁( ▁1 ▁<< ▁30 ▁) ▁) ▁goto ▁fail ▁; ▁} ▁if ▁( ▁! ▁range ▁) ▁break ▁; ▁last _ index ▁+= ▁range ▁; ▁} ▁* ▁p first _ index ▁= ▁first _ index ▁; ▁* ▁p last _ index ▁= ▁last _ index ▁; ▁return ▁0 ▁; ▁fail ▁: ▁return ▁-1 ▁; ▁}	0
▁int ▁BN _ mod _ exp _ mont ▁( ▁BIGNUM ▁* ▁rr ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁p ▁, ▁const ▁BIGNUM ▁* ▁m ▁, ▁BN _ CTX ▁* ▁ctx ▁, ▁BN _ M ONT _ CTX ▁* ▁in _ mont ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁bits ▁, ▁ret ▁= ▁0 ▁, ▁w start ▁, ▁w end ▁, ▁window ▁, ▁wvalue ▁; ▁int ▁start ▁= ▁1 ▁; ▁BIGNUM ▁* ▁d ▁, ▁* ▁r ▁; ▁const ▁BIGNUM ▁* ▁aa ▁; ▁BIGNUM ▁* ▁val ▁[ ▁TABLE _ SIZE ▁] ▁; ▁BN _ M ONT _ CTX ▁* ▁m ont ▁= ▁NULL ▁; ▁if ▁( ▁BN _ get _ flags ▁( ▁p ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁|| ▁BN _ get _ flags ▁( ▁a ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁|| ▁BN _ get _ flags ▁( ▁m ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁) ▁{ ▁return ▁BN _ mod _ exp _ mont _ const time ▁( ▁rr ▁, ▁a ▁, ▁p ▁, ▁m ▁, ▁ctx ▁, ▁in _ mont ▁) ▁; ▁} ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁p ▁) ▁; ▁bn _ check _ top ▁( ▁m ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ odd ▁( ▁m ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ MOD _ EXP _ M ONT ▁, ▁BN _ R _ CALLED _ WITH _ EVEN _ MODUL US ▁) ▁; ▁return ▁0 ▁; ▁} ▁bits ▁= ▁BN _ num _ bits ▁( ▁p ▁) ▁; ▁if ▁( ▁bits ▁== ▁0 ▁) ▁{ ▁if ▁( ▁BN _ abs _ is _ word ▁( ▁m ▁, ▁1 ▁) ▁) ▁{ ▁ret ▁= ▁1 ▁; ▁BN _ zero ▁( ▁rr ▁) ▁; ▁} ▁else ▁{ ▁ret ▁= ▁BN _ one ▁( ▁rr ▁) ▁; ▁} ▁return ▁ret ▁; ▁} ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁d ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁r ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁val ▁[ ▁0 ▁] ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁val ▁[ ▁0 ▁] ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁in _ mont ▁!= ▁NULL ▁) ▁m ont ▁= ▁in _ mont ▁; ▁else ▁{ ▁if ▁( ▁( ▁m ont ▁= ▁BN _ M ONT _ CTX _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁m ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁a ▁-> ▁neg ▁|| ▁BN _ ucmp ▁( ▁a ▁, ▁m ▁) ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁! ▁BN _ nn mod ▁( ▁val ▁[ ▁0 ▁] ▁, ▁a ▁, ▁m ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁aa ▁= ▁val ▁[ ▁0 ▁] ▁; ▁} ▁else ▁aa ▁= ▁a ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁aa ▁) ▁) ▁{ ▁BN _ zero ▁( ▁rr ▁) ▁; ▁ret ▁= ▁1 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁bn _ to _ mont _ fixed _ top ▁( ▁val ▁[ ▁0 ▁] ▁, ▁aa ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁window ▁= ▁BN _ window _ bits _ for _ exponent _ size ▁( ▁bits ▁) ▁; ▁if ▁( ▁window ▁> ▁1 ▁) ▁{ ▁if ▁( ▁! ▁bn _ mul _ mont _ fixed _ top ▁( ▁d ▁, ▁val ▁[ ▁0 ▁] ▁, ▁val ▁[ ▁0 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁j ▁= ▁1 ▁<< ▁( ▁window ▁- ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁val ▁[ ▁i ▁] ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁|| ▁! ▁bn _ mul _ mont _ fixed _ top ▁( ▁val ▁[ ▁i ▁] ▁, ▁val ▁[ ▁i ▁- ▁1 ▁] ▁, ▁d ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁} ▁start ▁= ▁1 ▁; ▁wvalue ▁= ▁0 ▁; ▁w start ▁= ▁bits ▁- ▁1 ▁; ▁w end ▁= ▁0 ▁; ▁# if ▁1 ▁j ▁= ▁m ▁-> ▁top ▁; ▁if ▁( ▁m ▁-> ▁d ▁[ ▁j ▁- ▁1 ▁] ▁& ▁( ▁( ▁( ▁BN _ ULONG ▁) ▁1 ▁) ▁<< ▁( ▁BN _ BITS 2 ▁- ▁1 ▁) ▁) ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁r ▁, ▁j ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁r ▁-> ▁d ▁[ ▁0 ▁] ▁= ▁( ▁0 ▁- ▁m ▁-> ▁d ▁[ ▁0 ▁] ▁) ▁& ▁BN _ MASK 2 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁r ▁-> ▁d ▁[ ▁i ▁] ▁= ▁( ▁ ~ ▁m ▁-> ▁d ▁[ ▁i ▁] ▁) ▁& ▁BN _ MASK 2 ▁; ▁r ▁-> ▁top ▁= ▁j ▁; ▁r ▁-> ▁flags ▁|= ▁BN _ FLG _ FIXED _ TOP ▁; ▁} ▁else ▁# endif ▁if ▁( ▁! ▁bn _ to _ mont _ fixed _ top ▁( ▁r ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁BN _ is _ bit _ set ▁( ▁p ▁, ▁w start ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁! ▁start ▁) ▁{ ▁if ▁( ▁! ▁bn _ mul _ mont _ fixed _ top ▁( ▁r ▁, ▁r ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁w start ▁== ▁0 ▁) ▁break ▁; ▁w start ▁-- ▁; ▁continue ▁; ▁} ▁j ▁= ▁w start ▁; ▁wvalue ▁= ▁1 ▁; ▁w end ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁window ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁w start ▁- ▁i ▁< ▁0 ▁) ▁break ▁; ▁if ▁( ▁BN _ is _ bit _ set ▁( ▁p ▁, ▁w start ▁- ▁i ▁) ▁) ▁{ ▁wvalue ▁<<= ▁( ▁i ▁- ▁w end ▁) ▁; ▁wvalue ▁|= ▁1 ▁; ▁w end ▁= ▁i ▁; ▁} ▁} ▁j ▁= ▁w end ▁+ ▁1 ▁; ▁if ▁( ▁! ▁start ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁bn _ mul _ mont _ fixed _ top ▁( ▁r ▁, ▁r ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁bn _ mul _ mont _ fixed _ top ▁( ▁r ▁, ▁r ▁, ▁val ▁[ ▁wvalue ▁>> ▁1 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁w start ▁-= ▁w end ▁+ ▁1 ▁; ▁wvalue ▁= ▁0 ▁; ▁start ▁= ▁0 ▁; ▁if ▁( ▁w start ▁< ▁0 ▁) ▁break ▁; ▁} ▁# if ▁defined ▁( ▁SPARC _ T 4_ M ONT ▁) ▁if ▁( ▁OPENSSL _ spar cv 9 cap _ P ▁[ ▁0 ▁] ▁& ▁( ▁SPAR CV 9_ VIS 3 ▁| ▁SPAR CV 9_ PREFER _ FPU ▁) ▁) ▁{ ▁j ▁= ▁m ont ▁-> ▁N ▁. ▁top ▁; ▁val ▁[ ▁0 ▁] ▁-> ▁d ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁val ▁[ ▁0 ▁] ▁-> ▁d ▁[ ▁i ▁] ▁= ▁0 ▁; ▁val ▁[ ▁0 ▁] ▁-> ▁top ▁= ▁j ▁; ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁rr ▁, ▁r ▁, ▁val ▁[ ▁0 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁# endif ▁if ▁( ▁! ▁BN _ from _ mon tg om ery ▁( ▁rr ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁in _ mont ▁== ▁NULL ▁) ▁BN _ M ONT _ CTX _ free ▁( ▁m ont ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁bn _ check _ top ▁( ▁rr ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁execute _ decode _ s lices ▁( ▁H 264 Context ▁* ▁h ▁, ▁int ▁context _ count ▁) ▁{ ▁Mpeg Enc Context ▁* ▁const ▁s ▁= ▁& ▁h ▁-> ▁s ▁; ▁AVCodecContext ▁* ▁const ▁avctx ▁= ▁s ▁-> ▁avctx ▁; ▁H 264 Context ▁* ▁hx ▁; ▁int ▁i ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁hw accel ▁|| ▁s ▁-> ▁avctx ▁-> ▁codec ▁-> ▁capabilities ▁& ▁CODEC _ CAP _ HW ACCEL _ VD PA U ▁) ▁return ▁0 ▁; ▁if ▁( ▁context _ count ▁== ▁1 ▁) ▁{ ▁return ▁decode _ slice ▁( ▁avctx ▁, ▁& ▁h ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁context _ count ▁; ▁i ▁++ ▁) ▁{ ▁hx ▁= ▁h ▁-> ▁thread _ context ▁[ ▁i ▁] ▁; ▁hx ▁-> ▁s ▁. ▁err _ recogn ition ▁= ▁avctx ▁-> ▁err _ recogn ition ▁; ▁hx ▁-> ▁s ▁. ▁error _ count ▁= ▁0 ▁; ▁hx ▁-> ▁x 264_ build ▁= ▁h ▁-> ▁x 264_ build ▁; ▁} ▁avctx ▁-> ▁execute ▁( ▁avctx ▁, ▁decode _ slice ▁, ▁h ▁-> ▁thread _ context ▁, ▁NULL ▁, ▁context _ count ▁, ▁sizeof ▁( ▁void ▁* ▁) ▁) ▁; ▁hx ▁= ▁h ▁-> ▁thread _ context ▁[ ▁context _ count ▁- ▁1 ▁] ▁; ▁s ▁-> ▁mb _ x ▁= ▁hx ▁-> ▁s ▁. ▁mb _ x ▁; ▁s ▁-> ▁mb _ y ▁= ▁hx ▁-> ▁s ▁. ▁mb _ y ▁; ▁s ▁-> ▁drop able ▁= ▁hx ▁-> ▁s ▁. ▁drop able ▁; ▁s ▁-> ▁picture _ structure ▁= ▁hx ▁-> ▁s ▁. ▁picture _ structure ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁context _ count ▁; ▁i ▁++ ▁) ▁h ▁-> ▁s ▁. ▁error _ count ▁+= ▁h ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁s ▁. ▁error _ count ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁decode _ inter frame _ v 4 ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁uint 8_ t ▁* ▁src ▁, ▁uint 32_ t ▁size ▁) ▁{ ▁H nm 4 Video Context ▁* ▁h nm ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁Get Byte Context ▁gb ▁; ▁uint 32_ t ▁write offset ▁= ▁0 ▁; ▁int ▁count ▁, ▁left ▁, ▁offset ▁; ▁uint 8_ t ▁tag ▁, ▁previous ▁, ▁back line ▁, ▁backward ▁, ▁swap ▁; ▁bytestream 2_ init ▁( ▁& ▁gb ▁, ▁src ▁, ▁size ▁) ▁; ▁while ▁( ▁bytestream 2_ tell ▁( ▁& ▁gb ▁) ▁< ▁size ▁) ▁{ ▁count ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 1 F ▁; ▁if ▁( ▁count ▁== ▁0 ▁) ▁{ ▁tag ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 xE 0 ▁; ▁tag ▁= ▁tag ▁>> ▁5 ▁; ▁if ▁( ▁tag ▁== ▁0 ▁) ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁; ▁} ▁else ▁if ▁( ▁tag ▁== ▁1 ▁) ▁{ ▁write offset ▁+= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁* ▁2 ▁; ▁} ▁else ▁if ▁( ▁tag ▁== ▁2 ▁) ▁{ ▁count ▁= ▁bytestream 2_ get _ le 16 ▁( ▁& ▁gb ▁) ▁; ▁count ▁*= ▁2 ▁; ▁write offset ▁+= ▁count ▁; ▁} ▁else ▁if ▁( ▁tag ▁== ▁3 ▁) ▁{ ▁count ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁* ▁2 ▁; ▁while ▁( ▁count ▁> ▁0 ▁) ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁; ▁count ▁-- ▁; ▁} ▁bytestream 2_ skip ▁( ▁& ▁gb ▁, ▁1 ▁) ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁else ▁{ ▁previous ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 20 ▁; ▁back line ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 40 ▁; ▁backward ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 80 ▁; ▁bytestream 2_ skip ▁( ▁& ▁gb ▁, ▁1 ▁) ▁; ▁swap ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 01 ▁; ▁offset ▁= ▁bytestream 2_ get _ le 16 ▁( ▁& ▁gb ▁) ▁; ▁offset ▁= ▁( ▁offset ▁>> ▁1 ▁) ▁& ▁0 x 7 FFF ▁; ▁offset ▁= ▁write offset ▁+ ▁( ▁offset ▁* ▁2 ▁) ▁- ▁0 x 8000 ▁; ▁left ▁= ▁count ▁; ▁if ▁( ▁! ▁backward ▁&& ▁offset ▁+ ▁2 ▁* ▁count ▁> ▁h nm ▁-> ▁width ▁* ▁h nm ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Attemp ting t oread out of bounds " ▁) ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁backward ▁&& ▁offset ▁+ ▁1 ▁>= ▁h nm ▁-> ▁width ▁* ▁h nm ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Attemp ting t oread out of bounds " ▁) ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁write offset ▁+ ▁count ▁>= ▁h nm ▁-> ▁width ▁* ▁h nm ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Attemp ting tow rite out of bounds " ▁) ▁; ▁break ▁; ▁} ▁if ▁( ▁backward ▁) ▁{ ▁if ▁( ▁offset ▁< ▁( ▁! ▁! ▁back line ▁) ▁* ▁( ▁2 ▁* ▁h nm ▁-> ▁width ▁- ▁1 ▁) ▁+ ▁2 ▁* ▁( ▁left ▁- ▁1 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Attemp ting t oread out of bounds \ n " ▁) ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁offset ▁< ▁( ▁! ▁! ▁back line ▁) ▁* ▁( ▁2 ▁* ▁h nm ▁-> ▁width ▁- ▁1 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Attemp ting t oread out of bounds \ n " ▁) ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁previous ▁) ▁{ ▁while ▁( ▁left ▁> ▁0 ▁) ▁{ ▁if ▁( ▁back line ▁) ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁previous ▁[ ▁offset ▁- ▁( ▁2 ▁* ▁h nm ▁-> ▁width ▁) ▁+ ▁1 ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁previous ▁[ ▁offset ▁++ ▁] ▁; ▁offset ▁++ ▁; ▁} ▁else ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁previous ▁[ ▁offset ▁++ ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁previous ▁[ ▁offset ▁++ ▁] ▁; ▁} ▁if ▁( ▁backward ▁) ▁offset ▁-= ▁4 ▁; ▁left ▁-- ▁; ▁} ▁} ▁else ▁{ ▁while ▁( ▁left ▁> ▁0 ▁) ▁{ ▁if ▁( ▁back line ▁) ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁current ▁[ ▁offset ▁- ▁( ▁2 ▁* ▁h nm ▁-> ▁width ▁) ▁+ ▁1 ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁current ▁[ ▁offset ▁++ ▁] ▁; ▁offset ▁++ ▁; ▁} ▁else ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁current ▁[ ▁offset ▁++ ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁++ ▁] ▁= ▁h nm ▁-> ▁current ▁[ ▁offset ▁++ ▁] ▁; ▁} ▁if ▁( ▁backward ▁) ▁offset ▁-= ▁4 ▁; ▁left ▁-- ▁; ▁} ▁} ▁if ▁( ▁swap ▁) ▁{ ▁left ▁= ▁count ▁; ▁write offset ▁-= ▁count ▁* ▁2 ▁; ▁while ▁( ▁left ▁> ▁0 ▁) ▁{ ▁swap ▁= ▁h nm ▁-> ▁current ▁[ ▁write offset ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁] ▁= ▁h nm ▁-> ▁current ▁[ ▁write offset ▁+ ▁1 ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁+ ▁1 ▁] ▁= ▁swap ▁; ▁left ▁-- ▁; ▁write offset ▁+= ▁2 ▁; ▁} ▁} ▁} ▁} ▁}	0
▁int ▁ASN 1_ digest ▁( ▁i 2 d _ of _ void ▁* ▁i 2 d ▁, ▁const ▁EVP _ MD ▁* ▁type ▁, ▁char ▁* ▁data ▁, ▁unsigned ▁char ▁* ▁md ▁, ▁unsigned ▁int ▁* ▁len ▁) ▁{ ▁int ▁i ▁; ▁unsigned ▁char ▁* ▁str ▁, ▁* ▁p ▁; ▁i ▁= ▁i 2 d ▁( ▁data ▁, ▁NULL ▁) ▁; ▁if ▁( ▁( ▁str ▁= ▁OPENSSL _ malloc ▁( ▁i ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ DIGEST ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁p ▁= ▁str ▁; ▁i 2 d ▁( ▁data ▁, ▁& ▁p ▁) ▁; ▁if ▁( ▁! ▁EVP _ Digest ▁( ▁str ▁, ▁i ▁, ▁md ▁, ▁len ▁, ▁type ▁, ▁NULL ▁) ▁) ▁return ▁0 ▁; ▁OPENSSL _ free ▁( ▁str ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁av _ always _ inline ▁void ▁rv 40_ adapt ive _ loop _ filter ▁( ▁uint 8_ t ▁* ▁src ▁, ▁const ▁int ▁step ▁, ▁const ▁int ▁stride ▁, ▁const ▁int ▁d mode ▁, ▁const ▁int ▁lim _ q 1 ▁, ▁const ▁int ▁lim _ p 1 ▁, ▁const ▁int ▁alpha ▁, ▁const ▁int ▁beta ▁, ▁const ▁int ▁beta 2 ▁, ▁const ▁int ▁chroma ▁, ▁const ▁int ▁edge ▁) ▁{ ▁int ▁diff _ p 1 p 0 ▁[ ▁4 ▁] ▁, ▁diff _ q 1 q 0 ▁[ ▁4 ▁] ▁, ▁diff _ p 1 p 2 ▁[ ▁4 ▁] ▁, ▁diff _ q 1 q 2 ▁[ ▁4 ▁] ▁; ▁int ▁sum _ p 1 p 0 ▁= ▁0 ▁, ▁sum _ q 1 q 0 ▁= ▁0 ▁, ▁sum _ p 1 p 2 ▁= ▁0 ▁, ▁sum _ q 1 q 2 ▁= ▁0 ▁; ▁uint 8_ t ▁* ▁ptr ▁; ▁int ▁flag _ strong 0 ▁= ▁1 ▁, ▁flag _ strong 1 ▁= ▁1 ▁; ▁int ▁filter _ p 1 ▁, ▁filter _ q 1 ▁; ▁int ▁i ▁; ▁int ▁l ims ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁ptr ▁= ▁src ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁, ▁ptr ▁+= ▁stride ▁) ▁{ ▁diff _ p 1 p 0 ▁[ ▁i ▁] ▁= ▁ptr ▁[ ▁-2 ▁* ▁step ▁] ▁- ▁ptr ▁[ ▁-1 ▁* ▁step ▁] ▁; ▁diff _ q 1 q 0 ▁[ ▁i ▁] ▁= ▁ptr ▁[ ▁1 ▁* ▁step ▁] ▁- ▁ptr ▁[ ▁0 ▁* ▁step ▁] ▁; ▁sum _ p 1 p 0 ▁+= ▁diff _ p 1 p 0 ▁[ ▁i ▁] ▁; ▁sum _ q 1 q 0 ▁+= ▁diff _ q 1 q 0 ▁[ ▁i ▁] ▁; ▁} ▁filter _ p 1 ▁= ▁FF ABS ▁( ▁sum _ p 1 p 0 ▁) ▁< ▁( ▁beta ▁<< ▁2 ▁) ▁; ▁filter _ q 1 ▁= ▁FF ABS ▁( ▁sum _ q 1 q 0 ▁) ▁< ▁( ▁beta ▁<< ▁2 ▁) ▁; ▁if ▁( ▁! ▁filter _ p 1 ▁&& ▁! ▁filter _ q 1 ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁ptr ▁= ▁src ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁, ▁ptr ▁+= ▁stride ▁) ▁{ ▁diff _ p 1 p 2 ▁[ ▁i ▁] ▁= ▁ptr ▁[ ▁-2 ▁* ▁step ▁] ▁- ▁ptr ▁[ ▁-3 ▁* ▁step ▁] ▁; ▁diff _ q 1 q 2 ▁[ ▁i ▁] ▁= ▁ptr ▁[ ▁1 ▁* ▁step ▁] ▁- ▁ptr ▁[ ▁2 ▁* ▁step ▁] ▁; ▁sum _ p 1 p 2 ▁+= ▁diff _ p 1 p 2 ▁[ ▁i ▁] ▁; ▁sum _ q 1 q 2 ▁+= ▁diff _ q 1 q 2 ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁edge ▁) ▁{ ▁flag _ strong 0 ▁= ▁filter _ p 1 ▁&& ▁( ▁FF ABS ▁( ▁sum _ p 1 p 2 ▁) ▁< ▁beta 2 ▁) ▁; ▁flag _ strong 1 ▁= ▁filter _ q 1 ▁&& ▁( ▁FF ABS ▁( ▁sum _ q 1 q 2 ▁) ▁< ▁beta 2 ▁) ▁; ▁} ▁else ▁{ ▁flag _ strong 0 ▁= ▁flag _ strong 1 ▁= ▁0 ▁; ▁} ▁l ims ▁= ▁filter _ p 1 ▁+ ▁filter _ q 1 ▁+ ▁( ▁( ▁lim _ q 1 ▁+ ▁lim _ p 1 ▁) ▁>> ▁1 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁flag _ strong 0 ▁&& ▁flag _ strong 1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁, ▁src ▁+= ▁stride ▁) ▁{ ▁int ▁sf lag ▁, ▁p 0 ▁, ▁q 0 ▁, ▁p 1 ▁, ▁q 1 ▁; ▁int ▁t ▁= ▁src ▁[ ▁0 ▁* ▁step ▁] ▁- ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁; ▁if ▁( ▁! ▁t ▁) ▁continue ▁; ▁sf lag ▁= ▁( ▁alpha ▁* ▁FF ABS ▁( ▁t ▁) ▁) ▁>> ▁7 ▁; ▁if ▁( ▁sf lag ▁> ▁1 ▁) ▁continue ▁; ▁p 0 ▁= ▁( ▁25 ▁* ▁src ▁[ ▁-3 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁0 ▁* ▁step ▁] ▁+ ▁25 ▁* ▁src ▁[ ▁1 ▁* ▁step ▁] ▁+ ▁rv 40_ d ither _ l ▁[ ▁d mode ▁+ ▁i ▁] ▁) ▁>> ▁7 ▁; ▁q 0 ▁= ▁( ▁25 ▁* ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁0 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁1 ▁* ▁step ▁] ▁+ ▁25 ▁* ▁src ▁[ ▁2 ▁* ▁step ▁] ▁+ ▁rv 40_ d ither _ r ▁[ ▁d mode ▁+ ▁i ▁] ▁) ▁>> ▁7 ▁; ▁if ▁( ▁sf lag ▁) ▁{ ▁p 0 ▁= ▁av _ clip ▁( ▁p 0 ▁, ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁- ▁l ims ▁, ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁+ ▁l ims ▁) ▁; ▁q 0 ▁= ▁av _ clip ▁( ▁q 0 ▁, ▁src ▁[ ▁0 ▁* ▁step ▁] ▁- ▁l ims ▁, ▁src ▁[ ▁0 ▁* ▁step ▁] ▁+ ▁l ims ▁) ▁; ▁} ▁p 1 ▁= ▁( ▁25 ▁* ▁src ▁[ ▁-4 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁-3 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁p 0 ▁+ ▁25 ▁* ▁src ▁[ ▁0 ▁* ▁step ▁] ▁+ ▁rv 40_ d ither _ l ▁[ ▁d mode ▁+ ▁i ▁] ▁) ▁>> ▁7 ▁; ▁q 1 ▁= ▁( ▁25 ▁* ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁q 0 ▁+ ▁26 ▁* ▁src ▁[ ▁1 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁2 ▁* ▁step ▁] ▁+ ▁25 ▁* ▁src ▁[ ▁3 ▁* ▁step ▁] ▁+ ▁rv 40_ d ither _ r ▁[ ▁d mode ▁+ ▁i ▁] ▁) ▁>> ▁7 ▁; ▁if ▁( ▁sf lag ▁) ▁{ ▁p 1 ▁= ▁av _ clip ▁( ▁p 1 ▁, ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁- ▁l ims ▁, ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁+ ▁l ims ▁) ▁; ▁q 1 ▁= ▁av _ clip ▁( ▁q 1 ▁, ▁src ▁[ ▁1 ▁* ▁step ▁] ▁- ▁l ims ▁, ▁src ▁[ ▁1 ▁* ▁step ▁] ▁+ ▁l ims ▁) ▁; ▁} ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁= ▁p 1 ▁; ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁= ▁p 0 ▁; ▁src ▁[ ▁0 ▁* ▁step ▁] ▁= ▁q 0 ▁; ▁src ▁[ ▁1 ▁* ▁step ▁] ▁= ▁q 1 ▁; ▁if ▁( ▁! ▁chroma ▁) ▁{ ▁src ▁[ ▁-3 ▁* ▁step ▁] ▁= ▁( ▁25 ▁* ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁+ ▁51 ▁* ▁src ▁[ ▁-3 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁-4 ▁* ▁step ▁] ▁+ ▁64 ▁) ▁>> ▁7 ▁; ▁src ▁[ ▁2 ▁* ▁step ▁] ▁= ▁( ▁25 ▁* ▁src ▁[ ▁0 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁1 ▁* ▁step ▁] ▁+ ▁51 ▁* ▁src ▁[ ▁2 ▁* ▁step ▁] ▁+ ▁26 ▁* ▁src ▁[ ▁3 ▁* ▁step ▁] ▁+ ▁64 ▁) ▁>> ▁7 ▁; ▁} ▁} ▁} ▁else ▁if ▁( ▁filter _ p 1 ▁&& ▁filter _ q 1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁, ▁src ▁+= ▁stride ▁) ▁rv 40_ weak _ loop _ filter ▁( ▁src ▁, ▁step ▁, ▁1 ▁, ▁1 ▁, ▁alpha ▁, ▁beta ▁, ▁l ims ▁, ▁lim _ q 1 ▁, ▁lim _ p 1 ▁, ▁diff _ p 1 p 0 ▁[ ▁i ▁] ▁, ▁diff _ q 1 q 0 ▁[ ▁i ▁] ▁, ▁diff _ p 1 p 2 ▁[ ▁i ▁] ▁, ▁diff _ q 1 q 2 ▁[ ▁i ▁] ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁, ▁src ▁+= ▁stride ▁) ▁rv 40_ weak _ loop _ filter ▁( ▁src ▁, ▁step ▁, ▁filter _ p 1 ▁, ▁filter _ q 1 ▁, ▁alpha ▁, ▁beta ▁, ▁l ims ▁>> ▁1 ▁, ▁lim _ q 1 ▁>> ▁1 ▁, ▁lim _ p 1 ▁>> ▁1 ▁, ▁diff _ p 1 p 0 ▁[ ▁i ▁] ▁, ▁diff _ q 1 q 0 ▁[ ▁i ▁] ▁, ▁diff _ p 1 p 2 ▁[ ▁i ▁] ▁, ▁diff _ q 1 q 2 ▁[ ▁i ▁] ▁) ▁; ▁} ▁}	1
▁char ▁* ▁CONF _ get 1_ default _ config _ file ▁( ▁void ▁) ▁{ ▁char ▁* ▁file ▁; ▁int ▁len ▁; ▁file ▁= ▁getenv ▁( ▁" OPENSSL _ CONF " ▁) ▁; ▁if ▁( ▁file ▁) ▁return ▁BUF _ strdup ▁( ▁file ▁) ▁; ▁len ▁= ▁strlen ▁( ▁X 509_ get _ default _ cert _ area ▁( ▁) ▁) ▁; ▁# ifndef ▁OPENSSL _ SYS _ VMS ▁len ▁++ ▁; ▁# endif ▁len ▁+= ▁strlen ▁( ▁OPENSSL _ CONF ▁) ▁; ▁file ▁= ▁OPENSSL _ malloc ▁( ▁len ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁file ▁) ▁return ▁NULL ▁; ▁strcpy ▁( ▁file ▁, ▁X 509_ get _ default _ cert _ area ▁( ▁) ▁) ▁; ▁# ifndef ▁OPENSSL _ SYS _ VMS ▁strcat ▁( ▁file ▁, ▁"/" ▁) ▁; ▁# endif ▁strcat ▁( ▁file ▁, ▁OPENSSL _ CONF ▁) ▁; ▁return ▁file ▁; ▁}	1
▁static ▁av _ cold ▁int ▁x ma _ decode _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁X MA Decode Ctx ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁channels ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁= ▁decode _ init ▁( ▁& ▁s ▁-> ▁x ma ▁[ ▁i ▁] ▁, ▁avctx ▁) ▁; ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁-> ▁nb _ samples ▁= ▁512 ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁} ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁d xt ory _ decode _ v 2_ 565 ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVFrame ▁* ▁pic ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁int ▁src _ size ▁, ▁int ▁is _5 65 ▁) ▁{ ▁Get Byte Context ▁gb ▁; ▁Get Bit Context ▁gb 2 ▁; ▁int ▁ns lices ▁, ▁slice ▁, ▁slice _ height ▁; ▁uint 32_ t ▁off ▁, ▁slice _ size ▁; ▁uint 8_ t ▁* ▁dst ▁; ▁int ▁ret ▁; ▁ret ▁= ▁load _ buffer ▁( ▁avctx ▁, ▁src ▁, ▁src _ size ▁, ▁& ▁gb ▁, ▁& ▁ns lices ▁, ▁& ▁off ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁slice _ height ▁= ▁avctx ▁-> ▁height ▁/ ▁ns lices ▁; ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ RGB 24 ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁pic ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁dst ▁= ▁pic ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁slice ▁= ▁0 ▁; ▁slice ▁< ▁ns lices ▁; ▁slice ▁++ ▁) ▁{ ▁slice _ size ▁= ▁bytestream 2_ get _ le 32 ▁( ▁& ▁gb ▁) ▁; ▁ret ▁= ▁check _ slice _ size ▁( ▁avctx ▁, ▁src ▁, ▁src _ size ▁, ▁slice _ size ▁, ▁off ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁init _ get _ bits ▁( ▁& ▁gb 2 ▁, ▁src ▁+ ▁off ▁+ ▁16 ▁, ▁( ▁slice _ size ▁- ▁16 ▁) ▁* ▁8 ▁) ▁; ▁dx 2_ decode _ slice _5 65 ▁( ▁& ▁gb 2 ▁, ▁avctx ▁-> ▁width ▁, ▁slice _ height ▁, ▁dst ▁, ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁, ▁is _5 65 ▁) ▁; ▁dst ▁+= ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁* ▁slice _ height ▁; ▁off ▁+= ▁slice _ size ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁X 509_ STORE _ CTX ▁* ▁X 509_ STORE _ CTX _ new ▁( ▁void ▁) ▁{ ▁X 509_ STORE _ CTX ▁* ▁ctx ▁; ▁ctx ▁= ▁( ▁X 509_ STORE _ CTX ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁X 509_ STORE _ CTX ▁) ▁) ▁; ▁if ▁( ▁ctx ▁) ▁memset ▁( ▁ctx ▁, ▁0 ▁, ▁sizeof ▁( ▁X 509_ STORE _ CTX ▁) ▁) ▁; ▁return ▁ctx ▁; ▁}	1
▁static ▁int ▁ssl 3_ get _ server _ certificate ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁int ▁al ▁, ▁i ▁, ▁ok ▁, ▁ret ▁= ▁-1 ▁; ▁unsigned ▁long ▁n ▁, ▁nc ▁, ▁l len ▁, ▁l ▁; ▁X 509 ▁* ▁x ▁= ▁NULL ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁* ▁d ▁, ▁* ▁q ▁; ▁STACK _ OF ▁( ▁X 509 ▁) ▁* ▁sk ▁= ▁NULL ▁; ▁S ESS _ CERT ▁* ▁sc ▁; ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁int ▁need _ cert ▁= ▁1 ▁; ▁n ▁= ▁ssl 3_ get _ message ▁( ▁s ▁, ▁SSL 3_ ST _ CR _ CERT _ A ▁, ▁SSL 3_ ST _ CR _ CERT _ B ▁, ▁-1 ▁, ▁s ▁-> ▁max _ cert _ list ▁, ▁& ▁ok ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁return ▁( ▁( ▁int ▁) ▁n ▁) ▁; ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁message _ type ▁== ▁SSL 3_ MT _ SERVER _ KEY _ EXCHANGE ▁) ▁{ ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁reuse _ message ▁= ▁1 ▁; ▁return ▁( ▁1 ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁message _ type ▁!= ▁SSL 3_ MT _ CERTIFICATE ▁) ▁{ ▁al ▁= ▁SSL _ AD _ UNEXPECTED _ MESSAGE ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁SSL _ R _ BAD _ MESSAGE _ TYPE ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁d ▁= ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁s ▁-> ▁init _ buf ▁-> ▁data ▁; ▁if ▁( ▁( ▁sk ▁= ▁sk _ X 509_ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁n 2 l 3 ▁( ▁p ▁, ▁l len ▁) ▁; ▁if ▁( ▁l len ▁+ ▁3 ▁!= ▁n ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁for ▁( ▁nc ▁= ▁0 ▁; ▁nc ▁< ▁l len ▁; ▁) ▁{ ▁n 2 l 3 ▁( ▁p ▁, ▁l ▁) ▁; ▁if ▁( ▁( ▁l ▁+ ▁nc ▁+ ▁3 ▁) ▁> ▁l len ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁SSL _ R _ CERT _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁q ▁= ▁p ▁; ▁x ▁= ▁d 2 i _ X 509 ▁( ▁NULL ▁, ▁& ▁q ▁, ▁l ▁) ▁; ▁if ▁( ▁x ▁== ▁NULL ▁) ▁{ ▁al ▁= ▁SSL _ AD _ BAD _ CERTIFICATE ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁ERR _ R _ ASN 1_ LIB ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁q ▁!= ▁( ▁p ▁+ ▁l ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁SSL _ R _ CERT _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁! ▁sk _ X 509_ push ▁( ▁sk ▁, ▁x ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁x ▁= ▁NULL ▁; ▁nc ▁+= ▁l ▁+ ▁3 ▁; ▁p ▁= ▁q ▁; ▁} ▁i ▁= ▁ssl _ verify _ cert _ chain ▁( ▁s ▁, ▁sk ▁) ▁; ▁if ▁( ▁( ▁s ▁-> ▁verify _ mode ▁!= ▁SSL _ VERIFY _ NONE ▁) ▁&& ▁( ▁! ▁i ▁) ▁# ifndef ▁OPENSSL _ NO _ KRB 5 ▁&& ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithms ▁& ▁( ▁SSL _ M KEY _ MASK ▁| ▁SSL _ AUTH _ MASK ▁) ▁) ▁!= ▁( ▁SSL _ a KRB 5 ▁| ▁SSL _ k KRB 5 ▁) ▁# endif ▁) ▁{ ▁al ▁= ▁ssl _ verify _ alarm _ type ▁( ▁s ▁-> ▁verify _ result ▁) ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁SSL _ R _ CERTIFICATE _ VERIFY _ FAILED ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁sc ▁= ▁ssl _ sess _ cert _ new ▁( ▁) ▁; ▁if ▁( ▁sc ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁s ▁-> ▁session ▁-> ▁sess _ cert ▁) ▁ssl _ sess _ cert _ free ▁( ▁s ▁-> ▁session ▁-> ▁sess _ cert ▁) ▁; ▁s ▁-> ▁session ▁-> ▁sess _ cert ▁= ▁sc ▁; ▁sc ▁-> ▁cert _ chain ▁= ▁sk ▁; ▁x ▁= ▁sk _ X 509_ value ▁( ▁sk ▁, ▁0 ▁) ▁; ▁sk ▁= ▁NULL ▁; ▁pkey ▁= ▁X 509_ get _ pubkey ▁( ▁x ▁) ▁; ▁need _ cert ▁= ▁( ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithms ▁& ▁( ▁SSL _ M KEY _ MASK ▁| ▁SSL _ AUTH _ MASK ▁) ▁) ▁== ▁( ▁SSL _ a KRB 5 ▁| ▁SSL _ k KRB 5 ▁) ▁) ▁? ▁0 ▁: ▁1 ▁; ▁# ifdef ▁K SSL _ DEBUG ▁printf ▁( ▁" pkey , x =% p ,% p \ n " ▁, ▁pkey ▁, ▁x ▁) ▁; ▁printf ▁( ▁" ssl _ cert _ type ( x , pkey ) =% d \ n " ▁, ▁ssl _ cert _ type ▁( ▁x ▁, ▁pkey ▁) ▁) ▁; ▁printf ▁( ▁" cipher , alg , nc =% s ,% lx ,% d \ n " ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁name ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithms ▁, ▁need _ cert ▁) ▁; ▁# endif ▁if ▁( ▁need _ cert ▁&& ▁( ▁( ▁pkey ▁== ▁NULL ▁) ▁|| ▁EVP _ PKEY _ missing _ parameters ▁( ▁pkey ▁) ▁) ▁) ▁{ ▁x ▁= ▁NULL ▁; ▁al ▁= ▁SSL 3_ AL _ FATAL ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁SSL _ R _ UN ABLE _ TO _ FIND _ PUBLIC _ KEY _ PARAMETERS ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁i ▁= ▁ssl _ cert _ type ▁( ▁x ▁, ▁pkey ▁) ▁; ▁if ▁( ▁need _ cert ▁&& ▁i ▁< ▁0 ▁) ▁{ ▁x ▁= ▁NULL ▁; ▁al ▁= ▁SSL 3_ AL _ FATAL ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ CERTIFICATE ▁, ▁SSL _ R _ UNKNOWN _ CERTIFICATE _ TYPE ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁need _ cert ▁) ▁{ ▁sc ▁-> ▁peer _ cert _ type ▁= ▁i ▁; ▁CRYPTO _ add ▁( ▁& ▁x ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ X 509 ▁) ▁; ▁if ▁( ▁sc ▁-> ▁peer _ p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁!= ▁NULL ▁) ▁X 509_ free ▁( ▁sc ▁-> ▁peer _ p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁) ▁; ▁sc ▁-> ▁peer _ p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁= ▁x ▁; ▁sc ▁-> ▁peer _ key ▁= ▁& ▁( ▁sc ▁-> ▁peer _ p keys ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁s ▁-> ▁session ▁-> ▁peer ▁!= ▁NULL ▁) ▁X 509_ free ▁( ▁s ▁-> ▁session ▁-> ▁peer ▁) ▁; ▁CRYPTO _ add ▁( ▁& ▁x ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ X 509 ▁) ▁; ▁s ▁-> ▁session ▁-> ▁peer ▁= ▁x ▁; ▁} ▁else ▁{ ▁sc ▁-> ▁peer _ cert _ type ▁= ▁i ▁; ▁sc ▁-> ▁peer _ key ▁= ▁NULL ▁; ▁if ▁( ▁s ▁-> ▁session ▁-> ▁peer ▁!= ▁NULL ▁) ▁X 509_ free ▁( ▁s ▁-> ▁session ▁-> ▁peer ▁) ▁; ▁s ▁-> ▁session ▁-> ▁peer ▁= ▁NULL ▁; ▁} ▁s ▁-> ▁session ▁-> ▁verify _ result ▁= ▁s ▁-> ▁verify _ result ▁; ▁x ▁= ▁NULL ▁; ▁ret ▁= ▁1 ▁; ▁if ▁( ▁0 ▁) ▁{ ▁f _ err ▁: ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ FATAL ▁, ▁al ▁) ▁; ▁} ▁err ▁: ▁EVP _ PKEY _ free ▁( ▁pkey ▁) ▁; ▁X 509_ free ▁( ▁x ▁) ▁; ▁sk _ X 509_ pop _ free ▁( ▁sk ▁, ▁X 509_ free ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁int ▁s iff _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁SI FF Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁if ▁( ▁c ▁-> ▁has _ video ▁) ▁{ ▁unsigned ▁int ▁size ▁; ▁if ▁( ▁c ▁-> ▁cur _ frame ▁>= ▁c ▁-> ▁frames ▁) ▁return ▁AVERROR _ EOF ▁; ▁if ▁( ▁c ▁-> ▁cur strm ▁== ▁-1 ▁) ▁{ ▁c ▁-> ▁pkt size ▁= ▁avio _ rl 32 ▁( ▁s ▁-> ▁pb ▁) ▁- ▁4 ▁; ▁c ▁-> ▁flags ▁= ▁avio _ rl 16 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁c ▁-> ▁g mc size ▁= ▁( ▁c ▁-> ▁flags ▁& ▁VB _ HAS _ G MC ▁) ▁? ▁4 ▁: ▁0 ▁; ▁if ▁( ▁c ▁-> ▁g mc size ▁) ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁c ▁-> ▁g mc ▁, ▁c ▁-> ▁g mc size ▁) ▁; ▁c ▁-> ▁snd size ▁= ▁( ▁c ▁-> ▁flags ▁& ▁VB _ HAS _ AUDIO ▁) ▁? ▁avio _ rl 32 ▁( ▁s ▁-> ▁pb ▁) ▁: ▁0 ▁; ▁c ▁-> ▁cur strm ▁= ▁! ▁! ▁( ▁c ▁-> ▁flags ▁& ▁VB _ HAS _ AUDIO ▁) ▁; ▁} ▁if ▁( ▁! ▁c ▁-> ▁cur strm ▁) ▁{ ▁if ▁( ▁c ▁-> ▁pkt size ▁< ▁2 LL ▁+ ▁c ▁-> ▁snd size ▁+ ▁c ▁-> ▁g mc size ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁size ▁= ▁c ▁-> ▁pkt size ▁- ▁c ▁-> ▁snd size ▁- ▁c ▁-> ▁g mc size ▁- ▁2 ▁; ▁size ▁= ▁ff io _ limit ▁( ▁s ▁-> ▁pb ▁, ▁size ▁) ▁; ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁size ▁+ ▁c ▁-> ▁g mc size ▁+ ▁2 ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁AV _ WL 16 ▁( ▁pkt ▁-> ▁data ▁, ▁c ▁-> ▁flags ▁) ▁; ▁if ▁( ▁c ▁-> ▁g mc size ▁) ▁memcpy ▁( ▁pkt ▁-> ▁data ▁+ ▁2 ▁, ▁c ▁-> ▁g mc ▁, ▁c ▁-> ▁g mc size ▁) ▁; ▁if ▁( ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁-> ▁data ▁+ ▁2 ▁+ ▁c ▁-> ▁g mc size ▁, ▁size ▁) ▁!= ▁size ▁) ▁{ ▁av _ free _ packet ▁( ▁pkt ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁c ▁-> ▁cur strm ▁= ▁-1 ▁; ▁} ▁else ▁{ ▁int ▁pkt size ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁c ▁-> ▁snd size ▁- ▁4 ▁) ▁; ▁if ▁( ▁pkt size ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁1 ▁; ▁pkt ▁-> ▁duration ▁= ▁pkt size ▁; ▁c ▁-> ▁cur strm ▁= ▁0 ▁; ▁} ▁if ▁( ▁! ▁c ▁-> ▁cur _ frame ▁|| ▁c ▁-> ▁cur strm ▁) ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ KEY ▁; ▁if ▁( ▁c ▁-> ▁cur strm ▁== ▁-1 ▁) ▁c ▁-> ▁cur _ frame ▁++ ▁; ▁} ▁else ▁{ ▁int ▁pkt size ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁c ▁-> ▁block _ align ▁) ▁; ▁if ▁( ▁! ▁pkt size ▁) ▁return ▁AVERROR _ EOF ▁; ▁if ▁( ▁pkt size ▁<= ▁0 ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁pkt ▁-> ▁duration ▁= ▁pkt size ▁; ▁} ▁return ▁pkt ▁-> ▁size ▁; ▁}	0
▁static ▁void ▁remove _ any _ filter ▁( ▁ap _ filter _ t ▁* ▁f ▁, ▁ap _ filter _ t ▁* ▁* ▁r _ filt ▁, ▁ap _ filter _ t ▁* ▁* ▁p _ filt ▁, ▁ap _ filter _ t ▁* ▁* ▁c _ filt ▁) ▁{ ▁ap _ filter _ t ▁* ▁* ▁curr ▁= ▁r _ filt ▁? ▁r _ filt ▁: ▁c _ filt ▁; ▁ap _ filter _ t ▁* ▁f scan ▁= ▁* ▁curr ▁; ▁if ▁( ▁is _ pending _ filter ▁( ▁f ▁) ▁) ▁{ ▁apr _ pool _ cleanup _ run ▁( ▁f ▁-> ▁c ▁-> ▁pool ▁, ▁f ▁, ▁pending _ filter _ cleanup ▁) ▁; ▁} ▁if ▁( ▁p _ filt ▁&& ▁* ▁p _ filt ▁== ▁f ▁) ▁* ▁p _ filt ▁= ▁( ▁* ▁p _ filt ▁) ▁-> ▁next ▁; ▁if ▁( ▁* ▁curr ▁== ▁f ▁) ▁{ ▁* ▁curr ▁= ▁( ▁* ▁curr ▁) ▁-> ▁next ▁; ▁return ▁; ▁} ▁while ▁( ▁f scan ▁-> ▁next ▁!= ▁f ▁) ▁{ ▁if ▁( ▁! ▁( ▁f scan ▁= ▁f scan ▁-> ▁next ▁) ▁) ▁{ ▁return ▁; ▁} ▁} ▁f scan ▁-> ▁next ▁= ▁f ▁-> ▁next ▁; ▁}	0
▁static ▁int ▁decode _ q _ branch ▁( ▁Snow Context ▁* ▁s ▁, ▁int ▁level ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁const ▁int ▁w ▁= ▁s ▁-> ▁b _ width ▁<< ▁s ▁-> ▁block _ max _ depth ▁; ▁const ▁int ▁rem _ depth ▁= ▁s ▁-> ▁block _ max _ depth ▁- ▁level ▁; ▁const ▁int ▁index ▁= ▁( ▁x ▁+ ▁y ▁* ▁w ▁) ▁<< ▁rem _ depth ▁; ▁int ▁trx ▁= ▁( ▁x ▁+ ▁1 ▁) ▁<< ▁rem _ depth ▁; ▁const ▁Block Node ▁* ▁left ▁= ▁x ▁? ▁& ▁s ▁-> ▁block ▁[ ▁index ▁- ▁1 ▁] ▁: ▁& ▁null _ block ▁; ▁const ▁Block Node ▁* ▁top ▁= ▁y ▁? ▁& ▁s ▁-> ▁block ▁[ ▁index ▁- ▁w ▁] ▁: ▁& ▁null _ block ▁; ▁const ▁Block Node ▁* ▁tl ▁= ▁y ▁&& ▁x ▁? ▁& ▁s ▁-> ▁block ▁[ ▁index ▁- ▁w ▁- ▁1 ▁] ▁: ▁left ▁; ▁const ▁Block Node ▁* ▁tr ▁= ▁y ▁&& ▁trx ▁< ▁w ▁&& ▁( ▁( ▁x ▁& ▁1 ▁) ▁== ▁0 ▁|| ▁level ▁== ▁0 ▁) ▁? ▁& ▁s ▁-> ▁block ▁[ ▁index ▁- ▁w ▁+ ▁( ▁1 ▁<< ▁rem _ depth ▁) ▁] ▁: ▁tl ▁; ▁int ▁s _ context ▁= ▁2 ▁* ▁left ▁-> ▁level ▁+ ▁2 ▁* ▁top ▁-> ▁level ▁+ ▁tl ▁-> ▁level ▁+ ▁tr ▁-> ▁level ▁; ▁int ▁res ▁; ▁if ▁( ▁s ▁-> ▁keyframe ▁) ▁{ ▁set _ blocks ▁( ▁s ▁, ▁level ▁, ▁x ▁, ▁y ▁, ▁null _ block ▁. ▁color ▁[ ▁0 ▁] ▁, ▁null _ block ▁. ▁color ▁[ ▁1 ▁] ▁, ▁null _ block ▁. ▁color ▁[ ▁2 ▁] ▁, ▁null _ block ▁. ▁mx ▁, ▁null _ block ▁. ▁my ▁, ▁null _ block ▁. ▁ref ▁, ▁BLOCK _ INTR A ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁level ▁== ▁s ▁-> ▁block _ max _ depth ▁|| ▁get _ rac ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁4 ▁+ ▁s _ context ▁] ▁) ▁) ▁{ ▁int ▁type ▁, ▁mx ▁, ▁my ▁; ▁int ▁l ▁= ▁left ▁-> ▁color ▁[ ▁0 ▁] ▁; ▁int ▁cb ▁= ▁left ▁-> ▁color ▁[ ▁1 ▁] ▁; ▁int ▁cr ▁= ▁left ▁-> ▁color ▁[ ▁2 ▁] ▁; ▁unsigned ▁ref ▁= ▁0 ▁; ▁int ▁ref _ context ▁= ▁av _ log 2 ▁( ▁2 ▁* ▁left ▁-> ▁ref ▁) ▁+ ▁av _ log 2 ▁( ▁2 ▁* ▁top ▁-> ▁ref ▁) ▁; ▁int ▁mx _ context ▁= ▁av _ log 2 ▁( ▁2 ▁* ▁FF ABS ▁( ▁left ▁-> ▁mx ▁- ▁top ▁-> ▁mx ▁) ▁) ▁+ ▁0 ▁* ▁av _ log 2 ▁( ▁2 ▁* ▁FF ABS ▁( ▁tr ▁-> ▁mx ▁- ▁top ▁-> ▁mx ▁) ▁) ▁; ▁int ▁my _ context ▁= ▁av _ log 2 ▁( ▁2 ▁* ▁FF ABS ▁( ▁left ▁-> ▁my ▁- ▁top ▁-> ▁my ▁) ▁) ▁+ ▁0 ▁* ▁av _ log 2 ▁( ▁2 ▁* ▁FF ABS ▁( ▁tr ▁-> ▁my ▁- ▁top ▁-> ▁my ▁) ▁) ▁; ▁type ▁= ▁get _ rac ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁1 ▁+ ▁left ▁-> ▁type ▁+ ▁top ▁-> ▁type ▁] ▁) ▁? ▁BLOCK _ INTR A ▁: ▁0 ▁; ▁if ▁( ▁type ▁) ▁{ ▁int ▁ld ▁, ▁cb d ▁, ▁cr d ▁; ▁pred _ mv ▁( ▁s ▁, ▁& ▁mx ▁, ▁& ▁my ▁, ▁0 ▁, ▁left ▁, ▁top ▁, ▁tr ▁) ▁; ▁ld ▁= ▁get _ symbol ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁32 ▁] ▁, ▁1 ▁) ▁; ▁if ▁( ▁ld ▁< ▁- 255 ▁|| ▁ld ▁> ▁255 ▁) ▁{ ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁l ▁+= ▁ld ▁; ▁if ▁( ▁s ▁-> ▁nb _ planes ▁> ▁2 ▁) ▁{ ▁cb d ▁= ▁get _ symbol ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁64 ▁] ▁, ▁1 ▁) ▁; ▁cr d ▁= ▁get _ symbol ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁96 ▁] ▁, ▁1 ▁) ▁; ▁if ▁( ▁cb d ▁< ▁- 255 ▁|| ▁cb d ▁> ▁255 ▁|| ▁cr d ▁< ▁- 255 ▁|| ▁cr d ▁> ▁255 ▁) ▁{ ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁cb ▁+= ▁cb d ▁; ▁cr ▁+= ▁cr d ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁ref _ frames ▁> ▁1 ▁) ▁ref ▁= ▁get _ symbol ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁128 ▁+ ▁1024 ▁+ ▁32 ▁* ▁ref _ context ▁] ▁, ▁0 ▁) ▁; ▁if ▁( ▁ref ▁>= ▁s ▁-> ▁ref _ frames ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid ref \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁pred _ mv ▁( ▁s ▁, ▁& ▁mx ▁, ▁& ▁my ▁, ▁ref ▁, ▁left ▁, ▁top ▁, ▁tr ▁) ▁; ▁mx ▁+= ▁get _ symbol ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁128 ▁+ ▁32 ▁* ▁( ▁mx _ context ▁+ ▁16 ▁* ▁! ▁! ▁ref ▁) ▁] ▁, ▁1 ▁) ▁; ▁my ▁+= ▁get _ symbol ▁( ▁& ▁s ▁-> ▁c ▁, ▁& ▁s ▁-> ▁block _ state ▁[ ▁128 ▁+ ▁32 ▁* ▁( ▁my _ context ▁+ ▁16 ▁* ▁! ▁! ▁ref ▁) ▁] ▁, ▁1 ▁) ▁; ▁} ▁set _ blocks ▁( ▁s ▁, ▁level ▁, ▁x ▁, ▁y ▁, ▁l ▁, ▁cb ▁, ▁cr ▁, ▁mx ▁, ▁my ▁, ▁ref ▁, ▁type ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁res ▁= ▁decode _ q _ branch ▁( ▁s ▁, ▁level ▁+ ▁1 ▁, ▁2 ▁* ▁x ▁+ ▁0 ▁, ▁2 ▁* ▁y ▁+ ▁0 ▁) ▁) ▁< ▁0 ▁|| ▁( ▁res ▁= ▁decode _ q _ branch ▁( ▁s ▁, ▁level ▁+ ▁1 ▁, ▁2 ▁* ▁x ▁+ ▁1 ▁, ▁2 ▁* ▁y ▁+ ▁0 ▁) ▁) ▁< ▁0 ▁|| ▁( ▁res ▁= ▁decode _ q _ branch ▁( ▁s ▁, ▁level ▁+ ▁1 ▁, ▁2 ▁* ▁x ▁+ ▁0 ▁, ▁2 ▁* ▁y ▁+ ▁1 ▁) ▁) ▁< ▁0 ▁|| ▁( ▁res ▁= ▁decode _ q _ branch ▁( ▁s ▁, ▁level ▁+ ▁1 ▁, ▁2 ▁* ▁x ▁+ ▁1 ▁, ▁2 ▁* ▁y ▁+ ▁1 ▁) ▁) ▁< ▁0 ▁) ▁return ▁res ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁ngx _ int _ t ▁ngx _ http _ file _ cache _ exists ▁( ▁ngx _ http _ file _ cache _ t ▁* ▁cache ▁, ▁ngx _ http _ cache _ t ▁* ▁c ▁) ▁{ ▁ngx _ int _ t ▁rc ▁; ▁ngx _ http _ file _ cache _ node _ t ▁* ▁f cn ▁; ▁ngx _ shm tx _ lock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁f cn ▁= ▁c ▁-> ▁node ▁; ▁if ▁( ▁f cn ▁== ▁NULL ▁) ▁{ ▁f cn ▁= ▁ngx _ http _ file _ cache _ lookup ▁( ▁cache ▁, ▁c ▁-> ▁key ▁) ▁; ▁} ▁if ▁( ▁f cn ▁) ▁{ ▁ngx _ queue _ remove ▁( ▁& ▁f cn ▁-> ▁queue ▁) ▁; ▁if ▁( ▁c ▁-> ▁node ▁== ▁NULL ▁) ▁{ ▁f cn ▁-> ▁uses ▁++ ▁; ▁f cn ▁-> ▁count ▁++ ▁; ▁} ▁if ▁( ▁f cn ▁-> ▁error ▁) ▁{ ▁if ▁( ▁f cn ▁-> ▁valid _ sec ▁< ▁ngx _ time ▁( ▁) ▁) ▁{ ▁goto ▁renew ▁; ▁} ▁rc ▁= ▁NGX _ OK ▁; ▁goto ▁done ▁; ▁} ▁if ▁( ▁f cn ▁-> ▁exists ▁|| ▁f cn ▁-> ▁uses ▁>= ▁c ▁-> ▁min _ uses ▁) ▁{ ▁c ▁-> ▁exists ▁= ▁f cn ▁-> ▁exists ▁; ▁if ▁( ▁f cn ▁-> ▁body _ start ▁) ▁{ ▁c ▁-> ▁body _ start ▁= ▁f cn ▁-> ▁body _ start ▁; ▁} ▁rc ▁= ▁NGX _ OK ▁; ▁goto ▁done ▁; ▁} ▁rc ▁= ▁NGX _ AGAIN ▁; ▁goto ▁done ▁; ▁} ▁f cn ▁= ▁ngx _ slab _ calloc _ locked ▁( ▁cache ▁-> ▁sh pool ▁, ▁sizeof ▁( ▁ngx _ http _ file _ cache _ node _ t ▁) ▁) ▁; ▁if ▁( ▁f cn ▁== ▁NULL ▁) ▁{ ▁ngx _ shm tx _ unlock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁( ▁void ▁) ▁ngx _ http _ file _ cache _ forced _ expire ▁( ▁cache ▁) ▁; ▁ngx _ shm tx _ lock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁f cn ▁= ▁ngx _ slab _ calloc _ locked ▁( ▁cache ▁-> ▁sh pool ▁, ▁sizeof ▁( ▁ngx _ http _ file _ cache _ node _ t ▁) ▁) ▁; ▁if ▁( ▁f cn ▁== ▁NULL ▁) ▁{ ▁rc ▁= ▁NGX _ ERROR ▁; ▁goto ▁failed ▁; ▁} ▁} ▁ngx _ memcpy ▁( ▁( ▁u _ char ▁* ▁) ▁& ▁f cn ▁-> ▁node ▁. ▁key ▁, ▁c ▁-> ▁key ▁, ▁sizeof ▁( ▁ngx _ rbtree _ key _ t ▁) ▁) ▁; ▁ngx _ memcpy ▁( ▁f cn ▁-> ▁key ▁, ▁& ▁c ▁-> ▁key ▁[ ▁sizeof ▁( ▁ngx _ rbtree _ key _ t ▁) ▁] ▁, ▁NGX _ HTTP _ CACHE _ KEY _ LEN ▁- ▁sizeof ▁( ▁ngx _ rbtree _ key _ t ▁) ▁) ▁; ▁ngx _ rbtree _ insert ▁( ▁& ▁cache ▁-> ▁sh ▁-> ▁r btree ▁, ▁& ▁f cn ▁-> ▁node ▁) ▁; ▁f cn ▁-> ▁uses ▁= ▁1 ▁; ▁f cn ▁-> ▁count ▁= ▁1 ▁; ▁renew ▁: ▁rc ▁= ▁NGX _ DECL INED ▁; ▁f cn ▁-> ▁valid _ msec ▁= ▁0 ▁; ▁f cn ▁-> ▁error ▁= ▁0 ▁; ▁f cn ▁-> ▁exists ▁= ▁0 ▁; ▁f cn ▁-> ▁valid _ sec ▁= ▁0 ▁; ▁f cn ▁-> ▁un iq ▁= ▁0 ▁; ▁f cn ▁-> ▁body _ start ▁= ▁0 ▁; ▁f cn ▁-> ▁fs _ size ▁= ▁0 ▁; ▁done ▁: ▁f cn ▁-> ▁expire ▁= ▁ngx _ time ▁( ▁) ▁+ ▁cache ▁-> ▁inactive ▁; ▁ngx _ queue _ insert _ head ▁( ▁& ▁cache ▁-> ▁sh ▁-> ▁queue ▁, ▁& ▁f cn ▁-> ▁queue ▁) ▁; ▁c ▁-> ▁un iq ▁= ▁f cn ▁-> ▁un iq ▁; ▁c ▁-> ▁error ▁= ▁f cn ▁-> ▁error ▁; ▁c ▁-> ▁node ▁= ▁f cn ▁; ▁failed ▁: ▁ngx _ shm tx _ unlock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁return ▁rc ▁; ▁}	0
▁void ▁ssl 3_ finish _ mac ▁( ▁SSL ▁* ▁s ▁, ▁const ▁unsigned ▁char ▁* ▁buf ▁, ▁int ▁len ▁) ▁{ ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ buffer ▁&& ▁! ▁( ▁s ▁-> ▁s 3 ▁-> ▁flags ▁& ▁TLS 1_ FLAGS _ KEEP _ HAND SHAKE ▁) ▁) ▁{ ▁BIO _ write ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ buffer ▁, ▁( ▁void ▁* ▁) ▁buf ▁, ▁len ▁) ▁; ▁} ▁else ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁SSL _ MAX _ DIGEST ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ dg st ▁[ ▁i ▁] ▁!= ▁NULL ▁) ▁EVP _ DigestUpdate ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ dg st ▁[ ▁i ▁] ▁, ▁buf ▁, ▁len ▁) ▁; ▁} ▁} ▁}	1
▁static ▁char ▁* ▁parse _ link _ name ▁( ▁const ▁char ▁* ▁* ▁buf ▁, ▁void ▁* ▁log _ ctx ▁) ▁{ ▁const ▁char ▁* ▁start ▁= ▁* ▁buf ▁; ▁char ▁* ▁name ▁; ▁( ▁* ▁buf ▁) ▁++ ▁; ▁name ▁= ▁av _ get _ token ▁( ▁buf ▁, ▁"]" ▁) ▁; ▁if ▁( ▁! ▁name ▁[ ▁0 ▁] ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bad ( empty ? ) label found int he follow ing : \"% s \" .\ n " ▁, ▁start ▁) ▁; ▁goto ▁fail ▁; ▁} ▁if ▁( ▁* ▁( ▁* ▁buf ▁) ▁++ ▁!= ▁' ▁' ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Mismatch ed ' [' found int he follow ing : \"% s \" .\ n " ▁, ▁start ▁) ▁; ▁fail ▁: ▁av _ freep ▁( ▁& ▁name ▁) ▁; ▁} ▁return ▁name ▁; ▁}	1
▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁ssl _ create _ cipher _ list ▁( ▁const ▁SSL _ METHOD ▁* ▁ssl _ method ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁* ▁cipher _ list ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁* ▁cipher _ list _ by _ id ▁, ▁const ▁char ▁* ▁rule _ str ▁, ▁C ERT ▁* ▁c ▁) ▁{ ▁int ▁ok ▁, ▁num _ of _ c iphers ▁, ▁num _ of _ alias _ max ▁, ▁num _ of _ group _ aliases ▁; ▁uint 32_ t ▁disabled _ m key ▁, ▁disabled _ auth ▁, ▁disabled _ enc ▁, ▁disabled _ mac ▁, ▁disabled _ ssl ▁; ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁cipher stack ▁, ▁* ▁tmp _ cipher _ list ▁; ▁const ▁char ▁* ▁rule _ p ▁; ▁C IPHER _ ORDER ▁* ▁co _ list ▁= ▁NULL ▁, ▁* ▁head ▁= ▁NULL ▁, ▁* ▁tail ▁= ▁NULL ▁, ▁* ▁curr ▁; ▁const ▁SSL _ CIPHER ▁* ▁* ▁ca _ list ▁= ▁NULL ▁; ▁if ▁( ▁rule _ str ▁== ▁NULL ▁|| ▁cipher _ list ▁== ▁NULL ▁|| ▁cipher _ list _ by _ id ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁! ▁check _ su it eb _ cipher _ list ▁( ▁ssl _ method ▁, ▁c ▁, ▁& ▁rule _ str ▁) ▁) ▁return ▁NULL ▁; ▁# endif ▁disabled _ m key ▁= ▁disabled _ m key _ mask ▁; ▁disabled _ auth ▁= ▁disabled _ auth _ mask ▁; ▁disabled _ enc ▁= ▁disabled _ enc _ mask ▁; ▁disabled _ mac ▁= ▁disabled _ mac _ mask ▁; ▁disabled _ ssl ▁= ▁0 ▁; ▁num _ of _ c iphers ▁= ▁ssl _ method ▁-> ▁num _ c iphers ▁( ▁) ▁; ▁co _ list ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁co _ list ▁) ▁* ▁num _ of _ c iphers ▁) ▁; ▁if ▁( ▁co _ list ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CREATE _ CIPHER _ LIST ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁ssl _ cipher _ collect _ c iphers ▁( ▁ssl _ method ▁, ▁num _ of _ c iphers ▁, ▁disabled _ m key ▁, ▁disabled _ auth ▁, ▁disabled _ enc ▁, ▁disabled _ mac ▁, ▁disabled _ ssl ▁, ▁co _ list ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁SSL _ k EC D HE ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ADD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁SSL _ k EC D HE ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ DEL ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁SSL _ AES ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ADD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ADD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁SSL _ MD 5 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ORD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁0 ▁, ▁SSL _ a NULL ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ORD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁0 ▁, ▁SSL _ a ECDH ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ORD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁SSL _ k RSA ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ORD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁SSL _ k PS K ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ORD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁SSL _ RC 4 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ ORD ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁if ▁( ▁! ▁ssl _ cipher _ strength _ sort ▁( ▁& ▁head ▁, ▁& ▁tail ▁) ▁) ▁{ ▁OPENSSL _ free ▁( ▁co _ list ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ssl _ cipher _ apply _ rule ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁C IPHER _ DEL ▁, ▁-1 ▁, ▁& ▁head ▁, ▁& ▁tail ▁) ▁; ▁num _ of _ group _ aliases ▁= ▁OSSL _ NE LEM ▁( ▁cipher _ aliases ▁) ▁; ▁num _ of _ alias _ max ▁= ▁num _ of _ c iphers ▁+ ▁num _ of _ group _ aliases ▁+ ▁1 ▁; ▁ca _ list ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁ca _ list ▁) ▁* ▁num _ of _ alias _ max ▁) ▁; ▁if ▁( ▁ca _ list ▁== ▁NULL ▁) ▁{ ▁OPENSSL _ free ▁( ▁co _ list ▁) ▁; ▁SSL err ▁( ▁SSL _ F _ SSL _ CREATE _ CIPHER _ LIST ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁ssl _ cipher _ collect _ aliases ▁( ▁ca _ list ▁, ▁num _ of _ group _ aliases ▁, ▁disabled _ m key ▁, ▁disabled _ auth ▁, ▁disabled _ enc ▁, ▁disabled _ mac ▁, ▁disabled _ ssl ▁, ▁head ▁) ▁; ▁ok ▁= ▁1 ▁; ▁rule _ p ▁= ▁rule _ str ▁; ▁if ▁( ▁strncmp ▁( ▁rule _ str ▁, ▁" DEFAULT " ▁, ▁7 ▁) ▁== ▁0 ▁) ▁{ ▁ok ▁= ▁ssl _ cipher _ process _ rule str ▁( ▁SSL _ DEFAULT _ CIPHER _ LIST ▁, ▁& ▁head ▁, ▁& ▁tail ▁, ▁ca _ list ▁, ▁c ▁) ▁; ▁rule _ p ▁+= ▁7 ▁; ▁if ▁( ▁* ▁rule _ p ▁== ▁' ▁' ▁) ▁rule _ p ▁++ ▁; ▁} ▁if ▁( ▁ok ▁&& ▁( ▁strlen ▁( ▁rule _ p ▁) ▁> ▁0 ▁) ▁) ▁ok ▁= ▁ssl _ cipher _ process _ rule str ▁( ▁rule _ p ▁, ▁& ▁head ▁, ▁& ▁tail ▁, ▁ca _ list ▁, ▁c ▁) ▁; ▁OPENSSL _ free ▁( ▁ca _ list ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁{ ▁OPENSSL _ free ▁( ▁co _ list ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁if ▁( ▁( ▁cipher stack ▁= ▁sk _ SSL _ CIPHER _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁OPENSSL _ free ▁( ▁co _ list ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁for ▁( ▁curr ▁= ▁head ▁; ▁curr ▁!= ▁NULL ▁; ▁curr ▁= ▁curr ▁-> ▁next ▁) ▁{ ▁if ▁( ▁curr ▁-> ▁active ▁&& ▁( ▁! ▁FIPS _ mode ▁( ▁) ▁|| ▁curr ▁-> ▁cipher ▁-> ▁algo _ strength ▁& ▁SSL _ FIPS ▁) ▁) ▁{ ▁if ▁( ▁! ▁sk _ SSL _ CIPHER _ push ▁( ▁cipher stack ▁, ▁curr ▁-> ▁cipher ▁) ▁) ▁{ ▁OPENSSL _ free ▁( ▁co _ list ▁) ▁; ▁sk _ SSL _ CIPHER _ free ▁( ▁cipher stack ▁) ▁; ▁return ▁NULL ▁; ▁} ▁# ifdef ▁C IPHER _ DEBUG ▁fprintf ▁( ▁stderr ▁, ▁"< % s >\ n " ▁, ▁curr ▁-> ▁cipher ▁-> ▁name ▁) ▁; ▁# endif ▁} ▁} ▁OPENSSL _ free ▁( ▁co _ list ▁) ▁; ▁tmp _ cipher _ list ▁= ▁sk _ SSL _ CIPHER _ dup ▁( ▁cipher stack ▁) ▁; ▁if ▁( ▁tmp _ cipher _ list ▁== ▁NULL ▁) ▁{ ▁sk _ SSL _ CIPHER _ free ▁( ▁cipher stack ▁) ▁; ▁return ▁NULL ▁; ▁} ▁sk _ SSL _ CIPHER _ free ▁( ▁* ▁cipher _ list ▁) ▁; ▁* ▁cipher _ list ▁= ▁cipher stack ▁; ▁if ▁( ▁* ▁cipher _ list _ by _ id ▁!= ▁NULL ▁) ▁sk _ SSL _ CIPHER _ free ▁( ▁* ▁cipher _ list _ by _ id ▁) ▁; ▁* ▁cipher _ list _ by _ id ▁= ▁tmp _ cipher _ list ▁; ▁( ▁void ▁) ▁sk _ SSL _ CIPHER _ set _ cmp _ func ▁( ▁* ▁cipher _ list _ by _ id ▁, ▁ssl _ cipher _ ptr _ id _ cmp ▁) ▁; ▁sk _ SSL _ CIPHER _ sort ▁( ▁* ▁cipher _ list _ by _ id ▁) ▁; ▁return ▁( ▁cipher stack ▁) ▁; ▁}	1
▁static ▁av _ always _ inline ▁int ▁decode _ dc _ coeffs ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁int 16_ t ▁* ▁out ▁, ▁int ▁blocks _ per _ slice ▁) ▁{ ▁int 16_ t ▁prev _ dc ▁; ▁int ▁code ▁, ▁i ▁, ▁sign ▁; ▁OPEN _ READER ▁( ▁re ▁, ▁gb ▁) ▁; ▁DECODE _ CODE WORD ▁( ▁code ▁, ▁FIRST _ DC _ CB ▁) ▁; ▁prev _ dc ▁= ▁T OS IGN ED ▁( ▁code ▁) ▁; ▁out ▁[ ▁0 ▁] ▁= ▁prev _ dc ▁; ▁out ▁+= ▁64 ▁; ▁code ▁= ▁5 ▁; ▁sign ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁blocks _ per _ slice ▁; ▁i ▁++ ▁, ▁out ▁+= ▁64 ▁) ▁{ ▁DECODE _ CODE WORD ▁( ▁code ▁, ▁dc _ code book ▁[ ▁FF MIN ▁( ▁code ▁, ▁6 U ▁) ▁] ▁) ▁; ▁if ▁( ▁code ▁) ▁sign ▁ ^ = ▁- ▁( ▁code ▁& ▁1 ▁) ▁; ▁else ▁sign ▁= ▁0 ▁; ▁prev _ dc ▁+= ▁( ▁( ▁( ▁code ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁ ^ ▁sign ▁) ▁- ▁sign ▁; ▁out ▁[ ▁0 ▁] ▁= ▁prev _ dc ▁; ▁} ▁CLOSE _ READER ▁( ▁re ▁, ▁gb ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁sub band _ transform ▁( ▁D CA Enc Context ▁* ▁c ▁, ▁const ▁int 32_ t ▁* ▁input ▁) ▁{ ▁int ▁ch ▁, ▁subs ▁, ▁i ▁, ▁k ▁, ▁j ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁c ▁-> ▁full band _ channels ▁; ▁ch ▁++ ▁) ▁{ ▁int 32_ t ▁hist ▁[ ▁512 ▁] ▁; ▁int ▁hist _ start ▁= ▁0 ▁; ▁const ▁int ▁chi ▁= ▁c ▁-> ▁channel _ order _ tab ▁[ ▁ch ▁] ▁; ▁memcpy ▁( ▁hist ▁, ▁& ▁c ▁-> ▁history ▁[ ▁ch ▁] ▁[ ▁0 ▁] ▁, ▁512 ▁* ▁sizeof ▁( ▁int 32_ t ▁) ▁) ▁; ▁for ▁( ▁subs ▁= ▁0 ▁; ▁subs ▁< ▁SUB BAND _ SAMPLES ▁; ▁subs ▁++ ▁) ▁{ ▁int 32_ t ▁accum ▁[ ▁64 ▁] ▁; ▁int 32_ t ▁resp ▁; ▁int ▁band ▁; ▁memset ▁( ▁accum ▁, ▁0 ▁, ▁64 ▁* ▁sizeof ▁( ▁int 32_ t ▁) ▁) ▁; ▁for ▁( ▁k ▁= ▁0 ▁, ▁i ▁= ▁hist _ start ▁, ▁j ▁= ▁0 ▁; ▁i ▁< ▁512 ▁; ▁k ▁= ▁( ▁k ▁+ ▁1 ▁) ▁& ▁63 ▁, ▁i ▁++ ▁, ▁j ▁++ ▁) ▁accum ▁[ ▁k ▁] ▁+= ▁mul 32 ▁( ▁hist ▁[ ▁i ▁] ▁, ▁c ▁-> ▁band _ interpol ation ▁[ ▁j ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁hist _ start ▁; ▁k ▁= ▁( ▁k ▁+ ▁1 ▁) ▁& ▁63 ▁, ▁i ▁++ ▁, ▁j ▁++ ▁) ▁accum ▁[ ▁k ▁] ▁+= ▁mul 32 ▁( ▁hist ▁[ ▁i ▁] ▁, ▁c ▁-> ▁band _ interpol ation ▁[ ▁j ▁] ▁) ▁; ▁for ▁( ▁k ▁= ▁16 ▁; ▁k ▁< ▁32 ▁; ▁k ▁++ ▁) ▁accum ▁[ ▁k ▁] ▁= ▁accum ▁[ ▁k ▁] ▁- ▁accum ▁[ ▁31 ▁- ▁k ▁] ▁; ▁for ▁( ▁k ▁= ▁32 ▁; ▁k ▁< ▁48 ▁; ▁k ▁++ ▁) ▁accum ▁[ ▁k ▁] ▁= ▁accum ▁[ ▁k ▁] ▁+ ▁accum ▁[ ▁95 ▁- ▁k ▁] ▁; ▁for ▁( ▁band ▁= ▁0 ▁; ▁band ▁< ▁32 ▁; ▁band ▁++ ▁) ▁{ ▁resp ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁16 ▁; ▁i ▁< ▁48 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁s ▁= ▁( ▁2 ▁* ▁band ▁+ ▁1 ▁) ▁* ▁( ▁2 ▁* ▁( ▁i ▁+ ▁16 ▁) ▁+ ▁1 ▁) ▁; ▁resp ▁+= ▁mul 32 ▁( ▁accum ▁[ ▁i ▁] ▁, ▁cos _ t ▁( ▁s ▁<< ▁3 ▁) ▁) ▁>> ▁3 ▁; ▁} ▁c ▁-> ▁sub band ▁[ ▁ch ▁] ▁[ ▁band ▁] ▁[ ▁subs ▁] ▁= ▁( ▁( ▁band ▁+ ▁1 ▁) ▁& ▁2 ▁) ▁? ▁- ▁resp ▁: ▁resp ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁32 ▁; ▁i ▁++ ▁) ▁hist ▁[ ▁i ▁+ ▁hist _ start ▁] ▁= ▁input ▁[ ▁( ▁subs ▁* ▁32 ▁+ ▁i ▁) ▁* ▁c ▁-> ▁channels ▁+ ▁chi ▁] ▁; ▁hist _ start ▁= ▁( ▁hist _ start ▁+ ▁32 ▁) ▁& ▁511 ▁; ▁} ▁} ▁}	0
▁static ▁int ▁m jpeg _ decode _ scan _ progress ive _ ac ▁( ▁MJ peg Decode Context ▁* ▁s ▁, ▁int ▁ss ▁, ▁int ▁se ▁, ▁int ▁Ah ▁, ▁int ▁Al ▁) ▁{ ▁int ▁mb _ x ▁, ▁mb _ y ▁; ▁int ▁E O BR UN ▁= ▁0 ▁; ▁int ▁c ▁= ▁s ▁-> ▁comp _ index ▁[ ▁0 ▁] ▁; ▁uint 8_ t ▁* ▁data ▁= ▁s ▁-> ▁picture _ ptr ▁-> ▁data ▁[ ▁c ▁] ▁; ▁int ▁linesize ▁= ▁s ▁-> ▁linesize ▁[ ▁c ▁] ▁; ▁int ▁last _ scan ▁= ▁0 ▁; ▁int 16_ t ▁* ▁quant _ matrix ▁= ▁s ▁-> ▁quant _ matrix es ▁[ ▁s ▁-> ▁quant _ s index ▁[ ▁0 ▁] ▁] ▁; ▁int ▁bytes _ per _ pixel ▁= ▁1 ▁+ ▁( ▁s ▁-> ▁bits ▁> ▁8 ▁) ▁; ▁av _ assert 0 ▁( ▁ss ▁>= ▁0 ▁&& ▁Ah ▁>= ▁0 ▁&& ▁Al ▁>= ▁0 ▁) ▁; ▁if ▁( ▁se ▁< ▁ss ▁|| ▁se ▁> ▁63 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" SS / SE % d /% dis invalid \ n " ▁, ▁ss ▁, ▁se ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁! ▁Al ▁) ▁{ ▁s ▁-> ▁co efs _ finished ▁[ ▁c ▁] ▁|= ▁( ▁2 LL ▁<< ▁se ▁) ▁- ▁( ▁1 LL ▁<< ▁ss ▁) ▁; ▁last _ scan ▁= ▁! ▁ ~ ▁s ▁-> ▁co efs _ finished ▁[ ▁c ▁] ▁; ▁} ▁if ▁( ▁s ▁-> ▁inter l aced ▁&& ▁s ▁-> ▁bottom _ field ▁) ▁data ▁+= ▁linesize ▁>> ▁1 ▁; ▁s ▁-> ▁restart _ count ▁= ▁0 ▁; ▁for ▁( ▁mb _ y ▁= ▁0 ▁; ▁mb _ y ▁< ▁s ▁-> ▁mb _ height ▁; ▁mb _ y ▁++ ▁) ▁{ ▁uint 8_ t ▁* ▁ptr ▁= ▁data ▁+ ▁( ▁mb _ y ▁* ▁linesize ▁* ▁8 ▁>> ▁s ▁-> ▁avctx ▁-> ▁low res ▁) ▁; ▁int ▁block _ idx ▁= ▁mb _ y ▁* ▁s ▁-> ▁block _ stride ▁[ ▁c ▁] ▁; ▁int 16_ t ▁( ▁* ▁block ▁) ▁[ ▁64 ▁] ▁= ▁& ▁s ▁-> ▁blocks ▁[ ▁c ▁] ▁[ ▁block _ idx ▁] ▁; ▁uint 8_ t ▁* ▁last _ nn z ▁= ▁& ▁s ▁-> ▁last _ nn z ▁[ ▁c ▁] ▁[ ▁block _ idx ▁] ▁; ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁mb _ x ▁++ ▁, ▁block ▁++ ▁, ▁last _ nn z ▁++ ▁) ▁{ ▁int ▁ret ▁; ▁if ▁( ▁s ▁-> ▁restart _ interval ▁&& ▁! ▁s ▁-> ▁restart _ count ▁) ▁s ▁-> ▁restart _ count ▁= ▁s ▁-> ▁restart _ interval ▁; ▁if ▁( ▁Ah ▁) ▁ret ▁= ▁decode _ block _ ref inement ▁( ▁s ▁, ▁* ▁block ▁, ▁last _ nn z ▁, ▁s ▁-> ▁ac _ index ▁[ ▁0 ▁] ▁, ▁quant _ matrix ▁, ▁ss ▁, ▁se ▁, ▁Al ▁, ▁& ▁E O BR UN ▁) ▁; ▁else ▁ret ▁= ▁decode _ block _ progress ive ▁( ▁s ▁, ▁* ▁block ▁, ▁last _ nn z ▁, ▁s ▁-> ▁ac _ index ▁[ ▁0 ▁] ▁, ▁quant _ matrix ▁, ▁ss ▁, ▁se ▁, ▁Al ▁, ▁& ▁E O BR UN ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" err ory =% dx =% d \ n " ▁, ▁mb _ y ▁, ▁mb _ x ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁last _ scan ▁) ▁{ ▁s ▁-> ▁dsp ▁. ▁idct _ put ▁( ▁ptr ▁, ▁linesize ▁, ▁* ▁block ▁) ▁; ▁if ▁( ▁s ▁-> ▁bits ▁& ▁7 ▁) ▁shift _ output ▁( ▁s ▁, ▁ptr ▁, ▁linesize ▁) ▁; ▁ptr ▁+= ▁bytes _ per _ pixel ▁* ▁8 ▁>> ▁s ▁-> ▁avctx ▁-> ▁low res ▁; ▁} ▁if ▁( ▁handle _ rst n ▁( ▁s ▁, ▁0 ▁) ▁) ▁E O BR UN ▁= ▁0 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁BN _ cmp ▁( ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁) ▁{ ▁int ▁i ▁; ▁int ▁gt ▁, ▁lt ▁; ▁BN _ ULONG ▁t 1 ▁, ▁t 2 ▁; ▁if ▁( ▁( ▁a ▁== ▁NULL ▁) ▁|| ▁( ▁b ▁== ▁NULL ▁) ▁) ▁{ ▁if ▁( ▁a ▁!= ▁NULL ▁) ▁return ▁( ▁-1 ▁) ▁; ▁else ▁if ▁( ▁b ▁!= ▁NULL ▁) ▁return ▁( ▁1 ▁) ▁; ▁else ▁return ▁( ▁0 ▁) ▁; ▁} ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁a ▁-> ▁neg ▁!= ▁b ▁-> ▁neg ▁) ▁{ ▁if ▁( ▁a ▁-> ▁neg ▁) ▁return ▁( ▁-1 ▁) ▁; ▁else ▁return ▁( ▁1 ▁) ▁; ▁} ▁if ▁( ▁a ▁-> ▁neg ▁== ▁0 ▁) ▁{ ▁gt ▁= ▁1 ▁; ▁lt ▁= ▁-1 ▁; ▁} ▁else ▁{ ▁gt ▁= ▁-1 ▁; ▁lt ▁= ▁1 ▁; ▁} ▁if ▁( ▁a ▁-> ▁top ▁> ▁b ▁-> ▁top ▁) ▁return ▁( ▁gt ▁) ▁; ▁if ▁( ▁a ▁-> ▁top ▁< ▁b ▁-> ▁top ▁) ▁return ▁( ▁lt ▁) ▁; ▁for ▁( ▁i ▁= ▁a ▁-> ▁top ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁t 1 ▁= ▁a ▁-> ▁d ▁[ ▁i ▁] ▁; ▁t 2 ▁= ▁b ▁-> ▁d ▁[ ▁i ▁] ▁; ▁if ▁( ▁t 1 ▁> ▁t 2 ▁) ▁return ▁( ▁gt ▁) ▁; ▁if ▁( ▁t 1 ▁< ▁t 2 ▁) ▁return ▁( ▁lt ▁) ▁; ▁} ▁return ▁( ▁0 ▁) ▁; ▁}	1
▁static ▁int ▁output _ frame ▁( ▁H 264 Context ▁* ▁h ▁, ▁AVFrame ▁* ▁dst ▁, ▁Picture ▁* ▁srcp ▁) ▁{ ▁AVFrame ▁* ▁src ▁= ▁& ▁srcp ▁-> ▁f ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁src ▁-> ▁format ▁) ▁; ▁int ▁i ▁; ▁int ▁ret ▁= ▁av _ frame _ ref ▁( ▁dst ▁, ▁src ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁av _ dict _ set ▁( ▁& ▁dst ▁-> ▁metadata ▁, ▁" stereo _ mode " ▁, ▁ff _ h 264_ se i _ stereo _ mode ▁( ▁h ▁) ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁srcp ▁-> ▁crop ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁desc ▁-> ▁nb _ components ▁; ▁i ▁++ ▁) ▁{ ▁int ▁h shift ▁= ▁( ▁i ▁> ▁0 ▁) ▁? ▁desc ▁-> ▁log 2_ chroma _ w ▁: ▁0 ▁; ▁int ▁v shift ▁= ▁( ▁i ▁> ▁0 ▁) ▁? ▁desc ▁-> ▁log 2_ chroma _ h ▁: ▁0 ▁; ▁int ▁off ▁= ▁( ▁( ▁srcp ▁-> ▁crop _ left ▁>> ▁h shift ▁) ▁<< ▁h ▁-> ▁pixel _ shift ▁) ▁+ ▁( ▁srcp ▁-> ▁crop _ top ▁>> ▁v shift ▁) ▁* ▁dst ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁dst ▁-> ▁data ▁[ ▁i ▁] ▁+= ▁off ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁uint 8_ t ▁get _ tlm ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁int ▁n ▁) ▁{ ▁uint 8_ t ▁St lm ▁, ▁ST ▁, ▁SP ▁, ▁tile _ tlm ▁, ▁i ▁; ▁bytestream _ get _ byte ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁St lm ▁= ▁bytestream _ get _ byte ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁ST ▁= ▁( ▁St lm ▁>> ▁4 ▁) ▁& ▁0 x 03 ▁; ▁SP ▁= ▁( ▁St lm ▁>> ▁6 ▁) ▁& ▁0 x 01 ▁; ▁tile _ tlm ▁= ▁( ▁n ▁- ▁4 ▁) ▁/ ▁( ▁( ▁SP ▁+ ▁1 ▁) ▁* ▁2 ▁+ ▁ST ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tile _ tlm ▁; ▁i ▁++ ▁) ▁{ ▁switch ▁( ▁ST ▁) ▁{ ▁case ▁0 ▁: ▁break ▁; ▁case ▁1 ▁: ▁bytestream _ get _ byte ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁bytestream _ get _ be 16 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁break ▁; ▁case ▁3 ▁: ▁bytestream _ get _ be 32 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁break ▁; ▁} ▁if ▁( ▁SP ▁== ▁0 ▁) ▁{ ▁bytestream _ get _ be 16 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁} ▁else ▁{ ▁bytestream _ get _ be 32 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁d nx hd _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁D NX HD Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁Thread Frame ▁frame ▁= ▁{ ▁. ▁f ▁= ▁data ▁} ▁; ▁AVFrame ▁* ▁picture ▁= ▁data ▁; ▁int ▁first _ field ▁= ▁1 ▁; ▁int ▁ret ▁, ▁i ▁; ▁ff _ d log ▁( ▁avctx ▁, ▁" frames ize % d \ n " ▁, ▁buf _ size ▁) ▁; ▁decode _ coding _ unit ▁: ▁if ▁( ▁( ▁ret ▁= ▁d nx hd _ decode _ header ▁( ▁ctx ▁, ▁picture ▁, ▁buf ▁, ▁buf _ size ▁, ▁first _ field ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁avctx ▁-> ▁width ▁|| ▁avctx ▁-> ▁height ▁) ▁&& ▁( ▁ctx ▁-> ▁width ▁!= ▁avctx ▁-> ▁width ▁|| ▁ctx ▁-> ▁height ▁!= ▁avctx ▁-> ▁height ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" frames ize changed :% dx % d -> % dx % d \ n " ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁, ▁ctx ▁-> ▁width ▁, ▁ctx ▁-> ▁height ▁) ▁; ▁first _ field ▁= ▁1 ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ NONE ▁&& ▁avctx ▁-> ▁pix _ fmt ▁!= ▁ctx ▁-> ▁pix _ fmt ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" pix _ fmt changed :% s -> % s \ n " ▁, ▁av _ get _ pix _ fmt _ name ▁( ▁avctx ▁-> ▁pix _ fmt ▁) ▁, ▁av _ get _ pix _ fmt _ name ▁( ▁ctx ▁-> ▁pix _ fmt ▁) ▁) ▁; ▁first _ field ▁= ▁1 ▁; ▁} ▁avctx ▁-> ▁pix _ fmt ▁= ▁ctx ▁-> ▁pix _ fmt ▁; ▁ret ▁= ▁ff _ set _ dimensions ▁( ▁avctx ▁, ▁ctx ▁-> ▁width ▁, ▁ctx ▁-> ▁height ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁first _ field ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁ff _ thread _ get _ buffer ▁( ▁avctx ▁, ▁& ▁frame ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁picture ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁picture ▁-> ▁key _ frame ▁= ▁1 ▁; ▁} ▁ctx ▁-> ▁buf _ size ▁= ▁buf _ size ▁- ▁0 x 280 ▁; ▁ctx ▁-> ▁buf ▁= ▁buf ▁+ ▁0 x 280 ▁; ▁avctx ▁-> ▁execute 2 ▁( ▁avctx ▁, ▁d nx hd _ decode _ row ▁, ▁picture ▁, ▁NULL ▁, ▁ctx ▁-> ▁mb _ height ▁) ▁; ▁if ▁( ▁first _ field ▁&& ▁picture ▁-> ▁inter l aced _ frame ▁) ▁{ ▁buf ▁+= ▁ctx ▁-> ▁cid _ table ▁-> ▁coding _ unit _ size ▁; ▁buf _ size ▁-= ▁ctx ▁-> ▁cid _ table ▁-> ▁coding _ unit _ size ▁; ▁first _ field ▁= ▁0 ▁; ▁goto ▁decode _ coding _ unit ▁; ▁} ▁ret ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁+= ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁errors ▁; ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁errors ▁= ▁0 ▁; ▁} ▁if ▁( ▁ret ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"% d lines with errors \ n " ▁, ▁ret ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁* ▁got _ frame ▁= ▁1 ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁}	1
▁uintptr _ t ▁ngx _ escape _ uri ▁( ▁u _ char ▁* ▁dst ▁, ▁u _ char ▁* ▁src ▁, ▁size _ t ▁size ▁, ▁ngx _ uint _ t ▁type ▁) ▁{ ▁ngx _ uint _ t ▁i ▁, ▁n ▁; ▁uint 32_ t ▁* ▁escape ▁; ▁static ▁u _ char ▁hex ▁[ ▁] ▁= ▁"0123456789 abcdef " ▁; ▁static ▁uint 32_ t ▁uri ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 8 000002 9 ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁args ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 80000 829 ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁html ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 000000 ad ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁refresh ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 000000 85 ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁memcached ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 000000 21 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁} ▁; ▁static ▁uint 32_ t ▁* ▁map ▁[ ▁] ▁= ▁{ ▁uri ▁, ▁args ▁, ▁html ▁, ▁refresh ▁, ▁memcached ▁, ▁memcached ▁} ▁; ▁escape ▁= ▁map ▁[ ▁type ▁] ▁; ▁if ▁( ▁dst ▁== ▁NULL ▁) ▁{ ▁n ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁escape ▁[ ▁* ▁src ▁>> ▁5 ▁] ▁& ▁( ▁1 ▁<< ▁( ▁* ▁src ▁& ▁0 x 1 f ▁) ▁) ▁) ▁{ ▁n ▁++ ▁; ▁} ▁src ▁++ ▁; ▁} ▁return ▁( ▁uintptr _ t ▁) ▁n ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁escape ▁[ ▁* ▁src ▁>> ▁5 ▁] ▁& ▁( ▁1 ▁<< ▁( ▁* ▁src ▁& ▁0 x 1 f ▁) ▁) ▁) ▁{ ▁* ▁dst ▁++ ▁= ▁' ▁' ▁; ▁* ▁dst ▁++ ▁= ▁hex ▁[ ▁* ▁src ▁>> ▁4 ▁] ▁; ▁* ▁dst ▁++ ▁= ▁hex ▁[ ▁* ▁src ▁& ▁0 xf ▁] ▁; ▁src ▁++ ▁; ▁} ▁else ▁{ ▁* ▁dst ▁++ ▁= ▁* ▁src ▁++ ▁; ▁} ▁} ▁return ▁( ▁uintptr _ t ▁) ▁dst ▁; ▁}	1
▁int ▁ff v 1_ init _ slice _ contexts ▁( ▁FF V 1 Context ▁* ▁f ▁) ▁{ ▁int ▁i ▁; ▁f ▁-> ▁slice _ count ▁= ▁f ▁-> ▁num _ h _ s lices ▁* ▁f ▁-> ▁num _ v _ s lices ▁; ▁av _ assert 0 ▁( ▁f ▁-> ▁slice _ count ▁> ▁0 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁f ▁-> ▁slice _ count ▁; ▁i ▁++ ▁) ▁{ ▁FF V 1 Context ▁* ▁fs ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁fs ▁) ▁) ▁; ▁int ▁sx ▁= ▁i ▁% ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁sy ▁= ▁i ▁/ ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁s xs ▁= ▁f ▁-> ▁avctx ▁-> ▁width ▁* ▁sx ▁/ ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁s xe ▁= ▁f ▁-> ▁avctx ▁-> ▁width ▁* ▁( ▁sx ▁+ ▁1 ▁) ▁/ ▁f ▁-> ▁num _ h _ s lices ▁; ▁int ▁sys ▁= ▁f ▁-> ▁avctx ▁-> ▁height ▁* ▁sy ▁/ ▁f ▁-> ▁num _ v _ s lices ▁; ▁int ▁sy e ▁= ▁f ▁-> ▁avctx ▁-> ▁height ▁* ▁( ▁sy ▁+ ▁1 ▁) ▁/ ▁f ▁-> ▁num _ v _ s lices ▁; ▁if ▁( ▁! ▁fs ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁f ▁-> ▁slice _ context ▁[ ▁i ▁] ▁= ▁fs ▁; ▁memcpy ▁( ▁fs ▁, ▁f ▁, ▁sizeof ▁( ▁* ▁fs ▁) ▁) ▁; ▁memset ▁( ▁fs ▁-> ▁rc _ stat 2 ▁, ▁0 ▁, ▁sizeof ▁( ▁fs ▁-> ▁rc _ stat 2 ▁) ▁) ▁; ▁fs ▁-> ▁slice _ width ▁= ▁s xe ▁- ▁s xs ▁; ▁fs ▁-> ▁slice _ height ▁= ▁sy e ▁- ▁sys ▁; ▁fs ▁-> ▁slice _ x ▁= ▁s xs ▁; ▁fs ▁-> ▁slice _ y ▁= ▁sys ▁; ▁fs ▁-> ▁sample _ buffer ▁= ▁av _ malloc ▁( ▁3 ▁* ▁MAX _ PLAN ES ▁* ▁( ▁fs ▁-> ▁width ▁+ ▁6 ▁) ▁* ▁sizeof ▁( ▁* ▁fs ▁-> ▁sample _ buffer ▁) ▁) ▁; ▁if ▁( ▁! ▁fs ▁-> ▁sample _ buffer ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁tls 13_ generate _ secret ▁( ▁SSL ▁* ▁s ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁const ▁unsigned ▁char ▁* ▁prev secret ▁, ▁const ▁unsigned ▁char ▁* ▁in secret ▁, ▁size _ t ▁in secret len ▁, ▁unsigned ▁char ▁* ▁out secret ▁) ▁{ ▁size _ t ▁md len ▁, ▁prev secret len ▁; ▁int ▁md len i ▁; ▁int ▁ret ▁; ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new _ id ▁( ▁EVP _ PKEY _ HK DF ▁, ▁NULL ▁) ▁; ▁static ▁const ▁char ▁derived _ secret _ label ▁[ ▁] ▁= ▁" derived " ▁; ▁unsigned ▁char ▁p ree x tract sec ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁if ▁( ▁pctx ▁== ▁NULL ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS 13_ GENERATE _ SECRET ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁md len i ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁if ▁( ▁! ▁ossl _ assert ▁( ▁md len i ▁>= ▁0 ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS 13_ GENERATE _ SECRET ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁md len ▁= ▁( ▁size _ t ▁) ▁md len i ▁; ▁if ▁( ▁in secret ▁== ▁NULL ▁) ▁{ ▁in secret ▁= ▁default _ zeros ▁; ▁in secret len ▁= ▁md len ▁; ▁} ▁if ▁( ▁prev secret ▁== ▁NULL ▁) ▁{ ▁prev secret ▁= ▁default _ zeros ▁; ▁prev secret len ▁= ▁0 ▁; ▁} ▁else ▁{ ▁EVP _ MD _ CTX ▁* ▁mctx ▁= ▁EVP _ MD _ CTX _ new ▁( ▁) ▁; ▁unsigned ▁char ▁hash ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁if ▁( ▁mctx ▁== ▁NULL ▁|| ▁EVP _ Digest Init _ ex ▁( ▁mctx ▁, ▁md ▁, ▁NULL ▁) ▁<= ▁0 ▁|| ▁EVP _ Digest Final _ ex ▁( ▁mctx ▁, ▁hash ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS 13_ GENERATE _ SECRET ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁EVP _ MD _ CTX _ free ▁( ▁mctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁0 ▁; ▁} ▁EVP _ MD _ CTX _ free ▁( ▁mctx ▁) ▁; ▁if ▁( ▁! ▁tls 13_ h kdf _ expand ▁( ▁s ▁, ▁md ▁, ▁prev secret ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁derived _ secret _ label ▁, ▁sizeof ▁( ▁derived _ secret _ label ▁) ▁- ▁1 ▁, ▁hash ▁, ▁md len ▁, ▁p ree x tract sec ▁, ▁md len ▁, ▁1 ▁) ▁) ▁{ ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁0 ▁; ▁} ▁prev secret ▁= ▁p ree x tract sec ▁; ▁prev secret len ▁= ▁md len ▁; ▁} ▁ret ▁= ▁EVP _ PKEY _ der ive _ init ▁( ▁pctx ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ h kdf _ mode ▁( ▁pctx ▁, ▁EVP _ PKEY _ HK DEF _ MODE _ EXTRACT _ ONLY ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set _ h kdf _ md ▁( ▁pctx ▁, ▁md ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set 1_ h kdf _ key ▁( ▁pctx ▁, ▁in secret ▁, ▁in secret len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set 1_ h kdf _ salt ▁( ▁pctx ▁, ▁prev secret ▁, ▁prev secret len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ der ive ▁( ▁pctx ▁, ▁out secret ▁, ▁& ▁md len ▁) ▁<= ▁0 ▁; ▁if ▁( ▁ret ▁!= ▁0 ▁) ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS 13_ GENERATE _ SECRET ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁if ▁( ▁prev secret ▁== ▁p ree x tract sec ▁) ▁OPENSSL _ cleanse ▁( ▁p ree x tract sec ▁, ▁md len ▁) ▁; ▁return ▁ret ▁== ▁0 ▁; ▁}	0
▁static ▁int ▁parse _ picture _ segment ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁PG SS ub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁uint 8_ t ▁sequence _ desc ▁; ▁unsigned ▁int ▁r le _ bitmap _ len ▁, ▁width ▁, ▁height ▁; ▁uint 16_ t ▁picture _ id ▁; ▁if ▁( ▁buf _ size ▁<= ▁4 ▁) ▁return ▁-1 ▁; ▁buf _ size ▁-= ▁4 ▁; ▁picture _ id ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁buf ▁) ▁; ▁buf ▁++ ▁; ▁sequence _ desc ▁= ▁bytestream _ get _ byte ▁( ▁& ▁buf ▁) ▁; ▁if ▁( ▁! ▁( ▁sequence _ desc ▁& ▁0 x 80 ▁) ▁) ▁{ ▁if ▁( ▁buf _ size ▁> ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le _ remaining _ len ▁) ▁return ▁-1 ▁; ▁memcpy ▁( ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le ▁+ ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le _ data _ len ▁, ▁buf ▁, ▁buf _ size ▁) ▁; ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le _ data _ len ▁+= ▁buf _ size ▁; ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le _ remaining _ len ▁-= ▁buf _ size ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁buf _ size ▁<= ▁7 ▁) ▁return ▁-1 ▁; ▁buf _ size ▁-= ▁7 ▁; ▁r le _ bitmap _ len ▁= ▁bytestream _ get _ be 24 ▁( ▁& ▁buf ▁) ▁- ▁2 ▁* ▁2 ▁; ▁width ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁buf ▁) ▁; ▁height ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁buf ▁) ▁; ▁if ▁( ▁avctx ▁-> ▁width ▁< ▁width ▁|| ▁avctx ▁-> ▁height ▁< ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bitmap dimensions l arger than video .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁buf _ size ▁> ▁r le _ bitmap _ len ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" t oom uch R LE data \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁w ▁= ▁width ▁; ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁h ▁= ▁height ▁; ▁av _ fast _ pad ded _ malloc ▁( ▁& ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le ▁, ▁& ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le _ buffer _ size ▁, ▁r le _ bitmap _ len ▁) ▁; ▁if ▁( ▁! ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le ▁) ▁return ▁-1 ▁; ▁memcpy ▁( ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le ▁, ▁buf ▁, ▁buf _ size ▁) ▁; ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le _ data _ len ▁= ▁buf _ size ▁; ▁ctx ▁-> ▁pict ures ▁[ ▁picture _ id ▁] ▁. ▁r le _ remaining _ len ▁= ▁r le _ bitmap _ len ▁- ▁buf _ size ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁dvb sub _ parse _ cl ut _ segment ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁DVB Sub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁uint 8_ t ▁* ▁buf _ end ▁= ▁buf ▁+ ▁buf _ size ▁; ▁int ▁i ▁, ▁cl ut _ id ▁; ▁DVB Sub CL UT ▁* ▁cl ut ▁; ▁int ▁entry _ id ▁, ▁depth ▁, ▁full _ range ▁; ▁int ▁y ▁, ▁cr ▁, ▁cb ▁, ▁alpha ▁; ▁int ▁r ▁, ▁g ▁, ▁b ▁, ▁r _ add ▁, ▁g _ add ▁, ▁b _ add ▁; ▁av _ d log ▁( ▁avctx ▁, ▁" D VB cl ut packet :\ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁buf _ size ▁; ▁i ▁++ ▁) ▁{ ▁av _ d log ▁( ▁avctx ▁, ▁"%02 x " ▁, ▁buf ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁i ▁% ▁16 ▁== ▁15 ▁) ▁av _ d log ▁( ▁avctx ▁, ▁"\ n " ▁) ▁; ▁} ▁if ▁( ▁i ▁% ▁16 ▁) ▁av _ d log ▁( ▁avctx ▁, ▁"\ n " ▁) ▁; ▁cl ut _ id ▁= ▁* ▁buf ▁++ ▁; ▁buf ▁+= ▁1 ▁; ▁cl ut ▁= ▁get _ cl ut ▁( ▁ctx ▁, ▁cl ut _ id ▁) ▁; ▁if ▁( ▁! ▁cl ut ▁) ▁{ ▁cl ut ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁DVB Sub CL UT ▁) ▁) ▁; ▁memcpy ▁( ▁cl ut ▁, ▁& ▁default _ cl ut ▁, ▁sizeof ▁( ▁DVB Sub CL UT ▁) ▁) ▁; ▁cl ut ▁-> ▁id ▁= ▁cl ut _ id ▁; ▁cl ut ▁-> ▁next ▁= ▁ctx ▁-> ▁cl ut _ list ▁; ▁ctx ▁-> ▁cl ut _ list ▁= ▁cl ut ▁; ▁} ▁while ▁( ▁buf ▁+ ▁4 ▁< ▁buf _ end ▁) ▁{ ▁entry _ id ▁= ▁* ▁buf ▁++ ▁; ▁depth ▁= ▁( ▁* ▁buf ▁) ▁& ▁0 xe 0 ▁; ▁if ▁( ▁depth ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid cl ut depth 0 x % x !\ n " ▁, ▁* ▁buf ▁) ▁; ▁return ▁; ▁} ▁full _ range ▁= ▁( ▁* ▁buf ▁++ ▁) ▁& ▁1 ▁; ▁if ▁( ▁full _ range ▁) ▁{ ▁y ▁= ▁* ▁buf ▁++ ▁; ▁cr ▁= ▁* ▁buf ▁++ ▁; ▁cb ▁= ▁* ▁buf ▁++ ▁; ▁alpha ▁= ▁* ▁buf ▁++ ▁; ▁} ▁else ▁{ ▁y ▁= ▁buf ▁[ ▁0 ▁] ▁& ▁0 xfc ▁; ▁cr ▁= ▁( ▁( ▁( ▁buf ▁[ ▁0 ▁] ▁& ▁3 ▁) ▁<< ▁2 ▁) ▁| ▁( ▁( ▁buf ▁[ ▁1 ▁] ▁>> ▁6 ▁) ▁& ▁3 ▁) ▁) ▁<< ▁4 ▁; ▁cb ▁= ▁( ▁buf ▁[ ▁1 ▁] ▁<< ▁2 ▁) ▁& ▁0 xf 0 ▁; ▁alpha ▁= ▁( ▁buf ▁[ ▁1 ▁] ▁<< ▁6 ▁) ▁& ▁0 xc 0 ▁; ▁buf ▁+= ▁2 ▁; ▁} ▁if ▁( ▁y ▁== ▁0 ▁) ▁alpha ▁= ▁0 xff ▁; ▁Y UV _ TO _ RGB 1_ CC IR ▁( ▁cb ▁, ▁cr ▁) ▁; ▁Y UV _ TO _ RGB 2_ CC IR ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁y ▁) ▁; ▁av _ d log ▁( ▁avctx ▁, ▁" cl ut % d : = (% d ,% d ,% d ,% d )\ n " ▁, ▁entry _ id ▁, ▁r ▁, ▁g ▁, ▁b ▁, ▁alpha ▁) ▁; ▁if ▁( ▁depth ▁& ▁0 x 80 ▁) ▁cl ut ▁-> ▁cl ut 4 ▁[ ▁entry _ id ▁] ▁= ▁RGBA ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁255 ▁- ▁alpha ▁) ▁; ▁if ▁( ▁depth ▁& ▁0 x 40 ▁) ▁cl ut ▁-> ▁cl ut 16 ▁[ ▁entry _ id ▁] ▁= ▁RGBA ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁255 ▁- ▁alpha ▁) ▁; ▁if ▁( ▁depth ▁& ▁0 x 20 ▁) ▁cl ut ▁-> ▁cl ut 256 ▁[ ▁entry _ id ▁] ▁= ▁RGBA ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁255 ▁- ▁alpha ▁) ▁; ▁} ▁}	1
▁int ▁EVP _ PBE _ scrypt ▁( ▁const ▁char ▁* ▁pass ▁, ▁size _ t ▁passlen ▁, ▁const ▁unsigned ▁char ▁* ▁salt ▁, ▁size _ t ▁saltlen ▁, ▁uint 64_ t ▁N ▁, ▁uint 64_ t ▁r ▁, ▁uint 64_ t ▁p ▁, ▁uint 64_ t ▁max mem ▁, ▁unsigned ▁char ▁* ▁key ▁, ▁size _ t ▁keylen ▁) ▁{ ▁int ▁rv ▁= ▁0 ▁; ▁unsigned ▁char ▁* ▁B ▁; ▁uint 32_ t ▁* ▁X ▁, ▁* ▁V ▁, ▁* ▁T ▁; ▁uint 64_ t ▁i ▁, ▁B len ▁, ▁V len ▁; ▁if ▁( ▁r ▁== ▁0 ▁|| ▁p ▁== ▁0 ▁|| ▁N ▁< ▁2 ▁|| ▁( ▁N ▁& ▁( ▁N ▁- ▁1 ▁) ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁p ▁> ▁S CRYPT _ PR _ MAX ▁/ ▁r ▁) ▁return ▁0 ▁; ▁if ▁( ▁16 ▁* ▁r ▁<= ▁LOG 2_ UINT 64_ MAX ▁) ▁{ ▁if ▁( ▁N ▁>= ▁( ▁( ▁( ▁uint 64_ t ▁) ▁1 ▁) ▁<< ▁( ▁16 ▁* ▁r ▁) ▁) ▁) ▁return ▁0 ▁; ▁} ▁B len ▁= ▁p ▁* ▁128 ▁* ▁r ▁; ▁i ▁= ▁UINT 64_ MAX ▁/ ▁( ▁32 ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁) ▁; ▁if ▁( ▁N ▁+ ▁2 ▁> ▁i ▁/ ▁r ▁) ▁return ▁0 ▁; ▁V len ▁= ▁32 ▁* ▁r ▁* ▁( ▁N ▁+ ▁2 ▁) ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁; ▁if ▁( ▁B len ▁> ▁UINT 64_ MAX ▁- ▁V len ▁) ▁return ▁0 ▁; ▁if ▁( ▁max mem ▁== ▁0 ▁) ▁max mem ▁= ▁S CRYPT _ MAX _ MEM ▁; ▁if ▁( ▁max mem ▁> ▁SIZE _ MAX ▁) ▁max mem ▁= ▁SIZE _ MAX ▁; ▁if ▁( ▁B len ▁+ ▁V len ▁> ▁max mem ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ PBE _ SCR YPT ▁, ▁EVP _ R _ MEMORY _ LIMIT _ EXCEEDED ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁key ▁== ▁NULL ▁) ▁return ▁1 ▁; ▁B ▁= ▁OPENSSL _ malloc ▁( ▁B len ▁+ ▁V len ▁) ▁; ▁if ▁( ▁B ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁X ▁= ▁( ▁uint 32_ t ▁* ▁) ▁( ▁B ▁+ ▁B len ▁) ▁; ▁T ▁= ▁X ▁+ ▁32 ▁* ▁r ▁; ▁V ▁= ▁T ▁+ ▁32 ▁* ▁r ▁; ▁if ▁( ▁PKCS 5_ PB KDF 2_ HMAC ▁( ▁pass ▁, ▁passlen ▁, ▁salt ▁, ▁saltlen ▁, ▁1 ▁, ▁EVP _ sha 256 ▁( ▁) ▁, ▁B len ▁, ▁B ▁) ▁== ▁0 ▁) ▁goto ▁err ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁; ▁i ▁++ ▁) ▁sc rypt ROM ix ▁( ▁B ▁+ ▁128 ▁* ▁r ▁* ▁i ▁, ▁r ▁, ▁N ▁, ▁X ▁, ▁T ▁, ▁V ▁) ▁; ▁if ▁( ▁PKCS 5_ PB KDF 2_ HMAC ▁( ▁pass ▁, ▁passlen ▁, ▁B ▁, ▁B len ▁, ▁1 ▁, ▁EVP _ sha 256 ▁( ▁) ▁, ▁keylen ▁, ▁key ▁) ▁== ▁0 ▁) ▁goto ▁err ▁; ▁rv ▁= ▁1 ▁; ▁err ▁: ▁OPENSSL _ clear _ free ▁( ▁B ▁, ▁B len ▁+ ▁V len ▁) ▁; ▁return ▁rv ▁; ▁}	1
▁static ▁int ▁dv _ extract _ audio ▁( ▁uint 8_ t ▁* ▁frame ▁, ▁uint 8_ t ▁* ▁p pcm ▁[ ▁4 ▁] ▁, ▁const ▁DV profile ▁* ▁sys ▁) ▁{ ▁int ▁size ▁, ▁chan ▁, ▁i ▁, ▁j ▁, ▁d ▁, ▁of ▁, ▁s mpl s ▁, ▁freq ▁, ▁quant ▁, ▁half _ ch ▁; ▁uint 16_ t ▁lc ▁, ▁rc ▁; ▁const ▁uint 8_ t ▁* ▁as _ pack ▁; ▁uint 8_ t ▁* ▁pcm ▁, ▁i pcm ▁; ▁as _ pack ▁= ▁dv _ extract _ pack ▁( ▁frame ▁, ▁dv _ audio _ source ▁) ▁; ▁if ▁( ▁! ▁as _ pack ▁) ▁return ▁0 ▁; ▁s mpl s ▁= ▁as _ pack ▁[ ▁1 ▁] ▁& ▁0 x 3 f ▁; ▁freq ▁= ▁( ▁as _ pack ▁[ ▁4 ▁] ▁>> ▁3 ▁) ▁& ▁0 x 07 ▁; ▁quant ▁= ▁as _ pack ▁[ ▁4 ▁] ▁& ▁0 x 07 ▁; ▁if ▁( ▁quant ▁> ▁1 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁freq ▁>= ▁FF _ ARRAY _ ELEMS ▁( ▁dv _ audio _ frequency ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁size ▁= ▁( ▁sys ▁-> ▁audio _ min _ samples ▁[ ▁freq ▁] ▁+ ▁s mpl s ▁) ▁* ▁4 ▁; ▁half _ ch ▁= ▁sys ▁-> ▁dif seg _ size ▁/ ▁2 ▁; ▁i pcm ▁= ▁( ▁sys ▁-> ▁height ▁== ▁720 ▁&& ▁! ▁( ▁frame ▁[ ▁1 ▁] ▁& ▁0 x 0 C ▁) ▁) ▁? ▁2 ▁: ▁0 ▁; ▁for ▁( ▁chan ▁= ▁0 ▁; ▁chan ▁< ▁sys ▁-> ▁n _ dif chan ▁; ▁chan ▁++ ▁) ▁{ ▁pcm ▁= ▁p pcm ▁[ ▁i pcm ▁++ ▁] ▁; ▁if ▁( ▁! ▁pcm ▁) ▁break ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sys ▁-> ▁dif seg _ size ▁; ▁i ▁++ ▁) ▁{ ▁frame ▁+= ▁6 ▁* ▁80 ▁; ▁if ▁( ▁quant ▁== ▁1 ▁&& ▁i ▁== ▁half _ ch ▁) ▁{ ▁pcm ▁= ▁p pcm ▁[ ▁i pcm ▁++ ▁] ▁; ▁if ▁( ▁! ▁pcm ▁) ▁break ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁9 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁d ▁= ▁8 ▁; ▁d ▁< ▁80 ▁; ▁d ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁quant ▁== ▁0 ▁) ▁{ ▁of ▁= ▁sys ▁-> ▁audio _ shuffle ▁[ ▁i ▁] ▁[ ▁j ▁] ▁+ ▁( ▁d ▁- ▁8 ▁) ▁/ ▁2 ▁* ▁sys ▁-> ▁audio _ stride ▁; ▁if ▁( ▁of ▁* ▁2 ▁>= ▁size ▁) ▁continue ▁; ▁pcm ▁[ ▁of ▁* ▁2 ▁] ▁= ▁frame ▁[ ▁d ▁+ ▁1 ▁] ▁; ▁pcm ▁[ ▁of ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁frame ▁[ ▁d ▁] ▁; ▁if ▁( ▁pcm ▁[ ▁of ▁* ▁2 ▁+ ▁1 ▁] ▁== ▁0 x 80 ▁&& ▁pcm ▁[ ▁of ▁* ▁2 ▁] ▁== ▁0 x 00 ▁) ▁pcm ▁[ ▁of ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁} ▁else ▁{ ▁lc ▁= ▁( ▁( ▁uint 16_ t ▁) ▁frame ▁[ ▁d ▁] ▁<< ▁4 ▁) ▁| ▁( ▁( ▁uint 16_ t ▁) ▁frame ▁[ ▁d ▁+ ▁2 ▁] ▁>> ▁4 ▁) ▁; ▁rc ▁= ▁( ▁( ▁uint 16_ t ▁) ▁frame ▁[ ▁d ▁+ ▁1 ▁] ▁<< ▁4 ▁) ▁| ▁( ▁( ▁uint 16_ t ▁) ▁frame ▁[ ▁d ▁+ ▁2 ▁] ▁& ▁0 x 0 f ▁) ▁; ▁lc ▁= ▁( ▁lc ▁== ▁0 x 800 ▁? ▁0 ▁: ▁dv _ audio _12 to 16 ▁( ▁lc ▁) ▁) ▁; ▁rc ▁= ▁( ▁rc ▁== ▁0 x 800 ▁? ▁0 ▁: ▁dv _ audio _12 to 16 ▁( ▁rc ▁) ▁) ▁; ▁of ▁= ▁sys ▁-> ▁audio _ shuffle ▁[ ▁i ▁% ▁half _ ch ▁] ▁[ ▁j ▁] ▁+ ▁( ▁d ▁- ▁8 ▁) ▁/ ▁3 ▁* ▁sys ▁-> ▁audio _ stride ▁; ▁if ▁( ▁of ▁* ▁2 ▁>= ▁size ▁) ▁continue ▁; ▁pcm ▁[ ▁of ▁* ▁2 ▁] ▁= ▁lc ▁& ▁0 xff ▁; ▁pcm ▁[ ▁of ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁lc ▁>> ▁8 ▁; ▁of ▁= ▁sys ▁-> ▁audio _ shuffle ▁[ ▁i ▁% ▁half _ ch ▁+ ▁half _ ch ▁] ▁[ ▁j ▁] ▁+ ▁( ▁d ▁- ▁8 ▁) ▁/ ▁3 ▁* ▁sys ▁-> ▁audio _ stride ▁; ▁pcm ▁[ ▁of ▁* ▁2 ▁] ▁= ▁rc ▁& ▁0 xff ▁; ▁pcm ▁[ ▁of ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁rc ▁>> ▁8 ▁; ▁++ ▁d ▁; ▁} ▁} ▁frame ▁+= ▁16 ▁* ▁80 ▁; ▁} ▁} ▁} ▁return ▁size ▁; ▁}	0
▁void ▁ff _ ms pel _ motion ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁int ▁motion _ x ▁, ▁int ▁motion _ y ▁, ▁int ▁h ▁) ▁{ ▁W mv 2 Context ▁* ▁const ▁w ▁= ▁( ▁W mv 2 Context ▁* ▁) ▁s ▁; ▁uint 8_ t ▁* ▁ptr ▁; ▁int ▁d xy ▁, ▁offset ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁, ▁v _ edge _ pos ▁, ▁linesize ▁, ▁uv lines ize ▁; ▁int ▁emu ▁= ▁0 ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁d xy ▁= ▁2 ▁* ▁d xy ▁+ ▁w ▁-> ▁h shift ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁1 ▁) ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁16 ▁+ ▁( ▁motion _ y ▁>> ▁1 ▁) ▁; ▁v _ edge _ pos ▁= ▁s ▁-> ▁v _ edge _ pos ▁; ▁src _ x ▁= ▁av _ clip ▁( ▁src _ x ▁, ▁-16 ▁, ▁s ▁-> ▁width ▁) ▁; ▁src _ y ▁= ▁av _ clip ▁( ▁src _ y ▁, ▁-16 ▁, ▁s ▁-> ▁height ▁) ▁; ▁if ▁( ▁src _ x ▁<= ▁-16 ▁|| ▁src _ x ▁>= ▁s ▁-> ▁width ▁) ▁d xy ▁&= ▁ ~ ▁3 ▁; ▁if ▁( ▁src _ y ▁<= ▁-16 ▁|| ▁src _ y ▁>= ▁s ▁-> ▁height ▁) ▁d xy ▁&= ▁ ~ ▁4 ▁; ▁linesize ▁= ▁s ▁-> ▁linesize ▁; ▁uv lines ize ▁= ▁s ▁-> ▁uv lines ize ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁( ▁src _ y ▁* ▁linesize ▁) ▁+ ▁src _ x ▁; ▁if ▁( ▁src _ x ▁< ▁1 ▁|| ▁src _ y ▁< ▁1 ▁|| ▁src _ x ▁+ ▁17 ▁>= ▁s ▁-> ▁h _ edge _ pos ▁|| ▁src _ y ▁+ ▁h ▁+ ▁1 ▁>= ▁v _ edge _ pos ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁- ▁1 ▁- ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁linesize ▁, ▁19 ▁, ▁19 ▁, ▁src _ x ▁- ▁1 ▁, ▁src _ y ▁- ▁1 ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁+ ▁1 ▁+ ▁s ▁-> ▁linesize ▁; ▁emu ▁= ▁1 ▁; ▁} ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr ▁, ▁linesize ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁, ▁ptr ▁+ ▁8 ▁, ▁linesize ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁* ▁linesize ▁, ▁ptr ▁+ ▁8 ▁* ▁linesize ▁, ▁linesize ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁+ ▁8 ▁* ▁linesize ▁, ▁ptr ▁+ ▁8 ▁+ ▁8 ▁* ▁linesize ▁, ▁linesize ▁) ▁; ▁if ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁return ▁; ▁if ▁( ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 263 ▁) ▁{ ▁d xy ▁= ▁0 ▁; ▁if ▁( ▁( ▁motion _ x ▁& ▁3 ▁) ▁!= ▁0 ▁) ▁d xy ▁|= ▁1 ▁; ▁if ▁( ▁( ▁motion _ y ▁& ▁3 ▁) ▁!= ▁0 ▁) ▁d xy ▁|= ▁2 ▁; ▁mx ▁= ▁motion _ x ▁>> ▁2 ▁; ▁my ▁= ▁motion _ y ▁>> ▁2 ▁; ▁} ▁else ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁/ ▁2 ▁; ▁d xy ▁= ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁mx ▁>>= ▁1 ▁; ▁my ▁>>= ▁1 ▁; ▁} ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁8 ▁+ ▁my ▁; ▁src _ x ▁= ▁av _ clip ▁( ▁src _ x ▁, ▁-8 ▁, ▁s ▁-> ▁width ▁>> ▁1 ▁) ▁; ▁if ▁( ▁src _ x ▁== ▁( ▁s ▁-> ▁width ▁>> ▁1 ▁) ▁) ▁d xy ▁&= ▁ ~ ▁1 ▁; ▁src _ y ▁= ▁av _ clip ▁( ▁src _ y ▁, ▁-8 ▁, ▁s ▁-> ▁height ▁>> ▁1 ▁) ▁; ▁if ▁( ▁src _ y ▁== ▁( ▁s ▁-> ▁height ▁>> ▁1 ▁) ▁) ▁d xy ▁&= ▁ ~ ▁2 ▁; ▁offset ▁= ▁( ▁src _ y ▁* ▁uv lines ize ▁) ▁+ ▁src _ x ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁offset ▁; ▁if ▁( ▁emu ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁} ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁offset ▁; ▁if ▁( ▁emu ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁} ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁}	1
▁static ▁void ▁reverse _ dc _ pred iction ▁( ▁V p 3 Decode Context ▁* ▁s ▁, ▁int ▁first _ fragment ▁, ▁int ▁fragment _ width ▁, ▁int ▁fragment _ height ▁) ▁{ ▁# define ▁P UL ▁8 ▁# define ▁PU ▁4 ▁# define ▁PUR ▁2 ▁# define ▁PL ▁1 ▁int ▁x ▁, ▁y ▁; ▁int ▁i ▁= ▁first _ fragment ▁; ▁int ▁predicted _ dc ▁; ▁int ▁vl ▁, ▁vul ▁, ▁vu ▁, ▁v ur ▁; ▁int ▁l ▁, ▁ul ▁, ▁u ▁, ▁ur ▁; ▁static ▁const ▁int ▁predictor _ transform ▁[ ▁16 ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁128 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁128 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁53 ▁, ▁75 ▁} ▁, ▁{ ▁0 ▁, ▁128 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁64 ▁, ▁0 ▁, ▁64 ▁} ▁, ▁{ ▁0 ▁, ▁128 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁53 ▁, ▁75 ▁} ▁, ▁{ ▁128 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁128 ▁} ▁, ▁{ ▁64 ▁, ▁0 ▁, ▁64 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁0 ▁, ▁53 ▁, ▁75 ▁} ▁, ▁{ ▁0 ▁, ▁128 ▁, ▁0 ▁, ▁0 ▁} ▁, ▁{ ▁-10 4 ▁, ▁116 ▁, ▁0 ▁, ▁116 ▁} ▁, ▁{ ▁24 ▁, ▁80 ▁, ▁24 ▁, ▁0 ▁} ▁, ▁{ ▁-10 4 ▁, ▁116 ▁, ▁0 ▁, ▁116 ▁} ▁} ▁; ▁static ▁const ▁unsigned ▁char ▁compatible _ frame ▁[ ▁8 ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁2 ▁, ▁2 ▁, ▁1 ▁} ▁; ▁int ▁current _ frame _ type ▁; ▁short ▁last _ dc ▁[ ▁3 ▁] ▁; ▁int ▁transform ▁= ▁0 ▁; ▁vul ▁= ▁vu ▁= ▁v ur ▁= ▁vl ▁= ▁0 ▁; ▁last _ dc ▁[ ▁0 ▁] ▁= ▁last _ dc ▁[ ▁1 ▁] ▁= ▁last _ dc ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁fragment _ height ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁fragment _ width ▁; ▁x ▁++ ▁, ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁all _ frag ments ▁[ ▁i ▁] ▁. ▁coding _ method ▁!= ▁MODE _ COPY ▁) ▁{ ▁current _ frame _ type ▁= ▁compatible _ frame ▁[ ▁s ▁-> ▁all _ frag ments ▁[ ▁i ▁] ▁. ▁coding _ method ▁] ▁; ▁transform ▁= ▁0 ▁; ▁if ▁( ▁x ▁) ▁{ ▁l ▁= ▁i ▁- ▁1 ▁; ▁vl ▁= ▁DC _ CO EFF ▁( ▁l ▁) ▁; ▁if ▁( ▁FRAME _ CODED ▁( ▁l ▁) ▁&& ▁COMP ATI BLE _ FRAME ▁( ▁l ▁) ▁) ▁transform ▁|= ▁PL ▁; ▁} ▁if ▁( ▁y ▁) ▁{ ▁u ▁= ▁i ▁- ▁fragment _ width ▁; ▁vu ▁= ▁DC _ CO EFF ▁( ▁u ▁) ▁; ▁if ▁( ▁FRAME _ CODED ▁( ▁u ▁) ▁&& ▁COMP ATI BLE _ FRAME ▁( ▁u ▁) ▁) ▁transform ▁|= ▁PU ▁; ▁if ▁( ▁x ▁) ▁{ ▁ul ▁= ▁i ▁- ▁fragment _ width ▁- ▁1 ▁; ▁vul ▁= ▁DC _ CO EFF ▁( ▁ul ▁) ▁; ▁if ▁( ▁FRAME _ CODED ▁( ▁ul ▁) ▁&& ▁COMP ATI BLE _ FRAME ▁( ▁ul ▁) ▁) ▁transform ▁|= ▁P UL ▁; ▁} ▁if ▁( ▁x ▁+ ▁1 ▁< ▁fragment _ width ▁) ▁{ ▁ur ▁= ▁i ▁- ▁fragment _ width ▁+ ▁1 ▁; ▁v ur ▁= ▁DC _ CO EFF ▁( ▁ur ▁) ▁; ▁if ▁( ▁FRAME _ CODED ▁( ▁ur ▁) ▁&& ▁COMP ATI BLE _ FRAME ▁( ▁ur ▁) ▁) ▁transform ▁|= ▁PUR ▁; ▁} ▁} ▁if ▁( ▁transform ▁== ▁0 ▁) ▁{ ▁predicted _ dc ▁= ▁last _ dc ▁[ ▁current _ frame _ type ▁] ▁; ▁} ▁else ▁{ ▁predicted _ dc ▁= ▁( ▁predictor _ transform ▁[ ▁transform ▁] ▁[ ▁0 ▁] ▁* ▁vul ▁) ▁+ ▁( ▁predictor _ transform ▁[ ▁transform ▁] ▁[ ▁1 ▁] ▁* ▁vu ▁) ▁+ ▁( ▁predictor _ transform ▁[ ▁transform ▁] ▁[ ▁2 ▁] ▁* ▁v ur ▁) ▁+ ▁( ▁predictor _ transform ▁[ ▁transform ▁] ▁[ ▁3 ▁] ▁* ▁vl ▁) ▁; ▁predicted _ dc ▁/= ▁128 ▁; ▁if ▁( ▁( ▁transform ▁== ▁13 ▁) ▁|| ▁( ▁transform ▁== ▁15 ▁) ▁) ▁{ ▁if ▁( ▁FF ABS ▁( ▁predicted _ dc ▁- ▁vu ▁) ▁> ▁128 ▁) ▁predicted _ dc ▁= ▁vu ▁; ▁else ▁if ▁( ▁FF ABS ▁( ▁predicted _ dc ▁- ▁vl ▁) ▁> ▁128 ▁) ▁predicted _ dc ▁= ▁vl ▁; ▁else ▁if ▁( ▁FF ABS ▁( ▁predicted _ dc ▁- ▁vul ▁) ▁> ▁128 ▁) ▁predicted _ dc ▁= ▁vul ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁coeffs ▁[ ▁i ▁] ▁. ▁index ▁) ▁{ ▁* ▁s ▁-> ▁next _ coeff ▁= ▁s ▁-> ▁coeffs ▁[ ▁i ▁] ▁; ▁s ▁-> ▁coeffs ▁[ ▁i ▁] ▁. ▁index ▁= ▁0 ▁; ▁s ▁-> ▁coeffs ▁[ ▁i ▁] ▁. ▁coeff ▁= ▁0 ▁; ▁s ▁-> ▁coeffs ▁[ ▁i ▁] ▁. ▁next ▁= ▁s ▁-> ▁next _ coeff ▁++ ▁; ▁} ▁s ▁-> ▁coeffs ▁[ ▁i ▁] ▁. ▁coeff ▁+= ▁predicted _ dc ▁; ▁last _ dc ▁[ ▁current _ frame _ type ▁] ▁= ▁DC _ CO EFF ▁( ▁i ▁) ▁; ▁if ▁( ▁DC _ CO EFF ▁( ▁i ▁) ▁&& ▁! ▁( ▁s ▁-> ▁coeff _ counts ▁[ ▁i ▁] ▁& ▁127 ▁) ▁) ▁{ ▁s ▁-> ▁coeff _ counts ▁[ ▁i ▁] ▁= ▁129 ▁; ▁s ▁-> ▁coeffs ▁[ ▁i ▁] ▁. ▁next ▁= ▁s ▁-> ▁next _ coeff ▁; ▁( ▁s ▁-> ▁next _ coeff ▁++ ▁) ▁-> ▁next ▁= ▁NULL ▁; ▁} ▁} ▁} ▁} ▁}	1
▁int ▁bn _ sqr _ fixed _ top ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁max ▁, ▁al ▁; ▁int ▁ret ▁= ▁0 ▁; ▁BIGNUM ▁* ▁tmp ▁, ▁* ▁rr ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁al ▁= ▁a ▁-> ▁top ▁; ▁if ▁( ▁al ▁<= ▁0 ▁) ▁{ ▁r ▁-> ▁top ▁= ▁0 ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁rr ▁= ▁( ▁a ▁!= ▁r ▁) ▁? ▁r ▁: ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁tmp ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁rr ▁== ▁NULL ▁|| ▁tmp ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁max ▁= ▁2 ▁* ▁al ▁; ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁al ▁== ▁4 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁BN _ ULONG ▁t ▁[ ▁8 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁4 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 4 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁else ▁if ▁( ▁al ▁== ▁8 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁BN _ ULONG ▁t ▁[ ▁16 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁8 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 8 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁else ▁{ ▁# if ▁defined ▁( ▁BN _ RECUR SION ▁) ▁if ▁( ▁al ▁< ▁BN _ SQR _ RECURSIVE _ SIZE _ NORMAL ▁) ▁{ ▁BN _ ULONG ▁t ▁[ ▁BN _ SQR _ RECURSIVE _ SIZE _ NORMAL ▁* ▁2 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁t ▁) ▁; ▁} ▁else ▁{ ▁int ▁j ▁, ▁k ▁; ▁j ▁= ▁BN _ num _ bits _ word ▁( ▁( ▁BN _ ULONG ▁) ▁al ▁) ▁; ▁j ▁= ▁1 ▁<< ▁( ▁j ▁- ▁1 ▁) ▁; ▁k ▁= ▁j ▁+ ▁j ▁; ▁if ▁( ▁al ▁== ▁j ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁k ▁* ▁2 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ recursive ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁} ▁} ▁# else ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁rr ▁-> ▁neg ▁= ▁0 ▁; ▁rr ▁-> ▁top ▁= ▁max ▁; ▁rr ▁-> ▁flags ▁|= ▁BN _ FLG _ FIXED _ TOP ▁; ▁if ▁( ▁r ▁!= ▁rr ▁&& ▁BN _ copy ▁( ▁r ▁, ▁rr ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁bn _ check _ top ▁( ▁rr ▁) ▁; ▁bn _ check _ top ▁( ▁tmp ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁inline ▁int ▁get _ s bits ▁( ▁Get Bit Context ▁* ▁s ▁, ▁int ▁n ▁) ▁{ ▁register ▁int ▁tmp ▁; ▁OPEN _ READER ▁( ▁re ▁, ▁s ▁) ▁; ▁av _ assert 2 ▁( ▁n ▁> ▁0 ▁&& ▁n ▁<= ▁25 ▁) ▁; ▁UPDATE _ CACHE ▁( ▁re ▁, ▁s ▁) ▁; ▁tmp ▁= ▁SHOW _ S BITS ▁( ▁re ▁, ▁s ▁, ▁n ▁) ▁; ▁LAST _ SKIP _ BITS ▁( ▁re ▁, ▁s ▁, ▁n ▁) ▁; ▁CLOSE _ READER ▁( ▁re ▁, ▁s ▁) ▁; ▁return ▁tmp ▁; ▁}	1
▁static ▁int ▁filter _ slice ▁( ▁AVFilter Context ▁* ▁ctx ▁, ▁void ▁* ▁arg ▁, ▁int ▁job nr ▁, ▁int ▁nb _ jobs ▁) ▁{ ▁Trans Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv ▁; ▁Thread Data ▁* ▁td ▁= ▁arg ▁; ▁AVFrame ▁* ▁out ▁= ▁td ▁-> ▁out ▁; ▁AVFrame ▁* ▁in ▁= ▁td ▁-> ▁in ▁; ▁int ▁plane ▁; ▁for ▁( ▁plane ▁= ▁0 ▁; ▁out ▁-> ▁data ▁[ ▁plane ▁] ▁; ▁plane ▁++ ▁) ▁{ ▁int ▁h sub ▁= ▁plane ▁== ▁1 ▁|| ▁plane ▁== ▁2 ▁? ▁s ▁-> ▁h sub ▁: ▁0 ▁; ▁int ▁v sub ▁= ▁plane ▁== ▁1 ▁|| ▁plane ▁== ▁2 ▁? ▁s ▁-> ▁v sub ▁: ▁0 ▁; ▁int ▁pix step ▁= ▁s ▁-> ▁pix steps ▁[ ▁plane ▁] ▁; ▁int ▁in h ▁= ▁AV _ CE IL _ RSHIFT ▁( ▁in ▁-> ▁height ▁, ▁v sub ▁) ▁; ▁int ▁outw ▁= ▁AV _ CE IL _ RSHIFT ▁( ▁out ▁-> ▁width ▁, ▁h sub ▁) ▁; ▁int ▁out h ▁= ▁AV _ CE IL _ RSHIFT ▁( ▁out ▁-> ▁height ▁, ▁v sub ▁) ▁; ▁int ▁start ▁= ▁( ▁out h ▁* ▁job nr ▁) ▁/ ▁nb _ jobs ▁; ▁int ▁end ▁= ▁( ▁out h ▁* ▁( ▁job nr ▁+ ▁1 ▁) ▁) ▁/ ▁nb _ jobs ▁; ▁uint 8_ t ▁* ▁dst ▁, ▁* ▁src ▁; ▁int ▁dst lines ize ▁, ▁sr cl ines ize ▁; ▁int ▁x ▁, ▁y ▁; ▁dst lines ize ▁= ▁out ▁-> ▁linesize ▁[ ▁plane ▁] ▁; ▁dst ▁= ▁out ▁-> ▁data ▁[ ▁plane ▁] ▁+ ▁start ▁* ▁dst lines ize ▁; ▁src ▁= ▁in ▁-> ▁data ▁[ ▁plane ▁] ▁; ▁sr cl ines ize ▁= ▁in ▁-> ▁linesize ▁[ ▁plane ▁] ▁; ▁if ▁( ▁s ▁-> ▁dir ▁& ▁1 ▁) ▁{ ▁src ▁+= ▁in ▁-> ▁linesize ▁[ ▁plane ▁] ▁* ▁( ▁in h ▁- ▁1 ▁) ▁; ▁sr cl ines ize ▁*= ▁-1 ▁; ▁} ▁if ▁( ▁s ▁-> ▁dir ▁& ▁2 ▁) ▁{ ▁dst ▁= ▁out ▁-> ▁data ▁[ ▁plane ▁] ▁+ ▁dst lines ize ▁* ▁( ▁out h ▁- ▁start ▁- ▁1 ▁) ▁; ▁dst lines ize ▁*= ▁-1 ▁; ▁} ▁for ▁( ▁y ▁= ▁start ▁; ▁y ▁< ▁end ▁- ▁7 ▁; ▁y ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁outw ▁- ▁7 ▁; ▁x ▁+= ▁8 ▁) ▁{ ▁s ▁-> ▁transpose _8 x 8 ▁( ▁src ▁+ ▁x ▁* ▁sr cl ines ize ▁+ ▁y ▁* ▁pix step ▁, ▁sr cl ines ize ▁, ▁dst ▁+ ▁( ▁y ▁- ▁start ▁) ▁* ▁dst lines ize ▁+ ▁x ▁* ▁pix step ▁, ▁dst lines ize ▁) ▁; ▁} ▁if ▁( ▁outw ▁- ▁x ▁> ▁0 ▁&& ▁end ▁- ▁y ▁> ▁0 ▁) ▁s ▁-> ▁transpose _ block ▁( ▁src ▁+ ▁x ▁* ▁sr cl ines ize ▁+ ▁y ▁* ▁pix step ▁, ▁sr cl ines ize ▁, ▁dst ▁+ ▁( ▁y ▁- ▁start ▁) ▁* ▁dst lines ize ▁+ ▁x ▁* ▁pix step ▁, ▁dst lines ize ▁, ▁outw ▁- ▁x ▁, ▁end ▁- ▁y ▁) ▁; ▁} ▁if ▁( ▁end ▁- ▁y ▁> ▁0 ▁) ▁s ▁-> ▁transpose _ block ▁( ▁src ▁+ ▁0 ▁* ▁sr cl ines ize ▁+ ▁y ▁* ▁pix step ▁, ▁sr cl ines ize ▁, ▁dst ▁+ ▁( ▁y ▁- ▁start ▁) ▁* ▁dst lines ize ▁+ ▁0 ▁* ▁pix step ▁, ▁dst lines ize ▁, ▁outw ▁, ▁end ▁- ▁y ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁modified _ lev in son _ d ur bin ▁( ▁int ▁* ▁window ▁, ▁int ▁window _ entries ▁, ▁int ▁* ▁out ▁, ▁int ▁out _ entries ▁, ▁int ▁channels ▁, ▁int ▁* ▁tap _ quant ▁) ▁{ ▁int ▁i ▁; ▁int ▁* ▁state ▁= ▁av _ calloc ▁( ▁window _ entries ▁, ▁sizeof ▁( ▁* ▁state ▁) ▁) ▁; ▁if ▁( ▁! ▁state ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁state ▁, ▁window ▁, ▁4 ▁* ▁window _ entries ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁out _ entries ▁; ▁i ▁++ ▁) ▁{ ▁int ▁step ▁= ▁( ▁i ▁+ ▁1 ▁) ▁* ▁channels ▁, ▁k ▁, ▁j ▁; ▁double ▁xx ▁= ▁0.0 ▁, ▁xy ▁= ▁0.0 ▁; ▁# if ▁1 ▁int ▁* ▁x _ ptr ▁= ▁& ▁( ▁window ▁[ ▁step ▁] ▁) ▁; ▁int ▁* ▁state _ ptr ▁= ▁& ▁( ▁state ▁[ ▁0 ▁] ▁) ▁; ▁j ▁= ▁window _ entries ▁- ▁step ▁; ▁for ▁( ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁, ▁x _ ptr ▁++ ▁, ▁state _ ptr ▁++ ▁) ▁{ ▁double ▁x _ value ▁= ▁* ▁x _ ptr ▁; ▁double ▁state _ value ▁= ▁* ▁state _ ptr ▁; ▁xx ▁+= ▁state _ value ▁* ▁state _ value ▁; ▁xy ▁+= ▁x _ value ▁* ▁state _ value ▁; ▁} ▁# else ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁<= ▁( ▁window _ entries ▁- ▁step ▁) ▁; ▁j ▁++ ▁) ▁; ▁{ ▁double ▁step val ▁= ▁window ▁[ ▁step ▁+ ▁j ▁] ▁; ▁double ▁state val ▁= ▁window ▁[ ▁j ▁] ▁; ▁xx ▁+= ▁state val ▁* ▁state val ▁; ▁xy ▁+= ▁step val ▁* ▁state val ▁; ▁} ▁# endif ▁if ▁( ▁xx ▁== ▁0.0 ▁) ▁k ▁= ▁0 ▁; ▁else ▁k ▁= ▁( ▁int ▁) ▁( ▁floor ▁( ▁- ▁xy ▁/ ▁xx ▁* ▁( ▁double ▁) ▁LAT TICE _ FACTOR ▁/ ▁( ▁double ▁) ▁( ▁tap _ quant ▁[ ▁i ▁] ▁) ▁+ ▁0.5 ▁) ▁) ▁; ▁if ▁( ▁k ▁> ▁( ▁LAT TICE _ FACTOR ▁/ ▁tap _ quant ▁[ ▁i ▁] ▁) ▁) ▁k ▁= ▁LAT TICE _ FACTOR ▁/ ▁tap _ quant ▁[ ▁i ▁] ▁; ▁if ▁( ▁- ▁k ▁> ▁( ▁LAT TICE _ FACTOR ▁/ ▁tap _ quant ▁[ ▁i ▁] ▁) ▁) ▁k ▁= ▁- ▁( ▁LAT TICE _ FACTOR ▁/ ▁tap _ quant ▁[ ▁i ▁] ▁) ▁; ▁out ▁[ ▁i ▁] ▁= ▁k ▁; ▁k ▁*= ▁tap _ quant ▁[ ▁i ▁] ▁; ▁# if ▁1 ▁x _ ptr ▁= ▁& ▁( ▁window ▁[ ▁step ▁] ▁) ▁; ▁state _ ptr ▁= ▁& ▁( ▁state ▁[ ▁0 ▁] ▁) ▁; ▁j ▁= ▁window _ entries ▁- ▁step ▁; ▁for ▁( ▁; ▁j ▁> ▁0 ▁; ▁j ▁-- ▁, ▁x _ ptr ▁++ ▁, ▁state _ ptr ▁++ ▁) ▁{ ▁int ▁x _ value ▁= ▁* ▁x _ ptr ▁; ▁int ▁state _ value ▁= ▁* ▁state _ ptr ▁; ▁* ▁x _ ptr ▁= ▁x _ value ▁+ ▁shift _ down ▁( ▁k ▁* ▁state _ value ▁, ▁LAT TICE _ SHIFT ▁) ▁; ▁* ▁state _ ptr ▁= ▁state _ value ▁+ ▁shift _ down ▁( ▁k ▁* ▁x _ value ▁, ▁LAT TICE _ SHIFT ▁) ▁; ▁} ▁# else ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁<= ▁( ▁window _ entries ▁- ▁step ▁) ▁; ▁j ▁++ ▁) ▁{ ▁int ▁step val ▁= ▁window ▁[ ▁step ▁+ ▁j ▁] ▁; ▁int ▁state val ▁= ▁state ▁[ ▁j ▁] ▁; ▁window ▁[ ▁step ▁+ ▁j ▁] ▁+= ▁shift _ down ▁( ▁k ▁* ▁state val ▁, ▁LAT TICE _ SHIFT ▁) ▁; ▁state ▁[ ▁j ▁] ▁+= ▁shift _ down ▁( ▁k ▁* ▁step val ▁, ▁LAT TICE _ SHIFT ▁) ▁; ▁} ▁# endif ▁} ▁av _ free ▁( ▁state ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁ff _ m jpeg _ encode _ init ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁MJ peg Context ▁* ▁m ▁; ▁av _ assert 0 ▁( ▁s ▁-> ▁slice _ context _ count ▁== ▁1 ▁) ▁; ▁if ▁( ▁s ▁-> ▁width ▁> ▁655 00 ▁|| ▁s ▁-> ▁height ▁> ▁655 00 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" JPEG does not support res olutions above 65 500 x 655 00\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁m ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁MJ peg Context ▁) ▁) ▁; ▁if ▁( ▁! ▁m ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁min _ q coeff ▁= ▁-10 23 ▁; ▁s ▁-> ▁max _ q coeff ▁= ▁1023 ▁; ▁ff _ m jpeg _ build _ h uffman _ codes ▁( ▁m ▁-> ▁h uff _ size _ dc _ l uminance ▁, ▁m ▁-> ▁h uff _ code _ dc _ l uminance ▁, ▁avpriv _ m jpeg _ bits _ dc _ l uminance ▁, ▁avpriv _ m jpeg _ val _ dc ▁) ▁; ▁ff _ m jpeg _ build _ h uffman _ codes ▁( ▁m ▁-> ▁h uff _ size _ dc _ chrom in ance ▁, ▁m ▁-> ▁h uff _ code _ dc _ chrom in ance ▁, ▁avpriv _ m jpeg _ bits _ dc _ chrom in ance ▁, ▁avpriv _ m jpeg _ val _ dc ▁) ▁; ▁ff _ m jpeg _ build _ h uffman _ codes ▁( ▁m ▁-> ▁h uff _ size _ ac _ l uminance ▁, ▁m ▁-> ▁h uff _ code _ ac _ l uminance ▁, ▁avpriv _ m jpeg _ bits _ ac _ l uminance ▁, ▁avpriv _ m jpeg _ val _ ac _ l uminance ▁) ▁; ▁ff _ m jpeg _ build _ h uffman _ codes ▁( ▁m ▁-> ▁h uff _ size _ ac _ chrom in ance ▁, ▁m ▁-> ▁h uff _ code _ ac _ chrom in ance ▁, ▁avpriv _ m jpeg _ bits _ ac _ chrom in ance ▁, ▁avpriv _ m jpeg _ val _ ac _ chrom in ance ▁) ▁; ▁ff _ init _ uni _ ac _ vlc ▁( ▁m ▁-> ▁h uff _ size _ ac _ l uminance ▁, ▁m ▁-> ▁uni _ ac _ vlc _ len ▁) ▁; ▁ff _ init _ uni _ ac _ vlc ▁( ▁m ▁-> ▁h uff _ size _ ac _ chrom in ance ▁, ▁m ▁-> ▁uni _ chroma _ ac _ vlc _ len ▁) ▁; ▁s ▁-> ▁in tra _ ac _ vlc _ length ▁= ▁s ▁-> ▁in tra _ ac _ vlc _ last _ length ▁= ▁m ▁-> ▁uni _ ac _ vlc _ len ▁; ▁s ▁-> ▁in tra _ chroma _ ac _ vlc _ length ▁= ▁s ▁-> ▁in tra _ chroma _ ac _ vlc _ last _ length ▁= ▁m ▁-> ▁uni _ chroma _ ac _ vlc _ len ▁; ▁m ▁-> ▁h uff _ n code ▁= ▁0 ▁; ▁s ▁-> ▁m jpeg _ ctx ▁= ▁m ▁; ▁if ▁( ▁s ▁-> ▁h uffman ▁== ▁H UFF MAN _ TABLE _ OPTIM AL ▁) ▁return ▁alloc _ h uffman ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁BIGNUM ▁* ▁bn _ expand 2 ▁( ▁BIGNUM ▁* ▁b ▁, ▁int ▁words ▁) ▁{ ▁BN _ ULONG ▁* ▁A ▁; ▁int ▁i ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁words ▁> ▁b ▁-> ▁dmax ▁) ▁{ ▁BN _ ULONG ▁* ▁a ▁= ▁bn _ expand _ internal ▁( ▁b ▁, ▁words ▁) ▁; ▁if ▁( ▁! ▁a ▁) ▁return ▁NULL ▁; ▁if ▁( ▁b ▁-> ▁d ▁) ▁OPENSSL _ free ▁( ▁b ▁-> ▁d ▁) ▁; ▁b ▁-> ▁d ▁= ▁a ▁; ▁b ▁-> ▁dmax ▁= ▁words ▁; ▁} ▁if ▁( ▁b ▁-> ▁top ▁< ▁b ▁-> ▁dmax ▁) ▁{ ▁A ▁= ▁& ▁( ▁b ▁-> ▁d ▁[ ▁b ▁-> ▁top ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁( ▁b ▁-> ▁dmax ▁- ▁b ▁-> ▁top ▁) ▁>> ▁3 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁+= ▁8 ▁) ▁{ ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁3 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁4 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁5 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁6 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁7 ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁( ▁b ▁-> ▁dmax ▁- ▁b ▁-> ▁top ▁) ▁& ▁7 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁++ ▁) ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁assert ▁( ▁A ▁== ▁& ▁( ▁b ▁-> ▁d ▁[ ▁b ▁-> ▁dmax ▁] ▁) ▁) ▁; ▁} ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁return ▁b ▁; ▁}	1
▁static ▁int ▁skip _ input ▁( ▁DB E Context ▁* ▁s ▁, ▁int ▁nb _ words ▁) ▁{ ▁if ▁( ▁nb _ words ▁> ▁s ▁-> ▁input _ size ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Packet too short \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁input ▁+= ▁nb _ words ▁* ▁s ▁-> ▁word _ bytes ▁; ▁s ▁-> ▁input _ size ▁-= ▁nb _ words ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁h ls _ slice _ data _ w pp ▁( ▁H EV C Context ▁* ▁s ▁, ▁const ▁H EV CN AL ▁* ▁nal ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁data ▁= ▁nal ▁-> ▁data ▁; ▁int ▁length ▁= ▁nal ▁-> ▁size ▁; ▁H EV CL ocal Context ▁* ▁lc ▁= ▁s ▁-> ▁H EV C lc ▁; ▁int ▁* ▁ret ▁= ▁av _ malloc _ array ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁, ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁* ▁arg ▁= ▁av _ malloc _ array ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁, ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int 64_ t ▁offset ▁; ▁int ▁start header ▁, ▁c mpt ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁, ▁res ▁= ▁0 ▁; ▁if ▁( ▁! ▁ret ▁|| ▁! ▁arg ▁) ▁{ ▁av _ free ▁( ▁ret ▁) ▁; ▁av _ free ▁( ▁arg ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁sh ▁. ▁slice _ ct b _ addr _ rs ▁+ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁* ▁s ▁-> ▁ps ▁. ▁sps ▁-> ▁ct b _ width ▁>= ▁s ▁-> ▁ps ▁. ▁sps ▁-> ▁ct b _ width ▁* ▁s ▁-> ▁ps ▁. ▁sps ▁-> ▁ct b _ height ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" W PP ct b addresses are wrong (% d % d % d % d )\ n " ▁, ▁s ▁-> ▁sh ▁. ▁slice _ ct b _ addr _ rs ▁, ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁, ▁s ▁-> ▁ps ▁. ▁sps ▁-> ▁ct b _ width ▁, ▁s ▁-> ▁ps ▁. ▁sps ▁-> ▁ct b _ height ▁) ▁; ▁res ▁= ▁AVERROR _ INVALIDDATA ▁; ▁goto ▁error ▁; ▁} ▁ff _ alloc _ entries ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁s List ▁[ ▁1 ▁] ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁H EV CL ocal Context ▁) ▁) ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁} ▁} ▁offset ▁= ▁( ▁lc ▁-> ▁gb ▁. ▁index ▁>> ▁3 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁, ▁c mpt ▁= ▁0 ▁, ▁start header ▁= ▁offset ▁+ ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁0 ▁] ▁; ▁j ▁< ▁nal ▁-> ▁skipped _ bytes ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁nal ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁>= ▁offset ▁&& ▁nal ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁< ▁start header ▁) ▁{ ▁start header ▁-- ▁; ▁c mpt ▁++ ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁{ ▁offset ▁+= ▁( ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁- ▁1 ▁] ▁- ▁c mpt ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁, ▁c mpt ▁= ▁0 ▁, ▁start header ▁= ▁offset ▁+ ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁] ▁; ▁j ▁< ▁nal ▁-> ▁skipped _ bytes ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁nal ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁>= ▁offset ▁&& ▁nal ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁< ▁start header ▁) ▁{ ▁start header ▁-- ▁; ▁c mpt ▁++ ▁; ▁} ▁} ▁s ▁-> ▁sh ▁. ▁size ▁[ ▁i ▁- ▁1 ▁] ▁= ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁] ▁- ▁c mpt ▁; ▁s ▁-> ▁sh ▁. ▁offset ▁[ ▁i ▁- ▁1 ▁] ▁= ▁offset ▁; ▁} ▁if ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁!= ▁0 ▁) ▁{ ▁offset ▁+= ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁- ▁c mpt ▁; ▁if ▁( ▁length ▁< ▁offset ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" entry _ point _ offset table isc or rupted \ n " ▁) ▁; ▁res ▁= ▁AVERROR _ INVALIDDATA ▁; ▁goto ▁error ▁; ▁} ▁s ▁-> ▁sh ▁. ▁size ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁= ▁length ▁- ▁offset ▁; ▁s ▁-> ▁sh ▁. ▁offset ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁= ▁offset ▁; ▁} ▁s ▁-> ▁data ▁= ▁data ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁-> ▁first _ qp _ group ▁= ▁1 ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁-> ▁qp _ y ▁= ▁s ▁-> ▁s List ▁[ ▁0 ▁] ▁-> ▁H EV C lc ▁-> ▁qp _ y ▁; ▁memcpy ▁( ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁} ▁avpriv _ atomic _ int _ set ▁( ▁& ▁s ▁-> ▁w pp _ err ▁, ▁0 ▁) ▁; ▁ff _ reset _ entries ▁( ▁s ▁-> ▁avctx ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁{ ▁arg ▁[ ▁i ▁] ▁= ▁i ▁; ▁ret ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁if ▁( ▁s ▁-> ▁ps ▁. ▁pps ▁-> ▁entropy _ coding _ sync _ enabled _ flag ▁) ▁s ▁-> ▁avctx ▁-> ▁execute 2 ▁( ▁s ▁-> ▁avctx ▁, ▁h ls _ decode _ entry _ w pp ▁, ▁arg ▁, ▁ret ▁, ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁res ▁+= ▁ret ▁[ ▁i ▁] ▁; ▁error ▁: ▁av _ free ▁( ▁ret ▁) ▁; ▁av _ free ▁( ▁arg ▁) ▁; ▁return ▁res ▁; ▁}	1
▁static ▁void ▁av _ always _ inline ▁filter _ mb _ edge v ▁( ▁uint 8_ t ▁* ▁pix ▁, ▁int ▁stride ▁, ▁int 16_ t ▁b S ▁[ ▁4 ▁] ▁, ▁unsigned ▁int ▁qp ▁, ▁H 264 Context ▁* ▁h ▁) ▁{ ▁const ▁unsigned ▁int ▁index _ a ▁= ▁qp ▁+ ▁h ▁-> ▁slice _ alpha _ c 0_ offset ▁; ▁const ▁int ▁alpha ▁= ▁alpha _ table ▁[ ▁index _ a ▁] ▁; ▁const ▁int ▁beta ▁= ▁beta _ table ▁[ ▁qp ▁+ ▁h ▁-> ▁slice _ beta _ offset ▁] ▁; ▁if ▁( ▁alpha ▁== ▁0 ▁|| ▁beta ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁b S ▁[ ▁0 ▁] ▁< ▁4 ▁) ▁{ ▁int 8_ t ▁tc ▁[ ▁4 ▁] ▁; ▁tc ▁[ ▁0 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁0 ▁] ▁] ▁; ▁tc ▁[ ▁1 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁1 ▁] ▁] ▁; ▁tc ▁[ ▁2 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁2 ▁] ▁] ▁; ▁tc ▁[ ▁3 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁3 ▁] ▁] ▁; ▁h ▁-> ▁h 264 dsp ▁. ▁h 264_ h _ loop _ filter _ l uma ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁, ▁tc ▁) ▁; ▁} ▁else ▁{ ▁h ▁-> ▁h 264 dsp ▁. ▁h 264_ h _ loop _ filter _ l uma _ intra ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁) ▁; ▁} ▁}	1
▁static ▁int ▁aic _ decode _ coeffs ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁int 16_ t ▁* ▁dst ▁, ▁int ▁band ▁, ▁int ▁slice _ width ▁) ▁{ ▁int ▁has _ sk ips ▁, ▁coeff _ type ▁, ▁coeff _ bits ▁, ▁skip _ type ▁, ▁skip _ bits ▁; ▁const ▁int ▁num _ coeffs ▁= ▁aic _ num _ band _ coeffs ▁[ ▁band ▁] ▁; ▁const ▁uint 8_ t ▁* ▁scan ▁= ▁aic _ scan ▁[ ▁band ▁] ▁; ▁int ▁mb ▁, ▁idx ▁; ▁unsigned ▁val ▁; ▁has _ sk ips ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁coeff _ type ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁coeff _ bits ▁= ▁get _ bits ▁( ▁gb ▁, ▁3 ▁) ▁; ▁if ▁( ▁has _ sk ips ▁) ▁{ ▁skip _ type ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁skip _ bits ▁= ▁get _ bits ▁( ▁gb ▁, ▁3 ▁) ▁; ▁for ▁( ▁mb ▁= ▁0 ▁; ▁mb ▁< ▁slice _ width ▁; ▁mb ▁++ ▁) ▁{ ▁idx ▁= ▁-1 ▁; ▁do ▁{ ▁GET _ CODE ▁( ▁val ▁, ▁skip _ type ▁, ▁skip _ bits ▁) ▁; ▁if ▁( ▁val ▁>= ▁0 x 10000 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁idx ▁+= ▁val ▁+ ▁1 ▁; ▁if ▁( ▁idx ▁>= ▁num _ coeffs ▁) ▁break ▁; ▁GET _ CODE ▁( ▁val ▁, ▁coeff _ type ▁, ▁coeff _ bits ▁) ▁; ▁val ▁++ ▁; ▁if ▁( ▁val ▁>= ▁0 x 10000 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁dst ▁[ ▁scan ▁[ ▁idx ▁] ▁] ▁= ▁val ▁; ▁} ▁while ▁( ▁idx ▁< ▁num _ coeffs ▁- ▁1 ▁) ▁; ▁dst ▁+= ▁num _ coeffs ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁mb ▁= ▁0 ▁; ▁mb ▁< ▁slice _ width ▁; ▁mb ▁++ ▁) ▁{ ▁for ▁( ▁idx ▁= ▁0 ▁; ▁idx ▁< ▁num _ coeffs ▁; ▁idx ▁++ ▁) ▁{ ▁GET _ CODE ▁( ▁val ▁, ▁coeff _ type ▁, ▁coeff _ bits ▁) ▁; ▁if ▁( ▁val ▁>= ▁0 x 10000 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁dst ▁[ ▁scan ▁[ ▁idx ▁] ▁] ▁= ▁val ▁; ▁} ▁dst ▁+= ▁num _ coeffs ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁MP V _ motion _ internal ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁dir ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁q pel _ mc _ func ▁( ▁* ▁q pix _ op ▁) ▁[ ▁16 ▁] ▁, ▁int ▁is _ mpeg 12 ▁) ▁{ ▁int ▁i ▁; ▁int ▁mb _ y ▁= ▁s ▁-> ▁mb _ y ▁; ▁prefetch _ motion ▁( ▁s ▁, ▁ref _ picture ▁, ▁dir ▁) ▁; ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁s ▁-> ▁ob mc ▁&& ▁s ▁-> ▁pict _ type ▁!= ▁AV _ PICTURE _ TYPE _ B ▁) ▁{ ▁apply _ ob mc ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁ref _ picture ▁, ▁pix _ op ▁) ▁; ▁return ▁; ▁} ▁switch ▁( ▁s ▁-> ▁mv _ type ▁) ▁{ ▁case ▁MV _ TYPE _16 X 16 ▁: ▁if ▁( ▁s ▁-> ▁mc sel ▁) ▁{ ▁if ▁( ▁s ▁-> ▁real _ sprite _ war ping _ points ▁== ▁1 ▁) ▁{ ▁g mc 1_ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁ref _ picture ▁) ▁; ▁} ▁else ▁{ ▁g mc _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁ref _ picture ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁s ▁-> ▁qu arter _ sample ▁) ▁{ ▁q pel _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁q pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁16 ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁( ▁CONFIG _ WM V 2_ DECODER ▁|| ▁CONFIG _ WM V 2_ ENCODER ▁) ▁&& ▁s ▁-> ▁ms pel ▁&& ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ WM V 2 ▁) ▁{ ▁ff _ ms pel _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁16 ▁) ▁; ▁} ▁else ▁{ ▁mpeg _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁0 ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁16 ▁, ▁mb _ y ▁) ▁; ▁} ▁break ▁; ▁case ▁MV _ TYPE _8 X 8 ▁: ▁if ▁( ▁! ▁is _ mpeg 12 ▁) ▁apply _8 x 8 ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁dir ▁, ▁ref _ picture ▁, ▁q pix _ op ▁, ▁pix _ op ▁) ▁; ▁break ▁; ▁case ▁MV _ TYPE _ FIELD ▁: ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁{ ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁s ▁-> ▁qu arter _ sample ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁q pel _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁1 ▁, ▁i ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁q pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁, ▁8 ▁) ▁; ▁} ▁else ▁{ ▁mpeg _ motion _ field ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁0 ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁8 ▁, ▁mb _ y ▁) ▁; ▁mpeg _ motion _ field ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁1 ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁1 ▁] ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁, ▁8 ▁, ▁mb _ y ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁picture _ structure ▁!= ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁+ ▁1 ▁&& ▁s ▁-> ▁pict _ type ▁!= ▁AV _ PICTURE _ TYPE _ B ▁&& ▁! ▁s ▁-> ▁first _ field ▁) ▁{ ▁ref _ picture ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁-> ▁data ▁; ▁} ▁mpeg _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁16 ▁, ▁mb _ y ▁>> ▁1 ▁) ▁; ▁} ▁break ▁; ▁case ▁MV _ TYPE _16 X 8 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁uint 8_ t ▁* ▁* ▁ref 2 picture ▁; ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁+ ▁1 ▁|| ▁s ▁-> ▁pict _ type ▁== ▁AV _ PICTURE _ TYPE _ B ▁|| ▁s ▁-> ▁first _ field ▁) ▁{ ▁ref 2 picture ▁= ▁ref _ picture ▁; ▁} ▁else ▁{ ▁ref 2 picture ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁-> ▁data ▁; ▁} ▁mpeg _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁s ▁-> ▁field _ select ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁, ▁ref 2 picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+ ▁16 ▁* ▁i ▁, ▁8 ▁, ▁mb _ y ▁>> ▁1 ▁) ▁; ▁dest _ y ▁+= ▁16 ▁* ▁s ▁-> ▁linesize ▁; ▁dest _ cb ▁+= ▁( ▁16 ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁* ▁s ▁-> ▁uv lines ize ▁; ▁dest _ cr ▁+= ▁( ▁16 ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁* ▁s ▁-> ▁uv lines ize ▁; ▁} ▁break ▁; ▁case ▁MV _ TYPE _ DM V ▁: ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁mpeg _ motion _ field ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁j ▁, ▁j ▁ ^ ▁i ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁+ ▁j ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁+ ▁j ▁] ▁[ ▁1 ▁] ▁, ▁8 ▁, ▁mb _ y ▁) ▁; ▁pix _ op ▁= ▁s ▁-> ▁h dsp ▁. ▁avg _ pixels _ tab ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁mpeg _ motion ▁( ▁s ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁s ▁-> ▁picture _ structure ▁!= ▁i ▁+ ▁1 ▁, ▁ref _ picture ▁, ▁pix _ op ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁2 ▁* ▁i ▁] ▁[ ▁1 ▁] ▁, ▁16 ▁, ▁mb _ y ▁>> ▁1 ▁) ▁; ▁pix _ op ▁= ▁s ▁-> ▁h dsp ▁. ▁avg _ pixels _ tab ▁; ▁if ▁( ▁! ▁s ▁-> ▁first _ field ▁) ▁{ ▁ref _ picture ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁-> ▁data ▁; ▁} ▁} ▁} ▁break ▁; ▁default ▁: ▁assert ▁( ▁0 ▁) ▁; ▁} ▁}	0
▁static ▁av _ cold ▁int ▁che _ configure ▁( ▁AAC Context ▁* ▁ac ▁, ▁enum ▁Channel Position ▁che _ pos ▁, ▁int ▁type ▁, ▁int ▁id ▁, ▁int ▁* ▁channels ▁) ▁{ ▁if ▁( ▁* ▁channels ▁>= ▁MAX _ CHANNELS ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁che _ pos ▁) ▁{ ▁if ▁( ▁! ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁) ▁{ ▁if ▁( ▁! ▁( ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁Channel Element ▁) ▁) ▁) ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁ff _ aac _ s br _ ctx _ init ▁( ▁ac ▁, ▁& ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁-> ▁sb r ▁) ▁; ▁} ▁if ▁( ▁type ▁!= ▁TYPE _ CCE ▁) ▁{ ▁ac ▁-> ▁output _ element ▁[ ▁( ▁* ▁channels ▁) ▁++ ▁] ▁= ▁& ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁-> ▁ch ▁[ ▁0 ▁] ▁; ▁if ▁( ▁type ▁== ▁TYPE _ C PE ▁|| ▁( ▁type ▁== ▁TYPE _ S CE ▁&& ▁ac ▁-> ▁oc ▁[ ▁1 ▁] ▁. ▁m 4 ac ▁. ▁ps ▁== ▁1 ▁) ▁) ▁{ ▁ac ▁-> ▁output _ element ▁[ ▁( ▁* ▁channels ▁) ▁++ ▁] ▁= ▁& ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁-> ▁ch ▁[ ▁1 ▁] ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁) ▁ff _ aac _ s br _ ctx _ close ▁( ▁& ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁-> ▁sb r ▁) ▁; ▁av _ freep ▁( ▁& ▁ac ▁-> ▁che ▁[ ▁type ▁] ▁[ ▁id ▁] ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁chroma _4 mv _ motion ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁* ▁pix _ op ▁, ▁int ▁mx ▁, ▁int ▁my ▁) ▁{ ▁int ▁d xy ▁, ▁emu ▁= ▁0 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁offset ▁; ▁uint 8_ t ▁* ▁ptr ▁; ▁mx ▁= ▁ff _ h 263_ round _ chroma ▁( ▁mx ▁) ▁; ▁my ▁= ▁ff _ h 263_ round _ chroma ▁( ▁my ▁) ▁; ▁d xy ▁= ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁mx ▁>>= ▁1 ▁; ▁my ▁>>= ▁1 ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁8 ▁+ ▁my ▁; ▁src _ x ▁= ▁av _ clip ▁( ▁src _ x ▁, ▁-8 ▁, ▁( ▁s ▁-> ▁width ▁>> ▁1 ▁) ▁) ▁; ▁if ▁( ▁src _ x ▁== ▁( ▁s ▁-> ▁width ▁>> ▁1 ▁) ▁) ▁d xy ▁&= ▁ ~ ▁1 ▁; ▁src _ y ▁= ▁av _ clip ▁( ▁src _ y ▁, ▁-8 ▁, ▁( ▁s ▁-> ▁height ▁>> ▁1 ▁) ▁) ▁; ▁if ▁( ▁src _ y ▁== ▁( ▁s ▁-> ▁height ▁>> ▁1 ▁) ▁) ▁d xy ▁&= ▁ ~ ▁2 ▁; ▁offset ▁= ▁src _ y ▁* ▁s ▁-> ▁uv lines ize ▁+ ▁src _ x ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁offset ▁; ▁if ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ EMU _ EDGE ▁) ▁{ ▁if ▁( ▁( ▁unsigned ▁) ▁src _ x ▁> ▁FF MAX ▁( ▁( ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁) ▁- ▁( ▁d xy ▁& ▁1 ▁) ▁- ▁8 ▁, ▁0 ▁) ▁|| ▁( ▁unsigned ▁) ▁src _ y ▁> ▁FF MAX ▁( ▁( ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁- ▁( ▁d xy ▁>> ▁1 ▁) ▁- ▁8 ▁, ▁0 ▁) ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁emu ▁= ▁1 ▁; ▁} ▁} ▁pix _ op ▁[ ▁d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁8 ▁) ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁offset ▁; ▁if ▁( ▁emu ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁} ▁pix _ op ▁[ ▁d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁8 ▁) ▁; ▁}	1
▁static ▁int ▁targ a _ encode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁pkt ▁, ▁const ▁AVFrame ▁* ▁p ▁, ▁int ▁* ▁got _ packet ▁) ▁{ ▁T arg a Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁bpp ▁, ▁pic size ▁, ▁datasize ▁= ▁-1 ▁, ▁ret ▁; ▁uint 8_ t ▁* ▁out ▁; ▁pic size ▁= ▁av _ image _ get _ buffer _ size ▁( ▁avctx ▁-> ▁pix _ fmt ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁, ▁1 ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ alloc _ packet ▁( ▁pkt ▁, ▁pic size ▁+ ▁45 ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" encode df ram et ool arge \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁memset ▁( ▁pkt ▁-> ▁data ▁, ▁0 ▁, ▁12 ▁) ▁; ▁AV _ WL 16 ▁( ▁pkt ▁-> ▁data ▁+ ▁12 ▁, ▁avctx ▁-> ▁width ▁) ▁; ▁AV _ WL 16 ▁( ▁pkt ▁-> ▁data ▁+ ▁14 ▁, ▁avctx ▁-> ▁height ▁) ▁; ▁pkt ▁-> ▁data ▁[ ▁17 ▁] ▁= ▁0 x 20 ▁| ▁( ▁avctx ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ B GRA ▁? ▁8 ▁: ▁0 ▁) ▁; ▁switch ▁( ▁avctx ▁-> ▁pix _ fmt ▁) ▁{ ▁case ▁AV _ PIX _ FMT _ GRAY 8 ▁: ▁pkt ▁-> ▁data ▁[ ▁2 ▁] ▁= ▁T GA _ BW ▁; ▁pkt ▁-> ▁data ▁[ ▁16 ▁] ▁= ▁8 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ RGB 555 LE ▁: ▁pkt ▁-> ▁data ▁[ ▁2 ▁] ▁= ▁T GA _ RGB ▁; ▁pkt ▁-> ▁data ▁[ ▁16 ▁] ▁= ▁16 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ BGR 24 ▁: ▁pkt ▁-> ▁data ▁[ ▁2 ▁] ▁= ▁T GA _ RGB ▁; ▁pkt ▁-> ▁data ▁[ ▁16 ▁] ▁= ▁24 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ B GRA ▁: ▁pkt ▁-> ▁data ▁[ ▁2 ▁] ▁= ▁T GA _ RGB ▁; ▁pkt ▁-> ▁data ▁[ ▁16 ▁] ▁= ▁32 ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Pixel format ' % s ' not supported .\ n " ▁, ▁av _ get _ pix _ fmt _ name ▁( ▁avctx ▁-> ▁pix _ fmt ▁) ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁bpp ▁= ▁pkt ▁-> ▁data ▁[ ▁16 ▁] ▁>> ▁3 ▁; ▁out ▁= ▁pkt ▁-> ▁data ▁+ ▁18 ▁; ▁# if ▁FF _ API _ CODER _ TYPE ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁if ▁( ▁avctx ▁-> ▁coder _ type ▁== ▁FF _ CODER _ TYPE _ RAW ▁) ▁s ▁-> ▁r le ▁= ▁0 ▁; ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁# endif ▁if ▁( ▁s ▁-> ▁r le ▁) ▁datasize ▁= ▁targ a _ encode _ r le ▁( ▁out ▁, ▁pic size ▁, ▁p ▁, ▁bpp ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁) ▁; ▁if ▁( ▁datasize ▁>= ▁0 ▁) ▁pkt ▁-> ▁data ▁[ ▁2 ▁] ▁|= ▁8 ▁; ▁else ▁datasize ▁= ▁targ a _ encode _ normal ▁( ▁out ▁, ▁p ▁, ▁bpp ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁) ▁; ▁out ▁+= ▁datasize ▁; ▁memcpy ▁( ▁out ▁, ▁"\ 0\0\0\0\ 0\0\ 0\0 TRUE VISION - X FILE ." ▁, ▁26 ▁) ▁; ▁pkt ▁-> ▁size ▁= ▁out ▁+ ▁26 ▁- ▁pkt ▁-> ▁data ▁; ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ KEY ▁; ▁* ▁got _ packet ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁store _ slot mem ▁( ▁ap _ slot mem _ instance _ t ▁* ▁slot mem ▁) ▁{ ▁apr _ file _ t ▁* ▁fp ▁; ▁apr _ status _ t ▁rv ▁; ▁apr _ size _ t ▁nbytes ▁; ▁unsigned ▁char ▁digest ▁[ ▁APR _ MD 5_ DIGEST SIZE ▁] ▁; ▁const ▁char ▁* ▁store name ▁= ▁slot mem ▁-> ▁pname ▁; ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁AP LOG NO ▁( ▁0 23 34 ▁) ▁" st oring % s " ▁, ▁store name ▁) ▁; ▁if ▁( ▁store name ▁) ▁{ ▁rv ▁= ▁apr _ file _ open ▁( ▁& ▁fp ▁, ▁store name ▁, ▁APR _ CREATE ▁| ▁APR _ READ ▁| ▁APR _ WRITE ▁, ▁APR _ OS _ DEFAULT ▁, ▁slot mem ▁-> ▁g pool ▁) ▁; ▁if ▁( ▁APR _ STATUS _ IS _ E EXIST ▁( ▁rv ▁) ▁) ▁{ ▁apr _ file _ remove ▁( ▁store name ▁, ▁slot mem ▁-> ▁g pool ▁) ▁; ▁rv ▁= ▁apr _ file _ open ▁( ▁& ▁fp ▁, ▁store name ▁, ▁APR _ CREATE ▁| ▁APR _ READ ▁| ▁APR _ WRITE ▁, ▁APR _ OS _ DEFAULT ▁, ▁slot mem ▁-> ▁g pool ▁) ▁; ▁} ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁AP _ SLOT MEM _ IS _ CLEAR IN USE ▁( ▁slot mem ▁) ▁) ▁{ ▁slot mem _ clear in use ▁( ▁slot mem ▁) ▁; ▁} ▁nbytes ▁= ▁( ▁slot mem ▁-> ▁desc ▁. ▁size ▁* ▁slot mem ▁-> ▁desc ▁. ▁num ▁) ▁+ ▁( ▁slot mem ▁-> ▁desc ▁. ▁num ▁* ▁sizeof ▁( ▁char ▁) ▁) ▁+ ▁AP _ UNSIGNED INT _ OFFSET ▁; ▁apr _ md 5 ▁( ▁digest ▁, ▁slot mem ▁-> ▁persist ▁, ▁nbytes ▁) ▁; ▁rv ▁= ▁apr _ file _ write _ full ▁( ▁fp ▁, ▁slot mem ▁-> ▁persist ▁, ▁nbytes ▁, ▁NULL ▁) ▁; ▁if ▁( ▁rv ▁== ▁APR _ SUCCESS ▁) ▁{ ▁rv ▁= ▁apr _ file _ write _ full ▁( ▁fp ▁, ▁digest ▁, ▁APR _ MD 5_ DIGEST SIZE ▁, ▁NULL ▁) ▁; ▁} ▁apr _ file _ close ▁( ▁fp ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁apr _ file _ remove ▁( ▁store name ▁, ▁slot mem ▁-> ▁g pool ▁) ▁; ▁} ▁} ▁}	1
▁static ▁void ▁encode _ ex pon ents _ blk _ ch ▁( ▁uint 8_ t ▁* ▁exp ▁, ▁int ▁nb _ ex ps ▁, ▁int ▁exp _ strategy ▁, ▁uint 8_ t ▁* ▁num _ exp _ groups ▁) ▁{ ▁int ▁group _ size ▁, ▁nb _ groups ▁, ▁i ▁, ▁j ▁, ▁k ▁, ▁exp _ min ▁; ▁group _ size ▁= ▁exp _ strategy ▁+ ▁( ▁exp _ strategy ▁== ▁EXP _ D 45 ▁) ▁; ▁* ▁num _ exp _ groups ▁= ▁( ▁nb _ ex ps ▁+ ▁( ▁group _ size ▁* ▁3 ▁) ▁- ▁4 ▁) ▁/ ▁( ▁3 ▁* ▁group _ size ▁) ▁; ▁nb _ groups ▁= ▁* ▁num _ exp _ groups ▁* ▁3 ▁; ▁if ▁( ▁exp _ strategy ▁> ▁EXP _ D 15 ▁) ▁{ ▁k ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁nb _ groups ▁; ▁i ▁++ ▁) ▁{ ▁exp _ min ▁= ▁exp ▁[ ▁k ▁] ▁; ▁assert ▁( ▁exp _ min ▁>= ▁0 ▁&& ▁exp _ min ▁<= ▁24 ▁) ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁group _ size ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁exp ▁[ ▁k ▁+ ▁j ▁] ▁< ▁exp _ min ▁) ▁exp _ min ▁= ▁exp ▁[ ▁k ▁+ ▁j ▁] ▁; ▁} ▁exp ▁[ ▁i ▁] ▁= ▁exp _ min ▁; ▁k ▁+= ▁group _ size ▁; ▁} ▁} ▁if ▁( ▁exp ▁[ ▁0 ▁] ▁> ▁15 ▁) ▁exp ▁[ ▁0 ▁] ▁= ▁15 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁nb _ groups ▁; ▁i ▁++ ▁) ▁exp ▁[ ▁i ▁] ▁= ▁FF MIN ▁( ▁exp ▁[ ▁i ▁] ▁, ▁exp ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁2 ▁) ▁; ▁for ▁( ▁i ▁= ▁nb _ groups ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁exp ▁[ ▁i ▁] ▁= ▁FF MIN ▁( ▁exp ▁[ ▁i ▁] ▁, ▁exp ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁2 ▁) ▁; ▁if ▁( ▁exp _ strategy ▁> ▁EXP _ D 15 ▁) ▁{ ▁k ▁= ▁nb _ groups ▁* ▁group _ size ▁; ▁for ▁( ▁i ▁= ▁nb _ groups ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁group _ size ▁; ▁j ▁++ ▁) ▁exp ▁[ ▁k ▁- ▁j ▁] ▁= ▁exp ▁[ ▁i ▁] ▁; ▁k ▁-= ▁group _ size ▁; ▁} ▁} ▁}	1
▁int ▁ff _ inter leave _ packet _ per _ dts ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁out ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁flush ▁) ▁{ ▁AVPacket List ▁* ▁pk tl ▁; ▁int ▁stream _ count ▁= ▁0 ▁; ▁int ▁non inter leaved _ count ▁= ▁0 ▁; ▁int ▁i ▁, ▁ret ▁; ▁int ▁eof ▁= ▁flush ▁; ▁if ▁( ▁pkt ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁ff _ inter leave _ add _ packet ▁( ▁s ▁, ▁pkt ▁, ▁interleave _ compare _ dts ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁last _ in _ packet _ buffer ▁) ▁{ ▁++ ▁stream _ count ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁codecpar ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ ATTACHMENT ▁&& ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁codecpar ▁-> ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ VP 8 ▁&& ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁codecpar ▁-> ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ VP 9 ▁) ▁{ ▁++ ▁non inter leaved _ count ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁internal ▁-> ▁nb _ inter leaved _ streams ▁== ▁stream _ count ▁) ▁flush ▁= ▁1 ▁; ▁if ▁( ▁s ▁-> ▁max _ inter leave _ delta ▁> ▁0 ▁&& ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁&& ▁! ▁flush ▁&& ▁s ▁-> ▁internal ▁-> ▁nb _ inter leaved _ streams ▁== ▁stream _ count ▁+ ▁non inter leaved _ count ▁) ▁{ ▁AVPacket ▁* ▁top _ pkt ▁= ▁& ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁-> ▁pkt ▁; ▁int 64_ t ▁delta _ dts ▁= ▁INT 64_ MIN ▁; ▁int 64_ t ▁top _ dts ▁= ▁av _ re scale _ q ▁( ▁top _ pkt ▁-> ▁dts ▁, ▁s ▁-> ▁streams ▁[ ▁top _ pkt ▁-> ▁stream _ index ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁int 64_ t ▁last _ dts ▁; ▁const ▁AVPacket List ▁* ▁last ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁last _ in _ packet _ buffer ▁; ▁if ▁( ▁! ▁last ▁) ▁continue ▁; ▁last _ dts ▁= ▁av _ re scale _ q ▁( ▁last ▁-> ▁pkt ▁. ▁dts ▁, ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁delta _ dts ▁= ▁FF MAX ▁( ▁delta _ dts ▁, ▁last _ dts ▁- ▁top _ dts ▁) ▁; ▁} ▁if ▁( ▁delta _ dts ▁> ▁s ▁-> ▁max _ inter leave _ delta ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Delay b et we ent he first packet and last packet int he " ▁" mux ing queue is %" ▁PRId 64 ▁"> %" ▁PRId 64 ▁": for cing output \ n " ▁, ▁delta _ dts ▁, ▁s ▁-> ▁max _ inter leave _ delta ▁) ▁; ▁flush ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁&& ▁eof ▁&& ▁( ▁s ▁-> ▁flags ▁& ▁AV FMT _ FLAG _ SHORT EST ▁) ▁&& ▁s ▁-> ▁internal ▁-> ▁shortest _ end ▁== ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁AVPacket ▁* ▁top _ pkt ▁= ▁& ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁-> ▁pkt ▁; ▁s ▁-> ▁internal ▁-> ▁shortest _ end ▁= ▁av _ re scale _ q ▁( ▁top _ pkt ▁-> ▁dts ▁, ▁s ▁-> ▁streams ▁[ ▁top _ pkt ▁-> ▁stream _ index ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁internal ▁-> ▁shortest _ end ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁while ▁( ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁) ▁{ ▁AVPacket ▁* ▁top _ pkt ▁= ▁& ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁-> ▁pkt ▁; ▁AVStream ▁* ▁st ▁; ▁int 64_ t ▁top _ dts ▁= ▁av _ re scale _ q ▁( ▁top _ pkt ▁-> ▁dts ▁, ▁s ▁-> ▁streams ▁[ ▁top _ pkt ▁-> ▁stream _ index ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁if ▁( ▁s ▁-> ▁internal ▁-> ▁shortest _ end ▁+ ▁1 ▁>= ▁top _ dts ▁) ▁break ▁; ▁pk tl ▁= ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁; ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁pk tl ▁-> ▁pkt ▁. ▁stream _ index ▁] ▁; ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁= ▁pk tl ▁-> ▁next ▁; ▁if ▁( ▁! ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁) ▁s ▁-> ▁internal ▁-> ▁packet _ buffer _ end ▁= ▁NULL ▁; ▁if ▁( ▁st ▁-> ▁last _ in _ packet _ buffer ▁== ▁pk tl ▁) ▁st ▁-> ▁last _ in _ packet _ buffer ▁= ▁NULL ▁; ▁av _ packet _ unref ▁( ▁& ▁pk tl ▁-> ▁pkt ▁) ▁; ▁av _ freep ▁( ▁& ▁pk tl ▁) ▁; ▁flush ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁stream _ count ▁&& ▁flush ▁) ▁{ ▁AVStream ▁* ▁st ▁; ▁pk tl ▁= ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁; ▁* ▁out ▁= ▁pk tl ▁-> ▁pkt ▁; ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁out ▁-> ▁stream _ index ▁] ▁; ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁= ▁pk tl ▁-> ▁next ▁; ▁if ▁( ▁! ▁s ▁-> ▁internal ▁-> ▁packet _ buffer ▁) ▁s ▁-> ▁internal ▁-> ▁packet _ buffer _ end ▁= ▁NULL ▁; ▁if ▁( ▁st ▁-> ▁last _ in _ packet _ buffer ▁== ▁pk tl ▁) ▁st ▁-> ▁last _ in _ packet _ buffer ▁= ▁NULL ▁; ▁av _ freep ▁( ▁& ▁pk tl ▁) ▁; ▁return ▁1 ▁; ▁} ▁else ▁{ ▁av _ init _ packet ▁( ▁out ▁) ▁; ▁return ▁0 ▁; ▁} ▁}	1
▁UI _ METHOD ▁* ▁UI _ create _ method ▁( ▁char ▁* ▁name ▁) ▁{ ▁UI _ METHOD ▁* ▁ui _ method ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁ui _ method ▁) ▁) ▁; ▁if ▁( ▁ui _ method ▁!= ▁NULL ▁) ▁ui _ method ▁-> ▁name ▁= ▁OPENSSL _ strdup ▁( ▁name ▁) ▁; ▁return ▁ui _ method ▁; ▁}	0
▁static ▁av _ cold ▁int ▁wm av oice _ decode _ init ▁( ▁AVCodecContext ▁* ▁ctx ▁) ▁{ ▁int ▁n ▁, ▁flags ▁, ▁pitch _ range ▁, ▁lsp 16_ flag ▁; ▁W MA Voice Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv _ data ▁; ▁if ▁( ▁ctx ▁-> ▁extradata _ size ▁!= ▁46 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" In val i dex trad atas ize % d ( should be 46 )\ n " ▁, ▁ctx ▁-> ▁extradata _ size ▁) ▁; ▁return ▁-1 ▁; ▁} ▁flags ▁= ▁AV _ RL 32 ▁( ▁ctx ▁-> ▁extradata ▁+ ▁18 ▁) ▁; ▁s ▁-> ▁sp illo ver _ bit size ▁= ▁3 ▁+ ▁av _ ceil _ log 2 ▁( ▁ctx ▁-> ▁block _ align ▁) ▁; ▁s ▁-> ▁do _ ap f ▁= ▁flags ▁& ▁0 x 1 ▁; ▁if ▁( ▁s ▁-> ▁do _ ap f ▁) ▁{ ▁ff _ rd ft _ init ▁( ▁& ▁s ▁-> ▁rd ft ▁, ▁7 ▁, ▁D FT _ R 2 C ▁) ▁; ▁ff _ rd ft _ init ▁( ▁& ▁s ▁-> ▁ir dft ▁, ▁7 ▁, ▁ID FT _ C 2 R ▁) ▁; ▁ff _ dct _ init ▁( ▁& ▁s ▁-> ▁dct ▁, ▁6 ▁, ▁DCT _ I ▁) ▁; ▁ff _ dct _ init ▁( ▁& ▁s ▁-> ▁dst ▁, ▁6 ▁, ▁DST _ I ▁) ▁; ▁ff _ s ine _ window _ init ▁( ▁s ▁-> ▁cos ▁, ▁256 ▁) ▁; ▁memcpy ▁( ▁& ▁s ▁-> ▁sin ▁[ ▁255 ▁] ▁, ▁s ▁-> ▁cos ▁, ▁256 ▁* ▁sizeof ▁( ▁s ▁-> ▁cos ▁[ ▁0 ▁] ▁) ▁) ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁255 ▁; ▁n ▁++ ▁) ▁{ ▁s ▁-> ▁sin ▁[ ▁n ▁] ▁= ▁- ▁s ▁-> ▁sin ▁[ ▁510 ▁- ▁n ▁] ▁; ▁s ▁-> ▁cos ▁[ ▁510 ▁- ▁n ▁] ▁= ▁s ▁-> ▁cos ▁[ ▁n ▁] ▁; ▁} ▁} ▁s ▁-> ▁den o ise _ strength ▁= ▁( ▁flags ▁>> ▁2 ▁) ▁& ▁0 xF ▁; ▁if ▁( ▁s ▁-> ▁den o ise _ strength ▁>= ▁12 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid d eno ise filter strength % d ( max = 11 )\ n " ▁, ▁s ▁-> ▁den o ise _ strength ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁den o ise _ til t _ corr ▁= ▁! ▁! ▁( ▁flags ▁& ▁0 x 40 ▁) ▁; ▁s ▁-> ▁dc _ level ▁= ▁( ▁flags ▁>> ▁7 ▁) ▁& ▁0 xF ▁; ▁s ▁-> ▁lsp _ q _ mode ▁= ▁! ▁! ▁( ▁flags ▁& ▁0 x 2000 ▁) ▁; ▁s ▁-> ▁lsp _ def _ mode ▁= ▁! ▁! ▁( ▁flags ▁& ▁0 x 4000 ▁) ▁; ▁lsp 16_ flag ▁= ▁flags ▁& ▁0 x 1000 ▁; ▁if ▁( ▁lsp 16_ flag ▁) ▁{ ▁s ▁-> ▁ls ps ▁= ▁16 ▁; ▁s ▁-> ▁frame _ l sp _ bit size ▁= ▁34 ▁; ▁s ▁-> ▁sf rame _ l sp _ bit size ▁= ▁60 ▁; ▁} ▁else ▁{ ▁s ▁-> ▁ls ps ▁= ▁10 ▁; ▁s ▁-> ▁frame _ l sp _ bit size ▁= ▁24 ▁; ▁s ▁-> ▁sf rame _ l sp _ bit size ▁= ▁48 ▁; ▁} ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁s ▁-> ▁ls ps ▁; ▁n ▁++ ▁) ▁s ▁-> ▁prev _ ls ps ▁[ ▁n ▁] ▁= ▁M _ PI ▁* ▁( ▁n ▁+ ▁1.0 ▁) ▁/ ▁( ▁s ▁-> ▁ls ps ▁+ ▁1.0 ▁) ▁; ▁init _ get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁ctx ▁-> ▁extradata ▁+ ▁22 ▁, ▁( ▁ctx ▁-> ▁extradata _ size ▁- ▁22 ▁) ▁<< ▁3 ▁) ▁; ▁if ▁( ▁decode _ vb mt ree ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁vb m _ tree ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid VB M tree ; broken extr adata ?\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁min _ pitch _ val ▁= ▁( ▁( ▁ctx ▁-> ▁sample _ rate ▁<< ▁8 ▁) ▁/ ▁400 ▁+ ▁50 ▁) ▁>> ▁8 ▁; ▁s ▁-> ▁max _ pitch _ val ▁= ▁( ▁( ▁ctx ▁-> ▁sample _ rate ▁<< ▁8 ▁) ▁* ▁37 ▁/ ▁2000 ▁+ ▁50 ▁) ▁>> ▁8 ▁; ▁pitch _ range ▁= ▁s ▁-> ▁max _ pitch _ val ▁- ▁s ▁-> ▁min _ pitch _ val ▁; ▁s ▁-> ▁pitch _ n bits ▁= ▁av _ ceil _ log 2 ▁( ▁pitch _ range ▁) ▁; ▁s ▁-> ▁last _ pitch _ val ▁= ▁40 ▁; ▁s ▁-> ▁last _ acb _ type ▁= ▁AC B _ TYPE _ NONE ▁; ▁s ▁-> ▁history _ ns amples ▁= ▁s ▁-> ▁max _ pitch _ val ▁+ ▁8 ▁; ▁if ▁( ▁s ▁-> ▁min _ pitch _ val ▁< ▁1 ▁|| ▁s ▁-> ▁history _ ns amples ▁> ▁MAX _ SIGNAL _ HISTORY ▁) ▁{ ▁int ▁min _ sr ▁= ▁( ▁( ▁( ▁( ▁1 ▁<< ▁8 ▁) ▁- ▁50 ▁) ▁* ▁400 ▁) ▁+ ▁0 xFF ▁) ▁>> ▁8 ▁, ▁max _ sr ▁= ▁( ▁( ▁( ▁( ▁MAX _ SIGNAL _ HISTORY ▁- ▁8 ▁) ▁<< ▁8 ▁) ▁+ ▁205 ▁) ▁* ▁2000 ▁/ ▁37 ▁) ▁>> ▁8 ▁; ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported sampler ate % d ( min =% d , max =% d )\ n " ▁, ▁ctx ▁-> ▁sample _ rate ▁, ▁min _ sr ▁, ▁max _ sr ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁block _ conv _ table ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁min _ pitch _ val ▁; ▁s ▁-> ▁block _ conv _ table ▁[ ▁1 ▁] ▁= ▁( ▁pitch _ range ▁* ▁25 ▁) ▁>> ▁6 ▁; ▁s ▁-> ▁block _ conv _ table ▁[ ▁2 ▁] ▁= ▁( ▁pitch _ range ▁* ▁44 ▁) ▁>> ▁6 ▁; ▁s ▁-> ▁block _ conv _ table ▁[ ▁3 ▁] ▁= ▁s ▁-> ▁max _ pitch _ val ▁- ▁1 ▁; ▁s ▁-> ▁block _ delta _ pitch _ h range ▁= ▁( ▁pitch _ range ▁>> ▁3 ▁) ▁& ▁ ~ ▁0 xF ▁; ▁s ▁-> ▁block _ delta _ pitch _ n bits ▁= ▁1 ▁+ ▁av _ ceil _ log 2 ▁( ▁s ▁-> ▁block _ delta _ pitch _ h range ▁) ▁; ▁s ▁-> ▁block _ pitch _ range ▁= ▁s ▁-> ▁block _ conv _ table ▁[ ▁2 ▁] ▁+ ▁s ▁-> ▁block _ conv _ table ▁[ ▁3 ▁] ▁+ ▁1 ▁+ ▁2 ▁* ▁( ▁s ▁-> ▁block _ conv _ table ▁[ ▁1 ▁] ▁- ▁2 ▁* ▁s ▁-> ▁min _ pitch _ val ▁) ▁; ▁s ▁-> ▁block _ pitch _ n bits ▁= ▁av _ ceil _ log 2 ▁( ▁s ▁-> ▁block _ pitch _ range ▁) ▁; ▁ctx ▁-> ▁sample _ fmt ▁= ▁AV _ SAMPLE _ FMT _ FLT ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁process _ input _ packet ▁( ▁InputStream ▁* ▁ist ▁, ▁const ▁AVPacket ▁* ▁pkt ▁, ▁int ▁no _ eof ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁, ▁i ▁; ▁int ▁re peating ▁= ▁0 ▁; ▁int ▁eof _ reached ▁= ▁0 ▁; ▁AVPacket ▁avpkt ▁; ▁if ▁( ▁! ▁ist ▁-> ▁saw _ first _ ts ▁) ▁{ ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁st ▁-> ▁avg _ frame _ rate ▁. ▁num ▁? ▁- ▁ist ▁-> ▁dec _ ctx ▁-> ▁has _ b _ frames ▁* ▁AV _ TIME _ BASE ▁/ ▁av _ q 2 d ▁( ▁ist ▁-> ▁st ▁-> ▁avg _ frame _ rate ▁) ▁: ▁0 ▁; ▁ist ▁-> ▁pts ▁= ▁0 ▁; ▁if ▁( ▁pkt ▁&& ▁pkt ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁{ ▁ist ▁-> ▁dts ▁+= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁pts ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁} ▁ist ▁-> ▁saw _ first _ ts ▁= ▁1 ▁; ▁} ▁if ▁( ▁ist ▁-> ▁next _ dts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁ist ▁-> ▁next _ dts ▁= ▁ist ▁-> ▁dts ▁; ▁if ▁( ▁ist ▁-> ▁next _ pts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁pts ▁; ▁if ▁( ▁! ▁pkt ▁) ▁{ ▁av _ init _ packet ▁( ▁& ▁avpkt ▁) ▁; ▁avpkt ▁. ▁data ▁= ▁NULL ▁; ▁avpkt ▁. ▁size ▁= ▁0 ▁; ▁} ▁else ▁{ ▁avpkt ▁= ▁* ▁pkt ▁; ▁} ▁if ▁( ▁pkt ▁&& ▁pkt ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁= ▁ist ▁-> ▁dts ▁= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁dts ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁if ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ VIDEO ▁|| ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁} ▁while ▁( ▁ist ▁-> ▁decoding _ needed ▁) ▁{ ▁int ▁duration ▁= ▁0 ▁; ▁int ▁got _ output ▁= ▁0 ▁; ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁next _ pts ▁; ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁switch ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁ret ▁= ▁decode _ audio ▁( ▁ist ▁, ▁re peating ▁? ▁NULL ▁: ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁ret ▁= ▁decode _ video ▁( ▁ist ▁, ▁re peating ▁? ▁NULL ▁: ▁& ▁avpkt ▁, ▁& ▁got _ output ▁, ▁! ▁pkt ▁) ▁; ▁if ▁( ▁! ▁re peating ▁|| ▁! ▁pkt ▁|| ▁got _ output ▁) ▁{ ▁if ▁( ▁pkt ▁&& ▁pkt ▁-> ▁duration ▁) ▁{ ▁duration ▁= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁duration ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁} ▁else ▁if ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁!= ▁0 ▁&& ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁den ▁!= ▁0 ▁) ▁{ ▁int ▁ticks ▁= ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁? ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁-> ▁repeat _ p ict ▁+ ▁1 ▁: ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁duration ▁= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁den ▁* ▁ticks ▁) ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁} ▁if ▁( ▁ist ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁duration ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁+= ▁duration ▁; ▁} ▁else ▁ist ▁-> ▁next _ dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁if ▁( ▁got _ output ▁) ▁ist ▁-> ▁next _ pts ▁+= ▁duration ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ SUBTITLE ▁: ▁if ▁( ▁re peating ▁) ▁break ▁; ▁ret ▁= ▁trans code _ sub title s ▁( ▁ist ▁, ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁if ▁( ▁! ▁pkt ▁&& ▁ret ▁>= ▁0 ▁) ▁ret ▁= ▁AVERROR _ EOF ▁; ▁break ▁; ▁default ▁: ▁return ▁-1 ▁; ▁} ▁if ▁( ▁ret ▁== ▁AVERROR _ EOF ▁) ▁{ ▁eof _ reached ▁= ▁1 ▁; ▁break ▁; ▁} ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error while de coding stream #% d :% d :% s \ n " ▁, ▁ist ▁-> ▁file _ index ▁, ▁ist ▁-> ▁st ▁-> ▁index ▁, ▁av _ err 2 str ▁( ▁ret ▁) ▁) ▁; ▁if ▁( ▁exit _ on _ error ▁) ▁exit _ program ▁( ▁1 ▁) ▁; ▁if ▁( ▁! ▁pkt ▁) ▁eof _ reached ▁= ▁1 ▁; ▁break ▁; ▁} ▁if ▁( ▁! ▁got _ output ▁) ▁break ▁; ▁if ▁( ▁! ▁pkt ▁) ▁break ▁; ▁re peating ▁= ▁1 ▁; ▁} ▁if ▁( ▁! ▁pkt ▁&& ▁ist ▁-> ▁decoding _ needed ▁&& ▁eof _ reached ▁&& ▁! ▁no _ eof ▁) ▁{ ▁int ▁ret ▁= ▁send _ filter _ eof ▁( ▁ist ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ FATAL ▁, ▁" Err orm ark ing filters as finished \ n " ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁{ ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁switch ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁ist ▁-> ▁next _ dts ▁+= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁dec _ ctx ▁-> ▁frame _ size ▁) ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁sample _ rate ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁if ▁( ▁ist ▁-> ▁fram erate ▁. ▁num ▁) ▁{ ▁AVR ational ▁time _ base _ q ▁= ▁AV _ TIME _ BASE _ Q ▁; ▁int 64_ t ▁next _ dts ▁= ▁av _ re scale _ q ▁( ▁ist ▁-> ▁next _ dts ▁, ▁time _ base _ q ▁, ▁av _ inv _ q ▁( ▁ist ▁-> ▁fram erate ▁) ▁) ▁; ▁ist ▁-> ▁next _ dts ▁= ▁av _ re scale _ q ▁( ▁next _ dts ▁+ ▁1 ▁, ▁av _ inv _ q ▁( ▁ist ▁-> ▁fram erate ▁) ▁, ▁time _ base _ q ▁) ▁; ▁} ▁else ▁if ▁( ▁pkt ▁-> ▁duration ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁+= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁duration ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁} ▁else ▁if ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁!= ▁0 ▁) ▁{ ▁int ▁ticks ▁= ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁? ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁-> ▁repeat _ p ict ▁+ ▁1 ▁: ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁ist ▁-> ▁next _ dts ▁+= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁den ▁* ▁ticks ▁) ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁} ▁break ▁; ▁} ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁pkt ▁&& ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁check _ output _ constraints ▁( ▁ist ▁, ▁o st ▁) ▁|| ▁o st ▁-> ▁encoding _ needed ▁) ▁continue ▁; ▁do _ stream copy ▁( ▁ist ▁, ▁o st ▁, ▁pkt ▁) ▁; ▁} ▁return ▁! ▁eof _ reached ▁; ▁}	0
▁OPENSSL _ STACK ▁* ▁OPENSSL _ sk _ new ▁( ▁OPENSSL _ sk _ comp func ▁c ▁) ▁{ ▁OPENSSL _ STACK ▁* ▁ret ▁= ▁OPENSSL _ sk _ new _ null ▁( ▁) ▁; ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁ret ▁-> ▁comp ▁= ▁c ▁; ▁return ▁ret ▁; ▁}	0
▁void ▁ngx _ sort ▁( ▁void ▁* ▁base ▁, ▁size _ t ▁n ▁, ▁size _ t ▁size ▁, ▁ngx _ int _ t ▁( ▁* ▁cmp ▁) ▁( ▁const ▁void ▁* ▁, ▁const ▁void ▁* ▁) ▁) ▁{ ▁u _ char ▁* ▁p 1 ▁, ▁* ▁p 2 ▁, ▁* ▁p ▁; ▁p ▁= ▁ngx _ alloc ▁( ▁size ▁, ▁ngx _ cycle ▁-> ▁log ▁) ▁; ▁if ▁( ▁p ▁== ▁NULL ▁) ▁{ ▁return ▁; ▁} ▁for ▁( ▁p 1 ▁= ▁( ▁u _ char ▁* ▁) ▁base ▁+ ▁size ▁; ▁p 1 ▁< ▁( ▁u _ char ▁* ▁) ▁base ▁+ ▁n ▁* ▁size ▁; ▁p 1 ▁+= ▁size ▁) ▁{ ▁ngx _ memcpy ▁( ▁p ▁, ▁p 1 ▁, ▁size ▁) ▁; ▁for ▁( ▁p 2 ▁= ▁p 1 ▁; ▁p 2 ▁> ▁( ▁u _ char ▁* ▁) ▁base ▁&& ▁cmp ▁( ▁p 2 ▁- ▁size ▁, ▁p ▁) ▁> ▁0 ▁; ▁p 2 ▁-= ▁size ▁) ▁{ ▁ngx _ memcpy ▁( ▁p 2 ▁, ▁p 2 ▁- ▁size ▁, ▁size ▁) ▁; ▁} ▁ngx _ memcpy ▁( ▁p 2 ▁, ▁p ▁, ▁size ▁) ▁; ▁} ▁ngx _ free ▁( ▁p ▁) ▁; ▁}	1
▁static ▁int ▁get _ scale _ factor ▁( ▁H 264 Slice Context ▁* ▁sl ▁, ▁int ▁p oc ▁, ▁int ▁p oc 1 ▁, ▁int ▁i ▁) ▁{ ▁int ▁p oc 0 ▁= ▁sl ▁-> ▁ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁p oc ▁; ▁int ▁td ▁= ▁av _ clip _ int 8 ▁( ▁p oc 1 ▁- ▁p oc 0 ▁) ▁; ▁if ▁( ▁td ▁== ▁0 ▁|| ▁sl ▁-> ▁ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁parent ▁-> ▁long _ ref ▁) ▁{ ▁return ▁256 ▁; ▁} ▁else ▁{ ▁int ▁tb ▁= ▁av _ clip _ int 8 ▁( ▁p oc ▁- ▁p oc 0 ▁) ▁; ▁int ▁tx ▁= ▁( ▁16384 ▁+ ▁( ▁FF ABS ▁( ▁td ▁) ▁>> ▁1 ▁) ▁) ▁/ ▁td ▁; ▁return ▁av _ clip _ int p 2 ▁( ▁( ▁tb ▁* ▁tx ▁+ ▁32 ▁) ▁>> ▁6 ▁, ▁10 ▁) ▁; ▁} ▁}	1
▁static ▁int ▁ftp _ current _ dir ▁( ▁FTP Context ▁* ▁s ▁) ▁{ ▁char ▁* ▁res ▁= ▁NULL ▁, ▁* ▁start ▁= ▁NULL ▁, ▁* ▁end ▁= ▁NULL ▁; ▁int ▁i ▁; ▁const ▁char ▁* ▁command ▁= ▁" PWD \ r \ n " ▁; ▁const ▁int ▁pwd _ codes ▁[ ▁] ▁= ▁{ ▁257 ▁, ▁0 ▁} ▁; ▁if ▁( ▁! ▁ftp _ send _ command ▁( ▁s ▁, ▁command ▁, ▁pwd _ codes ▁, ▁& ▁res ▁) ▁) ▁goto ▁fail ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁res ▁[ ▁i ▁] ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁res ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁! ▁start ▁) ▁{ ▁start ▁= ▁res ▁+ ▁i ▁+ ▁1 ▁; ▁continue ▁; ▁} ▁end ▁= ▁res ▁+ ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁end ▁) ▁goto ▁fail ▁; ▁if ▁( ▁end ▁> ▁res ▁&& ▁end ▁[ ▁-1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁end ▁[ ▁-1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁else ▁* ▁end ▁= ▁' ▁\0 ▁' ▁; ▁av _ strlcpy ▁( ▁s ▁-> ▁path ▁, ▁start ▁, ▁sizeof ▁( ▁s ▁-> ▁path ▁) ▁) ▁; ▁av _ free ▁( ▁res ▁) ▁; ▁return ▁0 ▁; ▁fail ▁: ▁av _ free ▁( ▁res ▁) ▁; ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁}	1
▁static ▁int ▁decode _ plane ▁( ▁In de o 3 Decode Context ▁* ▁ctx ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁Plane ▁* ▁plane ▁, ▁const ▁uint 8_ t ▁* ▁data ▁, ▁int 32_ t ▁data _ size ▁, ▁int 32_ t ▁strip _ width ▁) ▁{ ▁Cell ▁curr _ cell ▁; ▁uint 32_ t ▁num _ vectors ▁; ▁num _ vectors ▁= ▁bytestream _ get _ le 32 ▁( ▁& ▁data ▁) ▁; ▁if ▁( ▁num _ vectors ▁>= ▁data _ size ▁/ ▁2 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁ctx ▁-> ▁mc _ vectors ▁= ▁num _ vectors ▁? ▁data ▁: ▁0 ▁; ▁data ▁+= ▁num _ vectors ▁* ▁2 ▁; ▁data _ size ▁-= ▁num _ vectors ▁* ▁2 ▁; ▁init _ get _ bits ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁data ▁, ▁data _ size ▁<< ▁3 ▁) ▁; ▁ctx ▁-> ▁skip _ bits ▁= ▁0 ▁; ▁ctx ▁-> ▁need _ res ync ▁= ▁0 ▁; ▁ctx ▁-> ▁last _ byte ▁= ▁data ▁+ ▁data _ size ▁- ▁1 ▁; ▁curr _ cell ▁. ▁xpos ▁= ▁curr _ cell ▁. ▁ypos ▁= ▁0 ▁; ▁curr _ cell ▁. ▁width ▁= ▁plane ▁-> ▁width ▁>> ▁2 ▁; ▁curr _ cell ▁. ▁height ▁= ▁plane ▁-> ▁height ▁>> ▁2 ▁; ▁curr _ cell ▁. ▁tree ▁= ▁0 ▁; ▁curr _ cell ▁. ▁mv _ ptr ▁= ▁0 ▁; ▁return ▁parse _ b intree ▁( ▁ctx ▁, ▁avctx ▁, ▁plane ▁, ▁IN TRA _ NULL ▁, ▁& ▁curr _ cell ▁, ▁CELL _ STACK _ MAX ▁, ▁strip _ width ▁) ▁; ▁}	0
▁static ▁int ▁url _ open _ dyn _ buf _ internal ▁( ▁AVIO Context ▁* ▁* ▁s ▁, ▁int ▁max _ packet _ size ▁) ▁{ ▁Dyn Buffer ▁* ▁d ▁; ▁int ▁ret ▁; ▁unsigned ▁io _ buffer _ size ▁= ▁max _ packet _ size ▁? ▁max _ packet _ size ▁: ▁1024 ▁; ▁if ▁( ▁sizeof ▁( ▁Dyn Buffer ▁) ▁+ ▁io _ buffer _ size ▁< ▁io _ buffer _ size ▁) ▁return ▁-1 ▁; ▁d ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁Dyn Buffer ▁) ▁+ ▁io _ buffer _ size ▁) ▁; ▁if ▁( ▁! ▁d ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁* ▁s ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVIO Context ▁) ▁) ▁; ▁if ▁( ▁! ▁* ▁s ▁) ▁{ ▁av _ free ▁( ▁d ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁d ▁-> ▁io _ buffer _ size ▁= ▁io _ buffer _ size ▁; ▁ret ▁= ▁ff io _ init _ context ▁( ▁* ▁s ▁, ▁d ▁-> ▁io _ buffer ▁, ▁io _ buffer _ size ▁, ▁1 ▁, ▁d ▁, ▁NULL ▁, ▁max _ packet _ size ▁? ▁dyn _ packet _ buf _ write ▁: ▁dyn _ buf _ write ▁, ▁max _ packet _ size ▁? ▁NULL ▁: ▁dyn _ buf _ seek ▁) ▁; ▁if ▁( ▁ret ▁== ▁0 ▁) ▁{ ▁( ▁* ▁s ▁) ▁-> ▁max _ packet _ size ▁= ▁max _ packet _ size ▁; ▁} ▁else ▁{ ▁av _ free ▁( ▁d ▁) ▁; ▁av _ freep ▁( ▁s ▁) ▁; ▁} ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁s rt _ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁const ▁unsigned ▁char ▁* ▁ptr ▁= ▁p ▁-> ▁buf ▁; ▁int ▁i ▁, ▁v ▁, ▁num ▁= ▁0 ▁; ▁if ▁( ▁AV _ RB 24 ▁( ▁ptr ▁) ▁== ▁0 xEF BB BF ▁) ▁ptr ▁+= ▁3 ▁; ▁while ▁( ▁* ▁ptr ▁== ▁' ▁\ r ▁' ▁|| ▁* ▁ptr ▁== ▁' ▁\ n ▁' ▁) ▁ptr ▁++ ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁num ▁== ▁i ▁|| ▁num ▁+ ▁1 ▁== ▁i ▁) ▁&& ▁sscanf ▁( ▁ptr ▁, ▁"%* d :% * 2 d :% * 2 d % * 1 [ , .] % * 3 d -- >% * d :% * 2 d :% * 2 d % * 1 [ , .] %3 d " ▁, ▁& ▁v ▁) ▁== ▁1 ▁) ▁return ▁AV PROBE _ SCORE _ MAX ▁; ▁num ▁= ▁atoi ▁( ▁ptr ▁) ▁; ▁ptr ▁+= ▁strcspn ▁( ▁ptr ▁, ▁"\ n " ▁) ▁+ ▁1 ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁write _ packet ▁( ▁AVFormatContext ▁* ▁ctx ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁W VM ux Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv _ data ▁; ▁if ▁( ▁pkt ▁-> ▁size ▁>= ▁24 ▁) ▁s ▁-> ▁samples ▁+= ▁AV _ RL 32 ▁( ▁pkt ▁-> ▁data ▁+ ▁20 ▁) ▁; ▁avio _ write ▁( ▁ctx ▁-> ▁pb ▁, ▁pkt ▁-> ▁data ▁, ▁pkt ▁-> ▁size ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁make _ cp _ exchange _ key ▁( ▁BIGNUM ▁* ▁priv _ key ▁, ▁EVP _ PKEY ▁* ▁pub k ▁, ▁unsigned ▁char ▁* ▁shared _ key ▁) ▁{ ▁unsigned ▁char ▁dh _ key ▁[ ▁128 ▁] ▁; ▁int ▁ret ▁; ▁g ost _ hash _ ctx ▁hash _ ctx ▁; ▁DH ▁* ▁dh ▁= ▁DH _ new ▁( ▁) ▁; ▁memset ▁( ▁dh _ key ▁, ▁0 ▁, ▁128 ▁) ▁; ▁dh ▁-> ▁g ▁= ▁BN _ dup ▁( ▁pub k ▁-> ▁pkey ▁. ▁dsa ▁-> ▁g ▁) ▁; ▁dh ▁-> ▁p ▁= ▁BN _ dup ▁( ▁pub k ▁-> ▁pkey ▁. ▁dsa ▁-> ▁p ▁) ▁; ▁dh ▁-> ▁priv _ key ▁= ▁BN _ dup ▁( ▁priv _ key ▁) ▁; ▁ret ▁= ▁compute _ pair _ key _ le ▁( ▁dh _ key ▁, ▁( ▁( ▁DSA ▁* ▁) ▁( ▁EVP _ PKEY _ get 0 ▁( ▁pub k ▁) ▁) ▁) ▁-> ▁pub _ key ▁, ▁dh ▁) ▁; ▁DH _ free ▁( ▁dh ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁return ▁0 ▁; ▁init _ g ost _ hash _ ctx ▁( ▁& ▁hash _ ctx ▁, ▁& ▁G ost R 34 11_ 94_ Crypto Pro Param Set ▁) ▁; ▁start _ hash ▁( ▁& ▁hash _ ctx ▁) ▁; ▁hash _ block ▁( ▁& ▁hash _ ctx ▁, ▁dh _ key ▁, ▁128 ▁) ▁; ▁finish _ hash ▁( ▁& ▁hash _ ctx ▁, ▁shared _ key ▁) ▁; ▁done _ g ost _ hash _ ctx ▁( ▁& ▁hash _ ctx ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁request _ rec ▁* ▁ap _ read _ request ▁( ▁conn _ rec ▁* ▁conn ▁) ▁{ ▁int ▁access _ status ▁; ▁apr _ bucket _ b rig ade ▁* ▁tmp _ bb ▁; ▁request _ rec ▁* ▁r ▁= ▁ap _ create _ request ▁( ▁conn ▁) ▁; ▁tmp _ bb ▁= ▁apr _ b rig ade _ create ▁( ▁r ▁-> ▁pool ▁, ▁r ▁-> ▁connection ▁-> ▁bucket _ alloc ▁) ▁; ▁ap _ run _ pre _ read _ request ▁( ▁r ▁, ▁conn ▁) ▁; ▁if ▁( ▁! ▁read _ request _ line ▁( ▁r ▁, ▁tmp _ bb ▁) ▁|| ▁! ▁ap _ parse _ request _ line ▁( ▁r ▁) ▁) ▁{ ▁apr _ b rig ade _ cleanup ▁( ▁tmp _ bb ▁) ▁; ▁switch ▁( ▁r ▁-> ▁status ▁) ▁{ ▁case ▁HTTP _ REQUEST _ URI _ TOO _ LARGE ▁: ▁case ▁HTTP _ BAD _ REQUEST ▁: ▁case ▁HTTP _ VERSION _ NOT _ SUPPORTED ▁: ▁case ▁HTTP _ NOT _ IMPLEMENTED ▁: ▁if ▁( ▁r ▁-> ▁status ▁== ▁HTTP _ REQUEST _ URI _ TOO _ LARGE ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 05 65 ▁) ▁" request failed : client ' s request - line e xce eds Limit Request Line ( long er than % d )" ▁, ▁r ▁-> ▁server ▁-> ▁limit _ req _ line ▁) ▁; ▁} ▁else ▁if ▁( ▁r ▁-> ▁method ▁== ▁NULL ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 566 ▁) ▁" request failed : m alformed request line " ▁) ▁; ▁} ▁access _ status ▁= ▁r ▁-> ▁status ▁; ▁goto ▁die _ un usable _ input ▁; ▁case ▁HTTP _ REQUEST _ TIME _ OUT ▁: ▁ap _ update _ child _ status ▁( ▁conn ▁-> ▁sb h ▁, ▁SERVER _ BUSY _ LOG ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁r ▁-> ▁connection ▁-> ▁keep al ives ▁) ▁ap _ run _ log _ transaction ▁( ▁r ▁) ▁; ▁break ▁; ▁} ▁conn ▁-> ▁keep alive ▁= ▁AP _ CONN _ CLOSE ▁; ▁apr _ pool _ destroy ▁( ▁r ▁-> ▁pool ▁) ▁; ▁goto ▁ignore ▁; ▁} ▁apr _ b rig ade _ cleanup ▁( ▁tmp _ bb ▁) ▁; ▁apply _ server _ config ▁( ▁r ▁) ▁; ▁if ▁( ▁! ▁r ▁-> ▁ass back wards ▁) ▁{ ▁const ▁char ▁* ▁t enc ▁; ▁ap _ get _ mime _ headers _ core ▁( ▁r ▁, ▁tmp _ bb ▁) ▁; ▁apr _ b rig ade _ cleanup ▁( ▁tmp _ bb ▁) ▁; ▁if ▁( ▁r ▁-> ▁status ▁!= ▁HTTP _ OK ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 567 ▁) ▁" request failed : error reading the headers " ▁) ▁; ▁access _ status ▁= ▁r ▁-> ▁status ▁; ▁goto ▁die _ un usable _ input ▁; ▁} ▁t enc ▁= ▁apr _ table _ get ▁( ▁r ▁-> ▁headers _ in ▁, ▁" Transfer - Encoding " ▁) ▁; ▁if ▁( ▁t enc ▁) ▁{ ▁if ▁( ▁! ▁ap _ is _ chunk ed ▁( ▁r ▁-> ▁pool ▁, ▁t enc ▁) ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 25 39 ▁) ▁" client sent unknown Transfer - Encoding " ▁"(% s ) :% s " ▁, ▁t enc ▁, ▁r ▁-> ▁uri ▁) ▁; ▁access _ status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁goto ▁die _ un usable _ input ▁; ▁} ▁apr _ table _ unset ▁( ▁r ▁-> ▁headers _ in ▁, ▁" Content - Length " ▁) ▁; ▁} ▁} ▁ap _ add _ input _ filter _ handle ▁( ▁ap _ http _ input _ filter _ handle ▁, ▁NULL ▁, ▁r ▁, ▁r ▁-> ▁connection ▁) ▁; ▁if ▁( ▁! ▁ap _ check _ request _ header ▁( ▁r ▁) ▁) ▁{ ▁apply _ server _ config ▁( ▁r ▁) ▁; ▁access _ status ▁= ▁r ▁-> ▁status ▁; ▁goto ▁die _ before _ hooks ▁; ▁} ▁apply _ server _ config ▁( ▁r ▁) ▁; ▁if ▁( ▁( ▁access _ status ▁= ▁ap _ run _ post _ read _ request ▁( ▁r ▁) ▁) ▁) ▁{ ▁goto ▁die ▁; ▁} ▁AP _ READ _ REQUEST _ SUCCESS ▁( ▁( ▁uintptr _ t ▁) ▁r ▁, ▁( ▁char ▁* ▁) ▁r ▁-> ▁method ▁, ▁( ▁char ▁* ▁) ▁r ▁-> ▁uri ▁, ▁( ▁char ▁* ▁) ▁r ▁-> ▁server ▁-> ▁def n _ name ▁, ▁r ▁-> ▁status ▁) ▁; ▁return ▁r ▁; ▁die _ un usable _ input ▁: ▁{ ▁ap _ filter _ t ▁* ▁f ▁= ▁conn ▁-> ▁input _ filters ▁; ▁while ▁( ▁f ▁) ▁{ ▁ap _ filter _ re in state _ b rig ade ▁( ▁f ▁, ▁tmp _ bb ▁, ▁NULL ▁) ▁; ▁apr _ b rig ade _ cleanup ▁( ▁tmp _ bb ▁) ▁; ▁if ▁( ▁f ▁-> ▁f rec ▁== ▁ap _ core _ input _ filter _ handle ▁) ▁{ ▁break ▁; ▁} ▁ap _ remove _ input _ filter ▁( ▁f ▁) ▁; ▁f ▁= ▁f ▁-> ▁next ▁; ▁} ▁conn ▁-> ▁input _ filters ▁= ▁r ▁-> ▁input _ filters ▁= ▁f ▁; ▁conn ▁-> ▁keep alive ▁= ▁AP _ CONN _ CLOSE ▁; ▁} ▁die _ before _ hooks ▁: ▁r ▁-> ▁status ▁= ▁HTTP _ OK ▁; ▁die ▁: ▁ap _ die ▁( ▁access _ status ▁, ▁r ▁) ▁; ▁{ ▁apr _ bucket _ b rig ade ▁* ▁e or _ bb ▁; ▁e or _ bb ▁= ▁ap _ acquire _ b rig ade ▁( ▁conn ▁) ▁; ▁APR _ BR IG ADE _ INSERT _ TAIL ▁( ▁e or _ bb ▁, ▁ap _ bucket _ e or _ create ▁( ▁conn ▁-> ▁bucket _ alloc ▁, ▁r ▁) ▁) ▁; ▁ap _ pass _ b rig ade ▁( ▁conn ▁-> ▁output _ filters ▁, ▁e or _ bb ▁) ▁; ▁ap _ release _ b rig ade ▁( ▁conn ▁, ▁e or _ bb ▁) ▁; ▁} ▁ignore ▁: ▁r ▁= ▁NULL ▁; ▁AP _ READ _ REQUEST _ FAILURE ▁( ▁( ▁uintptr _ t ▁) ▁r ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁int ▁PKCS 12_ verify _ mac ▁( ▁PKCS 12 ▁* ▁p 12 ▁, ▁const ▁char ▁* ▁pass ▁, ▁int ▁passlen ▁) ▁{ ▁unsigned ▁char ▁mac ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁unsigned ▁int ▁mac len ▁; ▁const ▁ASN 1_ OCTET _ STRING ▁* ▁mac oct ▁; ▁if ▁( ▁p 12 ▁-> ▁mac ▁== ▁NULL ▁) ▁{ ▁PKCS 12 err ▁( ▁PKCS 12_ F _ PKCS 12_ VERIFY _ MAC ▁, ▁PKCS 12_ R _ MAC _ ABS ENT ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁! ▁pkcs 12_ gen _ mac ▁( ▁p 12 ▁, ▁pass ▁, ▁passlen ▁, ▁mac ▁, ▁& ▁mac len ▁, ▁PKCS 12_ key _ gen _ utf 8 ▁) ▁) ▁{ ▁PKCS 12 err ▁( ▁PKCS 12_ F _ PKCS 12_ VERIFY _ MAC ▁, ▁PKCS 12_ R _ MAC _ GENER ATION _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁X 509_ SIG _ get 0 ▁( ▁p 12 ▁-> ▁mac ▁-> ▁dinfo ▁, ▁NULL ▁, ▁& ▁mac oct ▁) ▁; ▁if ▁( ▁mac len ▁!= ▁( ▁unsigned ▁int ▁) ▁ASN 1_ STRING _ length ▁( ▁mac oct ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁CRYPTO _ memcmp ▁( ▁mac ▁, ▁ASN 1_ STRING _ get 0_ data ▁( ▁mac oct ▁) ▁, ▁mac len ▁) ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁pass ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁pkcs 12_ gen _ mac ▁( ▁p 12 ▁, ▁pass ▁, ▁passlen ▁, ▁mac ▁, ▁& ▁mac len ▁, ▁PKCS 12_ key _ gen _ asc ▁) ▁) ▁{ ▁PKCS 12 err ▁( ▁PKCS 12_ F _ PKCS 12_ VERIFY _ MAC ▁, ▁PKCS 12_ R _ MAC _ GENER ATION _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁( ▁mac len ▁!= ▁( ▁unsigned ▁int ▁) ▁ASN 1_ STRING _ length ▁( ▁mac oct ▁) ▁) ▁|| ▁CRYPTO _ memcmp ▁( ▁mac ▁, ▁ASN 1_ STRING _ get 0_ data ▁( ▁mac oct ▁) ▁, ▁mac len ▁) ▁!= ▁0 ▁) ▁return ▁0 ▁; ▁else ▁PKCS 12_ key _ gen ▁= ▁PKCS 12_ key _ gen _ asc ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁dss _ read _ seek ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁stream _ index ▁, ▁int 64_ t ▁timestamp ▁, ▁int ▁flags ▁) ▁{ ▁DSS Demux Context ▁* ▁ctx ▁= ▁s ▁-> ▁priv _ data ▁; ▁int 64_ t ▁ret ▁, ▁seek to ▁; ▁uint 8_ t ▁header ▁[ ▁DSS _ AUDIO _ BLOCK _ HEADER _ SIZE ▁] ▁; ▁int ▁offset ▁; ▁if ▁( ▁ctx ▁-> ▁audio _ codec ▁== ▁DSS _ ACO DEC _ DSS _ SP ▁) ▁seek to ▁= ▁timestamp ▁/ ▁2 64 ▁* ▁41 ▁/ ▁5 06 ▁* ▁512 ▁; ▁else ▁seek to ▁= ▁timestamp ▁/ ▁240 ▁* ▁ctx ▁-> ▁packet _ size ▁/ ▁5 06 ▁* ▁512 ▁; ▁if ▁( ▁seek to ▁< ▁0 ▁) ▁seek to ▁= ▁0 ▁; ▁seek to ▁+= ▁ctx ▁-> ▁dss _ header _ size ▁; ▁ret ▁= ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁seek to ▁, ▁SEEK _ SET ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁header ▁, ▁DSS _ AUDIO _ BLOCK _ HEADER _ SIZE ▁) ▁; ▁ctx ▁-> ▁swap ▁= ▁! ▁! ▁( ▁header ▁[ ▁0 ▁] ▁& ▁0 x 80 ▁) ▁; ▁offset ▁= ▁2 ▁* ▁header ▁[ ▁1 ▁] ▁+ ▁2 ▁* ▁ctx ▁-> ▁swap ▁; ▁if ▁( ▁offset ▁< ▁DSS _ AUDIO _ BLOCK _ HEADER _ SIZE ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁offset ▁== ▁DSS _ AUDIO _ BLOCK _ HEADER _ SIZE ▁) ▁{ ▁ctx ▁-> ▁counter ▁= ▁0 ▁; ▁offset ▁= ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁- ▁DSS _ AUDIO _ BLOCK _ HEADER _ SIZE ▁) ▁; ▁} ▁else ▁{ ▁ctx ▁-> ▁counter ▁= ▁DSS _ BLOCK _ SIZE ▁- ▁offset ▁; ▁offset ▁= ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁offset ▁- ▁DSS _ AUDIO _ BLOCK _ HEADER _ SIZE ▁) ▁; ▁} ▁ctx ▁-> ▁dss _ sp _ swap _ byte ▁= ▁-1 ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁EVP _ MD _ CTX _ copy _ ex ▁( ▁EVP _ MD _ CTX ▁* ▁out ▁, ▁const ▁EVP _ MD _ CTX ▁* ▁in ▁) ▁{ ▁unsigned ▁char ▁* ▁tmp _ buf ▁; ▁if ▁( ▁in ▁== ▁NULL ▁|| ▁in ▁-> ▁digest ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ MD _ CTX _ COPY _ EX ▁, ▁EVP _ R _ INPUT _ NOT _ INITIALIZED ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁in ▁-> ▁digest ▁-> ▁prov ▁== ▁NULL ▁) ▁goto ▁legacy ▁; ▁if ▁( ▁in ▁-> ▁digest ▁-> ▁dup ctx ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ MD _ CTX _ COPY _ EX ▁, ▁EVP _ R _ NOT _ ABLE _ TO _ COPY _ CTX ▁) ▁; ▁return ▁0 ▁; ▁} ▁EVP _ MD _ CTX _ reset ▁( ▁out ▁) ▁; ▁if ▁( ▁out ▁-> ▁fetched _ digest ▁!= ▁NULL ▁) ▁EVP _ MD _ meth _ free ▁( ▁out ▁-> ▁fetched _ digest ▁) ▁; ▁* ▁out ▁= ▁* ▁in ▁; ▁out ▁-> ▁pctx ▁= ▁NULL ▁; ▁out ▁-> ▁prov ctx ▁= ▁NULL ▁; ▁if ▁( ▁in ▁-> ▁fetched _ digest ▁!= ▁NULL ▁) ▁EVP _ MD _ up _ ref ▁( ▁in ▁-> ▁fetched _ digest ▁) ▁; ▁out ▁-> ▁prov ctx ▁= ▁in ▁-> ▁digest ▁-> ▁dup ctx ▁( ▁in ▁-> ▁prov ctx ▁) ▁; ▁if ▁( ▁out ▁-> ▁prov ctx ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ MD _ CTX _ COPY _ EX ▁, ▁EVP _ R _ NOT _ ABLE _ TO _ COPY _ CTX ▁) ▁; ▁return ▁0 ▁; ▁} ▁EVP _ MD _ CTX _ clear _ flags ▁( ▁out ▁, ▁EVP _ MD _ CTX _ FLAG _ KEEP _ PKEY _ CTX ▁) ▁; ▁# ifndef ▁FIPS _ MODE ▁if ▁( ▁in ▁-> ▁pctx ▁!= ▁NULL ▁) ▁{ ▁out ▁-> ▁pctx ▁= ▁EVP _ PKEY _ CTX _ dup ▁( ▁in ▁-> ▁pctx ▁) ▁; ▁if ▁( ▁out ▁-> ▁pctx ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ MD _ CTX _ COPY _ EX ▁, ▁EVP _ R _ NOT _ ABLE _ TO _ COPY _ CTX ▁) ▁; ▁EVP _ MD _ CTX _ reset ▁( ▁out ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁# endif ▁return ▁1 ▁; ▁legacy ▁: ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ ENGINE ▁) ▁&& ▁! ▁defined ▁( ▁FIPS _ MODE ▁) ▁if ▁( ▁in ▁-> ▁engine ▁&& ▁! ▁ENGINE _ init ▁( ▁in ▁-> ▁engine ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ MD _ CTX _ COPY _ EX ▁, ▁ERR _ R _ ENGINE _ LIB ▁) ▁; ▁return ▁0 ▁; ▁} ▁# endif ▁if ▁( ▁out ▁-> ▁digest ▁== ▁in ▁-> ▁digest ▁) ▁{ ▁tmp _ buf ▁= ▁out ▁-> ▁md _ data ▁; ▁EVP _ MD _ CTX _ set _ flags ▁( ▁out ▁, ▁EVP _ MD _ CTX _ FLAG _ REUSE ▁) ▁; ▁} ▁else ▁tmp _ buf ▁= ▁NULL ▁; ▁EVP _ MD _ CTX _ reset ▁( ▁out ▁) ▁; ▁memcpy ▁( ▁out ▁, ▁in ▁, ▁sizeof ▁( ▁* ▁out ▁) ▁) ▁; ▁EVP _ MD _ CTX _ clear _ flags ▁( ▁out ▁, ▁EVP _ MD _ CTX _ FLAG _ KEEP _ PKEY _ CTX ▁) ▁; ▁out ▁-> ▁md _ data ▁= ▁NULL ▁; ▁out ▁-> ▁pctx ▁= ▁NULL ▁; ▁if ▁( ▁in ▁-> ▁md _ data ▁&& ▁out ▁-> ▁digest ▁-> ▁ctx _ size ▁) ▁{ ▁if ▁( ▁tmp _ buf ▁) ▁out ▁-> ▁md _ data ▁= ▁tmp _ buf ▁; ▁else ▁{ ▁out ▁-> ▁md _ data ▁= ▁OPENSSL _ malloc ▁( ▁out ▁-> ▁digest ▁-> ▁ctx _ size ▁) ▁; ▁if ▁( ▁out ▁-> ▁md _ data ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ MD _ CTX _ COPY _ EX ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁memcpy ▁( ▁out ▁-> ▁md _ data ▁, ▁in ▁-> ▁md _ data ▁, ▁out ▁-> ▁digest ▁-> ▁ctx _ size ▁) ▁; ▁} ▁out ▁-> ▁update ▁= ▁in ▁-> ▁update ▁; ▁# ifndef ▁FIPS _ MODE ▁if ▁( ▁in ▁-> ▁pctx ▁) ▁{ ▁out ▁-> ▁pctx ▁= ▁EVP _ PKEY _ CTX _ dup ▁( ▁in ▁-> ▁pctx ▁) ▁; ▁if ▁( ▁! ▁out ▁-> ▁pctx ▁) ▁{ ▁EVP _ MD _ CTX _ reset ▁( ▁out ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁# endif ▁if ▁( ▁out ▁-> ▁digest ▁-> ▁copy ▁) ▁return ▁out ▁-> ▁digest ▁-> ▁copy ▁( ▁out ▁, ▁in ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁int ▁ff _ h uff _ gen _ len _ table ▁( ▁uint 8_ t ▁* ▁dst ▁, ▁const ▁uint 64_ t ▁* ▁stats ▁, ▁int ▁stats _ size ▁, ▁int ▁skip 0 ▁) ▁{ ▁Heap Elem ▁* ▁h ▁= ▁av _ malloc _ array ▁( ▁sizeof ▁( ▁* ▁h ▁) ▁, ▁stats _ size ▁) ▁; ▁int ▁* ▁up ▁= ▁av _ malloc _ array ▁( ▁sizeof ▁( ▁* ▁up ▁) ▁* ▁2 ▁, ▁stats _ size ▁) ▁; ▁uint 8_ t ▁* ▁len ▁= ▁av _ malloc _ array ▁( ▁sizeof ▁( ▁* ▁len ▁) ▁* ▁2 ▁, ▁stats _ size ▁) ▁; ▁uint 16_ t ▁* ▁map ▁= ▁av _ malloc _ array ▁( ▁sizeof ▁( ▁* ▁map ▁) ▁, ▁stats _ size ▁) ▁; ▁int ▁offset ▁, ▁i ▁, ▁next ▁; ▁int ▁size ▁= ▁0 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁! ▁h ▁|| ▁! ▁up ▁|| ▁! ▁len ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁end ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁stats _ size ▁; ▁i ▁++ ▁) ▁{ ▁dst ▁[ ▁i ▁] ▁= ▁255 ▁; ▁if ▁( ▁stats ▁[ ▁i ▁] ▁|| ▁! ▁skip 0 ▁) ▁map ▁[ ▁size ▁++ ▁] ▁= ▁i ▁; ▁} ▁for ▁( ▁offset ▁= ▁1 ▁; ▁; ▁offset ▁<<= ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁h ▁[ ▁i ▁] ▁. ▁name ▁= ▁i ▁; ▁h ▁[ ▁i ▁] ▁. ▁val ▁= ▁( ▁stats ▁[ ▁map ▁[ ▁i ▁] ▁] ▁<< ▁14 ▁) ▁+ ▁offset ▁; ▁} ▁for ▁( ▁i ▁= ▁size ▁/ ▁2 ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁heap _ s ift ▁( ▁h ▁, ▁i ▁, ▁size ▁) ▁; ▁for ▁( ▁next ▁= ▁size ▁; ▁next ▁< ▁size ▁* ▁2 ▁- ▁1 ▁; ▁next ▁++ ▁) ▁{ ▁uint 64_ t ▁min 1 v ▁= ▁h ▁[ ▁0 ▁] ▁. ▁val ▁; ▁up ▁[ ▁h ▁[ ▁0 ▁] ▁. ▁name ▁] ▁= ▁next ▁; ▁h ▁[ ▁0 ▁] ▁. ▁val ▁= ▁INT 64_ MAX ▁; ▁heap _ s ift ▁( ▁h ▁, ▁0 ▁, ▁size ▁) ▁; ▁up ▁[ ▁h ▁[ ▁0 ▁] ▁. ▁name ▁] ▁= ▁next ▁; ▁h ▁[ ▁0 ▁] ▁. ▁name ▁= ▁next ▁; ▁h ▁[ ▁0 ▁] ▁. ▁val ▁+= ▁min 1 v ▁; ▁heap _ s ift ▁( ▁h ▁, ▁0 ▁, ▁size ▁) ▁; ▁} ▁len ▁[ ▁2 ▁* ▁size ▁- ▁2 ▁] ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁2 ▁* ▁size ▁- ▁3 ▁; ▁i ▁>= ▁size ▁; ▁i ▁-- ▁) ▁len ▁[ ▁i ▁] ▁= ▁len ▁[ ▁up ▁[ ▁i ▁] ▁] ▁+ ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁dst ▁[ ▁map ▁[ ▁i ▁] ▁] ▁= ▁len ▁[ ▁up ▁[ ▁i ▁] ▁] ▁+ ▁1 ▁; ▁if ▁( ▁dst ▁[ ▁map ▁[ ▁i ▁] ▁] ▁>= ▁32 ▁) ▁break ▁; ▁} ▁if ▁( ▁i ▁== ▁size ▁) ▁break ▁; ▁} ▁end ▁: ▁av _ free ▁( ▁h ▁) ▁; ▁av _ free ▁( ▁up ▁) ▁; ▁av _ free ▁( ▁len ▁) ▁; ▁av _ free ▁( ▁map ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁void ▁print _ sdp ▁( ▁void ▁) ▁{ ▁char ▁sdp ▁[ ▁16384 ▁] ▁; ▁int ▁i ▁; ▁AVFormatContext ▁* ▁* ▁av c ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁* ▁av c ▁) ▁* ▁nb _ output _ files ▁) ▁; ▁if ▁( ▁! ▁av c ▁) ▁exit _ program ▁( ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ output _ files ▁; ▁i ▁++ ▁) ▁av c ▁[ ▁i ▁] ▁= ▁output _ files ▁[ ▁i ▁] ▁-> ▁ctx ▁; ▁av _ sdp _ create ▁( ▁av c ▁, ▁nb _ output _ files ▁, ▁sdp ▁, ▁sizeof ▁( ▁sdp ▁) ▁) ▁; ▁printf ▁( ▁" SDP :\ n % s \ n " ▁, ▁sdp ▁) ▁; ▁fflush ▁( ▁stdout ▁) ▁; ▁av _ freep ▁( ▁& ▁av c ▁) ▁; ▁}	1
▁long ▁TXT _ DB _ write ▁( ▁BIO ▁* ▁out ▁, ▁TXT _ DB ▁* ▁db ▁) ▁{ ▁long ▁i ▁, ▁j ▁, ▁n ▁, ▁nn ▁, ▁l ▁, ▁tot ▁= ▁0 ▁; ▁char ▁* ▁p ▁, ▁* ▁* ▁pp ▁, ▁* ▁f ▁; ▁BUF _ MEM ▁* ▁buf ▁= ▁NULL ▁; ▁long ▁ret ▁= ▁-1 ▁; ▁if ▁( ▁( ▁buf ▁= ▁BUF _ MEM _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁n ▁= ▁sk _ OPENSSL _ P STRING _ num ▁( ▁db ▁-> ▁data ▁) ▁; ▁nn ▁= ▁db ▁-> ▁num _ fields ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁pp ▁= ▁sk _ OPENSSL _ P STRING _ value ▁( ▁db ▁-> ▁data ▁, ▁i ▁) ▁; ▁l ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁nn ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁pp ▁[ ▁j ▁] ▁!= ▁NULL ▁) ▁l ▁+= ▁strlen ▁( ▁pp ▁[ ▁j ▁] ▁) ▁; ▁} ▁if ▁( ▁! ▁BUF _ MEM _ grow _ clean ▁( ▁buf ▁, ▁( ▁int ▁) ▁( ▁l ▁* ▁2 ▁+ ▁nn ▁) ▁) ▁) ▁goto ▁err ▁; ▁p ▁= ▁buf ▁-> ▁data ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁nn ▁; ▁j ▁++ ▁) ▁{ ▁f ▁= ▁pp ▁[ ▁j ▁] ▁; ▁if ▁( ▁f ▁!= ▁NULL ▁) ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁* ▁f ▁== ▁' ▁\0 ▁' ▁) ▁break ▁; ▁if ▁( ▁* ▁f ▁== ▁' ▁\ t ▁' ▁) ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁\\ ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁* ▁( ▁f ▁++ ▁) ▁; ▁} ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁\ t ▁' ▁; ▁} ▁p ▁[ ▁-1 ▁] ▁= ▁' ▁\ n ▁' ▁; ▁j ▁= ▁p ▁- ▁buf ▁-> ▁data ▁; ▁if ▁( ▁BIO _ write ▁( ▁out ▁, ▁buf ▁-> ▁data ▁, ▁( ▁int ▁) ▁j ▁) ▁!= ▁j ▁) ▁goto ▁err ▁; ▁tot ▁+= ▁j ▁; ▁} ▁ret ▁= ▁tot ▁; ▁err ▁: ▁BUF _ MEM _ free ▁( ▁buf ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁void ▁ff _ id 3 v 2_ parse ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁len ▁, ▁uint 8_ t ▁version ▁, ▁uint 8_ t ▁flags ▁, ▁ID 3 v 2 Extra Meta ▁* ▁* ▁extra _ meta ▁) ▁{ ▁int ▁is v 34 ▁, ▁tlen ▁, ▁un sync ▁; ▁char ▁tag ▁[ ▁5 ▁] ▁; ▁int 64_ t ▁next ▁, ▁end ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁+ ▁len ▁; ▁int ▁tag hdrlen ▁; ▁const ▁char ▁* ▁reason ▁= ▁NULL ▁; ▁AVIO Context ▁pb ▁; ▁AVIO Context ▁* ▁pb x ▁; ▁unsigned ▁char ▁* ▁buffer ▁= ▁NULL ▁; ▁int ▁buffer _ size ▁= ▁0 ▁; ▁void ▁( ▁* ▁extra _ func ▁) ▁( ▁AVFormatContext ▁* ▁, ▁AVIO Context ▁* ▁, ▁int ▁, ▁char ▁* ▁, ▁ID 3 v 2 Extra Meta ▁* ▁* ▁) ▁= ▁NULL ▁; ▁switch ▁( ▁version ▁) ▁{ ▁case ▁2 ▁: ▁if ▁( ▁flags ▁& ▁0 x 40 ▁) ▁{ ▁reason ▁= ▁" compression " ▁; ▁goto ▁error ▁; ▁} ▁is v 34 ▁= ▁0 ▁; ▁tag hdrlen ▁= ▁6 ▁; ▁break ▁; ▁case ▁3 ▁: ▁case ▁4 ▁: ▁is v 34 ▁= ▁1 ▁; ▁tag hdrlen ▁= ▁10 ▁; ▁break ▁; ▁default ▁: ▁reason ▁= ▁" version " ▁; ▁goto ▁error ▁; ▁} ▁un sync ▁= ▁flags ▁& ▁0 x 80 ▁; ▁if ▁( ▁is v 34 ▁&& ▁flags ▁& ▁0 x 40 ▁) ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁get _ size ▁( ▁s ▁-> ▁pb ▁, ▁4 ▁) ▁) ▁; ▁while ▁( ▁len ▁>= ▁tag hdrlen ▁) ▁{ ▁unsigned ▁int ▁t flags ▁= ▁0 ▁; ▁int ▁tun sync ▁= ▁0 ▁; ▁if ▁( ▁is v 34 ▁) ▁{ ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁tag ▁, ▁4 ▁) ▁; ▁tag ▁[ ▁4 ▁] ▁= ▁0 ▁; ▁if ▁( ▁version ▁== ▁3 ▁) ▁{ ▁tlen ▁= ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁} ▁else ▁tlen ▁= ▁get _ size ▁( ▁s ▁-> ▁pb ▁, ▁4 ▁) ▁; ▁t flags ▁= ▁avio _ rb 16 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁tun sync ▁= ▁t flags ▁& ▁ID 3 v 2_ FLAG _ UN SYN CH ▁; ▁} ▁else ▁{ ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁tag ▁, ▁3 ▁) ▁; ▁tag ▁[ ▁3 ▁] ▁= ▁0 ▁; ▁tlen ▁= ▁avio _ rb 24 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁} ▁if ▁( ▁tlen ▁< ▁0 ▁|| ▁tlen ▁> ▁len ▁- ▁tag hdrlen ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Invalid size in frame % s , sk ipping ther est oft ag .\ n " ▁, ▁tag ▁) ▁; ▁break ▁; ▁} ▁len ▁-= ▁tag hdrlen ▁+ ▁tlen ▁; ▁next ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁+ ▁tlen ▁; ▁if ▁( ▁! ▁tlen ▁) ▁{ ▁if ▁( ▁tag ▁[ ▁0 ▁] ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" In val ide mpty frame % s , sk ipping .\ n " ▁, ▁tag ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁t flags ▁& ▁ID 3 v 2_ FLAG _ D ATAL EN ▁) ▁{ ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁tlen ▁-= ▁4 ▁; ▁} ▁if ▁( ▁t flags ▁& ▁( ▁ID 3 v 2_ FLAG _ ENCRYPTION ▁| ▁ID 3 v 2_ FLAG _ COMPRESSION ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Skipping encrypted / compressed ID 3 v 2 frame % s .\ n " ▁, ▁tag ▁) ▁; ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁tlen ▁) ▁; ▁} ▁else ▁if ▁( ▁tag ▁[ ▁0 ▁] ▁== ▁' ▁' ▁|| ▁( ▁extra _ meta ▁&& ▁( ▁extra _ func ▁= ▁get _ extra _ meta _ func ▁( ▁tag ▁, ▁is v 34 ▁) ▁-> ▁read ▁) ▁) ▁) ▁{ ▁if ▁( ▁un sync ▁|| ▁tun sync ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁av _ fast _ malloc ▁( ▁& ▁buffer ▁, ▁& ▁buffer _ size ▁, ▁tlen ▁) ▁; ▁if ▁( ▁! ▁buffer ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Failed to alloc % db ytes \ n " ▁, ▁tlen ▁) ▁; ▁goto ▁seek ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁i ▁< ▁tlen ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁{ ▁buffer ▁[ ▁j ▁] ▁= ▁avio _ r 8 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁if ▁( ▁j ▁> ▁0 ▁&& ▁! ▁buffer ▁[ ▁j ▁] ▁&& ▁buffer ▁[ ▁j ▁- ▁1 ▁] ▁== ▁0 xff ▁) ▁{ ▁j ▁-- ▁; ▁} ▁} ▁ff io _ init _ context ▁( ▁& ▁pb ▁, ▁buffer ▁, ▁j ▁, ▁0 ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁tlen ▁= ▁j ▁; ▁pb x ▁= ▁& ▁pb ▁; ▁} ▁else ▁{ ▁pb x ▁= ▁s ▁-> ▁pb ▁; ▁} ▁if ▁( ▁tag ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁read _ tt ag ▁( ▁s ▁, ▁pb x ▁, ▁tlen ▁, ▁tag ▁) ▁; ▁else ▁extra _ func ▁( ▁s ▁, ▁pb x ▁, ▁tlen ▁, ▁tag ▁, ▁extra _ meta ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁tag ▁[ ▁0 ▁] ▁) ▁{ ▁if ▁( ▁tag ▁[ ▁1 ▁] ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" invalid frame id , ass uming padding " ▁) ▁; ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁tlen ▁) ▁; ▁break ▁; ▁} ▁seek ▁: ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁next ▁, ▁SEEK _ SET ▁) ▁; ▁} ▁if ▁( ▁version ▁== ▁4 ▁&& ▁flags ▁& ▁0 x 10 ▁) ▁end ▁+= ▁10 ▁; ▁error ▁: ▁if ▁( ▁reason ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ INFO ▁, ▁" ID 3 v 2. % dt ag skipped , cannot handle % s \ n " ▁, ▁version ▁, ▁reason ▁) ▁; ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁end ▁, ▁SEEK _ SET ▁) ▁; ▁av _ free ▁( ▁buffer ▁) ▁; ▁return ▁; ▁}	0
▁static ▁int ▁do _ decode ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁int ▁got _ frame ▁= ▁0 ▁; ▁int ▁ret ▁; ▁av _ assert 0 ▁( ▁! ▁avctx ▁-> ▁internal ▁-> ▁buffer _ frame ▁-> ▁buf ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁! ▁pkt ▁) ▁pkt ▁= ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁; ▁avctx ▁-> ▁refcount ed _ frames ▁= ▁1 ▁; ▁if ▁( ▁avctx ▁-> ▁internal ▁-> ▁dr aining _ done ▁) ▁return ▁AVERROR _ EOF ▁; ▁if ▁( ▁avctx ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁ret ▁= ▁avcodec _ decode _ video 2 ▁( ▁avctx ▁, ▁avctx ▁-> ▁internal ▁-> ▁buffer _ frame ▁, ▁& ▁got _ frame ▁, ▁pkt ▁) ▁; ▁if ▁( ▁ret ▁>= ▁0 ▁&& ▁! ▁( ▁avctx ▁-> ▁flags ▁& ▁AV _ CODEC _ FLAG _ TRUNC ATED ▁) ▁) ▁ret ▁= ▁pkt ▁-> ▁size ▁; ▁} ▁else ▁if ▁( ▁avctx ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁{ ▁ret ▁= ▁avcodec _ decode _ audio 4 ▁( ▁avctx ▁, ▁avctx ▁-> ▁internal ▁-> ▁buffer _ frame ▁, ▁& ▁got _ frame ▁, ▁pkt ▁) ▁; ▁} ▁else ▁{ ▁ret ▁= ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁ret ▁== ▁AVERROR ▁( ▁EAGAIN ▁) ▁) ▁ret ▁= ▁pkt ▁-> ▁size ▁; ▁if ▁( ▁avctx ▁-> ▁internal ▁-> ▁dr aining ▁&& ▁! ▁got _ frame ▁) ▁avctx ▁-> ▁internal ▁-> ▁dr aining _ done ▁= ▁1 ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁ret ▁>= ▁pkt ▁-> ▁size ▁) ▁{ ▁av _ packet _ unref ▁( ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁) ▁; ▁} ▁else ▁{ ▁int ▁consumed ▁= ▁ret ▁; ▁if ▁( ▁pkt ▁!= ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁) ▁{ ▁av _ packet _ unref ▁( ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ packet _ ref ▁( ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁, ▁pkt ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁-> ▁data ▁+= ▁consumed ▁; ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁-> ▁size ▁-= ▁consumed ▁; ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁-> ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁avctx ▁-> ▁internal ▁-> ▁buffer _ pkt ▁-> ▁dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁if ▁( ▁got _ frame ▁) ▁av _ assert 0 ▁( ▁avctx ▁-> ▁internal ▁-> ▁buffer _ frame ▁-> ▁buf ▁[ ▁0 ▁] ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁cin audio _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁C in Audio Context ▁* ▁cin ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁uint 8_ t ▁* ▁src ▁= ▁buf ▁; ▁int 16_ t ▁* ▁samples ▁= ▁data ▁; ▁int ▁delta ▁; ▁buf _ size ▁= ▁FF MIN ▁( ▁buf _ size ▁, ▁* ▁data _ size ▁/ ▁2 ▁) ▁; ▁delta ▁= ▁cin ▁-> ▁delta ▁; ▁if ▁( ▁cin ▁-> ▁initial _ decode _ frame ▁) ▁{ ▁cin ▁-> ▁initial _ decode _ frame ▁= ▁0 ▁; ▁delta ▁= ▁( ▁int 16_ t ▁) ▁AV _ RL 16 ▁( ▁src ▁) ▁; ▁src ▁+= ▁2 ▁; ▁* ▁samples ▁++ ▁= ▁delta ▁; ▁buf _ size ▁-= ▁2 ▁; ▁} ▁while ▁( ▁buf _ size ▁> ▁0 ▁) ▁{ ▁delta ▁+= ▁cin audio _ delta 16_ table ▁[ ▁* ▁src ▁++ ▁] ▁; ▁delta ▁= ▁av _ clip _ int 16 ▁( ▁delta ▁) ▁; ▁* ▁samples ▁++ ▁= ▁delta ▁; ▁-- ▁buf _ size ▁; ▁} ▁cin ▁-> ▁delta ▁= ▁delta ▁; ▁* ▁data _ size ▁= ▁( ▁uint 8_ t ▁* ▁) ▁samples ▁- ▁( ▁uint 8_ t ▁* ▁) ▁data ▁; ▁return ▁src ▁- ▁buf ▁; ▁}	1
▁static ▁void ▁vp 8_ decode _ mb _ row _ no _ filter ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁t data ▁, ▁int ▁job nr ▁, ▁int ▁thread nr ▁) ▁{ ▁VP 8 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁VP 8 Thread Data ▁* ▁prev _ td ▁, ▁* ▁next _ td ▁, ▁* ▁td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁thread nr ▁] ▁; ▁int ▁mb _ y ▁= ▁td ▁-> ▁thread _ mb _ pos ▁>> ▁16 ▁; ▁int ▁mb _ x ▁, ▁mb _ xy ▁= ▁mb _ y ▁* ▁s ▁-> ▁mb _ width ▁; ▁int ▁num _ jobs ▁= ▁s ▁-> ▁num _ jobs ▁; ▁VP 8 Frame ▁* ▁cur frame ▁= ▁s ▁-> ▁cur frame ▁, ▁* ▁prev _ frame ▁= ▁s ▁-> ▁prev _ frame ▁; ▁VP 56 Range Coder ▁* ▁c ▁= ▁& ▁s ▁-> ▁coeff _ partition ▁[ ▁mb _ y ▁& ▁( ▁s ▁-> ▁num _ coeff _ partitions ▁- ▁1 ▁) ▁] ▁; ▁VP 8 Macro block ▁* ▁mb ▁; ▁uint 8_ t ▁* ▁dst ▁[ ▁3 ▁] ▁= ▁{ ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁16 ▁* ▁mb _ y ▁* ▁s ▁-> ▁linesize ▁, ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁, ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁data ▁[ ▁2 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁} ▁; ▁if ▁( ▁mb _ y ▁== ▁0 ▁) ▁prev _ td ▁= ▁td ▁; ▁else ▁prev _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁num _ jobs ▁- ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁if ▁( ▁mb _ y ▁== ▁s ▁-> ▁mb _ height ▁- ▁1 ▁) ▁next _ td ▁= ▁td ▁; ▁else ▁next _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁if ▁( ▁s ▁-> ▁mb _ layout ▁== ▁1 ▁) ▁mb ▁= ▁s ▁-> ▁macro blocks _ base ▁+ ▁( ▁( ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁* ▁( ▁mb _ y ▁+ ▁1 ▁) ▁+ ▁1 ▁) ▁; ▁else ▁{ ▁if ▁( ▁prev _ frame ▁&& ▁s ▁-> ▁segment ation ▁. ▁enabled ▁&& ▁! ▁s ▁-> ▁segment ation ▁. ▁update _ map ▁) ▁ff _ thread _ await _ progress ▁( ▁& ▁prev _ frame ▁-> ▁tf ▁, ▁mb _ y ▁, ▁0 ▁) ▁; ▁mb ▁= ▁s ▁-> ▁macro blocks ▁+ ▁( ▁s ▁-> ▁mb _ height ▁- ▁mb _ y ▁- ▁1 ▁) ▁* ▁2 ▁; ▁memset ▁( ▁mb ▁- ▁1 ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁mb ▁) ▁) ▁; ▁AV _ WN 32 A ▁( ▁s ▁-> ▁in tra 4 x 4_ pred _ mode _ left ▁, ▁DC _ PRED ▁* ▁0 x 01010101 ▁) ▁; ▁} ▁memset ▁( ▁td ▁-> ▁left _ nn z ▁, ▁0 ▁, ▁sizeof ▁( ▁td ▁-> ▁left _ nn z ▁) ▁) ▁; ▁s ▁-> ▁mv _ min ▁. ▁x ▁= ▁- ▁M ARGIN ▁; ▁s ▁-> ▁mv _ max ▁. ▁x ▁= ▁( ▁( ▁s ▁-> ▁mb _ width ▁- ▁1 ▁) ▁<< ▁6 ▁) ▁+ ▁M ARGIN ▁; ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁mb _ x ▁++ ▁, ▁mb _ xy ▁++ ▁, ▁mb ▁++ ▁) ▁{ ▁if ▁( ▁prev _ td ▁!= ▁td ▁) ▁{ ▁if ▁( ▁thread nr ▁!= ▁0 ▁) ▁{ ▁check _ thread _ pos ▁( ▁td ▁, ▁prev _ td ▁, ▁mb _ x ▁+ ▁1 ▁, ▁mb _ y ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁check _ thread _ pos ▁( ▁td ▁, ▁prev _ td ▁, ▁( ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁) ▁+ ▁( ▁mb _ x ▁+ ▁1 ▁) ▁, ▁mb _ y ▁- ▁1 ▁) ▁; ▁} ▁} ▁s ▁-> ▁v dsp ▁. ▁prefetch ▁( ▁dst ▁[ ▁0 ▁] ▁+ ▁( ▁mb _ x ▁& ▁3 ▁) ▁* ▁4 ▁* ▁s ▁-> ▁linesize ▁+ ▁64 ▁, ▁s ▁-> ▁linesize ▁, ▁4 ▁) ▁; ▁s ▁-> ▁v dsp ▁. ▁prefetch ▁( ▁dst ▁[ ▁1 ▁] ▁+ ▁( ▁mb _ x ▁& ▁7 ▁) ▁* ▁s ▁-> ▁uv lines ize ▁+ ▁64 ▁, ▁dst ▁[ ▁2 ▁] ▁- ▁dst ▁[ ▁1 ▁] ▁, ▁2 ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁mb _ layout ▁) ▁decode _ mb _ mode ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁cur frame ▁-> ▁seg _ map ▁-> ▁data ▁+ ▁mb _ xy ▁, ▁prev _ frame ▁&& ▁prev _ frame ▁-> ▁seg _ map ▁? ▁prev _ frame ▁-> ▁seg _ map ▁-> ▁data ▁+ ▁mb _ xy ▁: ▁NULL ▁, ▁0 ▁) ▁; ▁prefetch _ motion ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁mb _ xy ▁, ▁VP 5 6_ FRAME _ PREVIOUS ▁) ▁; ▁if ▁( ▁! ▁mb ▁-> ▁skip ▁) ▁decode _ mb _ coeffs ▁( ▁s ▁, ▁td ▁, ▁c ▁, ▁mb ▁, ▁s ▁-> ▁top _ nn z ▁[ ▁mb _ x ▁] ▁, ▁td ▁-> ▁left _ nn z ▁) ▁; ▁if ▁( ▁mb ▁-> ▁mode ▁<= ▁MODE _ I 4 x 4 ▁) ▁in tra _ predict ▁( ▁s ▁, ▁td ▁, ▁dst ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁else ▁inter _ predict ▁( ▁s ▁, ▁td ▁, ▁dst ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁prefetch _ motion ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁mb _ xy ▁, ▁VP 5 6_ FRAME _ G OL DEN ▁) ▁; ▁if ▁( ▁! ▁mb ▁-> ▁skip ▁) ▁{ ▁idct _ mb ▁( ▁s ▁, ▁td ▁, ▁dst ▁, ▁mb ▁) ▁; ▁} ▁else ▁{ ▁AV _ ZERO 64 ▁( ▁td ▁-> ▁left _ nn z ▁) ▁; ▁AV _ WN 64 ▁( ▁s ▁-> ▁top _ nn z ▁[ ▁mb _ x ▁] ▁, ▁0 ▁) ▁; ▁if ▁( ▁mb ▁-> ▁mode ▁!= ▁MODE _ I 4 x 4 ▁&& ▁mb ▁-> ▁mode ▁!= ▁VP 8_ MV MODE _ SPLIT ▁) ▁{ ▁td ▁-> ▁left _ nn z ▁[ ▁8 ▁] ▁= ▁0 ▁; ▁s ▁-> ▁top _ nn z ▁[ ▁mb _ x ▁] ▁[ ▁8 ▁] ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁de block _ filter ▁) ▁filter _ level _ for _ mb ▁( ▁s ▁, ▁mb ▁, ▁& ▁td ▁-> ▁filter _ strength ▁[ ▁mb _ x ▁] ▁) ▁; ▁if ▁( ▁s ▁-> ▁de block _ filter ▁&& ▁num _ jobs ▁!= ▁1 ▁&& ▁thread nr ▁== ▁num _ jobs ▁- ▁1 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁filter ▁. ▁simple ▁) ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁NULL ▁, ▁NULL ▁, ▁s ▁-> ▁linesize ▁, ▁0 ▁, ▁1 ▁) ▁; ▁else ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁dst ▁[ ▁1 ▁] ▁, ▁dst ▁[ ▁2 ▁] ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁uv lines ize ▁, ▁0 ▁) ▁; ▁} ▁prefetch _ motion ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁mb _ xy ▁, ▁VP 5 6_ FRAME _ G OL DEN 2 ▁) ▁; ▁dst ▁[ ▁0 ▁] ▁+= ▁16 ▁; ▁dst ▁[ ▁1 ▁] ▁+= ▁8 ▁; ▁dst ▁[ ▁2 ▁] ▁+= ▁8 ▁; ▁s ▁-> ▁mv _ min ▁. ▁x ▁-= ▁64 ▁; ▁s ▁-> ▁mv _ max ▁. ▁x ▁-= ▁64 ▁; ▁if ▁( ▁mb _ x ▁== ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁{ ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁) ▁; ▁} ▁else ▁{ ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁mb _ x ▁) ▁; ▁} ▁} ▁}	1
▁static ▁int ▁r 3 d _ read _ red v ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁, ▁Atom ▁* ▁atom ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁; ▁int ▁tmp ▁; ▁int ▁av _ unused ▁tmp 2 ▁; ▁int 64_ t ▁pos ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁; ▁unsigned ▁dts ▁; ▁int ▁ret ▁; ▁dts ▁= ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁tmp ▁= ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" f ram enum % d \ n " ▁, ▁tmp ▁) ▁; ▁tmp ▁= ▁avio _ r 8 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁tmp 2 ▁= ▁avio _ r 8 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" version % d .% d \ n " ▁, ▁tmp ▁, ▁tmp 2 ▁) ▁; ▁tmp ▁= ▁avio _ rb 16 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" unknown % d \ n " ▁, ▁tmp ▁) ▁; ▁if ▁( ▁tmp ▁> ▁4 ▁) ▁{ ▁tmp ▁= ▁avio _ rb 16 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" unknown % d \ n " ▁, ▁tmp ▁) ▁; ▁tmp ▁= ▁avio _ rb 16 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" unknown % d \ n " ▁, ▁tmp ▁) ▁; ▁tmp ▁= ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" width % d \ n " ▁, ▁tmp ▁) ▁; ▁tmp ▁= ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" height % d \ n " ▁, ▁tmp ▁) ▁; ▁tmp ▁= ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁" met ad atal en % d \ n " ▁, ▁tmp ▁) ▁; ▁} ▁tmp ▁= ▁atom ▁-> ▁size ▁- ▁8 ▁- ▁( ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁- ▁pos ▁) ▁; ▁if ▁( ▁tmp ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁ret ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁tmp ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" error reading vide op acket \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁pkt ▁-> ▁dts ▁= ▁dts ▁; ▁if ▁( ▁st ▁-> ▁avg _ frame _ rate ▁. ▁num ▁) ▁pkt ▁-> ▁duration ▁= ▁( ▁uint 64_ t ▁) ▁st ▁-> ▁time _ base ▁. ▁den ▁* ▁st ▁-> ▁avg _ frame _ rate ▁. ▁den ▁/ ▁st ▁-> ▁avg _ frame _ rate ▁. ▁num ▁; ▁av _ d log ▁( ▁s ▁, ▁" pkt dts %" ▁PRId 64 ▁" duration % d \ n " ▁, ▁pkt ▁-> ▁dts ▁, ▁pkt ▁-> ▁duration ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁decrypt _ rfc 44 90_ shared _ key _2 001 ▁( ▁EVP _ PKEY ▁* ▁priv ▁, ▁GOST _ KEY _ TRANSPORT ▁* ▁g kt ▁, ▁unsigned ▁char ▁* ▁key _ buf ▁, ▁int ▁key _ buf _ len ▁) ▁{ ▁unsigned ▁char ▁wrapped Key ▁[ ▁44 ▁] ▁; ▁unsigned ▁char ▁shared Key ▁[ ▁32 ▁] ▁; ▁g ost _ ctx ▁ctx ▁; ▁const ▁struct ▁g ost _ cipher _ info ▁* ▁param ▁= ▁NULL ▁; ▁EVP _ PKEY ▁* ▁e ph _ key ▁= ▁NULL ▁; ▁e ph _ key ▁= ▁X 509_ PUB KEY _ get ▁( ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁ep hem _ key ▁) ▁; ▁param ▁= ▁get _ encryption _ params ▁( ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁cipher ▁) ▁; ▁g ost _ init ▁( ▁& ▁ctx ▁, ▁param ▁-> ▁sb lock ▁) ▁; ▁OPENSSL _ assert ▁( ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁e ph _ iv ▁-> ▁length ▁== ▁8 ▁) ▁; ▁memcpy ▁( ▁wrapped Key ▁, ▁g kt ▁-> ▁key _ ag ree ment _ info ▁-> ▁e ph _ iv ▁-> ▁data ▁, ▁8 ▁) ▁; ▁OPENSSL _ assert ▁( ▁g kt ▁-> ▁key _ info ▁-> ▁encrypted _ key ▁-> ▁length ▁== ▁32 ▁) ▁; ▁memcpy ▁( ▁wrapped Key ▁+ ▁8 ▁, ▁g kt ▁-> ▁key _ info ▁-> ▁encrypted _ key ▁-> ▁data ▁, ▁32 ▁) ▁; ▁OPENSSL _ assert ▁( ▁g kt ▁-> ▁key _ info ▁-> ▁i mit ▁-> ▁length ▁== ▁4 ▁) ▁; ▁memcpy ▁( ▁wrapped Key ▁+ ▁40 ▁, ▁g kt ▁-> ▁key _ info ▁-> ▁i mit ▁-> ▁data ▁, ▁4 ▁) ▁; ▁VK O _ compute _ key ▁( ▁shared Key ▁, ▁32 ▁, ▁EC _ KEY _ get 0_ public _ key ▁( ▁EVP _ PKEY _ get 0 ▁( ▁e ph _ key ▁) ▁) ▁, ▁EVP _ PKEY _ get 0 ▁( ▁priv ▁) ▁, ▁wrapped Key ▁) ▁; ▁if ▁( ▁! ▁key Un wrap Crypto Pro ▁( ▁& ▁ctx ▁, ▁shared Key ▁, ▁wrapped Key ▁, ▁key _ buf ▁) ▁) ▁{ ▁GOST err ▁( ▁GOST _ F _ PKCS 7_ GO ST 94 CP _ KEY _ TRANSPORT _ DECRYPT ▁, ▁GOST _ R _ ERROR _ COMP UT ING _ SHARED _ KEY ▁) ▁; ▁goto ▁err ▁; ▁} ▁EVP _ PKEY _ free ▁( ▁e ph _ key ▁) ▁; ▁return ▁32 ▁; ▁err ▁: ▁EVP _ PKEY _ free ▁( ▁e ph _ key ▁) ▁; ▁return ▁-1 ▁; ▁}	1
▁static ▁av _ cold ▁int ▁he vc _ decode _ free ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁H EV C Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁H EV CL ocal Context ▁* ▁lc ▁= ▁s ▁-> ▁H EV C lc ▁; ▁int ▁i ▁; ▁pic _ arrays _ free ▁( ▁s ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁md 5_ ctx ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n als _ allocated ▁; ▁i ▁++ ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ pos _ n al ▁[ ▁i ▁] ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ pos _ size _ n al ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ n al ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ pos _ n al ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁c abac _ state ▁) ▁; ▁av _ frame _ free ▁( ▁& ▁s ▁-> ▁tmp _ frame ▁) ▁; ▁av _ frame _ free ▁( ▁& ▁s ▁-> ▁output _ frame ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁D PB ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ff _ he vc _ unref _ frame ▁( ▁s ▁, ▁& ▁s ▁-> ▁D PB ▁[ ▁i ▁] ▁, ▁ ~ ▁0 ▁) ▁; ▁av _ frame _ free ▁( ▁& ▁s ▁-> ▁D PB ▁[ ▁i ▁] ▁. ▁frame ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁v ps _ list ▁) ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁v ps _ list ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁sps _ list ▁) ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁sps _ list ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁pps _ list ▁) ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁pps _ list ▁[ ▁i ▁] ▁) ▁; ▁s ▁-> ▁sps ▁= ▁NULL ▁; ▁s ▁-> ▁pps ▁= ▁NULL ▁; ▁s ▁-> ▁v ps ▁= ▁NULL ▁; ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁current _ s ps ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁sh ▁. ▁offset ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁sh ▁. ▁size ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁if ▁( ▁lc ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁H EV C lc ▁== ▁s ▁-> ▁H EV C lc List ▁[ ▁0 ▁] ▁) ▁s ▁-> ▁H EV C lc ▁= ▁NULL ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁H EV C lc List ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n als _ allocated ▁; ▁i ▁++ ▁) ▁av _ freep ▁( ▁& ▁s ▁-> ▁n als ▁[ ▁i ▁] ▁. ▁rb sp _ buffer ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁n als ▁) ▁; ▁s ▁-> ▁n als _ allocated ▁= ▁0 ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁R ENAME ▁( ▁res ample _ linear ▁) ▁( ▁Res ample Context ▁* ▁c ▁, ▁void ▁* ▁dest ▁, ▁const ▁void ▁* ▁source ▁, ▁int ▁n ▁, ▁int ▁update _ ctx ▁) ▁{ ▁DE LEM ▁* ▁dst ▁= ▁dest ▁; ▁const ▁DE LEM ▁* ▁src ▁= ▁source ▁; ▁int ▁dst _ index ▁; ▁int ▁index ▁= ▁c ▁-> ▁index ▁; ▁int ▁frac ▁= ▁c ▁-> ▁frac ▁; ▁int ▁sample _ index ▁= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁# if ▁FILTER _ SHIFT ▁== ▁0 ▁double ▁inv _ src _ incr ▁= ▁1.0 ▁/ ▁c ▁-> ▁src _ incr ▁; ▁# endif ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁n ▁; ▁dst _ index ▁++ ▁) ▁{ ▁F ELEM ▁* ▁filter ▁= ▁( ▁( ▁F ELEM ▁* ▁) ▁c ▁-> ▁filter _ bank ▁) ▁+ ▁c ▁-> ▁filter _ alloc ▁* ▁index ▁; ▁F ELEM 2 ▁val ▁= ▁0 ▁, ▁v 2 ▁= ▁0 ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁v 2 ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁+ ▁c ▁-> ▁filter _ alloc ▁] ▁; ▁} ▁# ifdef ▁F ELE ML ▁val ▁+= ▁( ▁v 2 ▁- ▁val ▁) ▁* ▁( ▁F ELE ML ▁) ▁frac ▁/ ▁c ▁-> ▁src _ incr ▁; ▁# else ▁# if ▁FILTER _ SHIFT ▁== ▁0 ▁val ▁+= ▁( ▁v 2 ▁- ▁val ▁) ▁* ▁inv _ src _ incr ▁* ▁frac ▁; ▁# else ▁val ▁+= ▁( ▁v 2 ▁- ▁val ▁) ▁/ ▁c ▁-> ▁src _ incr ▁* ▁frac ▁; ▁# endif ▁# endif ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁frac ▁+= ▁c ▁-> ▁dst _ incr _ mod ▁; ▁index ▁+= ▁c ▁-> ▁dst _ incr _ div ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁sample _ index ▁+= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁} ▁if ▁( ▁update _ ctx ▁) ▁{ ▁c ▁-> ▁frac ▁= ▁frac ▁; ▁c ▁-> ▁index ▁= ▁index ▁; ▁} ▁return ▁sample _ index ▁; ▁}	0
▁static ▁int ▁x an _ decode _ frame _ type 0 ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁X an Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁uint 8_ t ▁* ▁y buf ▁, ▁* ▁prev _ buf ▁, ▁* ▁src ▁= ▁s ▁-> ▁scratch _ buffer ▁; ▁unsigned ▁chroma _ off ▁, ▁corr _ off ▁; ▁int ▁cur ▁, ▁last ▁, ▁size ▁; ▁int ▁i ▁, ▁j ▁; ▁int ▁ret ▁; ▁corr _ off ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁8 ▁) ▁; ▁chroma _ off ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁4 ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁x an _ decode _ chroma ▁( ▁avctx ▁, ▁avpkt ▁) ▁) ▁!= ▁0 ▁) ▁return ▁ret ▁; ▁size ▁= ▁avpkt ▁-> ▁size ▁- ▁4 ▁; ▁if ▁( ▁corr _ off ▁>= ▁avpkt ▁-> ▁size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Ignoring invalid cor rection block position \ n " ▁) ▁; ▁corr _ off ▁= ▁0 ▁; ▁} ▁if ▁( ▁corr _ off ▁) ▁size ▁= ▁corr _ off ▁; ▁if ▁( ▁chroma _ off ▁) ▁size ▁= ▁FF MIN ▁( ▁size ▁, ▁chroma _ off ▁) ▁; ▁ret ▁= ▁x an _ unpack _ l uma ▁( ▁buf ▁+ ▁12 ▁, ▁size ▁, ▁src ▁, ▁s ▁-> ▁buffer _ size ▁>> ▁1 ▁) ▁; ▁if ▁( ▁ret ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" L um ade coding failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁y buf ▁= ▁s ▁-> ▁y _ buffer ▁; ▁last ▁= ▁* ▁src ▁++ ▁; ▁y buf ▁[ ▁0 ▁] ▁= ▁last ▁<< ▁1 ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁avctx ▁-> ▁width ▁- ▁1 ▁; ▁j ▁+= ▁2 ▁) ▁{ ▁cur ▁= ▁( ▁last ▁+ ▁* ▁src ▁++ ▁) ▁& ▁0 x 1 F ▁; ▁y buf ▁[ ▁j ▁] ▁= ▁last ▁+ ▁cur ▁; ▁y buf ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁cur ▁<< ▁1 ▁; ▁last ▁= ▁cur ▁; ▁} ▁y buf ▁[ ▁j ▁] ▁= ▁last ▁<< ▁1 ▁; ▁prev _ buf ▁= ▁y buf ▁; ▁y buf ▁+= ▁avctx ▁-> ▁width ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁avctx ▁-> ▁height ▁; ▁i ▁++ ▁) ▁{ ▁last ▁= ▁( ▁( ▁prev _ buf ▁[ ▁0 ▁] ▁>> ▁1 ▁) ▁+ ▁* ▁src ▁++ ▁) ▁& ▁0 x 1 F ▁; ▁y buf ▁[ ▁0 ▁] ▁= ▁last ▁<< ▁1 ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁avctx ▁-> ▁width ▁- ▁1 ▁; ▁j ▁+= ▁2 ▁) ▁{ ▁cur ▁= ▁( ▁( ▁prev _ buf ▁[ ▁j ▁+ ▁1 ▁] ▁>> ▁1 ▁) ▁+ ▁* ▁src ▁++ ▁) ▁& ▁0 x 1 F ▁; ▁y buf ▁[ ▁j ▁] ▁= ▁last ▁+ ▁cur ▁; ▁y buf ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁cur ▁<< ▁1 ▁; ▁last ▁= ▁cur ▁; ▁} ▁y buf ▁[ ▁j ▁] ▁= ▁last ▁<< ▁1 ▁; ▁prev _ buf ▁= ▁y buf ▁; ▁y buf ▁+= ▁avctx ▁-> ▁width ▁; ▁} ▁if ▁( ▁corr _ off ▁) ▁{ ▁int ▁corr _ end ▁, ▁dec _ size ▁; ▁corr _ end ▁= ▁avpkt ▁-> ▁size ▁; ▁if ▁( ▁chroma _ off ▁> ▁corr _ off ▁) ▁corr _ end ▁= ▁chroma _ off ▁; ▁dec _ size ▁= ▁x an _ unpack ▁( ▁s ▁-> ▁scratch _ buffer ▁, ▁s ▁-> ▁buffer _ size ▁, ▁avpkt ▁-> ▁data ▁+ ▁8 ▁+ ▁corr _ off ▁, ▁corr _ end ▁- ▁corr _ off ▁) ▁; ▁if ▁( ▁dec _ size ▁< ▁0 ▁) ▁dec _ size ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dec _ size ▁; ▁i ▁++ ▁) ▁s ▁-> ▁y _ buffer ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁( ▁s ▁-> ▁y _ buffer ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁+ ▁( ▁s ▁-> ▁scratch _ buffer ▁[ ▁i ▁] ▁<< ▁1 ▁) ▁) ▁& ▁0 x 3 F ▁; ▁} ▁src ▁= ▁s ▁-> ▁y _ buffer ▁; ▁y buf ▁= ▁s ▁-> ▁pic ▁. ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁avctx ▁-> ▁height ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁width ▁; ▁i ▁++ ▁) ▁y buf ▁[ ▁i ▁] ▁= ▁( ▁src ▁[ ▁i ▁] ▁<< ▁2 ▁) ▁| ▁( ▁src ▁[ ▁i ▁] ▁>> ▁3 ▁) ▁; ▁src ▁+= ▁avctx ▁-> ▁width ▁; ▁y buf ▁+= ▁s ▁-> ▁pic ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁tls _ ps k _ do _ binder ▁( ▁SSL ▁* ▁s ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁const ▁unsigned ▁char ▁* ▁msg start ▁, ▁size _ t ▁binder offset ▁, ▁const ▁unsigned ▁char ▁* ▁binder in ▁, ▁unsigned ▁char ▁* ▁binder out ▁, ▁SSL _ SESSION ▁* ▁sess ▁, ▁int ▁sign ▁, ▁int ▁external ▁) ▁{ ▁EVP _ PKEY ▁* ▁m ack ey ▁= ▁NULL ▁; ▁EVP _ MD _ CTX ▁* ▁mctx ▁= ▁NULL ▁; ▁unsigned ▁char ▁hash ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁, ▁binder key ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁unsigned ▁char ▁finished key ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁, ▁tmp binder ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁unsigned ▁char ▁* ▁early _ secret ▁; ▁const ▁char ▁res umption _ label ▁[ ▁] ▁= ▁" res binder " ▁; ▁const ▁char ▁external _ label ▁[ ▁] ▁= ▁" ext binder " ▁; ▁const ▁char ▁* ▁label ▁; ▁size _ t ▁binder size ▁, ▁label size ▁, ▁hash size ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁int ▁ret ▁= ▁-1 ▁; ▁if ▁( ▁external ▁) ▁{ ▁label ▁= ▁external _ label ▁; ▁label size ▁= ▁sizeof ▁( ▁external _ label ▁) ▁- ▁1 ▁; ▁} ▁else ▁{ ▁label ▁= ▁res umption _ label ▁; ▁label size ▁= ▁sizeof ▁( ▁res umption _ label ▁) ▁- ▁1 ▁; ▁} ▁if ▁( ▁s ▁-> ▁server ▁|| ▁! ▁external ▁) ▁early _ secret ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁s ▁-> ▁early _ secret ▁; ▁else ▁early _ secret ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁sess ▁-> ▁early _ secret ▁; ▁if ▁( ▁! ▁tls 13_ generate _ secret ▁( ▁s ▁, ▁md ▁, ▁NULL ▁, ▁sess ▁-> ▁master _ key ▁, ▁sess ▁-> ▁master _ key _ length ▁, ▁early _ secret ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁mctx ▁= ▁EVP _ MD _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁mctx ▁== ▁NULL ▁|| ▁EVP _ Digest Init _ ex ▁( ▁mctx ▁, ▁md ▁, ▁NULL ▁) ▁<= ▁0 ▁|| ▁EVP _ Digest Final _ ex ▁( ▁mctx ▁, ▁hash ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁tls 13_ h kdf _ expand ▁( ▁s ▁, ▁md ▁, ▁early _ secret ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁label ▁, ▁label size ▁, ▁hash ▁, ▁hash size ▁, ▁binder key ▁, ▁hash size ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁tls 13_ der ive _ finished key ▁( ▁s ▁, ▁md ▁, ▁binder key ▁, ▁finished key ▁, ▁hash size ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁EVP _ Digest Init _ ex ▁( ▁mctx ▁, ▁md ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁hello _ retry _ request ▁) ▁{ ▁size _ t ▁hd atal en ▁; ▁void ▁* ▁h data ▁; ▁hd atal en ▁= ▁BIO _ get _ mem _ data ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ buffer ▁, ▁& ▁h data ▁) ▁; ▁if ▁( ▁hd atal en ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁SSL _ R _ BAD _ HAND SHAKE _ LENGTH ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁server ▁) ▁{ ▁PACKET ▁hash prefix ▁, ▁msg ▁; ▁if ▁( ▁! ▁PACKET _ buf _ init ▁( ▁& ▁hash prefix ▁, ▁h data ▁, ▁hd atal en ▁) ▁|| ▁! ▁PACKET _ forward ▁( ▁& ▁hash prefix ▁, ▁1 ▁) ▁|| ▁! ▁PACKET _ get _ length _ pref ixed _3 ▁( ▁& ▁hash prefix ▁, ▁& ▁msg ▁) ▁|| ▁! ▁PACKET _ forward ▁( ▁& ▁hash prefix ▁, ▁1 ▁) ▁|| ▁! ▁PACKET _ get _ length _ pref ixed _3 ▁( ▁& ▁hash prefix ▁, ▁& ▁msg ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁hd atal en ▁-= ▁PACKET _ remaining ▁( ▁& ▁hash prefix ▁) ▁; ▁} ▁if ▁( ▁EVP _ DigestUpdate ▁( ▁mctx ▁, ▁h data ▁, ▁hd atal en ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁if ▁( ▁EVP _ DigestUpdate ▁( ▁mctx ▁, ▁msg start ▁, ▁binder offset ▁) ▁<= ▁0 ▁|| ▁EVP _ Digest Final _ ex ▁( ▁mctx ▁, ▁hash ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁m ack ey ▁= ▁EVP _ PKEY _ new _ mac _ key ▁( ▁EVP _ PKEY _ HMAC ▁, ▁NULL ▁, ▁finished key ▁, ▁hash size ▁) ▁; ▁if ▁( ▁m ack ey ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁sign ▁) ▁binder out ▁= ▁tmp binder ▁; ▁binder size ▁= ▁hash size ▁; ▁if ▁( ▁EVP _ Digest Sign Init ▁( ▁mctx ▁, ▁NULL ▁, ▁md ▁, ▁NULL ▁, ▁m ack ey ▁) ▁<= ▁0 ▁|| ▁EVP _ Digest Sign Update ▁( ▁mctx ▁, ▁hash ▁, ▁hash size ▁) ▁<= ▁0 ▁|| ▁EVP _ Digest Sign Final ▁( ▁mctx ▁, ▁binder out ▁, ▁& ▁binder size ▁) ▁<= ▁0 ▁|| ▁binder size ▁!= ▁hash size ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ PS K _ DO _ BIND ER ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁sign ▁) ▁{ ▁ret ▁= ▁1 ▁; ▁} ▁else ▁{ ▁ret ▁= ▁( ▁CRYPTO _ memcmp ▁( ▁binder in ▁, ▁binder out ▁, ▁hash size ▁) ▁== ▁0 ▁) ▁; ▁} ▁err ▁: ▁OPENSSL _ cleanse ▁( ▁binder key ▁, ▁sizeof ▁( ▁binder key ▁) ▁) ▁; ▁OPENSSL _ cleanse ▁( ▁finished key ▁, ▁sizeof ▁( ▁finished key ▁) ▁) ▁; ▁EVP _ PKEY _ free ▁( ▁m ack ey ▁) ▁; ▁EVP _ MD _ CTX _ free ▁( ▁mctx ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁opus _ packet ▁( ▁AVFormatContext ▁* ▁av f ▁, ▁int ▁idx ▁) ▁{ ▁struct ▁ogg ▁* ▁ogg ▁= ▁av f ▁-> ▁priv _ data ▁; ▁struct ▁ogg _ stream ▁* ▁os ▁= ▁& ▁ogg ▁-> ▁streams ▁[ ▁idx ▁] ▁; ▁AVStream ▁* ▁st ▁= ▁av f ▁-> ▁streams ▁[ ▁idx ▁] ▁; ▁struct ▁ogg opus _ private ▁* ▁priv ▁= ▁os ▁-> ▁private ▁; ▁uint 8_ t ▁* ▁packet ▁= ▁os ▁-> ▁buf ▁+ ▁os ▁-> ▁p start ▁; ▁int ▁ret ▁; ▁if ▁( ▁! ▁os ▁-> ▁psize ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁( ▁! ▁os ▁-> ▁last pts ▁|| ▁os ▁-> ▁last pts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁&& ▁! ▁( ▁os ▁-> ▁flags ▁& ▁O GG _ FLAG _ E OS ▁) ▁) ▁{ ▁int ▁seg ▁, ▁d ▁; ▁int ▁duration ▁; ▁uint 8_ t ▁* ▁last _ pkt ▁= ▁os ▁-> ▁buf ▁+ ▁os ▁-> ▁p start ▁; ▁uint 8_ t ▁* ▁next _ pkt ▁= ▁last _ pkt ▁; ▁duration ▁= ▁0 ▁; ▁seg ▁= ▁os ▁-> ▁seg p ▁; ▁d ▁= ▁opus _ duration ▁( ▁last _ pkt ▁, ▁os ▁-> ▁psize ▁) ▁; ▁if ▁( ▁d ▁< ▁0 ▁) ▁{ ▁os ▁-> ▁p flags ▁|= ▁AV _ PKT _ FLAG _ COR RUP T ▁; ▁return ▁0 ▁; ▁} ▁duration ▁+= ▁d ▁; ▁last _ pkt ▁= ▁next _ pkt ▁= ▁next _ pkt ▁+ ▁os ▁-> ▁psize ▁; ▁for ▁( ▁; ▁seg ▁< ▁os ▁-> ▁n segs ▁; ▁seg ▁++ ▁) ▁{ ▁if ▁( ▁os ▁-> ▁segments ▁[ ▁seg ▁] ▁< ▁255 ▁) ▁{ ▁int ▁d ▁= ▁opus _ duration ▁( ▁last _ pkt ▁, ▁os ▁-> ▁segments ▁[ ▁seg ▁] ▁) ▁; ▁if ▁( ▁d ▁< ▁0 ▁) ▁{ ▁duration ▁= ▁os ▁-> ▁gran ule ▁; ▁break ▁; ▁} ▁duration ▁+= ▁d ▁; ▁last _ pkt ▁= ▁next _ pkt ▁+ ▁os ▁-> ▁segments ▁[ ▁seg ▁] ▁; ▁} ▁next _ pkt ▁+= ▁os ▁-> ▁segments ▁[ ▁seg ▁] ▁; ▁} ▁os ▁-> ▁last pts ▁= ▁os ▁-> ▁last dts ▁= ▁os ▁-> ▁gran ule ▁- ▁duration ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁opus _ duration ▁( ▁packet ▁, ▁os ▁-> ▁psize ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁os ▁-> ▁pd uration ▁= ▁ret ▁; ▁if ▁( ▁os ▁-> ▁last pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁if ▁( ▁st ▁-> ▁start _ time ▁== ▁AV _ NOP TS _ VALUE ▁) ▁st ▁-> ▁start _ time ▁= ▁os ▁-> ▁last pts ▁; ▁priv ▁-> ▁cur _ dts ▁= ▁os ▁-> ▁last dts ▁= ▁os ▁-> ▁last pts ▁-= ▁priv ▁-> ▁pre _ skip ▁; ▁} ▁priv ▁-> ▁cur _ dts ▁+= ▁os ▁-> ▁pd uration ▁; ▁if ▁( ▁( ▁os ▁-> ▁flags ▁& ▁O GG _ FLAG _ E OS ▁) ▁) ▁{ ▁int 64_ t ▁skip ▁= ▁priv ▁-> ▁cur _ dts ▁- ▁os ▁-> ▁gran ule ▁+ ▁priv ▁-> ▁pre _ skip ▁; ▁skip ▁= ▁FF MIN ▁( ▁skip ▁, ▁os ▁-> ▁pd uration ▁) ▁; ▁if ▁( ▁skip ▁> ▁0 ▁) ▁{ ▁os ▁-> ▁pd uration ▁= ▁skip ▁< ▁os ▁-> ▁pd uration ▁? ▁os ▁-> ▁pd uration ▁- ▁skip ▁: ▁1 ▁; ▁os ▁-> ▁end _ tri mm ing ▁= ▁skip ▁; ▁av _ log ▁( ▁av f ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Last packet wa str unc ated to % dd u eto end tri mm ing .\ n " ▁, ▁os ▁-> ▁pd uration ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁h 264_ slice _ header _ init ▁( ▁H 264 Context ▁* ▁h ▁) ▁{ ▁int ▁nb _ s lices ▁= ▁( ▁HAVE _ THREADS ▁&& ▁h ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁? ▁h ▁-> ▁avctx ▁-> ▁thread _ count ▁: ▁1 ▁; ▁int ▁i ▁, ▁ret ▁; ▁ff _ set _ sar ▁( ▁h ▁-> ▁avctx ▁, ▁h ▁-> ▁sps ▁. ▁sar ▁) ▁; ▁av _ pix _ fmt _ get _ chroma _ sub _ sample ▁( ▁h ▁-> ▁avctx ▁-> ▁pix _ fmt ▁, ▁& ▁h ▁-> ▁chroma _ x _ shift ▁, ▁& ▁h ▁-> ▁chroma _ y _ shift ▁) ▁; ▁if ▁( ▁h ▁-> ▁sps ▁. ▁timing _ info _ present _ flag ▁) ▁{ ▁int 64_ t ▁den ▁= ▁h ▁-> ▁sps ▁. ▁time _ scale ▁; ▁if ▁( ▁h ▁-> ▁x 264_ build ▁< ▁44 U ▁) ▁den ▁*= ▁2 ▁; ▁av _ reduce ▁( ▁& ▁h ▁-> ▁avctx ▁-> ▁fram erate ▁. ▁den ▁, ▁& ▁h ▁-> ▁avctx ▁-> ▁fram erate ▁. ▁num ▁, ▁h ▁-> ▁sps ▁. ▁num _ units _ in _ tick ▁, ▁den ▁, ▁1 ▁<< ▁30 ▁) ▁; ▁} ▁ff _ h 264_ free _ tables ▁( ▁h ▁) ▁; ▁h ▁-> ▁first _ field ▁= ▁0 ▁; ▁h ▁-> ▁prev _ inter l aced _ frame ▁= ▁1 ▁; ▁init _ scan _ tables ▁( ▁h ▁) ▁; ▁ret ▁= ▁ff _ h 264_ alloc _ tables ▁( ▁h ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Could not allocate memory \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁< ▁8 ▁|| ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁> ▁10 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported bit depth % d \ n " ▁, ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁h ▁-> ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁= ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁; ▁h ▁-> ▁pixel _ shift ▁= ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁> ▁8 ▁; ▁h ▁-> ▁chroma _ format _ id c ▁= ▁h ▁-> ▁sps ▁. ▁chroma _ format _ id c ▁; ▁h ▁-> ▁bit _ depth _ l uma ▁= ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁; ▁ff _ h 264 dsp _ init ▁( ▁& ▁h ▁-> ▁h 264 dsp ▁, ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁, ▁h ▁-> ▁sps ▁. ▁chroma _ format _ id c ▁) ▁; ▁ff _ h 264 chroma _ init ▁( ▁& ▁h ▁-> ▁h 264 chroma ▁, ▁h ▁-> ▁sps ▁. ▁bit _ depth _ chroma ▁) ▁; ▁ff _ h 264 q pel _ init ▁( ▁& ▁h ▁-> ▁h 264 q pel ▁, ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁) ▁; ▁ff _ h 264_ pred _ init ▁( ▁& ▁h ▁-> ▁hpc ▁, ▁h ▁-> ▁avctx ▁-> ▁codec _ id ▁, ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁, ▁h ▁-> ▁sps ▁. ▁chroma _ format _ id c ▁) ▁; ▁ff _ vide od sp _ init ▁( ▁& ▁h ▁-> ▁v dsp ▁, ▁h ▁-> ▁sps ▁. ▁bit _ depth _ l uma ▁) ▁; ▁if ▁( ▁nb _ s lices ▁> ▁H 264_ MAX _ THREADS ▁|| ▁( ▁nb _ s lices ▁> ▁h ▁-> ▁mb _ height ▁&& ▁h ▁-> ▁mb _ height ▁) ▁) ▁{ ▁int ▁max _ s lices ▁; ▁if ▁( ▁h ▁-> ▁mb _ height ▁) ▁max _ s lices ▁= ▁FF MIN ▁( ▁H 264_ MAX _ THREADS ▁, ▁h ▁-> ▁mb _ height ▁) ▁; ▁else ▁max _ s lices ▁= ▁H 264_ MAX _ THREADS ▁; ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" t oom any threads / s lices % d ," ▁" red uc ing to % d \ n " ▁, ▁nb _ s lices ▁, ▁max _ s lices ▁) ▁; ▁nb _ s lices ▁= ▁max _ s lices ▁; ▁} ▁h ▁-> ▁slice _ context _ count ▁= ▁nb _ s lices ▁; ▁if ▁( ▁! ▁HAVE _ THREADS ▁|| ▁! ▁( ▁h ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁) ▁{ ▁ret ▁= ▁ff _ h 264_ slice _ context _ init ▁( ▁h ▁, ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" context _ init () failed .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁H 264 Slice Context ▁* ▁sl ▁= ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁i ▁] ▁; ▁sl ▁-> ▁h 264 ▁= ▁h ▁; ▁sl ▁-> ▁in tra 4 x 4_ pred _ mode ▁= ▁h ▁-> ▁in tra 4 x 4_ pred _ mode ▁+ ▁i ▁* ▁8 ▁* ▁2 ▁* ▁h ▁-> ▁mb _ stride ▁; ▁sl ▁-> ▁mv d _ table ▁[ ▁0 ▁] ▁= ▁h ▁-> ▁mv d _ table ▁[ ▁0 ▁] ▁+ ▁i ▁* ▁8 ▁* ▁2 ▁* ▁h ▁-> ▁mb _ stride ▁; ▁sl ▁-> ▁mv d _ table ▁[ ▁1 ▁] ▁= ▁h ▁-> ▁mv d _ table ▁[ ▁1 ▁] ▁+ ▁i ▁* ▁8 ▁* ▁2 ▁* ▁h ▁-> ▁mb _ stride ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ h 264_ slice _ context _ init ▁( ▁h ▁, ▁sl ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" context _ init () failed .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁} ▁h ▁-> ▁context _ initialized ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	1
▁void ▁ff _ e ac 3_ apply _ s pectral _ extension ▁( ▁AC 3 Decode Context ▁* ▁s ▁) ▁{ ▁int ▁bin ▁, ▁bnd ▁, ▁ch ▁, ▁i ▁; ▁uint 8_ t ▁wrap flag ▁[ ▁SP X _ MAX _ BAND S ▁] ▁= ▁{ ▁1 ▁, ▁0 ▁, ▁} ▁, ▁num _ copy _ sections ▁, ▁copy _ sizes ▁[ ▁SP X _ MAX _ BAND S ▁] ▁; ▁float ▁rms _ energy ▁[ ▁SP X _ MAX _ BAND S ▁] ▁; ▁bin ▁= ▁s ▁-> ▁sp x _ dst _ start _ freq ▁; ▁num _ copy _ sections ▁= ▁0 ▁; ▁for ▁( ▁bnd ▁= ▁0 ▁; ▁bnd ▁< ▁s ▁-> ▁num _ sp x _ band s ▁; ▁bnd ▁++ ▁) ▁{ ▁int ▁copy size ▁; ▁int ▁band size ▁= ▁s ▁-> ▁sp x _ band _ sizes ▁[ ▁bnd ▁] ▁; ▁if ▁( ▁bin ▁+ ▁band size ▁> ▁s ▁-> ▁sp x _ src _ start _ freq ▁) ▁{ ▁copy _ sizes ▁[ ▁num _ copy _ sections ▁++ ▁] ▁= ▁bin ▁- ▁s ▁-> ▁sp x _ dst _ start _ freq ▁; ▁bin ▁= ▁s ▁-> ▁sp x _ dst _ start _ freq ▁; ▁wrap flag ▁[ ▁bnd ▁] ▁= ▁1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁band size ▁; ▁i ▁+= ▁copy size ▁) ▁{ ▁if ▁( ▁bin ▁== ▁s ▁-> ▁sp x _ src _ start _ freq ▁) ▁{ ▁copy _ sizes ▁[ ▁num _ copy _ sections ▁++ ▁] ▁= ▁bin ▁- ▁s ▁-> ▁sp x _ dst _ start _ freq ▁; ▁bin ▁= ▁s ▁-> ▁sp x _ dst _ start _ freq ▁; ▁} ▁copy size ▁= ▁FF MIN ▁( ▁band size ▁- ▁i ▁, ▁s ▁-> ▁sp x _ src _ start _ freq ▁- ▁bin ▁) ▁; ▁bin ▁+= ▁copy size ▁; ▁} ▁} ▁copy _ sizes ▁[ ▁num _ copy _ sections ▁++ ▁] ▁= ▁bin ▁- ▁s ▁-> ▁sp x _ dst _ start _ freq ▁; ▁for ▁( ▁ch ▁= ▁1 ▁; ▁ch ▁<= ▁s ▁-> ▁fb w _ channels ▁; ▁ch ▁++ ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁channel _ uses _ sp x ▁[ ▁ch ▁] ▁) ▁continue ▁; ▁bin ▁= ▁s ▁-> ▁sp x _ src _ start _ freq ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ copy _ sections ▁; ▁i ▁++ ▁) ▁{ ▁memcpy ▁( ▁& ▁s ▁-> ▁transform _ coeffs ▁[ ▁ch ▁] ▁[ ▁bin ▁] ▁, ▁& ▁s ▁-> ▁transform _ coeffs ▁[ ▁ch ▁] ▁[ ▁s ▁-> ▁sp x _ dst _ start _ freq ▁] ▁, ▁copy _ sizes ▁[ ▁i ▁] ▁* ▁sizeof ▁( ▁float ▁) ▁) ▁; ▁bin ▁+= ▁copy _ sizes ▁[ ▁i ▁] ▁; ▁} ▁bin ▁= ▁s ▁-> ▁sp x _ src _ start _ freq ▁; ▁for ▁( ▁bnd ▁= ▁0 ▁; ▁bnd ▁< ▁s ▁-> ▁num _ sp x _ band s ▁; ▁bnd ▁++ ▁) ▁{ ▁int ▁band size ▁= ▁s ▁-> ▁sp x _ band _ sizes ▁[ ▁bnd ▁] ▁; ▁float ▁accum ▁= ▁0.0 f ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁band size ▁; ▁i ▁++ ▁) ▁{ ▁float ▁coeff ▁= ▁s ▁-> ▁transform _ coeffs ▁[ ▁ch ▁] ▁[ ▁bin ▁++ ▁] ▁; ▁accum ▁+= ▁coeff ▁* ▁coeff ▁; ▁} ▁rms _ energy ▁[ ▁bnd ▁] ▁= ▁sqrtf ▁( ▁accum ▁/ ▁band size ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁sp x _ at ten _ code ▁[ ▁ch ▁] ▁>= ▁0 ▁) ▁{ ▁const ▁float ▁* ▁at ten _ tab ▁= ▁ff _ e ac 3_ sp x _ at ten _ tab ▁[ ▁s ▁-> ▁sp x _ at ten _ code ▁[ ▁ch ▁] ▁] ▁; ▁bin ▁= ▁s ▁-> ▁sp x _ src _ start _ freq ▁- ▁2 ▁; ▁for ▁( ▁bnd ▁= ▁0 ▁; ▁bnd ▁< ▁s ▁-> ▁num _ sp x _ band s ▁; ▁bnd ▁++ ▁) ▁{ ▁if ▁( ▁wrap flag ▁[ ▁bnd ▁] ▁) ▁{ ▁float ▁* ▁coeffs ▁= ▁& ▁s ▁-> ▁transform _ coeffs ▁[ ▁ch ▁] ▁[ ▁bin ▁] ▁; ▁coeffs ▁[ ▁0 ▁] ▁*= ▁at ten _ tab ▁[ ▁0 ▁] ▁; ▁coeffs ▁[ ▁1 ▁] ▁*= ▁at ten _ tab ▁[ ▁1 ▁] ▁; ▁coeffs ▁[ ▁2 ▁] ▁*= ▁at ten _ tab ▁[ ▁2 ▁] ▁; ▁coeffs ▁[ ▁3 ▁] ▁*= ▁at ten _ tab ▁[ ▁1 ▁] ▁; ▁coeffs ▁[ ▁4 ▁] ▁*= ▁at ten _ tab ▁[ ▁0 ▁] ▁; ▁} ▁bin ▁+= ▁s ▁-> ▁sp x _ band _ sizes ▁[ ▁bnd ▁] ▁; ▁} ▁} ▁bin ▁= ▁s ▁-> ▁sp x _ src _ start _ freq ▁; ▁for ▁( ▁bnd ▁= ▁0 ▁; ▁bnd ▁< ▁s ▁-> ▁num _ sp x _ band s ▁; ▁bnd ▁++ ▁) ▁{ ▁float ▁n scale ▁= ▁s ▁-> ▁sp x _ noise _ blend ▁[ ▁ch ▁] ▁[ ▁bnd ▁] ▁* ▁rms _ energy ▁[ ▁bnd ▁] ▁* ▁( ▁1.0 f ▁/ ▁INT 32_ MIN ▁) ▁; ▁float ▁s scale ▁= ▁s ▁-> ▁sp x _ signal _ blend ▁[ ▁ch ▁] ▁[ ▁bnd ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁sp x _ band _ sizes ▁[ ▁bnd ▁] ▁; ▁i ▁++ ▁) ▁{ ▁float ▁noise ▁= ▁n scale ▁* ▁( ▁int 32_ t ▁) ▁av _ lf g _ get ▁( ▁& ▁s ▁-> ▁d ith _ state ▁) ▁; ▁s ▁-> ▁transform _ coeffs ▁[ ▁ch ▁] ▁[ ▁bin ▁] ▁*= ▁s scale ▁; ▁s ▁-> ▁transform _ coeffs ▁[ ▁ch ▁] ▁[ ▁bin ▁++ ▁] ▁+= ▁noise ▁; ▁} ▁} ▁} ▁}	1
▁SSL _ SESSION ▁* ▁ssl _ session _ dup ▁( ▁const ▁SSL _ SESSION ▁* ▁src ▁, ▁int ▁ticket ▁) ▁{ ▁SSL _ SESSION ▁* ▁dest ▁; ▁dest ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁src ▁) ▁) ▁; ▁if ▁( ▁dest ▁== ▁NULL ▁) ▁{ ▁goto ▁err ▁; ▁} ▁memcpy ▁( ▁dest ▁, ▁src ▁, ▁sizeof ▁( ▁* ▁dest ▁) ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ PS K ▁dest ▁-> ▁p sk _ identity _ hint ▁= ▁NULL ▁; ▁dest ▁-> ▁p sk _ identity ▁= ▁NULL ▁; ▁# endif ▁dest ▁-> ▁ext ▁. ▁hostname ▁= ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ EC ▁dest ▁-> ▁ext ▁. ▁ec point formats ▁= ▁NULL ▁; ▁# endif ▁dest ▁-> ▁ext ▁. ▁tick ▁= ▁NULL ▁; ▁dest ▁-> ▁ext ▁. ▁al pn _ selected ▁= ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ SR P ▁dest ▁-> ▁sr p _ username ▁= ▁NULL ▁; ▁# endif ▁dest ▁-> ▁peer _ chain ▁= ▁NULL ▁; ▁dest ▁-> ▁peer ▁= ▁NULL ▁; ▁dest ▁-> ▁ticket _ app data ▁= ▁NULL ▁; ▁memset ▁( ▁& ▁dest ▁-> ▁ex _ data ▁, ▁0 ▁, ▁sizeof ▁( ▁dest ▁-> ▁ex _ data ▁) ▁) ▁; ▁dest ▁-> ▁prev ▁= ▁NULL ▁; ▁dest ▁-> ▁next ▁= ▁NULL ▁; ▁dest ▁-> ▁references ▁= ▁1 ▁; ▁dest ▁-> ▁lock ▁= ▁CRYPTO _ THREAD _ lock _ new ▁( ▁) ▁; ▁if ▁( ▁dest ▁-> ▁lock ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁CRYPTO _ new _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL _ SESSION ▁, ▁dest ▁, ▁& ▁dest ▁-> ▁ex _ data ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁src ▁-> ▁peer ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁X 509_ up _ ref ▁( ▁src ▁-> ▁peer ▁) ▁) ▁goto ▁err ▁; ▁dest ▁-> ▁peer ▁= ▁src ▁-> ▁peer ▁; ▁} ▁if ▁( ▁src ▁-> ▁peer _ chain ▁!= ▁NULL ▁) ▁{ ▁dest ▁-> ▁peer _ chain ▁= ▁X 509_ chain _ up _ ref ▁( ▁src ▁-> ▁peer _ chain ▁) ▁; ▁if ▁( ▁dest ▁-> ▁peer _ chain ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ PS K ▁if ▁( ▁src ▁-> ▁p sk _ identity _ hint ▁) ▁{ ▁dest ▁-> ▁p sk _ identity _ hint ▁= ▁OPENSSL _ strdup ▁( ▁src ▁-> ▁p sk _ identity _ hint ▁) ▁; ▁if ▁( ▁dest ▁-> ▁p sk _ identity _ hint ▁== ▁NULL ▁) ▁{ ▁goto ▁err ▁; ▁} ▁} ▁if ▁( ▁src ▁-> ▁p sk _ identity ▁) ▁{ ▁dest ▁-> ▁p sk _ identity ▁= ▁OPENSSL _ strdup ▁( ▁src ▁-> ▁p sk _ identity ▁) ▁; ▁if ▁( ▁dest ▁-> ▁p sk _ identity ▁== ▁NULL ▁) ▁{ ▁goto ▁err ▁; ▁} ▁} ▁# endif ▁if ▁( ▁! ▁CRYPTO _ dup _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL _ SESSION ▁, ▁& ▁dest ▁-> ▁ex _ data ▁, ▁& ▁src ▁-> ▁ex _ data ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁if ▁( ▁src ▁-> ▁ext ▁. ▁hostname ▁) ▁{ ▁dest ▁-> ▁ext ▁. ▁hostname ▁= ▁OPENSSL _ strdup ▁( ▁src ▁-> ▁ext ▁. ▁hostname ▁) ▁; ▁if ▁( ▁dest ▁-> ▁ext ▁. ▁hostname ▁== ▁NULL ▁) ▁{ ▁goto ▁err ▁; ▁} ▁} ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁src ▁-> ▁ext ▁. ▁ec point formats ▁) ▁{ ▁dest ▁-> ▁ext ▁. ▁ec point formats ▁= ▁OPENSSL _ mem dup ▁( ▁src ▁-> ▁ext ▁. ▁ec point formats ▁, ▁src ▁-> ▁ext ▁. ▁ec point formats _ len ▁) ▁; ▁if ▁( ▁dest ▁-> ▁ext ▁. ▁ec point formats ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁# endif ▁if ▁( ▁ticket ▁!= ▁0 ▁&& ▁src ▁-> ▁ext ▁. ▁tick ▁!= ▁NULL ▁) ▁{ ▁dest ▁-> ▁ext ▁. ▁tick ▁= ▁OPENSSL _ mem dup ▁( ▁src ▁-> ▁ext ▁. ▁tick ▁, ▁src ▁-> ▁ext ▁. ▁tick len ▁) ▁; ▁if ▁( ▁dest ▁-> ▁ext ▁. ▁tick ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁else ▁{ ▁dest ▁-> ▁ext ▁. ▁tick _ l ifetime _ hint ▁= ▁0 ▁; ▁dest ▁-> ▁ext ▁. ▁tick len ▁= ▁0 ▁; ▁} ▁if ▁( ▁src ▁-> ▁ext ▁. ▁al pn _ selected ▁!= ▁NULL ▁) ▁{ ▁dest ▁-> ▁ext ▁. ▁al pn _ selected ▁= ▁OPENSSL _ mem dup ▁( ▁src ▁-> ▁ext ▁. ▁al pn _ selected ▁, ▁src ▁-> ▁ext ▁. ▁al pn _ selected _ len ▁) ▁; ▁if ▁( ▁dest ▁-> ▁ext ▁. ▁al pn _ selected ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ SR P ▁if ▁( ▁src ▁-> ▁sr p _ username ▁) ▁{ ▁dest ▁-> ▁sr p _ username ▁= ▁OPENSSL _ strdup ▁( ▁src ▁-> ▁sr p _ username ▁) ▁; ▁if ▁( ▁dest ▁-> ▁sr p _ username ▁== ▁NULL ▁) ▁{ ▁goto ▁err ▁; ▁} ▁} ▁# endif ▁if ▁( ▁src ▁-> ▁ticket _ app data ▁!= ▁NULL ▁) ▁{ ▁dest ▁-> ▁ticket _ app data ▁= ▁OPENSSL _ mem dup ▁( ▁src ▁-> ▁ticket _ app data ▁, ▁src ▁-> ▁ticket _ app data _ len ▁) ▁; ▁if ▁( ▁dest ▁-> ▁ticket _ app data ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁return ▁dest ▁; ▁err ▁: ▁SSL err ▁( ▁SSL _ F _ SSL _ SESSION _ DUP ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁SSL _ SESSION _ free ▁( ▁dest ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁BIGNUM ▁* ▁BN _ POOL _ get ▁( ▁BN _ POOL ▁* ▁p ▁, ▁int ▁flag ▁) ▁{ ▁BIGNUM ▁* ▁bn ▁; ▁unsigned ▁int ▁loop ▁; ▁if ▁( ▁p ▁-> ▁used ▁== ▁p ▁-> ▁size ▁) ▁{ ▁BN _ POOL _ ITEM ▁* ▁item ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁item ▁) ▁) ▁; ▁if ▁( ▁item ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁for ▁( ▁loop ▁= ▁0 ▁, ▁bn ▁= ▁item ▁-> ▁vals ▁; ▁loop ▁++ ▁< ▁BN _ CTX _ POOL _ SIZE ▁; ▁bn ▁++ ▁) ▁{ ▁BN _ init ▁( ▁bn ▁) ▁; ▁if ▁( ▁( ▁flag ▁& ▁BN _ FLG _ SECURE ▁) ▁!= ▁0 ▁) ▁BN _ set _ flags ▁( ▁bn ▁, ▁BN _ FLG _ SECURE ▁) ▁; ▁} ▁item ▁-> ▁prev ▁= ▁p ▁-> ▁tail ▁; ▁item ▁-> ▁next ▁= ▁NULL ▁; ▁if ▁( ▁p ▁-> ▁head ▁== ▁NULL ▁) ▁p ▁-> ▁head ▁= ▁p ▁-> ▁current ▁= ▁p ▁-> ▁tail ▁= ▁item ▁; ▁else ▁{ ▁p ▁-> ▁tail ▁-> ▁next ▁= ▁item ▁; ▁p ▁-> ▁tail ▁= ▁item ▁; ▁p ▁-> ▁current ▁= ▁item ▁; ▁} ▁p ▁-> ▁size ▁+= ▁BN _ CTX _ POOL _ SIZE ▁; ▁p ▁-> ▁used ▁++ ▁; ▁return ▁item ▁-> ▁vals ▁; ▁} ▁if ▁( ▁! ▁p ▁-> ▁used ▁) ▁p ▁-> ▁current ▁= ▁p ▁-> ▁head ▁; ▁else ▁if ▁( ▁( ▁p ▁-> ▁used ▁% ▁BN _ CTX _ POOL _ SIZE ▁) ▁== ▁0 ▁) ▁p ▁-> ▁current ▁= ▁p ▁-> ▁current ▁-> ▁next ▁; ▁return ▁p ▁-> ▁current ▁-> ▁vals ▁+ ▁( ▁( ▁p ▁-> ▁used ▁++ ▁) ▁% ▁BN _ CTX _ POOL _ SIZE ▁) ▁; ▁}	1
▁static ▁int ▁dvb sub _ parse _ cl ut _ segment ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁DVB Sub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁uint 8_ t ▁* ▁buf _ end ▁= ▁buf ▁+ ▁buf _ size ▁; ▁int ▁i ▁, ▁cl ut _ id ▁; ▁DVB Sub CL UT ▁* ▁cl ut ▁; ▁int ▁entry _ id ▁, ▁depth ▁, ▁full _ range ▁; ▁int ▁y ▁, ▁cr ▁, ▁cb ▁, ▁alpha ▁; ▁int ▁r ▁, ▁g ▁, ▁b ▁, ▁r _ add ▁, ▁g _ add ▁, ▁b _ add ▁; ▁av _ d log ▁( ▁avctx ▁, ▁" D VB cl ut packet :\ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁buf _ size ▁; ▁i ▁++ ▁) ▁{ ▁av _ d log ▁( ▁avctx ▁, ▁"%02 x " ▁, ▁buf ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁i ▁% ▁16 ▁== ▁15 ▁) ▁av _ d log ▁( ▁avctx ▁, ▁"\ n " ▁) ▁; ▁} ▁if ▁( ▁i ▁% ▁16 ▁) ▁av _ d log ▁( ▁avctx ▁, ▁"\ n " ▁) ▁; ▁cl ut _ id ▁= ▁* ▁buf ▁++ ▁; ▁buf ▁+= ▁1 ▁; ▁cl ut ▁= ▁get _ cl ut ▁( ▁ctx ▁, ▁cl ut _ id ▁) ▁; ▁if ▁( ▁! ▁cl ut ▁) ▁{ ▁cl ut ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁DVB Sub CL UT ▁) ▁) ▁; ▁if ▁( ▁! ▁cl ut ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁cl ut ▁, ▁& ▁default _ cl ut ▁, ▁sizeof ▁( ▁DVB Sub CL UT ▁) ▁) ▁; ▁cl ut ▁-> ▁id ▁= ▁cl ut _ id ▁; ▁cl ut ▁-> ▁next ▁= ▁ctx ▁-> ▁cl ut _ list ▁; ▁ctx ▁-> ▁cl ut _ list ▁= ▁cl ut ▁; ▁} ▁while ▁( ▁buf ▁+ ▁4 ▁< ▁buf _ end ▁) ▁{ ▁entry _ id ▁= ▁* ▁buf ▁++ ▁; ▁depth ▁= ▁( ▁* ▁buf ▁) ▁& ▁0 xe 0 ▁; ▁if ▁( ▁depth ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid cl ut depth 0 x % x !\ n " ▁, ▁* ▁buf ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁full _ range ▁= ▁( ▁* ▁buf ▁++ ▁) ▁& ▁1 ▁; ▁if ▁( ▁full _ range ▁) ▁{ ▁y ▁= ▁* ▁buf ▁++ ▁; ▁cr ▁= ▁* ▁buf ▁++ ▁; ▁cb ▁= ▁* ▁buf ▁++ ▁; ▁alpha ▁= ▁* ▁buf ▁++ ▁; ▁} ▁else ▁{ ▁y ▁= ▁buf ▁[ ▁0 ▁] ▁& ▁0 xfc ▁; ▁cr ▁= ▁( ▁( ▁( ▁buf ▁[ ▁0 ▁] ▁& ▁3 ▁) ▁<< ▁2 ▁) ▁| ▁( ▁( ▁buf ▁[ ▁1 ▁] ▁>> ▁6 ▁) ▁& ▁3 ▁) ▁) ▁<< ▁4 ▁; ▁cb ▁= ▁( ▁buf ▁[ ▁1 ▁] ▁<< ▁2 ▁) ▁& ▁0 xf 0 ▁; ▁alpha ▁= ▁( ▁buf ▁[ ▁1 ▁] ▁<< ▁6 ▁) ▁& ▁0 xc 0 ▁; ▁buf ▁+= ▁2 ▁; ▁} ▁if ▁( ▁y ▁== ▁0 ▁) ▁alpha ▁= ▁0 xff ▁; ▁Y UV _ TO _ RGB 1_ CC IR ▁( ▁cb ▁, ▁cr ▁) ▁; ▁Y UV _ TO _ RGB 2_ CC IR ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁y ▁) ▁; ▁av _ d log ▁( ▁avctx ▁, ▁" cl ut % d : = (% d ,% d ,% d ,% d )\ n " ▁, ▁entry _ id ▁, ▁r ▁, ▁g ▁, ▁b ▁, ▁alpha ▁) ▁; ▁if ▁( ▁depth ▁& ▁0 x 80 ▁) ▁cl ut ▁-> ▁cl ut 4 ▁[ ▁entry _ id ▁] ▁= ▁RGBA ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁255 ▁- ▁alpha ▁) ▁; ▁if ▁( ▁depth ▁& ▁0 x 40 ▁) ▁cl ut ▁-> ▁cl ut 16 ▁[ ▁entry _ id ▁] ▁= ▁RGBA ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁255 ▁- ▁alpha ▁) ▁; ▁if ▁( ▁depth ▁& ▁0 x 20 ▁) ▁cl ut ▁-> ▁cl ut 256 ▁[ ▁entry _ id ▁] ▁= ▁RGBA ▁( ▁r ▁, ▁g ▁, ▁b ▁, ▁255 ▁- ▁alpha ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁predictor _ decompress _ fir _ adapt ▁( ▁int 32_ t ▁* ▁error _ buffer ▁, ▁int 32_ t ▁* ▁buffer _ out ▁, ▁int ▁output _ size ▁, ▁int ▁read sample size ▁, ▁int 16_ t ▁* ▁predictor _ coef _ table ▁, ▁int ▁predictor _ coef _ num ▁, ▁int ▁predictor _ quant it ization ▁) ▁{ ▁int ▁i ▁; ▁* ▁buffer _ out ▁= ▁* ▁error _ buffer ▁; ▁if ▁( ▁! ▁predictor _ coef _ num ▁) ▁{ ▁if ▁( ▁output _ size ▁<= ▁1 ▁) ▁return ▁; ▁memcpy ▁( ▁buffer _ out ▁+ ▁1 ▁, ▁error _ buffer ▁+ ▁1 ▁, ▁( ▁output _ size ▁- ▁1 ▁) ▁* ▁4 ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁predictor _ coef _ num ▁== ▁0 x 1 f ▁) ▁{ ▁if ▁( ▁output _ size ▁<= ▁1 ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁output _ size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁prev _ value ▁; ▁int 32_ t ▁error _ value ▁; ▁prev _ value ▁= ▁buffer _ out ▁[ ▁i ▁] ▁; ▁error _ value ▁= ▁error _ buffer ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁buffer _ out ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁sign _ extend ▁( ▁( ▁prev _ value ▁+ ▁error _ value ▁) ▁, ▁read sample size ▁) ▁; ▁} ▁return ▁; ▁} ▁if ▁( ▁predictor _ coef _ num ▁> ▁0 ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁predictor _ coef _ num ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁val ▁; ▁val ▁= ▁buffer _ out ▁[ ▁i ▁] ▁+ ▁error _ buffer ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁val ▁= ▁sign _ extend ▁( ▁val ▁, ▁read sample size ▁) ▁; ▁buffer _ out ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁val ▁; ▁} ▁# if ▁0 ▁if ▁( ▁predictor _ coef _ num ▁== ▁4 ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁predictor _ coef _ table ▁== ▁8 ▁) ▁{ ▁return ▁; ▁} ▁# endif ▁if ▁( ▁predictor _ coef _ num ▁> ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁predictor _ coef _ num ▁+ ▁1 ▁; ▁i ▁< ▁output _ size ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁int ▁sum ▁= ▁0 ▁; ▁int ▁out val ▁; ▁int ▁error _ val ▁= ▁error _ buffer ▁[ ▁i ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁predictor _ coef _ num ▁; ▁j ▁++ ▁) ▁{ ▁sum ▁+= ▁( ▁buffer _ out ▁[ ▁predictor _ coef _ num ▁- ▁j ▁] ▁- ▁buffer _ out ▁[ ▁0 ▁] ▁) ▁* ▁predictor _ coef _ table ▁[ ▁j ▁] ▁; ▁} ▁out val ▁= ▁( ▁1 ▁<< ▁( ▁predictor _ quant it ization ▁- ▁1 ▁) ▁) ▁+ ▁sum ▁; ▁out val ▁= ▁out val ▁>> ▁predictor _ quant it ization ▁; ▁out val ▁= ▁out val ▁+ ▁buffer _ out ▁[ ▁0 ▁] ▁+ ▁error _ val ▁; ▁out val ▁= ▁sign _ extend ▁( ▁out val ▁, ▁read sample size ▁) ▁; ▁buffer _ out ▁[ ▁predictor _ coef _ num ▁+ ▁1 ▁] ▁= ▁out val ▁; ▁if ▁( ▁error _ val ▁> ▁0 ▁) ▁{ ▁int ▁predictor _ num ▁= ▁predictor _ coef _ num ▁- ▁1 ▁; ▁while ▁( ▁predictor _ num ▁>= ▁0 ▁&& ▁error _ val ▁> ▁0 ▁) ▁{ ▁int ▁val ▁= ▁buffer _ out ▁[ ▁0 ▁] ▁- ▁buffer _ out ▁[ ▁predictor _ coef _ num ▁- ▁predictor _ num ▁] ▁; ▁int ▁sign ▁= ▁sign _ only ▁( ▁val ▁) ▁; ▁predictor _ coef _ table ▁[ ▁predictor _ num ▁] ▁-= ▁sign ▁; ▁val ▁*= ▁sign ▁; ▁error _ val ▁-= ▁( ▁( ▁val ▁>> ▁predictor _ quant it ization ▁) ▁* ▁( ▁predictor _ coef _ num ▁- ▁predictor _ num ▁) ▁) ▁; ▁predictor _ num ▁-- ▁; ▁} ▁} ▁else ▁if ▁( ▁error _ val ▁< ▁0 ▁) ▁{ ▁int ▁predictor _ num ▁= ▁predictor _ coef _ num ▁- ▁1 ▁; ▁while ▁( ▁predictor _ num ▁>= ▁0 ▁&& ▁error _ val ▁< ▁0 ▁) ▁{ ▁int ▁val ▁= ▁buffer _ out ▁[ ▁0 ▁] ▁- ▁buffer _ out ▁[ ▁predictor _ coef _ num ▁- ▁predictor _ num ▁] ▁; ▁int ▁sign ▁= ▁- ▁sign _ only ▁( ▁val ▁) ▁; ▁predictor _ coef _ table ▁[ ▁predictor _ num ▁] ▁-= ▁sign ▁; ▁val ▁*= ▁sign ▁; ▁error _ val ▁-= ▁( ▁( ▁val ▁>> ▁predictor _ quant it ization ▁) ▁* ▁( ▁predictor _ coef _ num ▁- ▁predictor _ num ▁) ▁) ▁; ▁predictor _ num ▁-- ▁; ▁} ▁} ▁buffer _ out ▁++ ▁; ▁} ▁} ▁}	1
▁static ▁int ▁k ek _ wrap _ key ▁( ▁unsigned ▁char ▁* ▁out ▁, ▁size _ t ▁* ▁outlen ▁, ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁size _ t ▁inlen ▁, ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁) ▁{ ▁size _ t ▁block len ▁= ▁EVP _ CIPHER _ CTX _ block _ size ▁( ▁ctx ▁) ▁; ▁size _ t ▁olen ▁; ▁int ▁dummy ▁; ▁olen ▁= ▁( ▁inlen ▁+ ▁4 ▁+ ▁block len ▁- ▁1 ▁) ▁/ ▁block len ▁; ▁olen ▁*= ▁block len ▁; ▁if ▁( ▁olen ▁< ▁2 ▁* ▁block len ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁inlen ▁> ▁0 xFF ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁out ▁) ▁{ ▁out ▁[ ▁0 ▁] ▁= ▁( ▁unsigned ▁char ▁) ▁inlen ▁; ▁out ▁[ ▁1 ▁] ▁= ▁in ▁[ ▁0 ▁] ▁ ^ ▁0 xFF ▁; ▁out ▁[ ▁2 ▁] ▁= ▁in ▁[ ▁1 ▁] ▁ ^ ▁0 xFF ▁; ▁out ▁[ ▁3 ▁] ▁= ▁in ▁[ ▁2 ▁] ▁ ^ ▁0 xFF ▁; ▁memcpy ▁( ▁out ▁+ ▁4 ▁, ▁in ▁, ▁inlen ▁) ▁; ▁if ▁( ▁olen ▁> ▁inlen ▁+ ▁4 ▁) ▁RAND _ pseudo _ bytes ▁( ▁out ▁+ ▁4 ▁+ ▁inlen ▁, ▁olen ▁- ▁4 ▁- ▁inlen ▁) ▁; ▁if ▁( ▁! ▁EVP _ Encrypt Update ▁( ▁ctx ▁, ▁out ▁, ▁& ▁dummy ▁, ▁out ▁, ▁olen ▁) ▁|| ▁! ▁EVP _ Encrypt Update ▁( ▁ctx ▁, ▁out ▁, ▁& ▁dummy ▁, ▁out ▁, ▁olen ▁) ▁) ▁return ▁0 ▁; ▁} ▁* ▁outlen ▁= ▁olen ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁O JPEG Read Header Info Sec Stream D ht ▁( ▁TIFF ▁* ▁tif ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" O JPEG Read Header Info Sec Stream D ht " ▁; ▁O JPEG State ▁* ▁sp ▁= ▁( ▁O JPEG State ▁* ▁) ▁tif ▁-> ▁tif _ data ▁; ▁uint 16 ▁m ▁; ▁uint 32 ▁na ▁; ▁uint 8 ▁* ▁nb ▁; ▁uint 8 ▁o ▁; ▁if ▁( ▁O JPEG Read Word ▁( ▁sp ▁, ▁& ▁m ▁) ▁== ▁0 ▁) ▁return ▁( ▁0 ▁) ▁; ▁if ▁( ▁m ▁<= ▁2 ▁) ▁{ ▁if ▁( ▁sp ▁-> ▁sub sampling correct ▁== ▁0 ▁) ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Cor rupt D HT marker in JPEG data " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁sp ▁-> ▁sub sampling correct ▁!= ▁0 ▁) ▁{ ▁O JPEG Read Skip ▁( ▁sp ▁, ▁m ▁- ▁2 ▁) ▁; ▁} ▁else ▁{ ▁na ▁= ▁sizeof ▁( ▁uint 32 ▁) ▁+ ▁2 ▁+ ▁m ▁; ▁nb ▁= ▁_ TIFF malloc ▁( ▁na ▁) ▁; ▁if ▁( ▁nb ▁== ▁0 ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Out of memory " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁* ▁( ▁uint 32 ▁* ▁) ▁nb ▁= ▁na ▁; ▁nb ▁[ ▁sizeof ▁( ▁uint 32 ▁) ▁] ▁= ▁255 ▁; ▁nb ▁[ ▁sizeof ▁( ▁uint 32 ▁) ▁+ ▁1 ▁] ▁= ▁JPEG _ MARKER _ D HT ▁; ▁nb ▁[ ▁sizeof ▁( ▁uint 32 ▁) ▁+ ▁2 ▁] ▁= ▁( ▁m ▁>> ▁8 ▁) ▁; ▁nb ▁[ ▁sizeof ▁( ▁uint 32 ▁) ▁+ ▁3 ▁] ▁= ▁( ▁m ▁& ▁255 ▁) ▁; ▁if ▁( ▁O JPEG Read Block ▁( ▁sp ▁, ▁m ▁- ▁2 ▁, ▁& ▁nb ▁[ ▁sizeof ▁( ▁uint 32 ▁) ▁+ ▁4 ▁] ▁) ▁== ▁0 ▁) ▁return ▁( ▁0 ▁) ▁; ▁o ▁= ▁nb ▁[ ▁sizeof ▁( ▁uint 32 ▁) ▁+ ▁4 ▁] ▁; ▁if ▁( ▁( ▁o ▁& ▁240 ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁3 ▁< ▁o ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Cor rupt D HT marker in JPEG data " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁sp ▁-> ▁dct able ▁[ ▁o ▁] ▁!= ▁0 ▁) ▁_ TIFF free ▁( ▁sp ▁-> ▁dct able ▁[ ▁o ▁] ▁) ▁; ▁sp ▁-> ▁dct able ▁[ ▁o ▁] ▁= ▁nb ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁o ▁& ▁240 ▁) ▁!= ▁16 ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Cor rupt D HT marker in JPEG data " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁o ▁&= ▁15 ▁; ▁if ▁( ▁3 ▁< ▁o ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Cor rupt D HT marker in JPEG data " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁sp ▁-> ▁act able ▁[ ▁o ▁] ▁!= ▁0 ▁) ▁_ TIFF free ▁( ▁sp ▁-> ▁act able ▁[ ▁o ▁] ▁) ▁; ▁sp ▁-> ▁act able ▁[ ▁o ▁] ▁= ▁nb ▁; ▁} ▁} ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁int ▁JPEG Encode Raw ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 8 ▁* ▁buf ▁, ▁tm size _ t ▁cc ▁, ▁uint 16 ▁s ▁) ▁{ ▁JPEG State ▁* ▁sp ▁= ▁J State ▁( ▁tif ▁) ▁; ▁J SAMPLE ▁* ▁inptr ▁; ▁J SAMPLE ▁* ▁outptr ▁; ▁tm size _ t ▁nrows ▁; ▁JDIMENSION ▁c lu mps _ per _ line ▁, ▁n clu mp ▁; ▁int ▁c lu mp offset ▁, ▁ci ▁, ▁xpos ▁, ▁ypos ▁; ▁jpeg _ component _ info ▁* ▁comp ptr ▁; ▁int ▁samples _ per _ clu mp ▁= ▁sp ▁-> ▁samples per clu mp ▁; ▁tm size _ t ▁bytes per clu mpl ine ▁; ▁( ▁void ▁) ▁s ▁; ▁assert ▁( ▁sp ▁!= ▁NULL ▁) ▁; ▁bytes per clu mpl ine ▁= ▁( ▁( ▁( ▁( ▁tm size _ t ▁) ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁image _ width ▁+ ▁sp ▁-> ▁h _ sampling ▁- ▁1 ▁) ▁/ ▁sp ▁-> ▁h _ sampling ▁) ▁* ▁( ▁sp ▁-> ▁h _ sampling ▁* ▁sp ▁-> ▁v _ sampling ▁+ ▁2 ▁) ▁* ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁data _ precision ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁nrows ▁= ▁( ▁cc ▁/ ▁bytes per clu mpl ine ▁) ▁* ▁sp ▁-> ▁v _ sampling ▁; ▁if ▁( ▁cc ▁% ▁bytes per clu mpl ine ▁) ▁TIFF Warning Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁tif ▁-> ▁tif _ name ▁, ▁" fraction al scan lined isc arded " ▁) ▁; ▁c lu mps _ per _ line ▁= ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁comp _ info ▁[ ▁1 ▁] ▁. ▁down sample d _ width ▁; ▁while ▁( ▁nrows ▁> ▁0 ▁) ▁{ ▁c lu mp offset ▁= ▁0 ▁; ▁for ▁( ▁ci ▁= ▁0 ▁, ▁comp ptr ▁= ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁comp _ info ▁; ▁ci ▁< ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁num _ components ▁; ▁ci ▁++ ▁, ▁comp ptr ▁++ ▁) ▁{ ▁int ▁hs amp ▁= ▁comp ptr ▁-> ▁h _ s amp _ factor ▁; ▁int ▁vs amp ▁= ▁comp ptr ▁-> ▁v _ s amp _ factor ▁; ▁int ▁padding ▁= ▁( ▁int ▁) ▁( ▁comp ptr ▁-> ▁width _ in _ blocks ▁* ▁DCTSIZE ▁- ▁c lu mps _ per _ line ▁* ▁hs amp ▁) ▁; ▁for ▁( ▁ypos ▁= ▁0 ▁; ▁ypos ▁< ▁vs amp ▁; ▁ypos ▁++ ▁) ▁{ ▁inptr ▁= ▁( ▁( ▁J SAMPLE ▁* ▁) ▁buf ▁) ▁+ ▁c lu mp offset ▁; ▁outptr ▁= ▁sp ▁-> ▁ds _ buffer ▁[ ▁ci ▁] ▁[ ▁sp ▁-> ▁scan count ▁* ▁vs amp ▁+ ▁ypos ▁] ▁; ▁if ▁( ▁hs amp ▁== ▁1 ▁) ▁{ ▁for ▁( ▁n clu mp ▁= ▁c lu mps _ per _ line ▁; ▁n clu mp ▁-- ▁> ▁0 ▁; ▁) ▁{ ▁* ▁outptr ▁++ ▁= ▁inptr ▁[ ▁0 ▁] ▁; ▁inptr ▁+= ▁samples _ per _ clu mp ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁n clu mp ▁= ▁c lu mps _ per _ line ▁; ▁n clu mp ▁-- ▁> ▁0 ▁; ▁) ▁{ ▁for ▁( ▁xpos ▁= ▁0 ▁; ▁xpos ▁< ▁hs amp ▁; ▁xpos ▁++ ▁) ▁* ▁outptr ▁++ ▁= ▁inptr ▁[ ▁xpos ▁] ▁; ▁inptr ▁+= ▁samples _ per _ clu mp ▁; ▁} ▁} ▁for ▁( ▁xpos ▁= ▁0 ▁; ▁xpos ▁< ▁padding ▁; ▁xpos ▁++ ▁) ▁{ ▁* ▁outptr ▁= ▁outptr ▁[ ▁-1 ▁] ▁; ▁outptr ▁++ ▁; ▁} ▁c lu mp offset ▁+= ▁hs amp ▁; ▁} ▁} ▁sp ▁-> ▁scan count ▁++ ▁; ▁if ▁( ▁sp ▁-> ▁scan count ▁>= ▁DCTSIZE ▁) ▁{ ▁int ▁n ▁= ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁max _ v _ s amp _ factor ▁* ▁DCTSIZE ▁; ▁if ▁( ▁TIFF jpeg _ write _ raw _ data ▁( ▁sp ▁, ▁sp ▁-> ▁ds _ buffer ▁, ▁n ▁) ▁!= ▁n ▁) ▁return ▁( ▁0 ▁) ▁; ▁sp ▁-> ▁scan count ▁= ▁0 ▁; ▁} ▁tif ▁-> ▁tif _ row ▁+= ▁sp ▁-> ▁v _ sampling ▁; ▁buf ▁+= ▁bytes per clu mpl ine ▁; ▁nrows ▁-= ▁sp ▁-> ▁v _ sampling ▁; ▁} ▁return ▁( ▁1 ▁) ▁; ▁}	0
▁static ▁void ▁restore _ med ian _ il ▁( ▁uint 8_ t ▁* ▁src ▁, ▁int ▁step ▁, ▁int ▁stride ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁slices ▁, ▁int ▁r mode ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁slice ▁; ▁int ▁A ▁, ▁B ▁, ▁C ▁; ▁uint 8_ t ▁* ▁b src ▁; ▁int ▁slice _ start ▁, ▁slice _ height ▁; ▁const ▁int ▁c mask ▁= ▁ ~ ▁( ▁r mode ▁? ▁3 ▁: ▁1 ▁) ▁; ▁const ▁int ▁stride 2 ▁= ▁stride ▁<< ▁1 ▁; ▁for ▁( ▁slice ▁= ▁0 ▁; ▁slice ▁< ▁slices ▁; ▁slice ▁++ ▁) ▁{ ▁slice _ start ▁= ▁( ▁( ▁slice ▁* ▁height ▁) ▁/ ▁slices ▁) ▁& ▁c mask ▁; ▁slice _ height ▁= ▁( ▁( ▁( ▁( ▁slice ▁+ ▁1 ▁) ▁* ▁height ▁) ▁/ ▁slices ▁) ▁& ▁c mask ▁) ▁- ▁slice _ start ▁; ▁slice _ height ▁>>= ▁1 ▁; ▁if ▁( ▁! ▁slice _ height ▁) ▁continue ▁; ▁b src ▁= ▁src ▁+ ▁slice _ start ▁* ▁stride ▁; ▁b src ▁[ ▁0 ▁] ▁+= ▁0 x 80 ▁; ▁A ▁= ▁b src ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁step ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁b src ▁[ ▁i ▁] ▁+= ▁A ▁; ▁A ▁= ▁b src ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁b src ▁[ ▁stride ▁+ ▁i ▁] ▁+= ▁A ▁; ▁A ▁= ▁b src ▁[ ▁stride ▁+ ▁i ▁] ▁; ▁} ▁b src ▁+= ▁stride 2 ▁; ▁if ▁( ▁slice _ height ▁== ▁1 ▁) ▁continue ▁; ▁C ▁= ▁b src ▁[ ▁- ▁stride 2 ▁] ▁; ▁b src ▁[ ▁0 ▁] ▁+= ▁C ▁; ▁A ▁= ▁b src ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁step ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁B ▁= ▁b src ▁[ ▁i ▁- ▁stride 2 ▁] ▁; ▁b src ▁[ ▁i ▁] ▁+= ▁mid _ pred ▁( ▁A ▁, ▁B ▁, ▁( ▁uint 8_ t ▁) ▁( ▁A ▁+ ▁B ▁- ▁C ▁) ▁) ▁; ▁C ▁= ▁B ▁; ▁A ▁= ▁b src ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁B ▁= ▁b src ▁[ ▁i ▁- ▁stride ▁] ▁; ▁b src ▁[ ▁stride ▁+ ▁i ▁] ▁+= ▁mid _ pred ▁( ▁A ▁, ▁B ▁, ▁( ▁uint 8_ t ▁) ▁( ▁A ▁+ ▁B ▁- ▁C ▁) ▁) ▁; ▁C ▁= ▁B ▁; ▁A ▁= ▁b src ▁[ ▁stride ▁+ ▁i ▁] ▁; ▁} ▁b src ▁+= ▁stride 2 ▁; ▁for ▁( ▁j ▁= ▁2 ▁; ▁j ▁< ▁slice _ height ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁B ▁= ▁b src ▁[ ▁i ▁- ▁stride 2 ▁] ▁; ▁b src ▁[ ▁i ▁] ▁+= ▁mid _ pred ▁( ▁A ▁, ▁B ▁, ▁( ▁uint 8_ t ▁) ▁( ▁A ▁+ ▁B ▁- ▁C ▁) ▁) ▁; ▁C ▁= ▁B ▁; ▁A ▁= ▁b src ▁[ ▁i ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁B ▁= ▁b src ▁[ ▁i ▁- ▁stride ▁] ▁; ▁b src ▁[ ▁i ▁+ ▁stride ▁] ▁+= ▁mid _ pred ▁( ▁A ▁, ▁B ▁, ▁( ▁uint 8_ t ▁) ▁( ▁A ▁+ ▁B ▁- ▁C ▁) ▁) ▁; ▁C ▁= ▁B ▁; ▁A ▁= ▁b src ▁[ ▁i ▁+ ▁stride ▁] ▁; ▁} ▁b src ▁+= ▁stride 2 ▁; ▁} ▁} ▁}	0
▁static ▁void ▁vp 3_ h _ loop _ filter _ c ▁( ▁uint 8_ t ▁* ▁first _ pixel ▁, ▁int ▁stride ▁, ▁int ▁* ▁bounding _ values ▁) ▁{ ▁unsigned ▁char ▁* ▁end ▁; ▁int ▁filter _ value ▁; ▁for ▁( ▁end ▁= ▁first _ pixel ▁+ ▁8 ▁* ▁stride ▁; ▁first _ pixel ▁!= ▁end ▁; ▁first _ pixel ▁+= ▁stride ▁) ▁{ ▁filter _ value ▁= ▁( ▁first _ pixel ▁[ ▁-2 ▁] ▁- ▁first _ pixel ▁[ ▁1 ▁] ▁) ▁+ ▁3 ▁* ▁( ▁first _ pixel ▁[ ▁0 ▁] ▁- ▁first _ pixel ▁[ ▁-1 ▁] ▁) ▁; ▁filter _ value ▁= ▁bounding _ values ▁[ ▁( ▁filter _ value ▁+ ▁4 ▁) ▁>> ▁3 ▁] ▁; ▁first _ pixel ▁[ ▁-1 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁first _ pixel ▁[ ▁-1 ▁] ▁+ ▁filter _ value ▁) ▁; ▁first _ pixel ▁[ ▁0 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁first _ pixel ▁[ ▁0 ▁] ▁- ▁filter _ value ▁) ▁; ▁} ▁}	0
▁size _ t ▁BUF _ MEM _ grow ▁( ▁BUF _ MEM ▁* ▁str ▁, ▁size _ t ▁len ▁) ▁{ ▁char ▁* ▁ret ▁; ▁size _ t ▁n ▁; ▁if ▁( ▁str ▁-> ▁length ▁>= ▁len ▁) ▁{ ▁str ▁-> ▁length ▁= ▁len ▁; ▁return ▁( ▁len ▁) ▁; ▁} ▁if ▁( ▁str ▁-> ▁max ▁>= ▁len ▁) ▁{ ▁if ▁( ▁str ▁-> ▁data ▁!= ▁NULL ▁) ▁memset ▁( ▁& ▁str ▁-> ▁data ▁[ ▁str ▁-> ▁length ▁] ▁, ▁0 ▁, ▁len ▁- ▁str ▁-> ▁length ▁) ▁; ▁str ▁-> ▁length ▁= ▁len ▁; ▁return ▁( ▁len ▁) ▁; ▁} ▁if ▁( ▁len ▁> ▁LIMIT _ BEFORE _ EXP AN SION ▁) ▁{ ▁BUF err ▁( ▁BUF _ F _ BUF _ MEM _ G ROW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁n ▁= ▁( ▁len ▁+ ▁3 ▁) ▁/ ▁3 ▁* ▁4 ▁; ▁if ▁( ▁( ▁str ▁-> ▁flags ▁& ▁BUF _ MEM _ FLAG _ SECURE ▁) ▁) ▁ret ▁= ▁sec _ alloc _ realloc ▁( ▁str ▁, ▁n ▁) ▁; ▁else ▁ret ▁= ▁OPENSSL _ realloc ▁( ▁str ▁-> ▁data ▁, ▁n ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁BUF err ▁( ▁BUF _ F _ BUF _ MEM _ G ROW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁len ▁= ▁0 ▁; ▁} ▁else ▁{ ▁str ▁-> ▁data ▁= ▁ret ▁; ▁str ▁-> ▁max ▁= ▁n ▁; ▁memset ▁( ▁& ▁str ▁-> ▁data ▁[ ▁str ▁-> ▁length ▁] ▁, ▁0 ▁, ▁len ▁- ▁str ▁-> ▁length ▁) ▁; ▁str ▁-> ▁length ▁= ▁len ▁; ▁} ▁return ▁( ▁len ▁) ▁; ▁}	1
▁static ▁int ▁rtsp _ write _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁RT SP State ▁* ▁rt ▁= ▁s ▁-> ▁priv _ data ▁; ▁RT SP Stream ▁* ▁rtsp _ st ▁; ▁fd _ set ▁rf ds ▁; ▁int ▁n ▁, ▁tcp _ fd ▁; ▁struct ▁timeval ▁tv ▁; ▁AVFormatContext ▁* ▁rtp ctx ▁; ▁int ▁ret ▁; ▁tcp _ fd ▁= ▁url _ get _ file _ handle ▁( ▁rt ▁-> ▁rtsp _ hd ▁) ▁; ▁while ▁( ▁1 ▁) ▁{ ▁FD _ ZERO ▁( ▁& ▁rf ds ▁) ▁; ▁FD _ SET ▁( ▁tcp _ fd ▁, ▁& ▁rf ds ▁) ▁; ▁tv ▁. ▁tv _ sec ▁= ▁0 ▁; ▁tv ▁. ▁tv _ usec ▁= ▁0 ▁; ▁n ▁= ▁select ▁( ▁tcp _ fd ▁+ ▁1 ▁, ▁& ▁rf ds ▁, ▁NULL ▁, ▁NULL ▁, ▁& ▁tv ▁) ▁; ▁if ▁( ▁n ▁<= ▁0 ▁) ▁break ▁; ▁if ▁( ▁FD _ ISSET ▁( ▁tcp _ fd ▁, ▁& ▁rf ds ▁) ▁) ▁{ ▁RT SP Message Header ▁reply ▁; ▁ret ▁= ▁ff _ rt sp _ read _ reply ▁( ▁s ▁, ▁& ▁reply ▁, ▁NULL ▁, ▁1 ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁E PIPE ▁) ▁; ▁if ▁( ▁ret ▁== ▁1 ▁) ▁ff _ rt sp _ skip _ packet ▁( ▁s ▁) ▁; ▁if ▁( ▁rt ▁-> ▁state ▁!= ▁RT SP _ STATE _ STREAM ING ▁) ▁return ▁AVERROR ▁( ▁E PIPE ▁) ▁; ▁} ▁} ▁if ▁( ▁pkt ▁-> ▁stream _ index ▁< ▁0 ▁|| ▁pkt ▁-> ▁stream _ index ▁>= ▁rt ▁-> ▁nb _ rt sp _ streams ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁rtsp _ st ▁= ▁rt ▁-> ▁rtsp _ streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁; ▁rtp ctx ▁= ▁rtsp _ st ▁-> ▁transport _ priv ▁; ▁ret ▁= ▁ff _ write _ chained ▁( ▁rtp ctx ▁, ▁0 ▁, ▁pkt ▁, ▁s ▁) ▁; ▁if ▁( ▁! ▁ret ▁&& ▁rt ▁-> ▁lower _ transport ▁== ▁RT SP _ LOWER _ TRANSPORT _ TCP ▁) ▁ret ▁= ▁tcp _ write _ packet ▁( ▁s ▁, ▁rtsp _ st ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁inline ▁void ▁rv 40_ weak _ loop _ filter ▁( ▁uint 8_ t ▁* ▁src ▁, ▁const ▁int ▁step ▁, ▁const ▁int ▁filter _ p 1 ▁, ▁const ▁int ▁filter _ q 1 ▁, ▁const ▁int ▁alpha ▁, ▁const ▁int ▁beta ▁, ▁const ▁int ▁lim _ p 0 q 0 ▁, ▁const ▁int ▁lim _ q 1 ▁, ▁const ▁int ▁lim _ p 1 ▁, ▁const ▁int ▁diff _ p 1 p 0 ▁, ▁const ▁int ▁diff _ q 1 q 0 ▁, ▁const ▁int ▁diff _ p 1 p 2 ▁, ▁const ▁int ▁diff _ q 1 q 2 ▁) ▁{ ▁uint 8_ t ▁* ▁cm ▁= ▁ff _ crop Tbl ▁+ ▁MAX _ NEG _ CR OP ▁; ▁int ▁t ▁, ▁u ▁, ▁diff ▁; ▁t ▁= ▁src ▁[ ▁0 ▁* ▁step ▁] ▁- ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁; ▁if ▁( ▁! ▁t ▁) ▁return ▁; ▁u ▁= ▁( ▁alpha ▁* ▁FF ABS ▁( ▁t ▁) ▁) ▁>> ▁7 ▁; ▁if ▁( ▁u ▁> ▁3 ▁- ▁( ▁filter _ p 1 ▁&& ▁filter _ q 1 ▁) ▁) ▁return ▁; ▁t ▁<<= ▁2 ▁; ▁if ▁( ▁filter _ p 1 ▁&& ▁filter _ q 1 ▁) ▁t ▁+= ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁- ▁src ▁[ ▁1 ▁* ▁step ▁] ▁; ▁diff ▁= ▁CLIP _ SY MM ▁( ▁( ▁t ▁+ ▁4 ▁) ▁>> ▁3 ▁, ▁lim _ p 0 q 0 ▁) ▁; ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁= ▁cm ▁[ ▁src ▁[ ▁-1 ▁* ▁step ▁] ▁+ ▁diff ▁] ▁; ▁src ▁[ ▁0 ▁* ▁step ▁] ▁= ▁cm ▁[ ▁src ▁[ ▁0 ▁* ▁step ▁] ▁- ▁diff ▁] ▁; ▁if ▁( ▁FF ABS ▁( ▁diff _ p 1 p 2 ▁) ▁<= ▁beta ▁&& ▁filter _ p 1 ▁) ▁{ ▁t ▁= ▁( ▁diff _ p 1 p 0 ▁+ ▁diff _ p 1 p 2 ▁- ▁diff ▁) ▁>> ▁1 ▁; ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁= ▁cm ▁[ ▁src ▁[ ▁-2 ▁* ▁step ▁] ▁- ▁CLIP _ SY MM ▁( ▁t ▁, ▁lim _ p 1 ▁) ▁] ▁; ▁} ▁if ▁( ▁FF ABS ▁( ▁diff _ q 1 q 2 ▁) ▁<= ▁beta ▁&& ▁filter _ q 1 ▁) ▁{ ▁t ▁= ▁( ▁diff _ q 1 q 0 ▁+ ▁diff _ q 1 q 2 ▁+ ▁diff ▁) ▁>> ▁1 ▁; ▁src ▁[ ▁1 ▁* ▁step ▁] ▁= ▁cm ▁[ ▁src ▁[ ▁1 ▁* ▁step ▁] ▁- ▁CLIP _ SY MM ▁( ▁t ▁, ▁lim _ q 1 ▁) ▁] ▁; ▁} ▁}	1
▁static ▁av _ always _ inline ▁int ▁vp 7 8_ decode _ mb _ row _ slic ed ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁t data ▁, ▁int ▁job nr ▁, ▁int ▁thread nr ▁, ▁int ▁is _ vp 7 ▁) ▁{ ▁VP 8 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁VP 8 Thread Data ▁* ▁td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁job nr ▁] ▁; ▁VP 8 Thread Data ▁* ▁next _ td ▁= ▁NULL ▁, ▁* ▁prev _ td ▁= ▁NULL ▁; ▁VP 8 Frame ▁* ▁cur frame ▁= ▁s ▁-> ▁cur frame ▁; ▁int ▁mb _ y ▁, ▁num _ jobs ▁= ▁s ▁-> ▁num _ jobs ▁; ▁td ▁-> ▁thread _ nr ▁= ▁thread nr ▁; ▁for ▁( ▁mb _ y ▁= ▁job nr ▁; ▁mb _ y ▁< ▁s ▁-> ▁mb _ height ▁; ▁mb _ y ▁+= ▁num _ jobs ▁) ▁{ ▁if ▁( ▁mb _ y ▁>= ▁s ▁-> ▁mb _ height ▁) ▁break ▁; ▁td ▁-> ▁thread _ mb _ pos ▁= ▁mb _ y ▁<< ▁16 ▁; ▁vp 8_ decode _ mb _ row _ no _ filter ▁( ▁avctx ▁, ▁t data ▁, ▁job nr ▁, ▁thread nr ▁, ▁is _ vp 7 ▁) ▁; ▁if ▁( ▁s ▁-> ▁de block _ filter ▁) ▁vp 8_ filter _ mb _ row ▁( ▁avctx ▁, ▁t data ▁, ▁job nr ▁, ▁thread nr ▁, ▁is _ vp 7 ▁) ▁; ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁INT _ MAX ▁& ▁0 xFFFF ▁) ▁; ▁s ▁-> ▁mv _ min ▁. ▁y ▁-= ▁64 ▁; ▁s ▁-> ▁mv _ max ▁. ▁y ▁-= ▁64 ▁; ▁if ▁( ▁avctx ▁-> ▁active _ thread _ type ▁== ▁FF _ THREAD _ FRAME ▁) ▁ff _ thread _ report _ progress ▁( ▁& ▁cur frame ▁-> ▁tf ▁, ▁mb _ y ▁, ▁0 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁avfilter _ graph _ create _ filter ▁( ▁AVFilter Context ▁* ▁* ▁filt _ ctx ▁, ▁AVFilter ▁* ▁filt ▁, ▁const ▁char ▁* ▁name ▁, ▁const ▁char ▁* ▁args ▁, ▁void ▁* ▁opaque ▁, ▁AVFilter Graph ▁* ▁graph _ ctx ▁) ▁{ ▁int ▁ret ▁; ▁* ▁filt _ ctx ▁= ▁avfilter _ graph _ alloc _ filter ▁( ▁graph _ ctx ▁, ▁filt ▁, ▁name ▁) ▁; ▁if ▁( ▁! ▁* ▁filt _ ctx ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁ret ▁= ▁avfilter _ init _ str ▁( ▁* ▁filt _ ctx ▁, ▁args ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁return ▁0 ▁; ▁fail ▁: ▁if ▁( ▁* ▁filt _ ctx ▁) ▁avfilter _ free ▁( ▁* ▁filt _ ctx ▁) ▁; ▁* ▁filt _ ctx ▁= ▁NULL ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁av _ get _ pad ded _ bits _ per _ pixel ▁( ▁const ▁AV Pix Fmt Descriptor ▁* ▁pix desc ▁) ▁{ ▁int ▁c ▁, ▁bits ▁= ▁0 ▁; ▁int ▁log 2_ pixels ▁= ▁pix desc ▁-> ▁log 2_ chroma _ w ▁+ ▁pix desc ▁-> ▁log 2_ chroma _ h ▁; ▁int ▁steps ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁for ▁( ▁c ▁= ▁0 ▁; ▁c ▁< ▁pix desc ▁-> ▁nb _ components ▁; ▁c ▁++ ▁) ▁{ ▁const ▁AV Component Descriptor ▁* ▁comp ▁= ▁& ▁pix desc ▁-> ▁comp ▁[ ▁c ▁] ▁; ▁int ▁s ▁= ▁c ▁== ▁1 ▁|| ▁c ▁== ▁2 ▁? ▁0 ▁: ▁log 2_ pixels ▁; ▁steps ▁[ ▁comp ▁-> ▁plane ▁] ▁= ▁( ▁comp ▁-> ▁step _ minus 1 ▁+ ▁1 ▁) ▁<< ▁s ▁; ▁} ▁for ▁( ▁c ▁= ▁0 ▁; ▁c ▁< ▁4 ▁; ▁c ▁++ ▁) ▁bits ▁+= ▁steps ▁[ ▁c ▁] ▁; ▁if ▁( ▁! ▁( ▁pix desc ▁-> ▁flags ▁& ▁PIX _ FMT _ BIT STREAM ▁) ▁) ▁bits ▁*= ▁8 ▁; ▁return ▁bits ▁>> ▁log 2_ pixels ▁; ▁}	1
▁static ▁int ▁get _ bits ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁int ▁n ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁while ▁( ▁-- ▁n ▁>= ▁0 ▁) ▁{ ▁res ▁<<= ▁1 ▁; ▁if ▁( ▁s ▁-> ▁bit _ index ▁== ▁0 ▁) ▁{ ▁s ▁-> ▁bit _ index ▁= ▁7 ▁+ ▁( ▁bytestream 2_ get _ byte ▁( ▁& ▁s ▁-> ▁g ▁) ▁!= ▁0 xFF u ▁) ▁; ▁} ▁s ▁-> ▁bit _ index ▁-- ▁; ▁res ▁|= ▁( ▁bytestream 2_ peek _ byte ▁( ▁& ▁s ▁-> ▁g ▁) ▁>> ▁s ▁-> ▁bit _ index ▁) ▁& ▁1 ▁; ▁} ▁return ▁res ▁; ▁}	1
▁BIGNUM ▁* ▁bn _ expand 2 ▁( ▁BIGNUM ▁* ▁b ▁, ▁int ▁words ▁) ▁{ ▁if ▁( ▁words ▁> ▁b ▁-> ▁dmax ▁) ▁{ ▁BN _ ULONG ▁* ▁a ▁= ▁bn _ expand _ internal ▁( ▁b ▁, ▁words ▁) ▁; ▁if ▁( ▁! ▁a ▁) ▁return ▁NULL ▁; ▁if ▁( ▁b ▁-> ▁d ▁) ▁{ ▁OPENSSL _ cleanse ▁( ▁b ▁-> ▁d ▁, ▁b ▁-> ▁dmax ▁* ▁sizeof ▁( ▁b ▁-> ▁d ▁[ ▁0 ▁] ▁) ▁) ▁; ▁bn _ free _ d ▁( ▁b ▁) ▁; ▁} ▁b ▁-> ▁d ▁= ▁a ▁; ▁b ▁-> ▁dmax ▁= ▁words ▁; ▁} ▁return ▁b ▁; ▁}	1
▁int ▁BN _ M ONT _ CTX _ set ▁( ▁BN _ M ONT _ CTX ▁* ▁m ont ▁, ▁const ▁BIGNUM ▁* ▁mod ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁BIGNUM ▁* ▁R i ▁, ▁* ▁R ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁if ▁( ▁( ▁R i ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁R ▁= ▁& ▁( ▁m ont ▁-> ▁RR ▁) ▁; ▁BN _ copy ▁( ▁& ▁( ▁m ont ▁-> ▁N ▁) ▁, ▁mod ▁) ▁; ▁m ont ▁-> ▁N ▁. ▁neg ▁= ▁0 ▁; ▁# ifdef ▁M ONT _ WORD ▁{ ▁BIGNUM ▁tm od ▁; ▁BN _ ULONG ▁buf ▁[ ▁2 ▁] ▁; ▁m ont ▁-> ▁ri ▁= ▁( ▁BN _ num _ bits ▁( ▁mod ▁) ▁+ ▁( ▁BN _ BITS 2 ▁- ▁1 ▁) ▁) ▁/ ▁BN _ BITS 2 ▁* ▁BN _ BITS 2 ▁; ▁BN _ zero ▁( ▁R ▁) ▁; ▁if ▁( ▁! ▁( ▁BN _ set _ bit ▁( ▁R ▁, ▁BN _ BITS 2 ▁) ▁) ▁) ▁goto ▁err ▁; ▁buf ▁[ ▁0 ▁] ▁= ▁mod ▁-> ▁d ▁[ ▁0 ▁] ▁; ▁buf ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁tm od ▁. ▁d ▁= ▁buf ▁; ▁tm od ▁. ▁top ▁= ▁1 ▁; ▁tm od ▁. ▁dmax ▁= ▁2 ▁; ▁tm od ▁. ▁neg ▁= ▁0 ▁; ▁if ▁( ▁( ▁BN _ mod _ inverse ▁( ▁R i ▁, ▁R ▁, ▁& ▁tm od ▁, ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ lshift ▁( ▁R i ▁, ▁R i ▁, ▁BN _ BITS 2 ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ is _ zero ▁( ▁R i ▁) ▁) ▁{ ▁if ▁( ▁! ▁BN _ sub _ word ▁( ▁R i ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁BN _ set _ word ▁( ▁R i ▁, ▁BN _ MASK 2 ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ div ▁( ▁R i ▁, ▁NULL ▁, ▁R i ▁, ▁& ▁tm od ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁m ont ▁-> ▁n 0 ▁= ▁( ▁R i ▁-> ▁top ▁> ▁0 ▁) ▁? ▁R i ▁-> ▁d ▁[ ▁0 ▁] ▁: ▁0 ▁; ▁} ▁# else ▁{ ▁m ont ▁-> ▁ri ▁= ▁BN _ num _ bits ▁( ▁& ▁m ont ▁-> ▁N ▁) ▁; ▁BN _ zero ▁( ▁R ▁) ▁; ▁if ▁( ▁! ▁BN _ set _ bit ▁( ▁R ▁, ▁m ont ▁-> ▁ri ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁BN _ mod _ inverse ▁( ▁R i ▁, ▁R ▁, ▁& ▁m ont ▁-> ▁N ▁, ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ lshift ▁( ▁R i ▁, ▁R i ▁, ▁m ont ▁-> ▁ri ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ sub _ word ▁( ▁R i ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ div ▁( ▁& ▁( ▁m ont ▁-> ▁Ni ▁) ▁, ▁NULL ▁, ▁R i ▁, ▁& ▁m ont ▁-> ▁N ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁# endif ▁BN _ zero ▁( ▁& ▁( ▁m ont ▁-> ▁RR ▁) ▁) ▁; ▁if ▁( ▁! ▁BN _ set _ bit ▁( ▁& ▁( ▁m ont ▁-> ▁RR ▁) ▁, ▁m ont ▁-> ▁ri ▁* ▁2 ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ mod ▁( ▁& ▁( ▁m ont ▁-> ▁RR ▁) ▁, ▁& ▁( ▁m ont ▁-> ▁RR ▁) ▁, ▁& ▁( ▁m ont ▁-> ▁N ▁) ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁get _ a iff _ header ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁size ▁, ▁unsigned ▁version ▁) ▁{ ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁AVCodec Parameters ▁* ▁par ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codecpar ▁; ▁AI FF Input Context ▁* ▁a iff ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁exp ▁; ▁uint 64_ t ▁val ▁; ▁int ▁sample _ rate ▁; ▁unsigned ▁int ▁num _ frames ▁; ▁if ▁( ▁size ▁& ▁1 ▁) ▁size ▁++ ▁; ▁par ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁par ▁-> ▁channels ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁num _ frames ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁par ▁-> ▁bits _ per _ coded _ sample ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁exp ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁- ▁16 383 ▁- ▁63 ▁; ▁val ▁= ▁avio _ rb 64 ▁( ▁pb ▁) ▁; ▁if ▁( ▁exp ▁< ▁- 63 ▁|| ▁exp ▁> ▁63 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" exp % dis out of range \ n " ▁, ▁exp ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁exp ▁>= ▁0 ▁) ▁sample _ rate ▁= ▁val ▁<< ▁exp ▁; ▁else ▁sample _ rate ▁= ▁( ▁val ▁+ ▁( ▁1 ULL ▁<< ▁( ▁- ▁exp ▁- ▁1 ▁) ▁) ▁) ▁>> ▁- ▁exp ▁; ▁par ▁-> ▁sample _ rate ▁= ▁sample _ rate ▁; ▁size ▁-= ▁18 ▁; ▁if ▁( ▁size ▁< ▁4 ▁) ▁{ ▁version ▁= ▁AI FF ▁; ▁} ▁else ▁if ▁( ▁version ▁== ▁AI FF _ C _ VERSION 1 ▁) ▁{ ▁par ▁-> ▁codec _ tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁par ▁-> ▁codec _ id ▁= ▁ff _ codec _ get _ id ▁( ▁ff _ codec _ a iff _ tags ▁, ▁par ▁-> ▁codec _ tag ▁) ▁; ▁if ▁( ▁par ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ NONE ▁) ▁{ ▁char ▁tag ▁[ ▁32 ▁] ▁; ▁av _ get _ codec _ tag _ string ▁( ▁tag ▁, ▁sizeof ▁( ▁tag ▁) ▁, ▁par ▁-> ▁codec _ tag ▁) ▁; ▁avpriv _ request _ sample ▁( ▁s ▁, ▁" unknown or unsupported code ct ag :% s " ▁, ▁tag ▁) ▁; ▁} ▁size ▁-= ▁4 ▁; ▁} ▁if ▁( ▁version ▁!= ▁AI FF _ C _ VERSION 1 ▁|| ▁par ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ PCM _ S 16 BE ▁) ▁{ ▁par ▁-> ▁codec _ id ▁= ▁a iff _ codec _ get _ id ▁( ▁par ▁-> ▁bits _ per _ coded _ sample ▁) ▁; ▁par ▁-> ▁bits _ per _ coded _ sample ▁= ▁av _ get _ bits _ per _ sample ▁( ▁par ▁-> ▁codec _ id ▁) ▁; ▁a iff ▁-> ▁block _ duration ▁= ▁1 ▁; ▁} ▁else ▁{ ▁switch ▁( ▁par ▁-> ▁codec _ id ▁) ▁{ ▁case ▁AV _ CODEC _ ID _ PCM _ F 32 BE ▁: ▁case ▁AV _ CODEC _ ID _ PCM _ F 64 BE ▁: ▁case ▁AV _ CODEC _ ID _ PCM _ S 16 LE ▁: ▁case ▁AV _ CODEC _ ID _ PCM _ AL AW ▁: ▁case ▁AV _ CODEC _ ID _ PCM _ MUL AW ▁: ▁a iff ▁-> ▁block _ duration ▁= ▁1 ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ AD PCM _ I MA _ QT ▁: ▁par ▁-> ▁block _ align ▁= ▁34 ▁* ▁par ▁-> ▁channels ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ M ACE 3 ▁: ▁par ▁-> ▁block _ align ▁= ▁2 ▁* ▁par ▁-> ▁channels ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ AD PCM _ G 726 LE ▁: ▁par ▁-> ▁bits _ per _ coded _ sample ▁= ▁5 ▁; ▁case ▁AV _ CODEC _ ID _ AD PCM _ I MA _ WS ▁: ▁case ▁AV _ CODEC _ ID _ AD PCM _ G 7 22 ▁: ▁case ▁AV _ CODEC _ ID _ M ACE 6 ▁: ▁case ▁AV _ CODEC _ ID _ SD X 2_ D PCM ▁: ▁par ▁-> ▁block _ align ▁= ▁1 ▁* ▁par ▁-> ▁channels ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ GSM ▁: ▁par ▁-> ▁block _ align ▁= ▁33 ▁; ▁break ▁; ▁default ▁: ▁a iff ▁-> ▁block _ duration ▁= ▁1 ▁; ▁break ▁; ▁} ▁if ▁( ▁par ▁-> ▁block _ align ▁> ▁0 ▁) ▁a iff ▁-> ▁block _ duration ▁= ▁av _ get _ audio _ frame _ duration 2 ▁( ▁par ▁, ▁par ▁-> ▁block _ align ▁) ▁; ▁} ▁if ▁( ▁! ▁par ▁-> ▁block _ align ▁) ▁par ▁-> ▁block _ align ▁= ▁( ▁av _ get _ bits _ per _ sample ▁( ▁par ▁-> ▁codec _ id ▁) ▁* ▁par ▁-> ▁channels ▁) ▁>> ▁3 ▁; ▁if ▁( ▁a iff ▁-> ▁block _ duration ▁) ▁{ ▁par ▁-> ▁bit _ rate ▁= ▁par ▁-> ▁sample _ rate ▁* ▁( ▁par ▁-> ▁block _ align ▁<< ▁3 ▁) ▁/ ▁a iff ▁-> ▁block _ duration ▁; ▁} ▁if ▁( ▁size ▁) ▁avio _ skip ▁( ▁pb ▁, ▁size ▁) ▁; ▁return ▁num _ frames ▁; ▁}	1
▁static ▁BIGNUM ▁* ▁sr p _ Calc _ xy ▁( ▁const ▁BIGNUM ▁* ▁x ▁, ▁const ▁BIGNUM ▁* ▁y ▁, ▁const ▁BIGNUM ▁* ▁N ▁) ▁{ ▁unsigned ▁char ▁digest ▁[ ▁SHA _ DIGEST _ LENGTH ▁] ▁; ▁unsigned ▁char ▁* ▁tmp ▁= ▁NULL ▁; ▁int ▁num N ▁= ▁BN _ num _ bytes ▁( ▁N ▁) ▁; ▁BIGNUM ▁* ▁res ▁= ▁NULL ▁; ▁if ▁( ▁x ▁!= ▁N ▁&& ▁BN _ ucmp ▁( ▁x ▁, ▁N ▁) ▁>= ▁0 ▁) ▁return ▁NULL ▁; ▁if ▁( ▁y ▁!= ▁N ▁&& ▁BN _ ucmp ▁( ▁y ▁, ▁N ▁) ▁>= ▁0 ▁) ▁return ▁NULL ▁; ▁if ▁( ▁( ▁tmp ▁= ▁OPENSSL _ malloc ▁( ▁num N ▁* ▁2 ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ bn 2 bin pad ▁( ▁x ▁, ▁tmp ▁, ▁num N ▁) ▁< ▁0 ▁|| ▁BN _ bn 2 bin pad ▁( ▁y ▁, ▁tmp ▁+ ▁num N ▁, ▁num N ▁) ▁< ▁0 ▁|| ▁! ▁EVP _ Digest ▁( ▁tmp ▁, ▁num N ▁* ▁2 ▁, ▁digest ▁, ▁NULL ▁, ▁EVP _ sha 1 ▁( ▁) ▁, ▁NULL ▁) ▁) ▁goto ▁err ▁; ▁res ▁= ▁BN _ bin 2 bn ▁( ▁digest ▁, ▁sizeof ▁( ▁digest ▁) ▁, ▁NULL ▁) ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁tmp ▁) ▁; ▁return ▁res ▁; ▁}	0
▁static ▁void ▁decode _ n al _ se i _ frame _ pack ing _ ar range ment ▁( ▁H EV C Context ▁* ▁s ▁) ▁{ ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁H EV C lc ▁-> ▁gb ▁; ▁int ▁cancel ▁, ▁type ▁, ▁qu inc un x ▁, ▁content ▁; ▁get _ ue _ go lo mb ▁( ▁gb ▁) ▁; ▁cancel ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁if ▁( ▁cancel ▁== ▁0 ▁) ▁{ ▁type ▁= ▁get _ bits ▁( ▁gb ▁, ▁7 ▁) ▁; ▁qu inc un x ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁content ▁= ▁get _ bits ▁( ▁gb ▁, ▁6 ▁) ▁; ▁skip _ bits ▁( ▁gb ▁, ▁6 ▁) ▁; ▁if ▁( ▁qu inc un x ▁== ▁0 ▁&& ▁type ▁!= ▁5 ▁) ▁skip _ bits ▁( ▁gb ▁, ▁16 ▁) ▁; ▁skip _ bits ▁( ▁gb ▁, ▁8 ▁) ▁; ▁skip _ bits 1 ▁( ▁gb ▁) ▁; ▁} ▁skip _ bits 1 ▁( ▁gb ▁) ▁; ▁s ▁-> ▁se i _ frame _ pack ing _ present ▁= ▁( ▁cancel ▁== ▁0 ▁) ▁; ▁s ▁-> ▁frame _ pack ing _ ar range ment _ type ▁= ▁type ▁; ▁s ▁-> ▁content _ interpret ation _ type ▁= ▁content ▁; ▁s ▁-> ▁qu inc un x _ sub sampling ▁= ▁qu inc un x ▁; ▁}	1
▁static ▁int ▁parse _ inputs ▁( ▁const ▁char ▁* ▁* ▁buf ▁, ▁AVFilter InOut ▁* ▁* ▁curr _ inputs ▁, ▁AVFilter InOut ▁* ▁* ▁open _ outputs ▁, ▁AV Class ▁* ▁log _ ctx ▁) ▁{ ▁int ▁pad ▁= ▁0 ▁; ▁while ▁( ▁* ▁* ▁buf ▁== ▁' ▁' ▁) ▁{ ▁char ▁* ▁name ▁= ▁parse _ link _ name ▁( ▁buf ▁, ▁log _ ctx ▁) ▁; ▁AVFilter InOut ▁* ▁match ▁; ▁if ▁( ▁! ▁name ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁match ▁= ▁extract _ inout ▁( ▁name ▁, ▁open _ outputs ▁) ▁; ▁if ▁( ▁match ▁) ▁{ ▁av _ free ▁( ▁name ▁) ▁; ▁} ▁else ▁{ ▁match ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter InOut ▁) ▁) ▁; ▁match ▁-> ▁name ▁= ▁name ▁; ▁match ▁-> ▁pad _ idx ▁= ▁pad ▁; ▁} ▁insert _ inout ▁( ▁curr _ inputs ▁, ▁match ▁) ▁; ▁* ▁buf ▁+= ▁str spn ▁( ▁* ▁buf ▁, ▁WH IT ESP ACES ▁) ▁; ▁pad ▁++ ▁; ▁} ▁return ▁pad ▁; ▁}	1
▁static ▁int ▁dfa _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁D fa Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁const ▁uint 8_ t ▁* ▁buf _ end ▁= ▁avpkt ▁-> ▁data ▁+ ▁avpkt ▁-> ▁size ▁; ▁const ▁uint 8_ t ▁* ▁tmp _ buf ▁; ▁uint 32_ t ▁chunk _ type ▁, ▁chunk _ size ▁; ▁uint 8_ t ▁* ▁dst ▁; ▁int ▁ret ▁; ▁int ▁i ▁, ▁pal _ elems ▁; ▁if ▁( ▁s ▁-> ▁pic ▁. ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁pic ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁pic ▁) ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁while ▁( ▁buf ▁< ▁buf _ end ▁) ▁{ ▁chunk _ size ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁4 ▁) ▁; ▁chunk _ type ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁8 ▁) ▁; ▁buf ▁+= ▁12 ▁; ▁if ▁( ▁buf _ end ▁- ▁buf ▁< ▁chunk _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Chunk size ist oo big (% db ytes )\ n " ▁, ▁chunk _ size ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁! ▁chunk _ type ▁) ▁break ▁; ▁if ▁( ▁chunk _ type ▁== ▁1 ▁) ▁{ ▁pal _ elems ▁= ▁FF MIN ▁( ▁chunk _ size ▁/ ▁3 ▁, ▁256 ▁) ▁; ▁tmp _ buf ▁= ▁buf ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁pal _ elems ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁pal ▁[ ▁i ▁] ▁= ▁bytestream _ get _ be 24 ▁( ▁& ▁tmp _ buf ▁) ▁<< ▁2 ▁; ▁s ▁-> ▁pal ▁[ ▁i ▁] ▁|= ▁( ▁s ▁-> ▁pal ▁[ ▁i ▁] ▁>> ▁6 ▁) ▁& ▁0 x 333 ▁; ▁} ▁s ▁-> ▁pic ▁. ▁palette _ has _ changed ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁chunk _ type ▁<= ▁9 ▁) ▁{ ▁if ▁( ▁decoder ▁[ ▁chunk _ type ▁- ▁2 ▁] ▁( ▁s ▁-> ▁frame _ buf ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁, ▁buf ▁, ▁buf ▁+ ▁chunk _ size ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error de coding % s chunk \ n " ▁, ▁chunk _ name ▁[ ▁chunk _ type ▁- ▁2 ▁] ▁) ▁; ▁return ▁-1 ▁; ▁} ▁} ▁else ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Ignoring unknown chunk type % d \ n " ▁, ▁chunk _ type ▁) ▁; ▁} ▁buf ▁+= ▁chunk _ size ▁; ▁} ▁buf ▁= ▁s ▁-> ▁frame _ buf ▁; ▁dst ▁= ▁s ▁-> ▁pic ▁. ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁height ▁; ▁i ▁++ ▁) ▁{ ▁memcpy ▁( ▁dst ▁, ▁buf ▁, ▁avctx ▁-> ▁width ▁) ▁; ▁dst ▁+= ▁s ▁-> ▁pic ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁buf ▁+= ▁avctx ▁-> ▁width ▁; ▁} ▁memcpy ▁( ▁s ▁-> ▁pic ▁. ▁data ▁[ ▁1 ▁] ▁, ▁s ▁-> ▁pal ▁, ▁sizeof ▁( ▁s ▁-> ▁pal ▁) ▁) ▁; ▁* ▁data _ size ▁= ▁sizeof ▁( ▁AVFrame ▁) ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁s ▁-> ▁pic ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁}	1
▁int 64_ t ▁av _ get _ int ▁( ▁void ▁* ▁obj ▁, ▁const ▁char ▁* ▁name ▁, ▁const ▁AV Option ▁* ▁* ▁o _ out ▁) ▁{ ▁int 64_ t ▁int num ▁= ▁1 ▁; ▁double ▁num ▁= ▁1 ▁; ▁int ▁den ▁= ▁1 ▁; ▁av _ get _ number ▁( ▁obj ▁, ▁name ▁, ▁o _ out ▁, ▁& ▁num ▁, ▁& ▁den ▁, ▁& ▁int num ▁) ▁; ▁return ▁num ▁* ▁int num ▁/ ▁den ▁; ▁}	1
▁static ▁void ▁get _ block _ sizes ▁( ▁AL S Dec Context ▁* ▁ctx ▁, ▁unsigned ▁int ▁* ▁div _ blocks ▁, ▁uint 32_ t ▁* ▁bs _ info ▁) ▁{ ▁AL SS pecific Config ▁* ▁s conf ▁= ▁& ▁ctx ▁-> ▁s conf ▁; ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁ctx ▁-> ▁gb ▁; ▁unsigned ▁int ▁* ▁ptr _ div _ blocks ▁= ▁div _ blocks ▁; ▁unsigned ▁int ▁b ▁; ▁if ▁( ▁s conf ▁-> ▁block _ switch ing ▁) ▁{ ▁unsigned ▁int ▁bs _ info _ len ▁= ▁1 ▁<< ▁( ▁s conf ▁-> ▁block _ switch ing ▁+ ▁2 ▁) ▁; ▁* ▁bs _ info ▁= ▁get _ bits _ long ▁( ▁gb ▁, ▁bs _ info _ len ▁) ▁; ▁* ▁bs _ info ▁<<= ▁( ▁32 ▁- ▁bs _ info _ len ▁) ▁; ▁} ▁ctx ▁-> ▁num _ blocks ▁= ▁0 ▁; ▁parse _ bs _ info ▁( ▁* ▁bs _ info ▁, ▁0 ▁, ▁0 ▁, ▁& ▁ptr _ div _ blocks ▁, ▁& ▁ctx ▁-> ▁num _ blocks ▁) ▁; ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁< ▁ctx ▁-> ▁num _ blocks ▁; ▁b ▁++ ▁) ▁div _ blocks ▁[ ▁b ▁] ▁= ▁ctx ▁-> ▁s conf ▁. ▁frame _ length ▁>> ▁div _ blocks ▁[ ▁b ▁] ▁; ▁if ▁( ▁ctx ▁-> ▁cur _ frame _ length ▁!= ▁ctx ▁-> ▁s conf ▁. ▁frame _ length ▁) ▁{ ▁unsigned ▁int ▁remaining ▁= ▁ctx ▁-> ▁cur _ frame _ length ▁; ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁< ▁ctx ▁-> ▁num _ blocks ▁; ▁b ▁++ ▁) ▁{ ▁if ▁( ▁remaining ▁<= ▁div _ blocks ▁[ ▁b ▁] ▁) ▁{ ▁div _ blocks ▁[ ▁b ▁] ▁= ▁remaining ▁; ▁ctx ▁-> ▁num _ blocks ▁= ▁b ▁+ ▁1 ▁; ▁break ▁; ▁} ▁remaining ▁-= ▁div _ blocks ▁[ ▁b ▁] ▁; ▁} ▁} ▁}	1
▁static ▁int ▁x mv _ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁XM VD emux Context ▁* ▁x mv ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁uint 32_ t ▁file _ version ▁; ▁uint 32_ t ▁this _ packet _ size ▁; ▁uint 16_ t ▁audio _ track ▁; ▁int ▁ret ▁; ▁s ▁-> ▁ctx _ flags ▁|= ▁AV FMT CTX _ NO HEADER ▁; ▁avio _ skip ▁( ▁pb ▁, ▁4 ▁) ▁; ▁this _ packet _ size ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁4 ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁4 ▁) ▁; ▁file _ version ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁( ▁file _ version ▁!= ▁4 ▁) ▁&& ▁( ▁file _ version ▁!= ▁2 ▁) ▁) ▁avpriv _ request _ sample ▁( ▁s ▁, ▁" Un common version %" ▁PRIu 32 ▁"" ▁, ▁file _ version ▁) ▁; ▁x mv ▁-> ▁video _ width ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁x mv ▁-> ▁video _ height ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁x mv ▁-> ▁video _ duration ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁x mv ▁-> ▁audio _ track _ count ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁2 ▁) ▁; ▁x mv ▁-> ▁audio ▁= ▁av _ malloc z _ array ▁( ▁x mv ▁-> ▁audio _ track _ count ▁, ▁sizeof ▁( ▁X MV Audio Packet ▁) ▁) ▁; ▁if ▁( ▁! ▁x mv ▁-> ▁audio ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁for ▁( ▁audio _ track ▁= ▁0 ▁; ▁audio _ track ▁< ▁x mv ▁-> ▁audio _ track _ count ▁; ▁audio _ track ▁++ ▁) ▁{ ▁X MV Audio Packet ▁* ▁packet ▁= ▁& ▁x mv ▁-> ▁audio ▁[ ▁audio _ track ▁] ▁; ▁packet ▁-> ▁compression ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁packet ▁-> ▁channels ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁packet ▁-> ▁sample _ rate ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁packet ▁-> ▁bits _ per _ sample ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁packet ▁-> ▁flags ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁packet ▁-> ▁bit _ rate ▁= ▁packet ▁-> ▁bits _ per _ sample ▁* ▁packet ▁-> ▁sample _ rate ▁* ▁packet ▁-> ▁channels ▁; ▁packet ▁-> ▁block _ align ▁= ▁X MV _ BLOCK _ ALIGN _ SIZE ▁* ▁packet ▁-> ▁channels ▁; ▁packet ▁-> ▁block _ samples ▁= ▁64 ▁; ▁packet ▁-> ▁codec _ id ▁= ▁ff _ wav _ codec _ get _ id ▁( ▁packet ▁-> ▁compression ▁, ▁packet ▁-> ▁bits _ per _ sample ▁) ▁; ▁packet ▁-> ▁stream _ index ▁= ▁-1 ▁; ▁packet ▁-> ▁frame _ size ▁= ▁0 ▁; ▁packet ▁-> ▁block _ count ▁= ▁0 ▁; ▁if ▁( ▁packet ▁-> ▁flags ▁& ▁X MV _ AUDIO _ AD PCM 51 ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Unsupported 5 .1 AD PCM audio stream " ▁"( 0 x %04 X )\ n " ▁, ▁packet ▁-> ▁flags ▁) ▁; ▁if ▁( ▁! ▁packet ▁-> ▁channels ▁|| ▁! ▁packet ▁-> ▁sample _ rate ▁|| ▁packet ▁-> ▁channels ▁>= ▁UINT 16_ MAX ▁/ ▁X MV _ BLOCK _ ALIGN _ SIZE ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid parameters for audio track %" ▁PRIu 16 ▁" .\ n " ▁, ▁audio _ track ▁) ▁; ▁ret ▁= ▁AVERROR _ INVALIDDATA ▁; ▁goto ▁fail ▁; ▁} ▁} ▁x mv ▁-> ▁next _ packet _ offset ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁x mv ▁-> ▁next _ packet _ size ▁= ▁this _ packet _ size ▁- ▁x mv ▁-> ▁next _ packet _ offset ▁; ▁x mv ▁-> ▁stream _ count ▁= ▁x mv ▁-> ▁audio _ track _ count ▁+ ▁1 ▁; ▁return ▁0 ▁; ▁fail ▁: ▁x mv _ read _ close ▁( ▁s ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁apr _ status _ t ▁slot mem _ attach ▁( ▁ap _ slot mem _ instance _ t ▁* ▁* ▁new ▁, ▁const ▁char ▁* ▁name ▁, ▁apr _ size _ t ▁* ▁item _ size ▁, ▁unsigned ▁int ▁* ▁item _ num ▁, ▁apr _ pool _ t ▁* ▁pool ▁) ▁{ ▁char ▁* ▁ptr ▁; ▁ap _ slot mem _ instance _ t ▁* ▁res ▁; ▁ap _ slot mem _ instance _ t ▁* ▁next ▁= ▁glob all ist mem ▁; ▁share ds lot desc _ t ▁desc ▁; ▁const ▁char ▁* ▁fname ▁; ▁apr _ shm _ t ▁* ▁shm ▁; ▁apr _ status _ t ▁rv ▁; ▁if ▁( ▁g pool ▁== ▁NULL ▁) ▁{ ▁return ▁APR _ ENO SH MA V AIL ▁; ▁} ▁if ▁( ▁! ▁slot mem _ fil enames ▁( ▁pool ▁, ▁name ▁, ▁& ▁fname ▁, ▁NULL ▁) ▁) ▁{ ▁return ▁APR _ ENO SH MA V AIL ▁; ▁} ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁AP LOG NO ▁( ▁0 23 01 ▁) ▁" attach look ing for % s " ▁, ▁fname ▁) ▁; ▁if ▁( ▁next ▁) ▁{ ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁strcmp ▁( ▁next ▁-> ▁name ▁, ▁fname ▁) ▁== ▁0 ▁) ▁{ ▁* ▁new ▁= ▁next ▁; ▁* ▁item _ size ▁= ▁next ▁-> ▁desc ▁. ▁size ▁; ▁* ▁item _ num ▁= ▁next ▁-> ▁desc ▁. ▁num ▁; ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁AP LOG NO ▁( ▁0 23 02 ▁) ▁" attach found % s :% " ▁APR _ SIZE _ T _ FMT ▁"/ % u " ▁, ▁fname ▁, ▁* ▁item _ size ▁, ▁* ▁item _ num ▁) ▁; ▁return ▁APR _ SUCCESS ▁; ▁} ▁if ▁( ▁! ▁next ▁-> ▁next ▁) ▁{ ▁break ▁; ▁} ▁next ▁= ▁next ▁-> ▁next ▁; ▁} ▁} ▁rv ▁= ▁apr _ shm _ attach ▁( ▁& ▁shm ▁, ▁fname ▁, ▁g pool ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁rv ▁; ▁} ▁ptr ▁= ▁( ▁char ▁* ▁) ▁apr _ shm _ base addr _ get ▁( ▁shm ▁) ▁; ▁memcpy ▁( ▁& ▁desc ▁, ▁ptr ▁, ▁sizeof ▁( ▁desc ▁) ▁) ▁; ▁ptr ▁+= ▁AP _ SLOT MEM _ OFFSET ▁; ▁res ▁= ▁( ▁ap _ slot mem _ instance _ t ▁* ▁) ▁apr _ pc alloc ▁( ▁g pool ▁, ▁sizeof ▁( ▁ap _ slot mem _ instance _ t ▁) ▁) ▁; ▁res ▁-> ▁name ▁= ▁apr _ p strdup ▁( ▁g pool ▁, ▁fname ▁) ▁; ▁res ▁-> ▁f based ▁= ▁1 ▁; ▁res ▁-> ▁shm ▁= ▁shm ▁; ▁res ▁-> ▁num _ free ▁= ▁( ▁unsigned ▁int ▁* ▁) ▁ptr ▁; ▁res ▁-> ▁persist ▁= ▁( ▁void ▁* ▁) ▁ptr ▁; ▁ptr ▁+= ▁AP _ UNSIGNED INT _ OFFSET ▁; ▁res ▁-> ▁base ▁= ▁( ▁void ▁* ▁) ▁ptr ▁; ▁res ▁-> ▁desc ▁= ▁desc ▁; ▁res ▁-> ▁g pool ▁= ▁g pool ▁; ▁res ▁-> ▁in use ▁= ▁ptr ▁+ ▁( ▁desc ▁. ▁size ▁* ▁desc ▁. ▁num ▁) ▁; ▁res ▁-> ▁next ▁= ▁NULL ▁; ▁if ▁( ▁glob all ist mem ▁== ▁NULL ▁) ▁{ ▁glob all ist mem ▁= ▁res ▁; ▁} ▁else ▁{ ▁next ▁-> ▁next ▁= ▁res ▁; ▁} ▁* ▁new ▁= ▁res ▁; ▁* ▁item _ size ▁= ▁desc ▁. ▁size ▁; ▁* ▁item _ num ▁= ▁desc ▁. ▁num ▁; ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁AP LOG NO ▁( ▁02 303 ▁) ▁" attach found % s :% " ▁APR _ SIZE _ T _ FMT ▁"/ % u " ▁, ▁fname ▁, ▁* ▁item _ size ▁, ▁* ▁item _ num ▁) ▁; ▁return ▁APR _ SUCCESS ▁; ▁}	1
▁static ▁int ▁normalize _ samples ▁( ▁AC 3 Encode Context ▁* ▁s ▁) ▁{ ▁int ▁v ▁= ▁14 ▁- ▁log 2_ tab ▁( ▁s ▁, ▁s ▁-> ▁window ed _ samples ▁, ▁AC 3_ WINDOW _ SIZE ▁) ▁; ▁l shift _ tab ▁( ▁s ▁-> ▁window ed _ samples ▁, ▁AC 3_ WINDOW _ SIZE ▁, ▁v ▁) ▁; ▁return ▁v ▁- ▁9 ▁; ▁}	1
▁int ▁BN _ bn 2 le bin pad ▁( ▁const ▁BIGNUM ▁* ▁a ▁, ▁unsigned ▁char ▁* ▁to ▁, ▁int ▁to len ▁) ▁{ ▁int ▁i ▁; ▁BN _ ULONG ▁l ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁i ▁= ▁BN _ num _ bytes ▁( ▁a ▁) ▁; ▁if ▁( ▁to len ▁< ▁i ▁) ▁return ▁-1 ▁; ▁if ▁( ▁to len ▁> ▁i ▁) ▁memset ▁( ▁to ▁+ ▁i ▁, ▁0 ▁, ▁to len ▁- ▁i ▁) ▁; ▁to ▁+= ▁i ▁; ▁while ▁( ▁i ▁-- ▁) ▁{ ▁l ▁= ▁a ▁-> ▁d ▁[ ▁i ▁/ ▁BN _ BYTES ▁] ▁; ▁to ▁-- ▁; ▁* ▁to ▁= ▁( ▁unsigned ▁char ▁) ▁( ▁l ▁>> ▁( ▁8 ▁* ▁( ▁i ▁% ▁BN _ BYTES ▁) ▁) ▁) ▁& ▁0 xff ▁; ▁} ▁return ▁to len ▁; ▁}	1
▁void ▁ff _ af _ queue _ remove ▁( ▁Audio Frame Queue ▁* ▁af q ▁, ▁int ▁nb _ samples ▁, ▁int 64_ t ▁* ▁pts ▁, ▁int ▁* ▁duration ▁) ▁{ ▁int 64_ t ▁out _ pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁int ▁removed _ samples ▁= ▁0 ▁; ▁# ifdef ▁DEBUG ▁ff _ af _ queue _ log _ state ▁( ▁af q ▁) ▁; ▁# endif ▁if ▁( ▁af q ▁-> ▁frame _ queue ▁) ▁{ ▁if ▁( ▁af q ▁-> ▁frame _ queue ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁out _ pts ▁= ▁af q ▁-> ▁frame _ queue ▁-> ▁pts ▁- ▁af q ▁-> ▁remaining _ delay ▁; ▁} ▁else ▁{ ▁if ▁( ▁af q ▁-> ▁next _ pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁out _ pts ▁= ▁af q ▁-> ▁next _ pts ▁- ▁af q ▁-> ▁remaining _ delay ▁; ▁} ▁if ▁( ▁pts ▁) ▁{ ▁if ▁( ▁out _ pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁* ▁pts ▁= ▁ff _ samples _ to _ time _ base ▁( ▁af q ▁-> ▁avctx ▁, ▁out _ pts ▁) ▁; ▁else ▁* ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁if ▁( ▁af q ▁-> ▁remaining _ delay ▁>= ▁nb _ samples ▁) ▁{ ▁removed _ samples ▁+= ▁nb _ samples ▁; ▁af q ▁-> ▁remaining _ delay ▁-= ▁nb _ samples ▁; ▁} ▁while ▁( ▁removed _ samples ▁< ▁nb _ samples ▁&& ▁af q ▁-> ▁frame _ queue ▁) ▁{ ▁removed _ samples ▁+= ▁af q ▁-> ▁frame _ queue ▁-> ▁duration ▁; ▁delete _ next _ frame ▁( ▁af q ▁) ▁; ▁} ▁af q ▁-> ▁remaining _ samples ▁-= ▁removed _ samples ▁; ▁if ▁( ▁removed _ samples ▁< ▁nb _ samples ▁&& ▁af q ▁-> ▁remaining _ samples ▁> ▁0 ▁) ▁{ ▁int ▁add _ samples ▁= ▁FF MIN ▁( ▁af q ▁-> ▁remaining _ samples ▁, ▁nb _ samples ▁- ▁removed _ samples ▁) ▁; ▁removed _ samples ▁+= ▁add _ samples ▁; ▁af q ▁-> ▁remaining _ samples ▁-= ▁add _ samples ▁; ▁} ▁if ▁( ▁removed _ samples ▁> ▁nb _ samples ▁) ▁av _ log ▁( ▁af q ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" frame _ size ist ool arge \ n " ▁) ▁; ▁if ▁( ▁duration ▁) ▁* ▁duration ▁= ▁ff _ samples _ to _ time _ base ▁( ▁af q ▁-> ▁avctx ▁, ▁removed _ samples ▁) ▁; ▁}	1
▁unsigned ▁char ▁* ▁OPENSSL _ asc 2 uni ▁( ▁const ▁char ▁* ▁asc ▁, ▁int ▁as clen ▁, ▁unsigned ▁char ▁* ▁* ▁uni ▁, ▁int ▁* ▁un il en ▁) ▁{ ▁int ▁ul en ▁, ▁i ▁; ▁unsigned ▁char ▁* ▁unit mp ▁; ▁if ▁( ▁as clen ▁== ▁-1 ▁) ▁as clen ▁= ▁strlen ▁( ▁asc ▁) ▁; ▁ul en ▁= ▁as clen ▁* ▁2 ▁+ ▁2 ▁; ▁if ▁( ▁( ▁unit mp ▁= ▁OPENSSL _ malloc ▁( ▁ul en ▁) ▁) ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ul en ▁- ▁2 ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁unit mp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁unit mp ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁asc ▁[ ▁i ▁>> ▁1 ▁] ▁; ▁} ▁unit mp ▁[ ▁ul en ▁- ▁2 ▁] ▁= ▁0 ▁; ▁unit mp ▁[ ▁ul en ▁- ▁1 ▁] ▁= ▁0 ▁; ▁if ▁( ▁un il en ▁) ▁* ▁un il en ▁= ▁ul en ▁; ▁if ▁( ▁uni ▁) ▁* ▁uni ▁= ▁unit mp ▁; ▁return ▁unit mp ▁; ▁}	1
▁static ▁int ▁h 264_ slice _ header _ init ▁( ▁H 264 Context ▁* ▁h ▁) ▁{ ▁const ▁SP S ▁* ▁sps ▁= ▁h ▁-> ▁ps ▁. ▁sps ▁; ▁int ▁nb _ s lices ▁= ▁( ▁HAVE _ THREADS ▁&& ▁h ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁? ▁h ▁-> ▁avctx ▁-> ▁thread _ count ▁: ▁1 ▁; ▁int ▁i ▁, ▁ret ▁; ▁ff _ set _ sar ▁( ▁h ▁-> ▁avctx ▁, ▁sps ▁-> ▁sar ▁) ▁; ▁av _ pix _ fmt _ get _ chroma _ sub _ sample ▁( ▁h ▁-> ▁avctx ▁-> ▁pix _ fmt ▁, ▁& ▁h ▁-> ▁chroma _ x _ shift ▁, ▁& ▁h ▁-> ▁chroma _ y _ shift ▁) ▁; ▁if ▁( ▁sps ▁-> ▁timing _ info _ present _ flag ▁) ▁{ ▁int 64_ t ▁den ▁= ▁sps ▁-> ▁time _ scale ▁; ▁if ▁( ▁h ▁-> ▁x 264_ build ▁< ▁44 U ▁) ▁den ▁*= ▁2 ▁; ▁av _ reduce ▁( ▁& ▁h ▁-> ▁avctx ▁-> ▁fram erate ▁. ▁den ▁, ▁& ▁h ▁-> ▁avctx ▁-> ▁fram erate ▁. ▁num ▁, ▁sps ▁-> ▁num _ units _ in _ tick ▁, ▁den ▁, ▁1 ▁<< ▁30 ▁) ▁; ▁} ▁ff _ h 264_ free _ tables ▁( ▁h ▁) ▁; ▁h ▁-> ▁first _ field ▁= ▁0 ▁; ▁h ▁-> ▁prev _ inter l aced _ frame ▁= ▁1 ▁; ▁init _ scan _ tables ▁( ▁h ▁) ▁; ▁ret ▁= ▁ff _ h 264_ alloc _ tables ▁( ▁h ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Could not allocate memory \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁sps ▁-> ▁bit _ depth _ l uma ▁< ▁8 ▁|| ▁sps ▁-> ▁bit _ depth _ l uma ▁> ▁10 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported bit depth % d \ n " ▁, ▁sps ▁-> ▁bit _ depth _ l uma ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁h ▁-> ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁= ▁sps ▁-> ▁bit _ depth _ l uma ▁; ▁h ▁-> ▁pixel _ shift ▁= ▁sps ▁-> ▁bit _ depth _ l uma ▁> ▁8 ▁; ▁h ▁-> ▁chroma _ format _ id c ▁= ▁sps ▁-> ▁chroma _ format _ id c ▁; ▁h ▁-> ▁bit _ depth _ l uma ▁= ▁sps ▁-> ▁bit _ depth _ l uma ▁; ▁ff _ h 264 dsp _ init ▁( ▁& ▁h ▁-> ▁h 264 dsp ▁, ▁sps ▁-> ▁bit _ depth _ l uma ▁, ▁sps ▁-> ▁chroma _ format _ id c ▁) ▁; ▁ff _ h 264 chroma _ init ▁( ▁& ▁h ▁-> ▁h 264 chroma ▁, ▁sps ▁-> ▁bit _ depth _ chroma ▁) ▁; ▁ff _ h 264 q pel _ init ▁( ▁& ▁h ▁-> ▁h 264 q pel ▁, ▁sps ▁-> ▁bit _ depth _ l uma ▁) ▁; ▁ff _ h 264_ pred _ init ▁( ▁& ▁h ▁-> ▁hpc ▁, ▁h ▁-> ▁avctx ▁-> ▁codec _ id ▁, ▁sps ▁-> ▁bit _ depth _ l uma ▁, ▁sps ▁-> ▁chroma _ format _ id c ▁) ▁; ▁ff _ vide od sp _ init ▁( ▁& ▁h ▁-> ▁v dsp ▁, ▁sps ▁-> ▁bit _ depth _ l uma ▁) ▁; ▁if ▁( ▁nb _ s lices ▁> ▁H 264_ MAX _ THREADS ▁|| ▁( ▁nb _ s lices ▁> ▁h ▁-> ▁mb _ height ▁&& ▁h ▁-> ▁mb _ height ▁) ▁) ▁{ ▁int ▁max _ s lices ▁; ▁if ▁( ▁h ▁-> ▁mb _ height ▁) ▁max _ s lices ▁= ▁FF MIN ▁( ▁H 264_ MAX _ THREADS ▁, ▁h ▁-> ▁mb _ height ▁) ▁; ▁else ▁max _ s lices ▁= ▁H 264_ MAX _ THREADS ▁; ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" t oom any threads / s lices % d ," ▁" red uc ing to % d \ n " ▁, ▁nb _ s lices ▁, ▁max _ s lices ▁) ▁; ▁nb _ s lices ▁= ▁max _ s lices ▁; ▁} ▁h ▁-> ▁slice _ context _ count ▁= ▁nb _ s lices ▁; ▁if ▁( ▁! ▁HAVE _ THREADS ▁|| ▁! ▁( ▁h ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁) ▁{ ▁ret ▁= ▁ff _ h 264_ slice _ context _ init ▁( ▁h ▁, ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" context _ init () failed .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁H 264 Slice Context ▁* ▁sl ▁= ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁i ▁] ▁; ▁sl ▁-> ▁h 264 ▁= ▁h ▁; ▁sl ▁-> ▁in tra 4 x 4_ pred _ mode ▁= ▁h ▁-> ▁in tra 4 x 4_ pred _ mode ▁+ ▁i ▁* ▁8 ▁* ▁2 ▁* ▁h ▁-> ▁mb _ stride ▁; ▁sl ▁-> ▁mv d _ table ▁[ ▁0 ▁] ▁= ▁h ▁-> ▁mv d _ table ▁[ ▁0 ▁] ▁+ ▁i ▁* ▁8 ▁* ▁2 ▁* ▁h ▁-> ▁mb _ stride ▁; ▁sl ▁-> ▁mv d _ table ▁[ ▁1 ▁] ▁= ▁h ▁-> ▁mv d _ table ▁[ ▁1 ▁] ▁+ ▁i ▁* ▁8 ▁* ▁2 ▁* ▁h ▁-> ▁mb _ stride ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ h 264_ slice _ context _ init ▁( ▁h ▁, ▁sl ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" context _ init () failed .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁} ▁h ▁-> ▁context _ initialized ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁av _ cold ▁int ▁he vc _ decode _ free ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁H EV C Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁i ▁; ▁pic _ arrays _ free ▁( ▁s ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁md 5_ ctx ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n als _ allocated ▁; ▁i ▁++ ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ pos _ n al ▁[ ▁i ▁] ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ pos _ size _ n al ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ n al ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁skipped _ bytes _ pos _ n al ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁c abac _ state ▁) ▁; ▁av _ frame _ free ▁( ▁& ▁s ▁-> ▁tmp _ frame ▁) ▁; ▁av _ frame _ free ▁( ▁& ▁s ▁-> ▁output _ frame ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁D PB ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ff _ he vc _ unref _ frame ▁( ▁s ▁, ▁& ▁s ▁-> ▁D PB ▁[ ▁i ▁] ▁, ▁ ~ ▁0 ▁) ▁; ▁av _ frame _ free ▁( ▁& ▁s ▁-> ▁D PB ▁[ ▁i ▁] ▁. ▁frame ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁v ps _ list ▁) ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁v ps _ list ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁sps _ list ▁) ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁sps _ list ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁pps _ list ▁) ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁pps _ list ▁[ ▁i ▁] ▁) ▁; ▁s ▁-> ▁sps ▁= ▁NULL ▁; ▁s ▁-> ▁pps ▁= ▁NULL ▁; ▁s ▁-> ▁v ps ▁= ▁NULL ▁; ▁av _ buffer _ unref ▁( ▁& ▁s ▁-> ▁current _ s ps ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁sh ▁. ▁offset ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁sh ▁. ▁size ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁H EV CL ocal Context ▁* ▁lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁if ▁( ▁lc ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁H EV C lc ▁== ▁s ▁-> ▁H EV C lc List ▁[ ▁0 ▁] ▁) ▁s ▁-> ▁H EV C lc ▁= ▁NULL ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁H EV C lc List ▁[ ▁0 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n als _ allocated ▁; ▁i ▁++ ▁) ▁av _ freep ▁( ▁& ▁s ▁-> ▁n als ▁[ ▁i ▁] ▁. ▁rb sp _ buffer ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁n als ▁) ▁; ▁s ▁-> ▁n als _ allocated ▁= ▁0 ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁ff _ index _ search _ timestamp ▁( ▁const ▁AV Index Entry ▁* ▁entries ▁, ▁int ▁nb _ entries ▁, ▁int 64_ t ▁wanted _ timestamp ▁, ▁int ▁flags ▁) ▁{ ▁int ▁a ▁, ▁b ▁, ▁m ▁; ▁int 64_ t ▁timestamp ▁; ▁a ▁= ▁- ▁1 ▁; ▁b ▁= ▁nb _ entries ▁; ▁if ▁( ▁b ▁&& ▁entries ▁[ ▁b ▁- ▁1 ▁] ▁. ▁timestamp ▁< ▁wanted _ timestamp ▁) ▁a ▁= ▁b ▁- ▁1 ▁; ▁while ▁( ▁b ▁- ▁a ▁> ▁1 ▁) ▁{ ▁m ▁= ▁( ▁a ▁+ ▁b ▁) ▁>> ▁1 ▁; ▁timestamp ▁= ▁entries ▁[ ▁m ▁] ▁. ▁timestamp ▁; ▁if ▁( ▁timestamp ▁>= ▁wanted _ timestamp ▁) ▁b ▁= ▁m ▁; ▁if ▁( ▁timestamp ▁<= ▁wanted _ timestamp ▁) ▁a ▁= ▁m ▁; ▁} ▁m ▁= ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁) ▁? ▁a ▁: ▁b ▁; ▁if ▁( ▁! ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ ANY ▁) ▁) ▁{ ▁while ▁( ▁m ▁>= ▁0 ▁&& ▁m ▁< ▁nb _ entries ▁&& ▁! ▁( ▁entries ▁[ ▁m ▁] ▁. ▁flags ▁& ▁AV INDEX _ KEY FRAME ▁) ▁) ▁{ ▁m ▁+= ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁) ▁? ▁-1 ▁: ▁1 ▁; ▁} ▁} ▁if ▁( ▁m ▁== ▁nb _ entries ▁) ▁return ▁-1 ▁; ▁return ▁m ▁; ▁}	1
▁void ▁ff _ init _ block _ index ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁const ▁int ▁linesize ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁const ▁int ▁uv lines ize ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁linesize ▁[ ▁1 ▁] ▁; ▁const ▁int ▁mb _ size ▁= ▁4 ▁- ▁s ▁-> ▁avctx ▁-> ▁low res ▁; ▁s ▁-> ▁block _ index ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁) ▁- ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁) ▁- ▁1 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁2 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁+ ▁1 ▁) ▁- ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁3 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁+ ▁1 ▁) ▁- ▁1 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁4 ▁] ▁= ▁s ▁-> ▁mb _ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁+ ▁1 ▁) ▁+ ▁s ▁-> ▁b 8_ stride ▁* ▁s ▁-> ▁mb _ height ▁* ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁- ▁1 ▁; ▁s ▁-> ▁block _ index ▁[ ▁5 ▁] ▁= ▁s ▁-> ▁mb _ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁+ ▁s ▁-> ▁mb _ height ▁+ ▁2 ▁) ▁+ ▁s ▁-> ▁b 8_ stride ▁* ▁s ▁-> ▁mb _ height ▁* ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁- ▁1 ▁; ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁+ ▁( ▁( ▁s ▁-> ▁mb _ x ▁- ▁1 ▁) ▁<< ▁mb _ size ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁1 ▁] ▁+ ▁( ▁( ▁s ▁-> ▁mb _ x ▁- ▁1 ▁) ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ x _ shift ▁) ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁2 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁2 ▁] ▁+ ▁( ▁( ▁s ▁-> ▁mb _ x ▁- ▁1 ▁) ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ x _ shift ▁) ▁) ▁; ▁if ▁( ▁! ▁( ▁s ▁-> ▁pict _ type ▁== ▁AV _ PICTURE _ TYPE _ B ▁&& ▁s ▁-> ▁avctx ▁-> ▁draw _ h oriz _ band ▁&& ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁) ▁{ ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁{ ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁+= ▁s ▁-> ▁mb _ y ▁* ▁linesize ▁<< ▁mb _ size ▁; ▁s ▁-> ▁dest ▁[ ▁1 ▁] ▁+= ▁s ▁-> ▁mb _ y ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁2 ▁] ▁+= ▁s ▁-> ▁mb _ y ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁} ▁else ▁{ ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁+= ▁( ▁s ▁-> ▁mb _ y ▁>> ▁1 ▁) ▁* ▁linesize ▁<< ▁mb _ size ▁; ▁s ▁-> ▁dest ▁[ ▁1 ▁] ▁+= ▁( ▁s ▁-> ▁mb _ y ▁>> ▁1 ▁) ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁2 ▁] ▁+= ▁( ▁s ▁-> ▁mb _ y ▁>> ▁1 ▁) ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁av _ assert 1 ▁( ▁( ▁s ▁-> ▁mb _ y ▁& ▁1 ▁) ▁== ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ BOTTOM _ FIELD ▁) ▁) ▁; ▁} ▁} ▁}	1
▁ssize _ t ▁ngx _ write _ chain _ to _ file ▁( ▁ngx _ file _ t ▁* ▁file ▁, ▁ngx _ chain _ t ▁* ▁cl ▁, ▁off _ t ▁offset ▁, ▁ngx _ pool _ t ▁* ▁pool ▁) ▁{ ▁u _ char ▁* ▁prev ▁; ▁size _ t ▁size ▁; ▁ssize _ t ▁total ▁, ▁n ▁; ▁ngx _ array _ t ▁vec ▁; ▁struct ▁iovec ▁* ▁iov ▁, ▁io vs ▁[ ▁NGX _ IO VS ▁] ▁; ▁if ▁( ▁cl ▁-> ▁next ▁== ▁NULL ▁) ▁{ ▁return ▁ngx _ write _ file ▁( ▁file ▁, ▁cl ▁-> ▁buf ▁-> ▁pos ▁, ▁( ▁size _ t ▁) ▁( ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁) ▁, ▁offset ▁) ▁; ▁} ▁total ▁= ▁0 ▁; ▁vec ▁. ▁elts ▁= ▁io vs ▁; ▁vec ▁. ▁size ▁= ▁sizeof ▁( ▁struct ▁iovec ▁) ▁; ▁vec ▁. ▁n alloc ▁= ▁NGX _ IO VS ▁; ▁vec ▁. ▁pool ▁= ▁pool ▁; ▁do ▁{ ▁prev ▁= ▁NULL ▁; ▁iov ▁= ▁NULL ▁; ▁size ▁= ▁0 ▁; ▁vec ▁. ▁nel ts ▁= ▁0 ▁; ▁while ▁( ▁cl ▁&& ▁vec ▁. ▁nel ts ▁< ▁IO V _ MAX ▁) ▁{ ▁if ▁( ▁prev ▁== ▁cl ▁-> ▁buf ▁-> ▁pos ▁) ▁{ ▁iov ▁-> ▁iov _ len ▁+= ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁} ▁else ▁{ ▁iov ▁= ▁ngx _ array _ push ▁( ▁& ▁vec ▁) ▁; ▁if ▁( ▁iov ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁iov ▁-> ▁iov _ base ▁= ▁( ▁void ▁* ▁) ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁iov ▁-> ▁iov _ len ▁= ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁} ▁size ▁+= ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁prev ▁= ▁cl ▁-> ▁buf ▁-> ▁last ▁; ▁cl ▁= ▁cl ▁-> ▁next ▁; ▁} ▁if ▁( ▁vec ▁. ▁nel ts ▁== ▁1 ▁) ▁{ ▁iov ▁= ▁vec ▁. ▁elts ▁; ▁n ▁= ▁ngx _ write _ file ▁( ▁file ▁, ▁( ▁u _ char ▁* ▁) ▁iov ▁[ ▁0 ▁] ▁. ▁iov _ base ▁, ▁iov ▁[ ▁0 ▁] ▁. ▁iov _ len ▁, ▁offset ▁) ▁; ▁if ▁( ▁n ▁== ▁NGX _ ERROR ▁) ▁{ ▁return ▁n ▁; ▁} ▁return ▁total ▁+ ▁n ▁; ▁} ▁if ▁( ▁file ▁-> ▁sys _ offset ▁!= ▁offset ▁) ▁{ ▁if ▁( ▁lseek ▁( ▁file ▁-> ▁fd ▁, ▁offset ▁, ▁SEEK _ SET ▁) ▁== ▁-1 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁file ▁-> ▁log ▁, ▁ngx _ errno ▁, ▁" lseek () \"% s \" failed " ▁, ▁file ▁-> ▁name ▁. ▁data ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁file ▁-> ▁sys _ offset ▁= ▁offset ▁; ▁} ▁n ▁= ▁write v ▁( ▁file ▁-> ▁fd ▁, ▁vec ▁. ▁elts ▁, ▁vec ▁. ▁nel ts ▁) ▁; ▁if ▁( ▁n ▁== ▁-1 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁file ▁-> ▁log ▁, ▁ngx _ errno ▁, ▁" write v () \"% s \" failed " ▁, ▁file ▁-> ▁name ▁. ▁data ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁if ▁( ▁( ▁size _ t ▁) ▁n ▁!= ▁size ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁file ▁-> ▁log ▁, ▁0 ▁, ▁" write v () \"% s \" has written only % z of % uz " ▁, ▁file ▁-> ▁name ▁. ▁data ▁, ▁n ▁, ▁size ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ CORE ▁, ▁file ▁-> ▁log ▁, ▁0 ▁, ▁" write v :% d ,% z " ▁, ▁file ▁-> ▁fd ▁, ▁n ▁) ▁; ▁file ▁-> ▁sys _ offset ▁+= ▁n ▁; ▁file ▁-> ▁offset ▁+= ▁n ▁; ▁offset ▁+= ▁n ▁; ▁total ▁+= ▁n ▁; ▁} ▁while ▁( ▁cl ▁) ▁; ▁return ▁total ▁; ▁}	0
▁static ▁unsigned ▁int ▁fixup _ vorbis _ headers ▁( ▁AVFormatContext ▁* ▁as ▁, ▁struct ▁ogg vorbis _ private ▁* ▁priv ▁, ▁uint 8_ t ▁* ▁* ▁buf ▁) ▁{ ▁int ▁i ▁, ▁offset ▁, ▁len ▁, ▁buf _ len ▁; ▁unsigned ▁char ▁* ▁ptr ▁; ▁len ▁= ▁priv ▁-> ▁len ▁[ ▁0 ▁] ▁+ ▁priv ▁-> ▁len ▁[ ▁1 ▁] ▁+ ▁priv ▁-> ▁len ▁[ ▁2 ▁] ▁; ▁buf _ len ▁= ▁len ▁+ ▁len ▁/ ▁255 ▁+ ▁64 ▁; ▁ptr ▁= ▁* ▁buf ▁= ▁av _ realloc ▁( ▁NULL ▁, ▁buf _ len ▁) ▁; ▁memset ▁( ▁* ▁buf ▁, ▁' ▁\0 ▁' ▁, ▁buf _ len ▁) ▁; ▁ptr ▁[ ▁0 ▁] ▁= ▁2 ▁; ▁offset ▁= ▁1 ▁; ▁offset ▁+= ▁av _ x iph l acing ▁( ▁& ▁ptr ▁[ ▁offset ▁] ▁, ▁priv ▁-> ▁len ▁[ ▁0 ▁] ▁) ▁; ▁offset ▁+= ▁av _ x iph l acing ▁( ▁& ▁ptr ▁[ ▁offset ▁] ▁, ▁priv ▁-> ▁len ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁memcpy ▁( ▁& ▁ptr ▁[ ▁offset ▁] ▁, ▁priv ▁-> ▁packet ▁[ ▁i ▁] ▁, ▁priv ▁-> ▁len ▁[ ▁i ▁] ▁) ▁; ▁offset ▁+= ▁priv ▁-> ▁len ▁[ ▁i ▁] ▁; ▁av _ freep ▁( ▁& ▁priv ▁-> ▁packet ▁[ ▁i ▁] ▁) ▁; ▁} ▁* ▁buf ▁= ▁av _ realloc ▁( ▁* ▁buf ▁, ▁offset ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁return ▁offset ▁; ▁}	1
▁static ▁inline ▁void ▁ff _ update _ block _ index ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁const ▁int ▁block _ size ▁= ▁8 ▁>> ▁s ▁-> ▁avctx ▁-> ▁low res ▁; ▁s ▁-> ▁block _ index ▁[ ▁0 ▁] ▁+= ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁1 ▁] ▁+= ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁2 ▁] ▁+= ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁3 ▁] ▁+= ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁4 ▁] ▁++ ▁; ▁s ▁-> ▁block _ index ▁[ ▁5 ▁] ▁++ ▁; ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁+= ▁2 ▁* ▁block _ size ▁; ▁s ▁-> ▁dest ▁[ ▁1 ▁] ▁+= ▁block _ size ▁; ▁s ▁-> ▁dest ▁[ ▁2 ▁] ▁+= ▁block _ size ▁; ▁}	1
▁static ▁apr _ status _ t ▁commit _ entity ▁( ▁cache _ handle _ t ▁* ▁h ▁, ▁request _ rec ▁* ▁r ▁) ▁{ ▁cache _ soc ache _ conf ▁* ▁conf ▁= ▁ap _ get _ module _ config ▁( ▁r ▁-> ▁server ▁-> ▁module _ config ▁, ▁& ▁cache _ soc ache _ module ▁) ▁; ▁cache _ object _ t ▁* ▁obj ▁= ▁h ▁-> ▁cache _ obj ▁; ▁cache _ soc ache _ object _ t ▁* ▁s obj ▁= ▁( ▁cache _ soc ache _ object _ t ▁* ▁) ▁obj ▁-> ▁vo bj ▁; ▁apr _ status _ t ▁rv ▁; ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ lock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 84 ▁) ▁" could not acquire lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁status ▁; ▁} ▁} ▁rv ▁= ▁conf ▁-> ▁provider ▁-> ▁soc ache _ provider ▁-> ▁store ▁( ▁conf ▁-> ▁provider ▁-> ▁soc ache _ instance ▁, ▁r ▁-> ▁server ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁s obj ▁-> ▁key ▁, ▁strlen ▁( ▁s obj ▁-> ▁key ▁) ▁, ▁s obj ▁-> ▁expire ▁, ▁s obj ▁-> ▁buffer ▁, ▁s obj ▁-> ▁body _ offset ▁+ ▁s obj ▁-> ▁body _ length ▁, ▁s obj ▁-> ▁pool ▁) ▁; ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ unlock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 85 ▁) ▁" could not release lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁status ▁; ▁} ▁} ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ WARNING ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 86 ▁) ▁" could not writ et ocache , ign oring :% s " ▁, ▁s obj ▁-> ▁key ▁) ▁; ▁goto ▁fail ▁; ▁} ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 87 ▁) ▁" commit _ entity : Headers and body for URL % sc ached form ax imum of % d seconds ." ▁, ▁s obj ▁-> ▁name ▁, ▁( ▁apr _ uint 32_ t ▁) ▁apr _ time _ sec ▁( ▁s obj ▁-> ▁expire ▁- ▁r ▁-> ▁request _ time ▁) ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁APR _ SUCCESS ▁; ▁fail ▁: ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ lock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 2388 ▁) ▁" could not acquire lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁rv ▁; ▁} ▁} ▁conf ▁-> ▁provider ▁-> ▁soc ache _ provider ▁-> ▁remove ▁( ▁conf ▁-> ▁provider ▁-> ▁soc ache _ instance ▁, ▁r ▁-> ▁server ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁s obj ▁-> ▁key ▁, ▁strlen ▁( ▁s obj ▁-> ▁key ▁) ▁, ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ unlock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 89 ▁) ▁" could not release lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁} ▁} ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁rv ▁; ▁}	0
▁int ▁X 509_ NAME _ cmp ▁( ▁const ▁X 509_ NAME ▁* ▁a ▁, ▁const ▁X 509_ NAME ▁* ▁b ▁) ▁{ ▁int ▁ret ▁; ▁if ▁( ▁! ▁a ▁-> ▁can on _ enc ▁|| ▁a ▁-> ▁modified ▁) ▁{ ▁ret ▁= ▁i 2 d _ X 509_ NAME ▁( ▁( ▁X 509_ NAME ▁* ▁) ▁a ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁-2 ▁; ▁} ▁if ▁( ▁! ▁b ▁-> ▁can on _ enc ▁|| ▁b ▁-> ▁modified ▁) ▁{ ▁ret ▁= ▁i 2 d _ X 509_ NAME ▁( ▁( ▁X 509_ NAME ▁* ▁) ▁b ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁-2 ▁; ▁} ▁ret ▁= ▁a ▁-> ▁can on _ en clen ▁- ▁b ▁-> ▁can on _ en clen ▁; ▁if ▁( ▁ret ▁!= ▁0 ▁|| ▁a ▁-> ▁can on _ en clen ▁== ▁0 ▁) ▁return ▁ret ▁; ▁return ▁memcmp ▁( ▁a ▁-> ▁can on _ enc ▁, ▁b ▁-> ▁can on _ enc ▁, ▁a ▁-> ▁can on _ en clen ▁) ▁; ▁}	1
▁static ▁av _ cold ▁int ▁decode _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁I ff Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁err ▁; ▁if ▁( ▁avctx ▁-> ▁bits _ per _ coded _ sample ▁<= ▁8 ▁) ▁{ ▁avctx ▁-> ▁pix _ fmt ▁= ▁PIX _ FMT _ PAL 8 ▁; ▁} ▁else ▁if ▁( ▁avctx ▁-> ▁bits _ per _ coded _ sample ▁<= ▁32 ▁) ▁{ ▁avctx ▁-> ▁pix _ fmt ▁= ▁PIX _ FMT _ BGR 32 ▁; ▁} ▁else ▁{ ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁planes ize ▁= ▁avctx ▁-> ▁width ▁>> ▁3 ▁; ▁s ▁-> ▁plane buf ▁= ▁av _ malloc ▁( ▁s ▁-> ▁planes ize ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁plane buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁frame ▁. ▁reference ▁= ▁1 ▁; ▁if ▁( ▁( ▁err ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁frame ▁) ▁< ▁0 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁err ▁; ▁} ▁return ▁avctx ▁-> ▁bits _ per _ coded _ sample ▁<= ▁8 ▁? ▁ff _ cmap _ read _ palette ▁( ▁avctx ▁, ▁( ▁uint 32_ t ▁* ▁) ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁1 ▁] ▁) ▁: ▁0 ▁; ▁}	0
▁int ▁avio _ read ▁( ▁AVIO Context ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁buf ▁, ▁int ▁size ▁) ▁{ ▁int ▁len ▁, ▁size 1 ▁; ▁size 1 ▁= ▁size ▁; ▁while ▁( ▁size ▁> ▁0 ▁) ▁{ ▁len ▁= ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf _ ptr ▁; ▁if ▁( ▁len ▁> ▁size ▁) ▁len ▁= ▁size ▁; ▁if ▁( ▁len ▁== ▁0 ▁|| ▁s ▁-> ▁write _ flag ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁direct ▁|| ▁size ▁> ▁s ▁-> ▁buffer _ size ▁) ▁&& ▁! ▁s ▁-> ▁update _ checksum ▁) ▁{ ▁if ▁( ▁s ▁-> ▁read _ packet ▁) ▁len ▁= ▁s ▁-> ▁read _ packet ▁( ▁s ▁-> ▁opaque ▁, ▁buf ▁, ▁size ▁) ▁; ▁if ▁( ▁len ▁<= ▁0 ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁s ▁-> ▁error ▁= ▁len ▁; ▁break ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pos ▁+= ▁len ▁; ▁s ▁-> ▁bytes _ read ▁+= ▁len ▁; ▁size ▁-= ▁len ▁; ▁buf ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁s ▁-> ▁buf _ end ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁} ▁else ▁{ ▁fill _ buffer ▁( ▁s ▁) ▁; ▁len ▁= ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf _ ptr ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁break ▁; ▁} ▁} ▁else ▁{ ▁memcpy ▁( ▁buf ▁, ▁s ▁-> ▁buf _ ptr ▁, ▁len ▁) ▁; ▁buf ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁+= ▁len ▁; ▁size ▁-= ▁len ▁; ▁} ▁} ▁if ▁( ▁size 1 ▁== ▁size ▁) ▁{ ▁if ▁( ▁s ▁-> ▁error ▁) ▁return ▁s ▁-> ▁error ▁; ▁if ▁( ▁avio _ fe of ▁( ▁s ▁) ▁) ▁return ▁AVERROR _ EOF ▁; ▁} ▁return ▁size 1 ▁- ▁size ▁; ▁}	1
▁static ▁int ▁filter _ samples ▁( ▁AVFilter Link ▁* ▁inlink ▁, ▁AVFilter Buffer Ref ▁* ▁ins amples ref ▁) ▁{ ▁A Res ample Context ▁* ▁ares ample ▁= ▁inlink ▁-> ▁dst ▁-> ▁priv ▁; ▁const ▁int ▁n _ in ▁= ▁ins amples ref ▁-> ▁audio ▁-> ▁nb _ samples ▁; ▁int ▁n _ out ▁= ▁FF MAX ▁( ▁n _ in ▁* ▁ares ample ▁-> ▁ratio ▁* ▁2 ▁, ▁1 ▁) ▁; ▁AVFilter Link ▁* ▁const ▁out link ▁= ▁inlink ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁AVFilter Buffer Ref ▁* ▁out samples ref ▁= ▁ff _ get _ audio _ buffer ▁( ▁out link ▁, ▁AV _ PERM _ WRITE ▁, ▁n _ out ▁) ▁; ▁int ▁ret ▁; ▁if ▁( ▁! ▁out samples ref ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁avfilter _ copy _ buffer _ ref _ props ▁( ▁out samples ref ▁, ▁ins amples ref ▁) ▁; ▁out samples ref ▁-> ▁format ▁= ▁out link ▁-> ▁format ▁; ▁out samples ref ▁-> ▁audio ▁-> ▁channel _ layout ▁= ▁out link ▁-> ▁channel _ layout ▁; ▁out samples ref ▁-> ▁audio ▁-> ▁sample _ rate ▁= ▁out link ▁-> ▁sample _ rate ▁; ▁if ▁( ▁ins amples ref ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁int 64_ t ▁in pts ▁= ▁av _ re scale ▁( ▁ins amples ref ▁-> ▁pts ▁, ▁inlink ▁-> ▁time _ base ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁out link ▁-> ▁sample _ rate ▁* ▁inlink ▁-> ▁sample _ rate ▁, ▁inlink ▁-> ▁time _ base ▁. ▁den ▁) ▁; ▁int 64_ t ▁out pts ▁= ▁sw r _ next _ pts ▁( ▁ares ample ▁-> ▁sw r ▁, ▁in pts ▁) ▁; ▁ares ample ▁-> ▁next _ pts ▁= ▁out samples ref ▁-> ▁pts ▁= ▁( ▁out pts ▁+ ▁inlink ▁-> ▁sample _ rate ▁/ ▁2 ▁) ▁/ ▁inlink ▁-> ▁sample _ rate ▁; ▁} ▁else ▁{ ▁out samples ref ▁-> ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁n _ out ▁= ▁sw r _ convert ▁( ▁ares ample ▁-> ▁sw r ▁, ▁out samples ref ▁-> ▁extended _ data ▁, ▁n _ out ▁, ▁( ▁void ▁* ▁) ▁ins amples ref ▁-> ▁extended _ data ▁, ▁n _ in ▁) ▁; ▁if ▁( ▁n _ out ▁<= ▁0 ▁) ▁{ ▁avfilter _ unref _ buffer ▁( ▁out samples ref ▁) ▁; ▁avfilter _ unref _ buffer ▁( ▁ins amples ref ▁) ▁; ▁return ▁0 ▁; ▁} ▁out samples ref ▁-> ▁audio ▁-> ▁nb _ samples ▁= ▁n _ out ▁; ▁ret ▁= ▁ff _ filter _ samples ▁( ▁out link ▁, ▁out samples ref ▁) ▁; ▁ares ample ▁-> ▁req _ full filled ▁= ▁1 ▁; ▁avfilter _ unref _ buffer ▁( ▁ins amples ref ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁void ▁q tr le _ decode _1 bpp ▁( ▁Q tr le Context ▁* ▁s ▁, ▁int ▁stream _ ptr ▁, ▁int ▁row _ ptr ▁, ▁int ▁lines _ to _ change ▁) ▁{ ▁int ▁r le _ code ▁; ▁int ▁pixel _ ptr ▁= ▁0 ▁; ▁int ▁row _ inc ▁= ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁unsigned ▁char ▁pi 0 ▁, ▁pi 1 ▁; ▁unsigned ▁char ▁* ▁rgb ▁= ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁0 ▁] ▁; ▁int ▁pixel _ limit ▁= ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁* ▁s ▁-> ▁avctx ▁-> ▁height ▁; ▁int ▁skip ▁; ▁while ▁( ▁lines _ to _ change ▁) ▁{ ▁CHECK _ STREAM _ PTR ▁( ▁2 ▁) ▁; ▁skip ▁= ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁; ▁r le _ code ▁= ▁( ▁signed ▁char ▁) ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁; ▁if ▁( ▁r le _ code ▁== ▁0 ▁) ▁break ▁; ▁if ▁( ▁skip ▁& ▁0 x 80 ▁) ▁{ ▁lines _ to _ change ▁-- ▁; ▁row _ ptr ▁+= ▁row _ inc ▁; ▁pixel _ ptr ▁= ▁row _ ptr ▁+ ▁2 ▁* ▁( ▁skip ▁& ▁0 x 7 f ▁) ▁; ▁} ▁else ▁pixel _ ptr ▁+= ▁2 ▁* ▁skip ▁; ▁CHECK _ PIXEL _ PTR ▁( ▁0 ▁) ▁; ▁if ▁( ▁r le _ code ▁< ▁0 ▁) ▁{ ▁r le _ code ▁= ▁- ▁r le _ code ▁; ▁CHECK _ STREAM _ PTR ▁( ▁2 ▁) ▁; ▁pi 0 ▁= ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁; ▁pi 1 ▁= ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁; ▁CHECK _ PIXEL _ PTR ▁( ▁r le _ code ▁* ▁2 ▁) ▁; ▁while ▁( ▁r le _ code ▁-- ▁) ▁{ ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁pi 0 ▁; ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁pi 1 ▁; ▁} ▁} ▁else ▁{ ▁r le _ code ▁*= ▁2 ▁; ▁CHECK _ STREAM _ PTR ▁( ▁r le _ code ▁) ▁; ▁CHECK _ PIXEL _ PTR ▁( ▁r le _ code ▁) ▁; ▁while ▁( ▁r le _ code ▁-- ▁) ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁; ▁} ▁} ▁}	1
▁static ▁int ▁v md audio _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁V md Audio Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁block _ type ▁; ▁unsigned ▁char ▁* ▁output _ samples ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁data ▁; ▁if ▁( ▁buf _ size ▁< ▁16 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" sk ipping small junk packet \ n " ▁) ▁; ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁buf _ size ▁; ▁} ▁block _ type ▁= ▁buf ▁[ ▁6 ▁] ▁; ▁if ▁( ▁block _ type ▁< ▁BLOCK _ TYPE _ AUDIO ▁|| ▁block _ type ▁> ▁BLOCK _ TYPE _ SIL ENCE ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" unknown block type :% d \ n " ▁, ▁block _ type ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁buf ▁+= ▁16 ▁; ▁buf _ size ▁-= ▁16 ▁; ▁if ▁( ▁block _ type ▁== ▁BLOCK _ TYPE _ AUDIO ▁) ▁{ ▁* ▁data _ size ▁= ▁v md audio _ load sound ▁( ▁s ▁, ▁output _ samples ▁, ▁buf ▁, ▁0 ▁, ▁buf _ size ▁) ▁; ▁} ▁else ▁if ▁( ▁block _ type ▁== ▁BLOCK _ TYPE _ INITIAL ▁) ▁{ ▁uint 32_ t ▁flags ▁= ▁AV _ RB 32 ▁( ▁buf ▁) ▁; ▁int ▁silent _ chunks ▁= ▁av _ popcount ▁( ▁flags ▁) ▁; ▁buf ▁+= ▁4 ▁; ▁buf _ size ▁-= ▁4 ▁; ▁if ▁( ▁* ▁data _ size ▁< ▁( ▁s ▁-> ▁block _ align ▁* ▁silent _ chunks ▁+ ▁buf _ size ▁) ▁* ▁2 ▁) ▁return ▁-1 ▁; ▁* ▁data _ size ▁= ▁v md audio _ load sound ▁( ▁s ▁, ▁output _ samples ▁, ▁buf ▁, ▁silent _ chunks ▁, ▁buf _ size ▁) ▁; ▁} ▁else ▁if ▁( ▁block _ type ▁== ▁BLOCK _ TYPE _ SIL ENCE ▁) ▁{ ▁* ▁data _ size ▁= ▁v md audio _ load sound ▁( ▁s ▁, ▁output _ samples ▁, ▁buf ▁, ▁1 ▁, ▁0 ▁) ▁; ▁} ▁return ▁avpkt ▁-> ▁size ▁; ▁}	1
▁static ▁int ▁unix _ open ▁( ▁URL Context ▁* ▁h ▁, ▁const ▁char ▁* ▁filename ▁, ▁int ▁flags ▁) ▁{ ▁Unix Context ▁* ▁s ▁= ▁h ▁-> ▁priv _ data ▁; ▁int ▁fd ▁, ▁ret ▁; ▁av _ str start ▁( ▁filename ▁, ▁" unix :" ▁, ▁& ▁filename ▁) ▁; ▁s ▁-> ▁addr ▁. ▁sun _ family ▁= ▁AF _ UNIX ▁; ▁av _ strlcpy ▁( ▁s ▁-> ▁addr ▁. ▁sun _ path ▁, ▁filename ▁, ▁sizeof ▁( ▁s ▁-> ▁addr ▁. ▁sun _ path ▁) ▁) ▁; ▁if ▁( ▁( ▁fd ▁= ▁ff _ socket ▁( ▁AF _ UNIX ▁, ▁s ▁-> ▁type ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ff _ net errno ▁( ▁) ▁; ▁if ▁( ▁s ▁-> ▁listen ▁) ▁{ ▁ret ▁= ▁ff _ listen _ bind ▁( ▁fd ▁, ▁( ▁struct ▁sockaddr ▁* ▁) ▁& ▁s ▁-> ▁addr ▁, ▁sizeof ▁( ▁s ▁-> ▁addr ▁) ▁, ▁s ▁-> ▁timeout ▁, ▁h ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁fd ▁= ▁ret ▁; ▁} ▁else ▁{ ▁ret ▁= ▁ff _ listen _ connect ▁( ▁fd ▁, ▁( ▁struct ▁sockaddr ▁* ▁) ▁& ▁s ▁-> ▁addr ▁, ▁sizeof ▁( ▁s ▁-> ▁addr ▁) ▁, ▁s ▁-> ▁timeout ▁, ▁h ▁, ▁0 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁} ▁s ▁-> ▁fd ▁= ▁fd ▁; ▁return ▁0 ▁; ▁fail ▁: ▁if ▁( ▁s ▁-> ▁listen ▁&& ▁AV UN ERROR ▁( ▁ret ▁) ▁!= ▁E ADDR IN USE ▁) ▁unlink ▁( ▁s ▁-> ▁addr ▁. ▁sun _ path ▁) ▁; ▁if ▁( ▁fd ▁>= ▁0 ▁) ▁closesocket ▁( ▁fd ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁size _ t ▁BUF _ strl cat ▁( ▁char ▁* ▁dst ▁, ▁const ▁char ▁* ▁src ▁, ▁size _ t ▁size ▁) ▁{ ▁size _ t ▁l ▁= ▁0 ▁; ▁for ▁( ▁; ▁size ▁> ▁0 ▁&& ▁* ▁dst ▁; ▁size ▁-- ▁, ▁dst ▁++ ▁) ▁l ▁++ ▁; ▁return ▁l ▁+ ▁BUF _ strlcpy ▁( ▁dst ▁, ▁src ▁, ▁size ▁) ▁; ▁}	1
▁int ▁pkey param _ main ▁( ▁int ▁argc ▁, ▁char ▁* ▁* ▁argv ▁) ▁{ ▁BIO ▁* ▁in ▁= ▁NULL ▁, ▁* ▁out ▁= ▁NULL ▁; ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁int ▁text ▁= ▁0 ▁, ▁n oo ut ▁= ▁0 ▁, ▁ret ▁= ▁1 ▁; ▁OPTION _ CHOICE ▁o ▁; ▁char ▁* ▁infile ▁= ▁NULL ▁, ▁* ▁outfile ▁= ▁NULL ▁, ▁* ▁prog ▁; ▁prog ▁= ▁opt _ init ▁( ▁argc ▁, ▁argv ▁, ▁pkey param _ options ▁) ▁; ▁while ▁( ▁( ▁o ▁= ▁opt _ next ▁( ▁) ▁) ▁!= ▁OPT _ EOF ▁) ▁{ ▁switch ▁( ▁o ▁) ▁{ ▁case ▁OPT _ EOF ▁: ▁case ▁OPT _ ERR ▁: ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"% s : Use - help for summary .\ n " ▁, ▁prog ▁) ▁; ▁goto ▁end ▁; ▁case ▁OPT _ HELP ▁: ▁opt _ help ▁( ▁pkey param _ options ▁) ▁; ▁ret ▁= ▁0 ▁; ▁goto ▁end ▁; ▁case ▁OPT _ IN ▁: ▁infile ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ OUT ▁: ▁outfile ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ ENGINE ▁: ▁( ▁void ▁) ▁setup _ engine ▁( ▁opt _ arg ▁( ▁) ▁, ▁0 ▁) ▁; ▁break ▁; ▁case ▁OPT _ TEXT ▁: ▁text ▁= ▁1 ▁; ▁break ▁; ▁case ▁OPT _ NO OUT ▁: ▁n oo ut ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁argc ▁= ▁opt _ num _ rest ▁( ▁) ▁; ▁argv ▁= ▁opt _ rest ▁( ▁) ▁; ▁if ▁( ▁! ▁app _ load _ modules ▁( ▁NULL ▁) ▁) ▁goto ▁end ▁; ▁in ▁= ▁bio _ open _ default ▁( ▁infile ▁, ▁' ▁' ▁, ▁FORMAT _ PEM ▁) ▁; ▁if ▁( ▁in ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁out ▁= ▁bio _ open _ default ▁( ▁outfile ▁, ▁' ▁' ▁, ▁FORMAT _ PEM ▁) ▁; ▁if ▁( ▁out ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁pkey ▁= ▁PEM _ read _ bio _ Parameters ▁( ▁in ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁pkey ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Error reading parameters \ n " ▁) ▁; ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁n oo ut ▁) ▁PEM _ write _ bio _ Parameters ▁( ▁out ▁, ▁pkey ▁) ▁; ▁if ▁( ▁text ▁) ▁EVP _ PKEY _ print _ params ▁( ▁out ▁, ▁pkey ▁, ▁0 ▁, ▁NULL ▁) ▁; ▁ret ▁= ▁0 ▁; ▁end ▁: ▁EVP _ PKEY _ free ▁( ▁pkey ▁) ▁; ▁BIO _ free _ all ▁( ▁out ▁) ▁; ▁BIO _ free ▁( ▁in ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁mov _ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁int 64_ t ▁offset ▁; ▁uint 32_ t ▁tag ▁; ▁int ▁score ▁= ▁0 ▁; ▁offset ▁= ▁0 ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁( ▁offset ▁+ ▁8 ▁) ▁> ▁( ▁unsigned ▁int ▁) ▁p ▁-> ▁buf _ size ▁) ▁return ▁score ▁; ▁tag ▁= ▁AV _ RL 32 ▁( ▁p ▁-> ▁buf ▁+ ▁offset ▁+ ▁4 ▁) ▁; ▁switch ▁( ▁tag ▁) ▁{ ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁return ▁AV PROBE _ SCORE _ MAX ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁return ▁AV PROBE _ SCORE _ MAX ▁- ▁5 ▁; ▁case ▁MKTAG ▁( ▁0 x 82 ▁, ▁0 x 82 ▁, ▁0 x 7 f ▁, ▁0 x 7 d ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁offset ▁= ▁AV _ RB 32 ▁( ▁p ▁-> ▁buf ▁+ ▁offset ▁) ▁+ ▁offset ▁; ▁score ▁= ▁AV PROBE _ SCORE _ MAX ▁- ▁50 ▁; ▁break ▁; ▁default ▁: ▁return ▁score ▁; ▁} ▁} ▁}	0
▁static ▁int ▁decode _ ic cp _ chunk ▁( ▁PNG Dec Context ▁* ▁s ▁, ▁int ▁length ▁, ▁AVFrame ▁* ▁f ▁) ▁{ ▁int ▁ret ▁, ▁cnt ▁= ▁0 ▁; ▁uint 8_ t ▁* ▁data ▁, ▁profile _ name ▁[ ▁82 ▁] ▁; ▁AV B Print ▁bp ▁; ▁AVFrame Side Data ▁* ▁sd ▁; ▁while ▁( ▁( ▁profile _ name ▁[ ▁cnt ▁++ ▁] ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁s ▁-> ▁gb ▁) ▁) ▁&& ▁cnt ▁< ▁81 ▁) ▁; ▁if ▁( ▁cnt ▁> ▁80 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" i CC P with invalid name !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁length ▁= ▁FF MAX ▁( ▁length ▁- ▁cnt ▁, ▁0 ▁) ▁; ▁if ▁( ▁bytestream 2_ get _ byte ▁( ▁& ▁s ▁-> ▁gb ▁) ▁!= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" i CC P with invalid compression !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁length ▁= ▁FF MAX ▁( ▁length ▁- ▁1 ▁, ▁0 ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁decode _ z buf ▁( ▁& ▁bp ▁, ▁s ▁-> ▁gb ▁. ▁buffer ▁, ▁s ▁-> ▁gb ▁. ▁buffer ▁+ ▁length ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁av _ b print _ finalize ▁( ▁& ▁bp ▁, ▁( ▁char ▁* ▁* ▁) ▁& ▁data ▁) ▁; ▁if ▁( ▁! ▁data ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁sd ▁= ▁av _ frame _ new _ side _ data ▁( ▁f ▁, ▁AV _ FRAME _ DATA _ ICC _ PROFILE ▁, ▁bp ▁. ▁len ▁) ▁; ▁if ▁( ▁! ▁sd ▁) ▁{ ▁av _ free ▁( ▁data ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁av _ dict _ set ▁( ▁& ▁sd ▁-> ▁metadata ▁, ▁" name " ▁, ▁profile _ name ▁, ▁0 ▁) ▁; ▁memcpy ▁( ▁sd ▁-> ▁data ▁, ▁data ▁, ▁bp ▁. ▁len ▁) ▁; ▁av _ free ▁( ▁data ▁) ▁; ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁gb ▁, ▁length ▁+ ▁4 ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁sw ri _ res ample ▁( ▁Res ample Context ▁* ▁c ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁int ▁* ▁consumed ▁, ▁int ▁src _ size ▁, ▁int ▁dst _ size ▁, ▁int ▁update _ ctx ▁) ▁{ ▁if ▁( ▁c ▁-> ▁filter _ length ▁== ▁1 ▁&& ▁c ▁-> ▁phase _ count ▁== ▁1 ▁) ▁{ ▁int ▁index ▁= ▁c ▁-> ▁index ▁; ▁int ▁frac ▁= ▁c ▁-> ▁frac ▁; ▁int 64_ t ▁index 2 ▁= ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁c ▁-> ▁frac ▁/ ▁c ▁-> ▁src _ incr ▁+ ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁index ▁; ▁int 64_ t ▁incr ▁= ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁int ▁new _ size ▁= ▁( ▁src _ size ▁* ▁( ▁int 64_ t ▁) ▁c ▁-> ▁src _ incr ▁- ▁frac ▁+ ▁c ▁-> ▁dst _ incr ▁- ▁1 ▁) ▁/ ▁c ▁-> ▁dst _ incr ▁; ▁dst _ size ▁= ▁FF MAX ▁( ▁FF MIN ▁( ▁dst _ size ▁, ▁new _ size ▁) ▁, ▁0 ▁) ▁; ▁if ▁( ▁dst _ size ▁> ▁0 ▁) ▁c ▁-> ▁dsp ▁. ▁res ample _ one ▁( ▁dst ▁, ▁src ▁, ▁dst _ size ▁, ▁index 2 ▁, ▁incr ▁) ▁; ▁index ▁+= ▁dst _ size ▁* ▁c ▁-> ▁dst _ incr _ div ▁; ▁index ▁+= ▁( ▁frac ▁+ ▁dst _ size ▁* ▁( ▁int 64_ t ▁) ▁c ▁-> ▁dst _ incr _ mod ▁) ▁/ ▁c ▁-> ▁src _ incr ▁; ▁av _ assert 2 ▁( ▁index ▁>= ▁0 ▁) ▁; ▁* ▁consumed ▁= ▁index ▁; ▁if ▁( ▁update _ ctx ▁) ▁{ ▁c ▁-> ▁frac ▁= ▁( ▁frac ▁+ ▁dst _ size ▁* ▁( ▁int 64_ t ▁) ▁c ▁-> ▁dst _ incr _ mod ▁) ▁% ▁c ▁-> ▁src _ incr ▁; ▁c ▁-> ▁index ▁= ▁0 ▁; ▁} ▁} ▁else ▁{ ▁int 64_ t ▁end _ index ▁= ▁( ▁1 LL ▁+ ▁src _ size ▁- ▁c ▁-> ▁filter _ length ▁) ▁* ▁c ▁-> ▁phase _ count ▁; ▁int 64_ t ▁delta _ frac ▁= ▁( ▁end _ index ▁- ▁c ▁-> ▁index ▁) ▁* ▁c ▁-> ▁src _ incr ▁- ▁c ▁-> ▁frac ▁; ▁int ▁delta _ n ▁= ▁( ▁delta _ frac ▁+ ▁c ▁-> ▁dst _ incr ▁- ▁1 ▁) ▁/ ▁c ▁-> ▁dst _ incr ▁; ▁dst _ size ▁= ▁FF MAX ▁( ▁FF MIN ▁( ▁dst _ size ▁, ▁delta _ n ▁) ▁, ▁0 ▁) ▁; ▁if ▁( ▁dst _ size ▁> ▁0 ▁) ▁{ ▁if ▁( ▁c ▁-> ▁linear ▁&& ▁( ▁c ▁-> ▁frac ▁|| ▁c ▁-> ▁dst _ incr _ mod ▁) ▁) ▁* ▁consumed ▁= ▁c ▁-> ▁dsp ▁. ▁res ample _ linear ▁( ▁c ▁, ▁dst ▁, ▁src ▁, ▁dst _ size ▁, ▁update _ ctx ▁) ▁; ▁else ▁* ▁consumed ▁= ▁c ▁-> ▁dsp ▁. ▁res ample _ common ▁( ▁c ▁, ▁dst ▁, ▁src ▁, ▁dst _ size ▁, ▁update _ ctx ▁) ▁; ▁} ▁else ▁{ ▁* ▁consumed ▁= ▁0 ▁; ▁} ▁} ▁return ▁dst _ size ▁; ▁}	1
▁static ▁int ▁prefix _ write ▁( ▁BIO ▁* ▁b ▁, ▁const ▁char ▁* ▁out ▁, ▁size _ t ▁outl ▁, ▁size _ t ▁* ▁num written ▁) ▁{ ▁PREFIX _ CTX ▁* ▁ctx ▁= ▁BIO _ get _ data ▁( ▁b ▁) ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁ctx ▁-> ▁prefix ▁== ▁NULL ▁|| ▁* ▁ctx ▁-> ▁prefix ▁== ▁' ▁\0 ▁' ▁) ▁{ ▁if ▁( ▁outl ▁> ▁0 ▁) ▁ctx ▁-> ▁lin est art ▁= ▁( ▁out ▁[ ▁outl ▁- ▁1 ▁] ▁== ▁' ▁\ n ▁' ▁) ▁; ▁return ▁BIO _ write _ ex ▁( ▁BIO _ next ▁( ▁b ▁) ▁, ▁out ▁, ▁outl ▁, ▁num written ▁) ▁; ▁} ▁* ▁num written ▁= ▁0 ▁; ▁while ▁( ▁outl ▁> ▁0 ▁) ▁{ ▁size _ t ▁i ▁; ▁char ▁c ▁; ▁if ▁( ▁ctx ▁-> ▁lin est art ▁) ▁{ ▁size _ t ▁dont care ▁; ▁if ▁( ▁! ▁BIO _ write _ ex ▁( ▁BIO _ next ▁( ▁b ▁) ▁, ▁ctx ▁-> ▁prefix ▁, ▁strlen ▁( ▁ctx ▁-> ▁prefix ▁) ▁, ▁& ▁dont care ▁) ▁) ▁return ▁0 ▁; ▁ctx ▁-> ▁lin est art ▁= ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁, ▁c ▁= ▁' ▁\0 ▁' ▁; ▁i ▁< ▁outl ▁&& ▁( ▁c ▁= ▁out ▁[ ▁i ▁] ▁) ▁!= ▁' ▁\ n ▁' ▁; ▁i ▁++ ▁) ▁continue ▁; ▁if ▁( ▁c ▁== ▁' ▁\ n ▁' ▁) ▁i ▁++ ▁; ▁while ▁( ▁i ▁> ▁0 ▁) ▁{ ▁size _ t ▁num ▁= ▁0 ▁; ▁if ▁( ▁! ▁BIO _ write _ ex ▁( ▁BIO _ next ▁( ▁b ▁) ▁, ▁out ▁, ▁i ▁, ▁& ▁num ▁) ▁) ▁return ▁0 ▁; ▁out ▁+= ▁num ▁; ▁outl ▁-= ▁num ▁; ▁* ▁num written ▁+= ▁num ▁; ▁i ▁-= ▁num ▁; ▁} ▁if ▁( ▁c ▁== ▁' ▁\ n ▁' ▁) ▁ctx ▁-> ▁lin est art ▁= ▁1 ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁decode _ cb lk ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁J peg 2000 Coding Style ▁* ▁co dst y ▁, ▁J peg 2000 T 1 Context ▁* ▁t 1 ▁, ▁J peg 2000 C blk ▁* ▁cb lk ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁band pos ▁) ▁{ ▁int ▁pass no ▁= ▁cb lk ▁-> ▁np asses ▁, ▁pass _ t ▁= ▁2 ▁, ▁bp no ▁= ▁cb lk ▁-> ▁non zer ob its ▁- ▁1 ▁, ▁y ▁; ▁int ▁cl n pass _ cnt ▁= ▁0 ▁; ▁int ▁bp ass _ cst y _ symbol ▁= ▁co dst y ▁-> ▁cb lk _ style ▁& ▁JPEG 2000_ C BLK _ BYPASS ▁; ▁int ▁vert _ ca us al _ ctx _ cst y _ symbol ▁= ▁co dst y ▁-> ▁cb lk _ style ▁& ▁JPEG 2000_ C BLK _ V SC ▁; ▁av _ assert 0 ▁( ▁width ▁<= ▁JPEG 2000_ MAX _ C BLK W ▁) ▁; ▁av _ assert 0 ▁( ▁height ▁<= ▁JPEG 2000_ MAX _ C BLK H ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁++ ▁) ▁memset ▁( ▁t 1 ▁-> ▁data ▁[ ▁y ▁] ▁, ▁0 ▁, ▁width ▁* ▁sizeof ▁( ▁* ▁* ▁t 1 ▁-> ▁data ▁) ▁) ▁; ▁if ▁( ▁! ▁cb lk ▁-> ▁length ▁) ▁return ▁0 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁+ ▁2 ▁; ▁y ▁++ ▁) ▁memset ▁( ▁t 1 ▁-> ▁flags ▁[ ▁y ▁] ▁, ▁0 ▁, ▁( ▁width ▁+ ▁2 ▁) ▁* ▁sizeof ▁( ▁* ▁* ▁t 1 ▁-> ▁flags ▁) ▁) ▁; ▁cb lk ▁-> ▁data ▁[ ▁cb lk ▁-> ▁length ▁] ▁= ▁0 xff ▁; ▁cb lk ▁-> ▁data ▁[ ▁cb lk ▁-> ▁length ▁+ ▁1 ▁] ▁= ▁0 xff ▁; ▁ff _ mq c _ init dec ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁cb lk ▁-> ▁data ▁, ▁0 ▁, ▁1 ▁) ▁; ▁while ▁( ▁pass no ▁-- ▁) ▁{ ▁switch ▁( ▁pass _ t ▁) ▁{ ▁case ▁0 ▁: ▁decode _ sig pass ▁( ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁bp no ▁+ ▁1 ▁, ▁band pos ▁, ▁bp ass _ cst y _ symbol ▁&& ▁( ▁cl n pass _ cnt ▁>= ▁4 ▁) ▁, ▁vert _ ca us al _ ctx _ cst y _ symbol ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁decode _ ref pass ▁( ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁bp no ▁+ ▁1 ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁decode _ cl n pass ▁( ▁s ▁, ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁bp no ▁+ ▁1 ▁, ▁band pos ▁, ▁co dst y ▁-> ▁cb lk _ style ▁& ▁JPEG 2000_ C BLK _ SEG SYM ▁, ▁vert _ ca us al _ ctx _ cst y _ symbol ▁) ▁; ▁break ▁; ▁} ▁pass _ t ▁++ ▁; ▁if ▁( ▁pass _ t ▁== ▁3 ▁) ▁{ ▁bp no ▁-- ▁; ▁pass _ t ▁= ▁0 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁sb r _ hf _ assemble ▁( ▁float ▁Y 1 ▁[ ▁38 ▁] ▁[ ▁64 ▁] ▁[ ▁2 ▁] ▁, ▁const ▁float ▁X _ high ▁[ ▁64 ▁] ▁[ ▁40 ▁] ▁[ ▁2 ▁] ▁, ▁S pectral Band Replication ▁* ▁sb r ▁, ▁S BR Data ▁* ▁ch _ data ▁, ▁const ▁int ▁e _ a ▁[ ▁2 ▁] ▁) ▁{ ▁int ▁e ▁, ▁i ▁, ▁j ▁, ▁m ▁; ▁const ▁int ▁h _ SL ▁= ▁4 ▁* ▁! ▁sb r ▁-> ▁bs _ s moothing _ mode ▁; ▁const ▁int ▁kx ▁= ▁sb r ▁-> ▁kx ▁[ ▁1 ▁] ▁; ▁const ▁int ▁m _ max ▁= ▁sb r ▁-> ▁m ▁[ ▁1 ▁] ▁; ▁static ▁const ▁float ▁h _ smooth ▁[ ▁5 ▁] ▁= ▁{ ▁0. 33333333 3333 33 ▁, ▁0.3 015 02 832 39 58 2 ▁, ▁0. 21 816 94 99 06 249 ▁, ▁0. 115 16 38 34 27 08 4 ▁, ▁0.0 318 30 500 93 75 1 ▁, ▁} ▁; ▁static ▁const ▁int 8_ t ▁phi ▁[ ▁2 ▁] ▁[ ▁4 ▁] ▁= ▁{ ▁{ ▁1 ▁, ▁0 ▁, ▁-1 ▁, ▁0 ▁} ▁, ▁{ ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁-1 ▁} ▁, ▁} ▁; ▁float ▁( ▁* ▁g _ temp ▁) ▁[ ▁48 ▁] ▁= ▁ch _ data ▁-> ▁g _ temp ▁, ▁( ▁* ▁q _ temp ▁) ▁[ ▁48 ▁] ▁= ▁ch _ data ▁-> ▁q _ temp ▁; ▁int ▁index noise ▁= ▁ch _ data ▁-> ▁f _ index noise ▁; ▁int ▁index s ine ▁= ▁ch _ data ▁-> ▁f _ index s ine ▁; ▁if ▁( ▁sb r ▁-> ▁reset ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h _ SL ▁; ▁i ▁++ ▁) ▁{ ▁memcpy ▁( ▁g _ temp ▁[ ▁i ▁+ ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁0 ▁] ▁] ▁, ▁sb r ▁-> ▁gain ▁[ ▁0 ▁] ▁, ▁m _ max ▁* ▁sizeof ▁( ▁sb r ▁-> ▁gain ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁q _ temp ▁[ ▁i ▁+ ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁0 ▁] ▁] ▁, ▁sb r ▁-> ▁q _ m ▁[ ▁0 ▁] ▁, ▁m _ max ▁* ▁sizeof ▁( ▁sb r ▁-> ▁q _ m ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁h _ SL ▁) ▁{ ▁memcpy ▁( ▁g _ temp ▁[ ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁0 ▁] ▁] ▁, ▁g _ temp ▁[ ▁2 ▁* ▁ch _ data ▁-> ▁t _ env _ num _ env _ old ▁] ▁, ▁4 ▁* ▁sizeof ▁( ▁g _ temp ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁q _ temp ▁[ ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁0 ▁] ▁] ▁, ▁q _ temp ▁[ ▁2 ▁* ▁ch _ data ▁-> ▁t _ env _ num _ env _ old ▁] ▁, ▁4 ▁* ▁sizeof ▁( ▁q _ temp ▁[ ▁0 ▁] ▁) ▁) ▁; ▁} ▁for ▁( ▁e ▁= ▁0 ▁; ▁e ▁< ▁ch _ data ▁-> ▁bs _ num _ env ▁; ▁e ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁e ▁] ▁; ▁i ▁< ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁e ▁+ ▁1 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁memcpy ▁( ▁g _ temp ▁[ ▁h _ SL ▁+ ▁i ▁] ▁, ▁sb r ▁-> ▁gain ▁[ ▁e ▁] ▁, ▁m _ max ▁* ▁sizeof ▁( ▁sb r ▁-> ▁gain ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁q _ temp ▁[ ▁h _ SL ▁+ ▁i ▁] ▁, ▁sb r ▁-> ▁q _ m ▁[ ▁e ▁] ▁, ▁m _ max ▁* ▁sizeof ▁( ▁sb r ▁-> ▁q _ m ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁} ▁} ▁for ▁( ▁e ▁= ▁0 ▁; ▁e ▁< ▁ch _ data ▁-> ▁bs _ num _ env ▁; ▁e ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁e ▁] ▁; ▁i ▁< ▁2 ▁* ▁ch _ data ▁-> ▁t _ env ▁[ ▁e ▁+ ▁1 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁int ▁phi _ sign ▁= ▁( ▁1 ▁- ▁2 ▁* ▁( ▁kx ▁& ▁1 ▁) ▁) ▁; ▁LOCAL _ ALIGNED _16 ▁( ▁float ▁, ▁g _ filt _ tab ▁, ▁[ ▁48 ▁] ▁) ▁; ▁LOCAL _ ALIGNED _16 ▁( ▁float ▁, ▁q _ filt _ tab ▁, ▁[ ▁48 ▁] ▁) ▁; ▁float ▁* ▁g _ filt ▁, ▁* ▁q _ filt ▁; ▁if ▁( ▁h _ SL ▁&& ▁e ▁!= ▁e _ a ▁[ ▁0 ▁] ▁&& ▁e ▁!= ▁e _ a ▁[ ▁1 ▁] ▁) ▁{ ▁g _ filt ▁= ▁g _ filt _ tab ▁; ▁q _ filt ▁= ▁q _ filt _ tab ▁; ▁for ▁( ▁m ▁= ▁0 ▁; ▁m ▁< ▁m _ max ▁; ▁m ▁++ ▁) ▁{ ▁const ▁int ▁idx 1 ▁= ▁i ▁+ ▁h _ SL ▁; ▁g _ filt ▁[ ▁m ▁] ▁= ▁0.0 f ▁; ▁q _ filt ▁[ ▁m ▁] ▁= ▁0.0 f ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁<= ▁h _ SL ▁; ▁j ▁++ ▁) ▁{ ▁g _ filt ▁[ ▁m ▁] ▁+= ▁g _ temp ▁[ ▁idx 1 ▁- ▁j ▁] ▁[ ▁m ▁] ▁* ▁h _ smooth ▁[ ▁j ▁] ▁; ▁q _ filt ▁[ ▁m ▁] ▁+= ▁q _ temp ▁[ ▁idx 1 ▁- ▁j ▁] ▁[ ▁m ▁] ▁* ▁h _ smooth ▁[ ▁j ▁] ▁; ▁} ▁} ▁} ▁else ▁{ ▁g _ filt ▁= ▁g _ temp ▁[ ▁i ▁+ ▁h _ SL ▁] ▁; ▁q _ filt ▁= ▁q _ temp ▁[ ▁i ▁] ▁; ▁} ▁sb r ▁-> ▁dsp ▁. ▁hf _ g _ filt ▁( ▁Y 1 ▁[ ▁i ▁] ▁+ ▁kx ▁, ▁X _ high ▁+ ▁kx ▁, ▁g _ filt ▁, ▁m _ max ▁, ▁i ▁+ ▁EN VEL OPE _ ADJUST MENT _ OFFSET ▁) ▁; ▁if ▁( ▁e ▁!= ▁e _ a ▁[ ▁0 ▁] ▁&& ▁e ▁!= ▁e _ a ▁[ ▁1 ▁] ▁) ▁{ ▁sb r ▁-> ▁dsp ▁. ▁hf _ apply _ noise ▁[ ▁index s ine ▁] ▁( ▁Y 1 ▁[ ▁i ▁] ▁+ ▁kx ▁, ▁sb r ▁-> ▁s _ m ▁[ ▁e ▁] ▁, ▁q _ filt ▁, ▁index noise ▁, ▁kx ▁, ▁m _ max ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁m ▁= ▁0 ▁; ▁m ▁< ▁m _ max ▁; ▁m ▁++ ▁) ▁{ ▁Y 1 ▁[ ▁i ▁] ▁[ ▁m ▁+ ▁kx ▁] ▁[ ▁0 ▁] ▁+= ▁sb r ▁-> ▁s _ m ▁[ ▁e ▁] ▁[ ▁m ▁] ▁* ▁phi ▁[ ▁0 ▁] ▁[ ▁index s ine ▁] ▁; ▁Y 1 ▁[ ▁i ▁] ▁[ ▁m ▁+ ▁kx ▁] ▁[ ▁1 ▁] ▁+= ▁sb r ▁-> ▁s _ m ▁[ ▁e ▁] ▁[ ▁m ▁] ▁* ▁( ▁phi ▁[ ▁1 ▁] ▁[ ▁index s ine ▁] ▁* ▁phi _ sign ▁) ▁; ▁phi _ sign ▁= ▁- ▁phi _ sign ▁; ▁} ▁} ▁index noise ▁= ▁( ▁index noise ▁+ ▁m _ max ▁) ▁& ▁0 x 1 ff ▁; ▁index s ine ▁= ▁( ▁index s ine ▁+ ▁1 ▁) ▁& ▁3 ▁; ▁} ▁} ▁ch _ data ▁-> ▁f _ index noise ▁= ▁index noise ▁; ▁ch _ data ▁-> ▁f _ index s ine ▁= ▁index s ine ▁; ▁}	1
▁static ▁void ▁blend _ slice ▁( ▁AVFilter Context ▁* ▁ctx ▁, ▁AVFilter Buffer Ref ▁* ▁dst ▁, ▁AVFilter Buffer Ref ▁* ▁src ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁w ▁, ▁int ▁h ▁, ▁int ▁slice _ y ▁, ▁int ▁slice _ w ▁, ▁int ▁slice _ h ▁) ▁{ ▁Overlay Context ▁* ▁over ▁= ▁ctx ▁-> ▁priv ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁; ▁int ▁width ▁, ▁height ▁; ▁int ▁overlay _ end _ y ▁= ▁y ▁+ ▁h ▁; ▁int ▁slice _ end _ y ▁= ▁slice _ y ▁+ ▁slice _ h ▁; ▁int ▁end _ y ▁, ▁start _ y ▁; ▁width ▁= ▁FF MIN ▁( ▁slice _ w ▁- ▁x ▁, ▁w ▁) ▁; ▁end _ y ▁= ▁FF MIN ▁( ▁slice _ end _ y ▁, ▁overlay _ end _ y ▁) ▁; ▁start _ y ▁= ▁FF MAX ▁( ▁y ▁, ▁slice _ y ▁) ▁; ▁height ▁= ▁end _ y ▁- ▁start _ y ▁; ▁if ▁( ▁over ▁-> ▁main _ is _ packed _ rgb ▁) ▁{ ▁uint 8_ t ▁* ▁dp ▁= ▁dst ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁x ▁* ▁over ▁-> ▁main _ pix _ step ▁[ ▁0 ▁] ▁+ ▁start _ y ▁* ▁dst ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁uint 8_ t ▁* ▁sp ▁= ▁src ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁uint 8_ t ▁alpha ▁; ▁const ▁int ▁dr ▁= ▁over ▁-> ▁main _ rgba _ map ▁[ ▁R ▁] ▁; ▁const ▁int ▁dg ▁= ▁over ▁-> ▁main _ rgba _ map ▁[ ▁G ▁] ▁; ▁const ▁int ▁db ▁= ▁over ▁-> ▁main _ rgba _ map ▁[ ▁B ▁] ▁; ▁const ▁int ▁da ▁= ▁over ▁-> ▁main _ rgba _ map ▁[ ▁A ▁] ▁; ▁const ▁int ▁dst ep ▁= ▁over ▁-> ▁main _ pix _ step ▁[ ▁0 ▁] ▁; ▁const ▁int ▁sr ▁= ▁over ▁-> ▁overlay _ rgba _ map ▁[ ▁R ▁] ▁; ▁const ▁int ▁sg ▁= ▁over ▁-> ▁overlay _ rgba _ map ▁[ ▁G ▁] ▁; ▁const ▁int ▁sb ▁= ▁over ▁-> ▁overlay _ rgba _ map ▁[ ▁B ▁] ▁; ▁const ▁int ▁sa ▁= ▁over ▁-> ▁overlay _ rgba _ map ▁[ ▁A ▁] ▁; ▁const ▁int ▁s step ▁= ▁over ▁-> ▁overlay _ pix _ step ▁[ ▁0 ▁] ▁; ▁const ▁int ▁main _ has _ alpha ▁= ▁over ▁-> ▁main _ has _ alpha ▁; ▁if ▁( ▁slice _ y ▁> ▁y ▁) ▁sp ▁+= ▁( ▁slice _ y ▁- ▁y ▁) ▁* ▁src ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁height ▁; ▁i ▁++ ▁) ▁{ ▁uint 8_ t ▁* ▁d ▁= ▁dp ▁, ▁* ▁s ▁= ▁sp ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁width ▁; ▁j ▁++ ▁) ▁{ ▁alpha ▁= ▁s ▁[ ▁sa ▁] ▁; ▁if ▁( ▁main _ has _ alpha ▁&& ▁alpha ▁!= ▁0 ▁&& ▁alpha ▁!= ▁255 ▁) ▁{ ▁alpha ▁= ▁( ▁( ▁alpha ▁<< ▁16 ▁) ▁- ▁( ▁alpha ▁<< ▁9 ▁) ▁+ ▁alpha ▁) ▁/ ▁( ▁( ▁( ▁alpha ▁+ ▁d ▁[ ▁da ▁] ▁) ▁<< ▁8 ▁) ▁- ▁( ▁alpha ▁+ ▁d ▁[ ▁da ▁] ▁) ▁- ▁d ▁[ ▁da ▁] ▁* ▁alpha ▁) ▁; ▁} ▁switch ▁( ▁alpha ▁) ▁{ ▁case ▁0 ▁: ▁break ▁; ▁case ▁255 ▁: ▁d ▁[ ▁dr ▁] ▁= ▁s ▁[ ▁sr ▁] ▁; ▁d ▁[ ▁dg ▁] ▁= ▁s ▁[ ▁sg ▁] ▁; ▁d ▁[ ▁db ▁] ▁= ▁s ▁[ ▁sb ▁] ▁; ▁break ▁; ▁default ▁: ▁d ▁[ ▁dr ▁] ▁= ▁FAST _ DIV 255 ▁( ▁d ▁[ ▁dr ▁] ▁* ▁( ▁255 ▁- ▁alpha ▁) ▁+ ▁s ▁[ ▁sr ▁] ▁* ▁alpha ▁) ▁; ▁d ▁[ ▁dg ▁] ▁= ▁FAST _ DIV 255 ▁( ▁d ▁[ ▁dg ▁] ▁* ▁( ▁255 ▁- ▁alpha ▁) ▁+ ▁s ▁[ ▁sg ▁] ▁* ▁alpha ▁) ▁; ▁d ▁[ ▁db ▁] ▁= ▁FAST _ DIV 255 ▁( ▁d ▁[ ▁db ▁] ▁* ▁( ▁255 ▁- ▁alpha ▁) ▁+ ▁s ▁[ ▁sb ▁] ▁* ▁alpha ▁) ▁; ▁} ▁if ▁( ▁main _ has _ alpha ▁) ▁{ ▁switch ▁( ▁alpha ▁) ▁{ ▁case ▁0 ▁: ▁break ▁; ▁case ▁255 ▁: ▁d ▁[ ▁da ▁] ▁= ▁s ▁[ ▁sa ▁] ▁; ▁break ▁; ▁default ▁: ▁d ▁[ ▁da ▁] ▁+= ▁FAST _ DIV 255 ▁( ▁( ▁255 ▁- ▁d ▁[ ▁da ▁] ▁) ▁* ▁s ▁[ ▁sa ▁] ▁) ▁; ▁} ▁} ▁d ▁+= ▁dst ep ▁; ▁s ▁+= ▁s step ▁; ▁} ▁dp ▁+= ▁dst ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁sp ▁+= ▁src ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁h sub ▁= ▁i ▁? ▁over ▁-> ▁h sub ▁: ▁0 ▁; ▁int ▁v sub ▁= ▁i ▁? ▁over ▁-> ▁v sub ▁: ▁0 ▁; ▁uint 8_ t ▁* ▁dp ▁= ▁dst ▁-> ▁data ▁[ ▁i ▁] ▁+ ▁( ▁x ▁>> ▁h sub ▁) ▁+ ▁( ▁start _ y ▁>> ▁v sub ▁) ▁* ▁dst ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁uint 8_ t ▁* ▁sp ▁= ▁src ▁-> ▁data ▁[ ▁i ▁] ▁; ▁uint 8_ t ▁* ▁ap ▁= ▁src ▁-> ▁data ▁[ ▁3 ▁] ▁; ▁int ▁wp ▁= ▁FF ALIGN ▁( ▁width ▁, ▁1 ▁<< ▁h sub ▁) ▁>> ▁h sub ▁; ▁int ▁hp ▁= ▁FF ALIGN ▁( ▁height ▁, ▁1 ▁<< ▁v sub ▁) ▁>> ▁v sub ▁; ▁if ▁( ▁slice _ y ▁> ▁y ▁) ▁{ ▁sp ▁+= ▁( ▁( ▁slice _ y ▁- ▁y ▁) ▁>> ▁v sub ▁) ▁* ▁src ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁ap ▁+= ▁( ▁slice _ y ▁- ▁y ▁) ▁* ▁src ▁-> ▁linesize ▁[ ▁3 ▁] ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁hp ▁; ▁j ▁++ ▁) ▁{ ▁uint 8_ t ▁* ▁d ▁= ▁dp ▁, ▁* ▁s ▁= ▁sp ▁, ▁* ▁a ▁= ▁ap ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁wp ▁; ▁k ▁++ ▁) ▁{ ▁int ▁alpha _ v ▁, ▁alpha _ h ▁, ▁alpha ▁; ▁if ▁( ▁h sub ▁&& ▁v sub ▁&& ▁j ▁+ ▁1 ▁< ▁hp ▁&& ▁k ▁+ ▁1 ▁< ▁wp ▁) ▁{ ▁alpha ▁= ▁( ▁a ▁[ ▁0 ▁] ▁+ ▁a ▁[ ▁src ▁-> ▁linesize ▁[ ▁3 ▁] ▁] ▁+ ▁a ▁[ ▁1 ▁] ▁+ ▁a ▁[ ▁src ▁-> ▁linesize ▁[ ▁3 ▁] ▁+ ▁1 ▁] ▁) ▁>> ▁2 ▁; ▁} ▁else ▁if ▁( ▁h sub ▁|| ▁v sub ▁) ▁{ ▁alpha _ h ▁= ▁h sub ▁&& ▁k ▁+ ▁1 ▁< ▁wp ▁? ▁( ▁a ▁[ ▁0 ▁] ▁+ ▁a ▁[ ▁1 ▁] ▁) ▁>> ▁1 ▁: ▁a ▁[ ▁0 ▁] ▁; ▁alpha _ v ▁= ▁v sub ▁&& ▁j ▁+ ▁1 ▁< ▁hp ▁? ▁( ▁a ▁[ ▁0 ▁] ▁+ ▁a ▁[ ▁src ▁-> ▁linesize ▁[ ▁3 ▁] ▁] ▁) ▁>> ▁1 ▁: ▁a ▁[ ▁0 ▁] ▁; ▁alpha ▁= ▁( ▁alpha _ v ▁+ ▁alpha _ h ▁) ▁>> ▁1 ▁; ▁} ▁else ▁alpha ▁= ▁a ▁[ ▁0 ▁] ▁; ▁* ▁d ▁= ▁FAST _ DIV 255 ▁( ▁* ▁d ▁* ▁( ▁255 ▁- ▁alpha ▁) ▁+ ▁* ▁s ▁* ▁alpha ▁) ▁; ▁s ▁++ ▁; ▁d ▁++ ▁; ▁a ▁+= ▁1 ▁<< ▁h sub ▁; ▁} ▁dp ▁+= ▁dst ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁sp ▁+= ▁src ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁ap ▁+= ▁( ▁1 ▁<< ▁v sub ▁) ▁* ▁src ▁-> ▁linesize ▁[ ▁3 ▁] ▁; ▁} ▁} ▁} ▁}	1
▁int ▁tls 13_ export _ key ing _ material ▁( ▁SSL ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁size _ t ▁olen ▁, ▁const ▁char ▁* ▁label ▁, ▁size _ t ▁l len ▁, ▁const ▁unsigned ▁char ▁* ▁context ▁, ▁size _ t ▁context len ▁, ▁int ▁use _ context ▁) ▁{ ▁unsigned ▁char ▁export secret ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁static ▁const ▁unsigned ▁char ▁exporter label ▁[ ▁] ▁= ▁" export er " ▁; ▁unsigned ▁char ▁hash ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁const ▁EVP _ MD ▁* ▁md ▁= ▁ssl _ handshake _ md ▁( ▁s ▁) ▁; ▁EVP _ MD _ CTX ▁* ▁ctx ▁= ▁EVP _ MD _ CTX _ new ▁( ▁) ▁; ▁unsigned ▁int ▁hash size ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁|| ▁! ▁SSL _ is _ init _ finished ▁( ▁s ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁use _ context ▁) ▁context len ▁= ▁0 ▁; ▁if ▁( ▁EVP _ Digest Init _ ex ▁( ▁ctx ▁, ▁md ▁, ▁NULL ▁) ▁<= ▁0 ▁|| ▁EVP _ DigestUpdate ▁( ▁ctx ▁, ▁context ▁, ▁context len ▁) ▁<= ▁0 ▁|| ▁EVP _ Digest Final _ ex ▁( ▁ctx ▁, ▁hash ▁, ▁& ▁hash size ▁) ▁<= ▁0 ▁|| ▁! ▁tls 13_ h kdf _ expand ▁( ▁s ▁, ▁md ▁, ▁s ▁-> ▁exporter _ master _ secret ▁, ▁( ▁const ▁unsigned ▁char ▁* ▁) ▁label ▁, ▁l len ▁, ▁NULL ▁, ▁0 ▁, ▁export secret ▁, ▁hash size ▁) ▁|| ▁! ▁tls 13_ h kdf _ expand ▁( ▁s ▁, ▁md ▁, ▁export secret ▁, ▁exporter label ▁, ▁sizeof ▁( ▁exporter label ▁) ▁- ▁1 ▁, ▁hash ▁, ▁hash size ▁, ▁out ▁, ▁olen ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁EVP _ MD _ CTX _ free ▁( ▁ctx ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁UI _ set _ result _ ex ▁( ▁UI ▁* ▁ui ▁, ▁UI _ STRING ▁* ▁u is ▁, ▁const ▁char ▁* ▁result ▁, ▁int ▁len ▁) ▁{ ▁ui ▁-> ▁flags ▁&= ▁ ~ ▁UI _ FLAG _ RE DO ABLE ▁; ▁switch ▁( ▁u is ▁-> ▁type ▁) ▁{ ▁case ▁UIT _ PROMPT ▁: ▁case ▁UIT _ VERIFY ▁: ▁{ ▁char ▁number 1 ▁[ ▁DECIMAL _ SIZE ▁( ▁u is ▁-> ▁_ ▁. ▁string _ data ▁. ▁result _ min size ▁) ▁+ ▁1 ▁] ▁; ▁char ▁number 2 ▁[ ▁DECIMAL _ SIZE ▁( ▁u is ▁-> ▁_ ▁. ▁string _ data ▁. ▁result _ max size ▁) ▁+ ▁1 ▁] ▁; ▁BIO _ snprintf ▁( ▁number 1 ▁, ▁sizeof ▁( ▁number 1 ▁) ▁, ▁"% d " ▁, ▁u is ▁-> ▁_ ▁. ▁string _ data ▁. ▁result _ min size ▁) ▁; ▁BIO _ snprintf ▁( ▁number 2 ▁, ▁sizeof ▁( ▁number 2 ▁) ▁, ▁"% d " ▁, ▁u is ▁-> ▁_ ▁. ▁string _ data ▁. ▁result _ max size ▁) ▁; ▁if ▁( ▁len ▁< ▁u is ▁-> ▁_ ▁. ▁string _ data ▁. ▁result _ min size ▁) ▁{ ▁ui ▁-> ▁flags ▁|= ▁UI _ FLAG _ RE DO ABLE ▁; ▁UI err ▁( ▁UI _ F _ UI _ SET _ RESULT _ EX ▁, ▁UI _ R _ RESULT _ TOO _ SMALL ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁5 ▁, ▁" Y o um ust type in " ▁, ▁number 1 ▁, ▁" to " ▁, ▁number 2 ▁, ▁" char acters " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁len ▁> ▁u is ▁-> ▁_ ▁. ▁string _ data ▁. ▁result _ max size ▁) ▁{ ▁ui ▁-> ▁flags ▁|= ▁UI _ FLAG _ RE DO ABLE ▁; ▁UI err ▁( ▁UI _ F _ UI _ SET _ RESULT _ EX ▁, ▁UI _ R _ RESULT _ TOO _ LARGE ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁5 ▁, ▁" Y o um ust type in " ▁, ▁number 1 ▁, ▁" to " ▁, ▁number 2 ▁, ▁" char acters " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁} ▁if ▁( ▁u is ▁-> ▁result _ buf ▁== ▁NULL ▁) ▁{ ▁UI err ▁( ▁UI _ F _ UI _ SET _ RESULT _ EX ▁, ▁UI _ R _ NO _ RESULT _ BUFFER ▁) ▁; ▁return ▁-1 ▁; ▁} ▁memcpy ▁( ▁u is ▁-> ▁result _ buf ▁, ▁result ▁, ▁len ▁) ▁; ▁if ▁( ▁len ▁<= ▁u is ▁-> ▁_ ▁. ▁string _ data ▁. ▁result _ max size ▁) ▁u is ▁-> ▁result _ buf ▁[ ▁len ▁] ▁= ▁' ▁\0 ▁' ▁; ▁u is ▁-> ▁result _ len ▁= ▁len ▁; ▁break ▁; ▁case ▁UIT _ BOOLEAN ▁: ▁{ ▁const ▁char ▁* ▁p ▁; ▁if ▁( ▁u is ▁-> ▁result _ buf ▁== ▁NULL ▁) ▁{ ▁UI err ▁( ▁UI _ F _ UI _ SET _ RESULT _ EX ▁, ▁UI _ R _ NO _ RESULT _ BUFFER ▁) ▁; ▁return ▁-1 ▁; ▁} ▁u is ▁-> ▁result _ buf ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁for ▁( ▁p ▁= ▁result ▁; ▁* ▁p ▁; ▁p ▁++ ▁) ▁{ ▁if ▁( ▁strchr ▁( ▁u is ▁-> ▁_ ▁. ▁boolean _ data ▁. ▁ok _ chars ▁, ▁* ▁p ▁) ▁) ▁{ ▁u is ▁-> ▁result _ buf ▁[ ▁0 ▁] ▁= ▁u is ▁-> ▁_ ▁. ▁boolean _ data ▁. ▁ok _ chars ▁[ ▁0 ▁] ▁; ▁break ▁; ▁} ▁if ▁( ▁strchr ▁( ▁u is ▁-> ▁_ ▁. ▁boolean _ data ▁. ▁cancel _ chars ▁, ▁* ▁p ▁) ▁) ▁{ ▁u is ▁-> ▁result _ buf ▁[ ▁0 ▁] ▁= ▁u is ▁-> ▁_ ▁. ▁boolean _ data ▁. ▁cancel _ chars ▁[ ▁0 ▁] ▁; ▁break ▁; ▁} ▁} ▁} ▁case ▁UIT _ NONE ▁: ▁case ▁UIT _ INFO ▁: ▁case ▁UIT _ ERROR ▁: ▁break ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁ssl _ add _ cert _ to _ buf ▁( ▁BUF _ MEM ▁* ▁buf ▁, ▁unsigned ▁long ▁* ▁l ▁, ▁X 509 ▁* ▁x ▁) ▁{ ▁int ▁n ▁; ▁unsigned ▁char ▁* ▁p ▁; ▁n ▁= ▁i 2 d _ X 509 ▁( ▁x ▁, ▁NULL ▁) ▁; ▁if ▁( ▁n ▁< ▁0 ▁|| ▁! ▁BUF _ MEM _ grow _ clean ▁( ▁buf ▁, ▁( ▁int ▁) ▁( ▁n ▁+ ▁( ▁* ▁l ▁) ▁+ ▁3 ▁) ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ ADD _ CERT _ TO _ BUF ▁, ▁ERR _ R _ BUF _ LIB ▁) ▁; ▁return ▁0 ▁; ▁} ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁( ▁buf ▁-> ▁data ▁[ ▁* ▁l ▁] ▁) ▁; ▁l 2 n 3 ▁( ▁n ▁, ▁p ▁) ▁; ▁n ▁= ▁i 2 d _ X 509 ▁( ▁x ▁, ▁& ▁p ▁) ▁; ▁if ▁( ▁n ▁< ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ ADD _ CERT _ TO _ BUF ▁, ▁ERR _ R _ BUF _ LIB ▁) ▁; ▁return ▁0 ▁; ▁} ▁* ▁l ▁+= ▁n ▁+ ▁3 ▁; ▁return ▁1 ▁; ▁}	0
▁int ▁ssl 3_ send _ client _ verify ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁, ▁* ▁d ▁; ▁unsigned ▁char ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁+ ▁SHA _ DIGEST _ LENGTH ▁] ▁; ▁EVP _ PKEY ▁* ▁pkey ▁; ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁= ▁NULL ▁; ▁EVP _ MD _ CTX ▁mctx ▁; ▁unsigned ▁u ▁= ▁0 ▁; ▁unsigned ▁long ▁n ▁; ▁int ▁j ▁; ▁EVP _ MD _ CTX _ init ▁( ▁& ▁mctx ▁) ▁; ▁if ▁( ▁s ▁-> ▁state ▁== ▁SSL 3_ ST _ CW _ CERT _ V RF Y _ A ▁) ▁{ ▁d ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁s ▁-> ▁init _ buf ▁-> ▁data ▁; ▁p ▁= ▁& ▁( ▁d ▁[ ▁4 ▁] ▁) ▁; ▁pkey ▁= ▁s ▁-> ▁cert ▁-> ▁key ▁-> ▁private key ▁; ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new ▁( ▁pkey ▁, ▁NULL ▁) ▁; ▁EVP _ PKEY _ sign _ init ▁( ▁pctx ▁) ▁; ▁if ▁( ▁EVP _ PKEY _ CTX _ set _ signature _ md ▁( ▁pctx ▁, ▁EVP _ sha 1 ▁( ▁) ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁version ▁< ▁TLS 1_ 2_ VERSION ▁) ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ sha 1 ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁ERR _ clear _ error ▁( ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁version ▁>= ▁TLS 1_ 2_ VERSION ▁) ▁{ ▁long ▁hd atal en ▁= ▁0 ▁; ▁void ▁* ▁h data ▁; ▁const ▁EVP _ MD ▁* ▁md ▁= ▁s ▁-> ▁cert ▁-> ▁key ▁-> ▁digest ▁; ▁hd atal en ▁= ▁BIO _ get _ mem _ data ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ buffer ▁, ▁& ▁h data ▁) ▁; ▁if ▁( ▁hd atal en ▁<= ▁0 ▁|| ▁! ▁tls 12_ get _ sig and hash ▁( ▁p ▁, ▁pkey ▁, ▁md ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁p ▁+= ▁2 ▁; ▁# ifdef ▁SSL _ DEBUG ▁fprintf ▁( ▁stderr ▁, ▁" Using TLS 1.2 with client alg % s \ n " ▁, ▁EVP _ MD _ name ▁( ▁md ▁) ▁) ▁; ▁# endif ▁if ▁( ▁! ▁EVP _ Sign Init _ ex ▁( ▁& ▁mctx ▁, ▁md ▁, ▁NULL ▁) ▁|| ▁! ▁EVP _ Sign Update ▁( ▁& ▁mctx ▁, ▁h data ▁, ▁hd atal en ▁) ▁|| ▁! ▁EVP _ Sign Final ▁( ▁& ▁mctx ▁, ▁p ▁+ ▁2 ▁, ▁& ▁u ▁, ▁pkey ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ EVP _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁u ▁, ▁p ▁) ▁; ▁n ▁= ▁u ▁+ ▁4 ▁; ▁if ▁( ▁! ▁ssl 3_ digest _ cached _ records ▁( ▁s ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ RSA ▁) ▁{ ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ md 5 ▁, ▁& ▁( ▁data ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁RSA _ sign ▁( ▁NID _ md 5_ sha 1 ▁, ▁data ▁, ▁MD 5_ DIGEST _ LENGTH ▁+ ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁& ▁u ▁, ▁pkey ▁-> ▁pkey ▁. ▁rsa ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ RSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁u ▁, ▁p ▁) ▁; ▁n ▁= ▁u ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DSA ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ DSA ▁) ▁{ ▁if ▁( ▁! ▁DSA _ sign ▁( ▁pkey ▁-> ▁save _ type ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁, ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁( ▁unsigned ▁int ▁* ▁) ▁& ▁j ▁, ▁pkey ▁-> ▁pkey ▁. ▁dsa ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ DSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDSA ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ EC ▁) ▁{ ▁if ▁( ▁! ▁ECDSA _ sign ▁( ▁pkey ▁-> ▁save _ type ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁, ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁( ▁unsigned ▁int ▁* ▁) ▁& ▁j ▁, ▁pkey ▁-> ▁pkey ▁. ▁ec ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ ECDSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁NID _ id _ G ost R 34 10_ 94 ▁|| ▁pkey ▁-> ▁type ▁== ▁NID _ id _ G ost R 34 10 _2 001 ▁) ▁{ ▁unsigned ▁char ▁sign buf ▁[ ▁64 ▁] ▁; ▁int ▁i ▁; ▁size _ t ▁sig size ▁= ▁64 ▁; ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ id _ G ost R 34 11_ 94 ▁, ▁data ▁) ▁; ▁if ▁( ▁EVP _ PKEY _ sign ▁( ▁pctx ▁, ▁sign buf ▁, ▁& ▁sig size ▁, ▁data ▁, ▁32 ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁for ▁( ▁i ▁= ▁63 ▁, ▁j ▁= ▁0 ▁; ▁i ▁>= ▁0 ▁; ▁j ▁++ ▁, ▁i ▁-- ▁) ▁{ ▁p ▁[ ▁2 ▁+ ▁j ▁] ▁= ▁sign buf ▁[ ▁i ▁] ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁* ▁( ▁d ▁++ ▁) ▁= ▁SSL 3_ MT _ CERTIFICATE _ VERIFY ▁; ▁l 2 n 3 ▁( ▁n ▁, ▁d ▁) ▁; ▁s ▁-> ▁state ▁= ▁SSL 3_ ST _ CW _ CERT _ V RF Y _ B ▁; ▁s ▁-> ▁init _ num ▁= ▁( ▁int ▁) ▁n ▁+ ▁4 ▁; ▁s ▁-> ▁init _ off ▁= ▁0 ▁; ▁} ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁mctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁( ▁ssl 3_ do _ write ▁( ▁s ▁, ▁SSL 3_ RT _ HAND SHAKE ▁) ▁) ▁; ▁err ▁: ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁mctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁( ▁-1 ▁) ▁; ▁}	0
▁static ▁int ▁boundary _ strength ▁( ▁H EV C Context ▁* ▁s ▁, ▁M v Field ▁* ▁curr ▁, ▁uint 8_ t ▁curr _ cb f _ l uma ▁, ▁M v Field ▁* ▁neigh ▁, ▁uint 8_ t ▁neigh _ cb f _ l uma ▁, ▁Ref Pic List ▁* ▁neigh _ ref Pic List ▁, ▁int ▁tu _ border ▁) ▁{ ▁int ▁m vs ▁= ▁curr ▁-> ▁pred _ flag ▁[ ▁0 ▁] ▁+ ▁curr ▁-> ▁pred _ flag ▁[ ▁1 ▁] ▁; ▁if ▁( ▁tu _ border ▁) ▁{ ▁if ▁( ▁curr ▁-> ▁is _ intra ▁|| ▁neigh ▁-> ▁is _ intra ▁) ▁return ▁2 ▁; ▁if ▁( ▁curr _ cb f _ l uma ▁|| ▁neigh _ cb f _ l uma ▁) ▁return ▁1 ▁; ▁} ▁if ▁( ▁m vs ▁== ▁neigh ▁-> ▁pred _ flag ▁[ ▁0 ▁] ▁+ ▁neigh ▁-> ▁pred _ flag ▁[ ▁1 ▁] ▁) ▁{ ▁if ▁( ▁m vs ▁== ▁2 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁== ▁neigh _ ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁&& ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁== ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁&& ▁neigh _ ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁== ▁neigh _ ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁) ▁{ ▁if ▁( ▁( ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁) ▁&& ▁( ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁) ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁neigh _ ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁== ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁&& ▁neigh _ ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁== ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁) ▁{ ▁if ▁( ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁neigh _ ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁== ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁&& ▁neigh _ ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁== ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁) ▁{ ▁if ▁( ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁x ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁. ▁y ▁- ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁. ▁y ▁) ▁>= ▁4 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁else ▁{ ▁return ▁1 ▁; ▁} ▁} ▁else ▁{ ▁M v ▁A ▁, ▁B ▁; ▁int ▁ref _ A ▁, ▁ref _ B ▁; ▁if ▁( ▁curr ▁-> ▁pred _ flag ▁[ ▁0 ▁] ▁) ▁{ ▁A ▁= ▁curr ▁-> ▁mv ▁[ ▁0 ▁] ▁; ▁ref _ A ▁= ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁; ▁} ▁else ▁{ ▁A ▁= ▁curr ▁-> ▁mv ▁[ ▁1 ▁] ▁; ▁ref _ A ▁= ▁s ▁-> ▁ref ▁-> ▁ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁curr ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁; ▁} ▁if ▁( ▁neigh ▁-> ▁pred _ flag ▁[ ▁0 ▁] ▁) ▁{ ▁B ▁= ▁neigh ▁-> ▁mv ▁[ ▁0 ▁] ▁; ▁ref _ B ▁= ▁neigh _ ref Pic List ▁[ ▁0 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁0 ▁] ▁] ▁; ▁} ▁else ▁{ ▁B ▁= ▁neigh ▁-> ▁mv ▁[ ▁1 ▁] ▁; ▁ref _ B ▁= ▁neigh _ ref Pic List ▁[ ▁1 ▁] ▁. ▁list ▁[ ▁neigh ▁-> ▁ref _ idx ▁[ ▁1 ▁] ▁] ▁; ▁} ▁if ▁( ▁ref _ A ▁== ▁ref _ B ▁) ▁{ ▁if ▁( ▁abs ▁( ▁A ▁. ▁x ▁- ▁B ▁. ▁x ▁) ▁>= ▁4 ▁|| ▁abs ▁( ▁A ▁. ▁y ▁- ▁B ▁. ▁y ▁) ▁>= ▁4 ▁) ▁return ▁1 ▁; ▁else ▁return ▁0 ▁; ▁} ▁else ▁return ▁1 ▁; ▁} ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁apr _ status _ t ▁slot mem _ attach ▁( ▁ap _ slot mem _ instance _ t ▁* ▁* ▁new ▁, ▁const ▁char ▁* ▁name ▁, ▁apr _ size _ t ▁* ▁item _ size ▁, ▁unsigned ▁int ▁* ▁item _ num ▁, ▁apr _ pool _ t ▁* ▁pool ▁) ▁{ ▁char ▁* ▁ptr ▁; ▁ap _ slot mem _ instance _ t ▁* ▁res ▁; ▁ap _ slot mem _ instance _ t ▁* ▁next ▁= ▁glob all ist mem ▁; ▁share ds lot desc _ t ▁* ▁desc ▁; ▁const ▁char ▁* ▁fname ▁; ▁apr _ shm _ t ▁* ▁shm ▁; ▁apr _ status _ t ▁rv ▁; ▁if ▁( ▁g pool ▁== ▁NULL ▁) ▁{ ▁return ▁APR _ ENO SH MA V AIL ▁; ▁} ▁if ▁( ▁! ▁slot mem _ fil enames ▁( ▁pool ▁, ▁name ▁, ▁& ▁fname ▁, ▁NULL ▁) ▁) ▁{ ▁return ▁APR _ ENO SH MA V AIL ▁; ▁} ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁AP LOG NO ▁( ▁0 23 01 ▁) ▁" attach look ing for % s " ▁, ▁fname ▁) ▁; ▁if ▁( ▁next ▁) ▁{ ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁strcmp ▁( ▁next ▁-> ▁name ▁, ▁fname ▁) ▁== ▁0 ▁) ▁{ ▁* ▁new ▁= ▁next ▁; ▁* ▁item _ size ▁= ▁next ▁-> ▁desc ▁-> ▁size ▁; ▁* ▁item _ num ▁= ▁next ▁-> ▁desc ▁-> ▁num ▁; ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁AP LOG NO ▁( ▁0 23 02 ▁) ▁" attach found % s :% " ▁APR _ SIZE _ T _ FMT ▁"/ % u " ▁, ▁fname ▁, ▁* ▁item _ size ▁, ▁* ▁item _ num ▁) ▁; ▁return ▁APR _ SUCCESS ▁; ▁} ▁if ▁( ▁! ▁next ▁-> ▁next ▁) ▁{ ▁break ▁; ▁} ▁next ▁= ▁next ▁-> ▁next ▁; ▁} ▁} ▁rv ▁= ▁apr _ shm _ attach ▁( ▁& ▁shm ▁, ▁fname ▁, ▁g pool ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁rv ▁; ▁} ▁desc ▁= ▁( ▁share ds lot desc _ t ▁* ▁) ▁apr _ shm _ base addr _ get ▁( ▁shm ▁) ▁; ▁ptr ▁= ▁( ▁char ▁* ▁) ▁desc ▁+ ▁AP _ SLOT MEM _ OFFSET ▁; ▁res ▁= ▁apr _ pc alloc ▁( ▁g pool ▁, ▁sizeof ▁( ▁ap _ slot mem _ instance _ t ▁) ▁) ▁; ▁res ▁-> ▁name ▁= ▁apr _ p strdup ▁( ▁g pool ▁, ▁fname ▁) ▁; ▁res ▁-> ▁f based ▁= ▁1 ▁; ▁res ▁-> ▁shm ▁= ▁shm ▁; ▁res ▁-> ▁persist ▁= ▁( ▁void ▁* ▁) ▁ptr ▁; ▁res ▁-> ▁num _ free ▁= ▁( ▁unsigned ▁int ▁* ▁) ▁ptr ▁; ▁ptr ▁+= ▁AP _ UNSIGNED INT _ OFFSET ▁; ▁res ▁-> ▁base ▁= ▁( ▁void ▁* ▁) ▁ptr ▁; ▁res ▁-> ▁desc ▁= ▁desc ▁; ▁res ▁-> ▁g pool ▁= ▁g pool ▁; ▁res ▁-> ▁in use ▁= ▁ptr ▁+ ▁( ▁desc ▁-> ▁size ▁* ▁desc ▁-> ▁num ▁) ▁; ▁res ▁-> ▁next ▁= ▁NULL ▁; ▁* ▁new ▁= ▁res ▁; ▁* ▁item _ size ▁= ▁desc ▁-> ▁size ▁; ▁* ▁item _ num ▁= ▁desc ▁-> ▁num ▁; ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁AP LOG NO ▁( ▁02 303 ▁) ▁" attach found % s :% " ▁APR _ SIZE _ T _ FMT ▁"/ % u " ▁, ▁fname ▁, ▁* ▁item _ size ▁, ▁* ▁item _ num ▁) ▁; ▁return ▁APR _ SUCCESS ▁; ▁}	0
▁int ▁hash _ block ▁( ▁g ost _ hash _ ctx ▁* ▁ctx ▁, ▁const ▁byte ▁* ▁block ▁, ▁size _ t ▁length ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁left ▁) ▁{ ▁unsigned ▁int ▁add _ bytes ▁= ▁32 ▁- ▁ctx ▁-> ▁left ▁; ▁if ▁( ▁add _ bytes ▁> ▁length ▁) ▁{ ▁add _ bytes ▁= ▁length ▁; ▁} ▁memcpy ▁( ▁& ▁( ▁ctx ▁-> ▁remainder ▁[ ▁ctx ▁-> ▁left ▁] ▁) ▁, ▁block ▁, ▁add _ bytes ▁) ▁; ▁ctx ▁-> ▁left ▁+= ▁add _ bytes ▁; ▁if ▁( ▁ctx ▁-> ▁left ▁< ▁32 ▁) ▁{ ▁return ▁1 ▁; ▁} ▁block ▁+= ▁add _ bytes ▁; ▁length ▁-= ▁add _ bytes ▁; ▁hash _ step ▁( ▁ctx ▁-> ▁cipher _ ctx ▁, ▁ctx ▁-> ▁H ▁, ▁ctx ▁-> ▁remainder ▁) ▁; ▁add _ blocks ▁( ▁32 ▁, ▁ctx ▁-> ▁S ▁, ▁ctx ▁-> ▁remainder ▁) ▁; ▁ctx ▁-> ▁len ▁+= ▁32 ▁; ▁ctx ▁-> ▁left ▁= ▁0 ▁; ▁} ▁while ▁( ▁length ▁>= ▁32 ▁) ▁{ ▁hash _ step ▁( ▁ctx ▁-> ▁cipher _ ctx ▁, ▁ctx ▁-> ▁H ▁, ▁block ▁) ▁; ▁add _ blocks ▁( ▁32 ▁, ▁ctx ▁-> ▁S ▁, ▁block ▁) ▁; ▁ctx ▁-> ▁len ▁+= ▁32 ▁; ▁block ▁+= ▁32 ▁; ▁length ▁-= ▁32 ▁; ▁} ▁if ▁( ▁length ▁) ▁{ ▁memcpy ▁( ▁ctx ▁-> ▁remainder ▁, ▁block ▁, ▁ctx ▁-> ▁left ▁= ▁length ▁) ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁allocate _ buffers ▁( ▁Short en Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁chan ▁; ▁int ▁* ▁coeffs ▁; ▁for ▁( ▁chan ▁= ▁0 ▁; ▁chan ▁< ▁s ▁-> ▁channels ▁; ▁chan ▁++ ▁) ▁{ ▁if ▁( ▁FF MAX ▁( ▁1 ▁, ▁s ▁-> ▁n mean ▁) ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁int 32_ t ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" n me ant ool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁s ▁-> ▁blocksize ▁+ ▁s ▁-> ▁n wrap ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁int 32_ t ▁) ▁|| ▁s ▁-> ▁blocksize ▁+ ▁s ▁-> ▁n wrap ▁<= ▁( ▁unsigned ▁) ▁s ▁-> ▁n wrap ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" s -> blocksize + s -> nw ra pt ool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁offset ▁[ ▁chan ▁] ▁= ▁av _ realloc ▁( ▁s ▁-> ▁offset ▁[ ▁chan ▁] ▁, ▁sizeof ▁( ▁int 32_ t ▁) ▁* ▁FF MAX ▁( ▁1 ▁, ▁s ▁-> ▁n mean ▁) ▁) ▁; ▁s ▁-> ▁decoded ▁[ ▁chan ▁] ▁= ▁av _ realloc ▁( ▁s ▁-> ▁decoded ▁[ ▁chan ▁] ▁, ▁sizeof ▁( ▁int 32_ t ▁) ▁* ▁( ▁s ▁-> ▁blocksize ▁+ ▁s ▁-> ▁n wrap ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n wrap ▁; ▁i ▁++ ▁) ▁s ▁-> ▁decoded ▁[ ▁chan ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁s ▁-> ▁decoded ▁[ ▁chan ▁] ▁+= ▁s ▁-> ▁n wrap ▁; ▁} ▁coeffs ▁= ▁av _ realloc ▁( ▁s ▁-> ▁coeffs ▁, ▁s ▁-> ▁n wrap ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁coeffs ▁) ▁) ▁; ▁if ▁( ▁! ▁coeffs ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁coeffs ▁= ▁coeffs ▁; ▁return ▁0 ▁; ▁}	1
▁SSL _ CTX ▁* ▁SSL _ CTX _ new ▁( ▁SSL _ METHOD ▁* ▁meth ▁) ▁{ ▁SSL _ CTX ▁* ▁ret ▁= ▁NULL ▁; ▁if ▁( ▁meth ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ NULL _ SSL _ METHOD _ PASSED ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁if ▁( ▁SSL _ get _ ex _ data _ X 509_ STORE _ CTX _ idx ▁( ▁) ▁< ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ X 509_ VER IFICATION _ SETUP _ PRO BLE MS ▁) ▁; ▁goto ▁err ▁; ▁} ▁ret ▁= ▁( ▁SSL _ CTX ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁SSL _ CTX ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁memset ▁( ▁ret ▁, ▁0 ▁, ▁sizeof ▁( ▁SSL _ CTX ▁) ▁) ▁; ▁ret ▁-> ▁method ▁= ▁meth ▁; ▁ret ▁-> ▁cert _ store ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ cache _ mode ▁= ▁SSL _ S ESS _ CACHE _ SERVER ▁; ▁ret ▁-> ▁session _ cache _ size ▁= ▁SSL _ SESSION _ CACHE _ MAX _ SIZE _ DEFAULT ▁; ▁ret ▁-> ▁session _ cache _ head ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ cache _ tail ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ timeout ▁= ▁meth ▁-> ▁get _ timeout ▁( ▁) ▁; ▁ret ▁-> ▁new _ session _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁remove _ session _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁get _ session _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁generate _ session _ id ▁= ▁NULL ▁; ▁memset ▁( ▁( ▁char ▁* ▁) ▁& ▁ret ▁-> ▁stats ▁, ▁0 ▁, ▁sizeof ▁( ▁ret ▁-> ▁stats ▁) ▁) ▁; ▁ret ▁-> ▁references ▁= ▁1 ▁; ▁ret ▁-> ▁quiet _ shutdown ▁= ▁0 ▁; ▁ret ▁-> ▁info _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁app _ verify _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁app _ verify _ arg ▁= ▁NULL ▁; ▁ret ▁-> ▁read _ ahead ▁= ▁0 ▁; ▁ret ▁-> ▁verify _ mode ▁= ▁SSL _ VERIFY _ NONE ▁; ▁ret ▁-> ▁verify _ depth ▁= ▁-1 ▁; ▁ret ▁-> ▁default _ verify _ callback ▁= ▁NULL ▁; ▁if ▁( ▁( ▁ret ▁-> ▁cert ▁= ▁ssl _ cert _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁default _ passwd _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁default _ passwd _ callback _ userdata ▁= ▁NULL ▁; ▁ret ▁-> ▁client _ cert _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁sessions ▁= ▁lh _ new ▁( ▁L HASH _ HASH _ FN ▁( ▁SSL _ SESSION _ hash ▁) ▁, ▁L HASH _ COMP _ FN ▁( ▁SSL _ SESSION _ cmp ▁) ▁) ▁; ▁if ▁( ▁ret ▁-> ▁sessions ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁cert _ store ▁= ▁X 509_ STORE _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cert _ store ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ssl _ create _ cipher _ list ▁( ▁ret ▁-> ▁method ▁, ▁& ▁ret ▁-> ▁cipher _ list ▁, ▁& ▁ret ▁-> ▁cipher _ list _ by _ id ▁, ▁SSL _ DEFAULT _ CIPHER _ LIST ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cipher _ list ▁== ▁NULL ▁|| ▁sk _ SSL _ CIPHER _ num ▁( ▁ret ▁-> ▁cipher _ list ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ LIBRARY _ HAS _ NO _ CIPHER S ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁rsa _ md 5 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 2- md 5" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 2_ MD 5_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁md 5 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- md 5" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ MD 5_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁sha 1 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- sha 1" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ SHA 1_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁client _ CA ▁= ▁sk _ X 509_ NAME _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁CRYPTO _ new _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL _ CTX ▁, ▁ret ▁, ▁& ▁ret ▁-> ▁ex _ data ▁) ▁; ▁ret ▁-> ▁extra _ certs ▁= ▁NULL ▁; ▁ret ▁-> ▁comp _ methods ▁= ▁SSL _ COMP _ get _ compression _ methods ▁( ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁err ▁: ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁err 2 ▁: ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁SSL _ CTX _ free ▁( ▁ret ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	1
▁size _ t ▁ec _ GF 2 m _ simple _ point 2 oct ▁( ▁const ▁EC _ GROUP ▁* ▁group ▁, ▁const ▁EC _ POINT ▁* ▁point ▁, ▁point _ conversion _ form _ t ▁form ▁, ▁unsigned ▁char ▁* ▁buf ▁, ▁size _ t ▁len ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁size _ t ▁ret ▁; ▁BN _ CTX ▁* ▁new _ ctx ▁= ▁NULL ▁; ▁int ▁used _ ctx ▁= ▁0 ▁; ▁BIGNUM ▁* ▁x ▁, ▁* ▁y ▁, ▁* ▁y xi ▁; ▁size _ t ▁field _ len ▁, ▁i ▁, ▁skip ▁; ▁if ▁( ▁( ▁form ▁!= ▁POINT _ CONVERSION _ COMPRESSED ▁) ▁&& ▁( ▁form ▁!= ▁POINT _ CONVERSION _ UN COMPRESSED ▁) ▁&& ▁( ▁form ▁!= ▁POINT _ CONVERSION _ HY BR ID ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GF 2 M _ SIMPLE _ POINT 2 O CT ▁, ▁EC _ R _ INVALID _ FORM ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁EC _ POINT _ is _ at _ infinity ▁( ▁group ▁, ▁point ▁) ▁) ▁{ ▁if ▁( ▁buf ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁len ▁< ▁1 ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GF 2 M _ SIMPLE _ POINT 2 O CT ▁, ▁EC _ R _ BUFFER _ TOO _ SMALL ▁) ▁; ▁return ▁0 ▁; ▁} ▁buf ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁} ▁return ▁1 ▁; ▁} ▁field _ len ▁= ▁( ▁EC _ GROUP _ get _ degree ▁( ▁group ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁ret ▁= ▁( ▁form ▁== ▁POINT _ CONVERSION _ COMPRESSED ▁) ▁? ▁1 ▁+ ▁field _ len ▁: ▁1 ▁+ ▁2 ▁* ▁field _ len ▁; ▁if ▁( ▁buf ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁len ▁< ▁ret ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GF 2 M _ SIMPLE _ POINT 2 O CT ▁, ▁EC _ R _ BUFFER _ TOO _ SMALL ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁ctx ▁= ▁new _ ctx ▁= ▁BN _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁} ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁used _ ctx ▁= ▁1 ▁; ▁x ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁y ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁y xi ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁y xi ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EC _ POINT _ get _ aff ine _ coordinates _ GF 2 m ▁( ▁group ▁, ▁point ▁, ▁x ▁, ▁y ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁buf ▁[ ▁0 ▁] ▁= ▁form ▁; ▁if ▁( ▁( ▁form ▁!= ▁POINT _ CONVERSION _ UN COMPRESSED ▁) ▁&& ▁! ▁BN _ is _ zero ▁( ▁x ▁) ▁) ▁{ ▁if ▁( ▁! ▁group ▁-> ▁meth ▁-> ▁field _ div ▁( ▁group ▁, ▁y xi ▁, ▁y ▁, ▁x ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ is _ odd ▁( ▁y xi ▁) ▁) ▁buf ▁[ ▁0 ▁] ▁++ ▁; ▁} ▁i ▁= ▁1 ▁; ▁skip ▁= ▁field _ len ▁- ▁BN _ num _ bytes ▁( ▁x ▁) ▁; ▁if ▁( ▁skip ▁> ▁field _ len ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GF 2 M _ SIMPLE _ POINT 2 O CT ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁while ▁( ▁skip ▁> ▁0 ▁) ▁{ ▁buf ▁[ ▁i ▁++ ▁] ▁= ▁0 ▁; ▁skip ▁-- ▁; ▁} ▁skip ▁= ▁BN _ bn 2 bin ▁( ▁x ▁, ▁buf ▁+ ▁i ▁) ▁; ▁i ▁+= ▁skip ▁; ▁if ▁( ▁i ▁!= ▁1 ▁+ ▁field _ len ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GF 2 M _ SIMPLE _ POINT 2 O CT ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁form ▁== ▁POINT _ CONVERSION _ UN COMPRESSED ▁|| ▁form ▁== ▁POINT _ CONVERSION _ HY BR ID ▁) ▁{ ▁skip ▁= ▁field _ len ▁- ▁BN _ num _ bytes ▁( ▁y ▁) ▁; ▁if ▁( ▁skip ▁> ▁field _ len ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GF 2 M _ SIMPLE _ POINT 2 O CT ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁while ▁( ▁skip ▁> ▁0 ▁) ▁{ ▁buf ▁[ ▁i ▁++ ▁] ▁= ▁0 ▁; ▁skip ▁-- ▁; ▁} ▁skip ▁= ▁BN _ bn 2 bin ▁( ▁y ▁, ▁buf ▁+ ▁i ▁) ▁; ▁i ▁+= ▁skip ▁; ▁} ▁if ▁( ▁i ▁!= ▁ret ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GF 2 M _ SIMPLE _ POINT 2 O CT ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁if ▁( ▁used _ ctx ▁) ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁BN _ CTX _ free ▁( ▁new _ ctx ▁) ▁; ▁return ▁ret ▁; ▁err ▁: ▁if ▁( ▁used _ ctx ▁) ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁BN _ CTX _ free ▁( ▁new _ ctx ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁char ▁* ▁BUF _ str ndup ▁( ▁const ▁char ▁* ▁str ▁, ▁size _ t ▁siz ▁) ▁{ ▁char ▁* ▁ret ▁; ▁if ▁( ▁str ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁siz ▁= ▁BUF _ strn len ▁( ▁str ▁, ▁siz ▁) ▁; ▁if ▁( ▁siz ▁>= ▁INT _ MAX ▁) ▁return ▁NULL ▁; ▁ret ▁= ▁OPENSSL _ malloc ▁( ▁siz ▁+ ▁1 ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁BUF err ▁( ▁BUF _ F _ BUF _ STR ND UP ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁memcpy ▁( ▁ret ▁, ▁str ▁, ▁siz ▁) ▁; ▁ret ▁[ ▁siz ▁] ▁= ▁' ▁\0 ▁' ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁static ▁void ▁fmt fp ▁( ▁void ▁( ▁* ▁out ch _ fn ▁) ▁( ▁char ▁* ▁* ▁, ▁size _ t ▁* ▁, ▁size _ t ▁* ▁, ▁int ▁) ▁, ▁char ▁* ▁* ▁buffer ▁, ▁size _ t ▁* ▁curr len ▁, ▁size _ t ▁* ▁maxlen ▁, ▁L DOUBLE ▁f value ▁, ▁int ▁min ▁, ▁int ▁max ▁, ▁int ▁flags ▁) ▁{ ▁int ▁sign value ▁= ▁0 ▁; ▁L DOUBLE ▁uf value ▁; ▁char ▁icon vert ▁[ ▁20 ▁] ▁; ▁char ▁f convert ▁[ ▁20 ▁] ▁; ▁int ▁ip lace ▁= ▁0 ▁; ▁int ▁fp lace ▁= ▁0 ▁; ▁int ▁padlen ▁= ▁0 ▁; ▁int ▁z pad len ▁= ▁0 ▁; ▁int ▁caps ▁= ▁0 ▁; ▁long ▁int part ▁; ▁long ▁frac part ▁; ▁if ▁( ▁max ▁< ▁0 ▁) ▁max ▁= ▁6 ▁; ▁uf value ▁= ▁abs _ val ▁( ▁f value ▁) ▁; ▁if ▁( ▁f value ▁< ▁0 ▁) ▁sign value ▁= ▁' ▁' ▁; ▁else ▁if ▁( ▁flags ▁& ▁DP _ F _ PLUS ▁) ▁sign value ▁= ▁' ▁' ▁; ▁else ▁if ▁( ▁flags ▁& ▁DP _ F _ SPACE ▁) ▁sign value ▁= ▁' ▁' ▁; ▁int part ▁= ▁( ▁long ▁) ▁uf value ▁; ▁if ▁( ▁max ▁> ▁9 ▁) ▁max ▁= ▁9 ▁; ▁frac part ▁= ▁round ▁( ▁( ▁pow 10 ▁( ▁max ▁) ▁) ▁* ▁( ▁uf value ▁- ▁int part ▁) ▁) ▁; ▁if ▁( ▁frac part ▁>= ▁pow 10 ▁( ▁max ▁) ▁) ▁{ ▁int part ▁++ ▁; ▁frac part ▁-= ▁( ▁long ▁) ▁pow 10 ▁( ▁max ▁) ▁; ▁} ▁do ▁{ ▁icon vert ▁[ ▁ip lace ▁++ ▁] ▁= ▁( ▁caps ▁? ▁"0123456789 ABCDEF " ▁: ▁"0123456789 abcdef " ▁) ▁[ ▁int part ▁% ▁10 ▁] ▁; ▁int part ▁= ▁( ▁int part ▁/ ▁10 ▁) ▁; ▁} ▁while ▁( ▁int part ▁&& ▁( ▁ip lace ▁< ▁20 ▁) ▁) ▁; ▁if ▁( ▁ip lace ▁== ▁20 ▁) ▁ip lace ▁-- ▁; ▁icon vert ▁[ ▁ip lace ▁] ▁= ▁0 ▁; ▁do ▁{ ▁f convert ▁[ ▁fp lace ▁++ ▁] ▁= ▁( ▁caps ▁? ▁"0123456789 ABCDEF " ▁: ▁"0123456789 abcdef " ▁) ▁[ ▁frac part ▁% ▁10 ▁] ▁; ▁frac part ▁= ▁( ▁frac part ▁/ ▁10 ▁) ▁; ▁} ▁while ▁( ▁frac part ▁&& ▁( ▁fp lace ▁< ▁20 ▁) ▁) ▁; ▁if ▁( ▁fp lace ▁== ▁20 ▁) ▁fp lace ▁-- ▁; ▁f convert ▁[ ▁fp lace ▁] ▁= ▁0 ▁; ▁padlen ▁= ▁min ▁- ▁ip lace ▁- ▁max ▁- ▁1 ▁- ▁( ▁( ▁sign value ▁) ▁? ▁1 ▁: ▁0 ▁) ▁; ▁z pad len ▁= ▁max ▁- ▁fp lace ▁; ▁if ▁( ▁z pad len ▁< ▁0 ▁) ▁z pad len ▁= ▁0 ▁; ▁if ▁( ▁padlen ▁< ▁0 ▁) ▁padlen ▁= ▁0 ▁; ▁if ▁( ▁flags ▁& ▁DP _ F _ MINUS ▁) ▁padlen ▁= ▁- ▁padlen ▁; ▁if ▁( ▁( ▁flags ▁& ▁DP _ F _ ZERO ▁) ▁&& ▁( ▁padlen ▁> ▁0 ▁) ▁) ▁{ ▁if ▁( ▁sign value ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁sign value ▁) ▁; ▁-- ▁padlen ▁; ▁sign value ▁= ▁0 ▁; ▁} ▁while ▁( ▁padlen ▁> ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁padlen ▁; ▁} ▁} ▁while ▁( ▁padlen ▁> ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁padlen ▁; ▁} ▁if ▁( ▁sign value ▁) ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁sign value ▁) ▁; ▁while ▁( ▁ip lace ▁> ▁0 ▁) ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁icon vert ▁[ ▁-- ▁ip lace ▁] ▁) ▁; ▁if ▁( ▁max ▁> ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁while ▁( ▁fp lace ▁> ▁0 ▁) ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁f convert ▁[ ▁-- ▁fp lace ▁] ▁) ▁; ▁} ▁while ▁( ▁z pad len ▁> ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁z pad len ▁; ▁} ▁while ▁( ▁padlen ▁< ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁++ ▁padlen ▁; ▁} ▁}	0
▁void ▁* ▁lh _ delete ▁( ▁L HASH ▁* ▁lh ▁, ▁void ▁* ▁data ▁) ▁{ ▁unsigned ▁long ▁hash ▁; ▁L HASH _ NODE ▁* ▁nn ▁, ▁* ▁* ▁rn ▁; ▁void ▁* ▁ret ▁; ▁lh ▁-> ▁error ▁= ▁0 ▁; ▁rn ▁= ▁get rn ▁( ▁lh ▁, ▁data ▁, ▁& ▁hash ▁) ▁; ▁if ▁( ▁* ▁rn ▁== ▁NULL ▁) ▁{ ▁lh ▁-> ▁num _ no _ delete ▁++ ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁else ▁{ ▁nn ▁= ▁* ▁rn ▁; ▁* ▁rn ▁= ▁nn ▁-> ▁next ▁; ▁ret ▁= ▁nn ▁-> ▁data ▁; ▁OPENSSL _ free ▁( ▁nn ▁) ▁; ▁lh ▁-> ▁num _ delete ▁++ ▁; ▁} ▁lh ▁-> ▁num _ items ▁-- ▁; ▁if ▁( ▁( ▁lh ▁-> ▁num _ nodes ▁> ▁MIN _ NODES ▁) ▁&& ▁( ▁lh ▁-> ▁down _ load ▁>= ▁( ▁lh ▁-> ▁num _ items ▁* ▁L H _ LOAD _ MULT ▁/ ▁lh ▁-> ▁num _ nodes ▁) ▁) ▁) ▁contract ▁( ▁lh ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁static ▁av _ always _ inline ▁int ▁get _ c abac _ cb f _ ctx ▁( ▁H 264 Context ▁* ▁h ▁, ▁int ▁cat ▁, ▁int ▁idx ▁, ▁int ▁is _ dc ▁) ▁{ ▁int ▁nz a ▁, ▁nz b ▁; ▁int ▁ctx ▁= ▁0 ▁; ▁if ▁( ▁is _ dc ▁) ▁{ ▁if ▁( ▁cat ▁== ▁0 ▁) ▁{ ▁nz a ▁= ▁h ▁-> ▁left _ cb p ▁& ▁0 x 100 ▁; ▁nz b ▁= ▁h ▁-> ▁top _ cb p ▁& ▁0 x 100 ▁; ▁} ▁else ▁{ ▁nz a ▁= ▁( ▁h ▁-> ▁left _ cb p ▁>> ▁( ▁6 ▁+ ▁idx ▁) ▁) ▁& ▁0 x 01 ▁; ▁nz b ▁= ▁( ▁h ▁-> ▁top _ cb p ▁>> ▁( ▁6 ▁+ ▁idx ▁) ▁) ▁& ▁0 x 01 ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁cat ▁== ▁1 ▁|| ▁cat ▁== ▁2 ▁) ▁{ ▁nz a ▁= ▁h ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁idx ▁] ▁- ▁1 ▁] ▁; ▁nz b ▁= ▁h ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁idx ▁] ▁- ▁8 ▁] ▁; ▁} ▁else ▁{ ▁assert ▁( ▁cat ▁== ▁4 ▁) ▁; ▁nz a ▁= ▁h ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁16 ▁+ ▁idx ▁] ▁- ▁1 ▁] ▁; ▁nz b ▁= ▁h ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁16 ▁+ ▁idx ▁] ▁- ▁8 ▁] ▁; ▁} ▁} ▁if ▁( ▁nz a ▁> ▁0 ▁) ▁ctx ▁++ ▁; ▁if ▁( ▁nz b ▁> ▁0 ▁) ▁ctx ▁+= ▁2 ▁; ▁return ▁ctx ▁+ ▁4 ▁* ▁cat ▁; ▁}	0
▁void ▁avformat _ free _ context ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁AVStream ▁* ▁st ▁; ▁if ▁( ▁! ▁s ▁) ▁return ▁; ▁av _ opt _ free ▁( ▁s ▁) ▁; ▁if ▁( ▁s ▁-> ▁if orm at ▁&& ▁s ▁-> ▁if orm at ▁-> ▁priv _ class ▁&& ▁s ▁-> ▁priv _ data ▁) ▁av _ opt _ free ▁( ▁s ▁-> ▁priv _ data ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁st ▁-> ▁nb _ side _ data ▁; ▁j ▁++ ▁) ▁av _ freep ▁( ▁& ▁st ▁-> ▁side _ data ▁[ ▁j ▁] ▁. ▁data ▁) ▁; ▁av _ freep ▁( ▁& ▁st ▁-> ▁side _ data ▁) ▁; ▁st ▁-> ▁nb _ side _ data ▁= ▁0 ▁; ▁if ▁( ▁st ▁-> ▁parser ▁) ▁{ ▁av _ parser _ close ▁( ▁st ▁-> ▁parser ▁) ▁; ▁} ▁if ▁( ▁st ▁-> ▁attached _ pic ▁. ▁data ▁) ▁av _ free _ packet ▁( ▁& ▁st ▁-> ▁attached _ pic ▁) ▁; ▁av _ dict _ free ▁( ▁& ▁st ▁-> ▁metadata ▁) ▁; ▁av _ freep ▁( ▁& ▁st ▁-> ▁probe _ data ▁. ▁buf ▁) ▁; ▁av _ free ▁( ▁st ▁-> ▁index _ entries ▁) ▁; ▁av _ free ▁( ▁st ▁-> ▁codec ▁-> ▁extradata ▁) ▁; ▁av _ free ▁( ▁st ▁-> ▁codec ▁-> ▁subtitle _ header ▁) ▁; ▁av _ free ▁( ▁st ▁-> ▁codec ▁) ▁; ▁av _ free ▁( ▁st ▁-> ▁priv _ data ▁) ▁; ▁av _ free ▁( ▁st ▁-> ▁info ▁) ▁; ▁av _ free ▁( ▁st ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁s ▁-> ▁nb _ programs ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁av _ dict _ free ▁( ▁& ▁s ▁-> ▁programs ▁[ ▁i ▁] ▁-> ▁metadata ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁programs ▁[ ▁i ▁] ▁-> ▁stream _ index ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁programs ▁[ ▁i ▁] ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁programs ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁priv _ data ▁) ▁; ▁while ▁( ▁s ▁-> ▁nb _ ch apt ers ▁-- ▁) ▁{ ▁av _ dict _ free ▁( ▁& ▁s ▁-> ▁ch apt ers ▁[ ▁s ▁-> ▁nb _ ch apt ers ▁] ▁-> ▁metadata ▁) ▁; ▁av _ free ▁( ▁s ▁-> ▁ch apt ers ▁[ ▁s ▁-> ▁nb _ ch apt ers ▁] ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁ch apt ers ▁) ▁; ▁av _ dict _ free ▁( ▁& ▁s ▁-> ▁metadata ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁streams ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁internal ▁) ▁; ▁av _ free ▁( ▁s ▁) ▁; ▁}	1
▁static ▁int ▁mov 2 text sub ▁( ▁AV BitStream Filter Context ▁* ▁bs fc ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁char ▁* ▁args ▁, ▁uint 8_ t ▁* ▁* ▁poutbuf ▁, ▁int ▁* ▁poutbuf _ size ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁int ▁keyframe ▁) ▁{ ▁if ▁( ▁buf _ size ▁< ▁2 ▁) ▁return ▁0 ▁; ▁* ▁poutbuf _ size ▁= ▁FF MIN ▁( ▁buf _ size ▁- ▁2 ▁, ▁AV _ RB 16 ▁( ▁buf ▁) ▁) ▁; ▁* ▁poutbuf ▁= ▁av _ malloc ▁( ▁* ▁poutbuf _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁* ▁poutbuf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁* ▁poutbuf ▁, ▁buf ▁+ ▁2 ▁, ▁* ▁poutbuf _ size ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁void ▁av _ freep ▁( ▁void ▁* ▁arg ▁) ▁{ ▁void ▁* ▁val ▁; ▁memcpy ▁( ▁& ▁val ▁, ▁arg ▁, ▁sizeof ▁( ▁val ▁) ▁) ▁; ▁memcpy ▁( ▁arg ▁, ▁& ▁( ▁void ▁* ▁) ▁{ ▁NULL ▁} ▁, ▁sizeof ▁( ▁val ▁) ▁) ▁; ▁av _ free ▁( ▁val ▁) ▁; ▁}	1
▁int ▁cms _ add 1_ sign ing _ cert ▁( ▁CMS _ Signer Info ▁* ▁si ▁, ▁E SS _ SIGN ING _ CERT ▁* ▁sc ▁) ▁{ ▁ASN 1_ STRING ▁* ▁seq ▁= ▁NULL ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁* ▁pp ▁; ▁int ▁len ▁; ▁len ▁= ▁i 2 d _ ESS _ SIGN ING _ CERT ▁( ▁sc ▁, ▁NULL ▁) ▁; ▁if ▁( ▁( ▁pp ▁= ▁OPENSSL _ malloc ▁( ▁len ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁p ▁= ▁pp ▁; ▁i 2 d _ ESS _ SIGN ING _ CERT ▁( ▁sc ▁, ▁& ▁p ▁) ▁; ▁if ▁( ▁! ▁( ▁seq ▁= ▁ASN 1_ STRING _ new ▁( ▁) ▁) ▁|| ▁! ▁ASN 1_ STRING _ set ▁( ▁seq ▁, ▁pp ▁, ▁len ▁) ▁) ▁goto ▁err ▁; ▁OPENSSL _ free ▁( ▁pp ▁) ▁; ▁pp ▁= ▁NULL ▁; ▁if ▁( ▁! ▁CMS _ signed _ add 1_ attr _ by _ NID ▁( ▁si ▁, ▁NID _ id _ sm ime _ aa _ sign ing Certificate ▁, ▁V _ ASN 1_ SEQUENCE ▁, ▁seq ▁, ▁-1 ▁) ▁) ▁goto ▁err ▁; ▁ASN 1_ STRING _ free ▁( ▁seq ▁) ▁; ▁return ▁1 ▁; ▁err ▁: ▁CMS err ▁( ▁CMS _ F _ CMS _ ADD 1_ SIGN ING _ CERT ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁ASN 1_ STRING _ free ▁( ▁seq ▁) ▁; ▁OPENSSL _ free ▁( ▁pp ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁startup _ children ▁( ▁int ▁number _ to _ start ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁number _ to _ start ▁&& ▁i ▁< ▁ap _ daemon s _ limit ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁ap _ score board _ image ▁-> ▁parent ▁[ ▁i ▁] ▁. ▁pid ▁!= ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁make _ child ▁( ▁ap _ server _ conf ▁, ▁i ▁, ▁i ▁% ▁retained ▁-> ▁num _ buckets ▁) ▁< ▁0 ▁) ▁{ ▁break ▁; ▁} ▁-- ▁number _ to _ start ▁; ▁} ▁}	1
▁static ▁int ▁TIFF Write Directory Tag Checked R ational Array ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁* ▁n dir ▁, ▁TIFF Dir Entry ▁* ▁dir ▁, ▁uint 16 ▁tag ▁, ▁uint 32 ▁count ▁, ▁float ▁* ▁value ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Write Directory Tag Checked R ational Array " ▁; ▁uint 32 ▁* ▁m ▁; ▁float ▁* ▁na ▁; ▁uint 32 ▁* ▁nb ▁; ▁uint 32 ▁nc ▁; ▁int ▁o ▁; ▁assert ▁( ▁sizeof ▁( ▁uint 32 ▁) ▁== ▁4 ▁) ▁; ▁m ▁= ▁_ TIFF malloc ▁( ▁count ▁* ▁2 ▁* ▁sizeof ▁( ▁uint 32 ▁) ▁) ▁; ▁if ▁( ▁m ▁== ▁NULL ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Out of memory " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁for ▁( ▁na ▁= ▁value ▁, ▁nb ▁= ▁m ▁, ▁nc ▁= ▁0 ▁; ▁nc ▁< ▁count ▁; ▁na ▁++ ▁, ▁nb ▁+= ▁2 ▁, ▁nc ▁++ ▁) ▁{ ▁if ▁( ▁* ▁na ▁<= ▁0.0 ▁|| ▁* ▁na ▁!= ▁* ▁na ▁) ▁{ ▁nb ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁nb ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁* ▁na ▁>= ▁0 ▁&& ▁* ▁na ▁<= ▁( ▁float ▁) ▁0 xFFFFFFFF U ▁&& ▁* ▁na ▁== ▁( ▁float ▁) ▁( ▁uint 32 ▁) ▁( ▁* ▁na ▁) ▁) ▁{ ▁nb ▁[ ▁0 ▁] ▁= ▁( ▁uint 32 ▁) ▁( ▁* ▁na ▁) ▁; ▁nb ▁[ ▁1 ▁] ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁* ▁na ▁< ▁1.0 ▁) ▁{ ▁nb ▁[ ▁0 ▁] ▁= ▁( ▁uint 32 ▁) ▁( ▁( ▁double ▁) ▁( ▁* ▁na ▁) ▁* ▁0 xFFFFFFFF ▁) ▁; ▁nb ▁[ ▁1 ▁] ▁= ▁0 xFFFFFFFF ▁; ▁} ▁else ▁{ ▁nb ▁[ ▁0 ▁] ▁= ▁0 xFFFFFFFF ▁; ▁nb ▁[ ▁1 ▁] ▁= ▁( ▁uint 32 ▁) ▁( ▁( ▁double ▁) ▁0 xFFFFFFFF ▁/ ▁( ▁* ▁na ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ SW AB ▁) ▁TIFF Sw ab ArrayOf Long ▁( ▁m ▁, ▁count ▁* ▁2 ▁) ▁; ▁o ▁= ▁TIFF Write Directory Tag Data ▁( ▁tif ▁, ▁n dir ▁, ▁dir ▁, ▁tag ▁, ▁TIFF _ RATION AL ▁, ▁count ▁, ▁count ▁* ▁8 ▁, ▁& ▁m ▁[ ▁0 ▁] ▁) ▁; ▁_ TIFF free ▁( ▁m ▁) ▁; ▁return ▁( ▁o ▁) ▁; ▁}	1
▁static ▁int ▁udp _ read ▁( ▁URL Context ▁* ▁h ▁, ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁size ▁) ▁{ ▁UDP Context ▁* ▁s ▁= ▁h ▁-> ▁priv _ data ▁; ▁int ▁ret ▁; ▁if ▁( ▁! ▁( ▁h ▁-> ▁flags ▁& ▁URL _ FLAG _ NONBLOCK ▁) ▁) ▁{ ▁ret ▁= ▁ff _ network _ wait _ fd ▁( ▁s ▁-> ▁udp _ fd ▁, ▁0 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁ret ▁= ▁recv ▁( ▁s ▁-> ▁udp _ fd ▁, ▁buf ▁, ▁size ▁, ▁0 ▁) ▁; ▁return ▁ret ▁< ▁0 ▁? ▁ff _ net errno ▁( ▁) ▁: ▁ret ▁; ▁}	0
▁static ▁void ▁ngx _ http _ up stream _ next ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ http _ up stream _ t ▁* ▁u ▁, ▁ngx _ uint _ t ▁ft _ type ▁) ▁{ ▁ngx _ uint _ t ▁status ▁, ▁state ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" http next up stream ,% xi " ▁, ▁ft _ type ▁) ▁; ▁if ▁( ▁u ▁-> ▁peer ▁. ▁sockaddr ▁) ▁{ ▁if ▁( ▁ft _ type ▁== ▁NGX _ HTTP _ UP STREAM _ FT _ HTTP _40 3 ▁|| ▁ft _ type ▁== ▁NGX _ HTTP _ UP STREAM _ FT _ HTTP _ 404 ▁) ▁{ ▁state ▁= ▁NGX _ PEER _ NEXT ▁; ▁} ▁else ▁{ ▁state ▁= ▁NGX _ PEER _ FAILED ▁; ▁} ▁u ▁-> ▁peer ▁. ▁free ▁( ▁& ▁u ▁-> ▁peer ▁, ▁u ▁-> ▁peer ▁. ▁data ▁, ▁state ▁) ▁; ▁u ▁-> ▁peer ▁. ▁sockaddr ▁= ▁NULL ▁; ▁} ▁if ▁( ▁ft _ type ▁== ▁NGX _ HTTP _ UP STREAM _ FT _ TIMEOUT ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁NGX _ E TIMEDOUT ▁, ▁" up stream timed out " ▁) ▁; ▁} ▁if ▁( ▁u ▁-> ▁peer ▁. ▁cached ▁&& ▁ft _ type ▁== ▁NGX _ HTTP _ UP STREAM _ FT _ ERROR ▁) ▁{ ▁status ▁= ▁0 ▁; ▁u ▁-> ▁peer ▁. ▁tries ▁++ ▁; ▁} ▁else ▁{ ▁switch ▁( ▁ft _ type ▁) ▁{ ▁case ▁NGX _ HTTP _ UP STREAM _ FT _ TIMEOUT ▁: ▁status ▁= ▁NGX _ HTTP _ GATE WAY _ TIME _ OUT ▁; ▁break ▁; ▁case ▁NGX _ HTTP _ UP STREAM _ FT _ HTTP _5 00 ▁: ▁status ▁= ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁; ▁break ▁; ▁case ▁NGX _ HTTP _ UP STREAM _ FT _ HTTP _40 3 ▁: ▁status ▁= ▁NGX _ HTTP _ FOR BIDDEN ▁; ▁break ▁; ▁case ▁NGX _ HTTP _ UP STREAM _ FT _ HTTP _ 404 ▁: ▁status ▁= ▁NGX _ HTTP _ NOT _ FOUND ▁; ▁break ▁; ▁default ▁: ▁status ▁= ▁NGX _ HTTP _ BAD _ GATE WAY ▁; ▁} ▁} ▁if ▁( ▁r ▁-> ▁connection ▁-> ▁error ▁) ▁{ ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁NGX _ HTTP _ CLIENT _ CLOSED _ REQUEST ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁status ▁) ▁{ ▁u ▁-> ▁state ▁-> ▁status ▁= ▁status ▁; ▁if ▁( ▁u ▁-> ▁peer ▁. ▁tries ▁== ▁0 ▁|| ▁! ▁( ▁u ▁-> ▁conf ▁-> ▁next _ up stream ▁& ▁ft _ type ▁) ▁) ▁{ ▁# if ▁( ▁NGX _ HTTP _ CACHE ▁) ▁if ▁( ▁u ▁-> ▁cache _ status ▁== ▁NGX _ HTTP _ CACHE _ EXPIRED ▁&& ▁( ▁u ▁-> ▁conf ▁-> ▁cache _ use _ st ale ▁& ▁ft _ type ▁) ▁) ▁{ ▁ngx _ int _ t ▁rc ▁; ▁rc ▁= ▁u ▁-> ▁re init _ request ▁( ▁r ▁) ▁; ▁if ▁( ▁rc ▁== ▁NGX _ OK ▁) ▁{ ▁u ▁-> ▁cache _ status ▁= ▁NGX _ HTTP _ CACHE _ ST ALE ▁; ▁rc ▁= ▁ngx _ http _ up stream _ cache _ send ▁( ▁r ▁, ▁u ▁) ▁; ▁} ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁rc ▁) ▁; ▁return ▁; ▁} ▁# endif ▁ngx _ http _ up stream _ finalize _ request ▁( ▁r ▁, ▁u ▁, ▁status ▁) ▁; ▁return ▁; ▁} ▁} ▁if ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁) ▁{ ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" close http up stream connection :% d " ▁, ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁fd ▁) ▁; ▁# if ▁( ▁NGX _ HTTP _ SSL ▁) ▁if ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁ssl ▁) ▁{ ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁ssl ▁-> ▁no _ wait _ shutdown ▁= ▁1 ▁; ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁ssl ▁-> ▁no _ send _ shutdown ▁= ▁1 ▁; ▁( ▁void ▁) ▁ngx _ ssl _ shutdown ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁) ▁; ▁} ▁# endif ▁if ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁pool ▁) ▁{ ▁ngx _ destroy _ pool ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁-> ▁pool ▁) ▁; ▁} ▁ngx _ close _ connection ▁( ▁u ▁-> ▁peer ▁. ▁connection ▁) ▁; ▁u ▁-> ▁peer ▁. ▁connection ▁= ▁NULL ▁; ▁} ▁ngx _ http _ up stream _ connect ▁( ▁r ▁, ▁u ▁) ▁; ▁}	1
▁int ▁X 509_ cmp _ time ▁( ▁const ▁ASN 1_ TIME ▁* ▁ct m ▁, ▁time _ t ▁* ▁cmp _ time ▁) ▁{ ▁static ▁const ▁size _ t ▁ut ctime _ length ▁= ▁sizeof ▁( ▁" YY MM DD HH MM SS Z " ▁) ▁- ▁1 ▁; ▁static ▁const ▁size _ t ▁general ized time _ length ▁= ▁sizeof ▁( ▁" YY YY MM DD HH MM SS Z " ▁) ▁- ▁1 ▁; ▁ASN 1_ TIME ▁* ▁asn 1_ cmp _ time ▁= ▁NULL ▁; ▁int ▁i ▁, ▁day ▁, ▁sec ▁, ▁ret ▁= ▁0 ▁; ▁switch ▁( ▁ct m ▁-> ▁type ▁) ▁{ ▁case ▁V _ ASN 1_ UTC TIME ▁: ▁if ▁( ▁ct m ▁-> ▁length ▁!= ▁( ▁int ▁) ▁( ▁ut ctime _ length ▁) ▁) ▁return ▁0 ▁; ▁break ▁; ▁case ▁V _ ASN 1_ GENERAL IZED TIME ▁: ▁if ▁( ▁ct m ▁-> ▁length ▁!= ▁( ▁int ▁) ▁( ▁general ized time _ length ▁) ▁) ▁return ▁0 ▁; ▁break ▁; ▁default ▁: ▁return ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ct m ▁-> ▁length ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁isdigit ▁( ▁ct m ▁-> ▁data ▁[ ▁i ▁] ▁) ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁ct m ▁-> ▁data ▁[ ▁ct m ▁-> ▁length ▁- ▁1 ▁] ▁!= ▁' ▁' ▁) ▁return ▁0 ▁; ▁asn 1_ cmp _ time ▁= ▁X 509_ time _ adj ▁( ▁NULL ▁, ▁0 ▁, ▁cmp _ time ▁) ▁; ▁if ▁( ▁asn 1_ cmp _ time ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁ASN 1_ TIME _ diff ▁( ▁& ▁day ▁, ▁& ▁sec ▁, ▁ct m ▁, ▁asn 1_ cmp _ time ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁( ▁day ▁>= ▁0 ▁&& ▁sec ▁>= ▁0 ▁) ▁? ▁-1 ▁: ▁1 ▁; ▁err ▁: ▁ASN 1_ TIME _ free ▁( ▁asn 1_ cmp _ time ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁int ▁url _ f getc ▁( ▁Byte IO Context ▁* ▁s ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ ptr ▁< ▁s ▁-> ▁buf _ end ▁) ▁{ ▁return ▁* ▁s ▁-> ▁buf _ ptr ▁++ ▁; ▁} ▁else ▁{ ▁fill _ buffer ▁( ▁s ▁) ▁; ▁if ▁( ▁s ▁-> ▁buf _ ptr ▁< ▁s ▁-> ▁buf _ end ▁) ▁return ▁* ▁s ▁-> ▁buf _ ptr ▁++ ▁; ▁else ▁return ▁URL _ EOF ▁; ▁} ▁}	1
▁static ▁inline ▁void ▁packet _ forward ▁( ▁PACKET ▁* ▁pkt ▁, ▁size _ t ▁len ▁) ▁{ ▁pkt ▁-> ▁curr ▁+= ▁len ▁; ▁pkt ▁-> ▁remaining ▁-= ▁len ▁; ▁}	1
▁BN _ ULONG ▁bn _ sub _ words ▁( ▁BN _ ULONG ▁* ▁r ▁, ▁const ▁BN _ ULONG ▁* ▁a ▁, ▁const ▁BN _ ULONG ▁* ▁b ▁, ▁int ▁n ▁) ▁{ ▁BN _ ULONG ▁t 1 ▁, ▁t 2 ▁; ▁int ▁c ▁= ▁0 ▁; ▁assert ▁( ▁n ▁>= ▁0 ▁) ▁; ▁if ▁( ▁n ▁<= ▁0 ▁) ▁return ▁( ▁( ▁BN _ ULONG ▁) ▁0 ▁) ▁; ▁# ifndef ▁OPENSSL _ SMALL _ F OOT PRINT ▁while ▁( ▁n ▁& ▁ ~ ▁3 ▁) ▁{ ▁t 1 ▁= ▁a ▁[ ▁0 ▁] ▁; ▁t 2 ▁= ▁b ▁[ ▁0 ▁] ▁; ▁r ▁[ ▁0 ▁] ▁= ▁( ▁t 1 ▁- ▁t 2 ▁- ▁c ▁) ▁& ▁BN _ MASK 2 ▁; ▁if ▁( ▁t 1 ▁!= ▁t 2 ▁) ▁c ▁= ▁( ▁t 1 ▁< ▁t 2 ▁) ▁; ▁t 1 ▁= ▁a ▁[ ▁1 ▁] ▁; ▁t 2 ▁= ▁b ▁[ ▁1 ▁] ▁; ▁r ▁[ ▁1 ▁] ▁= ▁( ▁t 1 ▁- ▁t 2 ▁- ▁c ▁) ▁& ▁BN _ MASK 2 ▁; ▁if ▁( ▁t 1 ▁!= ▁t 2 ▁) ▁c ▁= ▁( ▁t 1 ▁< ▁t 2 ▁) ▁; ▁t 1 ▁= ▁a ▁[ ▁2 ▁] ▁; ▁t 2 ▁= ▁b ▁[ ▁2 ▁] ▁; ▁r ▁[ ▁2 ▁] ▁= ▁( ▁t 1 ▁- ▁t 2 ▁- ▁c ▁) ▁& ▁BN _ MASK 2 ▁; ▁if ▁( ▁t 1 ▁!= ▁t 2 ▁) ▁c ▁= ▁( ▁t 1 ▁< ▁t 2 ▁) ▁; ▁t 1 ▁= ▁a ▁[ ▁3 ▁] ▁; ▁t 2 ▁= ▁b ▁[ ▁3 ▁] ▁; ▁r ▁[ ▁3 ▁] ▁= ▁( ▁t 1 ▁- ▁t 2 ▁- ▁c ▁) ▁& ▁BN _ MASK 2 ▁; ▁if ▁( ▁t 1 ▁!= ▁t 2 ▁) ▁c ▁= ▁( ▁t 1 ▁< ▁t 2 ▁) ▁; ▁a ▁+= ▁4 ▁; ▁b ▁+= ▁4 ▁; ▁r ▁+= ▁4 ▁; ▁n ▁-= ▁4 ▁; ▁} ▁# endif ▁while ▁( ▁n ▁) ▁{ ▁t 1 ▁= ▁a ▁[ ▁0 ▁] ▁; ▁t 2 ▁= ▁b ▁[ ▁0 ▁] ▁; ▁r ▁[ ▁0 ▁] ▁= ▁( ▁t 1 ▁- ▁t 2 ▁- ▁c ▁) ▁& ▁BN _ MASK 2 ▁; ▁if ▁( ▁t 1 ▁!= ▁t 2 ▁) ▁c ▁= ▁( ▁t 1 ▁< ▁t 2 ▁) ▁; ▁a ▁++ ▁; ▁b ▁++ ▁; ▁r ▁++ ▁; ▁n ▁-- ▁; ▁} ▁return ▁( ▁c ▁) ▁; ▁}	1
▁void ▁ff _ t ak _ parse _ stream info ▁( ▁T AK Stream Info ▁* ▁s ▁, ▁Get Bit Context ▁* ▁gb ▁) ▁{ ▁uint 64_ t ▁channel _ mask ▁= ▁0 ▁; ▁int ▁frame _ type ▁, ▁i ▁; ▁s ▁-> ▁codec ▁= ▁get _ bits ▁( ▁gb ▁, ▁T AK _ ENCODER _ CODEC _ BITS ▁) ▁; ▁skip _ bits ▁( ▁gb ▁, ▁T AK _ ENCODER _ PROFILE _ BITS ▁) ▁; ▁frame _ type ▁= ▁get _ bits ▁( ▁gb ▁, ▁T AK _ SIZE _ FRAME _ DURATION _ BITS ▁) ▁; ▁s ▁-> ▁samples ▁= ▁get _ bits 64 ▁( ▁gb ▁, ▁T AK _ SIZE _ SAMPLES _ NUM _ BITS ▁) ▁; ▁s ▁-> ▁data _ type ▁= ▁get _ bits ▁( ▁gb ▁, ▁T AK _ FORMAT _ DATA _ TYPE _ BITS ▁) ▁; ▁s ▁-> ▁sample _ rate ▁= ▁get _ bits ▁( ▁gb ▁, ▁T AK _ FORMAT _ SAMPLE _ RATE _ BITS ▁) ▁+ ▁T AK _ SAMPLE _ RATE _ MIN ▁; ▁s ▁-> ▁bps ▁= ▁get _ bits ▁( ▁gb ▁, ▁T AK _ FORMAT _ B PS _ BITS ▁) ▁+ ▁T AK _ B PS _ MIN ▁; ▁s ▁-> ▁channels ▁= ▁get _ bits ▁( ▁gb ▁, ▁T AK _ FORMAT _ CHANNEL _ BITS ▁) ▁+ ▁T AK _ CHANNELS _ MIN ▁; ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁skip _ bits ▁( ▁gb ▁, ▁T AK _ FORMAT _ VALID _ BITS ▁) ▁; ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁int ▁value ▁= ▁get _ bits ▁( ▁gb ▁, ▁T AK _ FORMAT _ CH _ LAYOUT _ BITS ▁) ▁; ▁if ▁( ▁value ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁t ak _ channel _ layout s ▁) ▁) ▁channel _ mask ▁|= ▁t ak _ channel _ layout s ▁[ ▁value ▁] ▁; ▁} ▁} ▁} ▁s ▁-> ▁ch _ layout ▁= ▁channel _ mask ▁; ▁s ▁-> ▁frame _ samples ▁= ▁t ak _ get _ nb _ samples ▁( ▁s ▁-> ▁sample _ rate ▁, ▁frame _ type ▁) ▁; ▁}	0
▁uintptr _ t ▁ngx _ escape _ uri ▁( ▁u _ char ▁* ▁dst ▁, ▁u _ char ▁* ▁src ▁, ▁size _ t ▁size ▁, ▁ngx _ uint _ t ▁type ▁) ▁{ ▁ngx _ uint _ t ▁n ▁; ▁uint 32_ t ▁* ▁escape ▁; ▁static ▁u _ char ▁hex ▁[ ▁] ▁= ▁"0123456789 abcdef " ▁; ▁static ▁uint 32_ t ▁uri ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 8 000002 9 ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁args ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 80000 829 ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁html ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 000000 ad ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁refresh ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 000000 85 ▁, ▁0 x 00000000 ▁, ▁0 x 80000000 ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁, ▁0 xffffffff ▁} ▁; ▁static ▁uint 32_ t ▁memcached ▁[ ▁] ▁= ▁{ ▁0 xffffffff ▁, ▁0 x 000000 21 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁0 x 00000000 ▁, ▁} ▁; ▁static ▁uint 32_ t ▁* ▁map ▁[ ▁] ▁= ▁{ ▁uri ▁, ▁args ▁, ▁html ▁, ▁refresh ▁, ▁memcached ▁, ▁memcached ▁} ▁; ▁escape ▁= ▁map ▁[ ▁type ▁] ▁; ▁if ▁( ▁dst ▁== ▁NULL ▁) ▁{ ▁n ▁= ▁0 ▁; ▁while ▁( ▁size ▁) ▁{ ▁if ▁( ▁escape ▁[ ▁* ▁src ▁>> ▁5 ▁] ▁& ▁( ▁1 ▁<< ▁( ▁* ▁src ▁& ▁0 x 1 f ▁) ▁) ▁) ▁{ ▁n ▁++ ▁; ▁} ▁src ▁++ ▁; ▁size ▁-- ▁; ▁} ▁return ▁( ▁uintptr _ t ▁) ▁n ▁; ▁} ▁while ▁( ▁size ▁) ▁{ ▁if ▁( ▁escape ▁[ ▁* ▁src ▁>> ▁5 ▁] ▁& ▁( ▁1 ▁<< ▁( ▁* ▁src ▁& ▁0 x 1 f ▁) ▁) ▁) ▁{ ▁* ▁dst ▁++ ▁= ▁' ▁' ▁; ▁* ▁dst ▁++ ▁= ▁hex ▁[ ▁* ▁src ▁>> ▁4 ▁] ▁; ▁* ▁dst ▁++ ▁= ▁hex ▁[ ▁* ▁src ▁& ▁0 xf ▁] ▁; ▁src ▁++ ▁; ▁} ▁else ▁{ ▁* ▁dst ▁++ ▁= ▁* ▁src ▁++ ▁; ▁} ▁size ▁-- ▁; ▁} ▁return ▁( ▁uintptr _ t ▁) ▁dst ▁; ▁}	0
▁static ▁int ▁x 9_ 62_ test _ internal ▁( ▁int ▁nid ▁, ▁const ▁char ▁* ▁r _ in ▁, ▁const ▁char ▁* ▁s _ in ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁const ▁char ▁message ▁[ ▁] ▁= ▁" abc " ▁; ▁unsigned ▁char ▁digest ▁[ ▁20 ▁] ▁; ▁unsigned ▁int ▁dgst _ len ▁= ▁0 ▁; ▁EVP _ MD _ CTX ▁* ▁md _ ctx ▁; ▁EC _ KEY ▁* ▁key ▁= ▁NULL ▁; ▁ECDSA _ SIG ▁* ▁signature ▁= ▁NULL ▁; ▁BIGNUM ▁* ▁r ▁= ▁NULL ▁, ▁* ▁s ▁= ▁NULL ▁; ▁BIGNUM ▁* ▁k inv ▁= ▁NULL ▁, ▁* ▁rp ▁= ▁NULL ▁; ▁const ▁BIGNUM ▁* ▁sig _ r ▁, ▁* ▁sig _ s ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁md _ ctx ▁= ▁EVP _ MD _ CTX _ new ▁( ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁EVP _ Digest Init ▁( ▁md _ ctx ▁, ▁EVP _ sha 1 ▁( ▁) ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁EVP _ DigestUpdate ▁( ▁md _ ctx ▁, ▁( ▁const ▁void ▁* ▁) ▁message ▁, ▁3 ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁EVP _ Digest Final ▁( ▁md _ ctx ▁, ▁digest ▁, ▁& ▁dgst _ len ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁TEST _ info ▁( ▁" testing % s " ▁, ▁OBJ _ nid 2 sn ▁( ▁nid ▁) ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁key ▁= ▁EC _ KEY _ new _ by _ curve _ name ▁( ▁nid ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁use _ fake ▁= ▁1 ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁EC _ KEY _ generate _ key ▁( ▁key ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁use _ fake ▁= ▁1 ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁ECDSA _ sign _ setup ▁( ▁key ▁, ▁NULL ▁, ▁& ▁k inv ▁, ▁& ▁rp ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁signature ▁= ▁ECDSA _ do _ sign _ ex ▁( ▁digest ▁, ▁20 ▁, ▁k inv ▁, ▁rp ▁, ▁key ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁r ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁s ▁= ▁BN _ new ▁( ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁BN _ dec 2 bn ▁( ▁& ▁r ▁, ▁r _ in ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁BN _ dec 2 bn ▁( ▁& ▁s ▁, ▁s _ in ▁) ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁ECDSA _ SIG _ get 0 ▁( ▁signature ▁, ▁& ▁sig _ r ▁, ▁& ▁sig _ s ▁) ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁BN _ cmp ▁( ▁sig _ r ▁, ▁r ▁) ▁, ▁0 ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁BN _ cmp ▁( ▁sig _ s ▁, ▁s ▁) ▁, ▁0 ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁ECDSA _ do _ verify ▁( ▁digest ▁, ▁20 ▁, ▁signature ▁, ▁key ▁) ▁, ▁1 ▁) ▁) ▁goto ▁x 96 2_ int _ err ▁; ▁ret ▁= ▁1 ▁; ▁x 96 2_ int _ err ▁: ▁EC _ KEY _ free ▁( ▁key ▁) ▁; ▁ECDSA _ SIG _ free ▁( ▁signature ▁) ▁; ▁BN _ free ▁( ▁r ▁) ▁; ▁BN _ free ▁( ▁s ▁) ▁; ▁EVP _ MD _ CTX _ free ▁( ▁md _ ctx ▁) ▁; ▁BN _ clear _ free ▁( ▁k inv ▁) ▁; ▁BN _ clear _ free ▁( ▁rp ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁ff _ h 264_ fill _ default _ ref _ list ▁( ▁H 264 Context ▁* ▁h ▁) ▁{ ▁int ▁i ▁, ▁len ▁; ▁if ▁( ▁h ▁-> ▁slice _ type _ nos ▁== ▁AV _ PICTURE _ TYPE _ B ▁) ▁{ ▁Picture ▁* ▁sorted ▁[ ▁32 ▁] ▁; ▁int ▁cur _ p oc ▁, ▁list ▁; ▁int ▁lens ▁[ ▁2 ▁] ▁; ▁if ▁( ▁FIELD _ PICTURE ▁( ▁h ▁) ▁) ▁cur _ p oc ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁field _ p oc ▁[ ▁h ▁-> ▁picture _ structure ▁== ▁P ICT _ BOTTOM _ FIELD ▁] ▁; ▁else ▁cur _ p oc ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁p oc ▁; ▁for ▁( ▁list ▁= ▁0 ▁; ▁list ▁< ▁2 ▁; ▁list ▁++ ▁) ▁{ ▁len ▁= ▁add _ sorted ▁( ▁sorted ▁, ▁h ▁-> ▁short _ ref ▁, ▁h ▁-> ▁short _ ref _ count ▁, ▁cur _ p oc ▁, ▁1 ▁ ^ ▁list ▁) ▁; ▁len ▁+= ▁add _ sorted ▁( ▁sorted ▁+ ▁len ▁, ▁h ▁-> ▁short _ ref ▁, ▁h ▁-> ▁short _ ref _ count ▁, ▁cur _ p oc ▁, ▁0 ▁ ^ ▁list ▁) ▁; ▁av _ assert 0 ▁( ▁len ▁<= ▁32 ▁) ▁; ▁len ▁= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁list ▁] ▁, ▁sorted ▁, ▁len ▁, ▁0 ▁, ▁h ▁-> ▁picture _ structure ▁) ▁; ▁len ▁+= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁list ▁] ▁+ ▁len ▁, ▁h ▁-> ▁long _ ref ▁, ▁16 ▁, ▁1 ▁, ▁h ▁-> ▁picture _ structure ▁) ▁; ▁av _ assert 0 ▁( ▁len ▁<= ▁32 ▁) ▁; ▁if ▁( ▁len ▁< ▁h ▁-> ▁ref _ count ▁[ ▁list ▁] ▁) ▁memset ▁( ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁list ▁] ▁[ ▁len ▁] ▁, ▁0 ▁, ▁sizeof ▁( ▁Picture ▁) ▁* ▁( ▁h ▁-> ▁ref _ count ▁[ ▁list ▁] ▁- ▁len ▁) ▁) ▁; ▁lens ▁[ ▁list ▁] ▁= ▁len ▁; ▁} ▁if ▁( ▁lens ▁[ ▁0 ▁] ▁== ▁lens ▁[ ▁1 ▁] ▁&& ▁lens ▁[ ▁1 ▁] ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁== ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁&& ▁i ▁< ▁lens ▁[ ▁0 ▁] ▁; ▁i ▁++ ▁) ▁; ▁if ▁( ▁i ▁== ▁lens ▁[ ▁0 ▁] ▁) ▁{ ▁Picture ▁tmp ▁; ▁COPY _ PICTURE ▁( ▁& ▁tmp ▁, ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁COPY _ PICTURE ▁( ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁COPY _ PICTURE ▁( ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁, ▁& ▁tmp ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁len ▁= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁, ▁h ▁-> ▁short _ ref ▁, ▁h ▁-> ▁short _ ref _ count ▁, ▁0 ▁, ▁h ▁-> ▁picture _ structure ▁) ▁; ▁len ▁+= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁+ ▁len ▁, ▁h ▁-> ▁long _ ref ▁, ▁16 ▁, ▁1 ▁, ▁h ▁-> ▁picture _ structure ▁) ▁; ▁av _ assert 0 ▁( ▁len ▁<= ▁32 ▁) ▁; ▁if ▁( ▁len ▁< ▁h ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁) ▁memset ▁( ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁len ▁] ▁, ▁0 ▁, ▁sizeof ▁( ▁Picture ▁) ▁* ▁( ▁h ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁- ▁len ▁) ▁) ▁; ▁} ▁# ifdef ▁TRACE ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁t printf ▁( ▁h ▁-> ▁avctx ▁, ▁" List 0 :% s fn :% d 0 x % p \ n " ▁, ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁long _ ref ▁? ▁" LT " ▁: ▁" ST " ▁) ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁pic _ id ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁) ▁; ▁} ▁if ▁( ▁h ▁-> ▁slice _ type _ nos ▁== ▁AV _ PICTURE _ TYPE _ B ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁-> ▁ref _ count ▁[ ▁1 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁t printf ▁( ▁h ▁-> ▁avctx ▁, ▁" List 1 :% s fn :% d 0 x % p \ n " ▁, ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁long _ ref ▁? ▁" LT " ▁: ▁" ST " ▁) ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁pic _ id ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁) ▁; ▁} ▁} ▁# endif ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁g 72 6_ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁G 726 Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int 16_ t ▁* ▁samples ▁= ▁data ▁; ▁Get Bit Context ▁gb ▁; ▁int ▁out _ samples ▁, ▁out _ size ▁; ▁out _ samples ▁= ▁buf _ size ▁* ▁8 ▁/ ▁c ▁-> ▁code _ size ▁; ▁out _ size ▁= ▁out _ samples ▁* ▁av _ get _ bytes _ per _ sample ▁( ▁avctx ▁-> ▁sample _ fmt ▁) ▁; ▁if ▁( ▁* ▁data _ size ▁< ▁out _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Output buffer ist oo small \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁while ▁( ▁out _ samples ▁-- ▁) ▁* ▁samples ▁++ ▁= ▁g 72 6_ decode ▁( ▁c ▁, ▁get _ bits ▁( ▁& ▁gb ▁, ▁c ▁-> ▁code _ size ▁) ▁) ▁; ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁gb ▁) ▁> ▁0 ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Frame invalid ly split , missing parser ?\ n " ▁) ▁; ▁* ▁data _ size ▁= ▁out _ size ▁; ▁return ▁buf _ size ▁; ▁}	0
▁static ▁av _ cold ▁int ▁x ma _ decode _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁X MA Decode Ctx ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁ret ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁<= ▁0 ▁|| ▁avctx ▁-> ▁channels ▁> ▁8 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁avctx ▁-> ▁channels ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁= ▁decode _ init ▁( ▁& ▁s ▁-> ▁x ma ▁[ ▁i ▁] ▁, ▁avctx ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁-> ▁nb _ samples ▁= ▁512 ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁} ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁mat ro sk a _ parse _ rm _ audio ▁( ▁Mat ro sk a Demux Context ▁* ▁mat ro sk a ▁, ▁Mat ro sk a Track ▁* ▁track ▁, ▁AVStream ▁* ▁st ▁, ▁uint 8_ t ▁* ▁data ▁, ▁int ▁size ▁, ▁uint 64_ t ▁time code ▁, ▁int 64_ t ▁pos ▁) ▁{ ▁int ▁a ▁= ▁st ▁-> ▁codec ▁-> ▁block _ align ▁; ▁int ▁sps ▁= ▁track ▁-> ▁audio ▁. ▁sub _ packet _ size ▁; ▁int ▁cfs ▁= ▁track ▁-> ▁audio ▁. ▁coded _ frames ize ▁; ▁int ▁h ▁= ▁track ▁-> ▁audio ▁. ▁sub _ packet _ h ▁; ▁int ▁y ▁= ▁track ▁-> ▁audio ▁. ▁sub _ packet _ cnt ▁; ▁int ▁w ▁= ▁track ▁-> ▁audio ▁. ▁frame _ size ▁; ▁int ▁x ▁; ▁if ▁( ▁! ▁track ▁-> ▁audio ▁. ▁pkt _ cnt ▁) ▁{ ▁if ▁( ▁track ▁-> ▁audio ▁. ▁sub _ packet _ cnt ▁== ▁0 ▁) ▁track ▁-> ▁audio ▁. ▁buf _ time code ▁= ▁time code ▁; ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ RA _2 88 ▁) ▁{ ▁if ▁( ▁size ▁< ▁cfs ▁* ▁h ▁/ ▁2 ▁) ▁{ ▁av _ log ▁( ▁mat ro sk a ▁-> ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cor rupt int 4 RM - style aud iop acket size \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁h ▁/ ▁2 ▁; ▁x ▁++ ▁) ▁memcpy ▁( ▁track ▁-> ▁audio ▁. ▁buf ▁+ ▁x ▁* ▁2 ▁* ▁w ▁+ ▁y ▁* ▁cfs ▁, ▁data ▁+ ▁x ▁* ▁cfs ▁, ▁cfs ▁) ▁; ▁} ▁else ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ SI PR ▁) ▁{ ▁if ▁( ▁size ▁< ▁w ▁) ▁{ ▁av _ log ▁( ▁mat ro sk a ▁-> ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cor rupt sip r RM - style aud iop acket size \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁memcpy ▁( ▁track ▁-> ▁audio ▁. ▁buf ▁+ ▁y ▁* ▁w ▁, ▁data ▁, ▁w ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁size ▁< ▁sps ▁* ▁w ▁/ ▁sps ▁) ▁{ ▁av _ log ▁( ▁mat ro sk a ▁-> ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cor rupt generic RM - style aud iop acket size \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁w ▁/ ▁sps ▁; ▁x ▁++ ▁) ▁memcpy ▁( ▁track ▁-> ▁audio ▁. ▁buf ▁+ ▁sps ▁* ▁( ▁h ▁* ▁x ▁+ ▁( ▁( ▁h ▁+ ▁1 ▁) ▁/ ▁2 ▁) ▁* ▁( ▁y ▁& ▁1 ▁) ▁+ ▁( ▁y ▁>> ▁1 ▁) ▁) ▁, ▁data ▁+ ▁x ▁* ▁sps ▁, ▁sps ▁) ▁; ▁} ▁if ▁( ▁++ ▁track ▁-> ▁audio ▁. ▁sub _ packet _ cnt ▁>= ▁h ▁) ▁{ ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ SI PR ▁) ▁ff _ rm _ re order _ sip r _ data ▁( ▁track ▁-> ▁audio ▁. ▁buf ▁, ▁h ▁, ▁w ▁) ▁; ▁track ▁-> ▁audio ▁. ▁sub _ packet _ cnt ▁= ▁0 ▁; ▁track ▁-> ▁audio ▁. ▁pkt _ cnt ▁= ▁h ▁* ▁w ▁/ ▁a ▁; ▁} ▁} ▁while ▁( ▁track ▁-> ▁audio ▁. ▁pkt _ cnt ▁) ▁{ ▁AVPacket ▁* ▁pkt ▁= ▁NULL ▁; ▁if ▁( ▁! ▁( ▁pkt ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVPacket ▁) ▁) ▁) ▁|| ▁av _ new _ packet ▁( ▁pkt ▁, ▁a ▁) ▁< ▁0 ▁) ▁{ ▁av _ free ▁( ▁pkt ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁track ▁-> ▁audio ▁. ▁buf ▁+ ▁a ▁* ▁( ▁h ▁* ▁w ▁/ ▁a ▁- ▁track ▁-> ▁audio ▁. ▁pkt _ cnt ▁-- ▁) ▁, ▁a ▁) ▁; ▁pkt ▁-> ▁pts ▁= ▁track ▁-> ▁audio ▁. ▁buf _ time code ▁; ▁track ▁-> ▁audio ▁. ▁buf _ time code ▁= ▁AV _ NOP TS _ VALUE ▁; ▁pkt ▁-> ▁pos ▁= ▁pos ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁st ▁-> ▁index ▁; ▁dyn array _ add ▁( ▁& ▁mat ro sk a ▁-> ▁packets ▁, ▁& ▁mat ro sk a ▁-> ▁num _ packets ▁, ▁pkt ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁char ▁* ▁sk _ delete _ ptr ▁( ▁STACK ▁* ▁st ▁, ▁char ▁* ▁p ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁st ▁-> ▁num ▁; ▁i ▁++ ▁) ▁if ▁( ▁st ▁-> ▁data ▁[ ▁i ▁] ▁== ▁p ▁) ▁return ▁( ▁sk _ delete ▁( ▁st ▁, ▁i ▁) ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	1
▁BIGNUM ▁* ▁get bn from buf ▁( ▁const ▁unsigned ▁char ▁* ▁buf ▁, ▁size _ t ▁len ▁) ▁{ ▁while ▁( ▁* ▁buf ▁== ▁0 ▁&& ▁len ▁> ▁0 ▁) ▁{ ▁buf ▁++ ▁; ▁len ▁-- ▁; ▁} ▁if ▁( ▁len ▁) ▁{ ▁return ▁BN _ bin 2 bn ▁( ▁buf ▁, ▁len ▁, ▁NULL ▁) ▁; ▁} ▁else ▁{ ▁BIGNUM ▁* ▁b ▁= ▁BN _ new ▁( ▁) ▁; ▁BN _ zero ▁( ▁b ▁) ▁; ▁return ▁b ▁; ▁} ▁}	1
▁static ▁void ▁de inter lace _ bottom _ field _ inplace ▁( ▁uint 8_ t ▁* ▁src 1 ▁, ▁int ▁src _ wrap ▁, ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁uint 8_ t ▁* ▁src _ m 1 ▁, ▁* ▁src _0 ▁, ▁* ▁src _ p 1 ▁, ▁* ▁src _ p 2 ▁; ▁int ▁y ▁; ▁uint 8_ t ▁* ▁buf ▁; ▁buf ▁= ▁av _ malloc ▁( ▁width ▁) ▁; ▁src _ m 1 ▁= ▁src 1 ▁; ▁memcpy ▁( ▁buf ▁, ▁src _ m 1 ▁, ▁width ▁) ▁; ▁src _0 ▁= ▁& ▁src _ m 1 ▁[ ▁src _ wrap ▁] ▁; ▁src _ p 1 ▁= ▁& ▁src _0 ▁[ ▁src _ wrap ▁] ▁; ▁src _ p 2 ▁= ▁& ▁src _ p 1 ▁[ ▁src _ wrap ▁] ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁( ▁height ▁- ▁2 ▁) ▁; ▁y ▁+= ▁2 ▁) ▁{ ▁de inter lace _ line _ inplace ▁( ▁buf ▁, ▁src _ m 1 ▁, ▁src _0 ▁, ▁src _ p 1 ▁, ▁src _ p 2 ▁, ▁width ▁) ▁; ▁src _ m 1 ▁= ▁src _ p 1 ▁; ▁src _0 ▁= ▁src _ p 2 ▁; ▁src _ p 1 ▁+= ▁2 ▁* ▁src _ wrap ▁; ▁src _ p 2 ▁+= ▁2 ▁* ▁src _ wrap ▁; ▁} ▁de inter lace _ line _ inplace ▁( ▁buf ▁, ▁src _ m 1 ▁, ▁src _0 ▁, ▁src _0 ▁, ▁src _0 ▁, ▁width ▁) ▁; ▁av _ free ▁( ▁buf ▁) ▁; ▁}	1
▁int ▁EVP _ PBE _ scrypt ▁( ▁const ▁char ▁* ▁pass ▁, ▁size _ t ▁passlen ▁, ▁const ▁unsigned ▁char ▁* ▁salt ▁, ▁size _ t ▁saltlen ▁, ▁uint 64_ t ▁N ▁, ▁uint 64_ t ▁r ▁, ▁uint 64_ t ▁p ▁, ▁uint 64_ t ▁max mem ▁, ▁unsigned ▁char ▁* ▁key ▁, ▁size _ t ▁keylen ▁) ▁{ ▁int ▁rv ▁= ▁0 ▁; ▁unsigned ▁char ▁* ▁B ▁; ▁uint 32_ t ▁* ▁X ▁, ▁* ▁V ▁, ▁* ▁T ▁; ▁uint 64_ t ▁i ▁, ▁B len ▁, ▁V len ▁; ▁if ▁( ▁r ▁== ▁0 ▁|| ▁p ▁== ▁0 ▁|| ▁N ▁< ▁2 ▁|| ▁( ▁N ▁& ▁( ▁N ▁- ▁1 ▁) ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁p ▁> ▁S CRYPT _ PR _ MAX ▁/ ▁r ▁) ▁return ▁0 ▁; ▁if ▁( ▁16 ▁* ▁r ▁<= ▁LOG 2_ UINT 64_ MAX ▁) ▁{ ▁if ▁( ▁N ▁>= ▁( ▁( ▁( ▁uint 64_ t ▁) ▁1 ▁) ▁<< ▁( ▁16 ▁* ▁r ▁) ▁) ▁) ▁return ▁0 ▁; ▁} ▁B len ▁= ▁p ▁* ▁128 ▁* ▁r ▁; ▁if ▁( ▁B len ▁> ▁INT _ MAX ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ PBE _ SCR YPT ▁, ▁EVP _ R _ MEMORY _ LIMIT _ EXCEEDED ▁) ▁; ▁return ▁0 ▁; ▁} ▁i ▁= ▁UINT 64_ MAX ▁/ ▁( ▁32 ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁) ▁; ▁if ▁( ▁N ▁+ ▁2 ▁> ▁i ▁/ ▁r ▁) ▁return ▁0 ▁; ▁V len ▁= ▁32 ▁* ▁r ▁* ▁( ▁N ▁+ ▁2 ▁) ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁; ▁if ▁( ▁B len ▁> ▁UINT 64_ MAX ▁- ▁V len ▁) ▁return ▁0 ▁; ▁if ▁( ▁max mem ▁== ▁0 ▁) ▁max mem ▁= ▁S CRYPT _ MAX _ MEM ▁; ▁if ▁( ▁max mem ▁> ▁SIZE _ MAX ▁) ▁max mem ▁= ▁SIZE _ MAX ▁; ▁if ▁( ▁B len ▁+ ▁V len ▁> ▁max mem ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ PBE _ SCR YPT ▁, ▁EVP _ R _ MEMORY _ LIMIT _ EXCEEDED ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁key ▁== ▁NULL ▁) ▁return ▁1 ▁; ▁B ▁= ▁OPENSSL _ malloc ▁( ▁( ▁size _ t ▁) ▁( ▁B len ▁+ ▁V len ▁) ▁) ▁; ▁if ▁( ▁B ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁X ▁= ▁( ▁uint 32_ t ▁* ▁) ▁( ▁B ▁+ ▁B len ▁) ▁; ▁T ▁= ▁X ▁+ ▁32 ▁* ▁r ▁; ▁V ▁= ▁T ▁+ ▁32 ▁* ▁r ▁; ▁if ▁( ▁PKCS 5_ PB KDF 2_ HMAC ▁( ▁pass ▁, ▁passlen ▁, ▁salt ▁, ▁saltlen ▁, ▁1 ▁, ▁EVP _ sha 256 ▁( ▁) ▁, ▁( ▁int ▁) ▁B len ▁, ▁B ▁) ▁== ▁0 ▁) ▁goto ▁err ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁; ▁i ▁++ ▁) ▁sc rypt ROM ix ▁( ▁B ▁+ ▁128 ▁* ▁r ▁* ▁i ▁, ▁r ▁, ▁N ▁, ▁X ▁, ▁T ▁, ▁V ▁) ▁; ▁if ▁( ▁PKCS 5_ PB KDF 2_ HMAC ▁( ▁pass ▁, ▁passlen ▁, ▁B ▁, ▁( ▁int ▁) ▁B len ▁, ▁1 ▁, ▁EVP _ sha 256 ▁( ▁) ▁, ▁keylen ▁, ▁key ▁) ▁== ▁0 ▁) ▁goto ▁err ▁; ▁rv ▁= ▁1 ▁; ▁err ▁: ▁OPENSSL _ clear _ free ▁( ▁B ▁, ▁( ▁size _ t ▁) ▁( ▁B len ▁+ ▁V len ▁) ▁) ▁; ▁return ▁rv ▁; ▁}	0
▁int ▁EVP _ Open Init ▁( ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁, ▁const ▁EVP _ CIPHER ▁* ▁type ▁, ▁const ▁unsigned ▁char ▁* ▁ek ▁, ▁int ▁ek l ▁, ▁const ▁unsigned ▁char ▁* ▁iv ▁, ▁EVP _ PKEY ▁* ▁priv ▁) ▁{ ▁unsigned ▁char ▁* ▁key ▁= ▁NULL ▁; ▁int ▁i ▁, ▁size ▁= ▁0 ▁, ▁ret ▁= ▁0 ▁; ▁if ▁( ▁type ▁) ▁{ ▁EVP _ CIPHER _ CTX _ reset ▁( ▁ctx ▁) ▁; ▁if ▁( ▁! ▁EVP _ Decrypt Init _ ex ▁( ▁ctx ▁, ▁type ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁! ▁priv ▁) ▁return ▁1 ▁; ▁if ▁( ▁EVP _ PKEY _ id ▁( ▁priv ▁) ▁!= ▁EVP _ PKEY _ RSA ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ OPEN INIT ▁, ▁EVP _ R _ PUBLIC _ KEY _ NOT _ RSA ▁) ▁; ▁goto ▁err ▁; ▁} ▁size ▁= ▁EVP _ PKEY _ size ▁( ▁priv ▁) ▁; ▁key ▁= ▁OPENSSL _ malloc ▁( ▁size ▁+ ▁2 ▁) ▁; ▁if ▁( ▁key ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ OPEN INIT ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁i ▁= ▁EVP _ PKEY _ decrypt _ old ▁( ▁key ▁, ▁ek ▁, ▁ek l ▁, ▁priv ▁) ▁; ▁if ▁( ▁( ▁i ▁<= ▁0 ▁) ▁|| ▁! ▁EVP _ CIPHER _ CTX _ set _ key _ length ▁( ▁ctx ▁, ▁i ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁EVP _ Decrypt Init _ ex ▁( ▁ctx ▁, ▁NULL ▁, ▁NULL ▁, ▁key ▁, ▁iv ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁OPENSSL _ clear _ free ▁( ▁key ▁, ▁size ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁gif _ image _ write _ image ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁uint 8_ t ▁* ▁* ▁bytestream ▁, ▁uint 8_ t ▁* ▁end ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁linesize ▁) ▁{ ▁GIF Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁len ▁, ▁height ▁; ▁const ▁uint 8_ t ▁* ▁ptr ▁; ▁bytestream _ put _ byte ▁( ▁bytestream ▁, ▁0 x 2 c ▁) ▁; ▁bytestream _ put _ le 16 ▁( ▁bytestream ▁, ▁0 ▁) ▁; ▁bytestream _ put _ le 16 ▁( ▁bytestream ▁, ▁0 ▁) ▁; ▁bytestream _ put _ le 16 ▁( ▁bytestream ▁, ▁avctx ▁-> ▁width ▁) ▁; ▁bytestream _ put _ le 16 ▁( ▁bytestream ▁, ▁avctx ▁-> ▁height ▁) ▁; ▁bytestream _ put _ byte ▁( ▁bytestream ▁, ▁0 x 00 ▁) ▁; ▁bytestream _ put _ byte ▁( ▁bytestream ▁, ▁0 x 08 ▁) ▁; ▁ff _ lz w _ encode _ init ▁( ▁s ▁-> ▁lz w ▁, ▁s ▁-> ▁buf ▁, ▁avctx ▁-> ▁width ▁* ▁avctx ▁-> ▁height ▁, ▁12 ▁, ▁FF _ LZ W _ GIF ▁, ▁put _ bits ▁) ▁; ▁ptr ▁= ▁buf ▁; ▁for ▁( ▁height ▁= ▁avctx ▁-> ▁height ▁; ▁height ▁-- ▁; ▁) ▁{ ▁len ▁+= ▁ff _ lz w _ encode ▁( ▁s ▁-> ▁lz w ▁, ▁ptr ▁, ▁avctx ▁-> ▁width ▁) ▁; ▁ptr ▁+= ▁linesize ▁; ▁} ▁len ▁+= ▁ff _ lz w _ encode _ flush ▁( ▁s ▁-> ▁lz w ▁, ▁flush _ put _ bits ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁buf ▁; ▁while ▁( ▁len ▁> ▁0 ▁) ▁{ ▁int ▁size ▁= ▁FF MIN ▁( ▁255 ▁, ▁len ▁) ▁; ▁bytestream _ put _ byte ▁( ▁bytestream ▁, ▁size ▁) ▁; ▁if ▁( ▁end ▁- ▁* ▁bytestream ▁< ▁size ▁) ▁return ▁-1 ▁; ▁bytestream _ put _ buffer ▁( ▁bytestream ▁, ▁ptr ▁, ▁size ▁) ▁; ▁ptr ▁+= ▁size ▁; ▁len ▁-= ▁size ▁; ▁} ▁bytestream _ put _ byte ▁( ▁bytestream ▁, ▁0 x 00 ▁) ▁; ▁bytestream _ put _ byte ▁( ▁bytestream ▁, ▁0 x 3 b ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁av _ always _ inline ▁void ▁filter _ mb _ mb aff _ ed g ec v ▁( ▁const ▁H 264 Context ▁* ▁h ▁, ▁uint 8_ t ▁* ▁pix ▁, ▁int ▁stride ▁, ▁const ▁int 16_ t ▁b S ▁[ ▁7 ▁] ▁, ▁int ▁b si ▁, ▁int ▁qp ▁, ▁int ▁a ▁, ▁int ▁b ▁, ▁int ▁in tra ▁) ▁{ ▁const ▁unsigned ▁int ▁index _ a ▁= ▁qp ▁+ ▁a ▁; ▁const ▁int ▁alpha ▁= ▁alpha _ table ▁[ ▁index _ a ▁] ▁; ▁const ▁int ▁beta ▁= ▁beta _ table ▁[ ▁qp ▁+ ▁b ▁] ▁; ▁if ▁( ▁alpha ▁== ▁0 ▁|| ▁beta ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁b S ▁[ ▁0 ▁] ▁< ▁4 ▁|| ▁! ▁in tra ▁) ▁{ ▁int 8_ t ▁tc ▁[ ▁4 ▁] ▁; ▁tc ▁[ ▁0 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁0 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁tc ▁[ ▁1 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁1 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁tc ▁[ ▁2 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁2 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁tc ▁[ ▁3 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁3 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁h ▁-> ▁h 264 dsp ▁. ▁h 264_ h _ loop _ filter _ chroma _ mb aff ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁, ▁tc ▁) ▁; ▁} ▁else ▁{ ▁h ▁-> ▁h 264 dsp ▁. ▁h 264_ h _ loop _ filter _ chroma _ mb aff _ intra ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁) ▁; ▁} ▁}	1
▁static ▁void ▁ngx _ http _ init _ request ▁( ▁ngx _ event _ t ▁* ▁rev ▁) ▁{ ▁ngx _ pool _ t ▁* ▁pool ▁; ▁ngx _ time _ t ▁* ▁tp ▁; ▁ngx _ connection _ t ▁* ▁c ▁; ▁ngx _ http _ request _ t ▁* ▁r ▁; ▁ngx _ http _ log _ ctx _ t ▁* ▁ctx ▁; ▁ngx _ http _ connection _ t ▁* ▁hc ▁; ▁ngx _ http _ core _ srv _ conf _ t ▁* ▁csc f ▁; ▁ngx _ http _ core _ loc _ conf _ t ▁* ▁cl cf ▁; ▁ngx _ http _ core _ main _ conf _ t ▁* ▁c mcf ▁; ▁c ▁= ▁rev ▁-> ▁data ▁; ▁if ▁( ▁rev ▁-> ▁timed out ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ INFO ▁, ▁c ▁-> ▁log ▁, ▁NGX _ E TIMEDOUT ▁, ▁" client timed out " ▁) ▁; ▁ngx _ http _ close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁c ▁-> ▁requests ▁++ ▁; ▁hc ▁= ▁c ▁-> ▁data ▁; ▁csc f ▁= ▁ngx _ http _ get _ module _ srv _ conf ▁( ▁hc ▁-> ▁conf _ ctx ▁, ▁ngx _ http _ core _ module ▁) ▁; ▁pool ▁= ▁ngx _ create _ pool ▁( ▁csc f ▁-> ▁request _ pool _ size ▁, ▁c ▁-> ▁log ▁) ▁; ▁if ▁( ▁pool ▁== ▁NULL ▁) ▁{ ▁ngx _ http _ close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁r ▁= ▁ngx _ pc alloc ▁( ▁pool ▁, ▁sizeof ▁( ▁ngx _ http _ request _ t ▁) ▁) ▁; ▁if ▁( ▁r ▁== ▁NULL ▁) ▁{ ▁ngx _ destroy _ pool ▁( ▁pool ▁) ▁; ▁ngx _ http _ close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁r ▁-> ▁pool ▁= ▁pool ▁; ▁r ▁-> ▁pipeline ▁= ▁hc ▁-> ▁pipeline ▁; ▁c ▁-> ▁data ▁= ▁r ▁; ▁r ▁-> ▁http _ connection ▁= ▁hc ▁; ▁c ▁-> ▁sent ▁= ▁0 ▁; ▁r ▁-> ▁signature ▁= ▁NGX _ HTTP _ MODULE ▁; ▁r ▁-> ▁connection ▁= ▁c ▁; ▁r ▁-> ▁main _ conf ▁= ▁hc ▁-> ▁conf _ ctx ▁-> ▁main _ conf ▁; ▁r ▁-> ▁srv _ conf ▁= ▁hc ▁-> ▁conf _ ctx ▁-> ▁srv _ conf ▁; ▁r ▁-> ▁loc _ conf ▁= ▁hc ▁-> ▁conf _ ctx ▁-> ▁loc _ conf ▁; ▁r ▁-> ▁read _ event _ handler ▁= ▁ngx _ http _ block _ reading ▁; ▁cl cf ▁= ▁ngx _ http _ get _ module _ loc _ conf ▁( ▁r ▁, ▁ngx _ http _ core _ module ▁) ▁; ▁ngx _ http _ set _ connection _ log ▁( ▁r ▁-> ▁connection ▁, ▁cl cf ▁-> ▁error _ log ▁) ▁; ▁if ▁( ▁c ▁-> ▁buffer ▁== ▁NULL ▁) ▁{ ▁c ▁-> ▁buffer ▁= ▁ngx _ create _ temp _ buf ▁( ▁c ▁-> ▁pool ▁, ▁csc f ▁-> ▁client _ header _ buffer _ size ▁) ▁; ▁if ▁( ▁c ▁-> ▁buffer ▁== ▁NULL ▁) ▁{ ▁ngx _ destroy _ pool ▁( ▁r ▁-> ▁pool ▁) ▁; ▁ngx _ http _ close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁} ▁r ▁-> ▁header _ in ▁= ▁hc ▁-> ▁n busy ▁? ▁hc ▁-> ▁busy ▁[ ▁0 ▁] ▁: ▁c ▁-> ▁buffer ▁; ▁if ▁( ▁ngx _ list _ init ▁( ▁& ▁r ▁-> ▁headers _ out ▁. ▁headers ▁, ▁r ▁-> ▁pool ▁, ▁20 ▁, ▁sizeof ▁( ▁ngx _ table _ elt _ t ▁) ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁ngx _ destroy _ pool ▁( ▁r ▁-> ▁pool ▁) ▁; ▁ngx _ http _ close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁r ▁-> ▁ctx ▁= ▁ngx _ pc alloc ▁( ▁r ▁-> ▁pool ▁, ▁sizeof ▁( ▁void ▁* ▁) ▁* ▁ngx _ http _ max _ module ▁) ▁; ▁if ▁( ▁r ▁-> ▁ctx ▁== ▁NULL ▁) ▁{ ▁ngx _ destroy _ pool ▁( ▁r ▁-> ▁pool ▁) ▁; ▁ngx _ http _ close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁c mcf ▁= ▁ngx _ http _ get _ module _ main _ conf ▁( ▁r ▁, ▁ngx _ http _ core _ module ▁) ▁; ▁r ▁-> ▁variables ▁= ▁ngx _ pc alloc ▁( ▁r ▁-> ▁pool ▁, ▁c mcf ▁-> ▁variables ▁. ▁nel ts ▁* ▁sizeof ▁( ▁ngx _ http _ variable _ value _ t ▁) ▁) ▁; ▁if ▁( ▁r ▁-> ▁variables ▁== ▁NULL ▁) ▁{ ▁ngx _ destroy _ pool ▁( ▁r ▁-> ▁pool ▁) ▁; ▁ngx _ http _ close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁c ▁-> ▁single _ connection ▁= ▁1 ▁; ▁c ▁-> ▁destroyed ▁= ▁0 ▁; ▁# if ▁( ▁NGX _ HTTP _ SSL ▁) ▁if ▁( ▁c ▁-> ▁ssl ▁) ▁{ ▁r ▁-> ▁main _ filter _ need _ in _ memory ▁= ▁1 ▁; ▁} ▁# endif ▁r ▁-> ▁main ▁= ▁r ▁; ▁r ▁-> ▁count ▁= ▁1 ▁; ▁tp ▁= ▁ngx _ timeofday ▁( ▁) ▁; ▁r ▁-> ▁start _ sec ▁= ▁tp ▁-> ▁sec ▁; ▁r ▁-> ▁start _ msec ▁= ▁tp ▁-> ▁msec ▁; ▁r ▁-> ▁method ▁= ▁NGX _ HTTP _ UNKNOWN ▁; ▁r ▁-> ▁headers _ in ▁. ▁content _ length _ n ▁= ▁-1 ▁; ▁r ▁-> ▁headers _ in ▁. ▁keep _ alive _ n ▁= ▁-1 ▁; ▁r ▁-> ▁headers _ out ▁. ▁content _ length _ n ▁= ▁-1 ▁; ▁r ▁-> ▁headers _ out ▁. ▁last _ modified _ time ▁= ▁-1 ▁; ▁r ▁-> ▁uri _ changes ▁= ▁NGX _ HTTP _ MAX _ URI _ CHAN GES ▁+ ▁1 ▁; ▁r ▁-> ▁sub requests ▁= ▁NGX _ HTTP _ MAX _ SUB REQUEST S ▁+ ▁1 ▁; ▁r ▁-> ▁http _ state ▁= ▁NGX _ HTTP _ READ ING _ REQUEST _ STATE ▁; ▁ctx ▁= ▁c ▁-> ▁log ▁-> ▁data ▁; ▁ctx ▁-> ▁request ▁= ▁r ▁; ▁ctx ▁-> ▁current _ request ▁= ▁r ▁; ▁r ▁-> ▁log _ handler ▁= ▁ngx _ http _ log _ error _ handler ▁; ▁# if ▁( ▁NGX _ STAT _ STUB ▁) ▁( ▁void ▁) ▁ngx _ atomic _ fetch _ add ▁( ▁ngx _ stat _ reading ▁, ▁1 ▁) ▁; ▁r ▁-> ▁stat _ reading ▁= ▁1 ▁; ▁( ▁void ▁) ▁ngx _ atomic _ fetch _ add ▁( ▁ngx _ stat _ requests ▁, ▁1 ▁) ▁; ▁# endif ▁rev ▁-> ▁handler ▁= ▁ngx _ http _ process _ request _ line ▁; ▁ngx _ http _ process _ request _ line ▁( ▁rev ▁) ▁; ▁}	0
▁static ▁void ▁ctr _ XOR ▁( ▁RAND _ DR BG _ CTR ▁* ▁ctr ▁, ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁size _ t ▁inlen ▁) ▁{ ▁size _ t ▁i ▁, ▁n ▁; ▁if ▁( ▁in ▁== ▁NULL ▁|| ▁inlen ▁== ▁0 ▁) ▁return ▁; ▁n ▁= ▁inlen ▁< ▁ctr ▁-> ▁keylen ▁? ▁inlen ▁: ▁ctr ▁-> ▁keylen ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ctr ▁-> ▁K ▁[ ▁i ▁] ▁ ^ = ▁in ▁[ ▁i ▁] ▁; ▁if ▁( ▁inlen ▁<= ▁ctr ▁-> ▁keylen ▁) ▁return ▁; ▁n ▁= ▁inlen ▁- ▁ctr ▁-> ▁keylen ▁; ▁if ▁( ▁n ▁> ▁16 ▁) ▁{ ▁n ▁= ▁16 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁ctr ▁-> ▁V ▁[ ▁i ▁] ▁ ^ = ▁in ▁[ ▁i ▁+ ▁ctr ▁-> ▁keylen ▁] ▁; ▁}	0
▁int ▁ff _ w ma _ run _ level _ decode ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁Get Bit Context ▁* ▁gb ▁, ▁VLC ▁* ▁vlc ▁, ▁const ▁uint 16_ t ▁* ▁level _ table ▁, ▁const ▁uint 16_ t ▁* ▁run _ table ▁, ▁int ▁version ▁, ▁W MAC o ef ▁* ▁ptr ▁, ▁int ▁offset ▁, ▁int ▁num _ co efs ▁, ▁int ▁block _ len ▁, ▁int ▁frame _ len _ bits ▁, ▁int ▁coef _ nb _ bits ▁) ▁{ ▁int ▁code ▁, ▁run ▁, ▁level ▁, ▁sign ▁; ▁W MAC o ef ▁* ▁e ptr ▁= ▁ptr ▁+ ▁num _ co efs ▁; ▁ptr ▁+= ▁offset ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁code ▁= ▁get _ vlc 2 ▁( ▁gb ▁, ▁vlc ▁-> ▁table ▁, ▁VLC BITS ▁, ▁VLC MAX ▁) ▁; ▁if ▁( ▁code ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁code ▁== ▁1 ▁) ▁{ ▁break ▁; ▁} ▁else ▁if ▁( ▁code ▁== ▁0 ▁) ▁{ ▁if ▁( ▁! ▁version ▁) ▁{ ▁level ▁= ▁get _ bits ▁( ▁gb ▁, ▁coef _ nb _ bits ▁) ▁; ▁run ▁= ▁get _ bits ▁( ▁gb ▁, ▁frame _ len _ bits ▁) ▁; ▁} ▁else ▁{ ▁level ▁= ▁ff _ w ma _ get _ large _ val ▁( ▁gb ▁) ▁; ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" broken escape sequence \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁else ▁run ▁= ▁get _ bits ▁( ▁gb ▁, ▁frame _ len _ bits ▁) ▁+ ▁4 ▁; ▁} ▁else ▁run ▁= ▁get _ bits ▁( ▁gb ▁, ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁else ▁run ▁= ▁0 ▁; ▁} ▁} ▁else ▁{ ▁run ▁= ▁run _ table ▁[ ▁code ▁] ▁; ▁level ▁= ▁level _ table ▁[ ▁code ▁] ▁; ▁} ▁sign ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁if ▁( ▁! ▁sign ▁) ▁level ▁= ▁- ▁level ▁; ▁ptr ▁+= ▁run ▁; ▁if ▁( ▁ptr ▁>= ▁e ptr ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" overflow ins pectral R LE , ign oring \ n " ▁) ▁; ▁break ▁; ▁} ▁* ▁ptr ▁++ ▁= ▁level ▁; ▁if ▁( ▁ptr ▁>= ▁e ptr ▁) ▁break ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁xa _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁Max is X AD emux Context ▁* ▁xa ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁; ▁Byte IO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁unsigned ▁int ▁packet _ size ▁; ▁int ▁ret ▁; ▁if ▁( ▁xa ▁-> ▁sent _ bytes ▁> ▁xa ▁-> ▁out _ size ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁packet _ size ▁= ▁15 ▁* ▁st ▁-> ▁codec ▁-> ▁channels ▁; ▁ret ▁= ▁av _ get _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁packet _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁st ▁-> ▁index ▁; ▁xa ▁-> ▁sent _ bytes ▁+= ▁packet _ size ▁; ▁pkt ▁-> ▁pts ▁= ▁xa ▁-> ▁audio _ frame _ counter ▁; ▁xa ▁-> ▁audio _ frame _ counter ▁+= ▁28 ▁* ▁st ▁-> ▁codec ▁-> ▁channels ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁gif _ image _ write _ header ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁loop _ count ▁, ▁uint 32_ t ▁* ▁palette ▁) ▁{ ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁AVR ational ▁sar ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁-> ▁sample _ aspect _ ratio ▁; ▁int ▁i ▁; ▁int 64_ t ▁aspect ▁= ▁0 ▁; ▁if ▁( ▁sar ▁. ▁num ▁> ▁0 ▁&& ▁sar ▁. ▁den ▁> ▁0 ▁) ▁{ ▁aspect ▁= ▁sar ▁. ▁num ▁* ▁64 LL ▁/ ▁sar ▁. ▁den ▁- ▁15 ▁; ▁if ▁( ▁aspect ▁< ▁0 ▁|| ▁aspect ▁> ▁255 ▁) ▁aspect ▁= ▁0 ▁; ▁} ▁avio _ write ▁( ▁pb ▁, ▁" GIF " ▁, ▁3 ▁) ▁; ▁avio _ write ▁( ▁pb ▁, ▁" 89 a " ▁, ▁3 ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁width ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁height ▁) ▁; ▁if ▁( ▁palette ▁) ▁{ ▁avio _ w 8 ▁( ▁pb ▁, ▁0 xf 7 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 1 f ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁aspect ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁const ▁uint 32_ t ▁v ▁= ▁palette ▁[ ▁i ▁] ▁& ▁0 xffffff ▁; ▁avio _ wb 24 ▁( ▁pb ▁, ▁v ▁) ▁; ▁} ▁} ▁else ▁{ ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁aspect ▁) ▁; ▁} ▁if ▁( ▁loop _ count ▁>= ▁0 ▁) ▁{ ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 21 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 xff ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 0 b ▁) ▁; ▁avio _ write ▁( ▁pb ▁, ▁" NET SCAPE 2.0" ▁, ▁sizeof ▁( ▁" NET SCAPE 2.0" ▁) ▁- ▁1 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 03 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 01 ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁( ▁uint 16_ t ▁) ▁loop _ count ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 00 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁test _ export _ key _ mat _ early ▁( ▁int ▁idx ▁) ▁{ ▁static ▁const ▁char ▁label ▁[ ▁] ▁= ▁" test label " ▁; ▁static ▁const ▁unsigned ▁char ▁context ▁[ ▁] ▁= ▁" context " ▁; ▁int ▁test result ▁= ▁0 ▁; ▁SSL _ CTX ▁* ▁cctx ▁= ▁NULL ▁, ▁* ▁sctx ▁= ▁NULL ▁; ▁SSL ▁* ▁client ssl ▁= ▁NULL ▁, ▁* ▁server ssl ▁= ▁NULL ▁; ▁SSL _ SESSION ▁* ▁sess ▁= ▁NULL ▁; ▁const ▁unsigned ▁char ▁* ▁empty context ▁= ▁NULL ▁; ▁unsigned ▁char ▁c key mat 1 ▁[ ▁80 ▁] ▁, ▁c key mat 2 ▁[ ▁80 ▁] ▁; ▁unsigned ▁char ▁skey mat 1 ▁[ ▁80 ▁] ▁, ▁skey mat 2 ▁[ ▁80 ▁] ▁; ▁unsigned ▁char ▁buf ▁[ ▁1 ▁] ▁; ▁size _ t ▁read bytes ▁, ▁written ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁set u pe arly _ data _ test ▁( ▁& ▁cctx ▁, ▁& ▁sctx ▁, ▁& ▁client ssl ▁, ▁& ▁server ssl ▁, ▁& ▁sess ▁, ▁idx ▁) ▁) ▁) ▁goto ▁end ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ write _ early _ data ▁( ▁client ssl ▁, ▁NULL ▁, ▁0 ▁, ▁& ▁written ▁) ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁SSL _ read _ early _ data ▁( ▁server ssl ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁, ▁& ▁read bytes ▁) ▁, ▁SSL _ READ _ EARLY _ DATA _ ERROR ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁SSL _ get _ early _ data _ status ▁( ▁server ssl ▁) ▁, ▁SSL _ EARLY _ DATA _ ACCEPT ED ▁) ▁) ▁goto ▁end ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁SSL _ export _ key ing _ material _ early ▁( ▁client ssl ▁, ▁c key mat 1 ▁, ▁sizeof ▁( ▁c key mat 1 ▁) ▁, ▁label ▁, ▁sizeof ▁( ▁label ▁) ▁- ▁1 ▁, ▁context ▁, ▁sizeof ▁( ▁context ▁) ▁- ▁1 ▁) ▁, ▁1 ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁SSL _ export _ key ing _ material _ early ▁( ▁client ssl ▁, ▁c key mat 2 ▁, ▁sizeof ▁( ▁c key mat 2 ▁) ▁, ▁label ▁, ▁sizeof ▁( ▁label ▁) ▁- ▁1 ▁, ▁empty context ▁, ▁0 ▁) ▁, ▁1 ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁SSL _ export _ key ing _ material _ early ▁( ▁server ssl ▁, ▁skey mat 1 ▁, ▁sizeof ▁( ▁skey mat 1 ▁) ▁, ▁label ▁, ▁sizeof ▁( ▁label ▁) ▁- ▁1 ▁, ▁context ▁, ▁sizeof ▁( ▁context ▁) ▁- ▁1 ▁) ▁, ▁1 ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁SSL _ export _ key ing _ material _ early ▁( ▁server ssl ▁, ▁skey mat 2 ▁, ▁sizeof ▁( ▁skey mat 2 ▁) ▁, ▁label ▁, ▁sizeof ▁( ▁label ▁) ▁- ▁1 ▁, ▁empty context ▁, ▁0 ▁) ▁, ▁1 ▁) ▁|| ▁! ▁TEST _ mem _ eq ▁( ▁c key mat 1 ▁, ▁sizeof ▁( ▁c key mat 1 ▁) ▁, ▁skey mat 1 ▁, ▁sizeof ▁( ▁skey mat 1 ▁) ▁) ▁|| ▁! ▁TEST _ mem _ eq ▁( ▁c key mat 2 ▁, ▁sizeof ▁( ▁c key mat 2 ▁) ▁, ▁skey mat 2 ▁, ▁sizeof ▁( ▁skey mat 2 ▁) ▁) ▁|| ▁! ▁TEST _ mem _ ne ▁( ▁c key mat 1 ▁, ▁sizeof ▁( ▁c key mat 1 ▁) ▁, ▁c key mat 2 ▁, ▁sizeof ▁( ▁c key mat 2 ▁) ▁) ▁) ▁goto ▁end ▁; ▁test result ▁= ▁1 ▁; ▁end ▁: ▁SSL _ SESSION _ free ▁( ▁sess ▁) ▁; ▁SSL _ SESSION _ free ▁( ▁client ps k ▁) ▁; ▁SSL _ SESSION _ free ▁( ▁server ps k ▁) ▁; ▁client ps k ▁= ▁server ps k ▁= ▁NULL ▁; ▁SSL _ free ▁( ▁server ssl ▁) ▁; ▁SSL _ free ▁( ▁client ssl ▁) ▁; ▁SSL _ CTX _ free ▁( ▁sctx ▁) ▁; ▁SSL _ CTX _ free ▁( ▁cctx ▁) ▁; ▁return ▁test result ▁; ▁}	0
▁static ▁int ▁read _ channels ▁( ▁AVFilter Context ▁* ▁ctx ▁, ▁int ▁channels ▁, ▁uint 8_ t ▁* ▁item _ str ▁, ▁int ▁* ▁nb ▁, ▁double ▁* ▁* ▁c ▁, ▁double ▁* ▁* ▁cache ▁) ▁{ ▁char ▁* ▁p ▁, ▁* ▁arg ▁, ▁* ▁old _ str ▁, ▁* ▁prev _ arg ▁= ▁NULL ▁, ▁* ▁save ptr ▁= ▁NULL ▁; ▁int ▁i ▁, ▁ret ▁; ▁p ▁= ▁old _ str ▁= ▁av _ strdup ▁( ▁item _ str ▁) ▁; ▁if ▁( ▁! ▁p ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁arg ▁= ▁av _ strto k ▁( ▁p ▁, ▁"|" ▁, ▁& ▁save ptr ▁) ▁) ▁) ▁arg ▁= ▁prev _ arg ▁; ▁if ▁( ▁! ▁arg ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁count _ coeff icients ▁( ▁arg ▁, ▁& ▁nb ▁[ ▁i ▁] ▁) ▁; ▁p ▁= ▁NULL ▁; ▁cache ▁[ ▁i ▁] ▁= ▁av _ calloc ▁( ▁nb ▁[ ▁i ▁] ▁+ ▁1 ▁, ▁sizeof ▁( ▁double ▁) ▁) ▁; ▁c ▁[ ▁i ▁] ▁= ▁av _ calloc ▁( ▁nb ▁[ ▁i ▁] ▁, ▁sizeof ▁( ▁double ▁) ▁) ▁; ▁if ▁( ▁! ▁c ▁[ ▁i ▁] ▁|| ▁! ▁cache ▁[ ▁i ▁] ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁ret ▁= ▁read _ coeff icients ▁( ▁ctx ▁, ▁arg ▁, ▁nb ▁[ ▁i ▁] ▁, ▁c ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁prev _ arg ▁= ▁arg ▁; ▁} ▁av _ freep ▁( ▁& ▁old _ str ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁set _ s ps ▁( ▁H EV C Context ▁* ▁s ▁, ▁const ▁H EV C SP S ▁* ▁sps ▁) ▁{ ▁# define ▁HW ACCEL _ MAX ▁( CONFIG _ H EV C _ DX VA 2_ HW ACCEL + CONFIG _ H EV C _ D 3 D 11 VA _ HW ACCEL ) ▁enum ▁AV PixelFormat ▁pix _ fmts ▁[ ▁HW ACCEL _ MAX ▁+ ▁2 ▁] ▁, ▁* ▁fmt ▁= ▁pix _ fmts ▁; ▁int ▁ret ▁; ▁pic _ arrays _ free ▁( ▁s ▁) ▁; ▁s ▁-> ▁ps ▁. ▁sps ▁= ▁NULL ▁; ▁s ▁-> ▁ps ▁. ▁v ps ▁= ▁NULL ▁; ▁if ▁( ▁! ▁sps ▁) ▁return ▁0 ▁; ▁ret ▁= ▁pic _ arrays _ init ▁( ▁s ▁, ▁sps ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁export _ stream _ params ▁( ▁s ▁-> ▁avctx ▁, ▁& ▁s ▁-> ▁ps ▁, ▁sps ▁) ▁; ▁if ▁( ▁sps ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ YUV 420 P ▁|| ▁sps ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ YUV J 420 P ▁) ▁{ ▁# if ▁CONFIG _ H EV C _ DX VA 2_ HW ACCEL ▁* ▁fmt ▁++ ▁= ▁AV _ PIX _ FMT _ DX VA 2_ V LD ▁; ▁# endif ▁# if ▁CONFIG _ H EV C _ D 3 D 11 VA _ HW ACCEL ▁* ▁fmt ▁++ ▁= ▁AV _ PIX _ FMT _ D 3 D 11 VA _ V LD ▁; ▁# endif ▁} ▁* ▁fmt ▁++ ▁= ▁sps ▁-> ▁pix _ fmt ▁; ▁* ▁fmt ▁= ▁AV _ PIX _ FMT _ NONE ▁; ▁ret ▁= ▁ff _ get _ format ▁( ▁s ▁-> ▁avctx ▁, ▁pix _ fmts ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁ret ▁; ▁ff _ he vc _ pred _ init ▁( ▁& ▁s ▁-> ▁hpc ▁, ▁sps ▁-> ▁bit _ depth ▁) ▁; ▁ff _ he vc _ dsp _ init ▁( ▁& ▁s ▁-> ▁he vc dsp ▁, ▁sps ▁-> ▁bit _ depth ▁) ▁; ▁ff _ vide od sp _ init ▁( ▁& ▁s ▁-> ▁v dsp ▁, ▁sps ▁-> ▁bit _ depth ▁) ▁; ▁if ▁( ▁sps ▁-> ▁sa o _ enabled ▁&& ▁! ▁s ▁-> ▁avctx ▁-> ▁hw accel ▁) ▁{ ▁av _ frame _ unref ▁( ▁s ▁-> ▁tmp _ frame ▁) ▁; ▁ret ▁= ▁ff _ get _ buffer ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁tmp _ frame ▁, ▁AV _ GET _ BUFFER _ FLAG _ REF ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁frame ▁= ▁s ▁-> ▁tmp _ frame ▁; ▁} ▁s ▁-> ▁ps ▁. ▁sps ▁= ▁sps ▁; ▁s ▁-> ▁ps ▁. ▁v ps ▁= ▁( ▁H EV CV PS ▁* ▁) ▁s ▁-> ▁ps ▁. ▁v ps _ list ▁[ ▁s ▁-> ▁ps ▁. ▁sps ▁-> ▁v ps _ id ▁] ▁-> ▁data ▁; ▁return ▁0 ▁; ▁fail ▁: ▁pic _ arrays _ free ▁( ▁s ▁) ▁; ▁s ▁-> ▁ps ▁. ▁sps ▁= ▁NULL ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁str _ copy ▁( ▁CONF ▁* ▁conf ▁, ▁char ▁* ▁section ▁, ▁char ▁* ▁* ▁p to ▁, ▁char ▁* ▁from ▁) ▁{ ▁int ▁q ▁, ▁r ▁, ▁rr ▁= ▁0 ▁, ▁to ▁= ▁0 ▁, ▁len ▁= ▁0 ▁; ▁char ▁* ▁s ▁, ▁* ▁e ▁, ▁* ▁rp ▁, ▁* ▁p ▁, ▁* ▁r rp ▁, ▁* ▁np ▁, ▁* ▁cp ▁, ▁v ▁; ▁BUF _ MEM ▁* ▁buf ▁; ▁if ▁( ▁( ▁buf ▁= ▁BUF _ MEM _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁len ▁= ▁strlen ▁( ▁from ▁) ▁+ ▁1 ▁; ▁if ▁( ▁! ▁BUF _ MEM _ grow ▁( ▁buf ▁, ▁len ▁) ▁) ▁goto ▁err ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁IS _ QUOTE ▁( ▁conf ▁, ▁* ▁from ▁) ▁) ▁{ ▁q ▁= ▁* ▁from ▁; ▁from ▁++ ▁; ▁while ▁( ▁! ▁IS _ EOF ▁( ▁conf ▁, ▁* ▁from ▁) ▁&& ▁( ▁* ▁from ▁!= ▁q ▁) ▁) ▁{ ▁if ▁( ▁IS _ ESC ▁( ▁conf ▁, ▁* ▁from ▁) ▁) ▁{ ▁from ▁++ ▁; ▁if ▁( ▁IS _ EOF ▁( ▁conf ▁, ▁* ▁from ▁) ▁) ▁break ▁; ▁} ▁buf ▁-> ▁data ▁[ ▁to ▁++ ▁] ▁= ▁* ▁( ▁from ▁++ ▁) ▁; ▁} ▁if ▁( ▁* ▁from ▁== ▁q ▁) ▁from ▁++ ▁; ▁} ▁else ▁if ▁( ▁IS _ D QUOTE ▁( ▁conf ▁, ▁* ▁from ▁) ▁) ▁{ ▁q ▁= ▁* ▁from ▁; ▁from ▁++ ▁; ▁while ▁( ▁! ▁IS _ EOF ▁( ▁conf ▁, ▁* ▁from ▁) ▁) ▁{ ▁if ▁( ▁* ▁from ▁== ▁q ▁) ▁{ ▁if ▁( ▁* ▁( ▁from ▁+ ▁1 ▁) ▁== ▁q ▁) ▁{ ▁from ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁buf ▁-> ▁data ▁[ ▁to ▁++ ▁] ▁= ▁* ▁( ▁from ▁++ ▁) ▁; ▁} ▁if ▁( ▁* ▁from ▁== ▁q ▁) ▁from ▁++ ▁; ▁} ▁else ▁if ▁( ▁IS _ ESC ▁( ▁conf ▁, ▁* ▁from ▁) ▁) ▁{ ▁from ▁++ ▁; ▁v ▁= ▁* ▁( ▁from ▁++ ▁) ▁; ▁if ▁( ▁IS _ EOF ▁( ▁conf ▁, ▁v ▁) ▁) ▁break ▁; ▁else ▁if ▁( ▁v ▁== ▁' ▁' ▁) ▁v ▁= ▁' ▁\ r ▁' ▁; ▁else ▁if ▁( ▁v ▁== ▁' ▁' ▁) ▁v ▁= ▁' ▁\ n ▁' ▁; ▁else ▁if ▁( ▁v ▁== ▁' ▁' ▁) ▁v ▁= ▁' ▁\ b ▁' ▁; ▁else ▁if ▁( ▁v ▁== ▁' ▁' ▁) ▁v ▁= ▁' ▁\ t ▁' ▁; ▁buf ▁-> ▁data ▁[ ▁to ▁++ ▁] ▁= ▁v ▁; ▁} ▁else ▁if ▁( ▁IS _ EOF ▁( ▁conf ▁, ▁* ▁from ▁) ▁) ▁break ▁; ▁else ▁if ▁( ▁* ▁from ▁== ▁' ▁' ▁) ▁{ ▁r rp ▁= ▁NULL ▁; ▁s ▁= ▁& ▁( ▁from ▁[ ▁1 ▁] ▁) ▁; ▁if ▁( ▁* ▁s ▁== ▁' ▁' ▁) ▁q ▁= ▁' ▁' ▁; ▁else ▁if ▁( ▁* ▁s ▁== ▁' ▁' ▁) ▁q ▁= ▁' ▁' ▁; ▁else ▁q ▁= ▁0 ▁; ▁if ▁( ▁q ▁) ▁s ▁++ ▁; ▁cp ▁= ▁section ▁; ▁e ▁= ▁np ▁= ▁s ▁; ▁while ▁( ▁IS _ ALPHA _ NUMERIC ▁( ▁conf ▁, ▁* ▁e ▁) ▁) ▁e ▁++ ▁; ▁if ▁( ▁( ▁e ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁&& ▁( ▁e ▁[ ▁1 ▁] ▁== ▁' ▁' ▁) ▁) ▁{ ▁cp ▁= ▁np ▁; ▁r rp ▁= ▁e ▁; ▁rr ▁= ▁* ▁e ▁; ▁* ▁r rp ▁= ▁' ▁\0 ▁' ▁; ▁e ▁+= ▁2 ▁; ▁np ▁= ▁e ▁; ▁while ▁( ▁IS _ ALPHA _ NUMERIC ▁( ▁conf ▁, ▁* ▁e ▁) ▁) ▁e ▁++ ▁; ▁} ▁r ▁= ▁* ▁e ▁; ▁* ▁e ▁= ▁' ▁\0 ▁' ▁; ▁rp ▁= ▁e ▁; ▁if ▁( ▁q ▁) ▁{ ▁if ▁( ▁r ▁!= ▁q ▁) ▁{ ▁CONF err ▁( ▁CONF _ F _ STR _ COPY ▁, ▁CONF _ R _ NO _ CLOSE _ BR ACE ▁) ▁; ▁goto ▁err ▁; ▁} ▁e ▁++ ▁; ▁} ▁p ▁= ▁_ CONF _ get _ string ▁( ▁conf ▁, ▁cp ▁, ▁np ▁) ▁; ▁if ▁( ▁r rp ▁!= ▁NULL ▁) ▁* ▁r rp ▁= ▁rr ▁; ▁* ▁rp ▁= ▁r ▁; ▁if ▁( ▁p ▁== ▁NULL ▁) ▁{ ▁CONF err ▁( ▁CONF _ F _ STR _ COPY ▁, ▁CONF _ R _ VARIABLE _ HAS _ NO _ VALUE ▁) ▁; ▁goto ▁err ▁; ▁} ▁BUF _ MEM _ grow _ clean ▁( ▁buf ▁, ▁( ▁strlen ▁( ▁p ▁) ▁+ ▁len ▁- ▁( ▁e ▁- ▁from ▁) ▁) ▁) ▁; ▁while ▁( ▁* ▁p ▁) ▁buf ▁-> ▁data ▁[ ▁to ▁++ ▁] ▁= ▁* ▁( ▁p ▁++ ▁) ▁; ▁from ▁= ▁e ▁; ▁} ▁else ▁buf ▁-> ▁data ▁[ ▁to ▁++ ▁] ▁= ▁* ▁( ▁from ▁++ ▁) ▁; ▁} ▁buf ▁-> ▁data ▁[ ▁to ▁] ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁* ▁p to ▁!= ▁NULL ▁) ▁OPENSSL _ free ▁( ▁* ▁p to ▁) ▁; ▁* ▁p to ▁= ▁buf ▁-> ▁data ▁; ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁err ▁: ▁if ▁( ▁buf ▁!= ▁NULL ▁) ▁BUF _ MEM _ free ▁( ▁buf ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁}	1
▁static ▁int ▁e ights vx _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame _ ptr ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁E ight S vx Context ▁* ▁esc ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁buf _ size ▁; ▁int ▁ch ▁, ▁ret ▁; ▁int ▁hdr _ size ▁= ▁2 ▁; ▁if ▁( ▁! ▁esc ▁-> ▁data ▁[ ▁0 ▁] ▁&& ▁avpkt ▁) ▁{ ▁int ▁chan _ size ▁= ▁avpkt ▁-> ▁size ▁/ ▁avctx ▁-> ▁channels ▁- ▁hdr _ size ▁; ▁if ▁( ▁avpkt ▁-> ▁size ▁% ▁avctx ▁-> ▁channels ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Packet with odd size , ign oring last byte \ n " ▁) ▁; ▁} ▁if ▁( ▁avpkt ▁-> ▁size ▁< ▁( ▁hdr _ size ▁+ ▁1 ▁) ▁* ▁avctx ▁-> ▁channels ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" packet size ist oo small \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁esc ▁-> ▁fib _ acc ▁[ ▁0 ▁] ▁= ▁avpkt ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁128 ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁== ▁2 ▁) ▁esc ▁-> ▁fib _ acc ▁[ ▁1 ▁] ▁= ▁avpkt ▁-> ▁data ▁[ ▁2 ▁+ ▁chan _ size ▁+ ▁1 ▁] ▁+ ▁128 ▁; ▁esc ▁-> ▁data _ idx ▁= ▁0 ▁; ▁esc ▁-> ▁data _ size ▁= ▁chan _ size ▁; ▁if ▁( ▁! ▁( ▁esc ▁-> ▁data ▁[ ▁0 ▁] ▁= ▁av _ malloc ▁( ▁chan _ size ▁) ▁) ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁== ▁2 ▁) ▁{ ▁if ▁( ▁! ▁( ▁esc ▁-> ▁data ▁[ ▁1 ▁] ▁= ▁av _ malloc ▁( ▁chan _ size ▁) ▁) ▁) ▁{ ▁av _ freep ▁( ▁& ▁esc ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁} ▁memcpy ▁( ▁esc ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁& ▁avpkt ▁-> ▁data ▁[ ▁hdr _ size ▁] ▁, ▁chan _ size ▁) ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁== ▁2 ▁) ▁memcpy ▁( ▁esc ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁& ▁avpkt ▁-> ▁data ▁[ ▁2 ▁* ▁hdr _ size ▁+ ▁chan _ size ▁] ▁, ▁chan _ size ▁) ▁; ▁} ▁if ▁( ▁! ▁esc ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" un expect ede mpty packet \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁buf _ size ▁= ▁FF MIN ▁( ▁MAX _ FRAME _ SIZE ▁, ▁esc ▁-> ▁data _ size ▁- ▁esc ▁-> ▁data _ idx ▁) ▁; ▁if ▁( ▁buf _ size ▁<= ▁0 ▁) ▁{ ▁* ▁got _ frame _ ptr ▁= ▁0 ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁} ▁esc ▁-> ▁frame ▁. ▁nb _ samples ▁= ▁buf _ size ▁* ▁2 ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁& ▁esc ▁-> ▁frame ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁avctx ▁-> ▁channels ▁; ▁ch ▁++ ▁) ▁{ ▁delta _ decode ▁( ▁esc ▁-> ▁frame ▁. ▁data ▁[ ▁ch ▁] ▁, ▁& ▁esc ▁-> ▁data ▁[ ▁ch ▁] ▁[ ▁esc ▁-> ▁data _ idx ▁] ▁, ▁buf _ size ▁, ▁& ▁esc ▁-> ▁fib _ acc ▁[ ▁ch ▁] ▁, ▁esc ▁-> ▁table ▁) ▁; ▁} ▁esc ▁-> ▁data _ idx ▁+= ▁buf _ size ▁; ▁* ▁got _ frame _ ptr ▁= ▁1 ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁esc ▁-> ▁frame ▁; ▁return ▁( ▁( ▁avctx ▁-> ▁frame _ number ▁== ▁0 ▁) ▁* ▁hdr _ size ▁+ ▁buf _ size ▁) ▁* ▁avctx ▁-> ▁channels ▁; ▁}	0
▁void ▁ff _ MP V _ frame _ end ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁CONFIG _ MPEG _ X VM C _ DECODER ▁&& ▁s ▁-> ▁avctx ▁-> ▁x vm c _ ac celeration ▁) ▁{ ▁ff _ x vm c _ field _ end ▁( ▁s ▁) ▁; ▁} ▁else ▁if ▁( ▁( ▁s ▁-> ▁error _ count ▁|| ▁s ▁-> ▁encoding ▁) ▁&& ▁! ▁s ▁-> ▁avctx ▁-> ▁hw accel ▁&& ▁! ▁( ▁s ▁-> ▁avctx ▁-> ▁codec ▁-> ▁capabilities ▁& ▁CODEC _ CAP _ HW ACCEL _ VD PA U ▁) ▁&& ▁s ▁-> ▁un restricted _ mv ▁&& ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁reference ▁&& ▁! ▁s ▁-> ▁in tra _ only ▁&& ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ EMU _ EDGE ▁) ▁) ▁{ ▁int ▁h shift ▁= ▁av _ pix _ fmt _ descriptors ▁[ ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁] ▁. ▁log 2_ chroma _ w ▁; ▁int ▁v shift ▁= ▁av _ pix _ fmt _ descriptors ▁[ ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁] ▁. ▁log 2_ chroma _ h ▁; ▁s ▁-> ▁dsp ▁. ▁draw _ edges ▁( ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁, ▁EDGE _ WIDTH ▁, ▁EDGE _ WIDTH ▁, ▁EDGE _ TOP ▁| ▁EDGE _ BOTTOM ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁draw _ edges ▁( ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁1 ▁] ▁, ▁s ▁-> ▁uv lines ize ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁h shift ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁v shift ▁, ▁EDGE _ WIDTH ▁>> ▁h shift ▁, ▁EDGE _ WIDTH ▁>> ▁v shift ▁, ▁EDGE _ TOP ▁| ▁EDGE _ BOTTOM ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁draw _ edges ▁( ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁2 ▁] ▁, ▁s ▁-> ▁uv lines ize ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁h shift ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁v shift ▁, ▁EDGE _ WIDTH ▁>> ▁h shift ▁, ▁EDGE _ WIDTH ▁>> ▁v shift ▁, ▁EDGE _ TOP ▁| ▁EDGE _ BOTTOM ▁) ▁; ▁} ▁e mm s _ c ▁( ▁) ▁; ▁s ▁-> ▁last _ p ict _ type ▁= ▁s ▁-> ▁pict _ type ▁; ▁s ▁-> ▁last _ lambda _ for ▁[ ▁s ▁-> ▁pict _ type ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁quality ▁; ▁if ▁( ▁s ▁-> ▁pict _ type ▁!= ▁AV _ PICTURE _ TYPE _ B ▁) ▁{ ▁s ▁-> ▁last _ non _ b _ p ict _ type ▁= ▁s ▁-> ▁pict _ type ▁; ▁} ▁# if ▁0 ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁== ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁) ▁{ ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁= ▁s ▁-> ▁current _ picture ▁; ▁break ▁; ▁} ▁} ▁assert ▁( ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁) ▁; ▁# endif ▁if ▁( ▁s ▁-> ▁encoding ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁picture _ count ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁. ▁data ▁[ ▁0 ▁] ▁&& ▁! ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁. ▁reference ▁) ▁{ ▁free _ frame _ buffer ▁( ▁s ▁, ▁& ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁} ▁# if ▁0 ▁memset ▁( ▁& ▁s ▁-> ▁last _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁Picture ▁) ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁next _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁Picture ▁) ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁current _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁Picture ▁) ▁) ▁; ▁# endif ▁s ▁-> ▁avctx ▁-> ▁coded _ frame ▁= ▁& ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁; ▁if ▁( ▁s ▁-> ▁codec _ id ▁!= ▁CODEC _ ID _ H 264 ▁&& ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁reference ▁) ▁{ ▁ff _ thread _ report _ progress ▁( ▁& ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁, ▁INT _ MAX ▁, ▁0 ▁) ▁; ▁} ▁}	1
▁X 509_ STORE _ CTX ▁* ▁X 509_ STORE _ CTX _ new ▁( ▁void ▁) ▁{ ▁X 509_ STORE _ CTX ▁* ▁ctx ▁; ▁ctx ▁= ▁( ▁X 509_ STORE _ CTX ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁X 509_ STORE _ CTX ▁) ▁) ▁; ▁if ▁( ▁ctx ▁) ▁memset ▁( ▁ctx ▁, ▁0 ▁, ▁sizeof ▁( ▁X 509_ STORE _ CTX ▁) ▁) ▁; ▁return ▁ctx ▁; ▁}	1
▁static ▁int ▁h ls _ read _ seek ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁stream _ index ▁, ▁int 64_ t ▁timestamp ▁, ▁int ▁flags ▁) ▁{ ▁H LS Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁struct ▁playlist ▁* ▁seek _ pls ▁= ▁NULL ▁; ▁int ▁i ▁, ▁seq _ no ▁; ▁int 64_ t ▁seek _ timestamp ▁; ▁if ▁( ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BYTE ▁) ▁|| ▁! ▁c ▁-> ▁variants ▁[ ▁0 ▁] ▁-> ▁play lists ▁[ ▁0 ▁] ▁-> ▁finished ▁) ▁return ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁seek _ timestamp ▁= ▁av _ re scale _ rnd ▁( ▁timestamp ▁, ▁AV _ TIME _ BASE ▁, ▁s ▁-> ▁streams ▁[ ▁stream _ index ▁] ▁-> ▁time _ base ▁. ▁den ▁, ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁? ▁AV _ ROUND _ DOWN ▁: ▁AV _ ROUND _ UP ▁) ▁; ▁if ▁( ▁s ▁-> ▁duration ▁< ▁seek _ timestamp ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁n _ play lists ▁; ▁i ▁++ ▁) ▁{ ▁struct ▁playlist ▁* ▁p ls ▁= ▁c ▁-> ▁play lists ▁[ ▁i ▁] ▁; ▁if ▁( ▁stream _ index ▁>= ▁p ls ▁-> ▁stream _ offset ▁&& ▁stream _ index ▁- ▁p ls ▁-> ▁stream _ offset ▁< ▁p ls ▁-> ▁ctx ▁-> ▁nb _ streams ▁) ▁{ ▁seek _ pls ▁= ▁p ls ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁seek _ pls ▁|| ▁! ▁find _ timestamp _ in _ playlist ▁( ▁c ▁, ▁seek _ pls ▁, ▁seek _ timestamp ▁, ▁& ▁seq _ no ▁) ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁seek _ pls ▁-> ▁cur _ seq _ no ▁= ▁seq _ no ▁; ▁seek _ pls ▁-> ▁seek _ stream _ index ▁= ▁stream _ index ▁- ▁seek _ pls ▁-> ▁stream _ offset ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁n _ play lists ▁; ▁i ▁++ ▁) ▁{ ▁struct ▁playlist ▁* ▁p ls ▁= ▁c ▁-> ▁play lists ▁[ ▁i ▁] ▁; ▁if ▁( ▁p ls ▁-> ▁input ▁) ▁{ ▁ff url _ close ▁( ▁p ls ▁-> ▁input ▁) ▁; ▁p ls ▁-> ▁input ▁= ▁NULL ▁; ▁} ▁av _ free _ packet ▁( ▁& ▁p ls ▁-> ▁pkt ▁) ▁; ▁reset _ packet ▁( ▁& ▁p ls ▁-> ▁pkt ▁) ▁; ▁p ls ▁-> ▁pb ▁. ▁eof _ reached ▁= ▁0 ▁; ▁p ls ▁-> ▁pb ▁. ▁buf _ end ▁= ▁p ls ▁-> ▁pb ▁. ▁buf _ ptr ▁= ▁p ls ▁-> ▁pb ▁. ▁buffer ▁; ▁p ls ▁-> ▁pb ▁. ▁pos ▁= ▁0 ▁; ▁p ls ▁-> ▁seek _ timestamp ▁= ▁seek _ timestamp ▁; ▁p ls ▁-> ▁seek _ flags ▁= ▁flags ▁; ▁if ▁( ▁p ls ▁!= ▁seek _ pls ▁) ▁{ ▁find _ timestamp _ in _ playlist ▁( ▁c ▁, ▁p ls ▁, ▁seek _ timestamp ▁, ▁& ▁p ls ▁-> ▁cur _ seq _ no ▁) ▁; ▁p ls ▁-> ▁seek _ stream _ index ▁= ▁-1 ▁; ▁p ls ▁-> ▁seek _ flags ▁|= ▁AV SEEK _ FLAG _ ANY ▁; ▁} ▁} ▁c ▁-> ▁cur _ timestamp ▁= ▁seek _ timestamp ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁copy _ packet _ data ▁( ▁AVPacket ▁* ▁pkt ▁, ▁const ▁AVPacket ▁* ▁src ▁, ▁int ▁dup ▁) ▁{ ▁pkt ▁-> ▁data ▁= ▁NULL ▁; ▁pkt ▁-> ▁side _ data ▁= ▁NULL ▁; ▁pkt ▁-> ▁side _ data _ elems ▁= ▁0 ▁; ▁if ▁( ▁pkt ▁-> ▁buf ▁) ▁{ ▁AV Buffer Ref ▁* ▁ref ▁= ▁av _ buffer _ ref ▁( ▁src ▁-> ▁buf ▁) ▁; ▁if ▁( ▁! ▁ref ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁pkt ▁-> ▁buf ▁= ▁ref ▁; ▁pkt ▁-> ▁data ▁= ▁ref ▁-> ▁data ▁; ▁} ▁else ▁{ ▁DUP _ DATA ▁( ▁pkt ▁-> ▁data ▁, ▁src ▁-> ▁data ▁, ▁pkt ▁-> ▁size ▁, ▁1 ▁, ▁ALLOC _ BUF ▁) ▁; ▁} ▁if ▁( ▁src ▁-> ▁side _ data _ elems ▁&& ▁dup ▁) ▁{ ▁pkt ▁-> ▁side _ data ▁= ▁src ▁-> ▁side _ data ▁; ▁pkt ▁-> ▁side _ data _ elems ▁= ▁src ▁-> ▁side _ data _ elems ▁; ▁} ▁if ▁( ▁src ▁-> ▁side _ data _ elems ▁&& ▁! ▁dup ▁) ▁{ ▁return ▁av _ copy _ packet _ side _ data ▁( ▁pkt ▁, ▁src ▁) ▁; ▁} ▁return ▁0 ▁; ▁failed _ alloc ▁: ▁av _ packet _ unref ▁( ▁pkt ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁}	0
▁static ▁int ▁noise ▁( ▁AV BitStream Filter Context ▁* ▁bs fc ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁char ▁* ▁args ▁, ▁uint 8_ t ▁* ▁* ▁poutbuf ▁, ▁int ▁* ▁poutbuf _ size ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁int ▁keyframe ▁) ▁{ ▁unsigned ▁int ▁* ▁state ▁= ▁bs fc ▁-> ▁priv _ data ▁; ▁int ▁amount ▁= ▁args ▁? ▁atoi ▁( ▁args ▁) ▁: ▁( ▁* ▁state ▁% ▁100 01 ▁+ ▁1 ▁) ▁; ▁int ▁i ▁; ▁* ▁poutbuf ▁= ▁av _ malloc ▁( ▁buf _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁memcpy ▁( ▁* ▁poutbuf ▁, ▁buf ▁, ▁buf _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁buf _ size ▁; ▁i ▁++ ▁) ▁{ ▁( ▁* ▁state ▁) ▁+= ▁( ▁* ▁poutbuf ▁) ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁if ▁( ▁* ▁state ▁% ▁amount ▁== ▁0 ▁) ▁( ▁* ▁poutbuf ▁) ▁[ ▁i ▁] ▁= ▁* ▁state ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁configure _ video _ filters ▁( ▁Filter Graph ▁* ▁fg ▁, ▁AVFilter Context ▁* ▁* ▁in _ filter ▁, ▁AVFilter Context ▁* ▁* ▁out _ filter ▁) ▁{ ▁InputStream ▁* ▁ist ▁= ▁fg ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁ist ▁; ▁OutputStream ▁* ▁o st ▁= ▁fg ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁o st ▁; ▁AVFilter Context ▁* ▁filter ▁; ▁AVCodecContext ▁* ▁codec ▁= ▁o st ▁-> ▁st ▁-> ▁codec ▁; ▁char ▁* ▁pix _ fmts ▁; ▁AVR ational ▁sample _ aspect _ ratio ▁; ▁char ▁args ▁[ ▁255 ▁] ▁; ▁int ▁ret ▁; ▁if ▁( ▁ist ▁-> ▁st ▁-> ▁sample _ aspect _ ratio ▁. ▁num ▁) ▁{ ▁sample _ aspect _ ratio ▁= ▁ist ▁-> ▁st ▁-> ▁sample _ aspect _ ratio ▁; ▁} ▁else ▁sample _ aspect _ ratio ▁= ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁sample _ aspect _ ratio ▁; ▁snprintf ▁( ▁args ▁, ▁255 ▁, ▁"% d :% d :% d :% d :% d :% d :% d " ▁, ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁width ▁, ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁height ▁, ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁pix _ fmt ▁, ▁1 ▁, ▁AV _ TIME _ BASE ▁, ▁sample _ aspect _ ratio ▁. ▁num ▁, ▁sample _ aspect _ ratio ▁. ▁den ▁) ▁; ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁fg ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁filter ▁, ▁avfilter _ get _ by _ name ▁( ▁" buffer " ▁) ▁, ▁" src " ▁, ▁args ▁, ▁NULL ▁, ▁fg ▁-> ▁graph ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁fg ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁filter ▁, ▁avfilter _ get _ by _ name ▁( ▁" buffers ink " ▁) ▁, ▁" out " ▁, ▁NULL ▁, ▁NULL ▁, ▁fg ▁-> ▁graph ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁in _ filter ▁= ▁fg ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁filter ▁; ▁* ▁out _ filter ▁= ▁fg ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁filter ▁; ▁if ▁( ▁codec ▁-> ▁width ▁|| ▁codec ▁-> ▁height ▁) ▁{ ▁snprintf ▁( ▁args ▁, ▁255 ▁, ▁"% d :% d : flags =0 x % X " ▁, ▁codec ▁-> ▁width ▁, ▁codec ▁-> ▁height ▁, ▁( ▁unsigned ▁) ▁o st ▁-> ▁s ws _ flags ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁filter ▁, ▁avfilter _ get _ by _ name ▁( ▁" scale " ▁) ▁, ▁NULL ▁, ▁args ▁, ▁NULL ▁, ▁fg ▁-> ▁graph ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁avfilter _ link ▁( ▁* ▁in _ filter ▁, ▁0 ▁, ▁filter ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁in _ filter ▁= ▁filter ▁; ▁} ▁if ▁( ▁( ▁pix _ fmts ▁= ▁choose _ pix _ fmts ▁( ▁o st ▁) ▁) ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁filter ▁, ▁avfilter _ get _ by _ name ▁( ▁" format " ▁) ▁, ▁" format " ▁, ▁pix _ fmts ▁, ▁NULL ▁, ▁fg ▁-> ▁graph ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁avfilter _ link ▁( ▁filter ▁, ▁0 ▁, ▁* ▁out _ filter ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁out _ filter ▁= ▁filter ▁; ▁av _ freep ▁( ▁& ▁pix _ fmts ▁) ▁; ▁} ▁snprintf ▁( ▁args ▁, ▁sizeof ▁( ▁args ▁) ▁, ▁" flags =0 x % X " ▁, ▁( ▁unsigned ▁) ▁o st ▁-> ▁s ws _ flags ▁) ▁; ▁fg ▁-> ▁graph ▁-> ▁scale _ s ws _ opts ▁= ▁av _ strdup ▁( ▁args ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁process _ t ns _ coeffs ▁( ▁Temporal Noise Sh ap ing ▁* ▁t ns ▁, ▁double ▁* ▁coef _ raw ▁, ▁int ▁* ▁order _ p ▁, ▁int ▁w ▁, ▁int ▁filt ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁order ▁= ▁* ▁order _ p ▁; ▁int ▁* ▁idx ▁= ▁t ns ▁-> ▁coef _ idx ▁[ ▁w ▁] ▁[ ▁filt ▁] ▁; ▁float ▁* ▁lpc ▁= ▁t ns ▁-> ▁coef ▁[ ▁w ▁] ▁[ ▁filt ▁] ▁; ▁float ▁temp ▁[ ▁T NS _ MAX _ ORDER ▁] ▁= ▁{ ▁0.0 f ▁} ▁, ▁out ▁[ ▁T NS _ MAX _ ORDER ▁] ▁= ▁{ ▁0.0 f ▁} ▁; ▁if ▁( ▁! ▁order ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁order ▁; ▁i ▁++ ▁) ▁{ ▁idx ▁[ ▁i ▁] ▁= ▁quant _ array _ idx ▁( ▁coef _ raw ▁[ ▁i ▁] ▁, ▁t ns _ tmp 2_ map _0_ 4 ▁, ▁16 ▁) ▁; ▁lpc ▁[ ▁i ▁] ▁= ▁t ns _ tmp 2_ map _0_ 4 ▁[ ▁idx ▁[ ▁i ▁] ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁order ▁- ▁1 ▁; ▁i ▁> ▁-1 ▁; ▁i ▁-- ▁) ▁{ ▁lpc ▁[ ▁i ▁] ▁= ▁( ▁fabs ▁( ▁lpc ▁[ ▁i ▁] ▁) ▁> ▁0.1 f ▁) ▁? ▁lpc ▁[ ▁i ▁] ▁: ▁0.0 f ▁; ▁if ▁( ▁lpc ▁[ ▁i ▁] ▁!= ▁0.0 ▁) ▁{ ▁order ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁out ▁[ ▁0 ▁] ▁= ▁1.0 f ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁order ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁{ ▁temp ▁[ ▁j ▁] ▁= ▁out ▁[ ▁j ▁] ▁+ ▁lpc ▁[ ▁i ▁] ▁* ▁out ▁[ ▁i ▁- ▁j ▁] ▁; ▁} ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁<= ▁i ▁; ▁j ▁++ ▁) ▁{ ▁out ▁[ ▁j ▁] ▁= ▁temp ▁[ ▁j ▁] ▁; ▁} ▁out ▁[ ▁i ▁] ▁= ▁lpc ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁* ▁order _ p ▁= ▁order ▁; ▁memcpy ▁( ▁lpc ▁, ▁out ▁, ▁T NS _ MAX _ ORDER ▁* ▁sizeof ▁( ▁float ▁) ▁) ▁; ▁}	1
▁static ▁int ▁h ds _ flush ▁( ▁AVFormatContext ▁* ▁s ▁, ▁OutputStream ▁* ▁os ▁, ▁int ▁final ▁, ▁int 64_ t ▁end _ ts ▁) ▁{ ▁H DS Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁ret ▁= ▁0 ▁; ▁char ▁target _ filename ▁[ ▁1024 ▁] ▁; ▁int ▁index ▁= ▁s ▁-> ▁streams ▁[ ▁os ▁-> ▁first _ stream ▁] ▁-> ▁id ▁; ▁if ▁( ▁! ▁os ▁-> ▁packets _ written ▁) ▁return ▁0 ▁; ▁avio _ flush ▁( ▁os ▁-> ▁ctx ▁-> ▁pb ▁) ▁; ▁os ▁-> ▁packets _ written ▁= ▁0 ▁; ▁close _ file ▁( ▁s ▁, ▁os ▁) ▁; ▁snprintf ▁( ▁target _ filename ▁, ▁sizeof ▁( ▁target _ filename ▁) ▁, ▁"% s / stream % d Seg 1- Frag % d " ▁, ▁s ▁-> ▁filename ▁, ▁index ▁, ▁os ▁-> ▁fragment _ index ▁) ▁; ▁ret ▁= ▁ff _ rename ▁( ▁os ▁-> ▁temp _ filename ▁, ▁target _ filename ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁add _ fragment ▁( ▁os ▁, ▁target _ filename ▁, ▁os ▁-> ▁frag _ start _ ts ▁, ▁end _ ts ▁- ▁os ▁-> ▁frag _ start _ ts ▁) ▁; ▁if ▁( ▁! ▁final ▁) ▁{ ▁ret ▁= ▁init _ file ▁( ▁s ▁, ▁os ▁, ▁end _ ts ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁c ▁-> ▁window _ size ▁|| ▁( ▁final ▁&& ▁c ▁-> ▁remove _ at _ exit ▁) ▁) ▁{ ▁int ▁remove ▁= ▁os ▁-> ▁nb _ frag ments ▁- ▁c ▁-> ▁window _ size ▁- ▁c ▁-> ▁extra _ window _ size ▁; ▁if ▁( ▁final ▁&& ▁c ▁-> ▁remove _ at _ exit ▁) ▁remove ▁= ▁os ▁-> ▁nb _ frag ments ▁; ▁if ▁( ▁remove ▁> ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁remove ▁; ▁i ▁++ ▁) ▁{ ▁unlink ▁( ▁os ▁-> ▁fragments ▁[ ▁i ▁] ▁-> ▁file ▁) ▁; ▁av _ free ▁( ▁os ▁-> ▁fragments ▁[ ▁i ▁] ▁) ▁; ▁} ▁os ▁-> ▁nb _ frag ments ▁-= ▁remove ▁; ▁memmove ▁( ▁os ▁-> ▁fragments ▁, ▁os ▁-> ▁fragments ▁+ ▁remove ▁, ▁os ▁-> ▁nb _ frag ments ▁* ▁sizeof ▁( ▁* ▁os ▁-> ▁fragments ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁ret ▁>= ▁0 ▁) ▁ret ▁= ▁write _ ab st ▁( ▁s ▁, ▁os ▁, ▁final ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁tn put ▁( ▁uint 8_ t ▁* ▁* ▁p ▁, ▁int ▁n ▁, ▁const ▁uint 8_ t ▁* ▁val ▁, ▁enum ▁T iff Types ▁type ▁, ▁int ▁flip ▁) ▁{ ▁int ▁i ▁; ▁# if ▁HAVE _ BIG ENDIAN ▁flip ▁ ^ = ▁( ▁( ▁int ▁[ ▁] ▁) ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁3 ▁, ▁3 ▁} ▁) ▁[ ▁type ▁] ▁; ▁# endif ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁* ▁type _ sizes 2 ▁[ ▁type ▁] ▁; ▁i ▁++ ▁) ▁* ▁( ▁* ▁p ▁) ▁++ ▁= ▁val ▁[ ▁i ▁ ^ ▁flip ▁] ▁; ▁}	1
▁SSL ▁* ▁SSL _ dup ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁SSL ▁* ▁ret ▁; ▁int ▁i ▁; ▁if ▁( ▁! ▁SSL _ in _ init ▁( ▁s ▁) ▁|| ▁! ▁SSL _ in _ before ▁( ▁s ▁) ▁) ▁{ ▁CRYPTO _ UP _ REF ▁( ▁& ▁s ▁-> ▁references ▁, ▁& ▁i ▁, ▁s ▁-> ▁lock ▁) ▁; ▁return ▁s ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁SSL _ new ▁( ▁SSL _ get _ SSL _ CTX ▁( ▁s ▁) ▁) ▁) ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁s ▁-> ▁session ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁SSL _ copy _ session _ id ▁( ▁ret ▁, ▁s ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁SSL _ set _ ssl _ method ▁( ▁ret ▁, ▁s ▁-> ▁method ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁s ▁-> ▁cert ▁!= ▁NULL ▁) ▁{ ▁ssl _ cert _ free ▁( ▁ret ▁-> ▁cert ▁) ▁; ▁ret ▁-> ▁cert ▁= ▁ssl _ cert _ dup ▁( ▁s ▁-> ▁cert ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cert ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁SSL _ set _ session _ id _ context ▁( ▁ret ▁, ▁s ▁-> ▁sid _ ctx ▁, ▁( ▁int ▁) ▁s ▁-> ▁sid _ ctx _ length ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁ssl _ d ane _ dup ▁( ▁ret ▁, ▁s ▁) ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁version ▁= ▁s ▁-> ▁version ▁; ▁ret ▁-> ▁options ▁= ▁s ▁-> ▁options ▁; ▁ret ▁-> ▁mode ▁= ▁s ▁-> ▁mode ▁; ▁SSL _ set _ max _ cert _ list ▁( ▁ret ▁, ▁SSL _ get _ max _ cert _ list ▁( ▁s ▁) ▁) ▁; ▁SSL _ set _ read _ ahead ▁( ▁ret ▁, ▁SSL _ get _ read _ ahead ▁( ▁s ▁) ▁) ▁; ▁ret ▁-> ▁msg _ callback ▁= ▁s ▁-> ▁msg _ callback ▁; ▁ret ▁-> ▁msg _ callback _ arg ▁= ▁s ▁-> ▁msg _ callback _ arg ▁; ▁SSL _ set _ verify ▁( ▁ret ▁, ▁SSL _ get _ verify _ mode ▁( ▁s ▁) ▁, ▁SSL _ get _ verify _ callback ▁( ▁s ▁) ▁) ▁; ▁SSL _ set _ verify _ depth ▁( ▁ret ▁, ▁SSL _ get _ verify _ depth ▁( ▁s ▁) ▁) ▁; ▁ret ▁-> ▁generate _ session _ id ▁= ▁s ▁-> ▁generate _ session _ id ▁; ▁SSL _ set _ info _ callback ▁( ▁ret ▁, ▁SSL _ get _ info _ callback ▁( ▁s ▁) ▁) ▁; ▁if ▁( ▁! ▁CRYPTO _ dup _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL ▁, ▁& ▁ret ▁-> ▁ex _ data ▁, ▁& ▁s ▁-> ▁ex _ data ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁s ▁-> ▁rb io ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁BIO _ dup _ state ▁( ▁s ▁-> ▁rb io ▁, ▁( ▁char ▁* ▁) ▁& ▁ret ▁-> ▁rb io ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁w bio ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁s ▁-> ▁w bio ▁!= ▁s ▁-> ▁rb io ▁) ▁{ ▁if ▁( ▁! ▁BIO _ dup _ state ▁( ▁s ▁-> ▁w bio ▁, ▁( ▁char ▁* ▁) ▁& ▁ret ▁-> ▁w bio ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁{ ▁BIO _ up _ ref ▁( ▁ret ▁-> ▁rb io ▁) ▁; ▁ret ▁-> ▁w bio ▁= ▁ret ▁-> ▁rb io ▁; ▁} ▁} ▁ret ▁-> ▁server ▁= ▁s ▁-> ▁server ▁; ▁if ▁( ▁s ▁-> ▁handshake _ func ▁) ▁{ ▁if ▁( ▁s ▁-> ▁server ▁) ▁SSL _ set _ accept _ state ▁( ▁ret ▁) ▁; ▁else ▁SSL _ set _ connect _ state ▁( ▁ret ▁) ▁; ▁} ▁ret ▁-> ▁shutdown ▁= ▁s ▁-> ▁shutdown ▁; ▁ret ▁-> ▁hit ▁= ▁s ▁-> ▁hit ▁; ▁ret ▁-> ▁default _ passwd _ callback ▁= ▁s ▁-> ▁default _ passwd _ callback ▁; ▁ret ▁-> ▁default _ passwd _ callback _ userdata ▁= ▁s ▁-> ▁default _ passwd _ callback _ userdata ▁; ▁X 509_ VERIFY _ PARAM _ inherit ▁( ▁ret ▁-> ▁param ▁, ▁s ▁-> ▁param ▁) ▁; ▁if ▁( ▁s ▁-> ▁cipher _ list ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ret ▁-> ▁cipher _ list ▁= ▁sk _ SSL _ CIPHER _ dup ▁( ▁s ▁-> ▁cipher _ list ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁cipher _ list _ by _ id ▁!= ▁NULL ▁) ▁if ▁( ▁( ▁ret ▁-> ▁cipher _ list _ by _ id ▁= ▁sk _ SSL _ CIPHER _ dup ▁( ▁s ▁-> ▁cipher _ list _ by _ id ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁dup _ ca _ names ▁( ▁& ▁ret ▁-> ▁ca _ names ▁, ▁s ▁-> ▁ca _ names ▁) ▁|| ▁! ▁dup _ ca _ names ▁( ▁& ▁ret ▁-> ▁client _ ca _ names ▁, ▁s ▁-> ▁client _ ca _ names ▁) ▁) ▁goto ▁err ▁; ▁return ▁ret ▁; ▁err ▁: ▁SSL _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁inline ▁int ▁get _ ue _ code ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁int ▁order ▁) ▁{ ▁unsigned ▁ret ▁= ▁get _ ue _ go lo mb ▁( ▁gb ▁) ▁; ▁if ▁( ▁ret ▁>= ▁( ▁( ▁1 U ▁<< ▁31 ▁) ▁>> ▁order ▁) ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ ue _ code : valu et ool arger \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁order ▁) ▁{ ▁return ▁( ▁ret ▁<< ▁order ▁) ▁+ ▁get _ bits ▁( ▁gb ▁, ▁order ▁) ▁; ▁} ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁add _ c andidate _ ref ▁( ▁H EV C Context ▁* ▁s ▁, ▁Ref Pic List ▁* ▁list ▁, ▁int ▁p oc ▁, ▁int ▁ref _ flag ▁) ▁{ ▁H EV C Frame ▁* ▁ref ▁= ▁find _ ref _ idx ▁( ▁s ▁, ▁p oc ▁) ▁; ▁if ▁( ▁ref ▁== ▁s ▁-> ▁ref ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁! ▁ref ▁) ▁{ ▁ref ▁= ▁generate _ missing _ ref ▁( ▁s ▁, ▁p oc ▁) ▁; ▁if ▁( ▁! ▁ref ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁list ▁-> ▁list ▁[ ▁list ▁-> ▁nb _ refs ▁] ▁= ▁ref ▁-> ▁p oc ▁; ▁list ▁-> ▁ref ▁[ ▁list ▁-> ▁nb _ refs ▁] ▁= ▁ref ▁; ▁list ▁-> ▁nb _ refs ▁++ ▁; ▁mark _ ref ▁( ▁ref ▁, ▁ref _ flag ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁ssize _ t ▁ngx _ write _ chain _ to _ file ▁( ▁ngx _ file _ t ▁* ▁file ▁, ▁ngx _ chain _ t ▁* ▁cl ▁, ▁off _ t ▁offset ▁, ▁ngx _ pool _ t ▁* ▁pool ▁) ▁{ ▁u _ char ▁* ▁prev ▁; ▁size _ t ▁size ▁; ▁ssize _ t ▁total ▁, ▁n ▁; ▁ngx _ array _ t ▁vec ▁; ▁struct ▁iovec ▁* ▁iov ▁, ▁io vs ▁[ ▁NGX _ IO VS ▁] ▁; ▁if ▁( ▁cl ▁-> ▁next ▁== ▁NULL ▁) ▁{ ▁return ▁ngx _ write _ file ▁( ▁file ▁, ▁cl ▁-> ▁buf ▁-> ▁pos ▁, ▁( ▁size _ t ▁) ▁( ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁) ▁, ▁offset ▁) ▁; ▁} ▁total ▁= ▁0 ▁; ▁vec ▁. ▁elts ▁= ▁io vs ▁; ▁vec ▁. ▁size ▁= ▁sizeof ▁( ▁struct ▁iovec ▁) ▁; ▁vec ▁. ▁n alloc ▁= ▁NGX _ IO VS ▁; ▁vec ▁. ▁pool ▁= ▁pool ▁; ▁do ▁{ ▁prev ▁= ▁NULL ▁; ▁iov ▁= ▁NULL ▁; ▁size ▁= ▁0 ▁; ▁vec ▁. ▁nel ts ▁= ▁0 ▁; ▁while ▁( ▁cl ▁&& ▁vec ▁. ▁nel ts ▁< ▁IO V _ MAX ▁) ▁{ ▁if ▁( ▁prev ▁== ▁cl ▁-> ▁buf ▁-> ▁pos ▁) ▁{ ▁iov ▁-> ▁iov _ len ▁+= ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁} ▁else ▁{ ▁iov ▁= ▁ngx _ array _ push ▁( ▁& ▁vec ▁) ▁; ▁if ▁( ▁iov ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁iov ▁-> ▁iov _ base ▁= ▁( ▁void ▁* ▁) ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁iov ▁-> ▁iov _ len ▁= ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁} ▁size ▁+= ▁cl ▁-> ▁buf ▁-> ▁last ▁- ▁cl ▁-> ▁buf ▁-> ▁pos ▁; ▁prev ▁= ▁cl ▁-> ▁buf ▁-> ▁last ▁; ▁cl ▁= ▁cl ▁-> ▁next ▁; ▁} ▁if ▁( ▁vec ▁. ▁nel ts ▁== ▁1 ▁) ▁{ ▁iov ▁= ▁vec ▁. ▁elts ▁; ▁n ▁= ▁ngx _ write _ file ▁( ▁file ▁, ▁( ▁u _ char ▁* ▁) ▁iov ▁[ ▁0 ▁] ▁. ▁iov _ base ▁, ▁iov ▁[ ▁0 ▁] ▁. ▁iov _ len ▁, ▁offset ▁) ▁; ▁if ▁( ▁n ▁== ▁NGX _ ERROR ▁) ▁{ ▁return ▁n ▁; ▁} ▁return ▁total ▁+ ▁n ▁; ▁} ▁if ▁( ▁file ▁-> ▁sys _ offset ▁!= ▁offset ▁) ▁{ ▁if ▁( ▁lseek ▁( ▁file ▁-> ▁fd ▁, ▁offset ▁, ▁SEEK _ SET ▁) ▁== ▁-1 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁file ▁-> ▁log ▁, ▁ngx _ errno ▁, ▁" lseek () \"% s \" failed " ▁, ▁file ▁-> ▁name ▁. ▁data ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁file ▁-> ▁sys _ offset ▁= ▁offset ▁; ▁} ▁n ▁= ▁write v ▁( ▁file ▁-> ▁fd ▁, ▁vec ▁. ▁elts ▁, ▁vec ▁. ▁nel ts ▁) ▁; ▁if ▁( ▁n ▁== ▁-1 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁file ▁-> ▁log ▁, ▁ngx _ errno ▁, ▁" write v () \"% s \" failed " ▁, ▁file ▁-> ▁name ▁. ▁data ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁if ▁( ▁( ▁size _ t ▁) ▁n ▁!= ▁size ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁file ▁-> ▁log ▁, ▁0 ▁, ▁" write v () \"% s \" has written only % z of % uz " ▁, ▁file ▁-> ▁name ▁. ▁data ▁, ▁n ▁, ▁size ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ CORE ▁, ▁file ▁-> ▁log ▁, ▁0 ▁, ▁" write v :% d ,% z " ▁, ▁file ▁-> ▁fd ▁, ▁n ▁) ▁; ▁file ▁-> ▁sys _ offset ▁+= ▁n ▁; ▁file ▁-> ▁offset ▁+= ▁n ▁; ▁total ▁+= ▁n ▁; ▁} ▁while ▁( ▁cl ▁) ▁; ▁return ▁total ▁; ▁}	1
▁void ▁* ▁av _ realloc ▁( ▁void ▁* ▁ptr ▁, ▁size _ t ▁size ▁) ▁{ ▁if ▁( ▁size ▁> ▁( ▁max _ alloc _ size ▁- ▁32 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁HAVE _ ALIGNED _ MALLOC ▁return ▁_ aligned _ realloc ▁( ▁ptr ▁, ▁size ▁+ ▁! ▁size ▁, ▁ALIGN ▁) ▁; ▁# else ▁return ▁realloc ▁( ▁ptr ▁, ▁size ▁+ ▁! ▁size ▁) ▁; ▁# endif ▁}	1
▁BN _ ULONG ▁bn _ mul _ add _ words ▁( ▁BN _ ULONG ▁* ▁rp ▁, ▁const ▁BN _ ULONG ▁* ▁ap ▁, ▁int ▁num ▁, ▁BN _ ULONG ▁w ▁) ▁{ ▁BN _ ULONG ▁c ▁= ▁0 ▁; ▁BN _ ULONG ▁bl ▁, ▁bh ▁; ▁assert ▁( ▁num ▁>= ▁0 ▁) ▁; ▁if ▁( ▁num ▁<= ▁0 ▁) ▁return ▁( ▁( ▁BN _ ULONG ▁) ▁0 ▁) ▁; ▁bl ▁= ▁L BITS ▁( ▁w ▁) ▁; ▁bh ▁= ▁H BITS ▁( ▁w ▁) ▁; ▁# ifndef ▁OPENSSL _ SMALL _ F OOT PRINT ▁while ▁( ▁num ▁& ▁ ~ ▁3 ▁) ▁{ ▁mul _ add ▁( ▁rp ▁[ ▁0 ▁] ▁, ▁ap ▁[ ▁0 ▁] ▁, ▁bl ▁, ▁bh ▁, ▁c ▁) ▁; ▁mul _ add ▁( ▁rp ▁[ ▁1 ▁] ▁, ▁ap ▁[ ▁1 ▁] ▁, ▁bl ▁, ▁bh ▁, ▁c ▁) ▁; ▁mul _ add ▁( ▁rp ▁[ ▁2 ▁] ▁, ▁ap ▁[ ▁2 ▁] ▁, ▁bl ▁, ▁bh ▁, ▁c ▁) ▁; ▁mul _ add ▁( ▁rp ▁[ ▁3 ▁] ▁, ▁ap ▁[ ▁3 ▁] ▁, ▁bl ▁, ▁bh ▁, ▁c ▁) ▁; ▁ap ▁+= ▁4 ▁; ▁rp ▁+= ▁4 ▁; ▁num ▁-= ▁4 ▁; ▁} ▁# endif ▁while ▁( ▁num ▁) ▁{ ▁mul _ add ▁( ▁rp ▁[ ▁0 ▁] ▁, ▁ap ▁[ ▁0 ▁] ▁, ▁bl ▁, ▁bh ▁, ▁c ▁) ▁; ▁ap ▁++ ▁; ▁rp ▁++ ▁; ▁num ▁-- ▁; ▁} ▁return ▁( ▁c ▁) ▁; ▁}	1
▁static ▁int ▁v md audio _ load sound ▁( ▁V md Audio Context ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁data ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁silent _ chunks ▁, ▁int ▁data _ size ▁) ▁{ ▁int ▁silent _ size ▁= ▁s ▁-> ▁avctx ▁-> ▁block _ align ▁* ▁silent _ chunks ▁* ▁s ▁-> ▁out _ b ps ▁; ▁if ▁( ▁silent _ chunks ▁) ▁{ ▁memset ▁( ▁data ▁, ▁s ▁-> ▁out _ b ps ▁== ▁2 ▁? ▁0 x 00 ▁: ▁0 x 80 ▁, ▁silent _ size ▁) ▁; ▁data ▁+= ▁silent _ size ▁; ▁} ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁bits _ per _ coded _ sample ▁== ▁16 ▁) ▁v md audio _ decode _ audio ▁( ▁s ▁, ▁data ▁, ▁buf ▁, ▁data _ size ▁, ▁s ▁-> ▁avctx ▁-> ▁channels ▁== ▁2 ▁) ▁; ▁else ▁{ ▁memcpy ▁( ▁data ▁, ▁buf ▁, ▁data _ size ▁) ▁; ▁} ▁return ▁silent _ size ▁+ ▁data _ size ▁* ▁s ▁-> ▁out _ b ps ▁; ▁}	1
▁static ▁int ▁configure _ audio _ filters ▁( ▁Filter Graph ▁* ▁fg ▁, ▁AVFilter Context ▁* ▁* ▁in _ filter ▁, ▁AVFilter Context ▁* ▁* ▁out _ filter ▁) ▁{ ▁InputStream ▁* ▁ist ▁= ▁fg ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁ist ▁; ▁OutputStream ▁* ▁o st ▁= ▁fg ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁o st ▁; ▁AVCodecContext ▁* ▁codec ▁= ▁o st ▁-> ▁st ▁-> ▁codec ▁; ▁AVCodecContext ▁* ▁ic ode c ▁= ▁ist ▁-> ▁st ▁-> ▁codec ▁; ▁char ▁* ▁sample _ fmts ▁, ▁* ▁sample _ rates ▁, ▁* ▁channel _ layout s ▁; ▁char ▁args ▁[ ▁256 ▁] ▁; ▁int ▁ret ▁; ▁avfilter _ graph _ free ▁( ▁& ▁fg ▁-> ▁graph ▁) ▁; ▁if ▁( ▁! ▁( ▁fg ▁-> ▁graph ▁= ▁avfilter _ graph _ alloc ▁( ▁) ▁) ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁snprintf ▁( ▁args ▁, ▁sizeof ▁( ▁args ▁) ▁, ▁" time _ base =% d /% d : sample _ rate =% d : sample _ fmt =% s :" ▁" channel _ layout =0 x %" ▁PRIx 64 ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁. ▁num ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁. ▁den ▁, ▁ic ode c ▁-> ▁sample _ rate ▁, ▁av _ get _ sample _ fmt _ name ▁( ▁ic ode c ▁-> ▁sample _ fmt ▁) ▁, ▁ic ode c ▁-> ▁channel _ layout ▁) ▁; ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁fg ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁filter ▁, ▁avfilter _ get _ by _ name ▁( ▁" ab uffer " ▁) ▁, ▁" src " ▁, ▁args ▁, ▁NULL ▁, ▁fg ▁-> ▁graph ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁fg ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁filter ▁, ▁avfilter _ get _ by _ name ▁( ▁" ab uff ers ink " ▁) ▁, ▁" out " ▁, ▁NULL ▁, ▁NULL ▁, ▁fg ▁-> ▁graph ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁in _ filter ▁= ▁fg ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁filter ▁; ▁* ▁out _ filter ▁= ▁fg ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁filter ▁; ▁if ▁( ▁codec ▁-> ▁channels ▁&& ▁! ▁codec ▁-> ▁channel _ layout ▁) ▁codec ▁-> ▁channel _ layout ▁= ▁av _ get _ default _ channel _ layout ▁( ▁codec ▁-> ▁channels ▁) ▁; ▁sample _ fmts ▁= ▁choose _ sample _ fmts ▁( ▁o st ▁) ▁; ▁sample _ rates ▁= ▁choose _ sample _ rates ▁( ▁o st ▁) ▁; ▁channel _ layout s ▁= ▁choose _ channel _ layout s ▁( ▁o st ▁) ▁; ▁if ▁( ▁sample _ fmts ▁|| ▁sample _ rates ▁|| ▁channel _ layout s ▁) ▁{ ▁AVFilter Context ▁* ▁format ▁; ▁char ▁args ▁[ ▁256 ▁] ▁; ▁int ▁len ▁= ▁0 ▁; ▁if ▁( ▁sample _ fmts ▁) ▁len ▁+= ▁snprintf ▁( ▁args ▁+ ▁len ▁, ▁sizeof ▁( ▁args ▁) ▁- ▁len ▁, ▁" sample _ fmts =% s :" ▁, ▁sample _ fmts ▁) ▁; ▁if ▁( ▁sample _ rates ▁) ▁len ▁+= ▁snprintf ▁( ▁args ▁+ ▁len ▁, ▁sizeof ▁( ▁args ▁) ▁- ▁len ▁, ▁" sample _ rates =% s :" ▁, ▁sample _ rates ▁) ▁; ▁if ▁( ▁channel _ layout s ▁) ▁len ▁+= ▁snprintf ▁( ▁args ▁+ ▁len ▁, ▁sizeof ▁( ▁args ▁) ▁- ▁len ▁, ▁" channel _ layout s =% s :" ▁, ▁channel _ layout s ▁) ▁; ▁args ▁[ ▁len ▁- ▁1 ▁] ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁sample _ fmts ▁) ▁; ▁av _ freep ▁( ▁& ▁sample _ rates ▁) ▁; ▁av _ freep ▁( ▁& ▁channel _ layout s ▁) ▁; ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁format ▁, ▁avfilter _ get _ by _ name ▁( ▁" a format " ▁) ▁, ▁" a format " ▁, ▁args ▁, ▁NULL ▁, ▁fg ▁-> ▁graph ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ret ▁= ▁avfilter _ link ▁( ▁format ▁, ▁0 ▁, ▁fg ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁filter ▁, ▁0 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁out _ filter ▁= ▁format ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁ub sec _ mod _ exp ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁p ▁, ▁const ▁BIGNUM ▁* ▁m ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁y _ len ▁= ▁0 ▁; ▁int ▁fd ▁; ▁if ▁( ▁ub sec _ dso ▁== ▁NULL ▁) ▁{ ▁UB SEC err ▁( ▁UB SEC _ F _ UB SEC _ MOD _ EXP ▁, ▁UB SEC _ R _ NOT _ LOADED ▁) ▁; ▁return ▁0 ▁; ▁} ▁y _ len ▁= ▁BN _ num _ bits ▁( ▁m ▁) ▁; ▁if ▁( ▁y _ len ▁> ▁max _ key _ len ▁) ▁{ ▁UB SEC err ▁( ▁UB SEC _ F _ UB SEC _ MOD _ EXP ▁, ▁UB SEC _ R _ SIZE _ TOO _ LARGE _ OR _ TOO _ SMALL ▁) ▁; ▁return ▁BN _ mod _ exp ▁( ▁r ▁, ▁a ▁, ▁p ▁, ▁m ▁, ▁ctx ▁) ▁; ▁} ▁if ▁( ▁! ▁bn _ w expand ▁( ▁r ▁, ▁m ▁-> ▁top ▁) ▁) ▁{ ▁UB SEC err ▁( ▁UB SEC _ F _ UB SEC _ MOD _ EXP ▁, ▁UB SEC _ R _ BN _ EXPAND _ FAIL ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁( ▁fd ▁= ▁p _ UB SEC _ ub sec _ open ▁( ▁UB SEC _ KEY _ DEVICE _ NAME ▁) ▁) ▁<= ▁0 ▁) ▁{ ▁fd ▁= ▁0 ▁; ▁UB SEC err ▁( ▁UB SEC _ F _ UB SEC _ INIT ▁, ▁UB SEC _ R _ UNIT _ FAILURE ▁) ▁; ▁return ▁BN _ mod _ exp ▁( ▁r ▁, ▁a ▁, ▁p ▁, ▁m ▁, ▁ctx ▁) ▁; ▁} ▁if ▁( ▁p _ UB SEC _ rsa _ mod _ exp _ ioctl ▁( ▁fd ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁a ▁-> ▁d ▁, ▁BN _ num _ bits ▁( ▁a ▁) ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁m ▁-> ▁d ▁, ▁BN _ num _ bits ▁( ▁m ▁) ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁p ▁-> ▁d ▁, ▁BN _ num _ bits ▁( ▁p ▁) ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁r ▁-> ▁d ▁, ▁& ▁y _ len ▁) ▁!= ▁0 ▁) ▁{ ▁UB SEC err ▁( ▁UB SEC _ F _ UB SEC _ MOD _ EXP ▁, ▁UB SEC _ R _ REQUEST _ FAILED ▁) ▁; ▁p _ UB SEC _ ub sec _ close ▁( ▁fd ▁) ▁; ▁return ▁BN _ mod _ exp ▁( ▁r ▁, ▁a ▁, ▁p ▁, ▁m ▁, ▁ctx ▁) ▁; ▁} ▁p _ UB SEC _ ub sec _ close ▁( ▁fd ▁) ▁; ▁r ▁-> ▁top ▁= ▁( ▁BN _ num _ bits ▁( ▁m ▁) ▁+ ▁BN _ BITS 2 ▁- ▁1 ▁) ▁/ ▁BN _ BITS 2 ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁void ▁fix _ hostname ▁( ▁request _ rec ▁* ▁r ▁) ▁{ ▁char ▁* ▁host ▁, ▁* ▁scope _ id ▁; ▁char ▁* ▁dst ▁; ▁apr _ port _ t ▁port ▁; ▁apr _ status _ t ▁rv ▁; ▁const ▁char ▁* ▁c ▁; ▁if ▁( ▁! ▁* ▁r ▁-> ▁hostname ▁) ▁{ ▁return ▁; ▁} ▁for ▁( ▁c ▁= ▁r ▁-> ▁hostname ▁; ▁apr _ is digit ▁( ▁* ▁c ▁) ▁; ▁++ ▁c ▁) ▁; ▁if ▁( ▁! ▁* ▁c ▁) ▁{ ▁return ▁; ▁} ▁rv ▁= ▁apr _ parse _ addr _ port ▁( ▁& ▁host ▁, ▁& ▁scope _ id ▁, ▁& ▁port ▁, ▁r ▁-> ▁hostname ▁, ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁|| ▁scope _ id ▁) ▁{ ▁goto ▁bad ▁; ▁} ▁if ▁( ▁port ▁) ▁{ ▁r ▁-> ▁parsed _ uri ▁. ▁port ▁= ▁port ▁; ▁r ▁-> ▁parsed _ uri ▁. ▁port _ str ▁= ▁apr _ ito a ▁( ▁r ▁-> ▁pool ▁, ▁( ▁int ▁) ▁port ▁) ▁; ▁} ▁if ▁( ▁r ▁-> ▁hostname ▁[ ▁0 ▁] ▁!= ▁' ▁' ▁) ▁{ ▁for ▁( ▁dst ▁= ▁host ▁; ▁* ▁dst ▁; ▁dst ▁++ ▁) ▁{ ▁if ▁( ▁apr _ is lower ▁( ▁* ▁dst ▁) ▁) ▁{ ▁} ▁else ▁if ▁( ▁* ▁dst ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁* ▁( ▁dst ▁+ ▁1 ▁) ▁== ▁' ▁' ▁) ▁{ ▁goto ▁bad ▁; ▁} ▁} ▁else ▁if ▁( ▁apr _ is upper ▁( ▁* ▁dst ▁) ▁) ▁{ ▁* ▁dst ▁= ▁apr _ tolower ▁( ▁* ▁dst ▁) ▁; ▁} ▁else ▁if ▁( ▁* ▁dst ▁== ▁' ▁' ▁|| ▁* ▁dst ▁== ▁' ▁\\ ▁' ▁) ▁{ ▁goto ▁bad ▁; ▁} ▁} ▁if ▁( ▁dst ▁> ▁host ▁&& ▁dst ▁[ ▁-1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁dst ▁[ ▁-1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁} ▁r ▁-> ▁hostname ▁= ▁host ▁; ▁return ▁; ▁bad ▁: ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 05 50 ▁) ▁" Client sent m alformed Host header :% s " ▁, ▁r ▁-> ▁hostname ▁) ▁; ▁return ▁; ▁}	1
▁UI ▁* ▁UI _ new _ method ▁( ▁const ▁UI _ METHOD ▁* ▁method ▁) ▁{ ▁UI ▁* ▁ret ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁ret ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁UI err ▁( ▁UI _ F _ UI _ NEW _ METHOD ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ret ▁-> ▁lock ▁= ▁CRYPTO _ THREAD _ lock _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁lock ▁== ▁NULL ▁) ▁{ ▁UI err ▁( ▁UI _ F _ UI _ NEW _ METHOD ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁OPENSSL _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁method ▁== ▁NULL ▁) ▁method ▁= ▁UI _ get _ default _ method ▁( ▁) ▁; ▁if ▁( ▁method ▁== ▁NULL ▁) ▁method ▁= ▁UI _ null ▁( ▁) ▁; ▁ret ▁-> ▁meth ▁= ▁method ▁; ▁if ▁( ▁! ▁CRYPTO _ new _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ UI ▁, ▁ret ▁, ▁& ▁ret ▁-> ▁ex _ data ▁) ▁) ▁{ ▁OPENSSL _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁} ▁return ▁ret ▁; ▁}	0
▁void ▁av _ log ▁( ▁void ▁* ▁av cl ▁, ▁int ▁level ▁, ▁const ▁char ▁* ▁fmt ▁, ▁... ▁) ▁{ ▁AV Class ▁* ▁av c ▁= ▁av cl ▁? ▁* ▁( ▁AV Class ▁* ▁* ▁) ▁av cl ▁: ▁NULL ▁; ▁va _ list ▁vl ▁; ▁va _ start ▁( ▁vl ▁, ▁fmt ▁) ▁; ▁if ▁( ▁av c ▁&& ▁av c ▁-> ▁version ▁>= ▁( ▁50 ▁<< ▁16 ▁| ▁15 ▁<< ▁8 ▁| ▁2 ▁) ▁&& ▁av c ▁-> ▁log _ level _ offset _ offset ▁&& ▁level ▁>= ▁AV _ LOG _ FATAL ▁) ▁level ▁+= ▁* ▁( ▁int ▁* ▁) ▁( ▁( ▁( ▁uint 8_ t ▁* ▁) ▁av cl ▁) ▁+ ▁av c ▁-> ▁log _ level _ offset _ offset ▁) ▁; ▁av _ v log ▁( ▁av cl ▁, ▁level ▁, ▁fmt ▁, ▁vl ▁) ▁; ▁va _ end ▁( ▁vl ▁) ▁; ▁}	1
▁BIGNUM ▁* ▁get bn from buf ▁( ▁const ▁unsigned ▁char ▁* ▁buf ▁, ▁size _ t ▁len ▁) ▁{ ▁while ▁( ▁* ▁buf ▁== ▁0 ▁&& ▁len ▁> ▁0 ▁) ▁{ ▁buf ▁++ ▁; ▁len ▁-- ▁; ▁} ▁if ▁( ▁len ▁) ▁{ ▁return ▁BN _ bin 2 bn ▁( ▁buf ▁, ▁len ▁, ▁NULL ▁) ▁; ▁} ▁else ▁{ ▁BIGNUM ▁* ▁b ▁= ▁BN _ new ▁( ▁) ▁; ▁BN _ zero ▁( ▁b ▁) ▁; ▁return ▁b ▁; ▁} ▁}	1
▁static ▁int ▁stream _ req body _ cl ▁( ▁proxy _ http _ req _ t ▁* ▁req ▁) ▁{ ▁request _ rec ▁* ▁r ▁= ▁req ▁-> ▁r ▁; ▁int ▁seen _ e os ▁= ▁0 ▁, ▁rv ▁= ▁OK ▁; ▁proxy _ conn _ rec ▁* ▁p _ conn ▁= ▁req ▁-> ▁backend ▁; ▁apr _ bucket _ alloc _ t ▁* ▁bucket _ alloc ▁= ▁req ▁-> ▁bucket _ alloc ▁; ▁apr _ bucket _ b rig ade ▁* ▁header _ b rig ade ▁= ▁req ▁-> ▁header _ b rig ade ▁; ▁apr _ bucket _ b rig ade ▁* ▁input _ b rig ade ▁= ▁req ▁-> ▁input _ b rig ade ▁; ▁apr _ bucket ▁* ▁e ▁; ▁apr _ off _ t ▁bytes ▁; ▁apr _ off _ t ▁bytes _ stream ed ▁= ▁0 ▁; ▁do ▁{ ▁if ▁( ▁APR _ BR IG ADE _ EMPTY ▁( ▁input _ b rig ade ▁) ▁&& ▁APR _ BR IG ADE _ EMPTY ▁( ▁header _ b rig ade ▁) ▁) ▁{ ▁rv ▁= ▁stream _ req body _ read ▁( ▁req ▁, ▁input _ b rig ade ▁, ▁1 ▁) ▁; ▁if ▁( ▁rv ▁!= ▁OK ▁) ▁{ ▁return ▁rv ▁; ▁} ▁} ▁if ▁( ▁! ▁APR _ BR IG ADE _ EMPTY ▁( ▁input _ b rig ade ▁) ▁) ▁{ ▁apr _ b rig ade _ length ▁( ▁input _ b rig ade ▁, ▁1 ▁, ▁& ▁bytes ▁) ▁; ▁bytes _ stream ed ▁+= ▁bytes ▁; ▁if ▁( ▁APR _ BUCKET _ IS _ E OS ▁( ▁APR _ BR IG ADE _ LAST ▁( ▁input _ b rig ade ▁) ▁) ▁) ▁{ ▁seen _ e os ▁= ▁1 ▁; ▁e ▁= ▁APR _ BR IG ADE _ LAST ▁( ▁input _ b rig ade ▁) ▁; ▁apr _ bucket _ delete ▁( ▁e ▁) ▁; ▁if ▁( ▁apr _ table _ get ▁( ▁r ▁-> ▁sub process _ env ▁, ▁" proxy - sen dex tr acr lf " ▁) ▁) ▁{ ▁e ▁= ▁apr _ bucket _ imm ort al _ create ▁( ▁CRLF _ ASCII ▁, ▁2 ▁, ▁bucket _ alloc ▁) ▁; ▁APR _ BR IG ADE _ INSERT _ TAIL ▁( ▁input _ b rig ade ▁, ▁e ▁) ▁; ▁} ▁} ▁if ▁( ▁bytes _ stream ed ▁> ▁req ▁-> ▁cl _ val ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 10 86 ▁) ▁" read more bytes of request body than expected " ▁"( got %" ▁APR _ OFF _ T _ FMT ▁", expected " ▁"%" ▁APR _ OFF _ T _ FMT ▁")" ▁, ▁bytes _ stream ed ▁, ▁req ▁-> ▁cl _ val ▁) ▁; ▁return ▁HTTP _ INTERNAL _ SERVER _ ERROR ▁; ▁} ▁} ▁APR _ BR IG ADE _ PRE PEND ▁( ▁input _ b rig ade ▁, ▁header _ b rig ade ▁) ▁; ▁rv ▁= ▁ap _ proxy _ pass _ b rig ade ▁( ▁bucket _ alloc ▁, ▁r ▁, ▁p _ conn ▁, ▁req ▁-> ▁origin ▁, ▁input _ b rig ade ▁, ▁seen _ e os ▁) ▁; ▁if ▁( ▁rv ▁!= ▁OK ▁) ▁{ ▁return ▁rv ▁; ▁} ▁} ▁while ▁( ▁! ▁seen _ e os ▁) ▁; ▁if ▁( ▁bytes _ stream ed ▁!= ▁req ▁-> ▁cl _ val ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 10 87 ▁) ▁" client % sg iven Content - Length did not match " ▁" number of body bytes read " ▁, ▁r ▁-> ▁connection ▁-> ▁client _ ip ▁) ▁; ▁return ▁HTTP _ BAD _ REQUEST ▁; ▁} ▁return ▁OK ▁; ▁}	0
▁static ▁void ▁opt _ pad ▁( ▁const ▁char ▁* ▁arg ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Please use vf ilters = pad \ n " ▁) ▁; ▁av _ exit ▁( ▁1 ▁) ▁; ▁}	0
▁int ▁tls 1_ cbc _ remove _ padding ▁( ▁const ▁SSL ▁* ▁s ▁, ▁SSL 3_ RECORD ▁* ▁rec ▁, ▁unsigned ▁block _ size ▁, ▁unsigned ▁mac _ size ▁) ▁{ ▁unsigned ▁padding _ length ▁, ▁good ▁, ▁to _ check ▁, ▁i ▁; ▁const ▁char ▁has _ explicit _ iv ▁= ▁s ▁-> ▁version ▁>= ▁TLS 1_ 1_ VERSION ▁|| ▁s ▁-> ▁version ▁== ▁DTLS 1_ VERSION ▁; ▁const ▁unsigned ▁overhead ▁= ▁1 ▁+ ▁mac _ size ▁+ ▁( ▁has _ explicit _ iv ▁? ▁block _ size ▁: ▁0 ▁) ▁; ▁if ▁( ▁overhead ▁> ▁rec ▁-> ▁length ▁) ▁return ▁0 ▁; ▁if ▁( ▁has _ explicit _ iv ▁) ▁{ ▁rec ▁-> ▁data ▁+= ▁block _ size ▁; ▁rec ▁-> ▁input ▁+= ▁block _ size ▁; ▁rec ▁-> ▁length ▁-= ▁block _ size ▁; ▁} ▁padding _ length ▁= ▁rec ▁-> ▁data ▁[ ▁rec ▁-> ▁length ▁- ▁1 ▁] ▁; ▁if ▁( ▁( ▁s ▁-> ▁options ▁& ▁SSL _ OP _ TLS _ BLOCK _ PADDING _ BUG ▁) ▁&& ▁! ▁s ▁-> ▁expand ▁) ▁{ ▁if ▁( ▁( ▁memcmp ▁( ▁s ▁-> ▁s 3 ▁-> ▁read _ sequence ▁, ▁"\ 0\0\0\0\ 0\0\0\ 0" ▁, ▁8 ▁) ▁== ▁0 ▁) ▁&& ▁! ▁( ▁padding _ length ▁& ▁1 ▁) ▁) ▁{ ▁s ▁-> ▁s 3 ▁-> ▁flags ▁|= ▁TLS 1_ FLAGS _ TLS _ PADDING _ BUG ▁; ▁} ▁if ▁( ▁( ▁s ▁-> ▁s 3 ▁-> ▁flags ▁& ▁TLS 1_ FLAGS _ TLS _ PADDING _ BUG ▁) ▁&& ▁padding _ length ▁> ▁0 ▁) ▁{ ▁padding _ length ▁-- ▁; ▁} ▁} ▁if ▁( ▁EVP _ CIPHER _ flags ▁( ▁s ▁-> ▁enc _ read _ ctx ▁-> ▁cipher ▁) ▁& ▁EVP _ C IPH _ FLAG _ A EAD _ CIPHER ▁) ▁{ ▁rec ▁-> ▁length ▁-= ▁padding _ length ▁; ▁return ▁1 ▁; ▁} ▁good ▁= ▁constant _ time _ ge ▁( ▁rec ▁-> ▁length ▁, ▁overhead ▁+ ▁padding _ length ▁) ▁; ▁to _ check ▁= ▁255 ▁; ▁if ▁( ▁to _ check ▁> ▁rec ▁-> ▁length ▁- ▁1 ▁) ▁to _ check ▁= ▁rec ▁-> ▁length ▁- ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁to _ check ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁char ▁mask ▁= ▁constant _ time _ ge ▁( ▁padding _ length ▁, ▁i ▁) ▁; ▁unsigned ▁char ▁b ▁= ▁rec ▁-> ▁data ▁[ ▁rec ▁-> ▁length ▁- ▁1 ▁- ▁i ▁] ▁; ▁good ▁&= ▁ ~ ▁( ▁mask ▁& ▁( ▁padding _ length ▁ ^ ▁b ▁) ▁) ▁; ▁} ▁good ▁&= ▁good ▁>> ▁4 ▁; ▁good ▁&= ▁good ▁>> ▁2 ▁; ▁good ▁&= ▁good ▁>> ▁1 ▁; ▁good ▁<<= ▁sizeof ▁( ▁good ▁) ▁* ▁8 ▁- ▁1 ▁; ▁good ▁= ▁DU PLICATE _ MSB _ TO _ ALL ▁( ▁good ▁) ▁; ▁padding _ length ▁= ▁good ▁& ▁( ▁padding _ length ▁+ ▁1 ▁) ▁; ▁rec ▁-> ▁length ▁-= ▁padding _ length ▁; ▁rec ▁-> ▁type ▁|= ▁padding _ length ▁<< ▁8 ▁; ▁return ▁( ▁int ▁) ▁( ▁( ▁good ▁& ▁1 ▁) ▁| ▁( ▁ ~ ▁good ▁& ▁-1 ▁) ▁) ▁; ▁}	0
▁static ▁apr _ status _ t ▁write v _ non blocking ▁( ▁apr _ socket _ t ▁* ▁s ▁, ▁struct ▁iovec ▁* ▁vec ▁, ▁apr _ size _ t ▁nvec ▁, ▁apr _ bucket _ b rig ade ▁* ▁bb ▁, ▁apr _ size _ t ▁* ▁cumulative _ bytes _ written ▁, ▁conn _ rec ▁* ▁c ▁) ▁{ ▁apr _ status _ t ▁rv ▁= ▁APR _ SUCCESS ▁, ▁ar v ▁; ▁apr _ size _ t ▁bytes _ written ▁= ▁0 ▁, ▁bytes _ to _ write ▁= ▁0 ▁; ▁apr _ size _ t ▁i ▁, ▁offset ▁; ▁apr _ interval _ time _ t ▁old _ timeout ▁; ▁ar v ▁= ▁apr _ socket _ timeout _ get ▁( ▁s ▁, ▁& ▁old _ timeout ▁) ▁; ▁if ▁( ▁ar v ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁ar v ▁; ▁} ▁ar v ▁= ▁apr _ socket _ timeout _ set ▁( ▁s ▁, ▁0 ▁) ▁; ▁if ▁( ▁ar v ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁return ▁ar v ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nvec ▁; ▁i ▁++ ▁) ▁{ ▁bytes _ to _ write ▁+= ▁vec ▁[ ▁i ▁] ▁. ▁iov _ len ▁; ▁} ▁offset ▁= ▁0 ▁; ▁while ▁( ▁bytes _ written ▁< ▁bytes _ to _ write ▁) ▁{ ▁apr _ size _ t ▁n ▁= ▁0 ▁; ▁rv ▁= ▁apr _ socket _ send v ▁( ▁s ▁, ▁vec ▁+ ▁offset ▁, ▁nvec ▁- ▁offset ▁, ▁& ▁n ▁) ▁; ▁if ▁( ▁n ▁> ▁0 ▁) ▁{ ▁bytes _ written ▁+= ▁n ▁; ▁for ▁( ▁i ▁= ▁offset ▁; ▁i ▁< ▁nvec ▁; ▁) ▁{ ▁apr _ bucket ▁* ▁bucket ▁= ▁APR _ BR IG ADE _ FIRST ▁( ▁bb ▁) ▁; ▁if ▁( ▁APR _ BUCKET _ IS _ METADATA ▁( ▁bucket ▁) ▁) ▁{ ▁apr _ bucket _ delete ▁( ▁bucket ▁) ▁; ▁} ▁else ▁if ▁( ▁n ▁>= ▁vec ▁[ ▁i ▁] ▁. ▁iov _ len ▁) ▁{ ▁apr _ bucket _ delete ▁( ▁bucket ▁) ▁; ▁offset ▁++ ▁; ▁n ▁-= ▁vec ▁[ ▁i ▁++ ▁] ▁. ▁iov _ len ▁; ▁} ▁else ▁{ ▁apr _ bucket _ split ▁( ▁bucket ▁, ▁n ▁) ▁; ▁apr _ bucket _ delete ▁( ▁bucket ▁) ▁; ▁vec ▁[ ▁i ▁] ▁. ▁iov _ len ▁-= ▁n ▁; ▁vec ▁[ ▁i ▁] ▁. ▁iov _ base ▁= ▁( ▁char ▁* ▁) ▁vec ▁[ ▁i ▁] ▁. ▁iov _ base ▁+ ▁n ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁( ▁ap __ log io _ add _ bytes _ out ▁!= ▁NULL ▁) ▁&& ▁( ▁bytes _ written ▁> ▁0 ▁) ▁) ▁{ ▁ap __ log io _ add _ bytes _ out ▁( ▁c ▁, ▁bytes _ written ▁) ▁; ▁} ▁* ▁cumulative _ bytes _ written ▁+= ▁bytes _ written ▁; ▁ar v ▁= ▁apr _ socket _ timeout _ set ▁( ▁s ▁, ▁old _ timeout ▁) ▁; ▁if ▁( ▁( ▁ar v ▁!= ▁APR _ SUCCESS ▁) ▁&& ▁( ▁rv ▁== ▁APR _ SUCCESS ▁) ▁) ▁{ ▁return ▁ar v ▁; ▁} ▁else ▁{ ▁return ▁rv ▁; ▁} ▁}	1
▁int ▁ENGINE _ finish ▁( ▁ENGINE ▁* ▁e ▁) ▁{ ▁int ▁to _ return ▁= ▁1 ▁; ▁if ▁( ▁e ▁== ▁NULL ▁) ▁return ▁1 ▁; ▁CRYPTO _ w _ lock ▁( ▁CRYPTO _ LOCK _ ENGINE ▁) ▁; ▁to _ return ▁= ▁engine _ unlocked _ finish ▁( ▁e ▁, ▁1 ▁) ▁; ▁CRYPTO _ w _ unlock ▁( ▁CRYPTO _ LOCK _ ENGINE ▁) ▁; ▁if ▁( ▁! ▁to _ return ▁) ▁{ ▁ENGINE err ▁( ▁ENGINE _ F _ ENGINE _ FINISH ▁, ▁ENGINE _ R _ FINISH _ FAILED ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁to _ return ▁; ▁}	0
▁void ▁* ▁ev p _ generic _ fetch ▁( ▁OPENSSL _ CTX ▁* ▁lib ctx ▁, ▁int ▁operation _ id ▁, ▁const ▁char ▁* ▁name ▁, ▁const ▁char ▁* ▁properties ▁, ▁void ▁* ▁( ▁* ▁new _ method ▁) ▁( ▁const ▁char ▁* ▁name ▁, ▁const ▁OSSL _ DISPATCH ▁* ▁fns ▁, ▁OSSL _ PROVIDER ▁* ▁prov ▁, ▁void ▁* ▁method _ data ▁) ▁, ▁void ▁* ▁method _ data ▁, ▁int ▁( ▁* ▁up _ ref _ method ▁) ▁( ▁void ▁* ▁) ▁, ▁void ▁( ▁* ▁free _ method ▁) ▁( ▁void ▁* ▁) ▁) ▁{ ▁OSSL _ METHOD _ STORE ▁* ▁store ▁= ▁get _ default _ method _ store ▁( ▁lib ctx ▁) ▁; ▁OSSL _ NAME MAP ▁* ▁name map ▁= ▁ossl _ name map _ stored ▁( ▁lib ctx ▁) ▁; ▁int ▁name id ▁= ▁0 ▁; ▁uint 32_ t ▁meth id ▁= ▁0 ▁; ▁void ▁* ▁method ▁= ▁NULL ▁; ▁if ▁( ▁store ▁== ▁NULL ▁|| ▁name map ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁! ▁ossl _ assert ▁( ▁operation _ id ▁> ▁0 ▁) ▁) ▁return ▁NULL ▁; ▁if ▁( ▁( ▁name id ▁= ▁ossl _ name map _ name 2 num ▁( ▁name map ▁, ▁name ▁) ▁) ▁!= ▁0 ▁&& ▁( ▁meth id ▁= ▁method _ id ▁( ▁operation _ id ▁, ▁name id ▁) ▁) ▁== ▁0 ▁) ▁return ▁NULL ▁; ▁if ▁( ▁name id ▁== ▁0 ▁|| ▁! ▁ossl _ method _ store _ cache _ get ▁( ▁store ▁, ▁meth id ▁, ▁properties ▁, ▁& ▁method ▁) ▁) ▁{ ▁OSSL _ METHOD _ CON STRUCT _ METHOD ▁m cm ▁= ▁{ ▁alloc _ tmp _ method _ store ▁, ▁de alloc _ tmp _ method _ store ▁, ▁get _ method _ from _ store ▁, ▁put _ method _ in _ store ▁, ▁construct _ method ▁, ▁destruct _ method ▁} ▁; ▁struct ▁method _ data _ st ▁m cm data ▁; ▁m cm data ▁. ▁m cm ▁= ▁& ▁m cm ▁; ▁m cm data ▁. ▁lib ctx ▁= ▁lib ctx ▁; ▁m cm data ▁. ▁name ▁= ▁name ▁; ▁m cm data ▁. ▁method _ from _ dispatch ▁= ▁new _ method ▁; ▁m cm data ▁. ▁destruct _ method ▁= ▁free _ method ▁; ▁m cm data ▁. ▁refcnt _ up _ method ▁= ▁up _ ref _ method ▁; ▁m cm data ▁. ▁destruct _ method ▁= ▁free _ method ▁; ▁m cm data ▁. ▁method _ data ▁= ▁method _ data ▁; ▁if ▁( ▁( ▁method ▁= ▁ossl _ method _ construct ▁( ▁lib ctx ▁, ▁operation _ id ▁, ▁name ▁, ▁properties ▁, ▁0 ▁, ▁& ▁m cm ▁, ▁& ▁m cm data ▁) ▁) ▁!= ▁NULL ▁) ▁{ ▁name id ▁= ▁ossl _ name map _ name 2 num ▁( ▁name map ▁, ▁name ▁) ▁; ▁meth id ▁= ▁method _ id ▁( ▁operation _ id ▁, ▁name id ▁) ▁; ▁ossl _ method _ store _ cache _ set ▁( ▁store ▁, ▁meth id ▁, ▁properties ▁, ▁method ▁) ▁; ▁} ▁} ▁else ▁{ ▁up _ ref _ method ▁( ▁method ▁) ▁; ▁} ▁return ▁method ▁; ▁}	0
▁static ▁void ▁ctr _ B CC _ final ▁( ▁RAND _ DR BG _ CTR ▁* ▁ctr ▁) ▁{ ▁if ▁( ▁ctr ▁-> ▁blt mp _ pos ▁) ▁{ ▁memset ▁( ▁ctr ▁-> ▁blt mp ▁+ ▁ctr ▁-> ▁blt mp _ pos ▁, ▁0 ▁, ▁16 ▁- ▁ctr ▁-> ▁blt mp _ pos ▁) ▁; ▁ctr _ B CC _ blocks ▁( ▁ctr ▁, ▁ctr ▁-> ▁blt mp ▁) ▁; ▁} ▁}	0
▁static ▁int ▁parse _ key ▁( ▁DB E Context ▁* ▁s ▁) ▁{ ▁if ▁( ▁s ▁-> ▁key _ present ▁) ▁{ ▁uint 8_ t ▁* ▁key ▁= ▁s ▁-> ▁input ▁; ▁int ▁ret ▁= ▁skip _ input ▁( ▁s ▁, ▁1 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁return ▁AV _ RB 24 ▁( ▁key ▁) ▁>> ▁24 ▁- ▁s ▁-> ▁word _ bits ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁ctr _ instantiate ▁( ▁RAND _ DR BG ▁* ▁dr bg ▁, ▁const ▁unsigned ▁char ▁* ▁ent ▁, ▁size _ t ▁ent len ▁, ▁const ▁unsigned ▁char ▁* ▁nonce ▁, ▁size _ t ▁nonce len ▁, ▁const ▁unsigned ▁char ▁* ▁pers ▁, ▁size _ t ▁pers len ▁) ▁{ ▁RAND _ DR BG _ CTR ▁* ▁ctr ▁= ▁& ▁dr bg ▁-> ▁ctr ▁; ▁memset ▁( ▁ctr ▁-> ▁K ▁, ▁0 ▁, ▁sizeof ▁( ▁ctr ▁-> ▁K ▁) ▁) ▁; ▁memset ▁( ▁ctr ▁-> ▁V ▁, ▁0 ▁, ▁sizeof ▁( ▁ctr ▁-> ▁V ▁) ▁) ▁; ▁AES _ set _ encrypt _ key ▁( ▁ctr ▁-> ▁K ▁, ▁dr bg ▁-> ▁strength ▁, ▁& ▁ctr ▁-> ▁ks ▁) ▁; ▁ctr _ update ▁( ▁dr bg ▁, ▁ent ▁, ▁ent len ▁, ▁pers ▁, ▁pers len ▁, ▁nonce ▁, ▁nonce len ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁ssl _ set _ auth z ▁( ▁C ERT ▁* ▁c ▁, ▁unsigned ▁char ▁* ▁authz ▁, ▁size _ t ▁authz _ length ▁) ▁{ ▁C ERT _ PKEY ▁* ▁current _ key ▁= ▁c ▁-> ▁key ▁; ▁if ▁( ▁current _ key ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁authz _ validate ▁( ▁authz ▁, ▁authz _ length ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ SET _ AUTH Z ▁, ▁SSL _ R _ INVALID _ AUTH Z _ DATA ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁current _ key ▁-> ▁authz ▁= ▁OPENSSL _ realloc ▁( ▁current _ key ▁-> ▁authz ▁, ▁authz _ length ▁) ▁; ▁if ▁( ▁current _ key ▁-> ▁authz ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ SET _ AUTH Z ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁current _ key ▁-> ▁authz _ length ▁= ▁authz _ length ▁; ▁memcpy ▁( ▁current _ key ▁-> ▁authz ▁, ▁authz ▁, ▁authz _ length ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁size _ t ▁OPENSSL _ strlcpy ▁( ▁char ▁* ▁dst ▁, ▁const ▁char ▁* ▁src ▁, ▁size _ t ▁size ▁) ▁{ ▁size _ t ▁l ▁= ▁0 ▁; ▁for ▁( ▁; ▁size ▁> ▁1 ▁&& ▁* ▁src ▁; ▁size ▁-- ▁) ▁{ ▁* ▁dst ▁++ ▁= ▁* ▁src ▁++ ▁; ▁l ▁++ ▁; ▁} ▁if ▁( ▁size ▁) ▁* ▁dst ▁= ▁' ▁\0 ▁' ▁; ▁return ▁l ▁+ ▁strlen ▁( ▁src ▁) ▁; ▁}	1
▁void ▁PEM _ de k _ info ▁( ▁char ▁* ▁buf ▁, ▁const ▁char ▁* ▁type ▁, ▁int ▁len ▁, ▁char ▁* ▁str ▁) ▁{ ▁static ▁const ▁unsigned ▁char ▁map ▁[ ▁17 ▁] ▁= ▁"0123456789 ABCDEF " ▁; ▁long ▁i ▁; ▁int ▁j ▁; ▁strcat ▁( ▁buf ▁, ▁" DE K - Info :" ▁) ▁; ▁strcat ▁( ▁buf ▁, ▁type ▁) ▁; ▁strcat ▁( ▁buf ▁, ▁"," ▁) ▁; ▁j ▁= ▁strlen ▁( ▁buf ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁] ▁= ▁map ▁[ ▁( ▁str ▁[ ▁i ▁] ▁>> ▁4 ▁) ▁& ▁0 x 0 f ▁] ▁; ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁map ▁[ ▁( ▁str ▁[ ▁i ▁] ▁) ▁& ▁0 x 0 f ▁] ▁; ▁} ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁] ▁= ▁' ▁\ n ▁' ▁; ▁buf ▁[ ▁j ▁+ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁}	0
▁static ▁void ▁* ▁grow _ array ▁( ▁void ▁* ▁array ▁, ▁int ▁elem _ size ▁, ▁int ▁* ▁size ▁, ▁int ▁new _ size ▁) ▁{ ▁if ▁( ▁new _ size ▁>= ▁INT _ MAX ▁/ ▁elem _ size ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Array too big .\ n " ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁if ▁( ▁* ▁size ▁< ▁new _ size ▁) ▁{ ▁uint 8_ t ▁* ▁tmp ▁= ▁av _ realloc ▁( ▁array ▁, ▁new _ size ▁* ▁elem _ size ▁) ▁; ▁if ▁( ▁! ▁tmp ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Could not alloc buffer .\ n " ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁memset ▁( ▁tmp ▁+ ▁* ▁size ▁* ▁elem _ size ▁, ▁0 ▁, ▁( ▁new _ size ▁- ▁* ▁size ▁) ▁* ▁elem _ size ▁) ▁; ▁* ▁size ▁= ▁new _ size ▁; ▁return ▁tmp ▁; ▁} ▁return ▁array ▁; ▁}	1
▁static ▁ngx _ int _ t ▁ngx _ http _ ssi _ include ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ http _ ssi _ ctx _ t ▁* ▁ctx ▁, ▁ngx _ str _ t ▁* ▁* ▁params ▁) ▁{ ▁u _ char ▁* ▁dst ▁, ▁* ▁src ▁; ▁size _ t ▁len ▁; ▁ngx _ int _ t ▁rc ▁, ▁key ▁; ▁ngx _ str _ t ▁* ▁uri ▁, ▁* ▁file ▁, ▁* ▁wait ▁, ▁* ▁set ▁, ▁* ▁stub ▁, ▁args ▁; ▁ngx _ buf _ t ▁* ▁b ▁; ▁ngx _ uint _ t ▁flags ▁, ▁i ▁; ▁ngx _ chain _ t ▁* ▁cl ▁, ▁* ▁tl ▁, ▁* ▁* ▁ll ▁, ▁* ▁out ▁; ▁ngx _ http _ request _ t ▁* ▁sr ▁; ▁ngx _ http _ ssi _ var _ t ▁* ▁var ▁; ▁ngx _ http _ ssi _ ctx _ t ▁* ▁mctx ▁; ▁ngx _ http _ ssi _ block _ t ▁* ▁bl ▁; ▁ngx _ http _ post _ sub request _ t ▁* ▁psr ▁; ▁uri ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ VIRTUAL ▁] ▁; ▁file ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ FILE ▁] ▁; ▁wait ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ WAIT ▁] ▁; ▁set ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ SET ▁] ▁; ▁stub ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ STUB ▁] ▁; ▁if ▁( ▁uri ▁&& ▁file ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" in lc usion may bee ither virtual =\"% V \" or file =\"% V \"" ▁, ▁uri ▁, ▁file ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁uri ▁== ▁NULL ▁&& ▁file ▁== ▁NULL ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" nop arameter in \" include \" S SI command " ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁set ▁&& ▁stub ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁"\" set \" and \" stub \" cannot be used to gether " ▁" in \" include \" S SI command " ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁wait ▁) ▁{ ▁if ▁( ▁uri ▁== ▁NULL ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁"\" wait \" cannot be used with file =\"% V \"" ▁, ▁file ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁wait ▁-> ▁len ▁== ▁2 ▁&& ▁ngx _ strncasecmp ▁( ▁wait ▁-> ▁data ▁, ▁( ▁u _ char ▁* ▁) ▁" no " ▁, ▁2 ▁) ▁== ▁0 ▁) ▁{ ▁wait ▁= ▁NULL ▁; ▁} ▁else ▁if ▁( ▁wait ▁-> ▁len ▁!= ▁3 ▁|| ▁ngx _ strncasecmp ▁( ▁wait ▁-> ▁data ▁, ▁( ▁u _ char ▁* ▁) ▁" yes " ▁, ▁3 ▁) ▁!= ▁0 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" invalid value \"% V \" int he \" wait \" parameter " ▁, ▁wait ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁} ▁if ▁( ▁uri ▁== ▁NULL ▁) ▁{ ▁uri ▁= ▁file ▁; ▁wait ▁= ▁( ▁ngx _ str _ t ▁* ▁) ▁-1 ▁; ▁} ▁rc ▁= ▁ngx _ http _ ssi _ evaluate _ string ▁( ▁r ▁, ▁ctx ▁, ▁uri ▁, ▁NGX _ HTTP _ S SI _ ADD _ PREFIX ▁) ▁; ▁if ▁( ▁rc ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁rc ▁; ▁} ▁dst ▁= ▁uri ▁-> ▁data ▁; ▁src ▁= ▁uri ▁-> ▁data ▁; ▁ngx _ un escape _ uri ▁( ▁& ▁dst ▁, ▁& ▁src ▁, ▁uri ▁-> ▁len ▁, ▁NGX _ UN ESCAPE _ URI ▁) ▁; ▁len ▁= ▁( ▁uri ▁-> ▁data ▁+ ▁uri ▁-> ▁len ▁) ▁- ▁src ▁; ▁if ▁( ▁len ▁) ▁{ ▁dst ▁= ▁ngx _ mov em em ▁( ▁dst ▁, ▁src ▁, ▁len ▁) ▁; ▁} ▁uri ▁-> ▁len ▁= ▁dst ▁- ▁uri ▁-> ▁data ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" ssi include : \"% V \"" ▁, ▁uri ▁) ▁; ▁ngx _ str _ null ▁( ▁& ▁args ▁) ▁; ▁flags ▁= ▁NGX _ HTTP _ LOG _ UN SAFE ▁; ▁if ▁( ▁ngx _ http _ parse _ unsafe _ uri ▁( ▁r ▁, ▁uri ▁, ▁& ▁args ▁, ▁& ▁flags ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁psr ▁= ▁NULL ▁; ▁mctx ▁= ▁ngx _ http _ get _ module _ ctx ▁( ▁r ▁-> ▁main ▁, ▁ngx _ http _ ssi _ filter _ module ▁) ▁; ▁if ▁( ▁stub ▁) ▁{ ▁if ▁( ▁mctx ▁-> ▁blocks ▁) ▁{ ▁bl ▁= ▁mctx ▁-> ▁blocks ▁-> ▁elts ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁mctx ▁-> ▁blocks ▁-> ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁stub ▁-> ▁len ▁== ▁bl ▁[ ▁i ▁] ▁. ▁name ▁. ▁len ▁&& ▁ngx _ strncmp ▁( ▁stub ▁-> ▁data ▁, ▁bl ▁[ ▁i ▁] ▁. ▁name ▁. ▁data ▁, ▁stub ▁-> ▁len ▁) ▁== ▁0 ▁) ▁{ ▁goto ▁found ▁; ▁} ▁} ▁} ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁"\" stub \" =\"% V \" for \" include \" not found " ▁, ▁stub ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁found ▁: ▁psr ▁= ▁ngx _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁sizeof ▁( ▁ngx _ http _ post _ sub request _ t ▁) ▁) ▁; ▁if ▁( ▁psr ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁psr ▁-> ▁handler ▁= ▁ngx _ http _ ssi _ stub _ output ▁; ▁if ▁( ▁bl ▁[ ▁i ▁] ▁. ▁count ▁++ ▁) ▁{ ▁out ▁= ▁NULL ▁; ▁ll ▁= ▁& ▁out ▁; ▁for ▁( ▁tl ▁= ▁bl ▁[ ▁i ▁] ▁. ▁bufs ▁; ▁tl ▁; ▁tl ▁= ▁tl ▁-> ▁next ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁free ▁) ▁{ ▁cl ▁= ▁ctx ▁-> ▁free ▁; ▁ctx ▁-> ▁free ▁= ▁ctx ▁-> ▁free ▁-> ▁next ▁; ▁b ▁= ▁cl ▁-> ▁buf ▁; ▁} ▁else ▁{ ▁b ▁= ▁ngx _ alloc _ buf ▁( ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁b ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁cl ▁= ▁ngx _ alloc _ chain _ link ▁( ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁cl ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁cl ▁-> ▁buf ▁= ▁b ▁; ▁} ▁ngx _ memcpy ▁( ▁b ▁, ▁tl ▁-> ▁buf ▁, ▁sizeof ▁( ▁ngx _ buf _ t ▁) ▁) ▁; ▁b ▁-> ▁pos ▁= ▁b ▁-> ▁start ▁; ▁* ▁ll ▁= ▁cl ▁; ▁cl ▁-> ▁next ▁= ▁NULL ▁; ▁ll ▁= ▁& ▁cl ▁-> ▁next ▁; ▁} ▁psr ▁-> ▁data ▁= ▁out ▁; ▁} ▁else ▁{ ▁psr ▁-> ▁data ▁= ▁bl ▁[ ▁i ▁] ▁. ▁bufs ▁; ▁} ▁} ▁if ▁( ▁wait ▁) ▁{ ▁flags ▁|= ▁NGX _ HTTP _ SUB REQUEST _ WAIT ED ▁; ▁} ▁if ▁( ▁set ▁) ▁{ ▁key ▁= ▁ngx _ hash _ str low ▁( ▁set ▁-> ▁data ▁, ▁set ▁-> ▁data ▁, ▁set ▁-> ▁len ▁) ▁; ▁psr ▁= ▁ngx _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁sizeof ▁( ▁ngx _ http _ post _ sub request _ t ▁) ▁) ▁; ▁if ▁( ▁psr ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁psr ▁-> ▁handler ▁= ▁ngx _ http _ ssi _ set _ variable ▁; ▁psr ▁-> ▁data ▁= ▁ngx _ http _ ssi _ get _ variable ▁( ▁r ▁, ▁set ▁, ▁key ▁) ▁; ▁if ▁( ▁psr ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁mctx ▁-> ▁variables ▁== ▁NULL ▁) ▁{ ▁mctx ▁-> ▁variables ▁= ▁ngx _ list _ create ▁( ▁r ▁-> ▁pool ▁, ▁4 ▁, ▁sizeof ▁( ▁ngx _ http _ ssi _ var _ t ▁) ▁) ▁; ▁if ▁( ▁mctx ▁-> ▁variables ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁} ▁var ▁= ▁ngx _ list _ push ▁( ▁mctx ▁-> ▁variables ▁) ▁; ▁if ▁( ▁var ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁var ▁-> ▁name ▁= ▁* ▁set ▁; ▁var ▁-> ▁key ▁= ▁key ▁; ▁var ▁-> ▁value ▁= ▁ngx _ http _ ssi _ null _ string ▁; ▁psr ▁-> ▁data ▁= ▁& ▁var ▁-> ▁value ▁; ▁} ▁flags ▁|= ▁NGX _ HTTP _ SUB REQUEST _ IN _ MEMORY ▁| ▁NGX _ HTTP _ SUB REQUEST _ WAIT ED ▁; ▁} ▁if ▁( ▁ngx _ http _ sub request ▁( ▁r ▁, ▁uri ▁, ▁& ▁args ▁, ▁& ▁sr ▁, ▁psr ▁, ▁flags ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁wait ▁== ▁NULL ▁&& ▁set ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ OK ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁wait ▁== ▁NULL ▁) ▁{ ▁ctx ▁-> ▁wait ▁= ▁sr ▁; ▁return ▁NGX _ AGAIN ▁; ▁} ▁else ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" can only wait for ones ub request at atime " ▁) ▁; ▁} ▁return ▁NGX _ OK ▁; ▁}	1
▁int ▁av _ fill _ image _ pointers ▁( ▁uint 8_ t ▁* ▁data ▁[ ▁4 ▁] ▁, ▁enum ▁PixelFormat ▁pix _ fmt ▁, ▁int ▁height ▁, ▁uint 8_ t ▁* ▁ptr ▁, ▁const ▁int ▁lines izes ▁[ ▁4 ▁] ▁) ▁{ ▁int ▁i ▁, ▁total _ size ▁, ▁size ▁[ ▁4 ▁] ▁, ▁has _ plane ▁[ ▁4 ▁] ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁& ▁av _ pix _ fmt _ descriptors ▁[ ▁pix _ fmt ▁] ▁; ▁memset ▁( ▁data ▁, ▁0 ▁, ▁sizeof ▁( ▁data ▁[ ▁0 ▁] ▁) ▁* ▁4 ▁) ▁; ▁memset ▁( ▁size ▁, ▁0 ▁, ▁sizeof ▁( ▁size ▁) ▁) ▁; ▁memset ▁( ▁has _ plane ▁, ▁0 ▁, ▁sizeof ▁( ▁has _ plane ▁) ▁) ▁; ▁if ▁( ▁desc ▁-> ▁flags ▁& ▁PIX _ FMT _ HW ACCEL ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁data ▁[ ▁0 ▁] ▁= ▁ptr ▁; ▁size ▁[ ▁0 ▁] ▁= ▁lines izes ▁[ ▁0 ▁] ▁* ▁height ▁; ▁if ▁( ▁desc ▁-> ▁flags ▁& ▁PIX _ FMT _ PAL ▁) ▁{ ▁size ▁[ ▁0 ▁] ▁= ▁( ▁size ▁[ ▁0 ▁] ▁+ ▁3 ▁) ▁& ▁ ~ ▁3 ▁; ▁data ▁[ ▁1 ▁] ▁= ▁ptr ▁+ ▁size ▁[ ▁0 ▁] ▁; ▁return ▁size ▁[ ▁0 ▁] ▁+ ▁256 ▁* ▁4 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁has _ plane ▁[ ▁desc ▁-> ▁comp ▁[ ▁i ▁] ▁. ▁plane ▁] ▁= ▁1 ▁; ▁total _ size ▁= ▁size ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁has _ plane ▁[ ▁i ▁] ▁&& ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁h ▁, ▁s ▁= ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁) ▁? ▁desc ▁-> ▁log 2_ chroma _ h ▁: ▁0 ▁; ▁data ▁[ ▁i ▁] ▁= ▁data ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁size ▁[ ▁i ▁- ▁1 ▁] ▁; ▁h ▁= ▁( ▁height ▁+ ▁( ▁1 ▁<< ▁s ▁) ▁- ▁1 ▁) ▁>> ▁s ▁; ▁size ▁[ ▁i ▁] ▁= ▁h ▁* ▁lines izes ▁[ ▁i ▁] ▁; ▁total _ size ▁+= ▁size ▁[ ▁i ▁] ▁; ▁} ▁return ▁total _ size ▁; ▁}	1
▁static ▁void ▁fe _ mul 12 16 66 ▁( ▁fe ▁h ▁, ▁fe ▁f ▁) ▁{ ▁int 32_ t ▁f 0 ▁= ▁f ▁[ ▁0 ▁] ▁; ▁int 32_ t ▁f 1 ▁= ▁f ▁[ ▁1 ▁] ▁; ▁int 32_ t ▁f 2 ▁= ▁f ▁[ ▁2 ▁] ▁; ▁int 32_ t ▁f 3 ▁= ▁f ▁[ ▁3 ▁] ▁; ▁int 32_ t ▁f 4 ▁= ▁f ▁[ ▁4 ▁] ▁; ▁int 32_ t ▁f 5 ▁= ▁f ▁[ ▁5 ▁] ▁; ▁int 32_ t ▁f 6 ▁= ▁f ▁[ ▁6 ▁] ▁; ▁int 32_ t ▁f 7 ▁= ▁f ▁[ ▁7 ▁] ▁; ▁int 32_ t ▁f 8 ▁= ▁f ▁[ ▁8 ▁] ▁; ▁int 32_ t ▁f 9 ▁= ▁f ▁[ ▁9 ▁] ▁; ▁int 64_ t ▁h 0 ▁= ▁f 0 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 1 ▁= ▁f 1 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 2 ▁= ▁f 2 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 3 ▁= ▁f 3 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 4 ▁= ▁f 4 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 5 ▁= ▁f 5 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 6 ▁= ▁f 6 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 7 ▁= ▁f 7 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 8 ▁= ▁f 8 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁h 9 ▁= ▁f 9 ▁* ▁( ▁int 64_ t ▁) ▁12 16 66 ▁; ▁int 64_ t ▁carry 0 ▁; ▁int 64_ t ▁carry 1 ▁; ▁int 64_ t ▁carry 2 ▁; ▁int 64_ t ▁carry 3 ▁; ▁int 64_ t ▁carry 4 ▁; ▁int 64_ t ▁carry 5 ▁; ▁int 64_ t ▁carry 6 ▁; ▁int 64_ t ▁carry 7 ▁; ▁int 64_ t ▁carry 8 ▁; ▁int 64_ t ▁carry 9 ▁; ▁carry 9 ▁= ▁h 9 ▁+ ▁( ▁1 ▁<< ▁24 ▁) ▁; ▁h 0 ▁+= ▁( ▁carry 9 ▁>> ▁25 ▁) ▁* ▁19 ▁; ▁h 9 ▁-= ▁carry 9 ▁& ▁k Top 39 Bits ▁; ▁carry 1 ▁= ▁h 1 ▁+ ▁( ▁1 ▁<< ▁24 ▁) ▁; ▁h 2 ▁+= ▁carry 1 ▁>> ▁25 ▁; ▁h 1 ▁-= ▁carry 1 ▁& ▁k Top 39 Bits ▁; ▁carry 3 ▁= ▁h 3 ▁+ ▁( ▁1 ▁<< ▁24 ▁) ▁; ▁h 4 ▁+= ▁carry 3 ▁>> ▁25 ▁; ▁h 3 ▁-= ▁carry 3 ▁& ▁k Top 39 Bits ▁; ▁carry 5 ▁= ▁h 5 ▁+ ▁( ▁1 ▁<< ▁24 ▁) ▁; ▁h 6 ▁+= ▁carry 5 ▁>> ▁25 ▁; ▁h 5 ▁-= ▁carry 5 ▁& ▁k Top 39 Bits ▁; ▁carry 7 ▁= ▁h 7 ▁+ ▁( ▁1 ▁<< ▁24 ▁) ▁; ▁h 8 ▁+= ▁carry 7 ▁>> ▁25 ▁; ▁h 7 ▁-= ▁carry 7 ▁& ▁k Top 39 Bits ▁; ▁carry 0 ▁= ▁h 0 ▁+ ▁( ▁1 ▁<< ▁25 ▁) ▁; ▁h 1 ▁+= ▁carry 0 ▁>> ▁26 ▁; ▁h 0 ▁-= ▁carry 0 ▁& ▁k Top 38 Bits ▁; ▁carry 2 ▁= ▁h 2 ▁+ ▁( ▁1 ▁<< ▁25 ▁) ▁; ▁h 3 ▁+= ▁carry 2 ▁>> ▁26 ▁; ▁h 2 ▁-= ▁carry 2 ▁& ▁k Top 38 Bits ▁; ▁carry 4 ▁= ▁h 4 ▁+ ▁( ▁1 ▁<< ▁25 ▁) ▁; ▁h 5 ▁+= ▁carry 4 ▁>> ▁26 ▁; ▁h 4 ▁-= ▁carry 4 ▁& ▁k Top 38 Bits ▁; ▁carry 6 ▁= ▁h 6 ▁+ ▁( ▁1 ▁<< ▁25 ▁) ▁; ▁h 7 ▁+= ▁carry 6 ▁>> ▁26 ▁; ▁h 6 ▁-= ▁carry 6 ▁& ▁k Top 38 Bits ▁; ▁carry 8 ▁= ▁h 8 ▁+ ▁( ▁1 ▁<< ▁25 ▁) ▁; ▁h 9 ▁+= ▁carry 8 ▁>> ▁26 ▁; ▁h 8 ▁-= ▁carry 8 ▁& ▁k Top 38 Bits ▁; ▁h ▁[ ▁0 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 0 ▁; ▁h ▁[ ▁1 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 1 ▁; ▁h ▁[ ▁2 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 2 ▁; ▁h ▁[ ▁3 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 3 ▁; ▁h ▁[ ▁4 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 4 ▁; ▁h ▁[ ▁5 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 5 ▁; ▁h ▁[ ▁6 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 6 ▁; ▁h ▁[ ▁7 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 7 ▁; ▁h ▁[ ▁8 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 8 ▁; ▁h ▁[ ▁9 ▁] ▁= ▁( ▁int 32_ t ▁) ▁h 9 ▁; ▁}	1
▁const ▁EVP _ PKEY _ ASN 1_ METHOD ▁* ▁EVP _ PKEY _ asn 1_ find ▁( ▁ENGINE ▁* ▁* ▁pe ▁, ▁int ▁type ▁) ▁{ ▁const ▁EVP _ PKEY _ ASN 1_ METHOD ▁* ▁t ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁t ▁= ▁pkey _ asn 1_ find ▁( ▁type ▁) ▁; ▁if ▁( ▁! ▁t ▁|| ▁! ▁( ▁t ▁-> ▁pkey _ flags ▁& ▁ASN 1_ PKEY _ ALIAS ▁) ▁) ▁break ▁; ▁type ▁= ▁t ▁-> ▁pkey _ base _ id ▁; ▁} ▁if ▁( ▁pe ▁) ▁{ ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁ENGINE ▁* ▁e ▁; ▁e ▁= ▁ENGINE _ get _ pkey _ asn 1_ meth _ engine ▁( ▁type ▁) ▁; ▁if ▁( ▁e ▁) ▁{ ▁* ▁pe ▁= ▁e ▁; ▁return ▁ENGINE _ get _ pkey _ asn 1_ meth ▁( ▁e ▁, ▁type ▁) ▁; ▁} ▁# endif ▁* ▁pe ▁= ▁NULL ▁; ▁} ▁return ▁t ▁; ▁}	1
▁char ▁* ▁av _ str ndup ▁( ▁const ▁char ▁* ▁s ▁, ▁size _ t ▁len ▁) ▁{ ▁char ▁* ▁ret ▁= ▁NULL ▁, ▁* ▁end ▁; ▁if ▁( ▁! ▁s ▁) ▁return ▁NULL ▁; ▁end ▁= ▁memchr ▁( ▁s ▁, ▁0 ▁, ▁len ▁) ▁; ▁if ▁( ▁end ▁) ▁len ▁= ▁end ▁- ▁s ▁; ▁ret ▁= ▁av _ realloc ▁( ▁NULL ▁, ▁len ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁return ▁NULL ▁; ▁memcpy ▁( ▁ret ▁, ▁s ▁, ▁len ▁) ▁; ▁ret ▁[ ▁len ▁] ▁= ▁0 ▁; ▁return ▁ret ▁; ▁}	1
▁void ▁BN _ free ▁( ▁BIGNUM ▁* ▁a ▁) ▁{ ▁if ▁( ▁a ▁== ▁NULL ▁) ▁return ▁; ▁if ▁( ▁! ▁BN _ get _ flags ▁( ▁a ▁, ▁BN _ FLG _ STATIC _ DATA ▁) ▁) ▁bn _ free _ d ▁( ▁a ▁) ▁; ▁if ▁( ▁a ▁-> ▁flags ▁& ▁BN _ FLG _ MALLOC ED ▁) ▁OPENSSL _ free ▁( ▁a ▁) ▁; ▁}	0
▁static ▁int ▁output _ packet ▁( ▁InputStream ▁* ▁ist ▁, ▁const ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁, ▁i ▁; ▁int ▁got _ output ▁= ▁0 ▁; ▁AVPacket ▁avpkt ▁; ▁if ▁( ▁! ▁ist ▁-> ▁saw _ first _ ts ▁) ▁{ ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁st ▁-> ▁avg _ frame _ rate ▁. ▁num ▁? ▁- ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁has _ b _ frames ▁* ▁AV _ TIME _ BASE ▁/ ▁av _ q 2 d ▁( ▁ist ▁-> ▁st ▁-> ▁avg _ frame _ rate ▁) ▁: ▁0 ▁; ▁ist ▁-> ▁pts ▁= ▁0 ▁; ▁if ▁( ▁pkt ▁!= ▁NULL ▁&& ▁pkt ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁{ ▁ist ▁-> ▁dts ▁+= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁pts ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁} ▁ist ▁-> ▁saw _ first _ ts ▁= ▁1 ▁; ▁} ▁if ▁( ▁ist ▁-> ▁next _ dts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁ist ▁-> ▁next _ dts ▁= ▁ist ▁-> ▁dts ▁; ▁if ▁( ▁ist ▁-> ▁next _ pts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁pts ▁; ▁if ▁( ▁pkt ▁== ▁NULL ▁) ▁{ ▁av _ init _ packet ▁( ▁& ▁avpkt ▁) ▁; ▁avpkt ▁. ▁data ▁= ▁NULL ▁; ▁avpkt ▁. ▁size ▁= ▁0 ▁; ▁goto ▁handle _ eof ▁; ▁} ▁else ▁{ ▁avpkt ▁= ▁* ▁pkt ▁; ▁} ▁if ▁( ▁pkt ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁= ▁ist ▁-> ▁dts ▁= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁dts ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁if ▁( ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ VIDEO ▁|| ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁} ▁while ▁( ▁ist ▁-> ▁decoding _ needed ▁&& ▁( ▁avpkt ▁. ▁size ▁> ▁0 ▁|| ▁( ▁! ▁pkt ▁&& ▁got _ output ▁) ▁) ▁) ▁{ ▁int ▁duration ▁; ▁handle _ eof ▁: ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁next _ pts ▁; ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁if ▁( ▁avpkt ▁. ▁size ▁&& ▁avpkt ▁. ▁size ▁!= ▁pkt ▁-> ▁size ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁ist ▁-> ▁show ed _ multi _ packet _ warning ▁? ▁AV _ LOG _ VERBOSE ▁: ▁AV _ LOG _ WARNING ▁, ▁" Multiple frames in ap acket from stream % d \ n " ▁, ▁pkt ▁-> ▁stream _ index ▁) ▁; ▁ist ▁-> ▁show ed _ multi _ packet _ warning ▁= ▁1 ▁; ▁} ▁switch ▁( ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁ret ▁= ▁decode _ audio ▁( ▁ist ▁, ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁ret ▁= ▁decode _ video ▁( ▁ist ▁, ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁if ▁( ▁avpkt ▁. ▁duration ▁) ▁{ ▁duration ▁= ▁av _ re scale _ q ▁( ▁avpkt ▁. ▁duration ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁} ▁else ▁if ▁( ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁num ▁!= ▁0 ▁&& ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁den ▁!= ▁0 ▁) ▁{ ▁int ▁ticks ▁= ▁ist ▁-> ▁st ▁-> ▁parser ▁? ▁ist ▁-> ▁st ▁-> ▁parser ▁-> ▁repeat _ p ict ▁+ ▁1 ▁: ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁ticks _ per _ frame ▁; ▁duration ▁= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁num ▁* ▁ticks ▁) ▁/ ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁den ▁; ▁} ▁else ▁duration ▁= ▁0 ▁; ▁if ▁( ▁ist ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁duration ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁+= ▁duration ▁; ▁} ▁else ▁ist ▁-> ▁next _ dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁if ▁( ▁got _ output ▁) ▁ist ▁-> ▁next _ pts ▁+= ▁duration ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ SUBTITLE ▁: ▁ret ▁= ▁trans code _ sub title s ▁( ▁ist ▁, ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁break ▁; ▁default ▁: ▁return ▁-1 ▁; ▁} ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁avpkt ▁. ▁dts ▁= ▁avpkt ▁. ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁if ▁( ▁pkt ▁) ▁{ ▁if ▁( ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁ret ▁= ▁avpkt ▁. ▁size ▁; ▁avpkt ▁. ▁data ▁+= ▁ret ▁; ▁avpkt ▁. ▁size ▁-= ▁ret ▁; ▁} ▁if ▁( ▁! ▁got _ output ▁) ▁{ ▁continue ▁; ▁} ▁} ▁if ▁( ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁{ ▁rate _ emu _ sleep ▁( ▁ist ▁) ▁; ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁switch ▁( ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁ist ▁-> ▁next _ dts ▁+= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁frame _ size ▁) ▁/ ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁if ▁( ▁pkt ▁-> ▁duration ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁+= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁duration ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁} ▁else ▁if ▁( ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁num ▁!= ▁0 ▁) ▁{ ▁int ▁ticks ▁= ▁ist ▁-> ▁st ▁-> ▁parser ▁? ▁ist ▁-> ▁st ▁-> ▁parser ▁-> ▁repeat _ p ict ▁+ ▁1 ▁: ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁ticks _ per _ frame ▁; ▁ist ▁-> ▁next _ dts ▁+= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁num ▁* ▁ticks ▁) ▁/ ▁ist ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁. ▁den ▁; ▁} ▁break ▁; ▁} ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁pkt ▁&& ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁check _ output _ constraints ▁( ▁ist ▁, ▁o st ▁) ▁|| ▁o st ▁-> ▁encoding _ needed ▁) ▁continue ▁; ▁do _ stream copy ▁( ▁ist ▁, ▁o st ▁, ▁pkt ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁EC _ KEY ▁* ▁make _ ec _ ep hemeral _ key ▁( ▁EC _ KEY ▁* ▁peer _ key ▁, ▁BIGNUM ▁* ▁se ckey ▁) ▁{ ▁EC _ KEY ▁* ▁out ▁= ▁EC _ KEY _ new ▁( ▁) ▁; ▁EC _ KEY _ copy ▁( ▁out ▁, ▁peer _ key ▁) ▁; ▁EC _ KEY _ set _ private _ key ▁( ▁out ▁, ▁se ckey ▁) ▁; ▁g ost 200 1_ compute _ public ▁( ▁out ▁) ▁; ▁return ▁out ▁; ▁}	1
▁static ▁int ▁unpack _ modes ▁( ▁V p 3 Decode Context ▁* ▁s ▁, ▁Get Bit Context ▁* ▁gb ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁sb _ x ▁, ▁sb _ y ▁; ▁int ▁scheme ▁; ▁int ▁current _ macro block ▁; ▁int ▁current _ fragment ▁; ▁int ▁coding _ mode ▁; ▁int ▁custom _ mode _ al phabet ▁[ ▁COD ING _ MODE _ COUNT ▁] ▁; ▁const ▁int ▁* ▁alphabet ▁; ▁if ▁( ▁s ▁-> ▁keyframe ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁fragment _ count ▁; ▁i ▁++ ▁) ▁s ▁-> ▁all _ frag ments ▁[ ▁i ▁] ▁. ▁coding _ method ▁= ▁MODE _ INTR A ▁; ▁} ▁else ▁{ ▁scheme ▁= ▁get _ bits ▁( ▁gb ▁, ▁3 ▁) ▁; ▁if ▁( ▁scheme ▁== ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁custom _ mode _ al phabet ▁[ ▁i ▁] ▁= ▁MODE _ INTER _ NO _ MV ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁custom _ mode _ al phabet ▁[ ▁get _ bits ▁( ▁gb ▁, ▁3 ▁) ▁] ▁= ▁i ▁; ▁alphabet ▁= ▁custom _ mode _ al phabet ▁; ▁} ▁else ▁alphabet ▁= ▁Mode Al phabet ▁[ ▁scheme ▁- ▁1 ▁] ▁; ▁for ▁( ▁sb _ y ▁= ▁0 ▁; ▁sb _ y ▁< ▁s ▁-> ▁y _ super block _ height ▁; ▁sb _ y ▁++ ▁) ▁{ ▁for ▁( ▁sb _ x ▁= ▁0 ▁; ▁sb _ x ▁< ▁s ▁-> ▁y _ super block _ width ▁; ▁sb _ x ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁int ▁mb _ x ▁= ▁2 ▁* ▁sb _ x ▁+ ▁( ▁j ▁>> ▁1 ▁) ▁; ▁int ▁mb _ y ▁= ▁2 ▁* ▁sb _ y ▁+ ▁( ▁( ▁( ▁j ▁>> ▁1 ▁) ▁+ ▁j ▁) ▁& ▁1 ▁) ▁; ▁int ▁frag s _ coded ▁= ▁0 ▁; ▁current _ macro block ▁= ▁mb _ y ▁* ▁s ▁-> ▁macro block _ width ▁+ ▁mb _ x ▁; ▁if ▁( ▁mb _ x ▁>= ▁s ▁-> ▁macro block _ width ▁|| ▁mb _ y ▁>= ▁s ▁-> ▁macro block _ height ▁) ▁continue ▁; ▁# define ▁BLOCK _ X ▁(2 * mb _ x +( k & 1 )) ▁# define ▁BLOCK _ Y ▁(2 * mb _ y +( k >> 1 )) ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁4 ▁; ▁k ▁++ ▁) ▁{ ▁current _ fragment ▁= ▁BLOCK _ Y ▁* ▁s ▁-> ▁fragment _ width ▁+ ▁BLOCK _ X ▁; ▁if ▁( ▁s ▁-> ▁all _ frag ments ▁[ ▁current _ fragment ▁] ▁. ▁coding _ method ▁!= ▁MODE _ COPY ▁) ▁break ▁; ▁} ▁if ▁( ▁k ▁== ▁4 ▁) ▁{ ▁s ▁-> ▁macro block _ coding ▁[ ▁current _ macro block ▁] ▁= ▁MODE _ INTER _ NO _ MV ▁; ▁continue ▁; ▁} ▁if ▁( ▁scheme ▁== ▁7 ▁) ▁coding _ mode ▁= ▁get _ bits ▁( ▁gb ▁, ▁3 ▁) ▁; ▁else ▁coding _ mode ▁= ▁alphabet ▁[ ▁get _ vlc 2 ▁( ▁gb ▁, ▁s ▁-> ▁mode _ code _ vlc ▁. ▁table ▁, ▁3 ▁, ▁3 ▁) ▁] ▁; ▁s ▁-> ▁macro block _ coding ▁[ ▁current _ macro block ▁] ▁= ▁coding _ mode ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁4 ▁; ▁k ▁++ ▁) ▁{ ▁current _ fragment ▁= ▁BLOCK _ Y ▁* ▁s ▁-> ▁fragment _ width ▁+ ▁BLOCK _ X ▁; ▁if ▁( ▁s ▁-> ▁all _ frag ments ▁[ ▁current _ fragment ▁] ▁. ▁coding _ method ▁!= ▁MODE _ COPY ▁) ▁s ▁-> ▁all _ frag ments ▁[ ▁current _ fragment ▁] ▁. ▁coding _ method ▁= ▁coding _ mode ▁; ▁} ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁2 ▁; ▁k ▁++ ▁) ▁{ ▁current _ fragment ▁= ▁s ▁-> ▁fragment _ start ▁[ ▁k ▁+ ▁1 ▁] ▁+ ▁mb _ y ▁* ▁( ▁s ▁-> ▁fragment _ width ▁>> ▁1 ▁) ▁+ ▁mb _ x ▁; ▁if ▁( ▁s ▁-> ▁all _ frag ments ▁[ ▁current _ fragment ▁] ▁. ▁coding _ method ▁!= ▁MODE _ COPY ▁) ▁s ▁-> ▁all _ frag ments ▁[ ▁current _ fragment ▁] ▁. ▁coding _ method ▁= ▁coding _ mode ▁; ▁} ▁} ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁r ac _ get _ model 256_ sym ▁( ▁Range Coder ▁* ▁c ▁, ▁Model 256 ▁* ▁m ▁) ▁{ ▁int ▁val ▁; ▁int ▁start ▁, ▁end ▁; ▁int ▁ss ym ▁; ▁unsigned ▁prob ▁, ▁prob 2 ▁, ▁helper ▁; ▁prob 2 ▁= ▁c ▁-> ▁range ▁; ▁c ▁-> ▁range ▁>>= ▁MODEL _ SCALE ▁; ▁helper ▁= ▁c ▁-> ▁low ▁/ ▁c ▁-> ▁range ▁; ▁ss ym ▁= ▁helper ▁>> ▁MODEL 256_ SEC _ SCALE ▁; ▁val ▁= ▁m ▁-> ▁secondary ▁[ ▁ss ym ▁] ▁; ▁end ▁= ▁start ▁= ▁m ▁-> ▁secondary ▁[ ▁ss ym ▁+ ▁1 ▁] ▁+ ▁1 ▁; ▁while ▁( ▁end ▁> ▁val ▁+ ▁1 ▁) ▁{ ▁ss ym ▁= ▁( ▁end ▁+ ▁val ▁) ▁>> ▁1 ▁; ▁if ▁( ▁m ▁-> ▁freqs ▁[ ▁ss ym ▁] ▁<= ▁helper ▁) ▁{ ▁end ▁= ▁start ▁; ▁val ▁= ▁ss ym ▁; ▁} ▁else ▁{ ▁end ▁= ▁( ▁end ▁+ ▁val ▁) ▁>> ▁1 ▁; ▁start ▁= ▁ss ym ▁; ▁} ▁} ▁prob ▁= ▁m ▁-> ▁freqs ▁[ ▁val ▁] ▁* ▁c ▁-> ▁range ▁; ▁if ▁( ▁val ▁!= ▁255 ▁) ▁prob 2 ▁= ▁m ▁-> ▁freqs ▁[ ▁val ▁+ ▁1 ▁] ▁* ▁c ▁-> ▁range ▁; ▁c ▁-> ▁low ▁-= ▁prob ▁; ▁c ▁-> ▁range ▁= ▁prob 2 ▁- ▁prob ▁; ▁if ▁( ▁c ▁-> ▁range ▁< ▁R AC _ BOTTOM ▁) ▁r ac _ normal ise ▁( ▁c ▁) ▁; ▁model 256_ update ▁( ▁m ▁, ▁val ▁) ▁; ▁return ▁val ▁; ▁}	0
▁static ▁const ▁char ▁* ▁add _ opts ▁( ▁cmd _ parms ▁* ▁cmd ▁, ▁void ▁* ▁d ▁, ▁int ▁argc ▁, ▁char ▁* ▁const ▁argv ▁[ ▁] ▁) ▁{ ▁int ▁i ▁; ▁char ▁* ▁w ▁; ▁apr _ int 32_ t ▁opts ▁; ▁apr _ int 32_ t ▁opts _ add ▁; ▁apr _ int 32_ t ▁opts _ remove ▁; ▁char ▁action ▁; ▁auto index _ config _ rec ▁* ▁d _ cfg ▁= ▁( ▁auto index _ config _ rec ▁* ▁) ▁d ▁; ▁opts ▁= ▁d _ cfg ▁-> ▁opts ▁; ▁opts _ add ▁= ▁d _ cfg ▁-> ▁increment ed _ opts ▁; ▁opts _ remove ▁= ▁d _ cfg ▁-> ▁decrement ed _ opts ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁argc ▁; ▁i ▁++ ▁) ▁{ ▁int ▁option ▁= ▁0 ▁; ▁w ▁= ▁argv ▁[ ▁i ▁] ▁; ▁if ▁( ▁( ▁* ▁w ▁== ▁' ▁' ▁) ▁|| ▁( ▁* ▁w ▁== ▁' ▁' ▁) ▁) ▁{ ▁action ▁= ▁* ▁( ▁w ▁++ ▁) ▁; ▁} ▁else ▁{ ▁action ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" F ancy Indexing " ▁) ▁) ▁{ ▁option ▁= ▁FAN CY _ INDEX ING ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Folders First " ▁) ▁) ▁{ ▁option ▁= ▁F OLDER S _ FIRST ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" HTML Table " ▁) ▁) ▁{ ▁option ▁= ▁TABLE _ INDEX ING ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Icons Are Links " ▁) ▁) ▁{ ▁option ▁= ▁ICON S _ ARE _ LINK S ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" IgnoreCase " ▁) ▁) ▁{ ▁option ▁= ▁IGNORE _ CASE ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Ignore Client " ▁) ▁) ▁{ ▁option ▁= ▁IGNORE _ CLIENT ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Scan HTML Title s " ▁) ▁) ▁{ ▁option ▁= ▁SCAN _ HTML _ TIT LES ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Suppress Column Sorting " ▁) ▁) ▁{ ▁option ▁= ▁SUP PRESS _ COLS ORT ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Suppress Description " ▁) ▁) ▁{ ▁option ▁= ▁SUP PRESS _ DESC ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Suppress HTML P reamble " ▁) ▁) ▁{ ▁option ▁= ▁SUP PRESS _ PRE AM BLE ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Suppress Icon " ▁) ▁) ▁{ ▁option ▁= ▁SUP PRESS _ ICON ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Suppress LastModified " ▁) ▁) ▁{ ▁option ▁= ▁SUP PRESS _ LAST _ MOD ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Suppress Size " ▁) ▁) ▁{ ▁option ▁= ▁SUP PRESS _ SIZE ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Suppress Rules " ▁) ▁) ▁{ ▁option ▁= ▁SUP PRESS _ R ULES ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Track Modified " ▁) ▁) ▁{ ▁option ▁= ▁TRACK _ MODIFIED ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Version Sort " ▁) ▁) ▁{ ▁option ▁= ▁VERSION _ SORT ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" X HTML " ▁) ▁) ▁{ ▁option ▁= ▁EM IT _ X HTML ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Show Forbidden " ▁) ▁) ▁{ ▁option ▁= ▁SHOW _ FOR BIDDEN ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" None " ▁) ▁) ▁{ ▁if ▁( ▁action ▁!= ▁' ▁\0 ▁' ▁) ▁{ ▁return ▁" Cannot combine ' +' or ' - ' with ' None ' keyword " ▁; ▁} ▁opts ▁= ▁NO _ OPTIONS ▁; ▁opts _ add ▁= ▁0 ▁; ▁opts _ remove ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Icon Width " ▁) ▁) ▁{ ▁if ▁( ▁action ▁!= ▁' ▁' ▁) ▁{ ▁d _ cfg ▁-> ▁icon _ width ▁= ▁DEFAULT _ ICON _ WIDTH ▁; ▁} ▁else ▁{ ▁d _ cfg ▁-> ▁icon _ width ▁= ▁0 ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁strncasecmp ▁( ▁w ▁, ▁" Icon Width =" ▁, ▁10 ▁) ▁) ▁{ ▁if ▁( ▁action ▁== ▁' ▁' ▁) ▁{ ▁return ▁" Cannot combine ' - ' with Icon Width = n " ▁; ▁} ▁d _ cfg ▁-> ▁icon _ width ▁= ▁atoi ▁( ▁& ▁w ▁[ ▁10 ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Icon Height " ▁) ▁) ▁{ ▁if ▁( ▁action ▁!= ▁' ▁' ▁) ▁{ ▁d _ cfg ▁-> ▁icon _ height ▁= ▁DEFAULT _ ICON _ HEIGHT ▁; ▁} ▁else ▁{ ▁d _ cfg ▁-> ▁icon _ height ▁= ▁0 ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁strncasecmp ▁( ▁w ▁, ▁" Icon Height =" ▁, ▁11 ▁) ▁) ▁{ ▁if ▁( ▁action ▁== ▁' ▁' ▁) ▁{ ▁return ▁" Cannot combine ' - ' with Icon Height = n " ▁; ▁} ▁d _ cfg ▁-> ▁icon _ height ▁= ▁atoi ▁( ▁& ▁w ▁[ ▁11 ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Name Width " ▁) ▁) ▁{ ▁if ▁( ▁action ▁!= ▁' ▁' ▁) ▁{ ▁return ▁" Name Width with no value may only ap pear as " ▁"' - Name Width '" ▁; ▁} ▁d _ cfg ▁-> ▁name _ width ▁= ▁DEFAULT _ NAME _ WIDTH ▁; ▁d _ cfg ▁-> ▁name _ adjust ▁= ▁K _ NO ADJUST ▁; ▁} ▁else ▁if ▁( ▁! ▁strncasecmp ▁( ▁w ▁, ▁" Name Width =" ▁, ▁10 ▁) ▁) ▁{ ▁if ▁( ▁action ▁== ▁' ▁' ▁) ▁{ ▁return ▁" Cannot combine ' - ' with Name Width = n " ▁; ▁} ▁if ▁( ▁w ▁[ ▁10 ▁] ▁== ▁' ▁' ▁) ▁{ ▁d _ cfg ▁-> ▁name _ adjust ▁= ▁K _ ADJUST ▁; ▁} ▁else ▁{ ▁int ▁width ▁= ▁atoi ▁( ▁& ▁w ▁[ ▁10 ▁] ▁) ▁; ▁if ▁( ▁width ▁&& ▁( ▁width ▁< ▁5 ▁) ▁) ▁{ ▁return ▁" Name Width value must be greater than 5" ▁; ▁} ▁d _ cfg ▁-> ▁name _ width ▁= ▁width ▁; ▁d _ cfg ▁-> ▁name _ adjust ▁= ▁K _ NO ADJUST ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁strcasecmp ▁( ▁w ▁, ▁" Description Width " ▁) ▁) ▁{ ▁if ▁( ▁action ▁!= ▁' ▁' ▁) ▁{ ▁return ▁" Description Width with no value may only ap pear as " ▁"' - Description Width '" ▁; ▁} ▁d _ cfg ▁-> ▁desc _ width ▁= ▁DEFAULT _ DESC _ WIDTH ▁; ▁d _ cfg ▁-> ▁desc _ adjust ▁= ▁K _ NO ADJUST ▁; ▁} ▁else ▁if ▁( ▁! ▁strncasecmp ▁( ▁w ▁, ▁" Description Width =" ▁, ▁17 ▁) ▁) ▁{ ▁if ▁( ▁action ▁== ▁' ▁' ▁) ▁{ ▁return ▁" Cannot combine ' - ' with Description Width = n " ▁; ▁} ▁if ▁( ▁w ▁[ ▁17 ▁] ▁== ▁' ▁' ▁) ▁{ ▁d _ cfg ▁-> ▁desc _ adjust ▁= ▁K _ ADJUST ▁; ▁} ▁else ▁{ ▁int ▁width ▁= ▁atoi ▁( ▁& ▁w ▁[ ▁17 ▁] ▁) ▁; ▁if ▁( ▁width ▁&& ▁( ▁width ▁< ▁12 ▁) ▁) ▁{ ▁return ▁" Description Width value must be greater than 12" ▁; ▁} ▁d _ cfg ▁-> ▁desc _ width ▁= ▁width ▁; ▁d _ cfg ▁-> ▁desc _ adjust ▁= ▁K _ NO ADJUST ▁; ▁} ▁} ▁else ▁{ ▁return ▁" Invalid directory indexing option " ▁; ▁} ▁if ▁( ▁action ▁== ▁' ▁\0 ▁' ▁) ▁{ ▁opts ▁|= ▁option ▁; ▁opts _ add ▁= ▁0 ▁; ▁opts _ remove ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁action ▁== ▁' ▁' ▁) ▁{ ▁opts _ add ▁|= ▁option ▁; ▁opts _ remove ▁&= ▁ ~ ▁option ▁; ▁} ▁else ▁{ ▁opts _ remove ▁|= ▁option ▁; ▁opts _ add ▁&= ▁ ~ ▁option ▁; ▁} ▁} ▁if ▁( ▁( ▁opts ▁& ▁NO _ OPTIONS ▁) ▁&& ▁( ▁opts ▁& ▁ ~ ▁NO _ OPTIONS ▁) ▁) ▁{ ▁return ▁" Cannot combine other Index Options keyword swith ' None '" ▁; ▁} ▁d _ cfg ▁-> ▁increment ed _ opts ▁= ▁opts _ add ▁; ▁d _ cfg ▁-> ▁decrement ed _ opts ▁= ▁opts _ remove ▁; ▁d _ cfg ▁-> ▁opts ▁= ▁opts ▁; ▁return ▁NULL ▁; ▁}	0
▁int ▁av _ dup _ packet ▁( ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁AVPacket ▁tmp _ pkt ▁; ▁if ▁( ▁! ▁pkt ▁-> ▁buf ▁&& ▁pkt ▁-> ▁data ▁) ▁{ ▁tmp _ pkt ▁= ▁* ▁pkt ▁; ▁pkt ▁-> ▁data ▁= ▁NULL ▁; ▁pkt ▁-> ▁side _ data ▁= ▁NULL ▁; ▁DUP _ DATA ▁( ▁pkt ▁-> ▁data ▁, ▁tmp _ pkt ▁. ▁data ▁, ▁pkt ▁-> ▁size ▁, ▁1 ▁, ▁ALLOC _ BUF ▁) ▁; ▁if ▁( ▁pkt ▁-> ▁side _ data _ elems ▁) ▁{ ▁int ▁i ▁; ▁DUP _ DATA ▁( ▁pkt ▁-> ▁side _ data ▁, ▁tmp _ pkt ▁. ▁side _ data ▁, ▁pkt ▁-> ▁side _ data _ elems ▁* ▁sizeof ▁( ▁* ▁pkt ▁-> ▁side _ data ▁) ▁, ▁0 ▁, ▁ALLOC _ MALLOC ▁) ▁; ▁memset ▁( ▁pkt ▁-> ▁side _ data ▁, ▁0 ▁, ▁pkt ▁-> ▁side _ data _ elems ▁* ▁sizeof ▁( ▁* ▁pkt ▁-> ▁side _ data ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁pkt ▁-> ▁side _ data _ elems ▁; ▁i ▁++ ▁) ▁{ ▁DUP _ DATA ▁( ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁data ▁, ▁tmp _ pkt ▁. ▁side _ data ▁[ ▁i ▁] ▁. ▁data ▁, ▁tmp _ pkt ▁. ▁side _ data ▁[ ▁i ▁] ▁. ▁size ▁, ▁1 ▁, ▁ALLOC _ MALLOC ▁) ▁; ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁size ▁= ▁tmp _ pkt ▁. ▁side _ data ▁[ ▁i ▁] ▁. ▁size ▁; ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁type ▁= ▁tmp _ pkt ▁. ▁side _ data ▁[ ▁i ▁] ▁. ▁type ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁failed _ alloc ▁: ▁av _ packet _ unref ▁( ▁pkt ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁}	1
▁static ▁av _ cold ▁void ▁md ct _ end ▁( ▁AC 3 MD CT Context ▁* ▁md ct ▁) ▁{ ▁ff _ fft _ end ▁( ▁& ▁md ct ▁-> ▁fft ▁) ▁; ▁}	0
▁static ▁int ▁ea _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁E a Demux Context ▁* ▁ea ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int ▁ret ▁= ▁0 ▁; ▁int ▁packet _ read ▁= ▁0 ▁; ▁unsigned ▁int ▁chunk _ type ▁, ▁chunk _ size ▁; ▁int ▁key ▁= ▁0 ▁; ▁int ▁av _ uninit ▁( ▁num _ samples ▁) ▁; ▁while ▁( ▁! ▁packet _ read ▁) ▁{ ▁chunk _ type ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁chunk _ size ▁= ▁ea ▁-> ▁big _ endian ▁? ▁avio _ rb 32 ▁( ▁pb ▁) ▁: ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁chunk _ size ▁<= ▁8 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁chunk _ size ▁-= ▁8 ▁; ▁switch ▁( ▁chunk _ type ▁) ▁{ ▁case ▁IS N h _ TAG ▁: ▁if ▁( ▁chunk _ size ▁< ▁32 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avio _ skip ▁( ▁pb ▁, ▁32 ▁) ▁; ▁chunk _ size ▁-= ▁32 ▁; ▁case ▁IS Nd _ TAG ▁: ▁case ▁S CD l _ TAG ▁: ▁case ▁SN DC _ TAG ▁: ▁case ▁SD EN _ TAG ▁: ▁if ▁( ▁! ▁ea ▁-> ▁audio _ codec ▁) ▁{ ▁avio _ skip ▁( ▁pb ▁, ▁chunk _ size ▁) ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁ea ▁-> ▁audio _ codec ▁== ▁CODEC _ ID _ PCM _ S 16 LE _ PLAN AR ▁|| ▁ea ▁-> ▁audio _ codec ▁== ▁CODEC _ ID _ MP 3 ▁) ▁{ ▁num _ samples ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁8 ▁) ▁; ▁chunk _ size ▁-= ▁12 ▁; ▁} ▁ret ▁= ▁av _ get _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁chunk _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁ea ▁-> ▁audio _ stream _ index ▁; ▁switch ▁( ▁ea ▁-> ▁audio _ codec ▁) ▁{ ▁case ▁CODEC _ ID _ AD PCM _ EA ▁: ▁case ▁CODEC _ ID _ AD PCM _ EA _ R 1 ▁: ▁case ▁CODEC _ ID _ AD PCM _ EA _ R 2 ▁: ▁case ▁CODEC _ ID _ AD PCM _ I MA _ EA _ E AC S ▁: ▁pkt ▁-> ▁duration ▁= ▁AV _ RL 32 ▁( ▁pkt ▁-> ▁data ▁) ▁; ▁break ▁; ▁case ▁CODEC _ ID _ AD PCM _ EA _ R 3 ▁: ▁pkt ▁-> ▁duration ▁= ▁AV _ RB 32 ▁( ▁pkt ▁-> ▁data ▁) ▁; ▁break ▁; ▁case ▁CODEC _ ID _ AD PCM _ I MA _ EA _ SE AD ▁: ▁pkt ▁-> ▁duration ▁= ▁ret ▁* ▁2 ▁/ ▁ea ▁-> ▁num _ channels ▁; ▁break ▁; ▁case ▁CODEC _ ID _ PCM _ S 16 LE _ PLAN AR ▁: ▁case ▁CODEC _ ID _ MP 3 ▁: ▁pkt ▁-> ▁duration ▁= ▁num _ samples ▁; ▁break ▁; ▁default ▁: ▁pkt ▁-> ▁duration ▁= ▁chunk _ size ▁/ ▁( ▁ea ▁-> ▁bytes ▁* ▁ea ▁-> ▁num _ channels ▁) ▁; ▁} ▁packet _ read ▁= ▁1 ▁; ▁break ▁; ▁case ▁0 ▁: ▁case ▁IS Ne _ TAG ▁: ▁case ▁SCE l _ TAG ▁: ▁case ▁SEND _ TAG ▁: ▁case ▁SE EN _ TAG ▁: ▁ret ▁= ▁AVERROR ▁( ▁EIO ▁) ▁; ▁packet _ read ▁= ▁1 ▁; ▁break ▁; ▁case ▁M VI h _ TAG ▁: ▁case ▁k V GT _ TAG ▁: ▁case ▁p Q GT _ TAG ▁: ▁case ▁TG Q s _ TAG ▁: ▁case ▁MAD k _ TAG ▁: ▁key ▁= ▁AV _ PKT _ FLAG _ KEY ▁; ▁case ▁MV If _ TAG ▁: ▁case ▁f V GT _ TAG ▁: ▁case ▁MAD m _ TAG ▁: ▁case ▁MA De _ TAG ▁: ▁avio _ seek ▁( ▁pb ▁, ▁-8 ▁, ▁SEEK _ CUR ▁) ▁; ▁chunk _ size ▁+= ▁8 ▁; ▁goto ▁get _ video _ packet ▁; ▁case ▁m TC D _ TAG ▁: ▁avio _ skip ▁( ▁pb ▁, ▁8 ▁) ▁; ▁chunk _ size ▁-= ▁8 ▁; ▁goto ▁get _ video _ packet ▁; ▁case ▁MV 0 K _ TAG ▁: ▁case ▁MP Ch _ TAG ▁: ▁case ▁p IQ T _ TAG ▁: ▁key ▁= ▁AV _ PKT _ FLAG _ KEY ▁; ▁case ▁MV 0 F _ TAG ▁: ▁get _ video _ packet ▁: ▁ret ▁= ▁av _ get _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁chunk _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁ea ▁-> ▁video _ stream _ index ▁; ▁pkt ▁-> ▁flags ▁|= ▁key ▁; ▁packet _ read ▁= ▁1 ▁; ▁break ▁; ▁default ▁: ▁avio _ skip ▁( ▁pb ▁, ▁chunk _ size ▁) ▁; ▁break ▁; ▁} ▁} ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁compute _ default _ cl ut ▁( ▁AV Subtitle Rect ▁* ▁rect ▁, ▁int ▁w ▁, ▁int ▁h ▁) ▁{ ▁uint 8_ t ▁list ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁uint 8_ t ▁list _ inv ▁[ ▁256 ▁] ▁; ▁int ▁count tab ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁count ▁, ▁i ▁, ▁x ▁, ▁y ▁; ▁# define ▁V ▁( ▁x ▁, ▁y ▁) ▁rect -> data [0 ][ ( x )+ ( y )* rect -> lines ize [0] ] ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁h ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁w ▁; ▁x ▁++ ▁) ▁{ ▁int ▁v ▁= ▁V ▁( ▁x ▁, ▁y ▁) ▁+ ▁1 ▁; ▁int ▁vl ▁= ▁x ▁? ▁V ▁( ▁x ▁- ▁1 ▁, ▁y ▁) ▁+ ▁1 ▁: ▁0 ▁; ▁int ▁vr ▁= ▁x ▁+ ▁1 ▁< ▁w ▁? ▁V ▁( ▁x ▁+ ▁1 ▁, ▁y ▁) ▁+ ▁1 ▁: ▁0 ▁; ▁int ▁vt ▁= ▁y ▁? ▁V ▁( ▁x ▁, ▁y ▁- ▁1 ▁) ▁+ ▁1 ▁: ▁0 ▁; ▁int ▁vb ▁= ▁y ▁+ ▁1 ▁< ▁h ▁? ▁V ▁( ▁x ▁, ▁y ▁+ ▁1 ▁) ▁+ ▁1 ▁: ▁0 ▁; ▁count tab ▁[ ▁v ▁- ▁1 ▁] ▁+= ▁! ▁! ▁( ▁( ▁v ▁!= ▁vl ▁) ▁+ ▁( ▁v ▁!= ▁vr ▁) ▁+ ▁( ▁v ▁!= ▁vt ▁) ▁+ ▁( ▁v ▁!= ▁vb ▁) ▁) ▁; ▁} ▁} ▁# define ▁L ▁( ▁x ▁, ▁y ▁) ▁list [ rect -> data [0 ][ ( x )+ ( y )* rect -> lines ize [0] ]] ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁sco ret ab ▁[ ▁256 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁best score ▁= ▁0 ▁; ▁int ▁best v ▁= ▁0 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁h ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁w ▁; ▁x ▁++ ▁) ▁{ ▁int ▁v ▁= ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁x ▁+ ▁y ▁* ▁rect ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁; ▁int ▁l _ m ▁= ▁list ▁[ ▁v ▁] ▁; ▁int ▁l _ l ▁= ▁x ▁? ▁L ▁( ▁x ▁- ▁1 ▁, ▁y ▁) ▁: ▁1 ▁; ▁int ▁l _ r ▁= ▁x ▁+ ▁1 ▁< ▁w ▁? ▁L ▁( ▁x ▁+ ▁1 ▁, ▁y ▁) ▁: ▁1 ▁; ▁int ▁l _ t ▁= ▁y ▁? ▁L ▁( ▁x ▁, ▁y ▁- ▁1 ▁) ▁: ▁1 ▁; ▁int ▁l _ b ▁= ▁y ▁+ ▁1 ▁< ▁h ▁? ▁L ▁( ▁x ▁, ▁y ▁+ ▁1 ▁) ▁: ▁1 ▁; ▁int ▁score ▁; ▁if ▁( ▁l _ m ▁) ▁continue ▁; ▁sco ret ab ▁[ ▁v ▁] ▁+= ▁l _ l ▁+ ▁l _ r ▁+ ▁l _ t ▁+ ▁l _ b ▁; ▁score ▁= ▁1024 LL ▁* ▁sco ret ab ▁[ ▁v ▁] ▁/ ▁count tab ▁[ ▁v ▁] ▁; ▁if ▁( ▁score ▁> ▁best score ▁) ▁{ ▁best score ▁= ▁score ▁; ▁best v ▁= ▁v ▁; ▁} ▁} ▁} ▁if ▁( ▁! ▁best score ▁) ▁break ▁; ▁list ▁[ ▁best v ▁] ▁= ▁1 ▁; ▁list _ inv ▁[ ▁i ▁] ▁= ▁best v ▁; ▁} ▁count ▁= ▁FF MAX ▁( ▁i ▁- ▁1 ▁, ▁1 ▁) ▁; ▁for ▁( ▁i ▁-- ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁int ▁v ▁= ▁i ▁* ▁255 ▁/ ▁count ▁; ▁AV _ WN 32 ▁( ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁4 ▁* ▁list _ inv ▁[ ▁i ▁] ▁, ▁RGBA ▁( ▁v ▁/ ▁2 ▁, ▁v ▁, ▁v ▁/ ▁2 ▁, ▁v ▁) ▁) ▁; ▁} ▁}	1
▁static ▁int ▁decode _ header ▁( ▁P SD Context ▁* ▁s ▁) ▁{ ▁int ▁signature ▁, ▁version ▁, ▁color _ mode ▁, ▁compression ▁; ▁int 64_ t ▁len _ section ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁30 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Head ert oo short top arse .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁signature ▁= ▁bytestream 2_ get _ le 32 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁signature ▁!= ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Wrong signature % d .\ n " ▁, ▁signature ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁version ▁= ▁bytestream 2_ get _ be 16 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁version ▁!= ▁1 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Wrong version % d .\ n " ▁, ▁version ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁gb ▁, ▁6 ▁) ▁; ▁s ▁-> ▁channel _ count ▁= ▁bytestream 2_ get _ be 16 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁( ▁s ▁-> ▁channel _ count ▁< ▁1 ▁) ▁|| ▁( ▁s ▁-> ▁channel _ count ▁> ▁56 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid channel count % d .\ n " ▁, ▁s ▁-> ▁channel _ count ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁height ▁= ▁bytestream 2_ get _ be 32 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁( ▁s ▁-> ▁height ▁> ▁30000 ▁) ▁&& ▁( ▁s ▁-> ▁avctx ▁-> ▁strict _ std _ comp liance ▁> ▁FF _ COM PL IANCE _ EX PER IMENTAL ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Height > 3 0000 ise x perimental , add " ▁"' - strict % d ' ify ou want to try t ode code the picture .\ n " ▁, ▁FF _ COM PL IANCE _ EX PER IMENTAL ▁) ▁; ▁return ▁AVERROR _ EX PER IMENTAL ▁; ▁} ▁s ▁-> ▁width ▁= ▁bytestream 2_ get _ be 32 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁( ▁s ▁-> ▁width ▁> ▁30000 ▁) ▁&& ▁( ▁s ▁-> ▁avctx ▁-> ▁strict _ std _ comp liance ▁> ▁FF _ COM PL IANCE _ EX PER IMENTAL ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Width > 3 0000 ise x perimental , add " ▁"' - strict % d ' ify ou want to try t ode code the picture .\ n " ▁, ▁FF _ COM PL IANCE _ EX PER IMENTAL ▁) ▁; ▁return ▁AVERROR _ EX PER IMENTAL ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁ff _ set _ dimensions ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁width ▁, ▁s ▁-> ▁height ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁s ▁-> ▁channel _ depth ▁= ▁bytestream 2_ get _ be 16 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁color _ mode ▁= ▁bytestream 2_ get _ be 16 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁switch ▁( ▁color _ mode ▁) ▁{ ▁case ▁0 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ BITMAP ▁; ▁break ▁; ▁case ▁1 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ GRAY SCALE ▁; ▁break ▁; ▁case ▁2 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ INDEX ED ▁; ▁break ▁; ▁case ▁3 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ RGB ▁; ▁break ▁; ▁case ▁4 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ CM Y K ▁; ▁break ▁; ▁case ▁7 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ MULTI CHANNEL ▁; ▁break ▁; ▁case ▁8 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ DU OT ONE ▁; ▁break ▁; ▁case ▁9 ▁: ▁s ▁-> ▁color _ mode ▁= ▁P SD _ L AB ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown col orm ode % d .\ n " ▁, ▁color _ mode ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁len _ section ▁= ▁bytestream 2_ get _ be 32 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁len _ section ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Neg atives ize for col ormap data section .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁( ▁len _ section ▁+ ▁4 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Incomplete file .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁gb ▁, ▁len _ section ▁) ▁; ▁len _ section ▁= ▁bytestream 2_ get _ be 32 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁len _ section ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Neg atives ize for im ager ess ource s section .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁( ▁len _ section ▁+ ▁4 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Incomplete file .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁gb ▁, ▁len _ section ▁) ▁; ▁len _ section ▁= ▁bytestream 2_ get _ be 32 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁len _ section ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Neg atives ize for layers and masks data section .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁len _ section ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Incomplete file .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁gb ▁, ▁len _ section ▁) ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁2 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" File without im aged ata section .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁compression ▁= ▁bytestream 2_ get _ be 16 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁switch ▁( ▁s ▁-> ▁compression ▁) ▁{ ▁case ▁0 ▁: ▁case ▁1 ▁: ▁break ▁; ▁case ▁2 ▁: ▁avpriv _ request _ sample ▁( ▁s ▁-> ▁avctx ▁, ▁" ZIP without predict or compression " ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁break ▁; ▁case ▁3 ▁: ▁avpriv _ request _ sample ▁( ▁s ▁-> ▁avctx ▁, ▁" ZIP with predict or compression " ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown compression % d .\ n " ▁, ▁compression ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁mov _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁MOV Context ▁* ▁mov ▁= ▁s ▁-> ▁priv _ data ▁; ▁MOV Stream Context ▁* ▁sc ▁; ▁AV Index Entry ▁* ▁sample ▁; ▁AVStream ▁* ▁st ▁= ▁NULL ▁; ▁int ▁ret ▁; ▁mov ▁-> ▁fc ▁= ▁s ▁; ▁retry ▁: ▁sample ▁= ▁mov _ find _ next _ sample ▁( ▁s ▁, ▁& ▁st ▁) ▁; ▁if ▁( ▁! ▁sample ▁) ▁{ ▁mov ▁-> ▁found _ md at ▁= ▁0 ▁; ▁if ▁( ▁! ▁mov ▁-> ▁next _ root _ atom ▁) ▁return ▁AVERROR _ EOF ▁; ▁if ▁( ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁mov ▁-> ▁next _ root _ atom ▁, ▁SEEK _ SET ▁) ▁!= ▁mov ▁-> ▁next _ root _ atom ▁) ▁{ ▁av _ log ▁( ▁mov ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" next root atom offset 0 x %" ▁PRIx 64 ▁": partial file \ n " ▁, ▁mov ▁-> ▁next _ root _ atom ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁mov ▁-> ▁next _ root _ atom ▁= ▁0 ▁; ▁if ▁( ▁mov _ read _ default ▁( ▁mov ▁, ▁s ▁-> ▁pb ▁, ▁( ▁MOV Atom ▁) ▁{ ▁AV _ RL 32 ▁( ▁" root " ▁) ▁, ▁INT 64_ MAX ▁} ▁) ▁< ▁0 ▁|| ▁avio _ fe of ▁( ▁s ▁-> ▁pb ▁) ▁) ▁return ▁AVERROR _ EOF ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ TRACE ▁, ▁" read frag ments , offset 0 x %" ▁PRIx 64 ▁"\ n " ▁, ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁) ▁; ▁goto ▁retry ▁; ▁} ▁sc ▁= ▁st ▁-> ▁priv _ data ▁; ▁sc ▁-> ▁current _ sample ▁++ ▁; ▁if ▁( ▁mov ▁-> ▁next _ root _ atom ▁) ▁{ ▁sample ▁-> ▁pos ▁= ▁FF MIN ▁( ▁sample ▁-> ▁pos ▁, ▁mov ▁-> ▁next _ root _ atom ▁) ▁; ▁sample ▁-> ▁size ▁= ▁FF MIN ▁( ▁sample ▁-> ▁size ▁, ▁( ▁mov ▁-> ▁next _ root _ atom ▁- ▁sample ▁-> ▁pos ▁) ▁) ▁; ▁} ▁if ▁( ▁st ▁-> ▁discard ▁!= ▁AV DISCARD _ ALL ▁) ▁{ ▁int 64_ t ▁ret 64 ▁= ▁avio _ seek ▁( ▁sc ▁-> ▁pb ▁, ▁sample ▁-> ▁pos ▁, ▁SEEK _ SET ▁) ▁; ▁if ▁( ▁ret 64 ▁!= ▁sample ▁-> ▁pos ▁) ▁{ ▁av _ log ▁( ▁mov ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" stream % d , offset 0 x %" ▁PRIx 64 ▁": partial file \ n " ▁, ▁sc ▁-> ▁ff index ▁, ▁sample ▁-> ▁pos ▁) ▁; ▁sc ▁-> ▁current _ sample ▁-= ▁should _ retry ▁( ▁sc ▁-> ▁pb ▁, ▁ret 64 ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ret ▁= ▁av _ get _ packet ▁( ▁sc ▁-> ▁pb ▁, ▁pkt ▁, ▁sample ▁-> ▁size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁sc ▁-> ▁current _ sample ▁-= ▁should _ retry ▁( ▁sc ▁-> ▁pb ▁, ▁ret ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁sc ▁-> ▁has _ palette ▁) ▁{ ▁uint 8_ t ▁* ▁pal ▁; ▁pal ▁= ▁av _ packet _ new _ side _ data ▁( ▁pkt ▁, ▁AV _ PKT _ DATA _ PALETTE ▁, ▁AV PALETTE _ SIZE ▁) ▁; ▁if ▁( ▁! ▁pal ▁) ▁{ ▁av _ log ▁( ▁mov ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cannot append pa let t et op acket \ n " ▁) ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁pal ▁, ▁sc ▁-> ▁palette ▁, ▁AV PALETTE _ SIZE ▁) ▁; ▁sc ▁-> ▁has _ palette ▁= ▁0 ▁; ▁} ▁} ▁# if ▁CONFIG _ DV _ DE MUX ER ▁if ▁( ▁mov ▁-> ▁dv _ demux ▁&& ▁sc ▁-> ▁dv _ audio _ container ▁) ▁{ ▁avpriv _ dv _ produce _ packet ▁( ▁mov ▁-> ▁dv _ demux ▁, ▁pkt ▁, ▁pkt ▁-> ▁data ▁, ▁pkt ▁-> ▁size ▁, ▁pkt ▁-> ▁pos ▁) ▁; ▁av _ freep ▁( ▁& ▁pkt ▁-> ▁data ▁) ▁; ▁pkt ▁-> ▁size ▁= ▁0 ▁; ▁ret ▁= ▁avpriv _ dv _ get _ packet ▁( ▁mov ▁-> ▁dv _ demux ▁, ▁pkt ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁# endif ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁sc ▁-> ▁ff index ▁; ▁pkt ▁-> ▁dts ▁= ▁sample ▁-> ▁timestamp ▁; ▁if ▁( ▁sc ▁-> ▁c tt s _ data ▁&& ▁sc ▁-> ▁c tt s _ index ▁< ▁sc ▁-> ▁c tt s _ count ▁) ▁{ ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁dts ▁+ ▁sc ▁-> ▁dts _ shift ▁+ ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ index ▁] ▁. ▁duration ▁; ▁sc ▁-> ▁c tt s _ sample ▁++ ▁; ▁if ▁( ▁sc ▁-> ▁c tt s _ index ▁< ▁sc ▁-> ▁c tt s _ count ▁&& ▁sc ▁-> ▁c tt s _ data ▁[ ▁sc ▁-> ▁c tt s _ index ▁] ▁. ▁count ▁== ▁sc ▁-> ▁c tt s _ sample ▁) ▁{ ▁sc ▁-> ▁c tt s _ index ▁++ ▁; ▁sc ▁-> ▁c tt s _ sample ▁= ▁0 ▁; ▁} ▁if ▁( ▁sc ▁-> ▁wrong _ dts ▁) ▁pkt ▁-> ▁dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁else ▁{ ▁int 64_ t ▁next _ dts ▁= ▁( ▁sc ▁-> ▁current _ sample ▁< ▁st ▁-> ▁nb _ index _ entries ▁) ▁? ▁st ▁-> ▁index _ entries ▁[ ▁sc ▁-> ▁current _ sample ▁] ▁. ▁timestamp ▁: ▁st ▁-> ▁duration ▁; ▁pkt ▁-> ▁duration ▁= ▁next _ dts ▁- ▁pkt ▁-> ▁dts ▁; ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁dts ▁; ▁} ▁if ▁( ▁st ▁-> ▁discard ▁== ▁AV DISCARD _ ALL ▁) ▁goto ▁retry ▁; ▁pkt ▁-> ▁flags ▁|= ▁sample ▁-> ▁flags ▁& ▁AV INDEX _ KEY FRAME ▁? ▁AV _ PKT _ FLAG _ KEY ▁: ▁0 ▁; ▁pkt ▁-> ▁pos ▁= ▁sample ▁-> ▁pos ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁inline ▁void ▁block _ copy ▁( ▁unsigned ▁char ▁* ▁out ▁, ▁unsigned ▁char ▁* ▁in ▁, ▁int ▁out stride ▁, ▁int ▁inst ride ▁, ▁int ▁sz ▁) ▁{ ▁int ▁rows ▁= ▁sz ▁; ▁while ▁( ▁rows ▁-- ▁) ▁{ ▁memcpy ▁( ▁out ▁, ▁in ▁, ▁sz ▁) ▁; ▁out ▁+= ▁out stride ▁; ▁in ▁+= ▁inst ride ▁; ▁} ▁}	1
▁static ▁inline ▁unsigned ▁int ▁constant _ time _ lt ▁( ▁unsigned ▁int ▁a ▁, ▁unsigned ▁int ▁b ▁) ▁{ ▁return ▁constant _ time _ msb ▁( ▁a ▁ ^ ▁( ▁( ▁a ▁ ^ ▁b ▁) ▁| ▁( ▁( ▁a ▁- ▁b ▁) ▁ ^ ▁b ▁) ▁) ▁) ▁; ▁}	1
▁static ▁int ▁gif _ read _ packet ▁( ▁AVFormatContext ▁* ▁s 1 ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁Gif State ▁* ▁s ▁= ▁s 1 ▁-> ▁priv _ data ▁; ▁int ▁ret ▁; ▁ret ▁= ▁gif _ parse _ next _ image ▁( ▁s ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁s ▁-> ▁screen _ width ▁* ▁s ▁-> ▁screen _ height ▁* ▁3 ▁) ▁) ▁{ ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁s ▁-> ▁image _ buf ▁, ▁s ▁-> ▁screen _ width ▁* ▁s ▁-> ▁screen _ height ▁* ▁3 ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁cd xl _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁CDXL Video Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁const ▁p ▁= ▁& ▁c ▁-> ▁frame ▁; ▁int ▁ret ▁, ▁w ▁, ▁h ▁, ▁encoding ▁, ▁format ▁, ▁buf _ size ▁= ▁pkt ▁-> ▁size ▁; ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁pkt ▁-> ▁data ▁; ▁if ▁( ▁buf _ size ▁< ▁32 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁encoding ▁= ▁buf ▁[ ▁1 ▁] ▁& ▁7 ▁; ▁format ▁= ▁buf ▁[ ▁1 ▁] ▁& ▁0 xE 0 ▁; ▁w ▁= ▁AV _ RB 16 ▁( ▁& ▁buf ▁[ ▁14 ▁] ▁) ▁; ▁h ▁= ▁AV _ RB 16 ▁( ▁& ▁buf ▁[ ▁16 ▁] ▁) ▁; ▁c ▁-> ▁bpp ▁= ▁buf ▁[ ▁19 ▁] ▁; ▁c ▁-> ▁palette _ size ▁= ▁AV _ RB 16 ▁( ▁& ▁buf ▁[ ▁20 ▁] ▁) ▁; ▁c ▁-> ▁palette ▁= ▁buf ▁+ ▁32 ▁; ▁c ▁-> ▁video ▁= ▁c ▁-> ▁palette ▁+ ▁c ▁-> ▁palette _ size ▁; ▁c ▁-> ▁video _ size ▁= ▁buf _ size ▁- ▁c ▁-> ▁palette _ size ▁- ▁32 ▁; ▁if ▁( ▁c ▁-> ▁palette _ size ▁> ▁512 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁buf _ size ▁< ▁c ▁-> ▁palette _ size ▁+ ▁32 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁c ▁-> ▁bpp ▁< ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁format ▁) ▁{ ▁av _ log _ ask _ for _ sample ▁( ▁avctx ▁, ▁" unsupported pixel format :% d \ n " ▁, ▁format ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ check _ size ▁( ▁w ▁, ▁h ▁, ▁0 ▁, ▁avctx ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁w ▁!= ▁avctx ▁-> ▁width ▁|| ▁h ▁!= ▁avctx ▁-> ▁height ▁) ▁avcodec _ set _ dimensions ▁( ▁avctx ▁, ▁w ▁, ▁h ▁) ▁; ▁if ▁( ▁c ▁-> ▁video _ size ▁< ▁FF ALIGN ▁( ▁avctx ▁-> ▁width ▁, ▁16 ▁) ▁* ▁avctx ▁-> ▁height ▁* ▁c ▁-> ▁bpp ▁/ ▁8 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁! ▁encoding ▁&& ▁c ▁-> ▁palette _ size ▁&& ▁c ▁-> ▁bpp ▁<= ▁8 ▁) ▁{ ▁avctx ▁-> ▁pix _ fmt ▁= ▁PIX _ FMT _ PAL 8 ▁; ▁} ▁else ▁if ▁( ▁encoding ▁== ▁1 ▁&& ▁( ▁c ▁-> ▁bpp ▁== ▁6 ▁|| ▁c ▁-> ▁bpp ▁== ▁8 ▁) ▁) ▁{ ▁if ▁( ▁c ▁-> ▁palette _ size ▁!= ▁( ▁1 ▁<< ▁( ▁c ▁-> ▁bpp ▁- ▁1 ▁) ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avctx ▁-> ▁pix _ fmt ▁= ▁PIX _ FMT _ BGR 24 ▁; ▁} ▁else ▁{ ▁av _ log _ ask _ for _ sample ▁( ▁avctx ▁, ▁" unsupported encoding % d and bpp % d \ n " ▁, ▁encoding ▁, ▁c ▁-> ▁bpp ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁p ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁; ▁p ▁-> ▁reference ▁= ▁0 ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁if ▁( ▁encoding ▁) ▁{ ▁av _ fast _ pad ded _ malloc ▁( ▁& ▁c ▁-> ▁new _ video ▁, ▁& ▁c ▁-> ▁new _ video _ size ▁, ▁h ▁* ▁w ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁new _ video ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁c ▁-> ▁bpp ▁== ▁8 ▁) ▁cd xl _ decode _ ham 8 ▁( ▁c ▁) ▁; ▁else ▁cd xl _ decode _ ham 6 ▁( ▁c ▁) ▁; ▁} ▁else ▁{ ▁cd xl _ decode _ rgb ▁( ▁c ▁) ▁; ▁} ▁* ▁data _ size ▁= ▁sizeof ▁( ▁AVFrame ▁) ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁c ▁-> ▁frame ▁; ▁return ▁buf _ size ▁; ▁}	0
▁static ▁int ▁old _ codec 47 ▁( ▁SAN M Video Context ▁* ▁ctx ▁, ▁int ▁top ▁, ▁int ▁left ▁, ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁seq ▁, ▁compr ▁, ▁new _ rot ▁, ▁tbl _ pos ▁, ▁skip ▁; ▁int ▁stride ▁= ▁ctx ▁-> ▁pitch ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁( ▁( ▁uint 8_ t ▁* ▁) ▁ctx ▁-> ▁frm 0 ▁) ▁+ ▁left ▁+ ▁top ▁* ▁stride ▁; ▁uint 8_ t ▁* ▁prev 1 ▁= ▁( ▁uint 8_ t ▁* ▁) ▁ctx ▁-> ▁frm 1 ▁; ▁uint 8_ t ▁* ▁prev 2 ▁= ▁( ▁uint 8_ t ▁* ▁) ▁ctx ▁-> ▁frm 2 ▁; ▁uint 32_ t ▁decoded _ size ▁; ▁tbl _ pos ▁= ▁bytestream 2_ tell ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁seq ▁= ▁bytestream 2_ get _ le 16 ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁compr ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁new _ rot ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁skip ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁bytestream 2_ skip ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁9 ▁) ▁; ▁decoded _ size ▁= ▁bytestream 2_ get _ le 32 ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁bytestream 2_ skip ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁if ▁( ▁decoded _ size ▁> ▁ctx ▁-> ▁height ▁* ▁stride ▁- ▁left ▁- ▁top ▁* ▁stride ▁) ▁{ ▁decoded _ size ▁= ▁ctx ▁-> ▁height ▁* ▁stride ▁- ▁left ▁- ▁top ▁* ▁stride ▁; ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" decoded size ist ool arge \ n " ▁) ▁; ▁} ▁if ▁( ▁skip ▁& ▁1 ▁) ▁bytestream 2_ skip ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁0 x 8080 ▁) ▁; ▁if ▁( ▁! ▁seq ▁) ▁{ ▁ctx ▁-> ▁prev _ seq ▁= ▁-1 ▁; ▁memset ▁( ▁prev 1 ▁, ▁0 ▁, ▁ctx ▁-> ▁height ▁* ▁stride ▁) ▁; ▁memset ▁( ▁prev 2 ▁, ▁0 ▁, ▁ctx ▁-> ▁height ▁* ▁stride ▁) ▁; ▁} ▁av _ d log ▁( ▁ctx ▁-> ▁avctx ▁, ▁" compression % d \ n " ▁, ▁compr ▁) ▁; ▁switch ▁( ▁compr ▁) ▁{ ▁case ▁0 ▁: ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁width ▁* ▁height ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁height ▁; ▁j ▁++ ▁) ▁{ ▁bytestream 2_ get _ buffer u ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁dst ▁, ▁width ▁) ▁; ▁dst ▁+= ▁stride ▁; ▁} ▁break ▁; ▁case ▁1 ▁: ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁( ▁( ▁width ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁* ▁( ▁( ▁height ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁height ▁; ▁j ▁+= ▁2 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁dst ▁[ ▁i ▁] ▁= ▁dst ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁dst ▁[ ▁stride ▁+ ▁i ▁] ▁= ▁dst ▁[ ▁stride ▁+ ▁i ▁+ ▁1 ▁] ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁} ▁dst ▁+= ▁stride ▁* ▁2 ▁; ▁} ▁break ▁; ▁case ▁2 ▁: ▁if ▁( ▁seq ▁== ▁ctx ▁-> ▁prev _ seq ▁+ ▁1 ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁height ▁; ▁j ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁; ▁i ▁+= ▁8 ▁) ▁{ ▁if ▁( ▁process _ block ▁( ▁ctx ▁, ▁dst ▁+ ▁i ▁, ▁prev 1 ▁+ ▁i ▁, ▁prev 2 ▁+ ▁i ▁, ▁stride ▁, ▁tbl _ pos ▁+ ▁8 ▁, ▁8 ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁dst ▁+= ▁stride ▁* ▁8 ▁; ▁prev 1 ▁+= ▁stride ▁* ▁8 ▁; ▁prev 2 ▁+= ▁stride ▁* ▁8 ▁; ▁} ▁} ▁break ▁; ▁case ▁3 ▁: ▁memcpy ▁( ▁ctx ▁-> ▁frm 0 ▁, ▁ctx ▁-> ▁frm 2 ▁, ▁ctx ▁-> ▁pitch ▁* ▁ctx ▁-> ▁height ▁) ▁; ▁break ▁; ▁case ▁4 ▁: ▁memcpy ▁( ▁ctx ▁-> ▁frm 0 ▁, ▁ctx ▁-> ▁frm 1 ▁, ▁ctx ▁-> ▁pitch ▁* ▁ctx ▁-> ▁height ▁) ▁; ▁break ▁; ▁case ▁5 ▁: ▁if ▁( ▁r le _ decode ▁( ▁ctx ▁, ▁dst ▁, ▁decoded _ size ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" sub codec 47 compression % d not implemented \ n " ▁, ▁compr ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁seq ▁== ▁ctx ▁-> ▁prev _ seq ▁+ ▁1 ▁) ▁ctx ▁-> ▁rotate _ code ▁= ▁new _ rot ▁; ▁else ▁ctx ▁-> ▁rotate _ code ▁= ▁0 ▁; ▁ctx ▁-> ▁prev _ seq ▁= ▁seq ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁dt ls 1_ process _ heartbeat ▁( ▁SSL ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁p ▁, ▁unsigned ▁int ▁length ▁) ▁{ ▁unsigned ▁char ▁* ▁pl ▁; ▁unsigned ▁short ▁hb type ▁; ▁unsigned ▁int ▁payload ▁; ▁unsigned ▁int ▁padding ▁= ▁16 ▁; ▁if ▁( ▁s ▁-> ▁msg _ callback ▁) ▁s ▁-> ▁msg _ callback ▁( ▁0 ▁, ▁s ▁-> ▁version ▁, ▁TLS 1_ RT _ HE ARTBEAT ▁, ▁p ▁, ▁length ▁, ▁s ▁, ▁s ▁-> ▁msg _ callback _ arg ▁) ▁; ▁if ▁( ▁1 ▁+ ▁2 ▁+ ▁16 ▁> ▁length ▁) ▁return ▁0 ▁; ▁if ▁( ▁length ▁> ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁) ▁return ▁0 ▁; ▁hb type ▁= ▁* ▁p ▁++ ▁; ▁n 2 s ▁( ▁p ▁, ▁payload ▁) ▁; ▁if ▁( ▁1 ▁+ ▁2 ▁+ ▁payload ▁+ ▁16 ▁> ▁length ▁) ▁return ▁0 ▁; ▁pl ▁= ▁p ▁; ▁if ▁( ▁hb type ▁== ▁TLS 1_ HB _ REQUEST ▁) ▁{ ▁unsigned ▁char ▁* ▁buffer ▁, ▁* ▁bp ▁; ▁unsigned ▁int ▁write _ length ▁= ▁1 ▁+ ▁2 ▁+ ▁payload ▁+ ▁padding ▁; ▁int ▁r ▁; ▁if ▁( ▁write _ length ▁> ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁) ▁return ▁0 ▁; ▁buffer ▁= ▁OPENSSL _ malloc ▁( ▁write _ length ▁) ▁; ▁if ▁( ▁buffer ▁== ▁NULL ▁) ▁return ▁-1 ▁; ▁bp ▁= ▁buffer ▁; ▁* ▁bp ▁++ ▁= ▁TLS 1_ HB _ RESPONSE ▁; ▁s 2 n ▁( ▁payload ▁, ▁bp ▁) ▁; ▁memcpy ▁( ▁bp ▁, ▁pl ▁, ▁payload ▁) ▁; ▁bp ▁+= ▁payload ▁; ▁if ▁( ▁RAND _ bytes ▁( ▁bp ▁, ▁padding ▁) ▁<= ▁0 ▁) ▁{ ▁OPENSSL _ free ▁( ▁buffer ▁) ▁; ▁return ▁-1 ▁; ▁} ▁r ▁= ▁dt ls 1_ write _ bytes ▁( ▁s ▁, ▁TLS 1_ RT _ HE ARTBEAT ▁, ▁buffer ▁, ▁write _ length ▁) ▁; ▁if ▁( ▁r ▁>= ▁0 ▁&& ▁s ▁-> ▁msg _ callback ▁) ▁s ▁-> ▁msg _ callback ▁( ▁1 ▁, ▁s ▁-> ▁version ▁, ▁TLS 1_ RT _ HE ARTBEAT ▁, ▁buffer ▁, ▁write _ length ▁, ▁s ▁, ▁s ▁-> ▁msg _ callback _ arg ▁) ▁; ▁OPENSSL _ free ▁( ▁buffer ▁) ▁; ▁if ▁( ▁r ▁< ▁0 ▁) ▁return ▁r ▁; ▁} ▁else ▁if ▁( ▁hb type ▁== ▁TLS 1_ HB _ RESPONSE ▁) ▁{ ▁unsigned ▁int ▁seq ▁; ▁n 2 s ▁( ▁pl ▁, ▁seq ▁) ▁; ▁if ▁( ▁payload ▁== ▁18 ▁&& ▁seq ▁== ▁s ▁-> ▁tl se xt _ hb _ seq ▁) ▁{ ▁dt ls 1_ stop _ timer ▁( ▁s ▁) ▁; ▁s ▁-> ▁tl se xt _ hb _ seq ▁++ ▁; ▁s ▁-> ▁tl se xt _ hb _ pending ▁= ▁0 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁filter _ frame ▁( ▁AVFilter Link ▁* ▁inlink ▁, ▁AVFilter Buffer Ref ▁* ▁pic ref ▁) ▁{ ▁AVFilter Context ▁* ▁ctx ▁= ▁inlink ▁-> ▁dst ▁; ▁Tile Context ▁* ▁tile ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFilter Link ▁* ▁out link ▁= ▁ctx ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁unsigned ▁x 0 ▁, ▁y 0 ▁; ▁if ▁( ▁! ▁tile ▁-> ▁current ▁) ▁{ ▁out link ▁-> ▁out _ buf ▁= ▁ff _ get _ video _ buffer ▁( ▁out link ▁, ▁AV _ PERM _ WRITE ▁, ▁out link ▁-> ▁w ▁, ▁out link ▁-> ▁h ▁) ▁; ▁if ▁( ▁! ▁out link ▁-> ▁out _ buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁avfilter _ copy _ buffer _ ref _ props ▁( ▁out link ▁-> ▁out _ buf ▁, ▁pic ref ▁) ▁; ▁out link ▁-> ▁out _ buf ▁-> ▁video ▁-> ▁w ▁= ▁out link ▁-> ▁w ▁; ▁out link ▁-> ▁out _ buf ▁-> ▁video ▁-> ▁h ▁= ▁out link ▁-> ▁h ▁; ▁if ▁( ▁tile ▁-> ▁margin ▁|| ▁tile ▁-> ▁padding ▁) ▁ff _ fill _ rectangle ▁( ▁& ▁tile ▁-> ▁draw ▁, ▁& ▁tile ▁-> ▁blank ▁, ▁out link ▁-> ▁out _ buf ▁-> ▁data ▁, ▁out link ▁-> ▁out _ buf ▁-> ▁linesize ▁, ▁0 ▁, ▁0 ▁, ▁out link ▁-> ▁w ▁, ▁out link ▁-> ▁h ▁) ▁; ▁} ▁get _ current _ tile _ pos ▁( ▁ctx ▁, ▁& ▁x 0 ▁, ▁& ▁y 0 ▁) ▁; ▁ff _ copy _ rectangle 2 ▁( ▁& ▁tile ▁-> ▁draw ▁, ▁out link ▁-> ▁out _ buf ▁-> ▁data ▁, ▁out link ▁-> ▁out _ buf ▁-> ▁linesize ▁, ▁inlink ▁-> ▁cur _ buf ▁-> ▁data ▁, ▁inlink ▁-> ▁cur _ buf ▁-> ▁linesize ▁, ▁x 0 ▁, ▁y 0 ▁, ▁0 ▁, ▁0 ▁, ▁inlink ▁-> ▁w ▁, ▁inlink ▁-> ▁h ▁) ▁; ▁avfilter _ unref _ buffer p ▁( ▁& ▁inlink ▁-> ▁cur _ buf ▁) ▁; ▁if ▁( ▁++ ▁tile ▁-> ▁current ▁== ▁tile ▁-> ▁nb _ frames ▁) ▁end _ last _ frame ▁( ▁ctx ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁tg v _ decode _ inter ▁( ▁T gv Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁const ▁uint 8_ t ▁* ▁buf _ end ▁) ▁{ ▁unsigned ▁char ▁* ▁frame 0_ end ▁= ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁+ ▁s ▁-> ▁avctx ▁-> ▁height ▁* ▁s ▁-> ▁last _ frame ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁int ▁num _ m vs ▁; ▁int ▁num _ blocks _ raw ▁; ▁int ▁num _ blocks _ packed ▁; ▁int ▁vector _ bits ▁; ▁int ▁i ▁, ▁j ▁, ▁x ▁, ▁y ▁; ▁Get Bit Context ▁gb ▁; ▁int ▁mv bits ▁; ▁const ▁unsigned ▁char ▁* ▁blocks _ raw ▁; ▁if ▁( ▁buf ▁+ ▁12 ▁> ▁buf _ end ▁) ▁return ▁-1 ▁; ▁num _ m vs ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁0 ▁] ▁) ▁; ▁num _ blocks _ raw ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁2 ▁] ▁) ▁; ▁num _ blocks _ packed ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁4 ▁] ▁) ▁; ▁vector _ bits ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁6 ▁] ▁) ▁; ▁buf ▁+= ▁12 ▁; ▁if ▁( ▁num _ m vs ▁> ▁s ▁-> ▁num _ m vs ▁) ▁{ ▁s ▁-> ▁mv _ code book ▁= ▁av _ realloc ▁( ▁s ▁-> ▁mv _ code book ▁, ▁num _ m vs ▁* ▁2 ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁s ▁-> ▁num _ m vs ▁= ▁num _ m vs ▁; ▁} ▁if ▁( ▁num _ blocks _ packed ▁> ▁s ▁-> ▁num _ blocks _ packed ▁) ▁{ ▁s ▁-> ▁block _ code book ▁= ▁av _ realloc ▁( ▁s ▁-> ▁block _ code book ▁, ▁num _ blocks _ packed ▁* ▁16 ▁* ▁sizeof ▁( ▁unsigned ▁char ▁) ▁) ▁; ▁s ▁-> ▁num _ blocks _ packed ▁= ▁num _ blocks _ packed ▁; ▁} ▁mv bits ▁= ▁( ▁num _ m vs ▁* ▁2 ▁* ▁10 ▁+ ▁31 ▁) ▁& ▁ ~ ▁31 ▁; ▁if ▁( ▁buf ▁+ ▁( ▁mv bits ▁>> ▁3 ▁) ▁+ ▁16 ▁* ▁num _ blocks _ raw ▁+ ▁8 ▁* ▁num _ blocks _ packed ▁> ▁buf _ end ▁) ▁return ▁-1 ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁mv bits ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ m vs ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁mv _ code book ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁get _ s bits ▁( ▁& ▁gb ▁, ▁10 ▁) ▁; ▁s ▁-> ▁mv _ code book ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁get _ s bits ▁( ▁& ▁gb ▁, ▁10 ▁) ▁; ▁} ▁buf ▁+= ▁mv bits ▁>> ▁3 ▁; ▁blocks _ raw ▁= ▁buf ▁; ▁buf ▁+= ▁num _ blocks _ raw ▁* ▁16 ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁( ▁buf _ end ▁- ▁buf ▁) ▁<< ▁3 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ blocks _ packed ▁; ▁i ▁++ ▁) ▁{ ▁int ▁tmp ▁[ ▁4 ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁tmp ▁[ ▁j ▁] ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁8 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁s ▁-> ▁block _ code book ▁[ ▁i ▁] ▁[ ▁15 ▁- ▁j ▁] ▁= ▁tmp ▁[ ▁get _ bits ▁( ▁& ▁gb ▁, ▁2 ▁) ▁] ▁; ▁} ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁gb ▁) ▁< ▁vector _ bits ▁* ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁/ ▁4 ▁) ▁* ▁( ▁s ▁-> ▁avctx ▁-> ▁width ▁/ ▁4 ▁) ▁) ▁return ▁-1 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁s ▁-> ▁avctx ▁-> ▁height ▁/ ▁4 ▁; ▁y ▁++ ▁) ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁s ▁-> ▁avctx ▁-> ▁width ▁/ ▁4 ▁; ▁x ▁++ ▁) ▁{ ▁unsigned ▁int ▁vector ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁vector _ bits ▁) ▁; ▁const ▁unsigned ▁char ▁* ▁src ▁; ▁int ▁src _ stride ▁; ▁if ▁( ▁vector ▁< ▁num _ m vs ▁) ▁{ ▁src ▁= ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁+ ▁( ▁y ▁* ▁4 ▁+ ▁s ▁-> ▁mv _ code book ▁[ ▁vector ▁] ▁[ ▁1 ▁] ▁) ▁* ▁s ▁-> ▁last _ frame ▁. ▁linesize ▁[ ▁0 ▁] ▁+ ▁x ▁* ▁4 ▁+ ▁s ▁-> ▁mv _ code book ▁[ ▁vector ▁] ▁[ ▁0 ▁] ▁; ▁src _ stride ▁= ▁s ▁-> ▁last _ frame ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁if ▁( ▁src ▁< ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁|| ▁src ▁+ ▁3 ▁* ▁src _ stride ▁+ ▁3 ▁>= ▁frame 0_ end ▁) ▁continue ▁; ▁} ▁else ▁{ ▁int ▁offset ▁= ▁vector ▁- ▁num _ m vs ▁; ▁if ▁( ▁offset ▁< ▁num _ blocks _ raw ▁) ▁src ▁= ▁blocks _ raw ▁+ ▁16 ▁* ▁offset ▁; ▁else ▁if ▁( ▁offset ▁- ▁num _ blocks _ raw ▁< ▁num _ blocks _ packed ▁) ▁src ▁= ▁s ▁-> ▁block _ code book ▁[ ▁offset ▁- ▁num _ blocks _ raw ▁] ▁; ▁else ▁continue ▁; ▁src _ stride ▁= ▁4 ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁0 ▁] ▁[ ▁( ▁y ▁* ▁4 ▁+ ▁j ▁) ▁* ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁+ ▁( ▁x ▁* ▁4 ▁+ ▁i ▁) ▁] ▁= ▁src ▁[ ▁j ▁* ▁src _ stride ▁+ ▁i ▁] ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁enum ▁WORK _ STATE ▁tls _ prepare _ client _ certificate ▁( ▁SSL ▁* ▁s ▁, ▁enum ▁WORK _ STATE ▁w st ▁) ▁{ ▁X 509 ▁* ▁x 509 ▁= ▁NULL ▁; ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁int ▁i ▁; ▁if ▁( ▁w st ▁== ▁WORK _ MORE _ A ▁) ▁{ ▁if ▁( ▁s ▁-> ▁cert ▁-> ▁cert _ cb ▁) ▁{ ▁i ▁= ▁s ▁-> ▁cert ▁-> ▁cert _ cb ▁( ▁s ▁, ▁s ▁-> ▁cert ▁-> ▁cert _ cb _ arg ▁) ▁; ▁if ▁( ▁i ▁< ▁0 ▁) ▁{ ▁s ▁-> ▁rw state ▁= ▁SSL _ X 509_ LOOKUP ▁; ▁return ▁WORK _ MORE _ A ▁; ▁} ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ FATAL ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁) ▁; ▁state m _ set _ error ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁} ▁s ▁-> ▁rw state ▁= ▁SSL _ NO THING ▁; ▁} ▁if ▁( ▁ssl 3_ check _ client _ certificate ▁( ▁s ▁) ▁) ▁return ▁WORK _ FINISHED _ CONTINUE ▁; ▁w st ▁= ▁WORK _ MORE _ B ▁; ▁} ▁if ▁( ▁w st ▁== ▁WORK _ MORE _ B ▁) ▁{ ▁i ▁= ▁ssl _ do _ client _ cert _ cb ▁( ▁s ▁, ▁& ▁x 509 ▁, ▁& ▁pkey ▁) ▁; ▁if ▁( ▁i ▁< ▁0 ▁) ▁{ ▁s ▁-> ▁rw state ▁= ▁SSL _ X 509_ LOOKUP ▁; ▁return ▁WORK _ MORE _ B ▁; ▁} ▁s ▁-> ▁rw state ▁= ▁SSL _ NO THING ▁; ▁if ▁( ▁( ▁i ▁== ▁1 ▁) ▁&& ▁( ▁pkey ▁!= ▁NULL ▁) ▁&& ▁( ▁x 509 ▁!= ▁NULL ▁) ▁) ▁{ ▁if ▁( ▁! ▁SSL _ use _ certificate ▁( ▁s ▁, ▁x 509 ▁) ▁|| ▁! ▁SSL _ use _ PrivateKey ▁( ▁s ▁, ▁pkey ▁) ▁) ▁i ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁1 ▁) ▁{ ▁i ▁= ▁0 ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PREP ARE _ CLIENT _ CERTIFICATE ▁, ▁SSL _ R _ BAD _ DATA _ RETURN ED _ BY _ CALLBACK ▁) ▁; ▁} ▁X 509_ free ▁( ▁x 509 ▁) ▁; ▁EVP _ PKEY _ free ▁( ▁pkey ▁) ▁; ▁if ▁( ▁i ▁&& ▁! ▁ssl 3_ check _ client _ certificate ▁( ▁s ▁) ▁) ▁i ▁= ▁0 ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁version ▁== ▁SSL 3_ VERSION ▁) ▁{ ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁cert _ req ▁= ▁0 ▁; ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ WARNING ▁, ▁SSL _ AD _ NO _ CERTIFICATE ▁) ▁; ▁return ▁WORK _ FINISHED _ CONTINUE ▁; ▁} ▁else ▁{ ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁cert _ req ▁= ▁2 ▁; ▁if ▁( ▁! ▁ssl 3_ digest _ cached _ records ▁( ▁s ▁, ▁0 ▁) ▁) ▁{ ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ FATAL ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁) ▁; ▁state m _ set _ error ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁} ▁return ▁WORK _ FINISHED _ CONTINUE ▁; ▁} ▁return ▁WORK _ ERROR ▁; ▁}	0
▁static ▁ossl _ inline ▁unsigned ▁int ▁constant _ time _ lt ▁( ▁unsigned ▁int ▁a ▁, ▁unsigned ▁int ▁b ▁) ▁{ ▁return ▁constant _ time _ msb ▁( ▁a ▁ ^ ▁( ▁( ▁a ▁ ^ ▁b ▁) ▁| ▁( ▁( ▁a ▁- ▁b ▁) ▁ ^ ▁b ▁) ▁) ▁) ▁; ▁}	1
▁static ▁int ▁multi _ split ▁( ▁BIO ▁* ▁bio ▁, ▁char ▁* ▁bound ▁, ▁STACK _ OF ▁( ▁BIO ▁) ▁* ▁* ▁ret ▁) ▁{ ▁char ▁linebuf ▁[ ▁MAX _ SML EN ▁] ▁; ▁int ▁len ▁, ▁blen ▁; ▁int ▁eol ▁= ▁0 ▁, ▁next _ eol ▁= ▁0 ▁; ▁BIO ▁* ▁b part ▁= ▁NULL ▁; ▁STACK _ OF ▁( ▁BIO ▁) ▁* ▁parts ▁; ▁char ▁state ▁, ▁part ▁, ▁first ▁; ▁blen ▁= ▁strlen ▁( ▁bound ▁) ▁; ▁part ▁= ▁0 ▁; ▁state ▁= ▁0 ▁; ▁first ▁= ▁1 ▁; ▁parts ▁= ▁sk _ BIO _ new _ null ▁( ▁) ▁; ▁* ▁ret ▁= ▁parts ▁; ▁while ▁( ▁( ▁len ▁= ▁BIO _ gets ▁( ▁bio ▁, ▁linebuf ▁, ▁MAX _ SML EN ▁) ▁) ▁> ▁0 ▁) ▁{ ▁state ▁= ▁mime _ bound _ check ▁( ▁linebuf ▁, ▁len ▁, ▁bound ▁, ▁blen ▁) ▁; ▁if ▁( ▁state ▁== ▁1 ▁) ▁{ ▁first ▁= ▁1 ▁; ▁part ▁++ ▁; ▁} ▁else ▁if ▁( ▁state ▁== ▁2 ▁) ▁{ ▁sk _ BIO _ push ▁( ▁parts ▁, ▁b part ▁) ▁; ▁return ▁1 ▁; ▁} ▁else ▁if ▁( ▁part ▁) ▁{ ▁next _ eol ▁= ▁strip _ eol ▁( ▁linebuf ▁, ▁& ▁len ▁) ▁; ▁if ▁( ▁first ▁) ▁{ ▁first ▁= ▁0 ▁; ▁if ▁( ▁b part ▁) ▁sk _ BIO _ push ▁( ▁parts ▁, ▁b part ▁) ▁; ▁b part ▁= ▁BIO _ new ▁( ▁BIO _ s _ mem ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁eol ▁) ▁BIO _ write ▁( ▁b part ▁, ▁"\ r \ n " ▁, ▁2 ▁) ▁; ▁eol ▁= ▁next _ eol ▁; ▁if ▁( ▁len ▁) ▁BIO _ write ▁( ▁b part ▁, ▁linebuf ▁, ▁len ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁size _ t ▁BUF _ MEM _ grow _ clean ▁( ▁BUF _ MEM ▁* ▁str ▁, ▁size _ t ▁len ▁) ▁{ ▁char ▁* ▁ret ▁; ▁size _ t ▁n ▁; ▁if ▁( ▁str ▁-> ▁length ▁>= ▁len ▁) ▁{ ▁memset ▁( ▁& ▁str ▁-> ▁data ▁[ ▁len ▁] ▁, ▁0 ▁, ▁str ▁-> ▁length ▁- ▁len ▁) ▁; ▁str ▁-> ▁length ▁= ▁len ▁; ▁return ▁( ▁len ▁) ▁; ▁} ▁if ▁( ▁str ▁-> ▁max ▁>= ▁len ▁) ▁{ ▁memset ▁( ▁& ▁str ▁-> ▁data ▁[ ▁str ▁-> ▁length ▁] ▁, ▁0 ▁, ▁len ▁- ▁str ▁-> ▁length ▁) ▁; ▁str ▁-> ▁length ▁= ▁len ▁; ▁return ▁( ▁len ▁) ▁; ▁} ▁if ▁( ▁len ▁> ▁LIMIT _ BEFORE _ EXP AN SION ▁) ▁{ ▁BUF err ▁( ▁BUF _ F _ BUF _ MEM _ G ROW _ CLEAN ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁n ▁= ▁( ▁len ▁+ ▁3 ▁) ▁/ ▁3 ▁* ▁4 ▁; ▁if ▁( ▁str ▁-> ▁data ▁== ▁NULL ▁) ▁ret ▁= ▁OPENSSL _ malloc ▁( ▁n ▁) ▁; ▁else ▁ret ▁= ▁OPENSSL _ realloc _ clean ▁( ▁str ▁-> ▁data ▁, ▁str ▁-> ▁max ▁, ▁n ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁BUF err ▁( ▁BUF _ F _ BUF _ MEM _ G ROW _ CLEAN ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁len ▁= ▁0 ▁; ▁} ▁else ▁{ ▁str ▁-> ▁data ▁= ▁ret ▁; ▁str ▁-> ▁max ▁= ▁n ▁; ▁memset ▁( ▁& ▁str ▁-> ▁data ▁[ ▁str ▁-> ▁length ▁] ▁, ▁0 ▁, ▁len ▁- ▁str ▁-> ▁length ▁) ▁; ▁str ▁-> ▁length ▁= ▁len ▁; ▁} ▁return ▁( ▁len ▁) ▁; ▁}	1
▁int ▁av _ image _ fill _ arrays ▁( ▁uint 8_ t ▁* ▁dst _ data ▁[ ▁4 ▁] ▁, ▁int ▁dst _ lines ize ▁[ ▁4 ▁] ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁align ▁) ▁{ ▁int ▁ret ▁, ▁i ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ check _ size ▁( ▁width ▁, ▁height ▁, ▁0 ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ fill _ lines izes ▁( ▁dst _ lines ize ▁, ▁pix _ fmt ▁, ▁width ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁dst _ lines ize ▁[ ▁i ▁] ▁= ▁FF ALIGN ▁( ▁dst _ lines ize ▁[ ▁i ▁] ▁, ▁align ▁) ▁; ▁return ▁av _ image _ fill _ pointers ▁( ▁dst _ data ▁, ▁pix _ fmt ▁, ▁height ▁, ▁( ▁uint 8_ t ▁* ▁) ▁src ▁, ▁dst _ lines ize ▁) ▁; ▁}	0
▁static ▁int ▁x iph _ handle _ packet ▁( ▁AVFormatContext ▁* ▁ctx ▁, ▁Payload Context ▁* ▁data ▁, ▁AVStream ▁* ▁st ▁, ▁AVPacket ▁* ▁pkt ▁, ▁uint 32_ t ▁* ▁timestamp ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁len ▁, ▁uint 16_ t ▁seq ▁, ▁int ▁flags ▁) ▁{ ▁int ▁ident ▁, ▁fragment ed ▁, ▁t dt ▁, ▁num _ pkts ▁, ▁pkt _ len ▁; ▁if ▁( ▁! ▁buf ▁) ▁{ ▁if ▁( ▁! ▁data ▁-> ▁split _ buf ▁|| ▁data ▁-> ▁split _ pos ▁+ ▁2 ▁> ▁data ▁-> ▁split _ buf _ len ▁|| ▁data ▁-> ▁split _ pkts ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" N om ore datat oreturn \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁pkt _ len ▁= ▁AV _ RB 16 ▁( ▁data ▁-> ▁split _ buf ▁+ ▁data ▁-> ▁split _ pos ▁) ▁; ▁data ▁-> ▁split _ pos ▁+= ▁2 ▁; ▁if ▁( ▁pkt _ len ▁> ▁data ▁-> ▁split _ buf _ len ▁- ▁data ▁-> ▁split _ pos ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Not en ough datat oreturn \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁pkt _ len ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Out of memory .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁st ▁-> ▁index ▁; ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁data ▁-> ▁split _ buf ▁+ ▁data ▁-> ▁split _ pos ▁, ▁pkt _ len ▁) ▁; ▁data ▁-> ▁split _ pos ▁+= ▁pkt _ len ▁; ▁data ▁-> ▁split _ pkts ▁-- ▁; ▁return ▁data ▁-> ▁split _ pkts ▁> ▁0 ▁; ▁} ▁if ▁( ▁len ▁< ▁6 ▁|| ▁len ▁> ▁INT _ MAX ▁/ ▁2 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid % db yte packet \ n " ▁, ▁len ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ident ▁= ▁AV _ RB 24 ▁( ▁buf ▁) ▁; ▁fragment ed ▁= ▁buf ▁[ ▁3 ▁] ▁>> ▁6 ▁; ▁t dt ▁= ▁( ▁buf ▁[ ▁3 ▁] ▁>> ▁4 ▁) ▁& ▁3 ▁; ▁num _ pkts ▁= ▁buf ▁[ ▁3 ▁] ▁& ▁0 xf ▁; ▁pkt _ len ▁= ▁AV _ RB 16 ▁( ▁buf ▁+ ▁4 ▁) ▁; ▁if ▁( ▁pkt _ len ▁> ▁len ▁- ▁6 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid packet length % din % db yte packet \ n " ▁, ▁pkt _ len ▁, ▁len ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁ident ▁!= ▁data ▁-> ▁ident ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unimplemented X iph SDP configuration change detected \ n " ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁t dt ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unimplemented RTP X iph packet settings (% d ,% d ,% d )\ n " ▁, ▁fragment ed ▁, ▁t dt ▁, ▁num _ pkts ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁buf ▁+= ▁6 ▁; ▁len ▁-= ▁6 ▁; ▁if ▁( ▁fragment ed ▁== ▁0 ▁) ▁{ ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁pkt _ len ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Out of memory .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁st ▁-> ▁index ▁; ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁buf ▁, ▁pkt _ len ▁) ▁; ▁buf ▁+= ▁pkt _ len ▁; ▁len ▁-= ▁pkt _ len ▁; ▁num _ pkts ▁-- ▁; ▁if ▁( ▁num _ pkts ▁> ▁0 ▁) ▁{ ▁if ▁( ▁len ▁> ▁data ▁-> ▁split _ buf _ size ▁|| ▁! ▁data ▁-> ▁split _ buf ▁) ▁{ ▁av _ freep ▁( ▁& ▁data ▁-> ▁split _ buf ▁) ▁; ▁data ▁-> ▁split _ buf _ size ▁= ▁2 ▁* ▁len ▁; ▁data ▁-> ▁split _ buf ▁= ▁av _ malloc ▁( ▁data ▁-> ▁split _ buf _ size ▁) ▁; ▁if ▁( ▁! ▁data ▁-> ▁split _ buf ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Out of memory .\ n " ▁) ▁; ▁av _ free _ packet ▁( ▁pkt ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁} ▁memcpy ▁( ▁data ▁-> ▁split _ buf ▁, ▁buf ▁, ▁len ▁) ▁; ▁data ▁-> ▁split _ buf _ len ▁= ▁len ▁; ▁data ▁-> ▁split _ pos ▁= ▁0 ▁; ▁data ▁-> ▁split _ pkts ▁= ▁num _ pkts ▁; ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁fragment ed ▁== ▁1 ▁) ▁{ ▁int ▁res ▁; ▁ff io _ free _ dyn _ buf ▁( ▁& ▁data ▁-> ▁fragment ▁) ▁; ▁if ▁( ▁( ▁res ▁= ▁avio _ open _ dyn _ buf ▁( ▁& ▁data ▁-> ▁fragment ▁) ▁) ▁< ▁0 ▁) ▁return ▁res ▁; ▁avio _ write ▁( ▁data ▁-> ▁fragment ▁, ▁buf ▁, ▁pkt _ len ▁) ▁; ▁data ▁-> ▁timestamp ▁= ▁* ▁timestamp ▁; ▁} ▁else ▁{ ▁av _ assert 1 ▁( ▁fragment ed ▁< ▁4 ▁) ▁; ▁if ▁( ▁data ▁-> ▁timestamp ▁!= ▁* ▁timestamp ▁) ▁{ ▁ff io _ free _ dyn _ buf ▁( ▁& ▁data ▁-> ▁fragment ▁) ▁; ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" RTP timestamp sd on ' t match !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁! ▁data ▁-> ▁fragment ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Received packet without ast art fragment ; dro pping .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EAGAIN ▁) ▁; ▁} ▁avio _ write ▁( ▁data ▁-> ▁fragment ▁, ▁buf ▁, ▁pkt _ len ▁) ▁; ▁if ▁( ▁fragment ed ▁== ▁3 ▁) ▁{ ▁int ▁ret ▁= ▁ff _ rtp _ finalize _ packet ▁( ▁pkt ▁, ▁& ▁data ▁-> ▁fragment ▁, ▁st ▁-> ▁index ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error occ urre dw hen get ting fragment buffer ." ▁) ▁; ▁return ▁ret ▁; ▁} ▁return ▁0 ▁; ▁} ▁} ▁return ▁AVERROR ▁( ▁EAGAIN ▁) ▁; ▁}	0
▁static ▁void ▁to _ meta _ with _ crop ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVFrame ▁* ▁p ▁, ▁int ▁* ▁dest ▁) ▁{ ▁int ▁block x ▁, ▁block y ▁, ▁x ▁, ▁y ▁; ▁int ▁lum a ▁= ▁0 ▁; ▁int ▁height ▁= ▁FF MIN ▁( ▁avctx ▁-> ▁height ▁, ▁C 64 Y RES ▁) ▁; ▁int ▁width ▁= ▁FF MIN ▁( ▁avctx ▁-> ▁width ▁, ▁C 64 X RES ▁) ▁; ▁uint 8_ t ▁* ▁src ▁= ▁p ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁block y ▁= ▁0 ▁; ▁block y ▁< ▁C 64 Y RES ▁; ▁block y ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁block x ▁= ▁0 ▁; ▁block x ▁< ▁C 64 X RES ▁; ▁block x ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁y ▁= ▁block y ▁; ▁y ▁< ▁block y ▁+ ▁8 ▁&& ▁y ▁< ▁C 64 Y RES ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁block x ▁; ▁x ▁< ▁block x ▁+ ▁8 ▁&& ▁x ▁< ▁C 64 X RES ▁; ▁x ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁x ▁< ▁width ▁&& ▁y ▁< ▁height ▁) ▁{ ▁lum a ▁= ▁( ▁src ▁[ ▁( ▁x ▁+ ▁0 ▁+ ▁y ▁* ▁p ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁] ▁+ ▁src ▁[ ▁( ▁x ▁+ ▁1 ▁+ ▁y ▁* ▁p ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁] ▁) ▁/ ▁2 ▁; ▁dest ▁[ ▁0 ▁] ▁= ▁lum a ▁; ▁} ▁dest ▁++ ▁; ▁} ▁} ▁} ▁} ▁}	1
▁int ▁ff _ new _ ch apter ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁id ▁, ▁int 64_ t ▁start ▁, ▁int 64_ t ▁end ▁, ▁const ▁char ▁* ▁title ▁) ▁{ ▁AV Ch apter ▁* ▁chapter ▁= ▁NULL ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁num _ ch apt ers ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁-> ▁ch apt ers ▁[ ▁i ▁] ▁-> ▁id ▁== ▁id ▁) ▁chapter ▁= ▁s ▁-> ▁ch apt ers ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁chapter ▁) ▁{ ▁chapter ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AV Ch apter ▁) ▁) ▁; ▁if ▁( ▁! ▁chapter ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁dyn array _ add ▁( ▁& ▁s ▁-> ▁ch apt ers ▁, ▁& ▁s ▁-> ▁num _ ch apt ers ▁, ▁chapter ▁) ▁; ▁} ▁if ▁( ▁chapter ▁-> ▁title ▁) ▁av _ free ▁( ▁chapter ▁-> ▁title ▁) ▁; ▁chapter ▁-> ▁title ▁= ▁av _ strdup ▁( ▁title ▁) ▁; ▁chapter ▁-> ▁id ▁= ▁id ▁; ▁chapter ▁-> ▁start ▁= ▁start ▁; ▁chapter ▁-> ▁end ▁= ▁end ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁skip _ check ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁Picture ▁* ▁p ▁, ▁Picture ▁* ▁ref ▁) ▁{ ▁int ▁x ▁, ▁y ▁, ▁plane ▁; ▁int ▁score ▁= ▁0 ▁; ▁int 64_ t ▁score 64 ▁= ▁0 ▁; ▁for ▁( ▁plane ▁= ▁0 ▁; ▁plane ▁< ▁3 ▁; ▁plane ▁++ ▁) ▁{ ▁const ▁int ▁stride ▁= ▁p ▁-> ▁f ▁-> ▁linesize ▁[ ▁plane ▁] ▁; ▁const ▁int ▁bw ▁= ▁plane ▁? ▁1 ▁: ▁2 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁s ▁-> ▁mb _ height ▁* ▁bw ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁s ▁-> ▁mb _ width ▁* ▁bw ▁; ▁x ▁++ ▁) ▁{ ▁int ▁off ▁= ▁p ▁-> ▁shared ▁? ▁0 ▁: ▁16 ▁; ▁uint 8_ t ▁* ▁dptr ▁= ▁p ▁-> ▁f ▁-> ▁data ▁[ ▁plane ▁] ▁+ ▁8 ▁* ▁( ▁x ▁+ ▁y ▁* ▁stride ▁) ▁+ ▁off ▁; ▁uint 8_ t ▁* ▁rptr ▁= ▁ref ▁-> ▁f ▁-> ▁data ▁[ ▁plane ▁] ▁+ ▁8 ▁* ▁( ▁x ▁+ ▁y ▁* ▁stride ▁) ▁; ▁int ▁v ▁= ▁s ▁-> ▁dsp ▁. ▁frame _ skip _ cmp ▁[ ▁1 ▁] ▁( ▁s ▁, ▁dptr ▁, ▁rptr ▁, ▁stride ▁, ▁8 ▁) ▁; ▁switch ▁( ▁s ▁-> ▁avctx ▁-> ▁frame _ skip _ exp ▁) ▁{ ▁case ▁0 ▁: ▁score ▁= ▁FF MAX ▁( ▁score ▁, ▁v ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁score ▁+= ▁FF ABS ▁( ▁v ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁score ▁+= ▁v ▁* ▁v ▁; ▁break ▁; ▁case ▁3 ▁: ▁score 64 ▁+= ▁FF ABS ▁( ▁v ▁* ▁v ▁* ▁( ▁int 64_ t ▁) ▁v ▁) ▁; ▁break ▁; ▁case ▁4 ▁: ▁score 64 ▁+= ▁v ▁* ▁v ▁* ▁( ▁int 64_ t ▁) ▁( ▁v ▁* ▁v ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁score ▁) ▁score 64 ▁= ▁score ▁; ▁if ▁( ▁score 64 ▁< ▁s ▁-> ▁avctx ▁-> ▁frame _ skip _ threshold ▁) ▁return ▁1 ▁; ▁if ▁( ▁score 64 ▁< ▁( ▁( ▁s ▁-> ▁avctx ▁-> ▁frame _ skip _ factor ▁* ▁( ▁int 64_ t ▁) ▁s ▁-> ▁lambda ▁) ▁>> ▁8 ▁) ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁ngx _ int _ t ▁ngx _ http _ file _ cache _ add ▁( ▁ngx _ http _ file _ cache _ t ▁* ▁cache ▁, ▁ngx _ http _ cache _ t ▁* ▁c ▁) ▁{ ▁ngx _ http _ file _ cache _ node _ t ▁* ▁f cn ▁; ▁ngx _ shm tx _ lock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁f cn ▁= ▁ngx _ http _ file _ cache _ lookup ▁( ▁cache ▁, ▁c ▁-> ▁key ▁) ▁; ▁if ▁( ▁f cn ▁== ▁NULL ▁) ▁{ ▁f cn ▁= ▁ngx _ slab _ calloc _ locked ▁( ▁cache ▁-> ▁sh pool ▁, ▁sizeof ▁( ▁ngx _ http _ file _ cache _ node _ t ▁) ▁) ▁; ▁if ▁( ▁f cn ▁== ▁NULL ▁) ▁{ ▁ngx _ shm tx _ unlock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁ngx _ memcpy ▁( ▁( ▁u _ char ▁* ▁) ▁& ▁f cn ▁-> ▁node ▁. ▁key ▁, ▁c ▁-> ▁key ▁, ▁sizeof ▁( ▁ngx _ rbtree _ key _ t ▁) ▁) ▁; ▁ngx _ memcpy ▁( ▁f cn ▁-> ▁key ▁, ▁& ▁c ▁-> ▁key ▁[ ▁sizeof ▁( ▁ngx _ rbtree _ key _ t ▁) ▁] ▁, ▁NGX _ HTTP _ CACHE _ KEY _ LEN ▁- ▁sizeof ▁( ▁ngx _ rbtree _ key _ t ▁) ▁) ▁; ▁ngx _ rbtree _ insert ▁( ▁& ▁cache ▁-> ▁sh ▁-> ▁r btree ▁, ▁& ▁f cn ▁-> ▁node ▁) ▁; ▁f cn ▁-> ▁uses ▁= ▁1 ▁; ▁f cn ▁-> ▁exists ▁= ▁1 ▁; ▁f cn ▁-> ▁fs _ size ▁= ▁c ▁-> ▁fs _ size ▁; ▁cache ▁-> ▁sh ▁-> ▁size ▁+= ▁c ▁-> ▁fs _ size ▁; ▁} ▁else ▁{ ▁ngx _ queue _ remove ▁( ▁& ▁f cn ▁-> ▁queue ▁) ▁; ▁} ▁f cn ▁-> ▁expire ▁= ▁ngx _ time ▁( ▁) ▁+ ▁cache ▁-> ▁inactive ▁; ▁ngx _ queue _ insert _ head ▁( ▁& ▁cache ▁-> ▁sh ▁-> ▁queue ▁, ▁& ▁f cn ▁-> ▁queue ▁) ▁; ▁ngx _ shm tx _ unlock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁return ▁NGX _ OK ▁; ▁}	0
▁int ▁ff _ MP V _ common _ init ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁; ▁int ▁nb _ s lices ▁= ▁( ▁HAVE _ THREADS ▁&& ▁s ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁? ▁s ▁-> ▁avctx ▁-> ▁thread _ count ▁: ▁1 ▁; ▁if ▁( ▁s ▁-> ▁encoding ▁&& ▁s ▁-> ▁avctx ▁-> ▁slices ▁) ▁nb _ s lices ▁= ▁s ▁-> ▁avctx ▁-> ▁slices ▁; ▁if ▁( ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁&& ▁! ▁s ▁-> ▁progress ive _ sequence ▁) ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁2 ▁; ▁else ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁15 ▁) ▁/ ▁16 ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ NONE ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" de coding to AV _ PIX _ FMT _ NONE is not supported .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁nb _ s lices ▁> ▁MAX _ THREADS ▁|| ▁( ▁nb _ s lices ▁> ▁s ▁-> ▁mb _ height ▁&& ▁s ▁-> ▁mb _ height ▁) ▁) ▁{ ▁int ▁max _ s lices ▁; ▁if ▁( ▁s ▁-> ▁mb _ height ▁) ▁max _ s lices ▁= ▁FF MIN ▁( ▁MAX _ THREADS ▁, ▁s ▁-> ▁mb _ height ▁) ▁; ▁else ▁max _ s lices ▁= ▁MAX _ THREADS ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" t oom any threads / s lices (% d )," ▁" red uc ing to % d \ n " ▁, ▁nb _ s lices ▁, ▁max _ s lices ▁) ▁; ▁nb _ s lices ▁= ▁max _ s lices ▁; ▁} ▁if ▁( ▁( ▁s ▁-> ▁width ▁|| ▁s ▁-> ▁height ▁) ▁&& ▁av _ image _ check _ size ▁( ▁s ▁-> ▁width ▁, ▁s ▁-> ▁height ▁, ▁0 ▁, ▁s ▁-> ▁avctx ▁) ▁) ▁return ▁-1 ▁; ▁ff _ dct _ common _ init ▁( ▁s ▁) ▁; ▁s ▁-> ▁flags ▁= ▁s ▁-> ▁avctx ▁-> ▁flags ▁; ▁s ▁-> ▁flags 2 ▁= ▁s ▁-> ▁avctx ▁-> ▁flags 2 ▁; ▁avcodec _ get _ chroma _ sub _ sample ▁( ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁, ▁& ▁s ▁-> ▁chroma _ x _ shift ▁, ▁& ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁s ▁-> ▁codec _ tag ▁= ▁avpriv _ toupper 4 ▁( ▁s ▁-> ▁avctx ▁-> ▁codec _ tag ▁) ▁; ▁s ▁-> ▁stream _ codec _ tag ▁= ▁avpriv _ toupper 4 ▁( ▁s ▁-> ▁avctx ▁-> ▁stream _ codec _ tag ▁) ▁; ▁s ▁-> ▁avctx ▁-> ▁coded _ frame ▁= ▁& ▁s ▁-> ▁current _ picture ▁. ▁f ▁; ▁if ▁( ▁s ▁-> ▁encoding ▁) ▁{ ▁if ▁( ▁s ▁-> ▁ms mpeg 4_ version ▁) ▁{ ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁ac _ stats ▁, ▁2 ▁* ▁2 ▁* ▁( ▁MAX _ LEVEL ▁+ ▁1 ▁) ▁* ▁( ▁MAX _ RUN ▁+ ▁1 ▁) ▁* ▁2 ▁* ▁sizeof ▁( ▁int ▁) ▁, ▁fail ▁) ▁; ▁} ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁avctx ▁-> ▁stats _ out ▁, ▁256 ▁, ▁fail ▁) ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁q _ intra _ matrix ▁, ▁64 ▁* ▁32 ▁* ▁sizeof ▁( ▁int ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁q _ chroma _ intra _ matrix ▁, ▁64 ▁* ▁32 ▁* ▁sizeof ▁( ▁int ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁q _ inter _ matrix ▁, ▁64 ▁* ▁32 ▁* ▁sizeof ▁( ▁int ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁q _ intra _ matrix 16 ▁, ▁64 ▁* ▁32 ▁* ▁2 ▁* ▁sizeof ▁( ▁uint 16_ t ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁q _ chroma _ intra _ matrix 16 ▁, ▁64 ▁* ▁32 ▁* ▁2 ▁* ▁sizeof ▁( ▁uint 16_ t ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁q _ inter _ matrix 16 ▁, ▁64 ▁* ▁32 ▁* ▁2 ▁* ▁sizeof ▁( ▁uint 16_ t ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁input _ picture ▁, ▁MAX _ PICTURE _ COUNT ▁* ▁sizeof ▁( ▁Picture ▁* ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁re ordered _ input _ picture ▁, ▁MAX _ PICTURE _ COUNT ▁* ▁sizeof ▁( ▁Picture ▁* ▁) ▁, ▁fail ▁) ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁noise _ reduction ▁) ▁{ ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁dct _ offset ▁, ▁2 ▁* ▁64 ▁* ▁sizeof ▁( ▁uint 16_ t ▁) ▁, ▁fail ▁) ▁; ▁} ▁} ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁picture ▁, ▁MAX _ PICTURE _ COUNT ▁* ▁sizeof ▁( ▁Picture ▁) ▁, ▁fail ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁avcodec _ get _ frame _ defaults ▁( ▁& ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁) ▁; ▁} ▁memset ▁( ▁& ▁s ▁-> ▁next _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁next _ picture ▁) ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁last _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁last _ picture ▁) ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁current _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁current _ picture ▁) ▁) ▁; ▁avcodec _ get _ frame _ defaults ▁( ▁& ▁s ▁-> ▁next _ picture ▁. ▁f ▁) ▁; ▁avcodec _ get _ frame _ defaults ▁( ▁& ▁s ▁-> ▁last _ picture ▁. ▁f ▁) ▁; ▁avcodec _ get _ frame _ defaults ▁( ▁& ▁s ▁-> ▁current _ picture ▁. ▁f ▁) ▁; ▁if ▁( ▁init _ context _ frame ▁( ▁s ▁) ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁parse _ context ▁. ▁state ▁= ▁-1 ▁; ▁s ▁-> ▁context _ initialized ▁= ▁1 ▁; ▁s ▁-> ▁thread _ context ▁[ ▁0 ▁] ▁= ▁s ▁; ▁if ▁( ▁nb _ s lices ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁init _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁start _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁end _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁init _ duplicate _ context ▁( ▁s ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁start _ mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁end _ mb _ y ▁= ▁s ▁-> ▁mb _ height ▁; ▁} ▁s ▁-> ▁slice _ context _ count ▁= ▁nb _ s lices ▁; ▁return ▁0 ▁; ▁fail ▁: ▁ff _ MP V _ common _ end ▁( ▁s ▁) ▁; ▁return ▁-1 ▁; ▁}	1
▁static ▁int ▁rm _ write _ audio ▁( ▁AVFormatContext ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁size ▁, ▁int ▁flags ▁) ▁{ ▁uint 8_ t ▁* ▁buf 1 ▁; ▁R MM ux Context ▁* ▁rm ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁Stream Info ▁* ▁stream ▁= ▁rm ▁-> ▁audio _ stream ▁; ▁int ▁i ▁; ▁buf 1 ▁= ▁av _ malloc ▁( ▁size ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁) ▁; ▁if ▁( ▁! ▁buf 1 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁write _ packet _ header ▁( ▁s ▁, ▁stream ▁, ▁size ▁, ▁! ▁! ▁( ▁flags ▁& ▁AV _ PKT _ FLAG _ KEY ▁) ▁) ▁; ▁if ▁( ▁stream ▁-> ▁enc ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ AC 3 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁buf 1 ▁[ ▁i ▁] ▁= ▁buf ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁buf 1 ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁buf ▁[ ▁i ▁] ▁; ▁} ▁avio _ write ▁( ▁pb ▁, ▁buf 1 ▁, ▁size ▁) ▁; ▁} ▁else ▁{ ▁avio _ write ▁( ▁pb ▁, ▁buf ▁, ▁size ▁) ▁; ▁} ▁stream ▁-> ▁nb _ frames ▁++ ▁; ▁av _ free ▁( ▁buf 1 ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁ssize _ t ▁ngx _ at os z ▁( ▁u _ char ▁* ▁line ▁, ▁size _ t ▁n ▁) ▁{ ▁ssize _ t ▁value ▁; ▁if ▁( ▁n ▁== ▁0 ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁for ▁( ▁value ▁= ▁0 ▁; ▁n ▁-- ▁; ▁line ▁++ ▁) ▁{ ▁if ▁( ▁* ▁line ▁< ▁' ▁' ▁|| ▁* ▁line ▁> ▁' ▁' ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁value ▁= ▁value ▁* ▁10 ▁+ ▁( ▁* ▁line ▁- ▁' ▁' ▁) ▁; ▁} ▁if ▁( ▁value ▁< ▁0 ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁else ▁{ ▁return ▁value ▁; ▁} ▁}	1
▁int ▁BIO _ read ▁( ▁BIO ▁* ▁b ▁, ▁void ▁* ▁out ▁, ▁int ▁outl ▁) ▁{ ▁int ▁i ▁; ▁long ▁( ▁* ▁cb ▁) ▁( ▁BIO ▁* ▁, ▁int ▁, ▁const ▁char ▁* ▁, ▁int ▁, ▁long ▁, ▁long ▁) ▁; ▁if ▁( ▁( ▁b ▁== ▁NULL ▁) ▁|| ▁( ▁b ▁-> ▁method ▁== ▁NULL ▁) ▁|| ▁( ▁b ▁-> ▁method ▁-> ▁bread ▁== ▁NULL ▁) ▁) ▁{ ▁BIO err ▁( ▁BIO _ F _ BIO _ READ ▁, ▁BIO _ R _ UNSUPPORTED _ METHOD ▁) ▁; ▁return ▁( ▁-2 ▁) ▁; ▁} ▁cb ▁= ▁b ▁-> ▁callback ▁; ▁if ▁( ▁( ▁cb ▁!= ▁NULL ▁) ▁&& ▁( ▁( ▁i ▁= ▁( ▁int ▁) ▁cb ▁( ▁b ▁, ▁BIO _ CB _ READ ▁, ▁out ▁, ▁outl ▁, ▁0 L ▁, ▁1 L ▁) ▁) ▁<= ▁0 ▁) ▁) ▁return ▁( ▁i ▁) ▁; ▁if ▁( ▁! ▁b ▁-> ▁init ▁) ▁{ ▁BIO err ▁( ▁BIO _ F _ BIO _ READ ▁, ▁BIO _ R _ UN INITIALIZED ▁) ▁; ▁return ▁( ▁-2 ▁) ▁; ▁} ▁i ▁= ▁b ▁-> ▁method ▁-> ▁bread ▁( ▁b ▁, ▁out ▁, ▁outl ▁) ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁b ▁-> ▁num _ read ▁+= ▁( ▁unsigned ▁long ▁) ▁i ▁; ▁if ▁( ▁cb ▁!= ▁NULL ▁) ▁i ▁= ▁( ▁int ▁) ▁cb ▁( ▁b ▁, ▁BIO _ CB _ READ ▁| ▁BIO _ CB _ RETURN ▁, ▁out ▁, ▁outl ▁, ▁0 L ▁, ▁( ▁long ▁) ▁i ▁) ▁; ▁return ▁( ▁i ▁) ▁; ▁}	1
▁int ▁tls _ construct _ certificate _ request ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁, ▁* ▁d ▁; ▁int ▁i ▁, ▁j ▁, ▁nl ▁, ▁off ▁, ▁n ▁; ▁STACK _ OF ▁( ▁X 509_ NAME ▁) ▁* ▁sk ▁= ▁NULL ▁; ▁X 509_ NAME ▁* ▁name ▁; ▁BUF _ MEM ▁* ▁buf ▁; ▁buf ▁= ▁s ▁-> ▁init _ buf ▁; ▁d ▁= ▁p ▁= ▁ssl _ handshake _ start ▁( ▁s ▁) ▁; ▁p ▁++ ▁; ▁n ▁= ▁ssl 3_ get _ req _ cert _ type ▁( ▁s ▁, ▁p ▁) ▁; ▁d ▁[ ▁0 ▁] ▁= ▁n ▁; ▁p ▁+= ▁n ▁; ▁n ▁++ ▁; ▁if ▁( ▁SSL _ USE _ SIG ALG S ▁( ▁s ▁) ▁) ▁{ ▁const ▁unsigned ▁char ▁* ▁ps ig s ▁; ▁unsigned ▁char ▁* ▁et mp ▁= ▁p ▁; ▁nl ▁= ▁tls 12_ get _ ps ig algs ▁( ▁s ▁, ▁& ▁ps ig s ▁) ▁; ▁p ▁+= ▁2 ▁; ▁nl ▁= ▁tls 12_ copy _ sig algs ▁( ▁s ▁, ▁p ▁, ▁ps ig s ▁, ▁nl ▁) ▁; ▁s 2 n ▁( ▁nl ▁, ▁et mp ▁) ▁; ▁p ▁+= ▁nl ▁; ▁n ▁+= ▁nl ▁+ ▁2 ▁; ▁} ▁off ▁= ▁n ▁; ▁p ▁+= ▁2 ▁; ▁n ▁+= ▁2 ▁; ▁sk ▁= ▁SSL _ get _ client _ CA _ list ▁( ▁s ▁) ▁; ▁nl ▁= ▁0 ▁; ▁if ▁( ▁sk ▁!= ▁NULL ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ X 509_ NAME _ num ▁( ▁sk ▁) ▁; ▁i ▁++ ▁) ▁{ ▁name ▁= ▁sk _ X 509_ NAME _ value ▁( ▁sk ▁, ▁i ▁) ▁; ▁j ▁= ▁i 2 d _ X 509_ NAME ▁( ▁name ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁BUF _ MEM _ grow _ clean ▁( ▁buf ▁, ▁SSL _ HM _ HEADER _ LENGTH ▁( ▁s ▁) ▁+ ▁n ▁+ ▁j ▁+ ▁2 ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CERTIFICATE _ REQUEST ▁, ▁ERR _ R _ BUF _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁p ▁= ▁ssl _ handshake _ start ▁( ▁s ▁) ▁+ ▁n ▁; ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁i 2 d _ X 509_ NAME ▁( ▁name ▁, ▁& ▁p ▁) ▁; ▁n ▁+= ▁2 ▁+ ▁j ▁; ▁nl ▁+= ▁2 ▁+ ▁j ▁; ▁} ▁} ▁p ▁= ▁ssl _ handshake _ start ▁( ▁s ▁) ▁+ ▁off ▁; ▁s 2 n ▁( ▁nl ▁, ▁p ▁) ▁; ▁if ▁( ▁! ▁ssl _ set _ handshake _ header ▁( ▁s ▁, ▁SSL 3_ MT _ CERTIFICATE _ REQUEST ▁, ▁n ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CERTIFICATE _ REQUEST ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁cert _ request ▁= ▁1 ▁; ▁return ▁1 ▁; ▁err ▁: ▁ossl _ state m _ set _ error ▁( ▁s ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁end _ frame ▁( ▁AVFilter Link ▁* ▁inlink ▁) ▁{ ▁Trans Context ▁* ▁trans ▁= ▁inlink ▁-> ▁dst ▁-> ▁priv ▁; ▁AVFilter Buffer Ref ▁* ▁in pic ▁= ▁inlink ▁-> ▁cur _ buf ▁; ▁AVFilter Buffer Ref ▁* ▁out pic ▁= ▁inlink ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁out _ buf ▁; ▁AVFilter Link ▁* ▁out link ▁= ▁inlink ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁int ▁plane ▁; ▁for ▁( ▁plane ▁= ▁0 ▁; ▁out pic ▁-> ▁data ▁[ ▁plane ▁] ▁; ▁plane ▁++ ▁) ▁{ ▁int ▁h sub ▁= ▁plane ▁== ▁1 ▁|| ▁plane ▁== ▁2 ▁? ▁trans ▁-> ▁h sub ▁: ▁0 ▁; ▁int ▁v sub ▁= ▁plane ▁== ▁1 ▁|| ▁plane ▁== ▁2 ▁? ▁trans ▁-> ▁v sub ▁: ▁0 ▁; ▁int ▁pix step ▁= ▁trans ▁-> ▁pix steps ▁[ ▁plane ▁] ▁; ▁int ▁in h ▁= ▁in pic ▁-> ▁video ▁-> ▁h ▁>> ▁v sub ▁; ▁int ▁outw ▁= ▁out pic ▁-> ▁video ▁-> ▁w ▁>> ▁h sub ▁; ▁int ▁out h ▁= ▁out pic ▁-> ▁video ▁-> ▁h ▁>> ▁v sub ▁; ▁uint 8_ t ▁* ▁out ▁, ▁* ▁in ▁; ▁int ▁out lines ize ▁, ▁in lines ize ▁; ▁int ▁x ▁, ▁y ▁; ▁out ▁= ▁out pic ▁-> ▁data ▁[ ▁plane ▁] ▁; ▁out lines ize ▁= ▁out pic ▁-> ▁linesize ▁[ ▁plane ▁] ▁; ▁in ▁= ▁in pic ▁-> ▁data ▁[ ▁plane ▁] ▁; ▁in lines ize ▁= ▁in pic ▁-> ▁linesize ▁[ ▁plane ▁] ▁; ▁if ▁( ▁trans ▁-> ▁dir ▁& ▁1 ▁) ▁{ ▁in ▁+= ▁in pic ▁-> ▁linesize ▁[ ▁plane ▁] ▁* ▁( ▁in h ▁- ▁1 ▁) ▁; ▁in lines ize ▁*= ▁-1 ▁; ▁} ▁if ▁( ▁trans ▁-> ▁dir ▁& ▁2 ▁) ▁{ ▁out ▁+= ▁out pic ▁-> ▁linesize ▁[ ▁plane ▁] ▁* ▁( ▁out h ▁- ▁1 ▁) ▁; ▁out lines ize ▁*= ▁-1 ▁; ▁} ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁out h ▁; ▁y ▁++ ▁) ▁{ ▁switch ▁( ▁pix step ▁) ▁{ ▁case ▁1 ▁: ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁outw ▁; ▁x ▁++ ▁) ▁out ▁[ ▁x ▁] ▁= ▁in ▁[ ▁x ▁* ▁in lines ize ▁+ ▁y ▁] ▁; ▁break ▁; ▁case ▁2 ▁: ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁outw ▁; ▁x ▁++ ▁) ▁* ▁( ▁( ▁uint 16_ t ▁* ▁) ▁( ▁out ▁+ ▁2 ▁* ▁x ▁) ▁) ▁= ▁* ▁( ▁( ▁uint 16_ t ▁* ▁) ▁( ▁in ▁+ ▁x ▁* ▁in lines ize ▁+ ▁y ▁* ▁2 ▁) ▁) ▁; ▁break ▁; ▁case ▁3 ▁: ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁outw ▁; ▁x ▁++ ▁) ▁{ ▁int 32_ t ▁v ▁= ▁AV _ RB 24 ▁( ▁in ▁+ ▁x ▁* ▁in lines ize ▁+ ▁y ▁* ▁3 ▁) ▁; ▁AV _ WB 24 ▁( ▁out ▁+ ▁3 ▁* ▁x ▁, ▁v ▁) ▁; ▁} ▁break ▁; ▁case ▁4 ▁: ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁outw ▁; ▁x ▁++ ▁) ▁* ▁( ▁( ▁uint 32_ t ▁* ▁) ▁( ▁out ▁+ ▁4 ▁* ▁x ▁) ▁) ▁= ▁* ▁( ▁( ▁uint 32_ t ▁* ▁) ▁( ▁in ▁+ ▁x ▁* ▁in lines ize ▁+ ▁y ▁* ▁4 ▁) ▁) ▁; ▁break ▁; ▁} ▁out ▁+= ▁out lines ize ▁; ▁} ▁} ▁ff _ draw _ slice ▁( ▁out link ▁, ▁0 ▁, ▁out pic ▁-> ▁video ▁-> ▁h ▁, ▁1 ▁) ▁; ▁ff _ end _ frame ▁( ▁out link ▁) ▁; ▁avfilter _ unref _ buffer ▁( ▁out pic ▁) ▁; ▁}	0
▁int ▁ec _ key _ simple _ check _ key ▁( ▁const ▁EC _ KEY ▁* ▁e ckey ▁) ▁{ ▁int ▁ok ▁= ▁0 ▁; ▁BN _ CTX ▁* ▁ctx ▁= ▁NULL ▁; ▁const ▁BIGNUM ▁* ▁order ▁= ▁NULL ▁; ▁EC _ POINT ▁* ▁point ▁= ▁NULL ▁; ▁if ▁( ▁e ckey ▁== ▁NULL ▁|| ▁e ckey ▁-> ▁group ▁== ▁NULL ▁|| ▁e ckey ▁-> ▁pub _ key ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁ERR _ R _ PASSED _ NULL _ PARAMETER ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁EC _ POINT _ is _ at _ infinity ▁( ▁e ckey ▁-> ▁group ▁, ▁e ckey ▁-> ▁pub _ key ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁EC _ R _ POINT _ AT _ INFINITY ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁ctx ▁= ▁BN _ CTX _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁point ▁= ▁EC _ POINT _ new ▁( ▁e ckey ▁-> ▁group ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁EC _ POINT _ is _ on _ curve ▁( ▁e ckey ▁-> ▁group ▁, ▁e ckey ▁-> ▁pub _ key ▁, ▁ctx ▁) ▁<= ▁0 ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁EC _ R _ POINT _ IS _ NOT _ ON _ CURVE ▁) ▁; ▁goto ▁err ▁; ▁} ▁order ▁= ▁e ckey ▁-> ▁group ▁-> ▁order ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁order ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁EC _ R _ INVALID _ GROUP _ ORDER ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁EC _ POINT _ mul ▁( ▁e ckey ▁-> ▁group ▁, ▁point ▁, ▁NULL ▁, ▁e ckey ▁-> ▁pub _ key ▁, ▁order ▁, ▁ctx ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁ERR _ R _ EC _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁EC _ POINT _ is _ at _ infinity ▁( ▁e ckey ▁-> ▁group ▁, ▁point ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁EC _ R _ WRONG _ ORDER ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁e ckey ▁-> ▁priv _ key ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁BN _ cmp ▁( ▁e ckey ▁-> ▁priv _ key ▁, ▁order ▁) ▁>= ▁0 ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁EC _ R _ WRONG _ ORDER ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁EC _ POINT _ mul ▁( ▁e ckey ▁-> ▁group ▁, ▁point ▁, ▁e ckey ▁-> ▁priv _ key ▁, ▁NULL ▁, ▁NULL ▁, ▁ctx ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁ERR _ R _ EC _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁EC _ POINT _ cmp ▁( ▁e ckey ▁-> ▁group ▁, ▁point ▁, ▁e ckey ▁-> ▁pub _ key ▁, ▁ctx ▁) ▁!= ▁0 ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ CHECK _ KEY ▁, ▁EC _ R _ INVALID _ PRIVATE _ KEY ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁ok ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ free ▁( ▁ctx ▁) ▁; ▁EC _ POINT _ free ▁( ▁point ▁) ▁; ▁return ▁ok ▁; ▁}	1
▁int 64_ t ▁avio _ seek ▁( ▁AVIO Context ▁* ▁s ▁, ▁int 64_ t ▁offset ▁, ▁int ▁whence ▁) ▁{ ▁int 64_ t ▁offset 1 ▁; ▁int 64_ t ▁pos ▁; ▁int ▁force ▁= ▁whence ▁& ▁AV SEEK _ FORCE ▁; ▁whence ▁&= ▁ ~ ▁AV SEEK _ FORCE ▁; ▁if ▁( ▁! ▁s ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁pos ▁= ▁s ▁-> ▁pos ▁- ▁( ▁s ▁-> ▁write _ flag ▁? ▁0 ▁: ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buffer ▁) ▁) ▁; ▁if ▁( ▁whence ▁!= ▁SEEK _ CUR ▁&& ▁whence ▁!= ▁SEEK _ SET ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁whence ▁== ▁SEEK _ CUR ▁) ▁{ ▁offset 1 ▁= ▁pos ▁+ ▁( ▁s ▁-> ▁buf _ ptr ▁- ▁s ▁-> ▁buffer ▁) ▁; ▁if ▁( ▁offset ▁== ▁0 ▁) ▁return ▁offset 1 ▁; ▁offset ▁+= ▁offset 1 ▁; ▁} ▁offset 1 ▁= ▁offset ▁- ▁pos ▁; ▁if ▁( ▁! ▁s ▁-> ▁must _ flush ▁&& ▁offset 1 ▁>= ▁0 ▁&& ▁offset 1 ▁< ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buffer ▁) ▁) ▁{ ▁s ▁-> ▁buf _ ptr ▁= ▁s ▁-> ▁buffer ▁+ ▁offset 1 ▁; ▁} ▁else ▁if ▁( ▁( ▁! ▁( ▁s ▁-> ▁seek able ▁& ▁AVIO _ SEEK ABLE _ NORMAL ▁) ▁|| ▁offset 1 ▁<= ▁s ▁-> ▁buf _ end ▁+ ▁SHORT _ SEEK _ THRESHOLD ▁- ▁s ▁-> ▁buffer ▁) ▁&& ▁! ▁s ▁-> ▁write _ flag ▁&& ▁offset 1 ▁>= ▁0 ▁&& ▁( ▁whence ▁!= ▁SEEK _ END ▁|| ▁force ▁) ▁) ▁{ ▁while ▁( ▁s ▁-> ▁pos ▁< ▁offset ▁&& ▁! ▁s ▁-> ▁eof _ reached ▁) ▁fill _ buffer ▁( ▁s ▁) ▁; ▁if ▁( ▁s ▁-> ▁eof _ reached ▁) ▁return ▁AVERROR _ EOF ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁s ▁-> ▁buf _ end ▁+ ▁offset ▁- ▁s ▁-> ▁pos ▁; ▁} ▁else ▁{ ▁int 64_ t ▁res ▁; ▁if ▁( ▁s ▁-> ▁write _ flag ▁) ▁{ ▁flush _ buffer ▁( ▁s ▁) ▁; ▁s ▁-> ▁must _ flush ▁= ▁1 ▁; ▁} ▁if ▁( ▁! ▁s ▁-> ▁seek ▁) ▁return ▁AVERROR ▁( ▁E PIPE ▁) ▁; ▁if ▁( ▁( ▁res ▁= ▁s ▁-> ▁seek ▁( ▁s ▁-> ▁opaque ▁, ▁offset ▁, ▁SEEK _ SET ▁) ▁) ▁< ▁0 ▁) ▁return ▁res ▁; ▁if ▁( ▁! ▁s ▁-> ▁write _ flag ▁) ▁s ▁-> ▁buf _ end ▁= ▁s ▁-> ▁buffer ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁s ▁-> ▁pos ▁= ▁offset ▁; ▁} ▁s ▁-> ▁eof _ reached ▁= ▁0 ▁; ▁return ▁offset ▁; ▁}	0
▁int ▁tls _ collect _ extensions ▁( ▁PACKET ▁* ▁packet ▁, ▁RAW _ EXTENSION ▁* ▁* ▁res ▁, ▁size _ t ▁* ▁num found ▁, ▁int ▁* ▁ad ▁) ▁{ ▁PACKET ▁extensions ▁= ▁* ▁packet ▁; ▁size _ t ▁num _ extensions ▁= ▁0 ▁, ▁i ▁= ▁0 ▁; ▁RAW _ EXTENSION ▁* ▁raw _ extensions ▁= ▁NULL ▁; ▁while ▁( ▁PACKET _ remaining ▁( ▁& ▁extensions ▁) ▁> ▁0 ▁) ▁{ ▁unsigned ▁int ▁type ▁; ▁PACKET ▁extension ▁; ▁if ▁( ▁! ▁PACKET _ get _ net _2 ▁( ▁& ▁extensions ▁, ▁& ▁type ▁) ▁|| ▁! ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁& ▁extensions ▁, ▁& ▁extension ▁) ▁) ▁{ ▁* ▁ad ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁goto ▁err ▁; ▁} ▁num _ extensions ▁++ ▁; ▁} ▁if ▁( ▁num _ extensions ▁> ▁0 ▁) ▁{ ▁raw _ extensions ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁raw _ extensions ▁) ▁* ▁num _ extensions ▁) ▁; ▁if ▁( ▁raw _ extensions ▁== ▁NULL ▁) ▁{ ▁* ▁ad ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PARSE _ RAW _ EXTENSIONS ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ extensions ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁PACKET _ get _ net _2 ▁( ▁packet ▁, ▁& ▁raw _ extensions ▁[ ▁i ▁] ▁. ▁type ▁) ▁|| ▁! ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁packet ▁, ▁& ▁raw _ extensions ▁[ ▁i ▁] ▁. ▁data ▁) ▁) ▁{ ▁* ▁ad ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PARSE _ RAW _ EXTENSIONS ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁if ▁( ▁PACKET _ remaining ▁( ▁packet ▁) ▁!= ▁0 ▁) ▁{ ▁* ▁ad ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PARSE _ RAW _ EXTENSIONS ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁err ▁; ▁} ▁qsort ▁( ▁raw _ extensions ▁, ▁num _ extensions ▁, ▁sizeof ▁( ▁* ▁raw _ extensions ▁) ▁, ▁compare _ extensions ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁num _ extensions ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁raw _ extensions ▁[ ▁i ▁- ▁1 ▁] ▁. ▁type ▁== ▁raw _ extensions ▁[ ▁i ▁] ▁. ▁type ▁) ▁{ ▁* ▁ad ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁goto ▁err ▁; ▁} ▁} ▁} ▁* ▁res ▁= ▁raw _ extensions ▁; ▁* ▁num found ▁= ▁num _ extensions ▁; ▁return ▁1 ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁raw _ extensions ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁CRYPTO _ set _ ex _ data ▁( ▁CRYPTO _ EX _ DATA ▁* ▁ad ▁, ▁int ▁idx ▁, ▁void ▁* ▁val ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁ad ▁-> ▁sk ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ad ▁-> ▁sk ▁= ▁sk _ void _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁CRYPTO err ▁( ▁CRYPTO _ F _ CRYPTO _ SET _ EX _ DATA ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁sk _ void _ num ▁( ▁ad ▁-> ▁sk ▁) ▁; ▁i ▁<= ▁idx ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁! ▁sk _ void _ push ▁( ▁ad ▁-> ▁sk ▁, ▁NULL ▁) ▁) ▁{ ▁CRYPTO err ▁( ▁CRYPTO _ F _ CRYPTO _ SET _ EX _ DATA ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁sk _ void _ set ▁( ▁ad ▁-> ▁sk ▁, ▁idx ▁, ▁val ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁int ▁av _ grow _ packet ▁( ▁AVPacket ▁* ▁pkt ▁, ▁int ▁grow _ by ▁) ▁{ ▁int ▁new _ size ▁; ▁av _ assert 0 ▁( ▁( ▁unsigned ▁) ▁pkt ▁-> ▁size ▁<= ▁INT _ MAX ▁- ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁pkt ▁-> ▁size ▁) ▁return ▁av _ new _ packet ▁( ▁pkt ▁, ▁grow _ by ▁) ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁grow _ by ▁> ▁INT _ MAX ▁- ▁( ▁pkt ▁-> ▁size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁) ▁return ▁-1 ▁; ▁new _ size ▁= ▁pkt ▁-> ▁size ▁+ ▁grow _ by ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁; ▁if ▁( ▁pkt ▁-> ▁buf ▁) ▁{ ▁int ▁ret ▁= ▁av _ buffer _ realloc ▁( ▁& ▁pkt ▁-> ▁buf ▁, ▁new _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁else ▁{ ▁pkt ▁-> ▁buf ▁= ▁av _ buffer _ alloc ▁( ▁new _ size ▁) ▁; ▁if ▁( ▁! ▁pkt ▁-> ▁buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁pkt ▁-> ▁buf ▁-> ▁data ▁, ▁pkt ▁-> ▁data ▁, ▁FF MIN ▁( ▁pkt ▁-> ▁size ▁, ▁pkt ▁-> ▁size ▁+ ▁grow _ by ▁) ▁) ▁; ▁# if ▁FF _ API _ DES TRUCT _ PACKET ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁pkt ▁-> ▁destruct ▁= ▁dummy _ destruct _ packet ▁; ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁# endif ▁} ▁pkt ▁-> ▁data ▁= ▁pkt ▁-> ▁buf ▁-> ▁data ▁; ▁pkt ▁-> ▁size ▁+= ▁grow _ by ▁; ▁memset ▁( ▁pkt ▁-> ▁data ▁+ ▁pkt ▁-> ▁size ▁, ▁0 ▁, ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁add _ short s _ metadata ▁( ▁int ▁count ▁, ▁const ▁char ▁* ▁name ▁, ▁const ▁char ▁* ▁sep ▁, ▁T iff Context ▁* ▁s ▁, ▁AVFrame ▁* ▁frame ▁) ▁{ ▁char ▁* ▁ap ▁; ▁int ▁i ▁; ▁int 16_ t ▁* ▁sp ▁; ▁if ▁( ▁count ▁>= ▁INT _ MAX ▁/ ▁sizeof ▁( ▁int 16_ t ▁) ▁|| ▁count ▁<= ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁count ▁* ▁sizeof ▁( ▁int 16_ t ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁sp ▁= ▁av _ malloc ▁( ▁count ▁* ▁sizeof ▁( ▁int 16_ t ▁) ▁) ▁; ▁if ▁( ▁! ▁sp ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁sp ▁[ ▁i ▁] ▁= ▁t get _ short ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁le ▁) ▁; ▁ap ▁= ▁short s 2 str ▁( ▁sp ▁, ▁count ▁, ▁sep ▁) ▁; ▁av _ freep ▁( ▁& ▁sp ▁) ▁; ▁if ▁( ▁! ▁ap ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁av _ dict _ set ▁( ▁avpriv _ frame _ get _ met ad at ap ▁( ▁frame ▁) ▁, ▁name ▁, ▁ap ▁, ▁AV _ DICT _ DONT _ STR DUP _ VAL ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁X 509_ NAME ▁* ▁do _ subject ▁( ▁char ▁* ▁subject ▁) ▁{ ▁size _ t ▁buflen ▁= ▁strlen ▁( ▁subject ▁) ▁+ ▁1 ▁; ▁char ▁* ▁buf ▁= ▁malloc ▁( ▁buflen ▁) ▁; ▁size _ t ▁max _ ne ▁= ▁buflen ▁/ ▁2 ▁+ ▁1 ▁; ▁char ▁* ▁* ▁ne _ types ▁= ▁malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁char ▁* ▁* ▁ne _ values ▁= ▁malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁char ▁* ▁sp ▁= ▁subject ▁, ▁* ▁bp ▁= ▁buf ▁; ▁int ▁i ▁, ▁ne _ num ▁= ▁0 ▁; ▁X 509_ NAME ▁* ▁n ▁= ▁NULL ▁; ▁int ▁nid ▁; ▁if ▁( ▁! ▁buf ▁|| ▁! ▁ne _ types ▁|| ▁! ▁ne _ values ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" malloc error \ n " ▁) ▁; ▁goto ▁error 0 ▁; ▁} ▁if ▁( ▁* ▁subject ▁!= ▁' ▁' ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Subject does not start with ' / ' .\ n " ▁) ▁; ▁goto ▁error 0 ▁; ▁} ▁sp ▁++ ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁ne _ types ▁[ ▁ne _ num ▁] ▁= ▁bp ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁if ▁( ▁* ▁sp ▁== ▁' ▁\\ ▁' ▁) ▁if ▁( ▁* ▁++ ▁sp ▁) ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" escape character at end of string \ n " ▁) ▁; ▁goto ▁error 0 ▁; ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁) ▁{ ▁sp ▁++ ▁; ▁* ▁bp ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁break ▁; ▁} ▁else ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁} ▁if ▁( ▁! ▁* ▁sp ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" end of string en countered while processing typeof subject name element #% d \ n " ▁, ▁ne _ num ▁) ▁; ▁goto ▁error 0 ▁; ▁} ▁ne _ values ▁[ ▁ne _ num ▁] ▁= ▁bp ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁if ▁( ▁* ▁sp ▁== ▁' ▁\\ ▁' ▁) ▁if ▁( ▁* ▁++ ▁sp ▁) ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" escape character at end of string \ n " ▁) ▁; ▁goto ▁error 0 ▁; ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁) ▁{ ▁sp ▁++ ▁; ▁* ▁bp ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁break ▁; ▁} ▁else ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁} ▁* ▁bp ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁ne _ num ▁++ ▁; ▁} ▁if ▁( ▁! ▁( ▁n ▁= ▁X 509_ NAME _ new ▁( ▁) ▁) ▁) ▁goto ▁error 0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ne _ num ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁nid ▁= ▁OBJ _ txt 2 nid ▁( ▁ne _ types ▁[ ▁i ▁] ▁) ▁) ▁== ▁NID _ undef ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Subject Attribute % sh as no known NID , skipped \ n " ▁, ▁ne _ types ▁[ ▁i ▁] ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁! ▁* ▁ne _ values ▁[ ▁i ▁] ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" No value provide df or Subject Attribute % s , skipped \ n " ▁, ▁ne _ types ▁[ ▁i ▁] ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁! ▁X 509_ NAME _ add _ entry _ by _ NID ▁( ▁n ▁, ▁nid ▁, ▁MB STRING _ ASC ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁ne _ values ▁[ ▁i ▁] ▁, ▁-1 ▁, ▁-1 ▁, ▁0 ▁) ▁) ▁goto ▁error 1 ▁; ▁} ▁free ▁( ▁ne _ values ▁) ▁; ▁free ▁( ▁ne _ types ▁) ▁; ▁free ▁( ▁buf ▁) ▁; ▁return ▁n ▁; ▁error 1 ▁: ▁X 509_ NAME _ free ▁( ▁n ▁) ▁; ▁error 0 ▁: ▁free ▁( ▁ne _ values ▁) ▁; ▁free ▁( ▁ne _ types ▁) ▁; ▁free ▁( ▁buf ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁inline ▁int ▁sym _ quant ▁( ▁int ▁c ▁, ▁int ▁e ▁, ▁int ▁levels ▁) ▁{ ▁int ▁v ▁= ▁( ▁( ▁( ▁( ▁levels ▁* ▁c ▁) ▁>> ▁( ▁24 ▁- ▁e ▁) ▁) ▁+ ▁1 ▁) ▁>> ▁1 ▁) ▁+ ▁( ▁levels ▁>> ▁1 ▁) ▁; ▁av _ assert 2 ▁( ▁v ▁>= ▁0 ▁&& ▁v ▁< ▁levels ▁) ▁; ▁return ▁v ▁; ▁}	1
▁static ▁void ▁adjust _ frame _ information ▁( ▁Channel Element ▁* ▁c pe ▁, ▁int ▁chans ▁) ▁{ ▁int ▁i ▁, ▁w ▁, ▁w 2 ▁, ▁g ▁, ▁ch ▁; ▁int ▁start ▁, ▁max s fb ▁, ▁c max s fb ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁chans ▁; ▁ch ▁++ ▁) ▁{ ▁Individual Channel Stream ▁* ▁ics ▁= ▁& ▁c pe ▁-> ▁ch ▁[ ▁ch ▁] ▁. ▁ics ▁; ▁start ▁= ▁0 ▁; ▁max s fb ▁= ▁0 ▁; ▁c pe ▁-> ▁ch ▁[ ▁ch ▁] ▁. ▁pulse ▁. ▁num _ pulse ▁= ▁0 ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁ics ▁-> ▁num _ windows ▁* ▁16 ▁; ▁w ▁+= ▁16 ▁) ▁{ ▁for ▁( ▁g ▁= ▁0 ▁; ▁g ▁< ▁ics ▁-> ▁num _ sw b ▁; ▁g ▁++ ▁) ▁{ ▁if ▁( ▁c pe ▁-> ▁common _ window ▁&& ▁! ▁ch ▁&& ▁c pe ▁-> ▁ms _ mask ▁[ ▁w ▁+ ▁g ▁] ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ics ▁-> ▁sw b _ sizes ▁[ ▁g ▁] ▁; ▁i ▁++ ▁) ▁{ ▁c pe ▁-> ▁ch ▁[ ▁0 ▁] ▁. ▁coeffs ▁[ ▁start ▁+ ▁i ▁] ▁= ▁( ▁c pe ▁-> ▁ch ▁[ ▁0 ▁] ▁. ▁coeffs ▁[ ▁start ▁+ ▁i ▁] ▁+ ▁c pe ▁-> ▁ch ▁[ ▁1 ▁] ▁. ▁coeffs ▁[ ▁start ▁+ ▁i ▁] ▁) ▁/ ▁2.0 ▁; ▁c pe ▁-> ▁ch ▁[ ▁1 ▁] ▁. ▁coeffs ▁[ ▁start ▁+ ▁i ▁] ▁= ▁c pe ▁-> ▁ch ▁[ ▁0 ▁] ▁. ▁coeffs ▁[ ▁start ▁+ ▁i ▁] ▁- ▁c pe ▁-> ▁ch ▁[ ▁1 ▁] ▁. ▁coeffs ▁[ ▁start ▁+ ▁i ▁] ▁; ▁} ▁} ▁start ▁+= ▁ics ▁-> ▁sw b _ sizes ▁[ ▁g ▁] ▁; ▁} ▁for ▁( ▁c max s fb ▁= ▁ics ▁-> ▁num _ sw b ▁; ▁c max s fb ▁> ▁0 ▁&& ▁c pe ▁-> ▁ch ▁[ ▁ch ▁] ▁. ▁zero es ▁[ ▁w ▁+ ▁c max s fb ▁- ▁1 ▁] ▁; ▁c max s fb ▁-- ▁) ▁; ▁max s fb ▁= ▁FF MAX ▁( ▁max s fb ▁, ▁c max s fb ▁) ▁; ▁} ▁ics ▁-> ▁max _ s fb ▁= ▁max s fb ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁ics ▁-> ▁num _ windows ▁; ▁w ▁+= ▁ics ▁-> ▁group _ len ▁[ ▁w ▁] ▁) ▁{ ▁for ▁( ▁g ▁= ▁0 ▁; ▁g ▁< ▁ics ▁-> ▁max _ s fb ▁; ▁g ▁++ ▁) ▁{ ▁i ▁= ▁1 ▁; ▁for ▁( ▁w 2 ▁= ▁w ▁; ▁w 2 ▁< ▁w ▁+ ▁ics ▁-> ▁group _ len ▁[ ▁w ▁] ▁; ▁w 2 ▁++ ▁) ▁{ ▁if ▁( ▁! ▁c pe ▁-> ▁ch ▁[ ▁ch ▁] ▁. ▁zero es ▁[ ▁w 2 ▁* ▁16 ▁+ ▁g ▁] ▁) ▁{ ▁i ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁c pe ▁-> ▁ch ▁[ ▁ch ▁] ▁. ▁zero es ▁[ ▁w ▁* ▁16 ▁+ ▁g ▁] ▁= ▁i ▁; ▁} ▁} ▁} ▁if ▁( ▁chans ▁> ▁1 ▁&& ▁c pe ▁-> ▁common _ window ▁) ▁{ ▁Individual Channel Stream ▁* ▁ics 0 ▁= ▁& ▁c pe ▁-> ▁ch ▁[ ▁0 ▁] ▁. ▁ics ▁; ▁Individual Channel Stream ▁* ▁ics 1 ▁= ▁& ▁c pe ▁-> ▁ch ▁[ ▁1 ▁] ▁. ▁ics ▁; ▁int ▁msc ▁= ▁0 ▁; ▁ics 0 ▁-> ▁max _ s fb ▁= ▁FF MAX ▁( ▁ics 0 ▁-> ▁max _ s fb ▁, ▁ics 1 ▁-> ▁max _ s fb ▁) ▁; ▁ics 1 ▁-> ▁max _ s fb ▁= ▁ics 0 ▁-> ▁max _ s fb ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁ics 0 ▁-> ▁num _ windows ▁* ▁16 ▁; ▁w ▁+= ▁16 ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ics 0 ▁-> ▁max _ s fb ▁; ▁i ▁++ ▁) ▁if ▁( ▁c pe ▁-> ▁ms _ mask ▁[ ▁w ▁+ ▁i ▁] ▁) ▁msc ▁++ ▁; ▁if ▁( ▁msc ▁== ▁0 ▁|| ▁ics 0 ▁-> ▁max _ s fb ▁== ▁0 ▁) ▁c pe ▁-> ▁ms _ mode ▁= ▁0 ▁; ▁else ▁c pe ▁-> ▁ms _ mode ▁= ▁msc ▁< ▁ics 0 ▁-> ▁max _ s fb ▁* ▁ics 0 ▁-> ▁num _ windows ▁? ▁1 ▁: ▁2 ▁; ▁} ▁}	1
▁static ▁size _ t ▁sh _ get list ▁( ▁char ▁* ▁ptr ▁) ▁{ ▁ossl _ ssize _ t ▁list ▁= ▁sh ▁. ▁fre elist _ size ▁- ▁1 ▁; ▁size _ t ▁bit ▁= ▁( ▁sh ▁. ▁arena _ size ▁+ ▁ptr ▁- ▁sh ▁. ▁arena ▁) ▁/ ▁sh ▁. ▁min size ▁; ▁for ▁( ▁; ▁bit ▁; ▁bit ▁>>= ▁1 ▁, ▁list ▁-- ▁) ▁{ ▁if ▁( ▁TEST BIT ▁( ▁sh ▁. ▁bit table ▁, ▁bit ▁) ▁) ▁break ▁; ▁OPENSSL _ assert ▁( ▁( ▁bit ▁& ▁1 ▁) ▁== ▁0 ▁) ▁; ▁} ▁return ▁list ▁; ▁}	0
▁static ▁void ▁list _ type ▁( ▁FUNC _ TYPE ▁ft ▁, ▁int ▁one ▁) ▁{ ▁FUNCTION ▁* ▁fp ▁; ▁int ▁i ▁= ▁0 ▁; ▁DISPLAY _ COLUMNS ▁dc ▁= ▁{ ▁0 ▁} ▁; ▁if ▁( ▁! ▁one ▁) ▁calculate _ columns ▁( ▁& ▁dc ▁) ▁; ▁for ▁( ▁fp ▁= ▁functions ▁; ▁fp ▁-> ▁name ▁!= ▁NULL ▁; ▁fp ▁++ ▁) ▁{ ▁if ▁( ▁fp ▁-> ▁type ▁!= ▁ft ▁) ▁continue ▁; ▁if ▁( ▁one ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% s \ n " ▁, ▁fp ▁-> ▁name ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁i ▁% ▁dc ▁. ▁columns ▁== ▁0 ▁&& ▁i ▁> ▁0 ▁) ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"\ n " ▁) ▁; ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% - * s " ▁, ▁dc ▁. ▁width ▁, ▁fp ▁-> ▁name ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁if ▁( ▁! ▁one ▁) ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"\ n \ n " ▁) ▁; ▁}	0
▁static ▁int ▁write _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁W VM ux Context ▁* ▁wc ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVCodecContext ▁* ▁codec ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁uint 64_ t ▁size ▁; ▁uint 32_ t ▁flags ▁; ▁uint 32_ t ▁left ▁= ▁pkt ▁-> ▁size ▁; ▁uint 8_ t ▁* ▁ptr ▁= ▁pkt ▁-> ▁data ▁; ▁int ▁off ▁= ▁codec ▁-> ▁channels ▁> ▁2 ▁? ▁4 ▁: ▁0 ▁; ▁wc ▁-> ▁duration ▁+= ▁pkt ▁-> ▁duration ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁" w v pk " ▁) ▁; ▁if ▁( ▁off ▁) ▁{ ▁size ▁= ▁AV _ RL 32 ▁( ▁pkt ▁-> ▁data ▁) ▁; ▁if ▁( ▁size ▁<= ▁12 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁size ▁-= ▁12 ▁; ▁} ▁else ▁{ ▁size ▁= ▁pkt ▁-> ▁size ▁; ▁} ▁if ▁( ▁size ▁+ ▁off ▁> ▁left ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁size ▁+ ▁12 ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁0 x 410 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁-1 ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁pkt ▁-> ▁pts ▁) ▁; ▁ptr ▁+= ▁off ▁; ▁left ▁-= ▁off ▁; ▁flags ▁= ▁AV _ RL 32 ▁( ▁ptr ▁+ ▁4 ▁) ▁; ▁avio _ write ▁( ▁pb ▁, ▁ptr ▁, ▁size ▁) ▁; ▁ptr ▁+= ▁size ▁; ▁left ▁-= ▁size ▁; ▁while ▁( ▁! ▁( ▁flags ▁& ▁W V _ END _ BLOCK ▁) ▁&& ▁( ▁left ▁>= ▁4 ▁+ ▁W V _ EXTRA _ SIZE ▁) ▁) ▁{ ▁ff io _ w four cc ▁( ▁pb ▁, ▁" w v pk " ▁) ▁; ▁size ▁= ▁AV _ RL 32 ▁( ▁ptr ▁) ▁; ▁ptr ▁+= ▁4 ▁; ▁left ▁-= ▁4 ▁; ▁if ▁( ▁size ▁< ▁24 ▁|| ▁size ▁- ▁24 ▁> ▁left ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁size ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁0 x 410 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁-1 ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁pkt ▁-> ▁pts ▁) ▁; ▁flags ▁= ▁AV _ RL 32 ▁( ▁ptr ▁+ ▁4 ▁) ▁; ▁avio _ write ▁( ▁pb ▁, ▁ptr ▁, ▁W V _ EXTRA _ SIZE ▁) ▁; ▁ptr ▁+= ▁W V _ EXTRA _ SIZE ▁; ▁left ▁-= ▁W V _ EXTRA _ SIZE ▁; ▁avio _ write ▁( ▁pb ▁, ▁ptr ▁, ▁size ▁- ▁24 ▁) ▁; ▁ptr ▁+= ▁size ▁- ▁24 ▁; ▁left ▁-= ▁size ▁- ▁24 ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁decode _ dc _ progress ive ▁( ▁MJ peg Decode Context ▁* ▁s ▁, ▁int 16_ t ▁* ▁block ▁, ▁int ▁component ▁, ▁int ▁dc _ index ▁, ▁int 16_ t ▁* ▁quant _ matrix ▁, ▁int ▁Al ▁) ▁{ ▁int ▁val ▁; ▁s ▁-> ▁b dsp ▁. ▁clear _ block ▁( ▁block ▁) ▁; ▁val ▁= ▁m jpeg _ decode _ dc ▁( ▁s ▁, ▁dc _ index ▁) ▁; ▁if ▁( ▁val ▁== ▁0 xfffff ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" err ord c \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁val ▁= ▁( ▁val ▁* ▁( ▁quant _ matrix ▁[ ▁0 ▁] ▁<< ▁Al ▁) ▁) ▁+ ▁s ▁-> ▁last _ dc ▁[ ▁component ▁] ▁; ▁s ▁-> ▁last _ dc ▁[ ▁component ▁] ▁= ▁val ▁; ▁block ▁[ ▁0 ▁] ▁= ▁val ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁encode _ ex pon ents _ blk _ ch ▁( ▁uint 8_ t ▁* ▁exp ▁, ▁int ▁nb _ ex ps ▁, ▁int ▁exp _ strategy ▁, ▁uint 8_ t ▁* ▁num _ exp _ groups ▁) ▁{ ▁int ▁group _ size ▁, ▁nb _ groups ▁, ▁i ▁, ▁j ▁, ▁k ▁, ▁exp _ min ▁; ▁group _ size ▁= ▁exp _ strategy ▁+ ▁( ▁exp _ strategy ▁== ▁EXP _ D 45 ▁) ▁; ▁* ▁num _ exp _ groups ▁= ▁( ▁nb _ ex ps ▁+ ▁( ▁group _ size ▁* ▁3 ▁) ▁- ▁4 ▁) ▁/ ▁( ▁3 ▁* ▁group _ size ▁) ▁; ▁nb _ groups ▁= ▁* ▁num _ exp _ groups ▁* ▁3 ▁; ▁if ▁( ▁exp _ strategy ▁> ▁EXP _ D 15 ▁) ▁{ ▁k ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁nb _ groups ▁; ▁i ▁++ ▁) ▁{ ▁exp _ min ▁= ▁exp ▁[ ▁k ▁] ▁; ▁assert ▁( ▁exp _ min ▁>= ▁0 ▁&& ▁exp _ min ▁<= ▁24 ▁) ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁group _ size ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁exp ▁[ ▁k ▁+ ▁j ▁] ▁< ▁exp _ min ▁) ▁exp _ min ▁= ▁exp ▁[ ▁k ▁+ ▁j ▁] ▁; ▁} ▁exp ▁[ ▁i ▁] ▁= ▁exp _ min ▁; ▁k ▁+= ▁group _ size ▁; ▁} ▁} ▁if ▁( ▁exp ▁[ ▁0 ▁] ▁> ▁15 ▁) ▁exp ▁[ ▁0 ▁] ▁= ▁15 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁nb _ groups ▁; ▁i ▁++ ▁) ▁exp ▁[ ▁i ▁] ▁= ▁FF MIN ▁( ▁exp ▁[ ▁i ▁] ▁, ▁exp ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁2 ▁) ▁; ▁i ▁-- ▁; ▁while ▁( ▁-- ▁i ▁>= ▁0 ▁) ▁exp ▁[ ▁i ▁] ▁= ▁FF MIN ▁( ▁exp ▁[ ▁i ▁] ▁, ▁exp ▁[ ▁i ▁+ ▁1 ▁] ▁+ ▁2 ▁) ▁; ▁if ▁( ▁exp _ strategy ▁> ▁EXP _ D 15 ▁) ▁{ ▁k ▁= ▁nb _ groups ▁* ▁group _ size ▁; ▁for ▁( ▁i ▁= ▁nb _ groups ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁group _ size ▁; ▁j ▁++ ▁) ▁exp ▁[ ▁k ▁- ▁j ▁] ▁= ▁exp ▁[ ▁i ▁] ▁; ▁k ▁-= ▁group _ size ▁; ▁} ▁} ▁}	0
▁int ▁engine _ unlocked _ finish ▁( ▁ENGINE ▁* ▁e ▁, ▁int ▁unlock _ for _ handlers ▁) ▁{ ▁int ▁to _ return ▁= ▁1 ▁; ▁e ▁-> ▁funct _ ref ▁-- ▁; ▁engine _ ref _ debug ▁( ▁e ▁, ▁1 ▁, ▁-1 ▁) ▁; ▁if ▁( ▁( ▁e ▁-> ▁funct _ ref ▁== ▁0 ▁) ▁&& ▁e ▁-> ▁finish ▁) ▁{ ▁if ▁( ▁unlock _ for _ handlers ▁) ▁CRYPTO _ w _ unlock ▁( ▁CRYPTO _ LOCK _ ENGINE ▁) ▁; ▁to _ return ▁= ▁e ▁-> ▁finish ▁( ▁e ▁) ▁; ▁if ▁( ▁unlock _ for _ handlers ▁) ▁CRYPTO _ w _ lock ▁( ▁CRYPTO _ LOCK _ ENGINE ▁) ▁; ▁if ▁( ▁! ▁to _ return ▁) ▁return ▁0 ▁; ▁} ▁# ifdef ▁REF _ CHECK ▁if ▁( ▁e ▁-> ▁funct _ ref ▁< ▁0 ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" ENGINE _ finish , bad functional reference count \ n " ▁) ▁; ▁abort ▁( ▁) ▁; ▁} ▁# endif ▁if ▁( ▁! ▁engine _ free _ util ▁( ▁e ▁, ▁0 ▁) ▁) ▁{ ▁ENGINE err ▁( ▁ENGINE _ F _ ENGINE _ UNLOCKED _ FINISH ▁, ▁ENGINE _ R _ FINISH _ FAILED ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁to _ return ▁; ▁}	1
▁SSL ▁* ▁SSL _ new ▁( ▁SSL _ CTX ▁* ▁ctx ▁) ▁{ ▁SSL ▁* ▁s ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ NEW ▁, ▁SSL _ R _ NULL _ SSL _ CTX ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁method ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ NEW ▁, ▁SSL _ R _ SSL _ CTX _ HAS _ NO _ DEFAULT _ SSL _ VERSION ▁) ▁; ▁return ▁NULL ▁; ▁} ▁s ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁s ▁) ▁) ▁; ▁if ▁( ▁s ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁s ▁-> ▁references ▁= ▁1 ▁; ▁s ▁-> ▁lock ▁= ▁CRYPTO _ THREAD _ lock _ new ▁( ▁) ▁; ▁if ▁( ▁s ▁-> ▁lock ▁== ▁NULL ▁) ▁{ ▁OPENSSL _ free ▁( ▁s ▁) ▁; ▁s ▁= ▁NULL ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁RAND _ get _ rand _ method ▁( ▁) ▁== ▁RAND _ Open SSL ▁( ▁) ▁) ▁{ ▁s ▁-> ▁dr bg ▁= ▁RAND _ DR BG _ new ▁( ▁RAND _ DR BG _ NID ▁, ▁0 ▁, ▁RAND _ DR BG _ get 0_ public ▁( ▁) ▁) ▁; ▁if ▁( ▁s ▁-> ▁dr bg ▁== ▁NULL ▁|| ▁RAND _ DR BG _ instantiate ▁( ▁s ▁-> ▁dr bg ▁, ▁( ▁const ▁unsigned ▁char ▁* ▁) ▁SSL _ version _ str ▁, ▁sizeof ▁( ▁SSL _ version _ str ▁) ▁- ▁1 ▁) ▁== ▁0 ▁) ▁goto ▁err ▁; ▁} ▁RECORD _ LAYER _ init ▁( ▁& ▁s ▁-> ▁r layer ▁, ▁s ▁) ▁; ▁s ▁-> ▁options ▁= ▁ctx ▁-> ▁options ▁; ▁s ▁-> ▁d ane ▁. ▁flags ▁= ▁ctx ▁-> ▁d ane ▁. ▁flags ▁; ▁s ▁-> ▁min _ proto _ version ▁= ▁ctx ▁-> ▁min _ proto _ version ▁; ▁s ▁-> ▁max _ proto _ version ▁= ▁ctx ▁-> ▁max _ proto _ version ▁; ▁s ▁-> ▁mode ▁= ▁ctx ▁-> ▁mode ▁; ▁s ▁-> ▁max _ cert _ list ▁= ▁ctx ▁-> ▁max _ cert _ list ▁; ▁s ▁-> ▁max _ early _ data ▁= ▁ctx ▁-> ▁max _ early _ data ▁; ▁s ▁-> ▁tls 13_ c iphers u ites ▁= ▁sk _ SSL _ CIPHER _ dup ▁( ▁ctx ▁-> ▁tls 13_ c iphers u ites ▁) ▁; ▁if ▁( ▁s ▁-> ▁tls 13_ c iphers u ites ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁s ▁-> ▁cert ▁= ▁ssl _ cert _ dup ▁( ▁ctx ▁-> ▁cert ▁) ▁; ▁if ▁( ▁s ▁-> ▁cert ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁RECORD _ LAYER _ set _ read _ ahead ▁( ▁& ▁s ▁-> ▁r layer ▁, ▁ctx ▁-> ▁read _ ahead ▁) ▁; ▁s ▁-> ▁msg _ callback ▁= ▁ctx ▁-> ▁msg _ callback ▁; ▁s ▁-> ▁msg _ callback _ arg ▁= ▁ctx ▁-> ▁msg _ callback _ arg ▁; ▁s ▁-> ▁verify _ mode ▁= ▁ctx ▁-> ▁verify _ mode ▁; ▁s ▁-> ▁not _ res um able _ session _ cb ▁= ▁ctx ▁-> ▁not _ res um able _ session _ cb ▁; ▁s ▁-> ▁record _ padding _ cb ▁= ▁ctx ▁-> ▁record _ padding _ cb ▁; ▁s ▁-> ▁record _ padding _ arg ▁= ▁ctx ▁-> ▁record _ padding _ arg ▁; ▁s ▁-> ▁block _ padding ▁= ▁ctx ▁-> ▁block _ padding ▁; ▁s ▁-> ▁sid _ ctx _ length ▁= ▁ctx ▁-> ▁sid _ ctx _ length ▁; ▁if ▁( ▁! ▁ossl _ assert ▁( ▁s ▁-> ▁sid _ ctx _ length ▁<= ▁sizeof ▁( ▁s ▁-> ▁sid _ ctx ▁) ▁) ▁) ▁goto ▁err ▁; ▁memcpy ▁( ▁& ▁s ▁-> ▁sid _ ctx ▁, ▁& ▁ctx ▁-> ▁sid _ ctx ▁, ▁sizeof ▁( ▁s ▁-> ▁sid _ ctx ▁) ▁) ▁; ▁s ▁-> ▁verify _ callback ▁= ▁ctx ▁-> ▁default _ verify _ callback ▁; ▁s ▁-> ▁generate _ session _ id ▁= ▁ctx ▁-> ▁generate _ session _ id ▁; ▁s ▁-> ▁param ▁= ▁X 509_ VERIFY _ PARAM _ new ▁( ▁) ▁; ▁if ▁( ▁s ▁-> ▁param ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁X 509_ VERIFY _ PARAM _ inherit ▁( ▁s ▁-> ▁param ▁, ▁ctx ▁-> ▁param ▁) ▁; ▁s ▁-> ▁quiet _ shutdown ▁= ▁ctx ▁-> ▁quiet _ shutdown ▁; ▁s ▁-> ▁ext ▁. ▁max _ fragment _ len _ mode ▁= ▁ctx ▁-> ▁ext ▁. ▁max _ fragment _ len _ mode ▁; ▁s ▁-> ▁max _ send _ fragment ▁= ▁ctx ▁-> ▁max _ send _ fragment ▁; ▁s ▁-> ▁split _ send _ fragment ▁= ▁ctx ▁-> ▁split _ send _ fragment ▁; ▁s ▁-> ▁max _ pipe lines ▁= ▁ctx ▁-> ▁max _ pipe lines ▁; ▁if ▁( ▁s ▁-> ▁max _ pipe lines ▁> ▁1 ▁) ▁RECORD _ LAYER _ set _ read _ ahead ▁( ▁& ▁s ▁-> ▁r layer ▁, ▁1 ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁default _ read _ buf _ len ▁> ▁0 ▁) ▁SSL _ set _ default _ read _ buffer _ len ▁( ▁s ▁, ▁ctx ▁-> ▁default _ read _ buf _ len ▁) ▁; ▁SSL _ CTX _ up _ ref ▁( ▁ctx ▁) ▁; ▁s ▁-> ▁ctx ▁= ▁ctx ▁; ▁s ▁-> ▁ext ▁. ▁debug _ cb ▁= ▁0 ▁; ▁s ▁-> ▁ext ▁. ▁debug _ arg ▁= ▁NULL ▁; ▁s ▁-> ▁ext ▁. ▁ticket _ expected ▁= ▁0 ▁; ▁s ▁-> ▁ext ▁. ▁status _ type ▁= ▁ctx ▁-> ▁ext ▁. ▁status _ type ▁; ▁s ▁-> ▁ext ▁. ▁status _ expected ▁= ▁0 ▁; ▁s ▁-> ▁ext ▁. ▁oc sp ▁. ▁ids ▁= ▁NULL ▁; ▁s ▁-> ▁ext ▁. ▁oc sp ▁. ▁exts ▁= ▁NULL ▁; ▁s ▁-> ▁ext ▁. ▁oc sp ▁. ▁resp ▁= ▁NULL ▁; ▁s ▁-> ▁ext ▁. ▁oc sp ▁. ▁resp _ len ▁= ▁0 ▁; ▁SSL _ CTX _ up _ ref ▁( ▁ctx ▁) ▁; ▁s ▁-> ▁session _ ctx ▁= ▁ctx ▁; ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁ctx ▁-> ▁ext ▁. ▁ec point formats ▁) ▁{ ▁s ▁-> ▁ext ▁. ▁ec point formats ▁= ▁OPENSSL _ mem dup ▁( ▁ctx ▁-> ▁ext ▁. ▁ec point formats ▁, ▁ctx ▁-> ▁ext ▁. ▁ec point formats _ len ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁ext ▁. ▁ec point formats ▁) ▁goto ▁err ▁; ▁s ▁-> ▁ext ▁. ▁ec point formats _ len ▁= ▁ctx ▁-> ▁ext ▁. ▁ec point formats _ len ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁ext ▁. ▁supported groups ▁) ▁{ ▁s ▁-> ▁ext ▁. ▁supported groups ▁= ▁OPENSSL _ mem dup ▁( ▁ctx ▁-> ▁ext ▁. ▁supported groups ▁, ▁ctx ▁-> ▁ext ▁. ▁supported groups _ len ▁* ▁sizeof ▁( ▁* ▁ctx ▁-> ▁ext ▁. ▁supported groups ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁ext ▁. ▁supported groups ▁) ▁goto ▁err ▁; ▁s ▁-> ▁ext ▁. ▁supported groups _ len ▁= ▁ctx ▁-> ▁ext ▁. ▁supported groups _ len ▁; ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ NEXT PROT ONE G ▁s ▁-> ▁ext ▁. ▁np n ▁= ▁NULL ▁; ▁# endif ▁if ▁( ▁s ▁-> ▁ctx ▁-> ▁ext ▁. ▁al pn ▁) ▁{ ▁s ▁-> ▁ext ▁. ▁al pn ▁= ▁OPENSSL _ malloc ▁( ▁s ▁-> ▁ctx ▁-> ▁ext ▁. ▁al pn _ len ▁) ▁; ▁if ▁( ▁s ▁-> ▁ext ▁. ▁al pn ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁memcpy ▁( ▁s ▁-> ▁ext ▁. ▁al pn ▁, ▁s ▁-> ▁ctx ▁-> ▁ext ▁. ▁al pn ▁, ▁s ▁-> ▁ctx ▁-> ▁ext ▁. ▁al pn _ len ▁) ▁; ▁s ▁-> ▁ext ▁. ▁al pn _ len ▁= ▁s ▁-> ▁ctx ▁-> ▁ext ▁. ▁al pn _ len ▁; ▁} ▁s ▁-> ▁verified _ chain ▁= ▁NULL ▁; ▁s ▁-> ▁verify _ result ▁= ▁X 509_ V _ OK ▁; ▁s ▁-> ▁default _ passwd _ callback ▁= ▁ctx ▁-> ▁default _ passwd _ callback ▁; ▁s ▁-> ▁default _ passwd _ callback _ userdata ▁= ▁ctx ▁-> ▁default _ passwd _ callback _ userdata ▁; ▁s ▁-> ▁method ▁= ▁ctx ▁-> ▁method ▁; ▁s ▁-> ▁key _ update ▁= ▁SSL _ KEY _ UPDATE _ NONE ▁; ▁if ▁( ▁! ▁s ▁-> ▁method ▁-> ▁ssl _ new ▁( ▁s ▁) ▁) ▁goto ▁err ▁; ▁s ▁-> ▁server ▁= ▁( ▁ctx ▁-> ▁method ▁-> ▁ssl _ accept ▁== ▁ssl _ undefined _ function ▁) ▁? ▁0 ▁: ▁1 ▁; ▁if ▁( ▁! ▁SSL _ clear ▁( ▁s ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁CRYPTO _ new _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL ▁, ▁s ▁, ▁& ▁s ▁-> ▁ex _ data ▁) ▁) ▁goto ▁err ▁; ▁# ifndef ▁OPENSSL _ NO _ PS K ▁s ▁-> ▁p sk _ client _ callback ▁= ▁ctx ▁-> ▁p sk _ client _ callback ▁; ▁s ▁-> ▁p sk _ server _ callback ▁= ▁ctx ▁-> ▁p sk _ server _ callback ▁; ▁# endif ▁s ▁-> ▁p sk _ find _ session _ cb ▁= ▁ctx ▁-> ▁p sk _ find _ session _ cb ▁; ▁s ▁-> ▁p sk _ use _ session _ cb ▁= ▁ctx ▁-> ▁p sk _ use _ session _ cb ▁; ▁s ▁-> ▁job ▁= ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ CT ▁if ▁( ▁! ▁SSL _ set _ ct _ validation _ callback ▁( ▁s ▁, ▁ctx ▁-> ▁ct _ validation _ callback ▁, ▁ctx ▁-> ▁ct _ validation _ callback _ arg ▁) ▁) ▁goto ▁err ▁; ▁# endif ▁return ▁s ▁; ▁err ▁: ▁SSL _ free ▁( ▁s ▁) ▁; ▁SSL err ▁( ▁SSL _ F _ SSL _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁int ▁avcodec _ check _ dimensions ▁( ▁void ▁* ▁av _ log _ ctx ▁, ▁unsigned ▁int ▁w ▁, ▁unsigned ▁int ▁h ▁) ▁{ ▁if ▁( ▁( ▁int ▁) ▁w ▁> ▁0 ▁&& ▁( ▁int ▁) ▁h ▁> ▁0 ▁&& ▁( ▁w ▁+ ▁128 ▁) ▁* ▁( ▁uint 64_ t ▁) ▁( ▁h ▁+ ▁128 ▁) ▁< ▁INT _ MAX ▁/ ▁4 ▁) ▁return ▁0 ▁; ▁av _ log ▁( ▁av _ log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" picture size invalid (% ux % u )\ n " ▁, ▁w ▁, ▁h ▁) ▁; ▁return ▁-1 ▁; ▁}	1
▁void ▁sk _ pop _ free ▁( ▁STACK ▁* ▁st ▁, ▁void ▁( ▁* ▁func ▁) ▁( ▁) ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁st ▁== ▁NULL ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁st ▁-> ▁num ▁; ▁i ▁++ ▁) ▁if ▁( ▁st ▁-> ▁data ▁[ ▁i ▁] ▁!= ▁NULL ▁) ▁func ▁( ▁st ▁-> ▁data ▁[ ▁i ▁] ▁) ▁; ▁sk _ free ▁( ▁st ▁) ▁; ▁}	1
▁static ▁char ▁* ▁sec _ alloc _ realloc ▁( ▁BUF _ MEM ▁* ▁str ▁, ▁size _ t ▁len ▁) ▁{ ▁char ▁* ▁ret ▁; ▁ret ▁= ▁OPENSSL _ secure _ malloc ▁( ▁len ▁) ▁; ▁if ▁( ▁str ▁-> ▁data ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁{ ▁memcpy ▁( ▁ret ▁, ▁str ▁-> ▁data ▁, ▁str ▁-> ▁length ▁) ▁; ▁OPENSSL _ secure _ clear _ free ▁( ▁str ▁-> ▁data ▁, ▁str ▁-> ▁length ▁) ▁; ▁str ▁-> ▁data ▁= ▁NULL ▁; ▁} ▁} ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁prob able _ prime ▁( ▁BIGNUM ▁* ▁rnd ▁, ▁int ▁bits ▁, ▁int ▁safe ▁, ▁prime _ t ▁* ▁mods ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁i ▁; ▁BN _ ULONG ▁delta ▁; ▁BN _ ULONG ▁max delta ▁= ▁BN _ MASK 2 ▁- ▁primes ▁[ ▁NU MP R IM ES ▁- ▁1 ▁] ▁; ▁again ▁: ▁if ▁( ▁! ▁BN _ priv _ rand _ ex ▁( ▁rnd ▁, ▁bits ▁, ▁BN _ RAND _ TOP _ TWO ▁, ▁BN _ RAND _ BOTTOM _ ODD ▁, ▁ctx ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁safe ▁&& ▁! ▁BN _ set _ bit ▁( ▁rnd ▁, ▁1 ▁) ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁NU MP R IM ES ▁; ▁i ▁++ ▁) ▁{ ▁BN _ ULONG ▁mod ▁= ▁BN _ mod _ word ▁( ▁rnd ▁, ▁( ▁BN _ ULONG ▁) ▁primes ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁mod ▁== ▁( ▁BN _ ULONG ▁) ▁- ▁1 ▁) ▁return ▁0 ▁; ▁mods ▁[ ▁i ▁] ▁= ▁( ▁prime _ t ▁) ▁mod ▁; ▁} ▁delta ▁= ▁0 ▁; ▁loop ▁: ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁NU MP R IM ES ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁bits ▁<= ▁31 ▁&& ▁delta ▁<= ▁0 x 7 fffffff ▁&& ▁square ▁( ▁primes ▁[ ▁i ▁] ▁) ▁> ▁BN _ get _ word ▁( ▁rnd ▁) ▁+ ▁delta ▁) ▁break ▁; ▁if ▁( ▁safe ▁? ▁( ▁mods ▁[ ▁i ▁] ▁+ ▁delta ▁) ▁% ▁primes ▁[ ▁i ▁] ▁<= ▁1 ▁: ▁( ▁mods ▁[ ▁i ▁] ▁+ ▁delta ▁) ▁% ▁primes ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁delta ▁+= ▁safe ▁? ▁4 ▁: ▁2 ▁; ▁if ▁( ▁delta ▁> ▁max delta ▁) ▁goto ▁again ▁; ▁goto ▁loop ▁; ▁} ▁} ▁if ▁( ▁! ▁BN _ add _ word ▁( ▁rnd ▁, ▁delta ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁BN _ num _ bits ▁( ▁rnd ▁) ▁!= ▁bits ▁) ▁goto ▁again ▁; ▁bn _ check _ top ▁( ▁rnd ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁void ▁bn _ sqr _ normal ▁( ▁BN _ ULONG ▁* ▁r ▁, ▁const ▁BN _ ULONG ▁* ▁a ▁, ▁int ▁n ▁, ▁BN _ ULONG ▁* ▁tmp ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁max ▁; ▁const ▁BN _ ULONG ▁* ▁ap ▁; ▁BN _ ULONG ▁* ▁rp ▁; ▁max ▁= ▁n ▁* ▁2 ▁; ▁ap ▁= ▁a ▁; ▁rp ▁= ▁r ▁; ▁rp ▁[ ▁0 ▁] ▁= ▁rp ▁[ ▁max ▁- ▁1 ▁] ▁= ▁0 ▁; ▁rp ▁++ ▁; ▁j ▁= ▁n ▁; ▁if ▁( ▁-- ▁j ▁> ▁0 ▁) ▁{ ▁ap ▁++ ▁; ▁rp ▁[ ▁j ▁] ▁= ▁bn _ mul _ words ▁( ▁rp ▁, ▁ap ▁, ▁j ▁, ▁ap ▁[ ▁-1 ▁] ▁) ▁; ▁rp ▁+= ▁2 ▁; ▁} ▁for ▁( ▁i ▁= ▁n ▁- ▁2 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁j ▁-- ▁; ▁ap ▁++ ▁; ▁rp ▁[ ▁j ▁] ▁= ▁bn _ mul _ add _ words ▁( ▁rp ▁, ▁ap ▁, ▁j ▁, ▁ap ▁[ ▁-1 ▁] ▁) ▁; ▁rp ▁+= ▁2 ▁; ▁} ▁bn _ add _ words ▁( ▁r ▁, ▁r ▁, ▁r ▁, ▁max ▁) ▁; ▁bn _ sqr _ words ▁( ▁tmp ▁, ▁a ▁, ▁n ▁) ▁; ▁bn _ add _ words ▁( ▁r ▁, ▁r ▁, ▁tmp ▁, ▁max ▁) ▁; ▁}	1
▁static ▁int ▁re configure _ filter ▁( ▁Buffer SourceContext ▁* ▁a buffer ▁, ▁AVFilter Context ▁* ▁filt _ ctx ▁) ▁{ ▁int ▁ret ▁; ▁AVFilter Link ▁* ▁const ▁inlink ▁= ▁filt _ ctx ▁-> ▁inputs ▁[ ▁0 ▁] ▁; ▁AVFilter Link ▁* ▁const ▁out link ▁= ▁filt _ ctx ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁inlink ▁-> ▁format ▁= ▁a buffer ▁-> ▁sample _ format ▁; ▁inlink ▁-> ▁channel _ layout ▁= ▁a buffer ▁-> ▁channel _ layout ▁; ▁inlink ▁-> ▁plan ar ▁= ▁a buffer ▁-> ▁pack ing _ format ▁; ▁inlink ▁-> ▁sample _ rate ▁= ▁a buffer ▁-> ▁sample _ rate ▁; ▁filt _ ctx ▁-> ▁filter ▁-> ▁uninit ▁( ▁filt _ ctx ▁) ▁; ▁memset ▁( ▁filt _ ctx ▁-> ▁priv ▁, ▁0 ▁, ▁filt _ ctx ▁-> ▁filter ▁-> ▁priv _ size ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁filt _ ctx ▁-> ▁filter ▁-> ▁init ▁( ▁filt _ ctx ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁inlink ▁-> ▁src pad ▁-> ▁config _ props ▁( ▁inlink ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁return ▁out link ▁-> ▁src pad ▁-> ▁config _ props ▁( ▁out link ▁) ▁; ▁}	1
▁int ▁BN _ num _ bits ▁( ▁const ▁BIGNUM ▁* ▁a ▁) ▁{ ▁BN _ ULONG ▁l ▁; ▁int ▁i ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁if ▁( ▁a ▁-> ▁top ▁== ▁0 ▁) ▁return ▁( ▁0 ▁) ▁; ▁l ▁= ▁a ▁-> ▁d ▁[ ▁a ▁-> ▁top ▁- ▁1 ▁] ▁; ▁i ▁= ▁( ▁a ▁-> ▁top ▁- ▁1 ▁) ▁* ▁BN _ BITS 2 ▁; ▁if ▁( ▁l ▁== ▁0 ▁) ▁{ ▁# if ▁! ▁defined ▁( ▁NO _ STDIO ▁) ▁&& ▁! ▁defined ▁( ▁WIN 16 ▁) ▁fprintf ▁( ▁stderr ▁, ▁" BAD TOP VALUE \ n " ▁) ▁; ▁# endif ▁abort ▁( ▁) ▁; ▁} ▁return ▁( ▁i ▁+ ▁BN _ num _ bits _ word ▁( ▁l ▁) ▁) ▁; ▁}	1
▁static ▁int ▁blend _ frames ▁( ▁AVFilter Context ▁* ▁ctx ▁, ▁int ▁interpolate ▁) ▁{ ▁Frame Rate Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFilter Link ▁* ▁out link ▁= ▁ctx ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁double ▁interpolate _ scene _ score ▁= ▁0 ▁; ▁if ▁( ▁( ▁s ▁-> ▁flags ▁& ▁F RAM ER ATE _ FLAG _ SCD ▁) ▁) ▁{ ▁if ▁( ▁s ▁-> ▁score ▁>= ▁0.0 ▁) ▁interpolate _ scene _ score ▁= ▁s ▁-> ▁score ▁; ▁else ▁interpolate _ scene _ score ▁= ▁s ▁-> ▁score ▁= ▁get _ scene _ score ▁( ▁ctx ▁, ▁s ▁-> ▁f 0 ▁, ▁s ▁-> ▁f 1 ▁) ▁; ▁ff _ d log ▁( ▁ctx ▁, ▁" blend _ frames () interpol ates c enes core :% f \ n " ▁, ▁interpolate _ scene _ score ▁) ▁; ▁} ▁if ▁( ▁interpolate _ scene _ score ▁< ▁s ▁-> ▁scene _ score ▁) ▁{ ▁Thread Data ▁td ▁; ▁td ▁. ▁copy _ src 1 ▁= ▁s ▁-> ▁f 0 ▁; ▁td ▁. ▁copy _ src 2 ▁= ▁s ▁-> ▁f 1 ▁; ▁td ▁. ▁src 2_ factor ▁= ▁interpolate ▁; ▁td ▁. ▁src 1_ factor ▁= ▁s ▁-> ▁max ▁- ▁td ▁. ▁src 2_ factor ▁; ▁s ▁-> ▁work ▁= ▁ff _ get _ video _ buffer ▁( ▁out link ▁, ▁out link ▁-> ▁w ▁, ▁out link ▁-> ▁h ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁work ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁av _ frame _ copy _ props ▁( ▁s ▁-> ▁work ▁, ▁s ▁-> ▁f 0 ▁) ▁; ▁ff _ d log ▁( ▁ctx ▁, ▁" blend _ frames () INTER POL ATE toc reate work frame \ n " ▁) ▁; ▁ctx ▁-> ▁internal ▁-> ▁execute ▁( ▁ctx ▁, ▁filter _ slice ▁, ▁& ▁td ▁, ▁NULL ▁, ▁FF MIN ▁( ▁out link ▁-> ▁h ▁, ▁ff _ filter _ get _ nb _ threads ▁( ▁ctx ▁) ▁) ▁) ▁; ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁group _ ex pon ents ▁( ▁AC 3 Encode Context ▁* ▁s ▁) ▁{ ▁int ▁blk ▁, ▁ch ▁, ▁i ▁; ▁int ▁group _ size ▁, ▁nb _ groups ▁, ▁bit _ count ▁; ▁uint 8_ t ▁* ▁p ▁; ▁int ▁delta 0 ▁, ▁delta 1 ▁, ▁delta 2 ▁; ▁int ▁exp 0 ▁, ▁exp 1 ▁; ▁bit _ count ▁= ▁0 ▁; ▁for ▁( ▁blk ▁= ▁0 ▁; ▁blk ▁< ▁AC 3_ MAX _ BLOCKS ▁; ▁blk ▁++ ▁) ▁{ ▁AC 3 Block ▁* ▁block ▁= ▁& ▁s ▁-> ▁blocks ▁[ ▁blk ▁] ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁s ▁-> ▁channels ▁; ▁ch ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁exp _ strategy ▁[ ▁ch ▁] ▁[ ▁blk ▁] ▁== ▁EXP _ REUSE ▁) ▁continue ▁; ▁group _ size ▁= ▁s ▁-> ▁exp _ strategy ▁[ ▁ch ▁] ▁[ ▁blk ▁] ▁+ ▁( ▁s ▁-> ▁exp _ strategy ▁[ ▁ch ▁] ▁[ ▁blk ▁] ▁== ▁EXP _ D 45 ▁) ▁; ▁nb _ groups ▁= ▁exponent _ group _ tab ▁[ ▁s ▁-> ▁exp _ strategy ▁[ ▁ch ▁] ▁[ ▁blk ▁] ▁- ▁1 ▁] ▁[ ▁s ▁-> ▁nb _ co efs ▁[ ▁ch ▁] ▁] ▁; ▁bit _ count ▁+= ▁4 ▁+ ▁( ▁nb _ groups ▁* ▁7 ▁) ▁; ▁p ▁= ▁block ▁-> ▁exp ▁[ ▁ch ▁] ▁; ▁exp 1 ▁= ▁* ▁p ▁++ ▁; ▁block ▁-> ▁grouped _ exp ▁[ ▁ch ▁] ▁[ ▁0 ▁] ▁= ▁exp 1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁nb _ groups ▁; ▁i ▁++ ▁) ▁{ ▁exp 0 ▁= ▁exp 1 ▁; ▁exp 1 ▁= ▁p ▁[ ▁0 ▁] ▁; ▁p ▁+= ▁group _ size ▁; ▁delta 0 ▁= ▁exp 1 ▁- ▁exp 0 ▁+ ▁2 ▁; ▁exp 0 ▁= ▁exp 1 ▁; ▁exp 1 ▁= ▁p ▁[ ▁0 ▁] ▁; ▁p ▁+= ▁group _ size ▁; ▁delta 1 ▁= ▁exp 1 ▁- ▁exp 0 ▁+ ▁2 ▁; ▁exp 0 ▁= ▁exp 1 ▁; ▁exp 1 ▁= ▁p ▁[ ▁0 ▁] ▁; ▁p ▁+= ▁group _ size ▁; ▁delta 2 ▁= ▁exp 1 ▁- ▁exp 0 ▁+ ▁2 ▁; ▁block ▁-> ▁grouped _ exp ▁[ ▁ch ▁] ▁[ ▁i ▁] ▁= ▁( ▁( ▁delta 0 ▁* ▁5 ▁+ ▁delta 1 ▁) ▁* ▁5 ▁) ▁+ ▁delta 2 ▁; ▁} ▁} ▁} ▁s ▁-> ▁exponent _ bits ▁= ▁bit _ count ▁; ▁}	1
▁void ▁ff _ id 3 v 2_ free _ extra _ meta ▁( ▁ID 3 v 2 Extra Meta ▁* ▁* ▁extra _ meta ▁) ▁{ ▁ID 3 v 2 Extra Meta ▁* ▁current ▁= ▁* ▁extra _ meta ▁, ▁* ▁next ▁; ▁void ▁( ▁* ▁free _ func ▁) ▁( ▁ID 3 v 2 Extra Meta ▁* ▁) ▁; ▁while ▁( ▁current ▁) ▁{ ▁if ▁( ▁( ▁free _ func ▁= ▁get _ extra _ meta _ func ▁( ▁current ▁-> ▁tag ▁, ▁1 ▁) ▁-> ▁free ▁) ▁) ▁free _ func ▁( ▁current ▁-> ▁data ▁) ▁; ▁next ▁= ▁current ▁-> ▁next ▁; ▁av _ freep ▁( ▁& ▁current ▁) ▁; ▁current ▁= ▁next ▁; ▁} ▁}	1
▁static ▁av _ always _ inline ▁int ▁vp 7 8_ decode _ mb _ row _ slic ed ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁t data ▁, ▁int ▁job nr ▁, ▁int ▁thread nr ▁, ▁int ▁is _ vp 7 ▁) ▁{ ▁VP 8 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁VP 8 Thread Data ▁* ▁td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁job nr ▁] ▁; ▁VP 8 Thread Data ▁* ▁next _ td ▁= ▁NULL ▁, ▁* ▁prev _ td ▁= ▁NULL ▁; ▁VP 8 Frame ▁* ▁cur frame ▁= ▁s ▁-> ▁cur frame ▁; ▁int ▁mb _ y ▁, ▁num _ jobs ▁= ▁s ▁-> ▁num _ jobs ▁; ▁td ▁-> ▁thread _ nr ▁= ▁thread nr ▁; ▁for ▁( ▁mb _ y ▁= ▁job nr ▁; ▁mb _ y ▁< ▁s ▁-> ▁mb _ height ▁; ▁mb _ y ▁+= ▁num _ jobs ▁) ▁{ ▁if ▁( ▁mb _ y ▁>= ▁s ▁-> ▁mb _ height ▁) ▁break ▁; ▁td ▁-> ▁thread _ mb _ pos ▁= ▁mb _ y ▁<< ▁16 ▁; ▁s ▁-> ▁decode _ mb _ row _ no _ filter ▁( ▁avctx ▁, ▁t data ▁, ▁job nr ▁, ▁thread nr ▁) ▁; ▁if ▁( ▁s ▁-> ▁de block _ filter ▁) ▁s ▁-> ▁filter _ mb _ row ▁( ▁avctx ▁, ▁t data ▁, ▁job nr ▁, ▁thread nr ▁) ▁; ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁INT _ MAX ▁& ▁0 xFFFF ▁) ▁; ▁s ▁-> ▁mv _ min ▁. ▁y ▁-= ▁64 ▁; ▁s ▁-> ▁mv _ max ▁. ▁y ▁-= ▁64 ▁; ▁if ▁( ▁avctx ▁-> ▁active _ thread _ type ▁== ▁FF _ THREAD _ FRAME ▁) ▁ff _ thread _ report _ progress ▁( ▁& ▁cur frame ▁-> ▁tf ▁, ▁mb _ y ▁, ▁0 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁av _ get _ channel _ layout _ nb _ channels ▁( ▁uint 64_ t ▁channel _ layout ▁) ▁{ ▁int ▁count ▁; ▁uint 64_ t ▁x ▁= ▁channel _ layout ▁; ▁for ▁( ▁count ▁= ▁0 ▁; ▁x ▁; ▁count ▁++ ▁) ▁x ▁&= ▁x ▁- ▁1 ▁; ▁return ▁count ▁; ▁}	0
▁static ▁int ▁aes _ init _ key ▁( ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁, ▁const ▁unsigned ▁char ▁* ▁key ▁, ▁const ▁unsigned ▁char ▁* ▁iv ▁, ▁int ▁enc ▁) ▁{ ▁if ▁( ▁enc ▁) ▁AES _ set _ encrypt _ key ▁( ▁key ▁, ▁ctx ▁-> ▁key _ len ▁* ▁8 ▁, ▁ctx ▁-> ▁cipher _ data ▁) ▁; ▁else ▁AES _ set _ decrypt _ key ▁( ▁key ▁, ▁ctx ▁-> ▁key _ len ▁* ▁8 ▁, ▁ctx ▁-> ▁cipher _ data ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁void ▁av _ noinline ▁filter _ mb _ edge h ▁( ▁uint 8_ t ▁* ▁pix ▁, ▁int ▁stride ▁, ▁int 16_ t ▁b S ▁[ ▁4 ▁] ▁, ▁unsigned ▁int ▁qp ▁, ▁H 264 Context ▁* ▁h ▁) ▁{ ▁const ▁unsigned ▁int ▁index _ a ▁= ▁52 ▁+ ▁qp ▁+ ▁h ▁-> ▁slice _ alpha _ c 0_ offset ▁; ▁const ▁int ▁alpha ▁= ▁alpha _ table ▁[ ▁index _ a ▁] ▁; ▁const ▁int ▁beta ▁= ▁( ▁beta _ table ▁+ ▁52 ▁) ▁[ ▁qp ▁+ ▁h ▁-> ▁slice _ beta _ offset ▁] ▁; ▁if ▁( ▁alpha ▁== ▁0 ▁|| ▁beta ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁b S ▁[ ▁0 ▁] ▁< ▁4 ▁) ▁{ ▁int 8_ t ▁tc ▁[ ▁4 ▁] ▁; ▁tc ▁[ ▁0 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁0 ▁] ▁] ▁; ▁tc ▁[ ▁1 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁1 ▁] ▁] ▁; ▁tc ▁[ ▁2 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁2 ▁] ▁] ▁; ▁tc ▁[ ▁3 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁3 ▁] ▁] ▁; ▁h ▁-> ▁s ▁. ▁dsp ▁. ▁h 264_ v _ loop _ filter _ l uma ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁, ▁tc ▁) ▁; ▁} ▁else ▁{ ▁h ▁-> ▁s ▁. ▁dsp ▁. ▁h 264_ v _ loop _ filter _ l uma _ intra ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁) ▁; ▁} ▁}	1
▁static ▁inline ▁void ▁tg q _ d con ly ▁( ▁T g q Context ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁dst ▁, ▁int ▁dst _ stride ▁, ▁int ▁dc ▁) ▁{ ▁int ▁level ▁= ▁av _ clip _ uint 8 ▁( ▁( ▁dc ▁* ▁s ▁-> ▁q table ▁[ ▁0 ▁] ▁+ ▁20 56 ▁) ▁>> ▁4 ▁) ▁; ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁8 ▁; ▁j ▁++ ▁) ▁memset ▁( ▁dst ▁+ ▁j ▁* ▁dst _ stride ▁, ▁level ▁, ▁8 ▁) ▁; ▁}	1
▁int ▁ff _ d ca _ x ll _ filter _ frame ▁( ▁D CA X ll Decoder ▁* ▁s ▁, ▁AVFrame ▁* ▁frame ▁) ▁{ ▁AVCodecContext ▁* ▁avctx ▁= ▁s ▁-> ▁avctx ▁; ▁D CA Context ▁* ▁dca ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁D CA Ex ss Asset ▁* ▁asset ▁= ▁& ▁dca ▁-> ▁ex ss ▁. ▁assets ▁[ ▁0 ▁] ▁; ▁D CA X ll Ch Set ▁* ▁p ▁= ▁& ▁s ▁-> ▁ch set ▁[ ▁0 ▁] ▁, ▁* ▁c ▁; ▁enum ▁AV Matrix Encoding ▁matrix _ encoding ▁= ▁AV _ MATRIX _ ENCODING _ NONE ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁ret ▁, ▁shift ▁, ▁ns amples ▁, ▁request _ mask ▁; ▁int ▁ch _ remap ▁[ ▁D CA _ SPE AKER _ COUNT ▁] ▁; ▁if ▁( ▁dca ▁-> ▁packet ▁& ▁D CA _ PACKET _ RECOVERY ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁, ▁c ▁= ▁s ▁-> ▁ch set ▁; ▁i ▁< ▁s ▁-> ▁n ch sets ▁; ▁i ▁++ ▁, ▁c ▁++ ▁) ▁{ ▁if ▁( ▁i ▁< ▁s ▁-> ▁n active ch sets ▁) ▁force _ loss y _ output ▁( ▁s ▁, ▁c ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁primary _ ch set ▁) ▁c ▁-> ▁dm ix _ embedded ▁= ▁0 ▁; ▁} ▁s ▁-> ▁scal able _ ls bs ▁= ▁0 ▁; ▁s ▁-> ▁fixed _ lsb _ width ▁= ▁0 ▁; ▁} ▁s ▁-> ▁output _ mask ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁c ▁= ▁s ▁-> ▁ch set ▁; ▁i ▁< ▁s ▁-> ▁n active ch sets ▁; ▁i ▁++ ▁, ▁c ▁++ ▁) ▁{ ▁chs _ filter _ band _ data ▁( ▁s ▁, ▁c ▁, ▁0 ▁) ▁; ▁if ▁( ▁c ▁-> ▁residual _ encode ▁!= ▁( ▁1 ▁<< ▁c ▁-> ▁n channels ▁) ▁- ▁1 ▁&& ▁( ▁ret ▁= ▁combine _ residual _ frame ▁( ▁s ▁, ▁c ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁s ▁-> ▁scal able _ ls bs ▁) ▁chs _ assemble _ ms bs _ ls bs ▁( ▁s ▁, ▁c ▁, ▁0 ▁) ▁; ▁if ▁( ▁c ▁-> ▁n freq band s ▁> ▁1 ▁) ▁{ ▁chs _ filter _ band _ data ▁( ▁s ▁, ▁c ▁, ▁1 ▁) ▁; ▁chs _ assemble _ ms bs _ ls bs ▁( ▁s ▁, ▁c ▁, ▁1 ▁) ▁; ▁} ▁s ▁-> ▁output _ mask ▁|= ▁c ▁-> ▁ch _ mask ▁; ▁} ▁for ▁( ▁i ▁= ▁1 ▁, ▁c ▁= ▁& ▁s ▁-> ▁ch set ▁[ ▁1 ▁] ▁; ▁i ▁< ▁s ▁-> ▁n ch sets ▁; ▁i ▁++ ▁, ▁c ▁++ ▁) ▁{ ▁if ▁( ▁! ▁is _ h ier _ dm ix _ ch set ▁( ▁c ▁) ▁) ▁continue ▁; ▁if ▁( ▁i ▁>= ▁s ▁-> ▁n active ch sets ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁-> ▁n freq band s ▁; ▁j ▁++ ▁) ▁if ▁( ▁c ▁-> ▁bands ▁[ ▁j ▁] ▁. ▁dm ix _ embedded ▁) ▁scale _ down _ mix ▁( ▁s ▁, ▁c ▁, ▁j ▁) ▁; ▁break ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁c ▁-> ▁n freq band s ▁; ▁j ▁++ ▁) ▁if ▁( ▁c ▁-> ▁bands ▁[ ▁j ▁] ▁. ▁dm ix _ embedded ▁) ▁undo _ down _ mix ▁( ▁s ▁, ▁c ▁, ▁j ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁n freq band s ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n active ch sets ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁chs _ assemble _ freq _ band s ▁( ▁s ▁, ▁& ▁s ▁-> ▁ch set ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁dca ▁-> ▁request _ channel _ layout ▁) ▁{ ▁if ▁( ▁s ▁-> ▁output _ mask ▁& ▁D CA _ SPE AKER _ MASK _ L ss ▁) ▁{ ▁s ▁-> ▁output _ samples ▁[ ▁D CA _ SPE AKER _ Ls ▁] ▁= ▁s ▁-> ▁output _ samples ▁[ ▁D CA _ SPE AKER _ L ss ▁] ▁; ▁s ▁-> ▁output _ mask ▁= ▁( ▁s ▁-> ▁output _ mask ▁& ▁ ~ ▁D CA _ SPE AKER _ MASK _ L ss ▁) ▁| ▁D CA _ SPE AKER _ MASK _ Ls ▁; ▁} ▁if ▁( ▁s ▁-> ▁output _ mask ▁& ▁D CA _ SPE AKER _ MASK _ R ss ▁) ▁{ ▁s ▁-> ▁output _ samples ▁[ ▁D CA _ SPE AKER _ Rs ▁] ▁= ▁s ▁-> ▁output _ samples ▁[ ▁D CA _ SPE AKER _ R ss ▁] ▁; ▁s ▁-> ▁output _ mask ▁= ▁( ▁s ▁-> ▁output _ mask ▁& ▁ ~ ▁D CA _ SPE AKER _ MASK _ R ss ▁) ▁| ▁D CA _ SPE AKER _ MASK _ Rs ▁; ▁} ▁} ▁if ▁( ▁dca ▁-> ▁request _ channel _ layout ▁== ▁D CA _ SPE AKER _ LAYOUT _ STEREO ▁&& ▁D CA _ HAS _ STEREO ▁( ▁s ▁-> ▁output _ mask ▁) ▁&& ▁p ▁-> ▁dm ix _ embedded ▁&& ▁( ▁p ▁-> ▁dm ix _ type ▁== ▁D CA _ DM IX _ TYPE _ Lo Ro ▁|| ▁p ▁-> ▁dm ix _ type ▁== ▁D CA _ DM IX _ TYPE _ L t Rt ▁) ▁) ▁request _ mask ▁= ▁D CA _ SPE AKER _ LAYOUT _ STEREO ▁; ▁else ▁request _ mask ▁= ▁s ▁-> ▁output _ mask ▁; ▁if ▁( ▁! ▁ff _ d ca _ set _ channel _ layout ▁( ▁avctx ▁, ▁ch _ remap ▁, ▁request _ mask ▁) ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁avctx ▁-> ▁sample _ rate ▁= ▁p ▁-> ▁freq ▁<< ▁( ▁s ▁-> ▁n freq band s ▁- ▁1 ▁) ▁; ▁switch ▁( ▁p ▁-> ▁storage _ bit _ res ▁) ▁{ ▁case ▁16 ▁: ▁avctx ▁-> ▁sample _ fmt ▁= ▁AV _ SAMPLE _ FMT _ S 16 P ▁; ▁shift ▁= ▁16 ▁- ▁p ▁-> ▁pcm _ bit _ res ▁; ▁break ▁; ▁case ▁20 ▁: ▁case ▁24 ▁: ▁avctx ▁-> ▁sample _ fmt ▁= ▁AV _ SAMPLE _ FMT _ S 32 P ▁; ▁shift ▁= ▁24 ▁- ▁p ▁-> ▁pcm _ bit _ res ▁; ▁break ▁; ▁default ▁: ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁= ▁p ▁-> ▁storage _ bit _ res ▁; ▁avctx ▁-> ▁profile ▁= ▁FF _ PROFILE _ D TS _ HD _ MA ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁0 ▁; ▁frame ▁-> ▁nb _ samples ▁= ▁ns amples ▁= ▁s ▁-> ▁n frames amples ▁<< ▁( ▁s ▁-> ▁n freq band s ▁- ▁1 ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁frame ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁request _ mask ▁!= ▁s ▁-> ▁output _ mask ▁) ▁{ ▁ff _ d ca _ down mix _ to _ stereo _ fixed ▁( ▁s ▁-> ▁dc ad sp ▁, ▁s ▁-> ▁output _ samples ▁, ▁p ▁-> ▁dm ix _ coeff ▁, ▁ns amples ▁, ▁s ▁-> ▁output _ mask ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁* ▁samples ▁= ▁s ▁-> ▁output _ samples ▁[ ▁ch _ remap ▁[ ▁i ▁] ▁] ▁; ▁if ▁( ▁frame ▁-> ▁format ▁== ▁AV _ SAMPLE _ FMT _ S 16 P ▁) ▁{ ▁int 16_ t ▁* ▁plane ▁= ▁( ▁int 16_ t ▁* ▁) ▁frame ▁-> ▁extended _ data ▁[ ▁i ▁] ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁ns amples ▁; ▁k ▁++ ▁) ▁plane ▁[ ▁k ▁] ▁= ▁av _ clip _ int 16 ▁( ▁samples ▁[ ▁k ▁] ▁* ▁( ▁1 ▁<< ▁shift ▁) ▁) ▁; ▁} ▁else ▁{ ▁int 32_ t ▁* ▁plane ▁= ▁( ▁int 32_ t ▁* ▁) ▁frame ▁-> ▁extended _ data ▁[ ▁i ▁] ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁ns amples ▁; ▁k ▁++ ▁) ▁plane ▁[ ▁k ▁] ▁= ▁clip 23 ▁( ▁samples ▁[ ▁k ▁] ▁* ▁( ▁1 ▁<< ▁shift ▁) ▁) ▁* ▁( ▁1 ▁<< ▁8 ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁asset ▁-> ▁one _ to _ one _ map _ ch _ to _ spkr ▁) ▁{ ▁if ▁( ▁asset ▁-> ▁representation _ type ▁== ▁D CA _ RE PR _ TYPE _ L t Rt ▁) ▁matrix _ encoding ▁= ▁AV _ MATRIX _ ENCODING _ D OL BY ▁; ▁else ▁if ▁( ▁asset ▁-> ▁representation _ type ▁== ▁D CA _ RE PR _ TYPE _ L h R h ▁) ▁matrix _ encoding ▁= ▁AV _ MATRIX _ ENCODING _ D OL BY HEAD PHONE ▁; ▁} ▁else ▁if ▁( ▁request _ mask ▁!= ▁s ▁-> ▁output _ mask ▁&& ▁p ▁-> ▁dm ix _ type ▁== ▁D CA _ DM IX _ TYPE _ L t Rt ▁) ▁{ ▁matrix _ encoding ▁= ▁AV _ MATRIX _ ENCODING _ D OL BY ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁ff _ side _ data _ update _ matrix _ encoding ▁( ▁frame ▁, ▁matrix _ encoding ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁return ▁0 ▁; ▁}	1
▁void ▁* ▁av _ malloc z ▁( ▁unsigned ▁int ▁size ▁) ▁{ ▁void ▁* ▁ptr ▁; ▁ptr ▁= ▁av _ malloc ▁( ▁size ▁) ▁; ▁if ▁( ▁ptr ▁) ▁memset ▁( ▁ptr ▁, ▁0 ▁, ▁size ▁) ▁; ▁return ▁ptr ▁; ▁}	1
▁size _ t ▁ec _ key _ simple _ priv 2 oct ▁( ▁const ▁EC _ KEY ▁* ▁e ckey ▁, ▁unsigned ▁char ▁* ▁buf ▁, ▁size _ t ▁len ▁) ▁{ ▁size _ t ▁buf _ len ▁; ▁buf _ len ▁= ▁( ▁EC _ GROUP _ get _ degree ▁( ▁e ckey ▁-> ▁group ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁if ▁( ▁e ckey ▁-> ▁priv _ key ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁buf ▁== ▁NULL ▁) ▁return ▁buf _ len ▁; ▁else ▁if ▁( ▁len ▁< ▁buf _ len ▁) ▁return ▁0 ▁; ▁if ▁( ▁BN _ bn 2 bin pad ▁( ▁e ckey ▁-> ▁priv _ key ▁, ▁buf ▁, ▁buf _ len ▁) ▁== ▁-1 ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ KEY _ SIMPLE _ PRIV 2 O CT ▁, ▁EC _ R _ BUFFER _ TOO _ SMALL ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁buf _ len ▁; ▁}	1
▁static ▁void ▁mpeg _ decode _ sequence _ extension ▁( ▁Mpeg 1 Context ▁* ▁s 1 ▁) ▁{ ▁Mpeg Enc Context ▁* ▁s ▁= ▁& ▁s 1 ▁-> ▁mpeg _ enc _ ctx ▁; ▁int ▁h oriz _ size _ ext ▁, ▁vert _ size _ ext ▁; ▁int ▁bit _ rate _ ext ▁; ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁1 ▁) ▁; ▁s ▁-> ▁avctx ▁-> ▁profile ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁3 ▁) ▁; ▁s ▁-> ▁avctx ▁-> ▁level ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁; ▁s ▁-> ▁progress ive _ sequence ▁= ▁get _ bits 1 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁s ▁-> ▁chroma _ format ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁2 ▁) ▁; ▁h oriz _ size _ ext ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁2 ▁) ▁; ▁vert _ size _ ext ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁2 ▁) ▁; ▁s ▁-> ▁width ▁|= ▁( ▁h oriz _ size _ ext ▁<< ▁12 ▁) ▁; ▁s ▁-> ▁height ▁|= ▁( ▁vert _ size _ ext ▁<< ▁12 ▁) ▁; ▁bit _ rate _ ext ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁12 ▁) ▁; ▁s ▁-> ▁bit _ rate ▁+= ▁( ▁bit _ rate _ ext ▁<< ▁18 ▁) ▁* ▁400 ▁; ▁check _ marker ▁( ▁& ▁s ▁-> ▁gb ▁, ▁" after bitrate extension " ▁) ▁; ▁s ▁-> ▁avctx ▁-> ▁rc _ buffer _ size ▁+= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁* ▁1024 ▁* ▁16 ▁<< ▁10 ▁; ▁s ▁-> ▁low _ delay ▁= ▁get _ bits 1 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ LOW _ DELAY ▁) ▁s ▁-> ▁low _ delay ▁= ▁1 ▁; ▁s 1 ▁-> ▁frame _ rate _ ext ▁. ▁num ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁2 ▁) ▁+ ▁1 ▁; ▁s 1 ▁-> ▁frame _ rate _ ext ▁. ▁den ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁5 ▁) ▁+ ▁1 ▁; ▁av _ d log ▁( ▁s ▁-> ▁avctx ▁, ▁" sequence extension \ n " ▁) ▁; ▁s ▁-> ▁codec _ id ▁= ▁s ▁-> ▁avctx ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ P ICT _ INFO ▁) ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" profile :% d , level :% dps :% dc f :% dvb v buffer :% d , bitrate :% d \ n " ▁, ▁s ▁-> ▁avctx ▁-> ▁profile ▁, ▁s ▁-> ▁avctx ▁-> ▁level ▁, ▁s ▁-> ▁progress ive _ sequence ▁, ▁s ▁-> ▁chroma _ format ▁, ▁s ▁-> ▁avctx ▁-> ▁rc _ buffer _ size ▁, ▁s ▁-> ▁bit _ rate ▁) ▁; ▁}	0
▁static ▁int ▁get _ s ot ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁int ▁n ▁) ▁{ ▁J peg 2000 Tile Part ▁* ▁tp ▁; ▁uint 16_ t ▁Is ot ▁; ▁uint 32_ t ▁Ps ot ▁; ▁uint 8_ t ▁T Ps ot ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁g ▁) ▁< ▁8 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁s ▁-> ▁cur til eno ▁= ▁Is ot ▁= ▁bytestream 2_ get _ be 16 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁s ▁-> ▁cur til eno ▁>= ▁s ▁-> ▁num X tiles ▁* ▁s ▁-> ▁num Y tiles ▁) ▁{ ▁s ▁-> ▁cur til eno ▁= ▁0 ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁Ps ot ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁T Ps ot ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁if ▁( ▁T Ps ot ▁>= ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁tile ▁[ ▁s ▁-> ▁cur til eno ▁] ▁. ▁tile _ part ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" TP s ot % dt oo big \ n " ▁, ▁T Ps ot ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁s ▁-> ▁tile ▁[ ▁s ▁-> ▁cur til eno ▁] ▁. ▁tp _ idx ▁= ▁T Ps ot ▁; ▁tp ▁= ▁s ▁-> ▁tile ▁[ ▁s ▁-> ▁cur til eno ▁] ▁. ▁tile _ part ▁+ ▁T Ps ot ▁; ▁tp ▁-> ▁tile _ index ▁= ▁Is ot ▁; ▁tp ▁-> ▁tp _ end ▁= ▁s ▁-> ▁g ▁. ▁buffer ▁+ ▁Ps ot ▁- ▁n ▁- ▁2 ▁; ▁if ▁( ▁! ▁T Ps ot ▁) ▁{ ▁J peg 2000 Tile ▁* ▁tile ▁= ▁s ▁-> ▁tile ▁+ ▁s ▁-> ▁cur til eno ▁; ▁memcpy ▁( ▁tile ▁-> ▁co dst y ▁, ▁s ▁-> ▁co dst y ▁, ▁s ▁-> ▁n components ▁* ▁sizeof ▁( ▁J peg 2000 Coding Style ▁) ▁) ▁; ▁memcpy ▁( ▁tile ▁-> ▁q nt st y ▁, ▁s ▁-> ▁q nt st y ▁, ▁s ▁-> ▁n components ▁* ▁sizeof ▁( ▁J peg 2000 Quant Style ▁) ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁size _ t ▁i 2 c _ i buf ▁( ▁const ▁unsigned ▁char ▁* ▁b ▁, ▁size _ t ▁blen ▁, ▁int ▁neg ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁) ▁{ ▁int ▁pad ▁= ▁0 ▁; ▁size _ t ▁ret ▁, ▁i ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁pb ▁= ▁0 ▁; ▁const ▁unsigned ▁char ▁* ▁n ▁; ▁if ▁( ▁b ▁== ▁NULL ▁|| ▁blen ▁== ▁0 ▁) ▁ret ▁= ▁1 ▁; ▁else ▁{ ▁ret ▁= ▁blen ▁; ▁i ▁= ▁b ▁[ ▁0 ▁] ▁; ▁if ▁( ▁ret ▁== ▁1 ▁&& ▁i ▁== ▁0 ▁) ▁neg ▁= ▁0 ▁; ▁if ▁( ▁! ▁neg ▁&& ▁( ▁i ▁> ▁127 ▁) ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁pb ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁neg ▁) ▁{ ▁if ▁( ▁i ▁> ▁128 ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁pb ▁= ▁0 xFF ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁128 ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁blen ▁; ▁i ▁++ ▁) ▁if ▁( ▁b ▁[ ▁i ▁] ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁pb ▁= ▁0 xFF ▁; ▁break ▁; ▁} ▁} ▁} ▁ret ▁+= ▁pad ▁; ▁} ▁if ▁( ▁pp ▁== ▁NULL ▁) ▁return ▁ret ▁; ▁p ▁= ▁* ▁pp ▁; ▁if ▁( ▁pad ▁) ▁* ▁( ▁p ▁++ ▁) ▁= ▁pb ▁; ▁if ▁( ▁b ▁== ▁NULL ▁|| ▁blen ▁== ▁0 ▁) ▁* ▁p ▁= ▁0 ▁; ▁else ▁if ▁( ▁! ▁neg ▁) ▁memcpy ▁( ▁p ▁, ▁b ▁, ▁blen ▁) ▁; ▁else ▁{ ▁n ▁= ▁b ▁+ ▁blen ▁; ▁p ▁+= ▁blen ▁; ▁i ▁= ▁blen ▁; ▁while ▁( ▁! ▁n ▁[ ▁-1 ▁] ▁&& ▁i ▁> ▁1 ▁) ▁{ ▁* ▁( ▁-- ▁p ▁) ▁= ▁0 ▁; ▁n ▁-- ▁; ▁i ▁-- ▁; ▁} ▁* ▁( ▁-- ▁p ▁) ▁= ▁( ▁( ▁* ▁( ▁-- ▁n ▁) ▁) ▁ ^ ▁0 xff ▁) ▁+ ▁1 ▁; ▁i ▁-- ▁; ▁for ▁( ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁* ▁( ▁-- ▁p ▁) ▁= ▁* ▁( ▁-- ▁n ▁) ▁ ^ ▁0 xff ▁; ▁} ▁* ▁pp ▁+= ▁ret ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁void ▁add _ pixels _ clamp ed 2_ c ▁( ▁const ▁DCT ELEM ▁* ▁block ▁, ▁uint 8_ t ▁* ▁restrict ▁pixels ▁, ▁int ▁line _ size ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁pixels ▁[ ▁0 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁pixels ▁[ ▁0 ▁] ▁+ ▁block ▁[ ▁0 ▁] ▁) ▁; ▁pixels ▁[ ▁1 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁pixels ▁[ ▁1 ▁] ▁+ ▁block ▁[ ▁1 ▁] ▁) ▁; ▁pixels ▁+= ▁line _ size ▁; ▁block ▁+= ▁8 ▁; ▁} ▁}	0
▁void ▁ff _ eval _ co efs ▁( ▁int ▁* ▁co efs ▁, ▁const ▁int ▁* ▁ref l ▁) ▁{ ▁int ▁buffer ▁[ ▁LPC _ ORDER ▁] ▁; ▁int ▁* ▁b 1 ▁= ▁buffer ▁; ▁int ▁* ▁b 2 ▁= ▁co efs ▁; ▁int ▁i ▁, ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁LPC _ ORDER ▁; ▁i ▁++ ▁) ▁{ ▁b 1 ▁[ ▁i ▁] ▁= ▁ref l ▁[ ▁i ▁] ▁* ▁16 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁i ▁; ▁j ▁++ ▁) ▁b 1 ▁[ ▁j ▁] ▁= ▁( ▁( ▁int ▁) ▁( ▁ref l ▁[ ▁i ▁] ▁* ▁( ▁unsigned ▁) ▁b 2 ▁[ ▁i ▁- ▁j ▁- ▁1 ▁] ▁) ▁>> ▁12 ▁) ▁+ ▁b 2 ▁[ ▁j ▁] ▁; ▁F FS W AP ▁( ▁int ▁* ▁, ▁b 1 ▁, ▁b 2 ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁LPC _ ORDER ▁; ▁i ▁++ ▁) ▁co efs ▁[ ▁i ▁] ▁>>= ▁4 ▁; ▁}	0
▁static ▁void ▁ini _ print _ section _ header ▁( ▁Writer Context ▁* ▁w ctx ▁) ▁{ ▁IN I Context ▁* ▁ini ▁= ▁w ctx ▁-> ▁priv ▁; ▁AV B Print ▁* ▁buf ▁= ▁& ▁ini ▁-> ▁section _ header ▁[ ▁w ctx ▁-> ▁level ▁] ▁; ▁const ▁struct ▁section ▁* ▁section ▁= ▁w ctx ▁-> ▁section ▁[ ▁w ctx ▁-> ▁level ▁] ▁; ▁const ▁struct ▁section ▁* ▁parent _ section ▁= ▁w ctx ▁-> ▁level ▁? ▁w ctx ▁-> ▁section ▁[ ▁w ctx ▁-> ▁level ▁- ▁1 ▁] ▁: ▁NULL ▁; ▁av _ b print _ clear ▁( ▁buf ▁) ▁; ▁if ▁( ▁! ▁parent _ section ▁) ▁{ ▁printf ▁( ▁"# ff probe output \ n \ n " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁w ctx ▁-> ▁nb _ item ▁[ ▁w ctx ▁-> ▁level ▁- ▁1 ▁] ▁) ▁printf ▁( ▁"\ n " ▁) ▁; ▁av _ b printf ▁( ▁buf ▁, ▁"% s " ▁, ▁ini ▁-> ▁section _ header ▁[ ▁w ctx ▁-> ▁level ▁- ▁1 ▁] ▁. ▁str ▁) ▁; ▁if ▁( ▁ini ▁-> ▁h ierarchical ▁|| ▁! ▁( ▁section ▁-> ▁flags ▁& ▁( ▁SECTION _ FLAG _ IS _ ARRAY ▁| ▁SECTION _ FLAG _ IS _ WRAPPER ▁) ▁) ▁) ▁{ ▁av _ b printf ▁( ▁buf ▁, ▁"% s % s " ▁, ▁buf ▁-> ▁str ▁[ ▁0 ▁] ▁? ▁"." ▁: ▁"" ▁, ▁w ctx ▁-> ▁section ▁[ ▁w ctx ▁-> ▁level ▁] ▁-> ▁name ▁) ▁; ▁if ▁( ▁parent _ section ▁-> ▁flags ▁& ▁SECTION _ FLAG _ IS _ ARRAY ▁) ▁{ ▁int ▁n ▁= ▁parent _ section ▁-> ▁id ▁== ▁SECTION _ ID _ PACKET S _ AND _ FRAMES ▁? ▁w ctx ▁-> ▁nb _ section _ packet _ frame ▁: ▁w ctx ▁-> ▁nb _ item ▁[ ▁w ctx ▁-> ▁level ▁- ▁1 ▁] ▁; ▁av _ b printf ▁( ▁buf ▁, ▁". % d " ▁, ▁n ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁( ▁section ▁-> ▁flags ▁& ▁( ▁SECTION _ FLAG _ IS _ ARRAY ▁| ▁SECTION _ FLAG _ IS _ WRAPPER ▁) ▁) ▁) ▁printf ▁( ▁"[% s ]\ n " ▁, ▁buf ▁-> ▁str ▁) ▁; ▁}	0
▁int ▁ff _ generate _ sl iding _ window _ mm cos ▁( ▁H 264 Context ▁* ▁h ▁, ▁int ▁first _ slice ▁) ▁{ ▁MM CO ▁mm co _ temp ▁[ ▁MAX _ MM CO _ COUNT ▁] ▁, ▁* ▁mm co ▁= ▁first _ slice ▁? ▁h ▁-> ▁mm co ▁: ▁mm co _ temp ▁; ▁int ▁mm co _ index ▁= ▁0 ▁, ▁i ▁; ▁assert ▁( ▁h ▁-> ▁long _ ref _ count ▁+ ▁h ▁-> ▁short _ ref _ count ▁<= ▁h ▁-> ▁sps ▁. ▁ref _ frame _ count ▁) ▁; ▁if ▁( ▁h ▁-> ▁short _ ref _ count ▁&& ▁h ▁-> ▁long _ ref _ count ▁+ ▁h ▁-> ▁short _ ref _ count ▁== ▁h ▁-> ▁sps ▁. ▁ref _ frame _ count ▁&& ▁! ▁( ▁FIELD _ PICTURE ▁( ▁h ▁) ▁&& ▁! ▁h ▁-> ▁first _ field ▁&& ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁reference ▁) ▁) ▁{ ▁mm co ▁[ ▁0 ▁] ▁. ▁opcode ▁= ▁MM CO _ SHORT 2 UNUSED ▁; ▁mm co ▁[ ▁0 ▁] ▁. ▁short _ pic _ num ▁= ▁h ▁-> ▁short _ ref ▁[ ▁h ▁-> ▁short _ ref _ count ▁- ▁1 ▁] ▁-> ▁frame _ num ▁; ▁mm co _ index ▁= ▁1 ▁; ▁if ▁( ▁FIELD _ PICTURE ▁( ▁h ▁) ▁) ▁{ ▁mm co ▁[ ▁0 ▁] ▁. ▁short _ pic _ num ▁*= ▁2 ▁; ▁mm co ▁[ ▁1 ▁] ▁. ▁opcode ▁= ▁MM CO _ SHORT 2 UNUSED ▁; ▁mm co ▁[ ▁1 ▁] ▁. ▁short _ pic _ num ▁= ▁mm co ▁[ ▁0 ▁] ▁. ▁short _ pic _ num ▁+ ▁1 ▁; ▁mm co _ index ▁= ▁2 ▁; ▁} ▁} ▁if ▁( ▁first _ slice ▁) ▁{ ▁h ▁-> ▁mm co _ index ▁= ▁mm co _ index ▁; ▁} ▁else ▁if ▁( ▁! ▁first _ slice ▁&& ▁mm co _ index ▁>= ▁0 ▁&& ▁( ▁mm co _ index ▁!= ▁h ▁-> ▁mm co _ index ▁|| ▁( ▁i ▁= ▁check _ opcodes ▁( ▁h ▁-> ▁mm co ▁, ▁mm co _ temp ▁, ▁mm co _ index ▁) ▁) ▁) ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" In consistent MM CO state b et we ens lices [% d ,% d ,% d ]\ n " ▁, ▁mm co _ index ▁, ▁h ▁-> ▁mm co _ index ▁, ▁i ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁cms _ set 1_ Signer Identifier ▁( ▁CMS _ Signer Identifier ▁* ▁sid ▁, ▁X 509 ▁* ▁cert ▁, ▁int ▁type ▁) ▁{ ▁switch ▁( ▁type ▁) ▁{ ▁case ▁CMS _ SIGN ER INFO _ IS SU ER _ SERIAL ▁: ▁if ▁( ▁! ▁cms _ set 1_ ias ▁( ▁& ▁sid ▁-> ▁d ▁. ▁issuer And SerialNumber ▁, ▁cert ▁) ▁) ▁return ▁0 ▁; ▁break ▁; ▁case ▁CMS _ SIGN ER INFO _ KEY IDENTIFIER ▁: ▁if ▁( ▁! ▁cms _ set 1_ keyid ▁( ▁& ▁sid ▁-> ▁d ▁. ▁subject Key Identifier ▁, ▁cert ▁) ▁) ▁return ▁0 ▁; ▁break ▁; ▁default ▁: ▁CMS err ▁( ▁CMS _ F _ CMS _ SET 1_ SIGN ER IDENTIFIER ▁, ▁CMS _ R _ UNKNOWN _ ID ▁) ▁; ▁return ▁0 ▁; ▁} ▁sid ▁-> ▁type ▁= ▁type ▁; ▁return ▁1 ▁; ▁}	0
▁int ▁ff _ alloc _ entries ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁int ▁count ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁{ ▁Slice ThreadContext ▁* ▁p ▁= ▁avctx ▁-> ▁internal ▁-> ▁thread _ ctx ▁; ▁p ▁-> ▁thread _ count ▁= ▁avctx ▁-> ▁thread _ count ▁; ▁p ▁-> ▁entries ▁= ▁av _ malloc z _ array ▁( ▁count ▁, ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁if ▁( ▁! ▁p ▁-> ▁entries ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁p ▁-> ▁entries _ count ▁= ▁count ▁; ▁p ▁-> ▁progress _ mutex ▁= ▁av _ malloc _ array ▁( ▁p ▁-> ▁thread _ count ▁, ▁sizeof ▁( ▁pthread _ mutex _ t ▁) ▁) ▁; ▁p ▁-> ▁progress _ cond ▁= ▁av _ malloc _ array ▁( ▁p ▁-> ▁thread _ count ▁, ▁sizeof ▁( ▁pthread _ cond _ t ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁p ▁-> ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁pthread _ mutex _ init ▁( ▁& ▁p ▁-> ▁progress _ mutex ▁[ ▁i ▁] ▁, ▁NULL ▁) ▁; ▁pthread _ cond _ init ▁( ▁& ▁p ▁-> ▁progress _ cond ▁[ ▁i ▁] ▁, ▁NULL ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁contract ▁( ▁L HASH ▁* ▁lh ▁) ▁{ ▁L HASH _ NODE ▁* ▁* ▁n ▁, ▁* ▁n 1 ▁, ▁* ▁np ▁; ▁np ▁= ▁lh ▁-> ▁b ▁[ ▁lh ▁-> ▁p ▁+ ▁lh ▁-> ▁p max ▁- ▁1 ▁] ▁; ▁lh ▁-> ▁b ▁[ ▁lh ▁-> ▁p ▁+ ▁lh ▁-> ▁p max ▁- ▁1 ▁] ▁= ▁NULL ▁; ▁if ▁( ▁lh ▁-> ▁p ▁== ▁0 ▁) ▁{ ▁n ▁= ▁( ▁L HASH _ NODE ▁* ▁* ▁) ▁OPENSSL _ realloc ▁( ▁lh ▁-> ▁b ▁, ▁( ▁unsigned ▁int ▁) ▁( ▁sizeof ▁( ▁L HASH _ NODE ▁* ▁) ▁* ▁lh ▁-> ▁p max ▁) ▁) ▁; ▁if ▁( ▁n ▁== ▁NULL ▁) ▁{ ▁lh ▁-> ▁error ▁++ ▁; ▁return ▁; ▁} ▁lh ▁-> ▁num _ contract _ realloc s ▁++ ▁; ▁lh ▁-> ▁num _ alloc _ nodes ▁/= ▁2 ▁; ▁lh ▁-> ▁p max ▁/= ▁2 ▁; ▁lh ▁-> ▁p ▁= ▁lh ▁-> ▁p max ▁- ▁1 ▁; ▁lh ▁-> ▁b ▁= ▁n ▁; ▁} ▁else ▁lh ▁-> ▁p ▁-- ▁; ▁lh ▁-> ▁num _ nodes ▁-- ▁; ▁lh ▁-> ▁num _ contract s ▁++ ▁; ▁n 1 ▁= ▁lh ▁-> ▁b ▁[ ▁( ▁int ▁) ▁lh ▁-> ▁p ▁] ▁; ▁if ▁( ▁n 1 ▁== ▁NULL ▁) ▁lh ▁-> ▁b ▁[ ▁( ▁int ▁) ▁lh ▁-> ▁p ▁] ▁= ▁np ▁; ▁else ▁{ ▁while ▁( ▁n 1 ▁-> ▁next ▁!= ▁NULL ▁) ▁n 1 ▁= ▁n 1 ▁-> ▁next ▁; ▁n 1 ▁-> ▁next ▁= ▁np ▁; ▁} ▁}	1
▁AP _ DECLARE ▁( ▁void ▁) ▁ap _ get _ mime _ headers _ core ▁( ▁request _ rec ▁* ▁r ▁, ▁apr _ bucket _ b rig ade ▁* ▁bb ▁) ▁{ ▁char ▁* ▁last _ field ▁= ▁NULL ▁; ▁apr _ size _ t ▁last _ len ▁= ▁0 ▁; ▁apr _ size _ t ▁alloc _ len ▁= ▁0 ▁; ▁char ▁* ▁field ▁; ▁char ▁* ▁value ▁; ▁apr _ size _ t ▁len ▁; ▁int ▁fields _ read ▁= ▁0 ▁; ▁char ▁* ▁tmp _ field ▁; ▁core _ server _ config ▁* ▁conf ▁= ▁ap _ get _ core _ module _ config ▁( ▁r ▁-> ▁server ▁-> ▁module _ config ▁) ▁; ▁while ▁( ▁1 ▁) ▁{ ▁apr _ status _ t ▁rv ▁; ▁field ▁= ▁NULL ▁; ▁rv ▁= ▁ap _ r get line ▁( ▁& ▁field ▁, ▁r ▁-> ▁server ▁-> ▁limit _ req _ field size ▁+ ▁2 ▁, ▁& ▁len ▁, ▁r ▁, ▁0 ▁, ▁bb ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁if ▁( ▁APR _ STATUS _ IS _ TIME UP ▁( ▁rv ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ REQUEST _ TIME _ OUT ▁; ▁} ▁else ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁} ▁if ▁( ▁rv ▁== ▁APR _ ENO SPC ▁) ▁{ ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Size of are quest header field " ▁" e xce ed ss erver limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 1 ▁) ▁" Request header e xce eds Limit Request Field Size % s " ▁"%.* s " ▁, ▁* ▁field ▁? ▁":" ▁: ▁"" ▁, ▁field _ name _ len ▁( ▁field ▁) ▁, ▁field ▁) ▁; ▁} ▁return ▁; ▁} ▁while ▁( ▁len ▁> ▁1 ▁&& ▁( ▁field ▁[ ▁len ▁- ▁1 ▁] ▁== ▁' ▁\ t ▁' ▁|| ▁field ▁[ ▁len ▁- ▁1 ▁] ▁== ▁' ▁' ▁) ▁) ▁{ ▁field ▁[ ▁-- ▁len ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁* ▁field ▁== ▁' ▁\ t ▁' ▁|| ▁* ▁field ▁== ▁' ▁' ▁) ▁{ ▁apr _ size _ t ▁fold _ len ▁; ▁if ▁( ▁last _ field ▁== ▁NULL ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 42 ▁) ▁" Line f olding en countered be fo ref irst " ▁" header line " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁field ▁[ ▁1 ▁] ▁== ▁' ▁\0 ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 43 ▁) ▁" Empty fol ded line en countered " ▁) ▁; ▁return ▁; ▁} ▁while ▁( ▁field ▁[ ▁1 ▁] ▁== ▁' ▁\ t ▁' ▁|| ▁field ▁[ ▁1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁++ ▁field ▁; ▁-- ▁len ▁; ▁} ▁fold _ len ▁= ▁last _ len ▁+ ▁len ▁+ ▁1 ▁; ▁if ▁( ▁fold _ len ▁>= ▁( ▁apr _ size _ t ▁) ▁( ▁r ▁-> ▁server ▁-> ▁limit _ req _ field size ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Size of are quest header field " ▁" e xce ed ss erver limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 2 ▁) ▁" Request header e xce eds Limit Request Field Size " ▁" after f olding :% .* s " ▁, ▁field _ name _ len ▁( ▁last _ field ▁) ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁fold _ len ▁> ▁alloc _ len ▁) ▁{ ▁char ▁* ▁fold _ buf ▁; ▁alloc _ len ▁+= ▁alloc _ len ▁; ▁if ▁( ▁fold _ len ▁> ▁alloc _ len ▁) ▁{ ▁alloc _ len ▁= ▁fold _ len ▁; ▁} ▁fold _ buf ▁= ▁( ▁char ▁* ▁) ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁alloc _ len ▁) ▁; ▁memcpy ▁( ▁fold _ buf ▁, ▁last _ field ▁, ▁last _ len ▁) ▁; ▁last _ field ▁= ▁fold _ buf ▁; ▁} ▁memcpy ▁( ▁last _ field ▁+ ▁last _ len ▁, ▁field ▁, ▁len ▁+ ▁1 ▁) ▁; ▁if ▁( ▁conf ▁-> ▁http _ con formance ▁& ▁AP _ HTTP _ CON FORM ANCE _ STRICT ▁) ▁{ ▁last _ field ▁[ ▁last _ len ▁] ▁= ▁' ▁' ▁; ▁} ▁last _ len ▁+= ▁len ▁; ▁continue ▁; ▁} ▁else ▁if ▁( ▁last _ field ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁r ▁-> ▁server ▁-> ▁limit _ req _ fields ▁&& ▁( ▁++ ▁fields _ read ▁> ▁r ▁-> ▁server ▁-> ▁limit _ req _ fields ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Th enum ber of request header fields " ▁" e xce ed sth iss erver ' s limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 3 ▁) ▁" Number of request header se xce eds " ▁" Limit Request Fields " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁( ▁conf ▁-> ▁http _ con formance ▁& ▁AP _ HTTP _ CON FORM ANCE _ STRICT ▁) ▁) ▁{ ▁if ▁( ▁! ▁( ▁value ▁= ▁strchr ▁( ▁last _ field ▁, ▁' ▁' ▁) ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 05 64 ▁) ▁" Request header field ism issing ': '" ▁" separator :% .* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁tmp _ field ▁= ▁value ▁- ▁1 ▁; ▁* ▁value ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁while ▁( ▁* ▁value ▁== ▁' ▁' ▁|| ▁* ▁value ▁== ▁' ▁\ t ▁' ▁) ▁{ ▁++ ▁value ▁; ▁} ▁while ▁( ▁tmp _ field ▁> ▁last _ field ▁&& ▁( ▁* ▁tmp _ field ▁== ▁' ▁' ▁|| ▁* ▁tmp _ field ▁== ▁' ▁\ t ▁' ▁) ▁) ▁{ ▁* ▁tmp _ field ▁-- ▁= ▁' ▁\0 ▁' ▁; ▁} ▁} ▁else ▁{ ▁value ▁= ▁( ▁char ▁* ▁) ▁ap _ scan _ http _ token ▁( ▁last _ field ▁) ▁; ▁if ▁( ▁( ▁value ▁== ▁last _ field ▁) ▁|| ▁* ▁value ▁!= ▁' ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 24 26 ▁) ▁" Request header field name ism alformed :" ▁"%.* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁* ▁value ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁while ▁( ▁* ▁value ▁== ▁' ▁' ▁|| ▁* ▁value ▁== ▁' ▁\ t ▁' ▁) ▁{ ▁++ ▁value ▁; ▁} ▁tmp _ field ▁= ▁( ▁char ▁* ▁) ▁ap _ scan _ http _ field _ content ▁( ▁value ▁) ▁; ▁if ▁( ▁* ▁tmp _ field ▁!= ▁' ▁\0 ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 24 27 ▁) ▁" Request header value ism alformed :" ▁"%.* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁value ▁) ▁; ▁return ▁; ▁} ▁} ▁apr _ table _ add n ▁( ▁r ▁-> ▁headers _ in ▁, ▁last _ field ▁, ▁value ▁) ▁; ▁} ▁if ▁( ▁len ▁== ▁0 ▁) ▁{ ▁break ▁; ▁} ▁alloc _ len ▁= ▁0 ▁; ▁last _ field ▁= ▁field ▁; ▁last _ len ▁= ▁len ▁; ▁} ▁apr _ table _ compress ▁( ▁r ▁-> ▁headers _ in ▁, ▁APR _ OVER LAP _ TABLES _ MERGE ▁) ▁; ▁apr _ table _ do ▁( ▁table _ do _ fn _ check _ length s ▁, ▁r ▁, ▁r ▁-> ▁headers _ in ▁, ▁NULL ▁) ▁; ▁}	0
▁static ▁av _ cold ▁int ▁q dm 2_ decode _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁Q DM 2 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁uint 8_ t ▁* ▁extradata ▁; ▁int ▁extradata _ size ▁; ▁int ▁tmp _ val ▁, ▁tmp ▁, ▁size ▁; ▁if ▁( ▁! ▁avctx ▁-> ▁extradata ▁|| ▁( ▁avctx ▁-> ▁extradata _ size ▁< ▁48 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" extr ad at am issing ort r unc ated \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁= ▁avctx ▁-> ▁extradata ▁; ▁extradata _ size ▁= ▁avctx ▁-> ▁extradata _ size ▁; ▁while ▁( ▁extradata _ size ▁> ▁7 ▁) ▁{ ▁if ▁( ▁! ▁memcmp ▁( ▁extradata ▁, ▁" fr ma Q DM " ▁, ▁7 ▁) ▁) ▁break ▁; ▁extradata ▁++ ▁; ▁extradata _ size ▁-- ▁; ▁} ▁if ▁( ▁extradata _ size ▁< ▁12 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" not en oug hex tr adata (% i )\ n " ▁, ▁extradata _ size ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁memcmp ▁( ▁extradata ▁, ▁" fr ma Q DM " ▁, ▁7 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid headers , Q DM ? not found \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁extradata ▁[ ▁7 ▁] ▁== ▁' ▁' ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" stream is Q D MC version 1, which is not supported \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁+= ▁8 ▁; ▁extradata _ size ▁-= ▁8 ▁; ▁size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁if ▁( ▁size ▁> ▁extradata _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" extr ad atas iz et oo small ,% i < % i \ n " ▁, ▁extradata _ size ▁, ▁size ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁+= ▁4 ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" size :% d \ n " ▁, ▁size ▁) ▁; ▁if ▁( ▁AV _ RB 32 ▁( ▁extradata ▁) ▁!= ▁M KB ET AG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" inval i dex tr adata , expect ing Q D CA \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁+= ▁8 ▁; ▁avctx ▁-> ▁channels ▁= ▁s ▁-> ▁nb _ channels ▁= ▁s ▁-> ▁channels ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁if ▁( ▁s ▁-> ▁channels ▁> ▁M PA _ MAX _ CHANNELS ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avctx ▁-> ▁sample _ rate ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁s ▁-> ▁group _ size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁s ▁-> ▁fft _ size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁s ▁-> ▁checksum _ size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁s ▁-> ▁fft _ order ▁= ▁av _ log 2 ▁( ▁s ▁-> ▁fft _ size ▁) ▁+ ▁1 ▁; ▁s ▁-> ▁fft _ frame _ size ▁= ▁2 ▁* ▁s ▁-> ▁fft _ size ▁; ▁s ▁-> ▁group _ order ▁= ▁av _ log 2 ▁( ▁s ▁-> ▁group _ size ▁) ▁+ ▁1 ▁; ▁s ▁-> ▁frame _ size ▁= ▁s ▁-> ▁group _ size ▁/ ▁16 ▁; ▁if ▁( ▁s ▁-> ▁frame _ size ▁> ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁output _ buffer ▁) ▁/ ▁2 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁s ▁-> ▁sub _ sampling ▁= ▁s ▁-> ▁fft _ order ▁- ▁7 ▁; ▁s ▁-> ▁frequency _ range ▁= ▁255 ▁/ ▁( ▁1 ▁<< ▁( ▁2 ▁- ▁s ▁-> ▁sub _ sampling ▁) ▁) ▁; ▁switch ▁( ▁( ▁s ▁-> ▁sub _ sampling ▁* ▁2 ▁+ ▁s ▁-> ▁channels ▁- ▁1 ▁) ▁) ▁{ ▁case ▁0 ▁: ▁tmp ▁= ▁40 ▁; ▁break ▁; ▁case ▁1 ▁: ▁tmp ▁= ▁48 ▁; ▁break ▁; ▁case ▁2 ▁: ▁tmp ▁= ▁56 ▁; ▁break ▁; ▁case ▁3 ▁: ▁tmp ▁= ▁72 ▁; ▁break ▁; ▁case ▁4 ▁: ▁tmp ▁= ▁80 ▁; ▁break ▁; ▁case ▁5 ▁: ▁tmp ▁= ▁100 ▁; ▁break ▁; ▁default ▁: ▁tmp ▁= ▁s ▁-> ▁sub _ sampling ▁; ▁break ▁; ▁} ▁tmp _ val ▁= ▁0 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁1000 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁1 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁14 40 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁2 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁1 760 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁3 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁22 40 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁4 ▁; ▁s ▁-> ▁cm _ table _ select ▁= ▁tmp _ val ▁; ▁if ▁( ▁s ▁-> ▁sub _ sampling ▁== ▁0 ▁) ▁tmp ▁= ▁7 999 ▁; ▁else ▁tmp ▁= ▁( ▁( ▁- ▁( ▁s ▁-> ▁sub _ sampling ▁- ▁1 ▁) ▁) ▁& ▁8000 ▁) ▁+ ▁20000 ▁; ▁if ▁( ▁tmp ▁< ▁8000 ▁) ▁s ▁-> ▁coeff _ per _ sb _ select ▁= ▁0 ▁; ▁else ▁if ▁( ▁tmp ▁<= ▁16000 ▁) ▁s ▁-> ▁coeff _ per _ sb _ select ▁= ▁1 ▁; ▁else ▁s ▁-> ▁coeff _ per _ sb _ select ▁= ▁2 ▁; ▁if ▁( ▁( ▁s ▁-> ▁fft _ order ▁< ▁7 ▁) ▁|| ▁( ▁s ▁-> ▁fft _ order ▁> ▁9 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown FFT order (% d ), contact the developers !\ n " ▁, ▁s ▁-> ▁fft _ order ▁) ▁; ▁return ▁-1 ▁; ▁} ▁ff _ rd ft _ init ▁( ▁& ▁s ▁-> ▁rd ft _ ctx ▁, ▁s ▁-> ▁fft _ order ▁, ▁ID FT _ C 2 R ▁) ▁; ▁ff _ mp ad sp _ init ▁( ▁& ▁s ▁-> ▁mp ad sp ▁) ▁; ▁q dm 2_ init ▁( ▁s ▁) ▁; ▁avctx ▁-> ▁sample _ fmt ▁= ▁AV _ SAMPLE _ FMT _ S 16 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁ff m _ seek 1 ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int 64_ t ▁pos 1 ▁) ▁{ ▁FF M Context ▁* ▁ff m ▁= ▁s ▁-> ▁priv _ data ▁; ▁Byte IO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int 64_ t ▁pos ▁; ▁pos ▁= ▁FF MIN ▁( ▁pos 1 ▁, ▁ff m ▁-> ▁file _ size ▁- ▁FF M _ PACKET _ SIZE ▁) ▁; ▁pos ▁= ▁FF MAX ▁( ▁pos ▁, ▁FF M _ PACKET _ SIZE ▁) ▁; ▁# ifdef ▁DEBUG _ SEEK ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" seek to %" ▁PRIx 64 ▁"-> %" ▁PRIx 64 ▁"\ n " ▁, ▁pos 1 ▁, ▁pos ▁) ▁; ▁# endif ▁url _ f seek ▁( ▁pb ▁, ▁pos ▁, ▁SEEK _ SET ▁) ▁; ▁}	0
▁static ▁int ▁decode _ tile ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁J peg 2000 Tile ▁* ▁tile ▁) ▁{ ▁int ▁comp no ▁, ▁res level no ▁, ▁band no ▁; ▁int ▁x ▁, ▁y ▁, ▁* ▁src ▁[ ▁4 ▁] ▁; ▁uint 8_ t ▁* ▁line ▁; ▁J peg 2000 T 1 Context ▁t 1 ▁; ▁for ▁( ▁comp no ▁= ▁0 ▁; ▁comp no ▁< ▁s ▁-> ▁n components ▁; ▁comp no ▁++ ▁) ▁{ ▁J peg 2000 Component ▁* ▁comp ▁= ▁tile ▁-> ▁comp ▁+ ▁comp no ▁; ▁J peg 2000 Coding Style ▁* ▁co dst y ▁= ▁tile ▁-> ▁co dst y ▁+ ▁comp no ▁; ▁for ▁( ▁res level no ▁= ▁0 ▁; ▁res level no ▁< ▁co dst y ▁-> ▁n res levels 2 decode ▁; ▁res level no ▁++ ▁) ▁{ ▁J peg 2000 Res Level ▁* ▁r level ▁= ▁comp ▁-> ▁res level ▁+ ▁res level no ▁; ▁for ▁( ▁band no ▁= ▁0 ▁; ▁band no ▁< ▁r level ▁-> ▁nb ands ▁; ▁band no ▁++ ▁) ▁{ ▁int ▁nb _ prec inct s ▁, ▁prec no ▁; ▁J peg 2000 Band ▁* ▁band ▁= ▁r level ▁-> ▁band ▁+ ▁band no ▁; ▁int ▁cb lk x ▁, ▁cb lk y ▁, ▁cb lk no ▁= ▁0 ▁, ▁band pos ▁; ▁band pos ▁= ▁band no ▁+ ▁( ▁res level no ▁> ▁0 ▁) ▁; ▁if ▁( ▁band ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁== ▁band ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁|| ▁band ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁== ▁band ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁continue ▁; ▁nb _ prec inct s ▁= ▁r level ▁-> ▁num _ prec inct s _ x ▁* ▁r level ▁-> ▁num _ prec inct s _ y ▁; ▁for ▁( ▁prec no ▁= ▁0 ▁; ▁prec no ▁< ▁nb _ prec inct s ▁; ▁prec no ▁++ ▁) ▁{ ▁J peg 2000 Prec ▁* ▁prec ▁= ▁band ▁-> ▁prec ▁+ ▁prec no ▁; ▁for ▁( ▁cb lk no ▁= ▁0 ▁; ▁cb lk no ▁< ▁prec ▁-> ▁nb _ code blocks _ width ▁* ▁prec ▁-> ▁nb _ code blocks _ height ▁; ▁cb lk no ▁++ ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁int ▁i ▁, ▁j ▁; ▁J peg 2000 C blk ▁* ▁cb lk ▁= ▁prec ▁-> ▁cb lk ▁+ ▁cb lk no ▁; ▁decode _ cb lk ▁( ▁s ▁, ▁co dst y ▁, ▁& ▁t 1 ▁, ▁cb lk ▁, ▁cb lk ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁- ▁cb lk ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁cb lk ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁- ▁cb lk ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁band pos ▁) ▁; ▁x ▁= ▁cb lk ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁y ▁= ▁cb lk ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁if ▁( ▁co dst y ▁-> ▁transform ▁== ▁FF _ D WT 97 ▁) ▁de quant ization _ float ▁( ▁x ▁, ▁y ▁, ▁cb lk ▁, ▁comp ▁, ▁& ▁t 1 ▁, ▁band ▁) ▁; ▁else ▁de quant ization _ int ▁( ▁x ▁, ▁y ▁, ▁cb lk ▁, ▁comp ▁, ▁& ▁t 1 ▁, ▁band ▁) ▁; ▁} ▁} ▁} ▁} ▁ff _ d wt _ decode ▁( ▁& ▁comp ▁-> ▁d wt ▁, ▁comp ▁-> ▁data ▁) ▁; ▁src ▁[ ▁comp no ▁] ▁= ▁comp ▁-> ▁data ▁; ▁} ▁if ▁( ▁tile ▁-> ▁co dst y ▁[ ▁0 ▁] ▁. ▁m ct ▁) ▁m ct _ decode ▁( ▁s ▁, ▁tile ▁) ▁; ▁if ▁( ▁s ▁-> ▁precision ▁<= ▁8 ▁) ▁{ ▁for ▁( ▁comp no ▁= ▁0 ▁; ▁comp no ▁< ▁s ▁-> ▁n components ▁; ▁comp no ▁++ ▁) ▁{ ▁J peg 2000 Component ▁* ▁comp ▁= ▁tile ▁-> ▁comp ▁+ ▁comp no ▁; ▁float ▁* ▁datap ▁= ▁( ▁float ▁* ▁) ▁comp ▁-> ▁data ▁; ▁int 32_ t ▁* ▁i _ datap ▁= ▁( ▁int 32_ t ▁* ▁) ▁comp ▁-> ▁data ▁; ▁y ▁= ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁- ▁s ▁-> ▁image _ offset _ y ▁; ▁line ▁= ▁s ▁-> ▁picture ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁y ▁* ▁s ▁-> ▁picture ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁for ▁( ▁; ▁y ▁< ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁- ▁s ▁-> ▁image _ offset _ y ▁; ▁y ▁+= ▁s ▁-> ▁cd y ▁[ ▁comp no ▁] ▁) ▁{ ▁uint 8_ t ▁* ▁dst ▁; ▁x ▁= ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁- ▁s ▁-> ▁image _ offset _ x ▁; ▁dst ▁= ▁line ▁+ ▁x ▁* ▁s ▁-> ▁n components ▁+ ▁comp no ▁; ▁for ▁( ▁; ▁x ▁< ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁- ▁s ▁-> ▁image _ offset _ x ▁; ▁x ▁+= ▁s ▁-> ▁cd x ▁[ ▁comp no ▁] ▁) ▁{ ▁int ▁val ▁; ▁if ▁( ▁tile ▁-> ▁co dst y ▁-> ▁transform ▁== ▁FF _ D WT 97 ▁) ▁val ▁= ▁l rintf ▁( ▁* ▁datap ▁) ▁+ ▁( ▁1 ▁<< ▁( ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁- ▁1 ▁) ▁) ▁; ▁else ▁val ▁= ▁* ▁i _ datap ▁+ ▁( ▁1 ▁<< ▁( ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁- ▁1 ▁) ▁) ▁; ▁val ▁= ▁av _ clip ▁( ▁val ▁, ▁0 ▁, ▁( ▁1 ▁<< ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁) ▁- ▁1 ▁) ▁; ▁* ▁dst ▁= ▁val ▁<< ▁( ▁8 ▁- ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁) ▁; ▁datap ▁++ ▁; ▁i _ datap ▁++ ▁; ▁dst ▁+= ▁s ▁-> ▁n components ▁; ▁} ▁line ▁+= ▁s ▁-> ▁picture ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁comp no ▁= ▁0 ▁; ▁comp no ▁< ▁s ▁-> ▁n components ▁; ▁comp no ▁++ ▁) ▁{ ▁J peg 2000 Component ▁* ▁comp ▁= ▁tile ▁-> ▁comp ▁+ ▁comp no ▁; ▁float ▁* ▁datap ▁= ▁( ▁float ▁* ▁) ▁comp ▁-> ▁data ▁; ▁int 32_ t ▁* ▁i _ datap ▁= ▁( ▁int 32_ t ▁* ▁) ▁comp ▁-> ▁data ▁; ▁uint 16_ t ▁* ▁lin el ▁; ▁y ▁= ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁- ▁s ▁-> ▁image _ offset _ y ▁; ▁lin el ▁= ▁( ▁uint 16_ t ▁* ▁) ▁s ▁-> ▁picture ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁y ▁* ▁( ▁s ▁-> ▁picture ▁-> ▁linesize ▁[ ▁0 ▁] ▁>> ▁1 ▁) ▁; ▁for ▁( ▁; ▁y ▁< ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁- ▁s ▁-> ▁image _ offset _ y ▁; ▁y ▁+= ▁s ▁-> ▁cd y ▁[ ▁comp no ▁] ▁) ▁{ ▁uint 16_ t ▁* ▁dst ▁; ▁x ▁= ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁- ▁s ▁-> ▁image _ offset _ x ▁; ▁dst ▁= ▁lin el ▁+ ▁( ▁x ▁* ▁s ▁-> ▁n components ▁+ ▁comp no ▁) ▁; ▁for ▁( ▁; ▁x ▁< ▁tile ▁-> ▁comp ▁[ ▁comp no ▁] ▁. ▁coord ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁- ▁s ▁-> ▁image _ offset _ x ▁; ▁x ▁+= ▁s ▁-> ▁cd x ▁[ ▁comp no ▁] ▁) ▁{ ▁int ▁val ▁; ▁if ▁( ▁tile ▁-> ▁co dst y ▁-> ▁transform ▁== ▁FF _ D WT 97 ▁) ▁val ▁= ▁l rintf ▁( ▁* ▁datap ▁) ▁+ ▁( ▁1 ▁<< ▁( ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁- ▁1 ▁) ▁) ▁; ▁else ▁val ▁= ▁* ▁i _ datap ▁+ ▁( ▁1 ▁<< ▁( ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁- ▁1 ▁) ▁) ▁; ▁val ▁= ▁av _ clip ▁( ▁val ▁, ▁0 ▁, ▁( ▁1 ▁<< ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁) ▁- ▁1 ▁) ▁; ▁* ▁dst ▁= ▁val ▁<< ▁( ▁16 ▁- ▁s ▁-> ▁cb ps ▁[ ▁comp no ▁] ▁) ▁; ▁datap ▁++ ▁; ▁i _ datap ▁++ ▁; ▁dst ▁+= ▁s ▁-> ▁n components ▁; ▁} ▁lin el ▁+= ▁s ▁-> ▁picture ▁-> ▁linesize ▁[ ▁0 ▁] ▁>> ▁1 ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁Ch op Up Single Un compressed Strip ▁( ▁TIFF ▁* ▁tif ▁) ▁{ ▁register ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁uint 64 ▁byte count ▁; ▁uint 64 ▁offset ▁; ▁uint 32 ▁row block ▁; ▁uint 64 ▁row block bytes ▁; ▁uint 64 ▁strip bytes ▁; ▁uint 32 ▁strip ▁; ▁uint 64 ▁n stri ps 64 ▁; ▁uint 32 ▁n stri ps 32 ▁; ▁uint 32 ▁rows per strip ▁; ▁uint 64 ▁* ▁new counts ▁; ▁uint 64 ▁* ▁new offsets ▁; ▁byte count ▁= ▁td ▁-> ▁td _ strip byte count ▁[ ▁0 ▁] ▁; ▁offset ▁= ▁td ▁-> ▁td _ strip offset ▁[ ▁0 ▁] ▁; ▁assert ▁( ▁td ▁-> ▁td _ planar config ▁== ▁PLAN AR CONFIG _ CON TI G ▁) ▁; ▁if ▁( ▁( ▁td ▁-> ▁td _ ph ot om etric ▁== ▁P HOTO METRIC _ Y CB CR ▁) ▁&& ▁( ▁! ▁is Up Sample d ▁( ▁tif ▁) ▁) ▁) ▁row block ▁= ▁td ▁-> ▁td _ y cb cr sub sampling ▁[ ▁1 ▁] ▁; ▁else ▁row block ▁= ▁1 ▁; ▁row block bytes ▁= ▁TIFF V Tile Size 64 ▁( ▁tif ▁, ▁row block ▁) ▁; ▁if ▁( ▁row block bytes ▁> ▁STR IP _ SIZE _ DEFAULT ▁) ▁{ ▁strip bytes ▁= ▁row block bytes ▁; ▁rows per strip ▁= ▁row block ▁; ▁} ▁else ▁if ▁( ▁row block bytes ▁> ▁0 ▁) ▁{ ▁uint 32 ▁row blocks per strip ▁; ▁row blocks per strip ▁= ▁( ▁uint 32 ▁) ▁( ▁STR IP _ SIZE _ DEFAULT ▁/ ▁row block bytes ▁) ▁; ▁rows per strip ▁= ▁row blocks per strip ▁* ▁row block ▁; ▁strip bytes ▁= ▁row blocks per strip ▁* ▁row block bytes ▁; ▁} ▁else ▁return ▁; ▁if ▁( ▁rows per strip ▁>= ▁td ▁-> ▁td _ rows per strip ▁) ▁return ▁; ▁n stri ps 64 ▁= ▁TIFF how many _64 ▁( ▁byte count ▁, ▁strip bytes ▁) ▁; ▁if ▁( ▁( ▁n stri ps 64 ▁== ▁0 ▁) ▁|| ▁( ▁n stri ps 64 ▁> ▁0 xFFFFFFFF ▁) ▁) ▁return ▁; ▁n stri ps 32 ▁= ▁( ▁uint 32 ▁) ▁n stri ps 64 ▁; ▁new counts ▁= ▁( ▁uint 64 ▁* ▁) ▁_ TIFF Check Malloc ▁( ▁tif ▁, ▁n stri ps 32 ▁, ▁sizeof ▁( ▁uint 64 ▁) ▁, ▁" for cho pped \" Strip Byte Counts \" array " ▁) ▁; ▁new offsets ▁= ▁( ▁uint 64 ▁* ▁) ▁_ TIFF Check Malloc ▁( ▁tif ▁, ▁n stri ps 32 ▁, ▁sizeof ▁( ▁uint 64 ▁) ▁, ▁" for cho pped \" Strip Offsets \" array " ▁) ▁; ▁if ▁( ▁new counts ▁== ▁NULL ▁|| ▁new offsets ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁new counts ▁!= ▁NULL ▁) ▁_ TIFF free ▁( ▁new counts ▁) ▁; ▁if ▁( ▁new offsets ▁!= ▁NULL ▁) ▁_ TIFF free ▁( ▁new offsets ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁strip ▁= ▁0 ▁; ▁strip ▁< ▁n stri ps 32 ▁; ▁strip ▁++ ▁) ▁{ ▁if ▁( ▁strip bytes ▁> ▁byte count ▁) ▁strip bytes ▁= ▁byte count ▁; ▁new counts ▁[ ▁strip ▁] ▁= ▁strip bytes ▁; ▁new offsets ▁[ ▁strip ▁] ▁= ▁offset ▁; ▁offset ▁+= ▁strip bytes ▁; ▁byte count ▁-= ▁strip bytes ▁; ▁} ▁td ▁-> ▁td _ stri ps per image ▁= ▁td ▁-> ▁td _ n stri ps ▁= ▁n stri ps 32 ▁; ▁TIFF Set Field ▁( ▁tif ▁, ▁TIFF TAG _ ROW SP ER STRIP ▁, ▁rows per strip ▁) ▁; ▁_ TIFF free ▁( ▁td ▁-> ▁td _ strip byte count ▁) ▁; ▁_ TIFF free ▁( ▁td ▁-> ▁td _ strip offset ▁) ▁; ▁td ▁-> ▁td _ strip byte count ▁= ▁new counts ▁; ▁td ▁-> ▁td _ strip offset ▁= ▁new offsets ▁; ▁td ▁-> ▁td _ strip byte count sorted ▁= ▁1 ▁; ▁}	1
▁static ▁int ▁on 2 avc _ decode _ band _ scale s ▁( ▁On 2 AV C Context ▁* ▁c ▁, ▁Get Bit Context ▁* ▁gb ▁) ▁{ ▁int ▁w ▁, ▁w 2 ▁, ▁b ▁, ▁scale ▁, ▁first ▁= ▁1 ▁; ▁int ▁band _ off ▁= ▁0 ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁c ▁-> ▁num _ windows ▁; ▁w ▁++ ▁) ▁{ ▁if ▁( ▁! ▁c ▁-> ▁grouping ▁[ ▁w ▁] ▁) ▁{ ▁memcpy ▁( ▁c ▁-> ▁band _ scale s ▁+ ▁band _ off ▁, ▁c ▁-> ▁band _ scale s ▁+ ▁band _ off ▁- ▁c ▁-> ▁num _ band s ▁, ▁c ▁-> ▁num _ band s ▁* ▁sizeof ▁( ▁* ▁c ▁-> ▁band _ scale s ▁) ▁) ▁; ▁band _ off ▁+= ▁c ▁-> ▁num _ band s ▁; ▁continue ▁; ▁} ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁< ▁c ▁-> ▁num _ band s ▁; ▁b ▁++ ▁) ▁{ ▁if ▁( ▁! ▁c ▁-> ▁band _ type ▁[ ▁band _ off ▁] ▁) ▁{ ▁int ▁all _ zero ▁= ▁1 ▁; ▁for ▁( ▁w 2 ▁= ▁w ▁+ ▁1 ▁; ▁w 2 ▁< ▁c ▁-> ▁num _ windows ▁; ▁w 2 ▁++ ▁) ▁{ ▁if ▁( ▁c ▁-> ▁grouping ▁[ ▁w 2 ▁] ▁) ▁break ▁; ▁if ▁( ▁c ▁-> ▁band _ type ▁[ ▁w 2 ▁* ▁c ▁-> ▁num _ band s ▁+ ▁b ▁] ▁) ▁{ ▁all _ zero ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁all _ zero ▁) ▁{ ▁c ▁-> ▁band _ scale s ▁[ ▁band _ off ▁++ ▁] ▁= ▁0 ▁; ▁continue ▁; ▁} ▁} ▁if ▁( ▁first ▁) ▁{ ▁scale ▁= ▁get _ bits ▁( ▁gb ▁, ▁7 ▁) ▁; ▁first ▁= ▁0 ▁; ▁} ▁else ▁{ ▁scale ▁+= ▁get _ vlc 2 ▁( ▁gb ▁, ▁c ▁-> ▁scale _ diff ▁. ▁table ▁, ▁9 ▁, ▁3 ▁) ▁- ▁60 ▁; ▁} ▁if ▁( ▁scale ▁< ▁0 ▁|| ▁scale ▁> ▁128 ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid scale value % d \ n " ▁, ▁scale ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁c ▁-> ▁band _ scale s ▁[ ▁band _ off ▁++ ▁] ▁= ▁c ▁-> ▁scale _ tab ▁[ ▁scale ▁] ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁void ▁add _ all _ tests ▁( ▁const ▁char ▁* ▁test _ case _ name ▁, ▁int ▁( ▁* ▁test _ fn ▁) ▁( ▁int ▁idx ▁) ▁, ▁int ▁num ▁, ▁int ▁subtest ▁) ▁{ ▁assert ▁( ▁num _ tests ▁!= ▁OSSL _ NE LEM ▁( ▁all _ tests ▁) ▁) ▁; ▁all _ tests ▁[ ▁num _ tests ▁] ▁. ▁test _ case _ name ▁= ▁test _ case _ name ▁; ▁all _ tests ▁[ ▁num _ tests ▁] ▁. ▁param _ test _ fn ▁= ▁test _ fn ▁; ▁all _ tests ▁[ ▁num _ tests ▁] ▁. ▁num ▁= ▁num ▁; ▁all _ tests ▁[ ▁num _ tests ▁] ▁. ▁subtest ▁= ▁subtest ▁; ▁++ ▁num _ tests ▁; ▁num _ test _ cases ▁+= ▁num ▁; ▁}	1
▁static ▁int ▁mov _ read _ ud ta _ string ▁( ▁MOV Context ▁* ▁c ▁, ▁AVIO Context ▁* ▁pb ▁, ▁MOV Atom ▁atom ▁) ▁{ ▁char ▁tmp _ key ▁[ ▁5 ▁] ▁; ▁char ▁* ▁str ▁, ▁key 2 ▁[ ▁32 ▁] ▁, ▁language ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁const ▁char ▁* ▁key ▁= ▁NULL ▁; ▁uint 16_ t ▁lang code ▁= ▁0 ▁; ▁uint 32_ t ▁data _ type ▁= ▁0 ▁, ▁str _ size ▁, ▁str _ size _ alloc ▁; ▁int ▁( ▁* ▁parse ▁) ▁( ▁MOV Context ▁* ▁, ▁AVIO Context ▁* ▁, ▁unsigned ▁, ▁const ▁char ▁* ▁) ▁= ▁NULL ▁; ▁switch ▁( ▁atom ▁. ▁type ▁) ▁{ ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" title " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" art ist " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" album _ art ist " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" comp oser " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" copyright " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" comment " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" album " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" date " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" gen re " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" gen re " ▁; ▁parse ▁= ▁mov _ metadata _ gn re ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" encoder " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" encoder " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" location " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" description " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" syn ops is " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" show " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" ep isode _ id " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" network " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" track " ▁; ▁parse ▁= ▁mov _ metadata _ track _ or _ disc _ number ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" disc " ▁; ▁parse ▁= ▁mov _ metadata _ track _ or _ disc _ number ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" ep isode _ sort " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ bypass _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" se ason _ number " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ bypass _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" media _ type " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ no _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" hd _ video " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ no _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" gap less _ playback " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ no _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁return ▁mov _ metadata _ loc i ▁( ▁c ▁, ▁pb ▁, ▁atom ▁. ▁size ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁it unes _ metadata ▁&& ▁atom ▁. ▁size ▁> ▁8 ▁) ▁{ ▁int ▁data _ size ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁int ▁tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁tag ▁== ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁data _ type ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁str _ size ▁= ▁data _ size ▁- ▁16 ▁; ▁atom ▁. ▁size ▁-= ▁16 ▁; ▁if ▁( ▁atom ▁. ▁type ▁== ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁int ▁ret ▁= ▁mov _ read _ co vr ▁( ▁c ▁, ▁pb ▁, ▁data _ type ▁, ▁str _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error parsing cover art .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁} ▁else ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁atom ▁. ▁size ▁> ▁4 ▁&& ▁key ▁&& ▁! ▁c ▁-> ▁it unes _ metadata ▁) ▁{ ▁str _ size ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁lang code ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁ff _ mov _ lang _ to _ iso 639 ▁( ▁lang code ▁, ▁language ▁) ▁; ▁atom ▁. ▁size ▁-= ▁4 ▁; ▁} ▁else ▁str _ size ▁= ▁atom ▁. ▁size ▁; ▁if ▁( ▁c ▁-> ▁export _ all ▁&& ▁! ▁key ▁) ▁{ ▁snprintf ▁( ▁tmp _ key ▁, ▁5 ▁, ▁"% .4 s " ▁, ▁( ▁char ▁* ▁) ▁& ▁atom ▁. ▁type ▁) ▁; ▁key ▁= ▁tmp _ key ▁; ▁} ▁if ▁( ▁! ▁key ▁) ▁return ▁0 ▁; ▁if ▁( ▁atom ▁. ▁size ▁< ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁str _ size _ alloc ▁= ▁str _ size ▁* ▁2 ▁; ▁str ▁= ▁av _ malloc ▁( ▁str _ size _ alloc ▁) ▁; ▁if ▁( ▁! ▁str ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁parse ▁) ▁parse ▁( ▁c ▁, ▁pb ▁, ▁str _ size ▁, ▁key ▁) ▁; ▁else ▁{ ▁if ▁( ▁data _ type ▁== ▁3 ▁|| ▁( ▁data _ type ▁== ▁0 ▁&& ▁( ▁lang code ▁< ▁0 x 400 ▁|| ▁lang code ▁== ▁0 x 7 fff ▁) ▁) ▁) ▁{ ▁mov _ read _ mac _ string ▁( ▁c ▁, ▁pb ▁, ▁str _ size ▁, ▁str ▁, ▁str _ size _ alloc ▁) ▁; ▁} ▁else ▁{ ▁avio _ read ▁( ▁pb ▁, ▁str ▁, ▁str _ size ▁) ▁; ▁str ▁[ ▁str _ size ▁] ▁= ▁0 ▁; ▁} ▁c ▁-> ▁fc ▁-> ▁event _ flags ▁|= ▁AV FMT _ EVENT _ FLAG _ METADATA _ UPDATED ▁; ▁av _ dict _ set ▁( ▁& ▁c ▁-> ▁fc ▁-> ▁metadata ▁, ▁key ▁, ▁str ▁, ▁0 ▁) ▁; ▁if ▁( ▁* ▁language ▁&& ▁strcmp ▁( ▁language ▁, ▁" und " ▁) ▁) ▁{ ▁snprintf ▁( ▁key 2 ▁, ▁sizeof ▁( ▁key 2 ▁) ▁, ▁"% s -% s " ▁, ▁key ▁, ▁language ▁) ▁; ▁av _ dict _ set ▁( ▁& ▁c ▁-> ▁fc ▁-> ▁metadata ▁, ▁key 2 ▁, ▁str ▁, ▁0 ▁) ▁; ▁} ▁} ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" lang \" %3 s \"" ▁, ▁language ▁) ▁; ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" tag \"% s \" value \"% s \" atom \"% .4 s \"% d %" ▁PRId 64 ▁"\ n " ▁, ▁key ▁, ▁str ▁, ▁( ▁char ▁* ▁) ▁& ▁atom ▁. ▁type ▁, ▁str _ size _ alloc ▁, ▁atom ▁. ▁size ▁) ▁; ▁av _ freep ▁( ▁& ▁str ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁dca _ parse _ params ▁( ▁D CAP arse Context ▁* ▁pc 1 ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁int ▁* ▁duration ▁, ▁int ▁* ▁sample _ rate ▁, ▁int ▁* ▁profile ▁) ▁{ ▁D CA Ex ss Asset ▁* ▁asset ▁= ▁& ▁pc 1 ▁-> ▁ex ss ▁. ▁assets ▁[ ▁0 ▁] ▁; ▁Get Bit Context ▁gb ▁; ▁DC AC ore Frame Header ▁h ▁; ▁uint 8_ t ▁hdr ▁[ ▁D CA _ CORE _ FRAME _ HEADER _ SIZE ▁+ ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁ret ▁, ▁frame _ size ▁; ▁if ▁( ▁buf _ size ▁< ▁D CA _ CORE _ FRAME _ HEADER _ SIZE ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁AV _ RB 32 ▁( ▁buf ▁) ▁== ▁D CA _ SYNC WORD _ SUB STREAM ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁ff _ d ca _ ex ss _ parse ▁( ▁& ▁pc 1 ▁-> ▁ex ss ▁, ▁buf ▁, ▁buf _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁asset ▁-> ▁extension _ mask ▁& ▁D CA _ EX SS _ L BR ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁init _ get _ bits 8 ▁( ▁& ▁gb ▁, ▁buf ▁+ ▁asset ▁-> ▁l br _ offset ▁, ▁asset ▁-> ▁l br _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁get _ bits _ long ▁( ▁& ▁gb ▁, ▁32 ▁) ▁!= ▁D CA _ SYNC WORD _ L BR ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁switch ▁( ▁get _ bits ▁( ▁& ▁gb ▁, ▁8 ▁) ▁) ▁{ ▁case ▁D CA _ L BR _ HEADER _ DECODER _ INIT ▁: ▁pc 1 ▁-> ▁sr _ code ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁8 ▁) ▁; ▁case ▁D CA _ L BR _ HEADER _ SYNC _ ONLY ▁: ▁break ▁; ▁default ▁: ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁pc 1 ▁-> ▁sr _ code ▁>= ▁FF _ ARRAY _ ELEMS ▁( ▁ff _ d ca _ sampling _ freq s ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁* ▁sample _ rate ▁= ▁ff _ d ca _ sampling _ freq s ▁[ ▁pc 1 ▁-> ▁sr _ code ▁] ▁; ▁* ▁duration ▁= ▁1024 ▁<< ▁ff _ d ca _ freq _ ranges ▁[ ▁pc 1 ▁-> ▁sr _ code ▁] ▁; ▁* ▁profile ▁= ▁FF _ PROFILE _ D TS _ EXPR ESS ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁asset ▁-> ▁extension _ mask ▁& ▁D CA _ EX SS _ X LL ▁) ▁{ ▁int ▁ns amples _ log 2 ▁; ▁if ▁( ▁( ▁ret ▁= ▁init _ get _ bits 8 ▁( ▁& ▁gb ▁, ▁buf ▁+ ▁asset ▁-> ▁x ll _ offset ▁, ▁asset ▁-> ▁x ll _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁get _ bits _ long ▁( ▁& ▁gb ▁, ▁32 ▁) ▁!= ▁D CA _ SYNC WORD _ X LL ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁get _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁skip _ bits ▁( ▁& ▁gb ▁, ▁8 ▁) ▁; ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁get _ bits ▁( ▁& ▁gb ▁, ▁5 ▁) ▁+ ▁1 ▁) ▁; ▁skip _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁ns amples _ log 2 ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁+ ▁get _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁if ▁( ▁ns amples _ log 2 ▁> ▁24 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁* ▁sample _ rate ▁= ▁asset ▁-> ▁max _ sample _ rate ▁; ▁* ▁duration ▁= ▁( ▁1 ▁+ ▁( ▁* ▁sample _ rate ▁> ▁96 000 ▁) ▁) ▁<< ▁ns amples _ log 2 ▁; ▁* ▁profile ▁= ▁FF _ PROFILE _ D TS _ HD _ MA ▁; ▁return ▁0 ▁; ▁} ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁avpriv _ d ca _ convert _ bit stream ▁( ▁buf ▁, ▁D CA _ CORE _ FRAME _ HEADER _ SIZE ▁, ▁hdr ▁, ▁D CA _ CORE _ FRAME _ HEADER _ SIZE ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁avpriv _ d ca _ parse _ core _ frame _ header ▁( ▁& ▁h ▁, ▁hdr ▁, ▁ret ▁) ▁< ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁* ▁duration ▁= ▁h ▁. ▁npc mb locks ▁* ▁D CA _ PC MB LOCK _ SAMPLES ▁; ▁* ▁sample _ rate ▁= ▁avpriv _ d ca _ sample _ rates ▁[ ▁h ▁. ▁sr _ code ▁] ▁; ▁if ▁( ▁* ▁profile ▁!= ▁FF _ PROFILE _ UNKNOWN ▁) ▁return ▁0 ▁; ▁* ▁profile ▁= ▁FF _ PROFILE _ D TS ▁; ▁if ▁( ▁h ▁. ▁ext _ audio _ present ▁) ▁{ ▁switch ▁( ▁h ▁. ▁ext _ audio _ type ▁) ▁{ ▁case ▁D CA _ EXT _ AUDIO _ X CH ▁: ▁case ▁D CA _ EXT _ AUDIO _ XX CH ▁: ▁* ▁profile ▁= ▁FF _ PROFILE _ D TS _ ES ▁; ▁break ▁; ▁case ▁D CA _ EXT _ AUDIO _ X 96 ▁: ▁* ▁profile ▁= ▁FF _ PROFILE _ D TS _9 6_ 24 ▁; ▁break ▁; ▁} ▁} ▁frame _ size ▁= ▁FF ALIGN ▁( ▁h ▁. ▁frame _ size ▁, ▁4 ▁) ▁; ▁if ▁( ▁buf _ size ▁- ▁4 ▁< ▁frame _ size ▁) ▁return ▁0 ▁; ▁buf ▁+= ▁frame _ size ▁; ▁buf _ size ▁-= ▁frame _ size ▁; ▁if ▁( ▁AV _ RB 32 ▁( ▁buf ▁) ▁!= ▁D CA _ SYNC WORD _ SUB STREAM ▁) ▁return ▁0 ▁; ▁if ▁( ▁ff _ d ca _ ex ss _ parse ▁( ▁& ▁pc 1 ▁-> ▁ex ss ▁, ▁buf ▁, ▁buf _ size ▁) ▁< ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁asset ▁-> ▁extension _ mask ▁& ▁D CA _ EX SS _ X LL ▁) ▁* ▁profile ▁= ▁FF _ PROFILE _ D TS _ HD _ MA ▁; ▁else ▁if ▁( ▁asset ▁-> ▁extension _ mask ▁& ▁( ▁D CA _ EX SS _ X BR ▁| ▁D CA _ EX SS _ XX CH ▁| ▁D CA _ EX SS _ X 96 ▁) ▁) ▁* ▁profile ▁= ▁FF _ PROFILE _ D TS _ HD _ H RA ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁yuv 2 rgb _2_ c _ template ▁( ▁S ws Context ▁* ▁c ▁, ▁const ▁int 16_ t ▁* ▁buf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁ubuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁vbuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁a buf ▁[ ▁2 ▁] ▁, ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁dst W ▁, ▁int ▁y alpha ▁, ▁int ▁u val pha ▁, ▁int ▁y ▁, ▁enum ▁PixelFormat ▁target ▁, ▁int ▁has Alpha ▁) ▁{ ▁const ▁int 16_ t ▁* ▁buf 0 ▁= ▁buf ▁[ ▁0 ▁] ▁, ▁* ▁buf 1 ▁= ▁buf ▁[ ▁1 ▁] ▁, ▁* ▁ubuf 0 ▁= ▁ubuf ▁[ ▁0 ▁] ▁, ▁* ▁ubuf 1 ▁= ▁ubuf ▁[ ▁1 ▁] ▁, ▁* ▁vbuf 0 ▁= ▁vbuf ▁[ ▁0 ▁] ▁, ▁* ▁vbuf 1 ▁= ▁vbuf ▁[ ▁1 ▁] ▁, ▁* ▁a buf 0 ▁= ▁a buf ▁[ ▁0 ▁] ▁, ▁* ▁a buf 1 ▁= ▁a buf ▁[ ▁1 ▁] ▁; ▁int ▁y alpha 1 ▁= ▁4095 ▁- ▁y alpha ▁; ▁int ▁u val pha 1 ▁= ▁4095 ▁- ▁u val pha ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁dst W ▁>> ▁1 ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁Y 1 ▁= ▁( ▁buf 0 ▁[ ▁i ▁* ▁2 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁* ▁2 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁int ▁Y 2 ▁= ▁( ▁buf 0 ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁int ▁U ▁= ▁( ▁ubuf 0 ▁[ ▁i ▁] ▁* ▁u val pha 1 ▁+ ▁ubuf 1 ▁[ ▁i ▁] ▁* ▁u val pha ▁) ▁>> ▁19 ▁; ▁int ▁V ▁= ▁( ▁vbuf 0 ▁[ ▁i ▁] ▁* ▁u val pha 1 ▁+ ▁vbuf 1 ▁[ ▁i ▁] ▁* ▁u val pha ▁) ▁>> ▁19 ▁; ▁int ▁A 1 ▁, ▁A 2 ▁; ▁const ▁void ▁* ▁r ▁= ▁c ▁-> ▁table _ r V ▁[ ▁V ▁] ▁, ▁* ▁g ▁= ▁( ▁c ▁-> ▁table _ g U ▁[ ▁U ▁] ▁+ ▁c ▁-> ▁table _ g V ▁[ ▁V ▁] ▁) ▁, ▁* ▁b ▁= ▁c ▁-> ▁table _ b U ▁[ ▁U ▁] ▁; ▁if ▁( ▁has Alpha ▁) ▁{ ▁A 1 ▁= ▁( ▁a buf 0 ▁[ ▁i ▁* ▁2 ▁] ▁* ▁y alpha 1 ▁+ ▁a buf 1 ▁[ ▁i ▁* ▁2 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁A 2 ▁= ▁( ▁a buf 0 ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁* ▁y alpha 1 ▁+ ▁a buf 1 ▁[ ▁i ▁* ▁2 ▁+ ▁1 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁} ▁yuv 2 rgb _ write ▁( ▁dest ▁, ▁i ▁, ▁Y 1 ▁, ▁Y 2 ▁, ▁U ▁, ▁V ▁, ▁has Alpha ▁? ▁A 1 ▁: ▁0 ▁, ▁has Alpha ▁? ▁A 2 ▁: ▁0 ▁, ▁r ▁, ▁g ▁, ▁b ▁, ▁y ▁, ▁target ▁, ▁has Alpha ▁) ▁; ▁} ▁}	0
▁static ▁void ▁fill _ table ▁( ▁uint 8_ t ▁* ▁table ▁[ ▁256 ▁+ ▁2 ▁* ▁Y U VR GB _ TABLE _ HEAD ROOM ▁] ▁, ▁const ▁int ▁elem size ▁, ▁const ▁int ▁inc ▁, ▁void ▁* ▁y _ tab ▁) ▁{ ▁int ▁i ▁; ▁uint 8_ t ▁* ▁y _ table ▁= ▁y _ tab ▁; ▁y _ table ▁-= ▁elem size ▁* ▁( ▁inc ▁>> ▁9 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁+ ▁2 ▁* ▁Y U VR GB _ TABLE _ HEAD ROOM ▁; ▁i ▁++ ▁) ▁{ ▁int 64_ t ▁cb ▁= ▁av _ clip ▁( ▁i ▁- ▁Y U VR GB _ TABLE _ HEAD ROOM ▁, ▁0 ▁, ▁255 ▁) ▁* ▁inc ▁; ▁table ▁[ ▁i ▁] ▁= ▁y _ table ▁+ ▁elem size ▁* ▁( ▁cb ▁>> ▁16 ▁) ▁; ▁} ▁}	1
▁static ▁int ▁add _ double s _ metadata ▁( ▁int ▁count ▁, ▁const ▁char ▁* ▁name ▁, ▁const ▁char ▁* ▁sep ▁, ▁T iff Context ▁* ▁s ▁) ▁{ ▁char ▁* ▁ap ▁; ▁int ▁i ▁; ▁double ▁* ▁dp ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁count ▁* ▁sizeof ▁( ▁int 64_ t ▁) ▁) ▁return ▁-1 ▁; ▁dp ▁= ▁av _ malloc ▁( ▁count ▁* ▁sizeof ▁( ▁double ▁) ▁) ▁; ▁if ▁( ▁! ▁dp ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁dp ▁[ ▁i ▁] ▁= ▁t get _ double ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁le ▁) ▁; ▁ap ▁= ▁doubles 2 str ▁( ▁dp ▁, ▁count ▁, ▁sep ▁) ▁; ▁av _ freep ▁( ▁& ▁dp ▁) ▁; ▁if ▁( ▁! ▁ap ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁av _ dict _ set ▁( ▁& ▁s ▁-> ▁picture ▁. ▁metadata ▁, ▁name ▁, ▁ap ▁, ▁AV _ DICT _ DONT _ STR DUP _ VAL ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁ngx _ inline ▁void ▁* ▁ngx _ palloc _ small ▁( ▁ngx _ pool _ t ▁* ▁pool ▁, ▁size _ t ▁size ▁, ▁ngx _ uint _ t ▁align ▁) ▁{ ▁u _ char ▁* ▁m ▁; ▁ngx _ pool _ t ▁* ▁p ▁; ▁p ▁= ▁pool ▁-> ▁current ▁; ▁do ▁{ ▁m ▁= ▁p ▁-> ▁d ▁. ▁last ▁; ▁if ▁( ▁align ▁) ▁{ ▁m ▁= ▁ngx _ align _ ptr ▁( ▁m ▁, ▁NGX _ ALIGNMENT ▁) ▁; ▁} ▁if ▁( ▁( ▁size _ t ▁) ▁( ▁p ▁-> ▁d ▁. ▁end ▁- ▁m ▁) ▁>= ▁size ▁) ▁{ ▁p ▁-> ▁d ▁. ▁last ▁= ▁m ▁+ ▁size ▁; ▁return ▁m ▁; ▁} ▁p ▁= ▁p ▁-> ▁d ▁. ▁next ▁; ▁} ▁while ▁( ▁p ▁) ▁; ▁return ▁ngx _ palloc _ block ▁( ▁pool ▁, ▁size ▁) ▁; ▁}	0
▁static ▁int ▁micro d vd _ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁unsigned ▁char ▁c ▁; ▁const ▁uint 8_ t ▁* ▁ptr ▁= ▁p ▁-> ▁buf ▁; ▁int ▁i ▁; ▁if ▁( ▁AV _ RB 24 ▁( ▁ptr ▁) ▁== ▁0 xEF BB BF ▁) ▁ptr ▁+= ▁3 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sscanf ▁( ▁ptr ▁, ▁"{ % * d }{ } % c " ▁, ▁& ▁c ▁) ▁!= ▁1 ▁&& ▁sscanf ▁( ▁ptr ▁, ▁"{ % * d }{ % * d } % c " ▁, ▁& ▁c ▁) ▁!= ▁1 ▁&& ▁sscanf ▁( ▁ptr ▁, ▁"{ DEFAULT }{ } % c " ▁, ▁& ▁c ▁) ▁!= ▁1 ▁) ▁return ▁0 ▁; ▁ptr ▁+= ▁ff _ sub title s _ next _ line ▁( ▁ptr ▁) ▁; ▁} ▁return ▁AV PROBE _ SCORE _ MAX ▁; ▁}	0
▁static ▁av _ always _ inline ▁int ▁simple _ limit ▁( ▁uint 8_ t ▁* ▁p ▁, ▁ptrdiff _ t ▁stride ▁, ▁int ▁f lim ▁) ▁{ ▁LOAD _ PIXEL S ▁return ▁2 ▁* ▁FF ABS ▁( ▁p 0 ▁- ▁q 0 ▁) ▁+ ▁( ▁FF ABS ▁( ▁p 1 ▁- ▁q 1 ▁) ▁>> ▁1 ▁) ▁<= ▁f lim ▁; ▁}	1
▁static ▁int ▁end _ frame ▁( ▁AVFilter Link ▁* ▁inlink ▁) ▁{ ▁AVFilter Context ▁* ▁ctx ▁= ▁inlink ▁-> ▁dst ▁; ▁Tile Context ▁* ▁tile ▁= ▁ctx ▁-> ▁priv ▁; ▁avfilter _ unref _ buffer p ▁( ▁& ▁inlink ▁-> ▁cur _ buf ▁) ▁; ▁if ▁( ▁++ ▁tile ▁-> ▁current ▁== ▁tile ▁-> ▁nb _ frames ▁) ▁end _ last _ frame ▁( ▁ctx ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁engine _ unlocked _ init ▁( ▁ENGINE ▁* ▁e ▁) ▁{ ▁int ▁to _ return ▁= ▁1 ▁; ▁if ▁( ▁( ▁e ▁-> ▁funct _ ref ▁== ▁0 ▁) ▁&& ▁e ▁-> ▁init ▁) ▁to _ return ▁= ▁e ▁-> ▁init ▁( ▁e ▁) ▁; ▁if ▁( ▁to _ return ▁) ▁{ ▁e ▁-> ▁struct _ ref ▁++ ▁; ▁e ▁-> ▁funct _ ref ▁++ ▁; ▁engine _ ref _ debug ▁( ▁e ▁, ▁0 ▁, ▁1 ▁) ▁engine _ ref _ debug ▁( ▁e ▁, ▁1 ▁, ▁1 ▁) ▁} ▁return ▁to _ return ▁; ▁}	1
▁static ▁int ▁o ma _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁O MA Context ▁* ▁oc ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁; ▁int ▁packet _ size ▁= ▁st ▁-> ▁codec ▁-> ▁block _ align ▁; ▁int ▁byte _ rate ▁= ▁st ▁-> ▁codec ▁-> ▁bit _ rate ▁>> ▁3 ▁; ▁int 64_ t ▁pos ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁; ▁int ▁ret ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁packet _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁packet _ size ▁) ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ COR RUP T ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁! ▁ret ▁) ▁return ▁AVERROR _ EOF ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁if ▁( ▁pos ▁> ▁0 ▁&& ▁byte _ rate ▁> ▁0 ▁) ▁{ ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁dts ▁= ▁av _ re scale ▁( ▁pos ▁, ▁st ▁-> ▁time _ base ▁. ▁den ▁, ▁byte _ rate ▁* ▁( ▁int 64_ t ▁) ▁st ▁-> ▁time _ base ▁. ▁num ▁) ▁; ▁} ▁if ▁( ▁oc ▁-> ▁encrypted ▁) ▁{ ▁if ▁( ▁ret ▁== ▁packet _ size ▁) ▁av _ des _ crypt ▁( ▁& ▁oc ▁-> ▁av _ des ▁, ▁pkt ▁-> ▁data ▁, ▁pkt ▁-> ▁data ▁, ▁( ▁packet _ size ▁>> ▁3 ▁) ▁, ▁oc ▁-> ▁iv ▁, ▁1 ▁) ▁; ▁else ▁memset ▁( ▁oc ▁-> ▁iv ▁, ▁0 ▁, ▁8 ▁) ▁; ▁} ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁read _ quant _ table ▁( ▁Range Coder ▁* ▁c ▁, ▁int 16_ t ▁* ▁quant _ table ▁, ▁int ▁scale ▁) ▁{ ▁int ▁v ▁; ▁int ▁i ▁= ▁0 ▁; ▁uint 8_ t ▁state ▁[ ▁CONTEXT _ SIZE ▁] ▁; ▁memset ▁( ▁state ▁, ▁128 ▁, ▁sizeof ▁( ▁state ▁) ▁) ▁; ▁for ▁( ▁v ▁= ▁0 ▁; ▁i ▁< ▁128 ▁; ▁v ▁++ ▁) ▁{ ▁int ▁len ▁= ▁get _ symbol ▁( ▁c ▁, ▁state ▁, ▁0 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁len ▁+ ▁i ▁> ▁128 ▁) ▁return ▁-1 ▁; ▁while ▁( ▁len ▁-- ▁) ▁{ ▁quant _ table ▁[ ▁i ▁] ▁= ▁scale ▁* ▁v ▁; ▁i ▁++ ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁128 ▁; ▁i ▁++ ▁) ▁{ ▁quant _ table ▁[ ▁256 ▁- ▁i ▁] ▁= ▁- ▁quant _ table ▁[ ▁i ▁] ▁; ▁} ▁quant _ table ▁[ ▁128 ▁] ▁= ▁- ▁quant _ table ▁[ ▁127 ▁] ▁; ▁return ▁2 ▁* ▁v ▁- ▁1 ▁; ▁}	1
▁int ▁ssl 3_ get _ finished ▁( ▁SSL ▁* ▁s ▁, ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁int ▁ok ▁; ▁long ▁n ▁; ▁# ifdef ▁OPENSSL _ NO _ NEXT PROT ONE G ▁# endif ▁n ▁= ▁s ▁-> ▁method ▁-> ▁ssl _ get _ message ▁( ▁s ▁, ▁a ▁, ▁b ▁, ▁SSL 3_ MT _ FINISHED ▁, ▁64 ▁, ▁& ▁ok ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁return ▁( ▁( ▁int ▁) ▁n ▁) ▁; ▁return ▁tls _ process _ finished ▁( ▁s ▁, ▁( ▁unsigned ▁long ▁) ▁n ▁) ▁; ▁}	0
▁static ▁apr _ status _ t ▁commit _ entity ▁( ▁cache _ handle _ t ▁* ▁h ▁, ▁request _ rec ▁* ▁r ▁) ▁{ ▁cache _ soc ache _ conf ▁* ▁conf ▁= ▁ap _ get _ module _ config ▁( ▁r ▁-> ▁server ▁-> ▁module _ config ▁, ▁& ▁cache _ soc ache _ module ▁) ▁; ▁cache _ object _ t ▁* ▁obj ▁= ▁h ▁-> ▁cache _ obj ▁; ▁cache _ soc ache _ object _ t ▁* ▁s obj ▁= ▁( ▁cache _ soc ache _ object _ t ▁* ▁) ▁obj ▁-> ▁vo bj ▁; ▁apr _ status _ t ▁rv ▁; ▁apr _ size _ t ▁len ▁; ▁len ▁= ▁s obj ▁-> ▁buffer _ len ▁- ▁s obj ▁-> ▁body _ offset ▁; ▁rv ▁= ▁apr _ b rig ade _ flatten ▁( ▁s obj ▁-> ▁body ▁, ▁( ▁char ▁* ▁) ▁s obj ▁-> ▁buffer ▁+ ▁s obj ▁-> ▁body _ offset ▁, ▁& ▁len ▁) ▁; ▁if ▁( ▁APR _ SUCCESS ▁!= ▁rv ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 82 ▁) ▁" could not flatten b rig ade , not c aching :% s " ▁, ▁s obj ▁-> ▁key ▁) ▁; ▁goto ▁fail ▁; ▁} ▁if ▁( ▁len ▁>= ▁s obj ▁-> ▁buffer _ len ▁- ▁s obj ▁-> ▁body _ offset ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 83 ▁) ▁" body too big fort he cache buffer , not c aching :% s " ▁, ▁h ▁-> ▁cache _ obj ▁-> ▁key ▁) ▁; ▁goto ▁fail ▁; ▁} ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ lock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 84 ▁) ▁" could not acquire lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁rv ▁; ▁} ▁} ▁rv ▁= ▁conf ▁-> ▁provider ▁-> ▁soc ache _ provider ▁-> ▁store ▁( ▁conf ▁-> ▁provider ▁-> ▁soc ache _ instance ▁, ▁r ▁-> ▁server ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁s obj ▁-> ▁key ▁, ▁strlen ▁( ▁s obj ▁-> ▁key ▁) ▁, ▁s obj ▁-> ▁expire ▁, ▁s obj ▁-> ▁buffer ▁, ▁( ▁unsigned ▁int ▁) ▁s obj ▁-> ▁body _ offset ▁+ ▁len ▁, ▁s obj ▁-> ▁pool ▁) ▁; ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ unlock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 85 ▁) ▁" could not release lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁DECL INED ▁; ▁} ▁} ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ WARNING ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 86 ▁) ▁" could not writ et ocache , ign oring :% s " ▁, ▁s obj ▁-> ▁key ▁) ▁; ▁goto ▁fail ▁; ▁} ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 87 ▁) ▁" commit _ entity : Headers and body for URL % sc ached form ax imum of % d seconds ." ▁, ▁s obj ▁-> ▁name ▁, ▁( ▁apr _ uint 32_ t ▁) ▁apr _ time _ sec ▁( ▁s obj ▁-> ▁expire ▁- ▁r ▁-> ▁request _ time ▁) ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁APR _ SUCCESS ▁; ▁fail ▁: ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ lock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 2388 ▁) ▁" could not acquire lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁rv ▁; ▁} ▁} ▁conf ▁-> ▁provider ▁-> ▁soc ache _ provider ▁-> ▁remove ▁( ▁conf ▁-> ▁provider ▁-> ▁soc ache _ instance ▁, ▁r ▁-> ▁server ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁s obj ▁-> ▁key ▁, ▁strlen ▁( ▁s obj ▁-> ▁key ▁) ▁, ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ unlock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 89 ▁) ▁" could not release lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁} ▁} ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁rv ▁; ▁}	1
▁void ▁ff _ sub block _ synth esis ▁( ▁RA 144 Context ▁* ▁r act x ▁, ▁const ▁int 16_ t ▁* ▁lpc _ co efs ▁, ▁int ▁cb a _ idx ▁, ▁int ▁cb 1_ idx ▁, ▁int ▁cb 2_ idx ▁, ▁int ▁g val ▁, ▁int ▁gain ▁) ▁{ ▁int 16_ t ▁* ▁block ▁; ▁int ▁m ▁[ ▁3 ▁] ▁; ▁if ▁( ▁cb a _ idx ▁) ▁{ ▁cb a _ idx ▁+= ▁BLOCKSIZE ▁/ ▁2 ▁- ▁1 ▁; ▁ff _ copy _ and _ dup ▁( ▁r act x ▁-> ▁buffer _ a ▁, ▁r act x ▁-> ▁adapt _ cb ▁, ▁cb a _ idx ▁) ▁; ▁m ▁[ ▁0 ▁] ▁= ▁( ▁ff _ ir ms ▁( ▁& ▁r act x ▁-> ▁a dsp ▁, ▁r act x ▁-> ▁buffer _ a ▁) ▁* ▁( ▁unsigned ▁) ▁g val ▁) ▁>> ▁12 ▁; ▁} ▁else ▁{ ▁m ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁} ▁m ▁[ ▁1 ▁] ▁= ▁( ▁ff _ cb 1_ base ▁[ ▁cb 1_ idx ▁] ▁* ▁g val ▁) ▁>> ▁8 ▁; ▁m ▁[ ▁2 ▁] ▁= ▁( ▁ff _ cb 2_ base ▁[ ▁cb 2_ idx ▁] ▁* ▁g val ▁) ▁>> ▁8 ▁; ▁memmove ▁( ▁r act x ▁-> ▁adapt _ cb ▁, ▁r act x ▁-> ▁adapt _ cb ▁+ ▁BLOCKSIZE ▁, ▁( ▁BUFFER SIZE ▁- ▁BLOCKSIZE ▁) ▁* ▁sizeof ▁( ▁* ▁r act x ▁-> ▁adapt _ cb ▁) ▁) ▁; ▁block ▁= ▁r act x ▁-> ▁adapt _ cb ▁+ ▁BUFFER SIZE ▁- ▁BLOCKSIZE ▁; ▁add _ wav ▁( ▁block ▁, ▁gain ▁, ▁cb a _ idx ▁, ▁m ▁, ▁cb a _ idx ▁? ▁r act x ▁-> ▁buffer _ a ▁: ▁NULL ▁, ▁ff _ cb 1_ vect s ▁[ ▁cb 1_ idx ▁] ▁, ▁ff _ cb 2_ vect s ▁[ ▁cb 2_ idx ▁] ▁) ▁; ▁memcpy ▁( ▁r act x ▁-> ▁curr _ s block ▁, ▁r act x ▁-> ▁curr _ s block ▁+ ▁BLOCKSIZE ▁, ▁LPC _ ORDER ▁* ▁sizeof ▁( ▁* ▁r act x ▁-> ▁curr _ s block ▁) ▁) ▁; ▁if ▁( ▁ff _ ce lp _ lp _ synth esis _ filter ▁( ▁r act x ▁-> ▁curr _ s block ▁+ ▁LPC _ ORDER ▁, ▁lpc _ co efs ▁, ▁block ▁, ▁BLOCKSIZE ▁, ▁LPC _ ORDER ▁, ▁1 ▁, ▁0 ▁, ▁0 xfff ▁) ▁) ▁memset ▁( ▁r act x ▁-> ▁curr _ s block ▁, ▁0 ▁, ▁( ▁LPC _ ORDER ▁+ ▁BLOCKSIZE ▁) ▁* ▁sizeof ▁( ▁* ▁r act x ▁-> ▁curr _ s block ▁) ▁) ▁; ▁}	0
▁static ▁int ▁allocate _ buffers ▁( ▁Short en Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁chan ▁, ▁err ▁; ▁for ▁( ▁chan ▁= ▁0 ▁; ▁chan ▁< ▁s ▁-> ▁channels ▁; ▁chan ▁++ ▁) ▁{ ▁if ▁( ▁FF MAX ▁( ▁1 ▁, ▁s ▁-> ▁n mean ▁) ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁int 32_ t ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" n me ant ool arge \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁s ▁-> ▁blocksize ▁+ ▁( ▁uint 64_ t ▁) ▁s ▁-> ▁n wrap ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁int 32_ t ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" s -> blocksize + s -> nw ra pt ool arge \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁( ▁err ▁= ▁av _ realloc p _ array ▁( ▁& ▁s ▁-> ▁offset ▁[ ▁chan ▁] ▁, ▁sizeof ▁( ▁int 32_ t ▁) ▁, ▁FF MAX ▁( ▁1 ▁, ▁s ▁-> ▁n mean ▁) ▁) ▁) ▁< ▁0 ▁) ▁return ▁err ▁; ▁if ▁( ▁( ▁err ▁= ▁av _ realloc p _ array ▁( ▁& ▁s ▁-> ▁decoded _ base ▁[ ▁chan ▁] ▁, ▁( ▁s ▁-> ▁blocksize ▁+ ▁s ▁-> ▁n wrap ▁) ▁, ▁sizeof ▁( ▁s ▁-> ▁decoded _ base ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁) ▁< ▁0 ▁) ▁return ▁err ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n wrap ▁; ▁i ▁++ ▁) ▁s ▁-> ▁decoded _ base ▁[ ▁chan ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁s ▁-> ▁decoded ▁[ ▁chan ▁] ▁= ▁s ▁-> ▁decoded _ base ▁[ ▁chan ▁] ▁+ ▁s ▁-> ▁n wrap ▁; ▁} ▁if ▁( ▁( ▁err ▁= ▁av _ realloc p _ array ▁( ▁& ▁s ▁-> ▁coeffs ▁, ▁s ▁-> ▁n wrap ▁, ▁sizeof ▁( ▁* ▁s ▁-> ▁coeffs ▁) ▁) ▁) ▁< ▁0 ▁) ▁return ▁err ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁av picture _ layout ▁( ▁const ▁AV Picture ▁* ▁src ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁unsigned ▁char ▁* ▁dest ▁, ▁int ▁dest _ size ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁nb _ planes ▁= ▁0 ▁, ▁lines izes ▁[ ▁4 ▁] ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁pix _ fmt ▁) ▁; ▁int ▁size ▁= ▁av picture _ get _ size ▁( ▁pix _ fmt ▁, ▁width ▁, ▁height ▁) ▁; ▁if ▁( ▁size ▁> ▁dest _ size ▁|| ▁size ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁desc ▁-> ▁nb _ components ▁; ▁i ▁++ ▁) ▁nb _ planes ▁= ▁FF MAX ▁( ▁desc ▁-> ▁comp ▁[ ▁i ▁] ▁. ▁plane ▁, ▁nb _ planes ▁) ▁; ▁nb _ planes ▁++ ▁; ▁av _ image _ fill _ lines izes ▁( ▁lines izes ▁, ▁pix _ fmt ▁, ▁width ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ planes ▁; ▁i ▁++ ▁) ▁{ ▁int ▁h ▁, ▁shift ▁= ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁) ▁? ▁desc ▁-> ▁log 2_ chroma _ h ▁: ▁0 ▁; ▁const ▁unsigned ▁char ▁* ▁s ▁= ▁src ▁-> ▁data ▁[ ▁i ▁] ▁; ▁h ▁= ▁( ▁height ▁+ ▁( ▁1 ▁<< ▁shift ▁) ▁- ▁1 ▁) ▁>> ▁shift ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁h ▁; ▁j ▁++ ▁) ▁{ ▁memcpy ▁( ▁dest ▁, ▁s ▁, ▁lines izes ▁[ ▁i ▁] ▁) ▁; ▁dest ▁+= ▁lines izes ▁[ ▁i ▁] ▁; ▁s ▁+= ▁src ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁} ▁} ▁if ▁( ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PAL ▁) ▁memcpy ▁( ▁( ▁unsigned ▁char ▁* ▁) ▁( ▁( ▁( ▁size _ t ▁) ▁dest ▁+ ▁3 ▁) ▁& ▁ ~ ▁3 ▁) ▁, ▁src ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁256 ▁* ▁4 ▁) ▁; ▁return ▁size ▁; ▁}	1
▁int ▁dt ls 1_ do _ write ▁( ▁SSL ▁* ▁s ▁, ▁int ▁type ▁) ▁{ ▁int ▁ret ▁; ▁size _ t ▁written ▁; ▁size _ t ▁curr _ mtu ▁; ▁int ▁retry ▁= ▁1 ▁; ▁size _ t ▁len ▁, ▁frag _ off ▁, ▁mac _ size ▁, ▁blocksize ▁, ▁used _ len ▁; ▁if ▁( ▁! ▁dt ls 1_ query _ mtu ▁( ▁s ▁) ▁) ▁return ▁-1 ▁; ▁if ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁< ▁dt ls 1_ min _ mtu ▁( ▁s ▁) ▁) ▁return ▁-1 ▁; ▁if ▁( ▁s ▁-> ▁init _ off ▁== ▁0 ▁&& ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁) ▁OPENSSL _ assert ▁( ▁s ▁-> ▁init _ num ▁== ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁. ▁msg _ len ▁+ ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁if ▁( ▁s ▁-> ▁write _ hash ▁) ▁{ ▁if ▁( ▁s ▁-> ▁enc _ write _ ctx ▁&& ▁( ▁EVP _ CIPHER _ flags ▁( ▁EVP _ CIPHER _ CTX _ cipher ▁( ▁s ▁-> ▁enc _ write _ ctx ▁) ▁) ▁& ▁EVP _ C IPH _ FLAG _ A EAD _ CIPHER ▁) ▁!= ▁0 ▁) ▁mac _ size ▁= ▁0 ▁; ▁else ▁mac _ size ▁= ▁EVP _ MD _ CTX _ size ▁( ▁s ▁-> ▁write _ hash ▁) ▁; ▁} ▁else ▁mac _ size ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁enc _ write _ ctx ▁&& ▁( ▁EVP _ CIPHER _ CTX _ mode ▁( ▁s ▁-> ▁enc _ write _ ctx ▁) ▁== ▁EVP _ C IPH _ CBC _ MODE ▁) ▁) ▁blocksize ▁= ▁2 ▁* ▁EVP _ CIPHER _ CTX _ block _ size ▁( ▁s ▁-> ▁enc _ write _ ctx ▁) ▁; ▁else ▁blocksize ▁= ▁0 ▁; ▁frag _ off ▁= ▁0 ▁; ▁s ▁-> ▁rw state ▁= ▁SSL _ NO THING ▁; ▁while ▁( ▁s ▁-> ▁init _ num ▁> ▁0 ▁) ▁{ ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁&& ▁s ▁-> ▁init _ off ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁frag _ off ▁> ▁0 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁init _ off ▁<= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁init _ off ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁s ▁-> ▁init _ num ▁+= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁} ▁else ▁{ ▁frag _ off ▁= ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁. ▁frag _ off ▁; ▁} ▁} ▁used _ len ▁= ▁BIO _ w pending ▁( ▁s ▁-> ▁w bio ▁) ▁+ ▁DTLS 1_ RT _ HEADER _ LENGTH ▁+ ▁mac _ size ▁+ ▁blocksize ▁; ▁if ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁> ▁used _ len ▁) ▁curr _ mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁- ▁used _ len ▁; ▁else ▁curr _ mtu ▁= ▁0 ▁; ▁if ▁( ▁curr _ mtu ▁<= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁ret ▁= ▁BIO _ flush ▁( ▁s ▁-> ▁w bio ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁) ▁{ ▁s ▁-> ▁rw state ▁= ▁SSL _ WRIT ING ▁; ▁return ▁ret ▁; ▁} ▁used _ len ▁= ▁DTLS 1_ RT _ HEADER _ LENGTH ▁+ ▁mac _ size ▁+ ▁blocksize ▁; ▁if ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁> ▁used _ len ▁+ ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁curr _ mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁- ▁used _ len ▁; ▁} ▁else ▁{ ▁return ▁-1 ▁; ▁} ▁} ▁if ▁( ▁( ▁( ▁unsigned ▁int ▁) ▁s ▁-> ▁init _ num ▁) ▁> ▁curr _ mtu ▁) ▁len ▁= ▁curr _ mtu ▁; ▁else ▁len ▁= ▁s ▁-> ▁init _ num ▁; ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁) ▁{ ▁if ▁( ▁len ▁< ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁dt ls 1_ fix _ message _ header ▁( ▁s ▁, ▁frag _ off ▁, ▁len ▁- ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁dt ls 1_ write _ message _ header ▁( ▁s ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁) ▁; ▁} ▁ret ▁= ▁dt ls 1_ write _ bytes ▁( ▁s ▁, ▁type ▁, ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁, ▁len ▁, ▁& ▁written ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁retry ▁&& ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ MTU _ EXCEEDED ▁, ▁0 ▁, ▁NULL ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁! ▁( ▁SSL _ get _ options ▁( ▁s ▁) ▁& ▁SSL _ OP _ NO _ QUERY _ MTU ▁) ▁) ▁{ ▁if ▁( ▁! ▁dt ls 1_ query _ mtu ▁( ▁s ▁) ▁) ▁return ▁-1 ▁; ▁retry ▁= ▁0 ▁; ▁} ▁else ▁return ▁-1 ▁; ▁} ▁else ▁{ ▁return ▁( ▁-1 ▁) ▁; ▁} ▁} ▁else ▁{ ▁OPENSSL _ assert ▁( ▁len ▁== ▁written ▁) ▁; ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁&& ▁! ▁s ▁-> ▁d 1 ▁-> ▁retrans mit ting ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁; ▁const ▁struct ▁hm _ header _ st ▁* ▁msg _ hdr ▁= ▁& ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁; ▁size _ t ▁xlen ▁; ▁if ▁( ▁frag _ off ▁== ▁0 ▁&& ▁s ▁-> ▁version ▁!= ▁DTLS 1_ BAD _ VER ▁) ▁{ ▁* ▁p ▁++ ▁= ▁msg _ hdr ▁-> ▁type ▁; ▁l 2 n 3 ▁( ▁msg _ hdr ▁-> ▁msg _ len ▁, ▁p ▁) ▁; ▁s 2 n ▁( ▁msg _ hdr ▁-> ▁seq ▁, ▁p ▁) ▁; ▁l 2 n 3 ▁( ▁0 ▁, ▁p ▁) ▁; ▁l 2 n 3 ▁( ▁msg _ hdr ▁-> ▁msg _ len ▁, ▁p ▁) ▁; ▁p ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁xlen ▁= ▁written ▁; ▁} ▁else ▁{ ▁p ▁+= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁xlen ▁= ▁written ▁- ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁} ▁if ▁( ▁! ▁ssl 3_ finish _ mac ▁( ▁s ▁, ▁p ▁, ▁xlen ▁) ▁) ▁return ▁-1 ▁; ▁} ▁if ▁( ▁written ▁== ▁s ▁-> ▁init _ num ▁) ▁{ ▁if ▁( ▁s ▁-> ▁msg _ callback ▁) ▁s ▁-> ▁msg _ callback ▁( ▁1 ▁, ▁s ▁-> ▁version ▁, ▁type ▁, ▁s ▁-> ▁init _ buf ▁-> ▁data ▁, ▁( ▁size _ t ▁) ▁( ▁s ▁-> ▁init _ off ▁+ ▁s ▁-> ▁init _ num ▁) ▁, ▁s ▁, ▁s ▁-> ▁msg _ callback _ arg ▁) ▁; ▁s ▁-> ▁init _ off ▁= ▁0 ▁; ▁s ▁-> ▁init _ num ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁s ▁-> ▁init _ off ▁+= ▁written ▁; ▁s ▁-> ▁init _ num ▁-= ▁written ▁; ▁written ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁frag _ off ▁+= ▁written ▁; ▁dt ls 1_ fix _ message _ header ▁( ▁s ▁, ▁frag _ off ▁, ▁0 ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁chs _ assemble _ ms bs _ ls bs ▁( ▁D CA X ll Decoder ▁* ▁s ▁, ▁D CA X ll Ch Set ▁* ▁c ▁, ▁int ▁band ▁) ▁{ ▁D CA X ll Band ▁* ▁b ▁= ▁& ▁c ▁-> ▁bands ▁[ ▁band ▁] ▁; ▁int ▁n ▁, ▁ch ▁, ▁ns amples ▁= ▁s ▁-> ▁n frames amples ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁c ▁-> ▁n channels ▁; ▁ch ▁++ ▁) ▁{ ▁int ▁shift ▁= ▁chs _ get _ lsb _ width ▁( ▁s ▁, ▁c ▁, ▁band ▁, ▁ch ▁) ▁; ▁if ▁( ▁shift ▁) ▁{ ▁int 32_ t ▁* ▁msb ▁= ▁b ▁-> ▁msb _ sample _ buffer ▁[ ▁ch ▁] ▁; ▁if ▁( ▁b ▁-> ▁n scal able ls bs ▁[ ▁ch ▁] ▁) ▁{ ▁int 32_ t ▁* ▁lsb ▁= ▁b ▁-> ▁lsb _ sample _ buffer ▁[ ▁ch ▁] ▁; ▁int ▁adj ▁= ▁b ▁-> ▁bit _ width _ adjust ▁[ ▁ch ▁] ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁ns amples ▁; ▁n ▁++ ▁) ▁msb ▁[ ▁n ▁] ▁= ▁msb ▁[ ▁n ▁] ▁* ▁( ▁1 ▁<< ▁shift ▁) ▁+ ▁( ▁lsb ▁[ ▁n ▁] ▁<< ▁adj ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁ns amples ▁; ▁n ▁++ ▁) ▁msb ▁[ ▁n ▁] ▁= ▁msb ▁[ ▁n ▁] ▁* ▁( ▁1 ▁<< ▁shift ▁) ▁; ▁} ▁} ▁} ▁}	1
▁int ▁dt ls 1_ process _ record ▁( ▁SSL ▁* ▁s ▁, ▁DTLS 1_ BITMAP ▁* ▁bitmap ▁) ▁{ ▁int ▁i ▁, ▁al ▁; ▁int ▁enc _ err ▁; ▁SSL _ SESSION ▁* ▁sess ▁; ▁SSL 3_ RECORD ▁* ▁rr ▁; ▁unsigned ▁int ▁mac _ size ▁; ▁unsigned ▁char ▁md ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁rr ▁= ▁RECORD _ LAYER _ get _ r rec ▁( ▁& ▁s ▁-> ▁r layer ▁) ▁; ▁sess ▁= ▁s ▁-> ▁session ▁; ▁rr ▁-> ▁input ▁= ▁& ▁( ▁RECORD _ LAYER _ get _ packet ▁( ▁& ▁s ▁-> ▁r layer ▁) ▁[ ▁DTLS 1_ RT _ HEADER _ LENGTH ▁] ▁) ▁; ▁if ▁( ▁rr ▁-> ▁length ▁> ▁SSL 3_ RT _ MAX _ ENCRYPT ED _ LENGTH ▁) ▁{ ▁al ▁= ▁SSL _ AD _ RECORD _ OVERFLOW ▁; ▁SSL err ▁( ▁SSL _ F _ DT LS 1_ PROCESS _ RECORD ▁, ▁SSL _ R _ ENCRYPT ED _ LENGTH _ TOO _ LONG ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁rr ▁-> ▁data ▁= ▁rr ▁-> ▁input ▁; ▁rr ▁-> ▁orig _ len ▁= ▁rr ▁-> ▁length ▁; ▁if ▁( ▁SSL _ USE _ ET M ▁( ▁s ▁) ▁&& ▁s ▁-> ▁read _ hash ▁) ▁{ ▁unsigned ▁char ▁* ▁mac ▁; ▁mac _ size ▁= ▁EVP _ MD _ CTX _ size ▁( ▁s ▁-> ▁read _ hash ▁) ▁; ▁OPENSSL _ assert ▁( ▁mac _ size ▁<= ▁EVP _ MAX _ MD _ SIZE ▁) ▁; ▁if ▁( ▁rr ▁-> ▁orig _ len ▁< ▁mac _ size ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ DT LS 1_ PROCESS _ RECORD ▁, ▁SSL _ R _ LENGTH _ TOO _ SHORT ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁rr ▁-> ▁length ▁-= ▁mac _ size ▁; ▁mac ▁= ▁rr ▁-> ▁data ▁+ ▁rr ▁-> ▁length ▁; ▁i ▁= ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁mac ▁( ▁s ▁, ▁rr ▁, ▁md ▁, ▁0 ▁) ▁; ▁if ▁( ▁i ▁< ▁0 ▁|| ▁CRYPTO _ memcmp ▁( ▁md ▁, ▁mac ▁, ▁( ▁size _ t ▁) ▁mac _ size ▁) ▁!= ▁0 ▁) ▁{ ▁al ▁= ▁SSL _ AD _ BAD _ RECORD _ MAC ▁; ▁SSL err ▁( ▁SSL _ F _ DT LS 1_ PROCESS _ RECORD ▁, ▁SSL _ R _ DE CRYPTION _ FAILED _ OR _ BAD _ RECORD _ MAC ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁} ▁enc _ err ▁= ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁enc ▁( ▁s ▁, ▁rr ▁, ▁1 ▁, ▁0 ▁) ▁; ▁if ▁( ▁enc _ err ▁== ▁0 ▁) ▁{ ▁rr ▁-> ▁length ▁= ▁0 ▁; ▁RECORD _ LAYER _ reset _ packet _ length ▁( ▁& ▁s ▁-> ▁r layer ▁) ▁; ▁goto ▁err ▁; ▁} ▁# ifdef ▁SSL _ DEBUG ▁printf ▁( ▁" dec % d \ n " ▁, ▁rr ▁-> ▁length ▁) ▁; ▁{ ▁unsigned ▁int ▁z ▁; ▁for ▁( ▁z ▁= ▁0 ▁; ▁z ▁< ▁rr ▁-> ▁length ▁; ▁z ▁++ ▁) ▁printf ▁( ▁"%02 X % c " ▁, ▁rr ▁-> ▁data ▁[ ▁z ▁] ▁, ▁( ▁( ▁z ▁+ ▁1 ▁) ▁% ▁16 ▁) ▁? ▁' ▁' ▁: ▁' ▁\ n ▁' ▁) ▁; ▁} ▁printf ▁( ▁"\ n " ▁) ▁; ▁# endif ▁if ▁( ▁( ▁sess ▁!= ▁NULL ▁) ▁&& ▁! ▁SSL _ USE _ ET M ▁( ▁s ▁) ▁&& ▁( ▁s ▁-> ▁enc _ read _ ctx ▁!= ▁NULL ▁) ▁&& ▁( ▁EVP _ MD _ CTX _ md ▁( ▁s ▁-> ▁read _ hash ▁) ▁!= ▁NULL ▁) ▁) ▁{ ▁unsigned ▁char ▁* ▁mac ▁= ▁NULL ▁; ▁unsigned ▁char ▁mac _ tmp ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁mac _ size ▁= ▁EVP _ MD _ CTX _ size ▁( ▁s ▁-> ▁read _ hash ▁) ▁; ▁OPENSSL _ assert ▁( ▁mac _ size ▁<= ▁EVP _ MAX _ MD _ SIZE ▁) ▁; ▁if ▁( ▁rr ▁-> ▁orig _ len ▁< ▁mac _ size ▁|| ▁( ▁EVP _ CIPHER _ CTX _ mode ▁( ▁s ▁-> ▁enc _ read _ ctx ▁) ▁== ▁EVP _ C IPH _ CBC _ MODE ▁&& ▁rr ▁-> ▁orig _ len ▁< ▁mac _ size ▁+ ▁1 ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ DT LS 1_ PROCESS _ RECORD ▁, ▁SSL _ R _ LENGTH _ TOO _ SHORT ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁EVP _ CIPHER _ CTX _ mode ▁( ▁s ▁-> ▁enc _ read _ ctx ▁) ▁== ▁EVP _ C IPH _ CBC _ MODE ▁) ▁{ ▁mac ▁= ▁mac _ tmp ▁; ▁ssl 3_ cbc _ copy _ mac ▁( ▁mac _ tmp ▁, ▁rr ▁, ▁mac _ size ▁) ▁; ▁rr ▁-> ▁length ▁-= ▁mac _ size ▁; ▁} ▁else ▁{ ▁rr ▁-> ▁length ▁-= ▁mac _ size ▁; ▁mac ▁= ▁& ▁rr ▁-> ▁data ▁[ ▁rr ▁-> ▁length ▁] ▁; ▁} ▁i ▁= ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁mac ▁( ▁s ▁, ▁rr ▁, ▁md ▁, ▁0 ▁) ▁; ▁if ▁( ▁i ▁< ▁0 ▁|| ▁mac ▁== ▁NULL ▁|| ▁CRYPTO _ memcmp ▁( ▁md ▁, ▁mac ▁, ▁( ▁size _ t ▁) ▁mac _ size ▁) ▁!= ▁0 ▁) ▁enc _ err ▁= ▁-1 ▁; ▁if ▁( ▁rr ▁-> ▁length ▁> ▁SSL 3_ RT _ MAX _ COMPRESSED _ LENGTH ▁+ ▁mac _ size ▁) ▁enc _ err ▁= ▁-1 ▁; ▁} ▁if ▁( ▁enc _ err ▁< ▁0 ▁) ▁{ ▁rr ▁-> ▁length ▁= ▁0 ▁; ▁RECORD _ LAYER _ reset _ packet _ length ▁( ▁& ▁s ▁-> ▁r layer ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁expand ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁rr ▁-> ▁length ▁> ▁SSL 3_ RT _ MAX _ COMPRESSED _ LENGTH ▁) ▁{ ▁al ▁= ▁SSL _ AD _ RECORD _ OVERFLOW ▁; ▁SSL err ▁( ▁SSL _ F _ DT LS 1_ PROCESS _ RECORD ▁, ▁SSL _ R _ COMPRESSED _ LENGTH _ TOO _ LONG ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁! ▁ssl 3_ do _ un compress ▁( ▁s ▁, ▁rr ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DE COMPRESSION _ FAILURE ▁; ▁SSL err ▁( ▁SSL _ F _ DT LS 1_ PROCESS _ RECORD ▁, ▁SSL _ R _ BAD _ DE COMPRESSION ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁} ▁if ▁( ▁rr ▁-> ▁length ▁> ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁) ▁{ ▁al ▁= ▁SSL _ AD _ RECORD _ OVERFLOW ▁; ▁SSL err ▁( ▁SSL _ F _ DT LS 1_ PROCESS _ RECORD ▁, ▁SSL _ R _ DATA _ LENGTH _ TOO _ LONG ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁rr ▁-> ▁off ▁= ▁0 ▁; ▁RECORD _ LAYER _ reset _ packet _ length ▁( ▁& ▁s ▁-> ▁r layer ▁) ▁; ▁dt ls 1_ record _ bitmap _ update ▁( ▁s ▁, ▁bitmap ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁f _ err ▁: ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ FATAL ▁, ▁al ▁) ▁; ▁err ▁: ▁return ▁( ▁0 ▁) ▁; ▁}	0
▁static ▁int ▁test _ gf 2 m _ sqr ▁( ▁) ▁{ ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁[ ▁2 ▁] ▁, ▁* ▁c ▁, ▁* ▁d ▁; ▁int ▁i ▁, ▁j ▁, ▁st ▁= ▁0 ▁; ▁int ▁p 0 ▁[ ▁] ▁= ▁{ ▁16 3 ▁, ▁7 ▁, ▁6 ▁, ▁3 ▁, ▁0 ▁, ▁-1 ▁} ▁; ▁int ▁p 1 ▁[ ▁] ▁= ▁{ ▁19 3 ▁, ▁15 ▁, ▁0 ▁, ▁-1 ▁} ▁; ▁a ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁[ ▁0 ▁] ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁[ ▁1 ▁] ▁= ▁BN _ new ▁( ▁) ▁; ▁c ▁= ▁BN _ new ▁( ▁) ▁; ▁d ▁= ▁BN _ new ▁( ▁) ▁; ▁BN _ GF 2 m _ arr 2 poly ▁( ▁p 0 ▁, ▁b ▁[ ▁0 ▁] ▁) ▁; ▁BN _ GF 2 m _ arr 2 poly ▁( ▁p 1 ▁, ▁b ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NUM 0 ▁; ▁i ▁++ ▁) ▁{ ▁BN _ bn test _ rand ▁( ▁a ▁, ▁1024 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁BN _ GF 2 m _ mod _ sqr ▁( ▁c ▁, ▁a ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁BN _ copy ▁( ▁d ▁, ▁a ▁) ▁; ▁BN _ GF 2 m _ mod _ mul ▁( ▁d ▁, ▁a ▁, ▁d ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁BN _ GF 2 m _ add ▁( ▁d ▁, ▁c ▁, ▁d ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ zero ▁( ▁d ▁) ▁) ▁{ ▁printf ▁( ▁" GF (2 ^ m ) mod ular s qu aring test failed !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁} ▁st ▁= ▁1 ▁; ▁err ▁: ▁BN _ free ▁( ▁a ▁) ▁; ▁BN _ free ▁( ▁b ▁[ ▁0 ▁] ▁) ▁; ▁BN _ free ▁( ▁b ▁[ ▁1 ▁] ▁) ▁; ▁BN _ free ▁( ▁c ▁) ▁; ▁BN _ free ▁( ▁d ▁) ▁; ▁return ▁st ▁; ▁}	0
▁static ▁int ▁join _ request _ frame ▁( ▁AVFilter Link ▁* ▁out link ▁) ▁{ ▁AVFilter Context ▁* ▁ctx ▁= ▁out link ▁-> ▁src ▁; ▁Join Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFilter Buffer Ref ▁* ▁buf ▁; ▁Join Buffer Priv ▁* ▁priv ▁; ▁int ▁linesize ▁= ▁INT _ MAX ▁; ▁int ▁perms ▁= ▁ ~ ▁0 ▁; ▁int ▁nb _ samples ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁, ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ctx ▁-> ▁nb _ inputs ▁; ▁i ▁++ ▁) ▁{ ▁AVFilter Link ▁* ▁inlink ▁= ▁ctx ▁-> ▁inputs ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁s ▁-> ▁input _ frames ▁[ ▁i ▁] ▁&& ▁( ▁ret ▁= ▁ff _ request _ frame ▁( ▁inlink ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁nb _ samples ▁= ▁s ▁-> ▁input _ frames ▁[ ▁0 ▁] ▁-> ▁audio ▁-> ▁nb _ samples ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁! ▁i ▁&& ▁j ▁< ▁ctx ▁-> ▁nb _ inputs ▁; ▁j ▁++ ▁) ▁ctx ▁-> ▁inputs ▁[ ▁j ▁] ▁-> ▁request _ samples ▁= ▁nb _ samples ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ channels ▁; ▁i ▁++ ▁) ▁{ ▁Channel Map ▁* ▁ch ▁= ▁& ▁s ▁-> ▁channels ▁[ ▁i ▁] ▁; ▁AVFilter Buffer Ref ▁* ▁cur _ buf ▁= ▁s ▁-> ▁input _ frames ▁[ ▁ch ▁-> ▁input ▁] ▁; ▁s ▁-> ▁data ▁[ ▁i ▁] ▁= ▁cur _ buf ▁-> ▁extended _ data ▁[ ▁ch ▁-> ▁in _ channel _ idx ▁] ▁; ▁linesize ▁= ▁FF MIN ▁( ▁linesize ▁, ▁cur _ buf ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁; ▁perms ▁&= ▁cur _ buf ▁-> ▁perms ▁; ▁} ▁av _ assert 0 ▁( ▁nb _ samples ▁> ▁0 ▁) ▁; ▁buf ▁= ▁avfilter _ get _ audio _ buffer _ ref _ from _ arrays ▁( ▁s ▁-> ▁data ▁, ▁linesize ▁, ▁perms ▁, ▁nb _ samples ▁, ▁out link ▁-> ▁format ▁, ▁out link ▁-> ▁channel _ layout ▁) ▁; ▁if ▁( ▁! ▁buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁buf ▁-> ▁buf ▁-> ▁free ▁= ▁join _ free _ buffer ▁; ▁buf ▁-> ▁pts ▁= ▁s ▁-> ▁input _ frames ▁[ ▁0 ▁] ▁-> ▁pts ▁; ▁if ▁( ▁! ▁( ▁priv ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁priv ▁) ▁) ▁) ▁) ▁goto ▁fail ▁; ▁if ▁( ▁! ▁( ▁priv ▁-> ▁in _ buffers ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁priv ▁-> ▁in _ buffers ▁) ▁* ▁ctx ▁-> ▁nb _ inputs ▁) ▁) ▁) ▁goto ▁fail ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ctx ▁-> ▁nb _ inputs ▁; ▁i ▁++ ▁) ▁priv ▁-> ▁in _ buffers ▁[ ▁i ▁] ▁= ▁s ▁-> ▁input _ frames ▁[ ▁i ▁] ▁; ▁priv ▁-> ▁nb _ in _ buffers ▁= ▁ctx ▁-> ▁nb _ inputs ▁; ▁buf ▁-> ▁buf ▁-> ▁priv ▁= ▁priv ▁; ▁ff _ filter _ samples ▁( ▁out link ▁, ▁buf ▁) ▁; ▁memset ▁( ▁s ▁-> ▁input _ frames ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁s ▁-> ▁input _ frames ▁) ▁* ▁ctx ▁-> ▁nb _ inputs ▁) ▁; ▁return ▁0 ▁; ▁fail ▁: ▁avfilter _ unref _ buffer ▁( ▁buf ▁) ▁; ▁if ▁( ▁priv ▁) ▁av _ freep ▁( ▁& ▁priv ▁-> ▁in _ buffers ▁) ▁; ▁av _ freep ▁( ▁& ▁priv ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁}	0
▁int ▁ff _ cmap _ read _ palette ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁uint 32_ t ▁* ▁pal ▁) ▁{ ▁int ▁count ▁, ▁i ▁; ▁if ▁( ▁avctx ▁-> ▁bits _ per _ coded _ sample ▁> ▁8 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" bit _ per _ coded _ sample > 8 not supported \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁count ▁= ▁1 ▁<< ▁avctx ▁-> ▁bits _ per _ coded _ sample ▁; ▁count ▁= ▁FF MIN ▁( ▁avctx ▁-> ▁extradata _ size ▁/ ▁3 ▁, ▁count ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁pal ▁[ ▁i ▁] ▁= ▁0 xFF 000000 ▁| ▁AV _ RB 24 ▁( ▁avctx ▁-> ▁extradata ▁+ ▁i ▁* ▁3 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁choose _ sample _ rate ▁( ▁AVStream ▁* ▁st ▁, ▁AVCodec ▁* ▁codec ▁) ▁{ ▁if ▁( ▁codec ▁&& ▁codec ▁-> ▁supported _ sampler ates ▁) ▁{ ▁const ▁int ▁* ▁p ▁= ▁codec ▁-> ▁supported _ sampler ates ▁; ▁int ▁best ▁= ▁0 ▁; ▁int ▁best _ dist ▁= ▁INT _ MAX ▁; ▁for ▁( ▁; ▁* ▁p ▁; ▁p ▁++ ▁) ▁{ ▁int ▁dist ▁= ▁abs ▁( ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁- ▁* ▁p ▁) ▁; ▁if ▁( ▁dist ▁< ▁best _ dist ▁) ▁{ ▁best _ dist ▁= ▁dist ▁; ▁best ▁= ▁* ▁p ▁; ▁} ▁} ▁if ▁( ▁best _ dist ▁) ▁{ ▁int ▁i ▁; ▁const ▁int ▁* ▁sample _ rates ▁= ▁codec ▁-> ▁supported _ sampler ates ▁; ▁av _ log ▁( ▁st ▁-> ▁codec ▁, ▁AV _ LOG _ WARNING ▁, ▁" Requested sampling rate (% d Hz ) unsupported , using % d Hz inst ead \ n " ▁" Available sampling rates for % s :" ▁, ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁, ▁best ▁, ▁codec ▁-> ▁name ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁sample _ rates ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁sample _ rates ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁av _ log ▁( ▁st ▁-> ▁codec ▁, ▁AV _ LOG _ WARNING ▁, ▁" and " ▁) ▁; ▁else ▁if ▁( ▁i ▁) ▁av _ log ▁( ▁st ▁-> ▁codec ▁, ▁AV _ LOG _ WARNING ▁, ▁"," ▁) ▁; ▁av _ log ▁( ▁st ▁-> ▁codec ▁, ▁AV _ LOG _ WARNING ▁, ▁"% d " ▁, ▁sample _ rates ▁[ ▁i ▁] ▁) ▁; ▁} ▁av _ log ▁( ▁st ▁-> ▁codec ▁, ▁AV _ LOG _ WARNING ▁, ▁" .\ n " ▁) ▁; ▁} ▁st ▁-> ▁codec ▁-> ▁sample _ rate ▁= ▁best ▁; ▁} ▁}	1
▁static ▁int ▁str match ▁( ▁const ▁char ▁* ▁s ▁, ▁const ▁char ▁* ▁prefix ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁prefix ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁prefix ▁[ ▁i ▁] ▁!= ▁s ▁[ ▁i ▁] ▁) ▁return ▁0 ▁; ▁} ▁return ▁! ▁IS _ IDENTIFIER _ CHAR ▁( ▁s ▁[ ▁i ▁] ▁) ▁; ▁}	1
▁int ▁tls 1_ get _ server _ supp lement al _ data ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁int ▁al ▁; ▁int ▁ok ▁; ▁unsigned ▁long ▁supp _ data _ len ▁, ▁authz _ data _ len ▁; ▁long ▁n ▁; ▁unsigned ▁short ▁supp _ data _ type ▁, ▁authz _ data _ type ▁, ▁proof _ len ▁; ▁const ▁unsigned ▁char ▁* ▁p ▁; ▁unsigned ▁char ▁* ▁new _ proof ▁; ▁n ▁= ▁s ▁-> ▁method ▁-> ▁ssl _ get _ message ▁( ▁s ▁, ▁SSL 3_ ST _ CR _ SUP PLE MENT AL _ DATA _ A ▁, ▁SSL 3_ ST _ CR _ SUP PLE MENT AL _ DATA _ B ▁, ▁SSL 3_ MT _ SUP PLE MENT AL _ DATA ▁, ▁TL SE XT _ MAX LEN _ supp lement al _ data ▁, ▁& ▁ok ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁return ▁( ▁( ▁int ▁) ▁n ▁) ▁; ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁s ▁-> ▁init _ msg ▁; ▁if ▁( ▁n ▁< ▁3 ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁n 2 l 3 ▁( ▁p ▁, ▁supp _ data _ len ▁) ▁; ▁n ▁-= ▁3 ▁; ▁if ▁( ▁supp _ data _ len ▁!= ▁( ▁unsigned ▁long ▁) ▁n ▁|| ▁n ▁< ▁4 ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁n 2 s ▁( ▁p ▁, ▁supp _ data _ type ▁) ▁; ▁n ▁-= ▁2 ▁; ▁if ▁( ▁supp _ data _ type ▁!= ▁TL SE XT _ SUP PLE MENT AL DATATYPE _ auth z _ data ▁) ▁{ ▁al ▁= ▁SSL _ AD _ UNEXPECTED _ MESSAGE ▁; ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁SSL _ R _ UNKNOWN _ SUP PLE MENT AL _ DATA _ TYPE ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁n 2 s ▁( ▁p ▁, ▁authz _ data _ len ▁) ▁; ▁n ▁-= ▁2 ▁; ▁if ▁( ▁authz _ data _ len ▁!= ▁( ▁unsigned ▁long ▁) ▁n ▁|| ▁n ▁< ▁1 ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁authz _ data _ type ▁= ▁* ▁( ▁p ▁++ ▁) ▁; ▁n ▁-= ▁1 ▁; ▁if ▁( ▁authz _ data _ type ▁!= ▁TL SE XT _ AUTH Z DATA FORMAT _ audit _ proof ▁) ▁{ ▁al ▁= ▁SSL _ AD _ UNEXPECTED _ MESSAGE ▁; ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁SSL _ R _ UNKNOWN _ AUTH Z _ DATA _ TYPE ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁n ▁< ▁2 ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁n 2 s ▁( ▁p ▁, ▁proof _ len ▁) ▁; ▁n ▁-= ▁2 ▁; ▁if ▁( ▁proof _ len ▁!= ▁( ▁unsigned ▁long ▁) ▁n ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁new _ proof ▁= ▁OPENSSL _ realloc ▁( ▁s ▁-> ▁session ▁-> ▁audit _ proof ▁, ▁proof _ len ▁) ▁; ▁if ▁( ▁new _ proof ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS 1_ GET _ SERVER _ SUP PLE MENT AL _ DATA ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁s ▁-> ▁session ▁-> ▁audit _ proof _ length ▁= ▁proof _ len ▁; ▁s ▁-> ▁session ▁-> ▁audit _ proof ▁= ▁new _ proof ▁; ▁memcpy ▁( ▁s ▁-> ▁session ▁-> ▁audit _ proof ▁, ▁p ▁, ▁proof _ len ▁) ▁; ▁return ▁1 ▁; ▁f _ err ▁: ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ FATAL ▁, ▁al ▁) ▁; ▁return ▁-1 ▁; ▁}	1
▁static ▁const ▁HW Accel ▁* ▁get _ hw accel ▁( ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁enum ▁HW Accel ID ▁selected _ hw accel _ id ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁hw ac cels ▁[ ▁i ▁] ▁. ▁name ▁; ▁i ▁++ ▁) ▁if ▁( ▁hw ac cels ▁[ ▁i ▁] ▁. ▁pix _ fmt ▁== ▁pix _ fmt ▁&& ▁( ▁! ▁selected _ hw accel _ id ▁|| ▁selected _ hw accel _ id ▁== ▁HW ACCEL _ AUTO ▁|| ▁hw ac cels ▁[ ▁i ▁] ▁. ▁id ▁== ▁selected _ hw accel _ id ▁) ▁) ▁return ▁& ▁hw ac cels ▁[ ▁i ▁] ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁av _ always _ inline ▁void ▁yuv 2 rgb _ full _1_ c _ template ▁( ▁S ws Context ▁* ▁c ▁, ▁const ▁int 16_ t ▁* ▁buf 0 ▁, ▁const ▁int 16_ t ▁* ▁ubuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁vbuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁a buf 0 ▁, ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁dst W ▁, ▁int ▁u val pha ▁, ▁int ▁y ▁, ▁enum ▁AV PixelFormat ▁target ▁, ▁int ▁has Alpha ▁) ▁{ ▁const ▁int 16_ t ▁* ▁ubuf 0 ▁= ▁ubuf ▁[ ▁0 ▁] ▁, ▁* ▁vbuf 0 ▁= ▁vbuf ▁[ ▁0 ▁] ▁; ▁int ▁i ▁; ▁int ▁step ▁= ▁( ▁target ▁== ▁AV _ PIX _ FMT _ RGB 24 ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ BGR 24 ▁) ▁? ▁3 ▁: ▁4 ▁; ▁int ▁err ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁if ▁( ▁target ▁== ▁AV _ PIX _ FMT _ BGR 4_ BYTE ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ RGB 4_ BYTE ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ BGR 8 ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ RGB 8 ▁) ▁step ▁= ▁1 ▁; ▁if ▁( ▁u val pha ▁< ▁2048 ▁) ▁{ ▁int ▁A ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁Y ▁= ▁buf 0 ▁[ ▁i ▁] ▁<< ▁2 ▁; ▁int ▁U ▁= ▁( ▁ubuf 0 ▁[ ▁i ▁] ▁- ▁( ▁128 ▁<< ▁7 ▁) ▁) ▁<< ▁2 ▁; ▁int ▁V ▁= ▁( ▁vbuf 0 ▁[ ▁i ▁] ▁- ▁( ▁128 ▁<< ▁7 ▁) ▁) ▁<< ▁2 ▁; ▁if ▁( ▁has Alpha ▁) ▁{ ▁A ▁= ▁( ▁a buf 0 ▁[ ▁i ▁] ▁+ ▁64 ▁) ▁>> ▁7 ▁; ▁if ▁( ▁A ▁& ▁0 x 100 ▁) ▁A ▁= ▁av _ clip _ uint 8 ▁( ▁A ▁) ▁; ▁} ▁yuv 2 rgb _ write _ full ▁( ▁c ▁, ▁dest ▁, ▁i ▁, ▁Y ▁, ▁A ▁, ▁U ▁, ▁V ▁, ▁y ▁, ▁target ▁, ▁has Alpha ▁, ▁err ▁) ▁; ▁dest ▁+= ▁step ▁; ▁} ▁} ▁else ▁{ ▁const ▁int 16_ t ▁* ▁ubuf 1 ▁= ▁ubuf ▁[ ▁1 ▁] ▁, ▁* ▁vbuf 1 ▁= ▁vbuf ▁[ ▁1 ▁] ▁; ▁int ▁A ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁Y ▁= ▁buf 0 ▁[ ▁i ▁] ▁<< ▁2 ▁; ▁int ▁U ▁= ▁( ▁ubuf 0 ▁[ ▁i ▁] ▁+ ▁ubuf 1 ▁[ ▁i ▁] ▁- ▁( ▁128 ▁<< ▁8 ▁) ▁) ▁<< ▁1 ▁; ▁int ▁V ▁= ▁( ▁vbuf 0 ▁[ ▁i ▁] ▁+ ▁vbuf 1 ▁[ ▁i ▁] ▁- ▁( ▁128 ▁<< ▁8 ▁) ▁) ▁<< ▁1 ▁; ▁if ▁( ▁has Alpha ▁) ▁{ ▁A ▁= ▁( ▁a buf 0 ▁[ ▁i ▁] ▁+ ▁64 ▁) ▁>> ▁7 ▁; ▁if ▁( ▁A ▁& ▁0 x 100 ▁) ▁A ▁= ▁av _ clip _ uint 8 ▁( ▁A ▁) ▁; ▁} ▁yuv 2 rgb _ write _ full ▁( ▁c ▁, ▁dest ▁, ▁i ▁, ▁Y ▁, ▁A ▁, ▁U ▁, ▁V ▁, ▁y ▁, ▁target ▁, ▁has Alpha ▁, ▁err ▁) ▁; ▁dest ▁+= ▁step ▁; ▁} ▁} ▁c ▁-> ▁d ither _ error ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁0 ▁] ▁; ▁c ▁-> ▁d ither _ error ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁1 ▁] ▁; ▁c ▁-> ▁d ither _ error ▁[ ▁2 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁2 ▁] ▁; ▁}	0
▁int ▁ff _ do _ el bg ▁( ▁int ▁* ▁points ▁, ▁int ▁dim ▁, ▁int ▁nump oints ▁, ▁int ▁* ▁code book ▁, ▁int ▁num CB ▁, ▁int ▁max _ steps ▁, ▁int ▁* ▁closest _ cb ▁, ▁AV L FG ▁* ▁rand _ state ▁) ▁{ ▁int ▁dist ▁; ▁el bg _ data ▁el bg _ d ▁; ▁el bg _ data ▁* ▁el bg ▁= ▁& ▁el bg _ d ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁last _ error ▁, ▁steps ▁= ▁0 ▁, ▁ret ▁= ▁0 ▁; ▁int ▁* ▁dist _ cb ▁= ▁av _ malloc ▁( ▁nump oints ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁* ▁size _ part ▁= ▁av _ malloc ▁( ▁num CB ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁cell ▁* ▁list _ buffer ▁= ▁av _ malloc ▁( ▁nump oints ▁* ▁sizeof ▁( ▁cell ▁) ▁) ▁; ▁cell ▁* ▁free _ cells ▁; ▁int ▁best _ dist ▁, ▁best _ idx ▁= ▁0 ▁; ▁el bg ▁-> ▁error ▁= ▁INT _ MAX ▁; ▁el bg ▁-> ▁dim ▁= ▁dim ▁; ▁el bg ▁-> ▁num CB ▁= ▁num CB ▁; ▁el bg ▁-> ▁code book ▁= ▁code book ▁; ▁el bg ▁-> ▁cells ▁= ▁av _ malloc ▁( ▁num CB ▁* ▁sizeof ▁( ▁cell ▁* ▁) ▁) ▁; ▁el bg ▁-> ▁utility ▁= ▁av _ malloc ▁( ▁num CB ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁el bg ▁-> ▁nearest _ cb ▁= ▁closest _ cb ▁; ▁el bg ▁-> ▁points ▁= ▁points ▁; ▁el bg ▁-> ▁utility _ inc ▁= ▁av _ malloc ▁( ▁num CB ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁el bg ▁-> ▁scratch buf ▁= ▁av _ malloc ▁( ▁5 ▁* ▁dim ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁if ▁( ▁! ▁dist _ cb ▁|| ▁! ▁size _ part ▁|| ▁! ▁list _ buffer ▁|| ▁! ▁el bg ▁-> ▁cells ▁|| ▁! ▁el bg ▁-> ▁utility ▁|| ▁! ▁el bg ▁-> ▁utility _ inc ▁|| ▁! ▁el bg ▁-> ▁scratch buf ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁out ▁; ▁} ▁el bg ▁-> ▁rand _ state ▁= ▁rand _ state ▁; ▁do ▁{ ▁free _ cells ▁= ▁list _ buffer ▁; ▁last _ error ▁= ▁el bg ▁-> ▁error ▁; ▁steps ▁++ ▁; ▁memset ▁( ▁el bg ▁-> ▁utility ▁, ▁0 ▁, ▁num CB ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁memset ▁( ▁el bg ▁-> ▁cells ▁, ▁0 ▁, ▁num CB ▁* ▁sizeof ▁( ▁cell ▁* ▁) ▁) ▁; ▁el bg ▁-> ▁error ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nump oints ▁; ▁i ▁++ ▁) ▁{ ▁best _ dist ▁= ▁distance _ limited ▁( ▁el bg ▁-> ▁points ▁+ ▁i ▁* ▁el bg ▁-> ▁dim ▁, ▁el bg ▁-> ▁code book ▁+ ▁best _ idx ▁* ▁el bg ▁-> ▁dim ▁, ▁dim ▁, ▁INT _ MAX ▁) ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁el bg ▁-> ▁num CB ▁; ▁k ▁++ ▁) ▁{ ▁dist ▁= ▁distance _ limited ▁( ▁el bg ▁-> ▁points ▁+ ▁i ▁* ▁el bg ▁-> ▁dim ▁, ▁el bg ▁-> ▁code book ▁+ ▁k ▁* ▁el bg ▁-> ▁dim ▁, ▁dim ▁, ▁best _ dist ▁) ▁; ▁if ▁( ▁dist ▁< ▁best _ dist ▁) ▁{ ▁best _ dist ▁= ▁dist ▁; ▁best _ idx ▁= ▁k ▁; ▁} ▁} ▁el bg ▁-> ▁nearest _ cb ▁[ ▁i ▁] ▁= ▁best _ idx ▁; ▁dist _ cb ▁[ ▁i ▁] ▁= ▁best _ dist ▁; ▁el bg ▁-> ▁error ▁+= ▁dist _ cb ▁[ ▁i ▁] ▁; ▁el bg ▁-> ▁utility ▁[ ▁el bg ▁-> ▁nearest _ cb ▁[ ▁i ▁] ▁] ▁+= ▁dist _ cb ▁[ ▁i ▁] ▁; ▁free _ cells ▁-> ▁index ▁= ▁i ▁; ▁free _ cells ▁-> ▁next ▁= ▁el bg ▁-> ▁cells ▁[ ▁el bg ▁-> ▁nearest _ cb ▁[ ▁i ▁] ▁] ▁; ▁el bg ▁-> ▁cells ▁[ ▁el bg ▁-> ▁nearest _ cb ▁[ ▁i ▁] ▁] ▁= ▁free _ cells ▁; ▁free _ cells ▁++ ▁; ▁} ▁do _ sh if tings ▁( ▁el bg ▁) ▁; ▁memset ▁( ▁size _ part ▁, ▁0 ▁, ▁num CB ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁memset ▁( ▁el bg ▁-> ▁code book ▁, ▁0 ▁, ▁el bg ▁-> ▁num CB ▁* ▁dim ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nump oints ▁; ▁i ▁++ ▁) ▁{ ▁size _ part ▁[ ▁el bg ▁-> ▁nearest _ cb ▁[ ▁i ▁] ▁] ▁++ ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁el bg ▁-> ▁dim ▁; ▁j ▁++ ▁) ▁el bg ▁-> ▁code book ▁[ ▁el bg ▁-> ▁nearest _ cb ▁[ ▁i ▁] ▁* ▁el bg ▁-> ▁dim ▁+ ▁j ▁] ▁+= ▁el bg ▁-> ▁points ▁[ ▁i ▁* ▁el bg ▁-> ▁dim ▁+ ▁j ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁el bg ▁-> ▁num CB ▁; ▁i ▁++ ▁) ▁vect _ division ▁( ▁el bg ▁-> ▁code book ▁+ ▁i ▁* ▁el bg ▁-> ▁dim ▁, ▁el bg ▁-> ▁code book ▁+ ▁i ▁* ▁el bg ▁-> ▁dim ▁, ▁size _ part ▁[ ▁i ▁] ▁, ▁el bg ▁-> ▁dim ▁) ▁; ▁} ▁while ▁( ▁( ▁( ▁last _ error ▁- ▁el bg ▁-> ▁error ▁) ▁> ▁DELTA _ ERR _ MAX ▁* ▁el bg ▁-> ▁error ▁) ▁&& ▁( ▁steps ▁< ▁max _ steps ▁) ▁) ▁; ▁out ▁: ▁av _ free ▁( ▁dist _ cb ▁) ▁; ▁av _ free ▁( ▁size _ part ▁) ▁; ▁av _ free ▁( ▁el bg ▁-> ▁utility ▁) ▁; ▁av _ free ▁( ▁list _ buffer ▁) ▁; ▁av _ free ▁( ▁el bg ▁-> ▁cells ▁) ▁; ▁av _ free ▁( ▁el bg ▁-> ▁utility _ inc ▁) ▁; ▁av _ free ▁( ▁el bg ▁-> ▁scratch buf ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁rv 34_ decode _ slice ▁( ▁R V 34 Dec Context ▁* ▁r ▁, ▁int ▁end ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁Mpeg Enc Context ▁* ▁s ▁= ▁& ▁r ▁-> ▁s ▁; ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁gb ▁; ▁int ▁mb _ pos ▁, ▁slice _ type ▁; ▁int ▁res ▁; ▁init _ get _ bits ▁( ▁& ▁r ▁-> ▁s ▁. ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁res ▁= ▁r ▁-> ▁parse _ slice _ header ▁( ▁r ▁, ▁gb ▁, ▁& ▁r ▁-> ▁si ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Incorrect or unknown slice header \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁slice _ type ▁= ▁r ▁-> ▁si ▁. ▁type ▁? ▁r ▁-> ▁si ▁. ▁type ▁: ▁AV _ PICTURE _ TYPE _ I ▁; ▁if ▁( ▁slice _ type ▁!= ▁s ▁-> ▁pict _ type ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" S lic etype mismatch \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁r ▁-> ▁si ▁. ▁end ▁= ▁end ▁; ▁s ▁-> ▁q scale ▁= ▁r ▁-> ▁si ▁. ▁quant ▁; ▁s ▁-> ▁mb _ num _ left ▁= ▁r ▁-> ▁si ▁. ▁end ▁- ▁r ▁-> ▁si ▁. ▁start ▁; ▁r ▁-> ▁s ▁. ▁mb _ skip _ run ▁= ▁0 ▁; ▁mb _ pos ▁= ▁s ▁-> ▁mb _ x ▁+ ▁s ▁-> ▁mb _ y ▁* ▁s ▁-> ▁mb _ width ▁; ▁if ▁( ▁r ▁-> ▁si ▁. ▁start ▁!= ▁mb _ pos ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Slice indic ates MB offset % d , got % d \ n " ▁, ▁r ▁-> ▁si ▁. ▁start ▁, ▁mb _ pos ▁) ▁; ▁s ▁-> ▁mb _ x ▁= ▁r ▁-> ▁si ▁. ▁start ▁% ▁s ▁-> ▁mb _ width ▁; ▁s ▁-> ▁mb _ y ▁= ▁r ▁-> ▁si ▁. ▁start ▁/ ▁s ▁-> ▁mb _ width ▁; ▁} ▁memset ▁( ▁r ▁-> ▁in tra _ types _ hist ▁, ▁-1 ▁, ▁r ▁-> ▁in tra _ types _ stride ▁* ▁4 ▁* ▁2 ▁* ▁sizeof ▁( ▁* ▁r ▁-> ▁in tra _ types _ hist ▁) ▁) ▁; ▁s ▁-> ▁first _ slice _ line ▁= ▁1 ▁; ▁s ▁-> ▁res ync _ mb _ x ▁= ▁s ▁-> ▁mb _ x ▁; ▁s ▁-> ▁res ync _ mb _ y ▁= ▁s ▁-> ▁mb _ y ▁; ▁ff _ init _ block _ index ▁( ▁s ▁) ▁; ▁while ▁( ▁! ▁check _ slice _ end ▁( ▁r ▁, ▁s ▁) ▁) ▁{ ▁ff _ update _ block _ index ▁( ▁s ▁) ▁; ▁if ▁( ▁r ▁-> ▁si ▁. ▁type ▁) ▁res ▁= ▁rv 34_ decode _ inter _ macro block ▁( ▁r ▁, ▁r ▁-> ▁in tra _ types ▁+ ▁s ▁-> ▁mb _ x ▁* ▁4 ▁+ ▁4 ▁) ▁; ▁else ▁res ▁= ▁rv 34_ decode _ intra _ macro block ▁( ▁r ▁, ▁r ▁-> ▁in tra _ types ▁+ ▁s ▁-> ▁mb _ x ▁* ▁4 ▁+ ▁4 ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁{ ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁s ▁-> ▁res ync _ mb _ x ▁, ▁s ▁-> ▁res ync _ mb _ y ▁, ▁s ▁-> ▁mb _ x ▁- ▁1 ▁, ▁s ▁-> ▁mb _ y ▁, ▁ER _ MB _ ERROR ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁++ ▁s ▁-> ▁mb _ x ▁== ▁s ▁-> ▁mb _ width ▁) ▁{ ▁s ▁-> ▁mb _ x ▁= ▁0 ▁; ▁s ▁-> ▁mb _ y ▁++ ▁; ▁ff _ init _ block _ index ▁( ▁s ▁) ▁; ▁memmove ▁( ▁r ▁-> ▁in tra _ types _ hist ▁, ▁r ▁-> ▁in tra _ types ▁, ▁r ▁-> ▁in tra _ types _ stride ▁* ▁4 ▁* ▁sizeof ▁( ▁* ▁r ▁-> ▁in tra _ types _ hist ▁) ▁) ▁; ▁memset ▁( ▁r ▁-> ▁in tra _ types ▁, ▁-1 ▁, ▁r ▁-> ▁in tra _ types _ stride ▁* ▁4 ▁* ▁sizeof ▁( ▁* ▁r ▁-> ▁in tra _ types _ hist ▁) ▁) ▁; ▁if ▁( ▁r ▁-> ▁loop _ filter ▁&& ▁s ▁-> ▁mb _ y ▁>= ▁2 ▁) ▁r ▁-> ▁loop _ filter ▁( ▁r ▁, ▁s ▁-> ▁mb _ y ▁- ▁2 ▁) ▁; ▁if ▁( ▁HAVE _ THREADS ▁&& ▁( ▁s ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ FRAME ▁) ▁) ▁ff _ thread _ report _ progress ▁( ▁& ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁, ▁s ▁-> ▁mb _ y ▁- ▁2 ▁, ▁0 ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁mb _ x ▁== ▁s ▁-> ▁res ync _ mb _ x ▁) ▁s ▁-> ▁first _ slice _ line ▁= ▁0 ▁; ▁s ▁-> ▁mb _ num _ left ▁-- ▁; ▁} ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁s ▁-> ▁res ync _ mb _ x ▁, ▁s ▁-> ▁res ync _ mb _ y ▁, ▁s ▁-> ▁mb _ x ▁- ▁1 ▁, ▁s ▁-> ▁mb _ y ▁, ▁ER _ MB _ END ▁) ▁; ▁return ▁s ▁-> ▁mb _ y ▁== ▁s ▁-> ▁mb _ height ▁; ▁}	0
▁static ▁av _ cold ▁int ▁vc 2_ encode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁avpkt ▁, ▁const ▁AVFrame ▁* ▁frame ▁, ▁int ▁* ▁got _ packet ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁int ▁sig _ size ▁= ▁256 ▁; ▁VC 2 Enc Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁char ▁aux _ data ▁[ ▁] ▁= ▁LIB AV CODEC _ IDENT ▁; ▁const ▁int ▁aux _ data _ size ▁= ▁sizeof ▁( ▁aux _ data ▁) ▁; ▁const ▁int ▁header _ size ▁= ▁100 ▁+ ▁aux _ data _ size ▁; ▁int 64_ t ▁max _ frame _ bytes ▁, ▁r _ bitrate ▁= ▁avctx ▁-> ▁bit _ rate ▁>> ▁( ▁s ▁-> ▁inter l aced ▁) ▁; ▁s ▁-> ▁avctx ▁= ▁avctx ▁; ▁s ▁-> ▁size _ scaler ▁= ▁2 ▁; ▁s ▁-> ▁prefix _ bytes ▁= ▁0 ▁; ▁s ▁-> ▁last _ parse _ code ▁= ▁0 ▁; ▁s ▁-> ▁next _ parse _ offset ▁= ▁0 ▁; ▁max _ frame _ bytes ▁= ▁( ▁av _ re scale ▁( ▁r _ bitrate ▁, ▁s ▁-> ▁avctx ▁-> ▁time _ base ▁. ▁num ▁, ▁s ▁-> ▁avctx ▁-> ▁time _ base ▁. ▁den ▁) ▁>> ▁3 ▁) ▁- ▁header _ size ▁; ▁while ▁( ▁sig _ size ▁> ▁255 ▁) ▁{ ▁s ▁-> ▁slice _ max _ bytes ▁= ▁FF ALIGN ▁( ▁av _ re scale ▁( ▁max _ frame _ bytes ▁, ▁1 ▁, ▁s ▁-> ▁num _ x ▁* ▁s ▁-> ▁num _ y ▁) ▁, ▁s ▁-> ▁size _ scaler ▁) ▁; ▁s ▁-> ▁slice _ max _ bytes ▁+= ▁4 ▁+ ▁s ▁-> ▁prefix _ bytes ▁; ▁sig _ size ▁= ▁s ▁-> ▁slice _ max _ bytes ▁/ ▁s ▁-> ▁size _ scaler ▁; ▁s ▁-> ▁size _ scaler ▁<<= ▁1 ▁; ▁} ▁s ▁-> ▁slice _ min _ bytes ▁= ▁s ▁-> ▁slice _ max _ bytes ▁- ▁s ▁-> ▁slice _ max _ bytes ▁* ▁( ▁s ▁-> ▁tolerance ▁/ ▁100.0 f ▁) ▁; ▁ret ▁= ▁encode _ frame ▁( ▁s ▁, ▁avpkt ▁, ▁frame ▁, ▁aux _ data ▁, ▁header _ size ▁, ▁s ▁-> ▁inter l aced ▁) ▁; ▁if ▁( ▁ret ▁) ▁return ▁ret ▁; ▁if ▁( ▁s ▁-> ▁inter l aced ▁) ▁{ ▁ret ▁= ▁encode _ frame ▁( ▁s ▁, ▁avpkt ▁, ▁frame ▁, ▁aux _ data ▁, ▁header _ size ▁, ▁2 ▁) ▁; ▁if ▁( ▁ret ▁) ▁return ▁ret ▁; ▁} ▁flush _ put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁) ▁; ▁avpkt ▁-> ▁size ▁= ▁put _ bits _ count ▁( ▁& ▁s ▁-> ▁pb ▁) ▁>> ▁3 ▁; ▁* ▁got _ packet ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁lat m _ decode _ extr adata ▁( ▁LAT M Context ▁* ▁ctx ▁, ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁size ▁) ▁{ ▁M PEG 4 Audio Config ▁m 4 ac ▁; ▁if ▁( ▁size ▁> ▁MAX _ EX TR ADATA _ SIZE ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Ex tr adata is l arger than current ly supported .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ctx ▁-> ▁off ▁= ▁avpriv _ mpeg 4 audio _ get _ config ▁( ▁& ▁m 4 ac ▁, ▁buf ▁, ▁size ▁* ▁8 ▁, ▁1 ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁off ▁< ▁0 ▁) ▁return ▁ctx ▁-> ▁off ▁; ▁if ▁( ▁ctx ▁-> ▁object _ type ▁== ▁A OT _ AL S ▁&& ▁( ▁ctx ▁-> ▁off ▁& ▁7 ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" BUG : AL S offset is not byte - aligned \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁m 4 ac ▁. ▁object _ type ▁> ▁A OT _ S BR ▁&& ▁m 4 ac ▁. ▁object _ type ▁!= ▁A OT _ AL S ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Mux ing MPEG -4 A OT % din LAT Mis not supported \ n " ▁, ▁m 4 ac ▁. ▁object _ type ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ctx ▁-> ▁channel _ conf ▁= ▁m 4 ac ▁. ▁chan _ config ▁; ▁ctx ▁-> ▁object _ type ▁= ▁m 4 ac ▁. ▁object _ type ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁char ▁* ▁sdp _ write _ media _ attributes ▁( ▁char ▁* ▁buff ▁, ▁int ▁size ▁, ▁AVCodecContext ▁* ▁c ▁, ▁int ▁payload _ type ▁, ▁AVFormatContext ▁* ▁fmt ▁) ▁{ ▁char ▁* ▁config ▁= ▁NULL ▁; ▁switch ▁( ▁c ▁-> ▁codec _ id ▁) ▁{ ▁case ▁AV _ CODEC _ ID _ H 264 ▁: ▁{ ▁int ▁mode ▁= ▁1 ▁; ▁if ▁( ▁fmt ▁&& ▁fmt ▁-> ▁of orm at ▁&& ▁fmt ▁-> ▁of orm at ▁-> ▁priv _ class ▁&& ▁av _ opt _ flag _ is _ set ▁( ▁fmt ▁-> ▁priv _ data ▁, ▁" rtp flags " ▁, ▁" h 264_ mode 0" ▁) ▁) ▁mode ▁= ▁0 ▁; ▁if ▁( ▁c ▁-> ▁extradata _ size ▁) ▁{ ▁config ▁= ▁extradata 2 p sets ▁( ▁c ▁) ▁; ▁} ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d H 264 /9 0000 \ r \ n " ▁" a = fm tp :% dp acket ization - mode =% d % s \ r \ n " ▁, ▁payload _ type ▁, ▁payload _ type ▁, ▁mode ▁, ▁config ▁? ▁config ▁: ▁"" ▁) ▁; ▁break ▁; ▁} ▁case ▁AV _ CODEC _ ID _ H 263 ▁: ▁case ▁AV _ CODEC _ ID _ H 263 P ▁: ▁if ▁( ▁! ▁fmt ▁|| ▁! ▁fmt ▁-> ▁of orm at ▁-> ▁priv _ class ▁|| ▁! ▁av _ opt _ flag _ is _ set ▁( ▁fmt ▁-> ▁priv _ data ▁, ▁" rtp flags " ▁, ▁" rfc 219 0" ▁) ▁|| ▁c ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ H 263 P ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d H 263 -2 000 /9 0000 \ r \ n " ▁" a = frames ize :% d % d -% d \ r \ n " ▁, ▁payload _ type ▁, ▁payload _ type ▁, ▁c ▁-> ▁width ▁, ▁c ▁-> ▁height ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ H EV C ▁: ▁if ▁( ▁c ▁-> ▁extradata _ size ▁) ▁config ▁= ▁extradata 2 p sets _ he vc ▁( ▁c ▁) ▁; ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d H 265 /9 0000 \ r \ n " ▁, ▁payload _ type ▁) ▁; ▁if ▁( ▁config ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = fm tp :% d % s \ r \ n " ▁, ▁payload _ type ▁, ▁config ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ MPEG 4 ▁: ▁if ▁( ▁c ▁-> ▁extradata _ size ▁) ▁{ ▁config ▁= ▁extradata 2 config ▁( ▁c ▁) ▁; ▁} ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d MP 4 V - ES /9 0000 \ r \ n " ▁" a = fm tp :% d profile - level - id =1 % s \ r \ n " ▁, ▁payload _ type ▁, ▁payload _ type ▁, ▁config ▁? ▁config ▁: ▁"" ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ A AC ▁: ▁if ▁( ▁fmt ▁&& ▁fmt ▁-> ▁of orm at ▁-> ▁priv _ class ▁&& ▁av _ opt _ flag _ is _ set ▁( ▁fmt ▁-> ▁priv _ data ▁, ▁" rtp flags " ▁, ▁" lat m " ▁) ▁) ▁{ ▁config ▁= ▁lat m _ context 2 config ▁( ▁c ▁) ▁; ▁if ▁( ▁! ▁config ▁) ▁return ▁NULL ▁; ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d MP 4 A - LAT M /% d /% d \ r \ n " ▁" a = fm tp :% d profile - level - id =% d ; cp resent =0; config =% s \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁, ▁payload _ type ▁, ▁lat m _ context 2 profile level ▁( ▁c ▁) ▁, ▁config ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁c ▁-> ▁extradata _ size ▁) ▁{ ▁config ▁= ▁extradata 2 config ▁( ▁c ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁c ▁, ▁AV _ LOG _ ERROR ▁, ▁" A AC with n og lobal headers is current ly not supported .\ n " ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁! ▁config ▁) ▁{ ▁return ▁NULL ▁; ▁} ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d MPEG 4- GENERIC /% d /% d \ r \ n " ▁" a = fm tp :% d profile - level - id =1 ;" ▁" mode = A AC - h br ; s iz elength = 13 ; index length = 3 ;" ▁" index de lt al en gth = 3 % s \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁, ▁payload _ type ▁, ▁config ▁) ▁; ▁} ▁break ▁; ▁case ▁AV _ CODEC _ ID _ PCM _ S 16 BE ▁: ▁if ▁( ▁payload _ type ▁>= ▁RTP _ PT _ PRIVATE ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% dL 16 /% d /% d \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ PCM _ MUL AW ▁: ▁if ▁( ▁payload _ type ▁>= ▁RTP _ PT _ PRIVATE ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d PCM U /% d /% d \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ PCM _ AL AW ▁: ▁if ▁( ▁payload _ type ▁>= ▁RTP _ PT _ PRIVATE ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d PC MA /% d /% d \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ AM R _ NB ▁: ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d AM R /% d /% d \ r \ n " ▁" a = fm tp :% do ct et - align = 1\ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁, ▁payload _ type ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ AM R _ WB ▁: ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d AM R - WB /% d /% d \ r \ n " ▁" a = fm tp :% do ct et - align = 1\ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁, ▁payload _ type ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ V ORB IS ▁: ▁if ▁( ▁c ▁-> ▁extradata _ size ▁) ▁config ▁= ▁x iph _ extr adata 2 config ▁( ▁c ▁) ▁; ▁else ▁av _ log ▁( ▁c ▁, ▁AV _ LOG _ ERROR ▁, ▁" V orbis configuration inf om issing \ n " ▁) ▁; ▁if ▁( ▁! ▁config ▁) ▁return ▁NULL ▁; ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% dv orbis /% d /% d \ r \ n " ▁" a = fm tp :% d configuration =% s \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁c ▁-> ▁channels ▁, ▁payload _ type ▁, ▁config ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ THE ORA ▁: ▁{ ▁const ▁char ▁* ▁pix _ fmt ▁; ▁switch ▁( ▁c ▁-> ▁pix _ fmt ▁) ▁{ ▁case ▁AV _ PIX _ FMT _ YUV 420 P ▁: ▁pix _ fmt ▁= ▁" Y Cb Cr -4 : 2: 0" ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ YUV 422 P ▁: ▁pix _ fmt ▁= ▁" Y Cb Cr -4 : 2: 2" ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ YUV 444 P ▁: ▁pix _ fmt ▁= ▁" Y Cb Cr -4 :4 : 4" ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁c ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported pixel format .\ n " ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁c ▁-> ▁extradata _ size ▁) ▁config ▁= ▁x iph _ extr adata 2 config ▁( ▁c ▁) ▁; ▁else ▁av _ log ▁( ▁c ▁, ▁AV _ LOG _ ERROR ▁, ▁" The or acon fig uation inf om issing \ n " ▁) ▁; ▁if ▁( ▁! ▁config ▁) ▁return ▁NULL ▁; ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d the ora /9 0000 \ r \ n " ▁" a = fm tp :% d delivery - method = inline ;" ▁" width =% d ; height =% d ; sampling =% s ;" ▁" configuration =% s \ r \ n " ▁, ▁payload _ type ▁, ▁payload _ type ▁, ▁c ▁-> ▁width ▁, ▁c ▁-> ▁height ▁, ▁pix _ fmt ▁, ▁config ▁) ▁; ▁break ▁; ▁} ▁case ▁AV _ CODEC _ ID _ VP 8 ▁: ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d VP 8/ 9 0000 \ r \ n " ▁, ▁payload _ type ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ M JPEG ▁: ▁if ▁( ▁payload _ type ▁>= ▁RTP _ PT _ PRIVATE ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d JPEG /9 0000 \ r \ n " ▁, ▁payload _ type ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ AD PCM _ G 7 22 ▁: ▁if ▁( ▁payload _ type ▁>= ▁RTP _ PT _ PRIVATE ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d G 7 22 /% d /% d \ r \ n " ▁, ▁payload _ type ▁, ▁8000 ▁, ▁c ▁-> ▁channels ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ AD PCM _ G 726 ▁: ▁{ ▁if ▁( ▁payload _ type ▁>= ▁RTP _ PT _ PRIVATE ▁) ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d G 726 -% d /% d \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁bits _ per _ coded _ sample ▁* ▁8 ▁, ▁c ▁-> ▁sample _ rate ▁) ▁; ▁break ▁; ▁} ▁case ▁AV _ CODEC _ ID _ IL BC ▁: ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% di LBC /% d \ r \ n " ▁" a = fm tp :% d mode =% d \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁, ▁payload _ type ▁, ▁c ▁-> ▁block _ align ▁== ▁38 ▁? ▁20 ▁: ▁30 ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ SPE EX ▁: ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% ds pe ex /% d \ r \ n " ▁, ▁payload _ type ▁, ▁c ▁-> ▁sample _ rate ▁) ▁; ▁break ▁; ▁case ▁AV _ CODEC _ ID _ OP US ▁: ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = rtp map :% d opus / 48 000/ 2\ r \ n " ▁, ▁payload _ type ▁) ▁; ▁if ▁( ▁c ▁-> ▁channels ▁== ▁2 ▁) ▁{ ▁av _ strl cat f ▁( ▁buff ▁, ▁size ▁, ▁" a = fm tp :% ds prop - stereo : 1\ r \ n " ▁, ▁payload _ type ▁) ▁; ▁} ▁break ▁; ▁default ▁: ▁break ▁; ▁} ▁av _ free ▁( ▁config ▁) ▁; ▁return ▁buff ▁; ▁}	0
▁static ▁int ▁th p _ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁Th p Demux Context ▁* ▁th p ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVStream ▁* ▁st ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int 64_ t ▁fsize ▁= ▁avio _ size ▁( ▁pb ▁) ▁; ▁int ▁i ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁th p ▁-> ▁version ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁th p ▁-> ▁fps ▁= ▁av _ d 2 q ▁( ▁av _ int 2 float ▁( ▁avio _ rb 32 ▁( ▁pb ▁) ▁) ▁, ▁INT _ MAX ▁) ▁; ▁th p ▁-> ▁frame cnt ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁th p ▁-> ▁first _ frames z ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁pb ▁-> ▁maxsize ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁fsize ▁> ▁0 ▁&& ▁( ▁! ▁pb ▁-> ▁maxsize ▁|| ▁fsize ▁< ▁pb ▁-> ▁maxsize ▁) ▁) ▁pb ▁-> ▁maxsize ▁= ▁fsize ▁; ▁th p ▁-> ▁comp off ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁th p ▁-> ▁first _ frame ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁th p ▁-> ▁last _ frame ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁th p ▁-> ▁next _ frames z ▁= ▁th p ▁-> ▁first _ frames z ▁; ▁th p ▁-> ▁next _ frame ▁= ▁th p ▁-> ▁first _ frame ▁; ▁avio _ seek ▁( ▁pb ▁, ▁th p ▁-> ▁comp off ▁, ▁SEEK _ SET ▁) ▁; ▁th p ▁-> ▁comp count ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ read ▁( ▁pb ▁, ▁th p ▁-> ▁components ▁, ▁16 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁th p ▁-> ▁comp count ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁th p ▁-> ▁components ▁[ ▁i ▁] ▁== ▁0 ▁) ▁{ ▁if ▁( ▁th p ▁-> ▁vst ▁) ▁break ▁; ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁th p ▁-> ▁fps ▁. ▁den ▁, ▁th p ▁-> ▁fps ▁. ▁num ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ VIDEO ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ TH P ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ tag ▁= ▁0 ▁; ▁st ▁-> ▁codecpar ▁-> ▁width ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁height ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁av _ q 2 d ▁( ▁th p ▁-> ▁fps ▁) ▁; ▁st ▁-> ▁nb _ frames ▁= ▁st ▁-> ▁duration ▁= ▁th p ▁-> ▁frame cnt ▁; ▁th p ▁-> ▁vst ▁= ▁st ▁; ▁th p ▁-> ▁video _ stream _ index ▁= ▁st ▁-> ▁index ▁; ▁if ▁( ▁th p ▁-> ▁version ▁== ▁0 x 11 000 ▁) ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁} ▁else ▁if ▁( ▁th p ▁-> ▁components ▁[ ▁i ▁] ▁== ▁1 ▁) ▁{ ▁if ▁( ▁th p ▁-> ▁has _ audio ▁!= ▁0 ▁) ▁break ▁; ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ AD PCM _ TH P ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ tag ▁= ▁0 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁duration ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁) ▁; ▁th p ▁-> ▁audio _ stream _ index ▁= ▁st ▁-> ▁index ▁; ▁th p ▁-> ▁has _ audio ▁= ▁1 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁ASN 1_ GENERAL IZED TIME ▁* ▁ASN 1_ TIME _ to _ general ized time ▁( ▁ASN 1_ TIME ▁* ▁t ▁, ▁ASN 1_ GENERAL IZED TIME ▁* ▁* ▁out ▁) ▁{ ▁ASN 1_ GENERAL IZED TIME ▁* ▁ret ▁; ▁char ▁* ▁str ▁; ▁if ▁( ▁! ▁ASN 1_ TIME _ check ▁( ▁t ▁) ▁) ▁return ▁NULL ▁; ▁if ▁( ▁! ▁out ▁|| ▁! ▁* ▁out ▁) ▁{ ▁if ▁( ▁! ▁( ▁ret ▁= ▁ASN 1_ GENERAL IZED TIME _ new ▁( ▁) ▁) ▁) ▁return ▁NULL ▁; ▁if ▁( ▁out ▁) ▁* ▁out ▁= ▁ret ▁; ▁} ▁else ▁ret ▁= ▁* ▁out ▁; ▁if ▁( ▁t ▁-> ▁type ▁== ▁V _ ASN 1_ GENERAL IZED TIME ▁) ▁{ ▁if ▁( ▁! ▁ASN 1_ STRING _ set ▁( ▁ret ▁, ▁t ▁-> ▁data ▁, ▁t ▁-> ▁length ▁) ▁) ▁return ▁NULL ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁! ▁ASN 1_ STRING _ set ▁( ▁ret ▁, ▁NULL ▁, ▁t ▁-> ▁length ▁+ ▁2 ▁) ▁) ▁return ▁NULL ▁; ▁str ▁= ▁( ▁char ▁* ▁) ▁ret ▁-> ▁data ▁; ▁if ▁( ▁t ▁-> ▁data ▁[ ▁0 ▁] ▁>= ▁' ▁' ▁) ▁strcpy ▁( ▁str ▁, ▁"19 " ▁) ▁; ▁else ▁strcpy ▁( ▁str ▁, ▁" 20" ▁) ▁; ▁BUF _ strl cat ▁( ▁str ▁, ▁( ▁char ▁* ▁) ▁t ▁-> ▁data ▁, ▁t ▁-> ▁length ▁+ ▁3 ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁internal _ find ▁( ▁_ STACK ▁* ▁st ▁, ▁void ▁* ▁data ▁, ▁int ▁ret _ val _ options ▁) ▁{ ▁const ▁void ▁* ▁const ▁* ▁r ▁; ▁int ▁i ▁; ▁if ▁( ▁st ▁== ▁NULL ▁) ▁return ▁-1 ▁; ▁if ▁( ▁st ▁-> ▁comp ▁== ▁NULL ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁st ▁-> ▁num ▁; ▁i ▁++ ▁) ▁if ▁( ▁st ▁-> ▁data ▁[ ▁i ▁] ▁== ▁data ▁) ▁return ▁( ▁i ▁) ▁; ▁return ▁( ▁-1 ▁) ▁; ▁} ▁sk _ sort ▁( ▁st ▁) ▁; ▁if ▁( ▁data ▁== ▁NULL ▁) ▁return ▁( ▁-1 ▁) ▁; ▁r ▁= ▁OBJ _ b search _ ex _ ▁( ▁& ▁data ▁, ▁st ▁-> ▁data ▁, ▁st ▁-> ▁num ▁, ▁sizeof ▁( ▁void ▁* ▁) ▁, ▁st ▁-> ▁comp ▁, ▁ret _ val _ options ▁) ▁; ▁if ▁( ▁r ▁== ▁NULL ▁) ▁return ▁( ▁-1 ▁) ▁; ▁return ▁( ▁int ▁) ▁( ▁( ▁char ▁* ▁* ▁) ▁r ▁- ▁st ▁-> ▁data ▁) ▁; ▁}	1
▁int ▁ff _ he vc _ decode _ short _ term _ r ps ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁Short Term R PS ▁* ▁r ps ▁, ▁const ▁H EV C SP S ▁* ▁sps ▁, ▁int ▁is _ slice _ header ▁) ▁{ ▁uint 8_ t ▁r ps _ predict ▁= ▁0 ▁; ▁int ▁delta _ p oc ▁; ▁int ▁k 0 ▁= ▁0 ▁; ▁int ▁k 1 ▁= ▁0 ▁; ▁int ▁k ▁= ▁0 ▁; ▁int ▁i ▁; ▁if ▁( ▁r ps ▁!= ▁sps ▁-> ▁st _ r ps ▁&& ▁sps ▁-> ▁nb _ st _ r ps ▁) ▁r ps _ predict ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁if ▁( ▁r ps _ predict ▁) ▁{ ▁const ▁Short Term R PS ▁* ▁r ps _ rid x ▁; ▁int ▁delta _ r ps ▁; ▁unsigned ▁abs _ delta _ r ps ▁; ▁uint 8_ t ▁use _ delta _ flag ▁= ▁0 ▁; ▁uint 8_ t ▁delta _ r ps _ sign ▁; ▁if ▁( ▁is _ slice _ header ▁) ▁{ ▁unsigned ▁int ▁delta _ idx ▁= ▁get _ ue _ go lo mb _ long ▁( ▁gb ▁) ▁+ ▁1 ▁; ▁if ▁( ▁delta _ idx ▁> ▁sps ▁-> ▁nb _ st _ r ps ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid value of delta _ idx ins lice header R PS :% d >% d .\ n " ▁, ▁delta _ idx ▁, ▁sps ▁-> ▁nb _ st _ r ps ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁r ps _ rid x ▁= ▁& ▁sps ▁-> ▁st _ r ps ▁[ ▁sps ▁-> ▁nb _ st _ r ps ▁- ▁delta _ idx ▁] ▁; ▁r ps ▁-> ▁r ps _ idx _ num _ delta _ p ocs ▁= ▁r ps _ rid x ▁-> ▁num _ delta _ p ocs ▁; ▁} ▁else ▁r ps _ rid x ▁= ▁& ▁sps ▁-> ▁st _ r ps ▁[ ▁r ps ▁- ▁sps ▁-> ▁st _ r ps ▁- ▁1 ▁] ▁; ▁delta _ r ps _ sign ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁abs _ delta _ r ps ▁= ▁get _ ue _ go lo mb _ long ▁( ▁gb ▁) ▁+ ▁1 ▁; ▁if ▁( ▁abs _ delta _ r ps ▁< ▁1 ▁|| ▁abs _ delta _ r ps ▁> ▁32768 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid value of abs _ delta _ r ps :% d \ n " ▁, ▁abs _ delta _ r ps ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁delta _ r ps ▁= ▁( ▁1 ▁- ▁( ▁delta _ r ps _ sign ▁<< ▁1 ▁) ▁) ▁* ▁abs _ delta _ r ps ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁r ps _ rid x ▁-> ▁num _ delta _ p ocs ▁; ▁i ▁++ ▁) ▁{ ▁int ▁used ▁= ▁r ps ▁-> ▁used ▁[ ▁k ▁] ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁if ▁( ▁! ▁used ▁) ▁use _ delta _ flag ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁if ▁( ▁used ▁|| ▁use _ delta _ flag ▁) ▁{ ▁if ▁( ▁i ▁< ▁r ps _ rid x ▁-> ▁num _ delta _ p ocs ▁) ▁delta _ p oc ▁= ▁delta _ r ps ▁+ ▁r ps _ rid x ▁-> ▁delta _ p oc ▁[ ▁i ▁] ▁; ▁else ▁delta _ p oc ▁= ▁delta _ r ps ▁; ▁r ps ▁-> ▁delta _ p oc ▁[ ▁k ▁] ▁= ▁delta _ p oc ▁; ▁if ▁( ▁delta _ p oc ▁< ▁0 ▁) ▁k 0 ▁++ ▁; ▁else ▁k 1 ▁++ ▁; ▁k ▁++ ▁; ▁} ▁} ▁r ps ▁-> ▁num _ delta _ p ocs ▁= ▁k ▁; ▁r ps ▁-> ▁num _ negative _ p ics ▁= ▁k 0 ▁; ▁if ▁( ▁r ps ▁-> ▁num _ delta _ p ocs ▁!= ▁0 ▁) ▁{ ▁int ▁used ▁, ▁tmp ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁r ps ▁-> ▁num _ delta _ p ocs ▁; ▁i ▁++ ▁) ▁{ ▁delta _ p oc ▁= ▁r ps ▁-> ▁delta _ p oc ▁[ ▁i ▁] ▁; ▁used ▁= ▁r ps ▁-> ▁used ▁[ ▁i ▁] ▁; ▁for ▁( ▁k ▁= ▁i ▁- ▁1 ▁; ▁k ▁>= ▁0 ▁; ▁k ▁-- ▁) ▁{ ▁tmp ▁= ▁r ps ▁-> ▁delta _ p oc ▁[ ▁k ▁] ▁; ▁if ▁( ▁delta _ p oc ▁< ▁tmp ▁) ▁{ ▁r ps ▁-> ▁delta _ p oc ▁[ ▁k ▁+ ▁1 ▁] ▁= ▁tmp ▁; ▁r ps ▁-> ▁used ▁[ ▁k ▁+ ▁1 ▁] ▁= ▁r ps ▁-> ▁used ▁[ ▁k ▁] ▁; ▁r ps ▁-> ▁delta _ p oc ▁[ ▁k ▁] ▁= ▁delta _ p oc ▁; ▁r ps ▁-> ▁used ▁[ ▁k ▁] ▁= ▁used ▁; ▁} ▁} ▁} ▁} ▁if ▁( ▁( ▁r ps ▁-> ▁num _ negative _ p ics ▁>> ▁1 ▁) ▁!= ▁0 ▁) ▁{ ▁int ▁used ▁; ▁k ▁= ▁r ps ▁-> ▁num _ negative _ p ics ▁- ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ps ▁-> ▁num _ negative _ p ics ▁>> ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁delta _ p oc ▁= ▁r ps ▁-> ▁delta _ p oc ▁[ ▁i ▁] ▁; ▁used ▁= ▁r ps ▁-> ▁used ▁[ ▁i ▁] ▁; ▁r ps ▁-> ▁delta _ p oc ▁[ ▁i ▁] ▁= ▁r ps ▁-> ▁delta _ p oc ▁[ ▁k ▁] ▁; ▁r ps ▁-> ▁used ▁[ ▁i ▁] ▁= ▁r ps ▁-> ▁used ▁[ ▁k ▁] ▁; ▁r ps ▁-> ▁delta _ p oc ▁[ ▁k ▁] ▁= ▁delta _ p oc ▁; ▁r ps ▁-> ▁used ▁[ ▁k ▁] ▁= ▁used ▁; ▁k ▁-- ▁; ▁} ▁} ▁} ▁else ▁{ ▁unsigned ▁int ▁prev ▁, ▁nb _ positive _ p ics ▁; ▁r ps ▁-> ▁num _ negative _ p ics ▁= ▁get _ ue _ go lo mb _ long ▁( ▁gb ▁) ▁; ▁nb _ positive _ p ics ▁= ▁get _ ue _ go lo mb _ long ▁( ▁gb ▁) ▁; ▁if ▁( ▁r ps ▁-> ▁num _ negative _ p ics ▁>= ▁H EV C _ MAX _ RE FS ▁|| ▁nb _ positive _ p ics ▁>= ▁H EV C _ MAX _ RE FS ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" T oom any refs in ash ort term R PS .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁r ps ▁-> ▁num _ delta _ p ocs ▁= ▁r ps ▁-> ▁num _ negative _ p ics ▁+ ▁nb _ positive _ p ics ▁; ▁if ▁( ▁r ps ▁-> ▁num _ delta _ p ocs ▁) ▁{ ▁prev ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁r ps ▁-> ▁num _ negative _ p ics ▁; ▁i ▁++ ▁) ▁{ ▁delta _ p oc ▁= ▁get _ ue _ go lo mb _ long ▁( ▁gb ▁) ▁+ ▁1 ▁; ▁prev ▁-= ▁delta _ p oc ▁; ▁r ps ▁-> ▁delta _ p oc ▁[ ▁i ▁] ▁= ▁prev ▁; ▁r ps ▁-> ▁used ▁[ ▁i ▁] ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁} ▁prev ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ positive _ p ics ▁; ▁i ▁++ ▁) ▁{ ▁delta _ p oc ▁= ▁get _ ue _ go lo mb _ long ▁( ▁gb ▁) ▁+ ▁1 ▁; ▁prev ▁+= ▁delta _ p oc ▁; ▁r ps ▁-> ▁delta _ p oc ▁[ ▁r ps ▁-> ▁num _ negative _ p ics ▁+ ▁i ▁] ▁= ▁prev ▁; ▁r ps ▁-> ▁used ▁[ ▁r ps ▁-> ▁num _ negative _ p ics ▁+ ▁i ▁] ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁m xf _ write _ header _ metadata _ sets ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁m xf _ write _ pre face ▁( ▁s ▁) ▁; ▁m xf _ write _ ident ification ▁( ▁s ▁) ▁; ▁m xf _ write _ content _ storage ▁( ▁s ▁) ▁; ▁m xf _ build _ struct ural _ metadata ▁( ▁s ▁, ▁Material Package ▁) ▁; ▁m xf _ build _ struct ural _ metadata ▁( ▁s ▁, ▁Source Package ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁MOD _ EXP _ C TIME _ COPY _ FROM _ PRE BUF ▁( ▁BIGNUM ▁* ▁b ▁, ▁int ▁top ▁, ▁unsigned ▁char ▁* ▁buf ▁, ▁int ▁idx ▁, ▁int ▁width ▁) ▁{ ▁size _ t ▁i ▁, ▁j ▁; ▁if ▁( ▁bn _ w expand ▁( ▁b ▁, ▁top ▁) ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁j ▁= ▁idx ▁; ▁i ▁< ▁top ▁* ▁sizeof ▁b ▁-> ▁d ▁[ ▁0 ▁] ▁; ▁i ▁++ ▁, ▁j ▁+= ▁width ▁) ▁{ ▁( ▁( ▁unsigned ▁char ▁* ▁) ▁b ▁-> ▁d ▁) ▁[ ▁i ▁] ▁= ▁buf ▁[ ▁j ▁] ▁; ▁} ▁b ▁-> ▁top ▁= ▁top ▁; ▁bn _ correct _ top ▁( ▁b ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁tm size _ t ▁TIFF Read Encoded Strip ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁strip ▁, ▁void ▁* ▁buf ▁, ▁tm size _ t ▁size ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Read Encoded Strip " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁uint 32 ▁rows per strip ▁; ▁uint 32 ▁stri ps per plane ▁; ▁uint 32 ▁stri pin plane ▁; ▁uint 16 ▁plane ▁; ▁uint 32 ▁rows ▁; ▁tm size _ t ▁strip size ▁; ▁if ▁( ▁! ▁TIFF Check Read ▁( ▁tif ▁, ▁0 ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁if ▁( ▁strip ▁>= ▁td ▁-> ▁td _ n stri ps ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁"% lu : Strip out of range , max % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁strip ▁, ▁( ▁unsigned ▁long ▁) ▁td ▁-> ▁td _ n stri ps ▁) ▁; ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁} ▁rows per strip ▁= ▁td ▁-> ▁td _ rows per strip ▁; ▁if ▁( ▁rows per strip ▁> ▁td ▁-> ▁td _ image length ▁) ▁rows per strip ▁= ▁td ▁-> ▁td _ image length ▁; ▁stri ps per plane ▁= ▁( ▁( ▁td ▁-> ▁td _ image length ▁+ ▁rows per strip ▁- ▁1 ▁) ▁/ ▁rows per strip ▁) ▁; ▁stri pin plane ▁= ▁( ▁strip ▁% ▁stri ps per plane ▁) ▁; ▁plane ▁= ▁( ▁uint 16 ▁) ▁( ▁strip ▁/ ▁stri ps per plane ▁) ▁; ▁rows ▁= ▁td ▁-> ▁td _ image length ▁- ▁stri pin plane ▁* ▁rows per strip ▁; ▁if ▁( ▁rows ▁> ▁rows per strip ▁) ▁rows ▁= ▁rows per strip ▁; ▁strip size ▁= ▁TIFF V Strip Size ▁( ▁tif ▁, ▁rows ▁) ▁; ▁if ▁( ▁strip size ▁== ▁0 ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁if ▁( ▁td ▁-> ▁td _ compression ▁== ▁COMPRESS ION _ NONE ▁&& ▁size ▁!= ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁&& ▁size ▁>= ▁strip size ▁&& ▁! ▁is Mapped ▁( ▁tif ▁) ▁&& ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NOR EAD RAW ▁) ▁== ▁0 ▁) ▁) ▁{ ▁if ▁( ▁TIFF Read Raw Strip 1 ▁( ▁tif ▁, ▁strip ▁, ▁buf ▁, ▁strip size ▁, ▁module ▁) ▁!= ▁strip size ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁if ▁( ▁! ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁&& ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁== ▁0 ▁) ▁TIFF Reverse Bits ▁( ▁buf ▁, ▁strip size ▁) ▁; ▁( ▁* ▁tif ▁-> ▁tif _ post decode ▁) ▁( ▁tif ▁, ▁buf ▁, ▁strip size ▁) ▁; ▁return ▁( ▁strip size ▁) ▁; ▁} ▁if ▁( ▁( ▁size ▁!= ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁&& ▁( ▁size ▁< ▁strip size ▁) ▁) ▁strip size ▁= ▁size ▁; ▁if ▁( ▁! ▁TIFF Fill Strip ▁( ▁tif ▁, ▁strip ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁if ▁( ▁( ▁* ▁tif ▁-> ▁tif _ decode strip ▁) ▁( ▁tif ▁, ▁buf ▁, ▁strip size ▁, ▁plane ▁) ▁<= ▁0 ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁( ▁* ▁tif ▁-> ▁tif _ post decode ▁) ▁( ▁tif ▁, ▁buf ▁, ▁strip size ▁) ▁; ▁return ▁( ▁strip size ▁) ▁; ▁}	0
▁static ▁int ▁mat ro sk a _ parse _ lace s ▁( ▁Mat ro sk a Demux Context ▁* ▁mat ro sk a ▁, ▁uint 8_ t ▁* ▁* ▁buf ▁, ▁int ▁* ▁buf _ size ▁, ▁int ▁type ▁, ▁uint 32_ t ▁* ▁* ▁l ace _ buf ▁, ▁int ▁* ▁l aces ▁) ▁{ ▁int ▁res ▁= ▁0 ▁, ▁n ▁, ▁size ▁= ▁* ▁buf _ size ▁; ▁uint 8_ t ▁* ▁data ▁= ▁* ▁buf ▁; ▁uint 32_ t ▁* ▁l ace _ size ▁; ▁if ▁( ▁! ▁type ▁) ▁{ ▁* ▁l aces ▁= ▁1 ▁; ▁* ▁l ace _ buf ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁if ▁( ▁! ▁* ▁l ace _ buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁* ▁l ace _ buf ▁[ ▁0 ▁] ▁= ▁size ▁; ▁return ▁0 ▁; ▁} ▁av _ assert 0 ▁( ▁size ▁> ▁0 ▁) ▁; ▁* ▁l aces ▁= ▁* ▁data ▁+ ▁1 ▁; ▁data ▁+= ▁1 ▁; ▁size ▁-= ▁1 ▁; ▁l ace _ size ▁= ▁av _ malloc z ▁( ▁* ▁l aces ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁if ▁( ▁! ▁l ace _ size ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁switch ▁( ▁type ▁) ▁{ ▁case ▁0 x 1 ▁: ▁{ ▁uint 8_ t ▁temp ▁; ▁uint 32_ t ▁total ▁= ▁0 ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁res ▁== ▁0 ▁&& ▁n ▁< ▁* ▁l aces ▁- ▁1 ▁; ▁n ▁++ ▁) ▁{ ▁while ▁( ▁1 ▁) ▁{ ▁if ▁( ▁size ▁== ▁0 ▁) ▁{ ▁res ▁= ▁AVERROR _ EOF ▁; ▁break ▁; ▁} ▁temp ▁= ▁* ▁data ▁; ▁l ace _ size ▁[ ▁n ▁] ▁+= ▁temp ▁; ▁data ▁+= ▁1 ▁; ▁size ▁-= ▁1 ▁; ▁if ▁( ▁temp ▁!= ▁0 xff ▁) ▁break ▁; ▁} ▁total ▁+= ▁l ace _ size ▁[ ▁n ▁] ▁; ▁} ▁if ▁( ▁size ▁<= ▁total ▁) ▁{ ▁res ▁= ▁AVERROR _ INVALIDDATA ▁; ▁break ▁; ▁} ▁l ace _ size ▁[ ▁n ▁] ▁= ▁size ▁- ▁total ▁; ▁break ▁; ▁} ▁case ▁0 x 2 ▁: ▁if ▁( ▁size ▁% ▁( ▁* ▁l aces ▁) ▁) ▁{ ▁res ▁= ▁AVERROR _ INVALIDDATA ▁; ▁break ▁; ▁} ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁* ▁l aces ▁; ▁n ▁++ ▁) ▁l ace _ size ▁[ ▁n ▁] ▁= ▁size ▁/ ▁* ▁l aces ▁; ▁break ▁; ▁case ▁0 x 3 ▁: ▁{ ▁uint 64_ t ▁num ▁; ▁uint 32_ t ▁total ▁; ▁n ▁= ▁mat ro sk a _ eb ml num _ uint ▁( ▁mat ro sk a ▁, ▁data ▁, ▁size ▁, ▁& ▁num ▁) ▁; ▁if ▁( ▁n ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁mat ro sk a ▁-> ▁ctx ▁, ▁AV _ LOG _ INFO ▁, ▁" EB ML block data error \ n " ▁) ▁; ▁res ▁= ▁n ▁; ▁break ▁; ▁} ▁data ▁+= ▁n ▁; ▁size ▁-= ▁n ▁; ▁total ▁= ▁l ace _ size ▁[ ▁0 ▁] ▁= ▁num ▁; ▁for ▁( ▁n ▁= ▁1 ▁; ▁res ▁== ▁0 ▁&& ▁n ▁< ▁* ▁l aces ▁- ▁1 ▁; ▁n ▁++ ▁) ▁{ ▁int 64_ t ▁s num ▁; ▁int ▁r ▁; ▁r ▁= ▁mat ro sk a _ eb ml num _ sint ▁( ▁mat ro sk a ▁, ▁data ▁, ▁size ▁, ▁& ▁s num ▁) ▁; ▁if ▁( ▁r ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁mat ro sk a ▁-> ▁ctx ▁, ▁AV _ LOG _ INFO ▁, ▁" EB ML block data error \ n " ▁) ▁; ▁res ▁= ▁r ▁; ▁break ▁; ▁} ▁data ▁+= ▁r ▁; ▁size ▁-= ▁r ▁; ▁l ace _ size ▁[ ▁n ▁] ▁= ▁l ace _ size ▁[ ▁n ▁- ▁1 ▁] ▁+ ▁s num ▁; ▁total ▁+= ▁l ace _ size ▁[ ▁n ▁] ▁; ▁} ▁if ▁( ▁size ▁<= ▁total ▁) ▁{ ▁res ▁= ▁AVERROR _ INVALIDDATA ▁; ▁break ▁; ▁} ▁l ace _ size ▁[ ▁* ▁l aces ▁- ▁1 ▁] ▁= ▁size ▁- ▁total ▁; ▁break ▁; ▁} ▁} ▁* ▁buf ▁= ▁data ▁; ▁* ▁l ace _ buf ▁= ▁l ace _ size ▁; ▁* ▁buf _ size ▁= ▁size ▁; ▁return ▁res ▁; ▁}	0
▁int ▁ctr _ generate ▁( ▁RAND _ DR BG ▁* ▁dr bg ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁size _ t ▁outlen ▁, ▁const ▁unsigned ▁char ▁* ▁ad in ▁, ▁size _ t ▁ad in len ▁) ▁{ ▁RAND _ DR BG _ CTR ▁* ▁ctr ▁= ▁& ▁dr bg ▁-> ▁ctr ▁; ▁if ▁( ▁ad in ▁!= ▁NULL ▁&& ▁ad in len ▁!= ▁0 ▁) ▁{ ▁ctr _ update ▁( ▁dr bg ▁, ▁ad in ▁, ▁ad in len ▁, ▁NULL ▁, ▁0 ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁if ▁( ▁dr bg ▁-> ▁flags ▁& ▁RAND _ DR BG _ FLAG _ CTR _ USE _ DF ▁) ▁{ ▁ad in ▁= ▁NULL ▁; ▁ad in len ▁= ▁1 ▁; ▁} ▁} ▁else ▁{ ▁ad in len ▁= ▁0 ▁; ▁} ▁for ▁( ▁; ▁; ▁) ▁{ ▁inc _128 ▁( ▁ctr ▁) ▁; ▁if ▁( ▁outlen ▁< ▁16 ▁) ▁{ ▁AES _ encrypt ▁( ▁ctr ▁-> ▁V ▁, ▁ctr ▁-> ▁K ▁, ▁& ▁ctr ▁-> ▁ks ▁) ▁; ▁memcpy ▁( ▁out ▁, ▁ctr ▁-> ▁K ▁, ▁outlen ▁) ▁; ▁break ▁; ▁} ▁AES _ encrypt ▁( ▁ctr ▁-> ▁V ▁, ▁out ▁, ▁& ▁ctr ▁-> ▁ks ▁) ▁; ▁out ▁+= ▁16 ▁; ▁outlen ▁-= ▁16 ▁; ▁if ▁( ▁outlen ▁== ▁0 ▁) ▁break ▁; ▁} ▁ctr _ update ▁( ▁dr bg ▁, ▁ad in ▁, ▁ad in len ▁, ▁NULL ▁, ▁0 ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁int ▁ff _ index _ search _ timestamp ▁( ▁const ▁AV Index Entry ▁* ▁entries ▁, ▁int ▁nb _ entries ▁, ▁int 64_ t ▁wanted _ timestamp ▁, ▁int ▁flags ▁) ▁{ ▁int ▁a ▁, ▁b ▁, ▁m ▁; ▁int 64_ t ▁timestamp ▁; ▁a ▁= ▁-1 ▁; ▁b ▁= ▁nb _ entries ▁; ▁if ▁( ▁b ▁&& ▁entries ▁[ ▁b ▁- ▁1 ▁] ▁. ▁timestamp ▁< ▁wanted _ timestamp ▁) ▁a ▁= ▁b ▁- ▁1 ▁; ▁while ▁( ▁b ▁- ▁a ▁> ▁1 ▁) ▁{ ▁m ▁= ▁( ▁a ▁+ ▁b ▁) ▁>> ▁1 ▁; ▁while ▁( ▁( ▁entries ▁[ ▁m ▁] ▁. ▁flags ▁& ▁AV INDEX _ DISCARD _ FRAME ▁) ▁&& ▁m ▁< ▁b ▁&& ▁m ▁< ▁nb _ entries ▁- ▁1 ▁) ▁{ ▁m ▁++ ▁; ▁if ▁( ▁m ▁== ▁b ▁&& ▁entries ▁[ ▁m ▁] ▁. ▁timestamp ▁>= ▁wanted _ timestamp ▁) ▁{ ▁m ▁= ▁b ▁- ▁1 ▁; ▁break ▁; ▁} ▁} ▁timestamp ▁= ▁entries ▁[ ▁m ▁] ▁. ▁timestamp ▁; ▁if ▁( ▁timestamp ▁>= ▁wanted _ timestamp ▁) ▁b ▁= ▁m ▁; ▁if ▁( ▁timestamp ▁<= ▁wanted _ timestamp ▁) ▁a ▁= ▁m ▁; ▁} ▁m ▁= ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁) ▁? ▁a ▁: ▁b ▁; ▁if ▁( ▁! ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ ANY ▁) ▁) ▁while ▁( ▁m ▁>= ▁0 ▁&& ▁m ▁< ▁nb _ entries ▁&& ▁! ▁( ▁entries ▁[ ▁m ▁] ▁. ▁flags ▁& ▁AV INDEX _ KEY FRAME ▁) ▁) ▁m ▁+= ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁) ▁? ▁-1 ▁: ▁1 ▁; ▁if ▁( ▁m ▁== ▁nb _ entries ▁) ▁return ▁-1 ▁; ▁return ▁m ▁; ▁}	0
▁static ▁int ▁expand _ r le _ row ▁( ▁S gi State ▁* ▁s ▁, ▁uint 8_ t ▁* ▁out _ buf ▁, ▁uint 8_ t ▁* ▁out _ end ▁, ▁int ▁pixel stride ▁) ▁{ ▁unsigned ▁char ▁pixel ▁, ▁count ▁; ▁unsigned ▁char ▁* ▁orig ▁= ▁out _ buf ▁; ▁while ▁( ▁1 ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁g ▁) ▁< ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁pixel ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁if ▁( ▁! ▁( ▁count ▁= ▁( ▁pixel ▁& ▁0 x 7 f ▁) ▁) ▁) ▁{ ▁return ▁( ▁out _ buf ▁- ▁orig ▁) ▁/ ▁pixel stride ▁; ▁} ▁if ▁( ▁out _ buf ▁+ ▁pixel stride ▁* ▁count ▁>= ▁out _ end ▁) ▁return ▁-1 ▁; ▁if ▁( ▁pixel ▁& ▁0 x 80 ▁) ▁{ ▁while ▁( ▁count ▁-- ▁) ▁{ ▁* ▁out _ buf ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁out _ buf ▁+= ▁pixel stride ▁; ▁} ▁} ▁else ▁{ ▁pixel ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁while ▁( ▁count ▁-- ▁) ▁{ ▁* ▁out _ buf ▁= ▁pixel ▁; ▁out _ buf ▁+= ▁pixel stride ▁; ▁} ▁} ▁} ▁}	0
▁static ▁EVP _ PKEY _ CTX ▁* ▁int _ ctx _ new ▁( ▁EVP _ PKEY ▁* ▁pkey ▁, ▁ENGINE ▁* ▁e ▁, ▁int ▁id ▁) ▁{ ▁EVP _ PKEY _ CTX ▁* ▁ret ▁; ▁const ▁EVP _ PKEY _ METHOD ▁* ▁pm eth ▁; ▁if ▁( ▁id ▁== ▁-1 ▁) ▁{ ▁if ▁( ▁! ▁pkey ▁|| ▁! ▁pkey ▁-> ▁am eth ▁) ▁return ▁NULL ▁; ▁id ▁= ▁pkey ▁-> ▁am eth ▁-> ▁pkey _ id ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁if ▁( ▁pkey ▁&& ▁pkey ▁-> ▁engine ▁) ▁e ▁= ▁pkey ▁-> ▁engine ▁; ▁if ▁( ▁e ▁) ▁{ ▁if ▁( ▁! ▁ENGINE _ init ▁( ▁e ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ INT _ CTX _ NEW ▁, ▁ERR _ R _ ENGINE _ LIB ▁) ▁; ▁return ▁NULL ▁; ▁} ▁} ▁else ▁e ▁= ▁ENGINE _ get _ pkey _ meth _ engine ▁( ▁id ▁) ▁; ▁if ▁( ▁e ▁) ▁pm eth ▁= ▁ENGINE _ get _ pkey _ meth ▁( ▁e ▁, ▁id ▁) ▁; ▁else ▁# endif ▁pm eth ▁= ▁EVP _ PKEY _ meth _ find ▁( ▁id ▁) ▁; ▁if ▁( ▁pm eth ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ INT _ CTX _ NEW ▁, ▁EVP _ R _ UNSUPPORTED _ ALGORITHM ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ret ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁ret ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁ENGINE _ finish ▁( ▁e ▁) ▁; ▁# endif ▁EVP err ▁( ▁EVP _ F _ INT _ CTX _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ret ▁-> ▁engine ▁= ▁e ▁; ▁ret ▁-> ▁pm eth ▁= ▁pm eth ▁; ▁ret ▁-> ▁operation ▁= ▁EVP _ PKEY _ OP _ UNDEFINED ▁; ▁ret ▁-> ▁pkey ▁= ▁pkey ▁; ▁if ▁( ▁pkey ▁) ▁CRYPTO _ add ▁( ▁& ▁pkey ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ EVP _ PKEY ▁) ▁; ▁if ▁( ▁pm eth ▁-> ▁init ▁) ▁{ ▁if ▁( ▁pm eth ▁-> ▁init ▁( ▁ret ▁) ▁<= ▁0 ▁) ▁{ ▁EVP _ PKEY _ CTX _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁} ▁} ▁return ▁ret ▁; ▁}	0
▁void ▁ff _ insert _ pad ▁( ▁unsigned ▁idx ▁, ▁unsigned ▁* ▁count ▁, ▁size _ t ▁pad idx _ off ▁, ▁AVFilter Pad ▁* ▁* ▁pad s ▁, ▁AVFilter Link ▁* ▁* ▁* ▁links ▁, ▁AVFilter Pad ▁* ▁new pad ▁) ▁{ ▁unsigned ▁i ▁; ▁idx ▁= ▁FF MIN ▁( ▁idx ▁, ▁* ▁count ▁) ▁; ▁* ▁pad s ▁= ▁av _ realloc ▁( ▁* ▁pad s ▁, ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁( ▁* ▁count ▁+ ▁1 ▁) ▁) ▁; ▁* ▁links ▁= ▁av _ realloc ▁( ▁* ▁links ▁, ▁sizeof ▁( ▁AVFilter Link ▁* ▁) ▁* ▁( ▁* ▁count ▁+ ▁1 ▁) ▁) ▁; ▁memmove ▁( ▁* ▁pad s ▁+ ▁idx ▁+ ▁1 ▁, ▁* ▁pad s ▁+ ▁idx ▁, ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁( ▁* ▁count ▁- ▁idx ▁) ▁) ▁; ▁memmove ▁( ▁* ▁links ▁+ ▁idx ▁+ ▁1 ▁, ▁* ▁links ▁+ ▁idx ▁, ▁sizeof ▁( ▁AVFilter Link ▁* ▁) ▁* ▁( ▁* ▁count ▁- ▁idx ▁) ▁) ▁; ▁memcpy ▁( ▁* ▁pad s ▁+ ▁idx ▁, ▁new pad ▁, ▁sizeof ▁( ▁AVFilter Pad ▁) ▁) ▁; ▁( ▁* ▁links ▁) ▁[ ▁idx ▁] ▁= ▁NULL ▁; ▁( ▁* ▁count ▁) ▁++ ▁; ▁for ▁( ▁i ▁= ▁idx ▁+ ▁1 ▁; ▁i ▁< ▁* ▁count ▁; ▁i ▁++ ▁) ▁if ▁( ▁* ▁links ▁[ ▁i ▁] ▁) ▁( ▁* ▁( ▁unsigned ▁* ▁) ▁( ▁( ▁uint 8_ t ▁* ▁) ▁* ▁links ▁[ ▁i ▁] ▁+ ▁pad idx _ off ▁) ▁) ▁++ ▁; ▁}	1
▁int ▁unpack _ rev info ▁( ▁ASN 1_ TIME ▁* ▁* ▁prev tm ▁, ▁int ▁* ▁pre ason ▁, ▁ASN 1_ OBJECT ▁* ▁* ▁ph old ▁, ▁ASN 1_ GENERAL IZED TIME ▁* ▁* ▁pin v tm ▁, ▁const ▁char ▁* ▁str ▁) ▁{ ▁char ▁* ▁tmp ▁; ▁char ▁* ▁r time _ str ▁, ▁* ▁reason _ str ▁= ▁NULL ▁, ▁* ▁arg _ str ▁= ▁NULL ▁, ▁* ▁p ▁; ▁int ▁reason _ code ▁= ▁-1 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁unsigned ▁int ▁i ▁; ▁ASN 1_ OBJECT ▁* ▁hold ▁= ▁NULL ▁; ▁ASN 1_ GENERAL IZED TIME ▁* ▁comp _ time ▁= ▁NULL ▁; ▁tmp ▁= ▁OPENSSL _ strdup ▁( ▁str ▁) ▁; ▁if ▁( ▁! ▁tmp ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" memory allocation failure \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁p ▁= ▁strchr ▁( ▁tmp ▁, ▁' ▁' ▁) ▁; ▁r time _ str ▁= ▁tmp ▁; ▁if ▁( ▁p ▁) ▁{ ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁p ▁++ ▁; ▁reason _ str ▁= ▁p ▁; ▁p ▁= ▁strchr ▁( ▁p ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁p ▁) ▁{ ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁arg _ str ▁= ▁p ▁+ ▁1 ▁; ▁} ▁} ▁if ▁( ▁prev tm ▁) ▁{ ▁* ▁prev tm ▁= ▁ASN 1_ UTC TIME _ new ▁( ▁) ▁; ▁if ▁( ▁* ▁prev tm ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" memory allocation failure \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁ASN 1_ UTC TIME _ set _ string ▁( ▁* ▁prev tm ▁, ▁r time _ str ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" invalid re vocation date % s \ n " ▁, ▁r time _ str ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁if ▁( ▁reason _ str ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NUM _ REASON S ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁strcasecmp ▁( ▁reason _ str ▁, ▁crl _ reasons ▁[ ▁i ▁] ▁) ▁== ▁0 ▁) ▁{ ▁reason _ code ▁= ▁i ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁reason _ code ▁== ▁OCSP _ REV OKED _ STATUS _ NO STATUS ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" invalid reason code % s \ n " ▁, ▁reason _ str ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁reason _ code ▁== ▁7 ▁) ▁reason _ code ▁= ▁OCSP _ REV OKED _ STATUS _ REMOVE FROM CRL ▁; ▁else ▁if ▁( ▁reason _ code ▁== ▁8 ▁) ▁{ ▁if ▁( ▁! ▁arg _ str ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" missing hold instruction \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁reason _ code ▁= ▁OCSP _ REV OKED _ STATUS _ CERTIFICATE HOLD ▁; ▁hold ▁= ▁OBJ _ txt 2 obj ▁( ▁arg _ str ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁hold ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" invalid object identifier % s \ n " ▁, ▁arg _ str ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁ph old ▁) ▁* ▁ph old ▁= ▁hold ▁; ▁else ▁ASN 1_ OBJECT _ free ▁( ▁hold ▁) ▁; ▁} ▁else ▁if ▁( ▁( ▁reason _ code ▁== ▁9 ▁) ▁|| ▁( ▁reason _ code ▁== ▁10 ▁) ▁) ▁{ ▁if ▁( ▁! ▁arg _ str ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" missing comp rom ised time \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁comp _ time ▁= ▁ASN 1_ GENERAL IZED TIME _ new ▁( ▁) ▁; ▁if ▁( ▁comp _ time ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" memory allocation failure \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁ASN 1_ GENERAL IZED TIME _ set _ string ▁( ▁comp _ time ▁, ▁arg _ str ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" invalid comp rom ised time % s \ n " ▁, ▁arg _ str ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁reason _ code ▁== ▁9 ▁) ▁reason _ code ▁= ▁OCSP _ REV OKED _ STATUS _ KEY COMP RO MI SE ▁; ▁else ▁reason _ code ▁= ▁OCSP _ REV OKED _ STATUS _ C ACO MP RO MI SE ▁; ▁} ▁} ▁if ▁( ▁pre ason ▁) ▁* ▁pre ason ▁= ▁reason _ code ▁; ▁if ▁( ▁pin v tm ▁) ▁{ ▁* ▁pin v tm ▁= ▁comp _ time ▁; ▁comp _ time ▁= ▁NULL ▁; ▁} ▁ret ▁= ▁1 ▁; ▁end ▁: ▁OPENSSL _ free ▁( ▁tmp ▁) ▁; ▁ASN 1_ GENERAL IZED TIME _ free ▁( ▁comp _ time ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁start _ connect ▁( ▁struct ▁connection ▁* ▁c ▁) ▁{ ▁apr _ status _ t ▁rv ▁; ▁if ▁( ▁! ▁( ▁started ▁< ▁requests ▁) ▁) ▁return ▁; ▁c ▁-> ▁read ▁= ▁0 ▁; ▁c ▁-> ▁bread ▁= ▁0 ▁; ▁c ▁-> ▁keep alive ▁= ▁0 ▁; ▁c ▁-> ▁cb x ▁= ▁0 ▁; ▁c ▁-> ▁got header ▁= ▁0 ▁; ▁c ▁-> ▁r write ▁= ▁0 ▁; ▁if ▁( ▁c ▁-> ▁ctx ▁) ▁apr _ pool _ destroy ▁( ▁c ▁-> ▁ctx ▁) ▁; ▁apr _ pool _ create ▁( ▁& ▁c ▁-> ▁ctx ▁, ▁cnt xt ▁) ▁; ▁if ▁( ▁( ▁rv ▁= ▁apr _ socket _ create ▁( ▁& ▁c ▁-> ▁apr sock ▁, ▁dest sa ▁-> ▁family ▁, ▁SOCK _ STREAM ▁, ▁0 ▁, ▁c ▁-> ▁ctx ▁) ▁) ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁apr _ err ▁( ▁" socket " ▁, ▁rv ▁) ▁; ▁} ▁if ▁( ▁( ▁rv ▁= ▁apr _ socket _ opt _ set ▁( ▁c ▁-> ▁apr sock ▁, ▁APR _ SO _ NONBLOCK ▁, ▁1 ▁) ▁) ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁apr _ err ▁( ▁" socket non block " ▁, ▁rv ▁) ▁; ▁} ▁if ▁( ▁windows ize ▁!= ▁0 ▁) ▁{ ▁rv ▁= ▁apr _ socket _ opt _ set ▁( ▁c ▁-> ▁apr sock ▁, ▁APR _ SO _ SND BUF ▁, ▁windows ize ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁&& ▁rv ▁!= ▁APR _ ENO TIM PL ▁) ▁{ ▁apr _ err ▁( ▁" socket send buffer " ▁, ▁rv ▁) ▁; ▁} ▁rv ▁= ▁apr _ socket _ opt _ set ▁( ▁c ▁-> ▁apr sock ▁, ▁APR _ SO _ RC V BUF ▁, ▁windows ize ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁&& ▁rv ▁!= ▁APR _ ENO TIM PL ▁) ▁{ ▁apr _ err ▁( ▁" socket receive buffer " ▁, ▁rv ▁) ▁; ▁} ▁} ▁c ▁-> ▁start ▁= ▁last time ▁= ▁apr _ time _ now ▁( ▁) ▁; ▁# ifdef ▁USE _ SSL ▁if ▁( ▁is _ ssl ▁) ▁{ ▁BIO ▁* ▁bio ▁; ▁apr _ os _ sock _ t ▁fd ▁; ▁if ▁( ▁( ▁c ▁-> ▁ssl ▁= ▁SSL _ new ▁( ▁ssl _ ctx ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" SSL _ new failed .\ n " ▁) ▁; ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁exit ▁( ▁1 ▁) ▁; ▁} ▁ssl _ rand _ seed ▁( ▁) ▁; ▁apr _ os _ sock _ get ▁( ▁& ▁fd ▁, ▁c ▁-> ▁apr sock ▁) ▁; ▁bio ▁= ▁BIO _ new _ socket ▁( ▁fd ▁, ▁BIO _ NO CLOSE ▁) ▁; ▁SSL _ set _ bio ▁( ▁c ▁-> ▁ssl ▁, ▁bio ▁, ▁bio ▁) ▁; ▁SSL _ set _ connect _ state ▁( ▁c ▁-> ▁ssl ▁) ▁; ▁if ▁( ▁verbosity ▁>= ▁4 ▁) ▁{ ▁BIO _ set _ callback ▁( ▁bio ▁, ▁ssl _ print _ cb ▁) ▁; ▁BIO _ set _ callback _ arg ▁( ▁bio ▁, ▁( ▁void ▁* ▁) ▁bio _ err ▁) ▁; ▁} ▁} ▁else ▁{ ▁c ▁-> ▁ssl ▁= ▁NULL ▁; ▁} ▁# endif ▁if ▁( ▁( ▁rv ▁= ▁apr _ socket _ connect ▁( ▁c ▁-> ▁apr sock ▁, ▁dest sa ▁) ▁) ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁if ▁( ▁APR _ STATUS _ IS _ E INPROGRESS ▁( ▁rv ▁) ▁) ▁{ ▁apr _ pol lfd _ t ▁new _ pol lfd ▁; ▁c ▁-> ▁state ▁= ▁STATE _ CONNECT ING ▁; ▁c ▁-> ▁r write ▁= ▁0 ▁; ▁new _ pol lfd ▁. ▁desc _ type ▁= ▁APR _ POLL _ SOCKET ▁; ▁new _ pol lfd ▁. ▁req events ▁= ▁APR _ POL LOUT ▁; ▁new _ pol lfd ▁. ▁desc ▁. ▁s ▁= ▁c ▁-> ▁apr sock ▁; ▁new _ pol lfd ▁. ▁client _ data ▁= ▁c ▁; ▁apr _ poll set _ add ▁( ▁read bits ▁, ▁& ▁new _ pol lfd ▁) ▁; ▁return ▁; ▁} ▁else ▁{ ▁apr _ pol lfd _ t ▁remove _ pol lfd ▁; ▁remove _ pol lfd ▁. ▁desc _ type ▁= ▁APR _ POLL _ SOCKET ▁; ▁remove _ pol lfd ▁. ▁desc ▁. ▁s ▁= ▁c ▁-> ▁apr sock ▁; ▁apr _ poll set _ remove ▁( ▁read bits ▁, ▁& ▁remove _ pol lfd ▁) ▁; ▁apr _ socket _ close ▁( ▁c ▁-> ▁apr sock ▁) ▁; ▁err _ conn ▁++ ▁; ▁if ▁( ▁bad ▁++ ▁> ▁10 ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁"\ n Test abort ed after 10 failures \ n \ n " ▁) ▁; ▁apr _ err ▁( ▁" apr _ socket _ connect ()" ▁, ▁rv ▁) ▁; ▁} ▁c ▁-> ▁state ▁= ▁STATE _ UN CONNECTED ▁; ▁start _ connect ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁} ▁c ▁-> ▁state ▁= ▁STATE _ CONNECTED ▁; ▁started ▁++ ▁; ▁# ifdef ▁USE _ SSL ▁if ▁( ▁c ▁-> ▁ssl ▁) ▁{ ▁ssl _ pro ceed _ handshake ▁( ▁c ▁) ▁; ▁} ▁else ▁# endif ▁{ ▁write _ request ▁( ▁c ▁) ▁; ▁} ▁}	0
▁static ▁int ▁adx _ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁AD X Demux er Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVCodec Parameters ▁* ▁par ▁; ▁AVStream ▁* ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁par ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codecpar ▁; ▁if ▁( ▁avio _ rb 16 ▁( ▁s ▁-> ▁pb ▁) ▁!= ▁0 x 8000 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁c ▁-> ▁header _ size ▁= ▁avio _ rb 16 ▁( ▁s ▁-> ▁pb ▁) ▁+ ▁4 ▁; ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁-4 ▁, ▁SEEK _ CUR ▁) ▁; ▁if ▁( ▁ff _ get _ extr adata ▁( ▁s ▁, ▁par ▁, ▁s ▁-> ▁pb ▁, ▁c ▁-> ▁header _ size ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁par ▁-> ▁extradata _ size ▁< ▁12 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" In val i dex trad atas ize .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁par ▁-> ▁channels ▁= ▁AV _ RB 8 ▁( ▁par ▁-> ▁extradata ▁+ ▁7 ▁) ▁; ▁par ▁-> ▁sample _ rate ▁= ▁AV _ RB 32 ▁( ▁par ▁-> ▁extradata ▁+ ▁8 ▁) ▁; ▁if ▁( ▁par ▁-> ▁channels ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid number of channels % d \ n " ▁, ▁par ▁-> ▁channels ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁par ▁-> ▁sample _ rate ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid sampler ate % d \ n " ▁, ▁par ▁-> ▁sample _ rate ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁par ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁par ▁-> ▁codec _ id ▁= ▁s ▁-> ▁if orm at ▁-> ▁raw _ codec _ id ▁; ▁par ▁-> ▁bit _ rate ▁= ▁par ▁-> ▁sample _ rate ▁* ▁par ▁-> ▁channels ▁* ▁BLOCK _ SIZE ▁* ▁8 LL ▁/ ▁BLOCK _ SAMPLES ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁BLOCK _ SAMPLES ▁, ▁par ▁-> ▁sample _ rate ▁) ▁; ▁return ▁0 ▁; ▁}	1
