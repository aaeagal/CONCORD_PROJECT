code	label
▁static ▁int 64_ t ▁wrap _ timestamp ▁( ▁AVStream ▁* ▁st ▁, ▁int 64_ t ▁timestamp ▁) ▁{ ▁if ▁( ▁st ▁-> ▁pts _ wrap _ behavior ▁!= ▁AV _ PT S _ WRAP _ IGNORE ▁&& ▁st ▁-> ▁pts _ wrap _ bits ▁< ▁64 ▁&& ▁st ▁-> ▁pts _ wrap _ reference ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁timestamp ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁if ▁( ▁st ▁-> ▁pts _ wrap _ behavior ▁== ▁AV _ PT S _ WRAP _ ADD _ OFFSET ▁&& ▁timestamp ▁< ▁st ▁-> ▁pts _ wrap _ reference ▁) ▁return ▁timestamp ▁+ ▁( ▁1 ULL ▁<< ▁st ▁-> ▁pts _ wrap _ bits ▁) ▁; ▁else ▁if ▁( ▁st ▁-> ▁pts _ wrap _ behavior ▁== ▁AV _ PT S _ WRAP _ SUB _ OFFSET ▁&& ▁timestamp ▁>= ▁st ▁-> ▁pts _ wrap _ reference ▁) ▁return ▁timestamp ▁- ▁( ▁1 ULL ▁<< ▁st ▁-> ▁pts _ wrap _ bits ▁) ▁; ▁} ▁return ▁timestamp ▁; ▁}	0
▁void ▁ngx _ rbtree _ insert _ timer _ value ▁( ▁ngx _ rbtree _ node _ t ▁* ▁temp ▁, ▁ngx _ rbtree _ node _ t ▁* ▁node ▁, ▁ngx _ rbtree _ node _ t ▁* ▁sentinel ▁) ▁{ ▁ngx _ rbtree _ node _ t ▁* ▁* ▁p ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁p ▁= ▁( ▁( ▁ngx _ rbtree _ key _ int _ t ▁) ▁node ▁-> ▁key ▁- ▁( ▁ngx _ rbtree _ key _ int _ t ▁) ▁temp ▁-> ▁key ▁< ▁0 ▁) ▁? ▁& ▁temp ▁-> ▁left ▁: ▁& ▁temp ▁-> ▁right ▁; ▁if ▁( ▁* ▁p ▁== ▁sentinel ▁) ▁{ ▁break ▁; ▁} ▁temp ▁= ▁* ▁p ▁; ▁} ▁* ▁p ▁= ▁node ▁; ▁node ▁-> ▁parent ▁= ▁temp ▁; ▁node ▁-> ▁left ▁= ▁sentinel ▁; ▁node ▁-> ▁right ▁= ▁sentinel ▁; ▁ngx _ rb t _ red ▁( ▁node ▁) ▁; ▁}	1
▁static ▁int ▁check _ pkt ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁MO VM ux Context ▁* ▁mov ▁= ▁s ▁-> ▁priv _ data ▁; ▁MOV Track ▁* ▁tr k ▁= ▁& ▁mov ▁-> ▁tracks ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁; ▁int 64_ t ▁ref ▁; ▁uint 64_ t ▁duration ▁; ▁if ▁( ▁tr k ▁-> ▁entry ▁) ▁{ ▁ref ▁= ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁- ▁1 ▁] ▁. ▁dts ▁; ▁} ▁else ▁if ▁( ▁tr k ▁-> ▁start _ dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁ref ▁= ▁tr k ▁-> ▁start _ dts ▁+ ▁tr k ▁-> ▁track _ duration ▁; ▁} ▁else ▁ref ▁= ▁pkt ▁-> ▁dts ▁; ▁duration ▁= ▁pkt ▁-> ▁dts ▁- ▁ref ▁; ▁if ▁( ▁pkt ▁-> ▁dts ▁< ▁ref ▁|| ▁duration ▁>= ▁INT _ MAX ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Application provide dd uration :% " ▁PRId 64 ▁"/ timestamp :% " ▁PRId 64 ▁" is out of range form ov / mp 4 format \ n " ▁, ▁duration ▁, ▁pkt ▁-> ▁dts ▁) ▁; ▁pkt ▁-> ▁dts ▁= ▁ref ▁+ ▁1 ▁; ▁pkt ▁-> ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁if ▁( ▁pkt ▁-> ▁duration ▁< ▁0 ▁|| ▁pkt ▁-> ▁duration ▁> ▁INT _ MAX ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Application provide dd uration :% " ▁PRId 64 ▁" is invalid \ n " ▁, ▁pkt ▁-> ▁duration ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁SSL _ early _ get 1_ extensions _ present ▁( ▁SSL ▁* ▁s ▁, ▁int ▁* ▁* ▁out ▁, ▁size _ t ▁* ▁outlen ▁) ▁{ ▁RAW _ EXTENSION ▁* ▁ext ▁; ▁int ▁* ▁present ▁; ▁size _ t ▁num ▁= ▁0 ▁, ▁i ▁; ▁if ▁( ▁s ▁-> ▁client hello ▁== ▁NULL ▁|| ▁out ▁== ▁NULL ▁|| ▁outlen ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁client hello ▁-> ▁pre _ proc _ ext s _ len ▁; ▁i ▁++ ▁) ▁{ ▁ext ▁= ▁s ▁-> ▁client hello ▁-> ▁pre _ proc _ ext s ▁+ ▁i ▁; ▁if ▁( ▁ext ▁-> ▁present ▁) ▁num ▁++ ▁; ▁} ▁present ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁present ▁) ▁* ▁num ▁) ▁; ▁if ▁( ▁present ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁client hello ▁-> ▁pre _ proc _ ext s _ len ▁; ▁i ▁++ ▁) ▁{ ▁ext ▁= ▁s ▁-> ▁client hello ▁-> ▁pre _ proc _ ext s ▁+ ▁i ▁; ▁if ▁( ▁ext ▁-> ▁present ▁) ▁{ ▁if ▁( ▁ext ▁-> ▁received _ order ▁>= ▁num ▁) ▁goto ▁err ▁; ▁present ▁[ ▁ext ▁-> ▁received _ order ▁] ▁= ▁ext ▁-> ▁type ▁; ▁} ▁} ▁* ▁out ▁= ▁present ▁; ▁* ▁outlen ▁= ▁num ▁; ▁return ▁1 ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁present ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁generate _ code book ▁( ▁Ro q Context ▁* ▁enc ▁, ▁Ro q Temp data ▁* ▁temp data ▁, ▁int ▁* ▁points ▁, ▁int ▁input Count ▁, ▁ro q _ cell ▁* ▁results ▁, ▁int ▁size ▁, ▁int ▁cb size ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁ret ▁= ▁0 ▁; ▁int ▁c _ size ▁= ▁size ▁* ▁size ▁/ ▁4 ▁; ▁int ▁* ▁buf ▁; ▁int ▁* ▁code book ▁= ▁av _ malloc ▁( ▁6 ▁* ▁c _ size ▁* ▁cb size ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁* ▁closest _ cb ▁; ▁if ▁( ▁! ▁code book ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁size ▁== ▁4 ▁) ▁{ ▁closest _ cb ▁= ▁av _ malloc ▁( ▁6 ▁* ▁c _ size ▁* ▁input Count ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁if ▁( ▁! ▁closest _ cb ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁out ▁; ▁} ▁} ▁else ▁closest _ cb ▁= ▁temp data ▁-> ▁closest _ cb 2 ▁; ▁ret ▁= ▁ff _ init _ el bg ▁( ▁points ▁, ▁6 ▁* ▁c _ size ▁, ▁input Count ▁, ▁code book ▁, ▁cb size ▁, ▁1 ▁, ▁closest _ cb ▁, ▁& ▁enc ▁-> ▁rand ctx ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁out ▁; ▁ret ▁= ▁ff _ do _ el bg ▁( ▁points ▁, ▁6 ▁* ▁c _ size ▁, ▁input Count ▁, ▁code book ▁, ▁cb size ▁, ▁1 ▁, ▁closest _ cb ▁, ▁& ▁enc ▁-> ▁rand ctx ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁out ▁; ▁buf ▁= ▁code book ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁cb size ▁; ▁i ▁++ ▁) ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁c _ size ▁; ▁k ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁results ▁-> ▁y ▁[ ▁j ▁] ▁= ▁* ▁buf ▁++ ▁; ▁results ▁-> ▁u ▁= ▁( ▁* ▁buf ▁++ ▁+ ▁CH RO MA _ BIAS ▁/ ▁2 ▁) ▁/ ▁CH RO MA _ BIAS ▁; ▁results ▁-> ▁v ▁= ▁( ▁* ▁buf ▁++ ▁+ ▁CH RO MA _ BIAS ▁/ ▁2 ▁) ▁/ ▁CH RO MA _ BIAS ▁; ▁results ▁++ ▁; ▁} ▁out ▁: ▁if ▁( ▁size ▁== ▁4 ▁) ▁av _ free ▁( ▁closest _ cb ▁) ▁; ▁av _ free ▁( ▁code book ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁apr _ status _ t ▁store _ headers ▁( ▁cache _ handle _ t ▁* ▁h ▁, ▁request _ rec ▁* ▁r ▁, ▁cache _ info ▁* ▁info ▁) ▁{ ▁cache _ soc ache _ dir _ conf ▁* ▁d conf ▁= ▁ap _ get _ module _ config ▁( ▁r ▁-> ▁per _ dir _ config ▁, ▁& ▁cache _ soc ache _ module ▁) ▁; ▁cache _ soc ache _ conf ▁* ▁conf ▁= ▁ap _ get _ module _ config ▁( ▁r ▁-> ▁server ▁-> ▁module _ config ▁, ▁& ▁cache _ soc ache _ module ▁) ▁; ▁apr _ size _ t ▁slider ▁; ▁apr _ status _ t ▁rv ▁; ▁cache _ object _ t ▁* ▁obj ▁= ▁h ▁-> ▁cache _ obj ▁; ▁cache _ soc ache _ object _ t ▁* ▁s obj ▁= ▁( ▁cache _ soc ache _ object _ t ▁* ▁) ▁obj ▁-> ▁vo bj ▁; ▁cache _ soc ache _ info _ t ▁* ▁soc ache _ info ▁; ▁memcpy ▁( ▁& ▁h ▁-> ▁cache _ obj ▁-> ▁info ▁, ▁info ▁, ▁sizeof ▁( ▁cache _ info ▁) ▁) ▁; ▁if ▁( ▁r ▁-> ▁headers _ out ▁) ▁{ ▁s obj ▁-> ▁headers _ out ▁= ▁ap _ cache _ cache able _ headers _ out ▁( ▁r ▁) ▁; ▁} ▁if ▁( ▁r ▁-> ▁headers _ in ▁) ▁{ ▁s obj ▁-> ▁headers _ in ▁= ▁ap _ cache _ cache able _ headers _ in ▁( ▁r ▁) ▁; ▁} ▁s obj ▁-> ▁expire ▁= ▁obj ▁-> ▁info ▁. ▁expire ▁> ▁r ▁-> ▁request _ time ▁+ ▁d conf ▁-> ▁maxt ime ▁? ▁r ▁-> ▁request _ time ▁+ ▁d conf ▁-> ▁maxt ime ▁: ▁obj ▁-> ▁info ▁. ▁expire ▁+ ▁d conf ▁-> ▁m int ime ▁; ▁apr _ pool _ create ▁( ▁& ▁s obj ▁-> ▁pool ▁, ▁r ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁buffer ▁= ▁apr _ palloc ▁( ▁s obj ▁-> ▁pool ▁, ▁d conf ▁-> ▁max ▁) ▁; ▁s obj ▁-> ▁buffer _ len ▁= ▁d conf ▁-> ▁max ▁; ▁soc ache _ info ▁= ▁( ▁cache _ soc ache _ info _ t ▁* ▁) ▁s obj ▁-> ▁buffer ▁; ▁if ▁( ▁s obj ▁-> ▁headers _ out ▁) ▁{ ▁const ▁char ▁* ▁v ary ▁; ▁v ary ▁= ▁apr _ table _ get ▁( ▁s obj ▁-> ▁headers _ out ▁, ▁" V ary " ▁) ▁; ▁if ▁( ▁v ary ▁) ▁{ ▁apr _ array _ header _ t ▁* ▁var ray ▁; ▁apr _ uint 32_ t ▁format ▁= ▁CACHE _ SO CACHE _ V ARY _ FORMAT _ VERSION ▁; ▁memcpy ▁( ▁s obj ▁-> ▁buffer ▁, ▁& ▁format ▁, ▁sizeof ▁( ▁format ▁) ▁) ▁; ▁slider ▁= ▁sizeof ▁( ▁format ▁) ▁; ▁memcpy ▁( ▁s obj ▁-> ▁buffer ▁+ ▁slider ▁, ▁& ▁obj ▁-> ▁info ▁. ▁expire ▁, ▁sizeof ▁( ▁obj ▁-> ▁info ▁. ▁expire ▁) ▁) ▁; ▁slider ▁+= ▁sizeof ▁( ▁obj ▁-> ▁info ▁. ▁expire ▁) ▁; ▁var ray ▁= ▁apr _ array _ make ▁( ▁r ▁-> ▁pool ▁, ▁6 ▁, ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁tokens _ to _ array ▁( ▁r ▁-> ▁pool ▁, ▁v ary ▁, ▁var ray ▁) ▁; ▁if ▁( ▁APR _ SUCCESS ▁!= ▁( ▁rv ▁= ▁store _ array ▁( ▁var ray ▁, ▁s obj ▁-> ▁buffer ▁, ▁s obj ▁-> ▁buffer _ len ▁, ▁& ▁slider ▁) ▁) ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ WARNING ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 70 ▁) ▁" buff ert oo small for V ary array , c aching abort ed :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁rv ▁; ▁} ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ lock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 71 ▁) ▁" could not acquire lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁status ▁; ▁} ▁} ▁rv ▁= ▁conf ▁-> ▁provider ▁-> ▁soc ache _ provider ▁-> ▁store ▁( ▁conf ▁-> ▁provider ▁-> ▁soc ache _ instance ▁, ▁r ▁-> ▁server ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁obj ▁-> ▁key ▁, ▁strlen ▁( ▁obj ▁-> ▁key ▁) ▁, ▁s obj ▁-> ▁expire ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁s obj ▁-> ▁buffer ▁, ▁( ▁unsigned ▁int ▁) ▁slider ▁, ▁s obj ▁-> ▁pool ▁) ▁; ▁if ▁( ▁soc ache _ mutex ▁) ▁{ ▁apr _ status _ t ▁status ▁= ▁apr _ global _ mutex _ unlock ▁( ▁soc ache _ mutex ▁) ▁; ▁if ▁( ▁status ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁status ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 72 ▁) ▁" could not release lock , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁} ▁} ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 73 ▁) ▁" V ary not writ t ent ocache , ign oring :% s " ▁, ▁obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁rv ▁; ▁} ▁obj ▁-> ▁key ▁= ▁s obj ▁-> ▁key ▁= ▁reg en _ key ▁( ▁r ▁-> ▁pool ▁, ▁s obj ▁-> ▁headers _ in ▁, ▁var ray ▁, ▁s obj ▁-> ▁name ▁) ▁; ▁} ▁} ▁soc ache _ info ▁-> ▁format ▁= ▁CACHE _ SO CACHE _ DISK _ FORMAT _ VERSION ▁; ▁soc ache _ info ▁-> ▁date ▁= ▁obj ▁-> ▁info ▁. ▁date ▁; ▁soc ache _ info ▁-> ▁expire ▁= ▁obj ▁-> ▁info ▁. ▁expire ▁; ▁soc ache _ info ▁-> ▁entity _ version ▁= ▁s obj ▁-> ▁soc ache _ info ▁. ▁entity _ version ▁++ ▁; ▁soc ache _ info ▁-> ▁request _ time ▁= ▁obj ▁-> ▁info ▁. ▁request _ time ▁; ▁soc ache _ info ▁-> ▁response _ time ▁= ▁obj ▁-> ▁info ▁. ▁response _ time ▁; ▁soc ache _ info ▁-> ▁status ▁= ▁obj ▁-> ▁info ▁. ▁status ▁; ▁if ▁( ▁r ▁-> ▁header _ only ▁&& ▁r ▁-> ▁status ▁!= ▁HTTP _ NOT _ MODIFIED ▁) ▁{ ▁soc ache _ info ▁-> ▁header _ only ▁= ▁1 ▁; ▁} ▁else ▁{ ▁soc ache _ info ▁-> ▁header _ only ▁= ▁s obj ▁-> ▁soc ache _ info ▁. ▁header _ only ▁; ▁} ▁soc ache _ info ▁-> ▁name _ len ▁= ▁strlen ▁( ▁s obj ▁-> ▁name ▁) ▁; ▁memcpy ▁( ▁& ▁soc ache _ info ▁-> ▁control ▁, ▁& ▁obj ▁-> ▁info ▁. ▁control ▁, ▁sizeof ▁( ▁cache _ control _ t ▁) ▁) ▁; ▁slider ▁= ▁sizeof ▁( ▁cache _ soc ache _ info _ t ▁) ▁; ▁if ▁( ▁slider ▁+ ▁soc ache _ info ▁-> ▁name _ len ▁>= ▁s obj ▁-> ▁buffer _ len ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ WARNING ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 74 ▁) ▁" cache buff ert oo small for name :% s " ▁, ▁s obj ▁-> ▁name ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁APR _ EG ENER AL ▁; ▁} ▁memcpy ▁( ▁s obj ▁-> ▁buffer ▁+ ▁slider ▁, ▁s obj ▁-> ▁name ▁, ▁soc ache _ info ▁-> ▁name _ len ▁) ▁; ▁slider ▁+= ▁soc ache _ info ▁-> ▁name _ len ▁; ▁if ▁( ▁s obj ▁-> ▁headers _ out ▁) ▁{ ▁if ▁( ▁APR _ SUCCESS ▁!= ▁store _ table ▁( ▁s obj ▁-> ▁headers _ out ▁, ▁s obj ▁-> ▁buffer ▁, ▁s obj ▁-> ▁buffer _ len ▁, ▁& ▁slider ▁) ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ WARNING ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 75 ▁) ▁" out - headers did n ' tf it in buffer :% s " ▁, ▁s obj ▁-> ▁name ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁APR _ EG ENER AL ▁; ▁} ▁} ▁if ▁( ▁s obj ▁-> ▁headers _ in ▁) ▁{ ▁if ▁( ▁APR _ SUCCESS ▁!= ▁store _ table ▁( ▁s obj ▁-> ▁headers _ in ▁, ▁s obj ▁-> ▁buffer ▁, ▁s obj ▁-> ▁buffer _ len ▁, ▁& ▁slider ▁) ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ WARNING ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 23 76 ▁) ▁" in - headers did n ' tf it in buffer % s " ▁, ▁s obj ▁-> ▁key ▁) ▁; ▁apr _ pool _ destroy ▁( ▁s obj ▁-> ▁pool ▁) ▁; ▁s obj ▁-> ▁pool ▁= ▁NULL ▁; ▁return ▁APR _ EG ENER AL ▁; ▁} ▁} ▁s obj ▁-> ▁body _ offset ▁= ▁slider ▁; ▁return ▁APR _ SUCCESS ▁; ▁}	0
▁int ▁cmd utils _ read _ file ▁( ▁const ▁char ▁* ▁filename ▁, ▁char ▁* ▁* ▁bufptr ▁, ▁size _ t ▁* ▁size ▁) ▁{ ▁int ▁ret ▁; ▁FILE ▁* ▁f ▁= ▁fopen ▁( ▁filename ▁, ▁" rb " ▁) ▁; ▁if ▁( ▁! ▁f ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cannot read file ' % s ' :% s \ n " ▁, ▁filename ▁, ▁strerror ▁( ▁errno ▁) ▁) ▁; ▁return ▁AVERROR ▁( ▁errno ▁) ▁; ▁} ▁fseek ▁( ▁f ▁, ▁0 ▁, ▁SEEK _ END ▁) ▁; ▁* ▁size ▁= ▁ftell ▁( ▁f ▁) ▁; ▁fseek ▁( ▁f ▁, ▁0 ▁, ▁SEEK _ SET ▁) ▁; ▁* ▁bufptr ▁= ▁av _ malloc ▁( ▁* ▁size ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁* ▁bufptr ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Could not allocate file buffer \ n " ▁) ▁; ▁fclose ▁( ▁f ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁ret ▁= ▁fread ▁( ▁* ▁bufptr ▁, ▁1 ▁, ▁* ▁size ▁, ▁f ▁) ▁; ▁if ▁( ▁ret ▁< ▁* ▁size ▁) ▁{ ▁av _ free ▁( ▁* ▁bufptr ▁) ▁; ▁if ▁( ▁ferror ▁( ▁f ▁) ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error wh il ere ading file ' % s ' :% s \ n " ▁, ▁filename ▁, ▁strerror ▁( ▁errno ▁) ▁) ▁; ▁ret ▁= ▁AVERROR ▁( ▁errno ▁) ▁; ▁} ▁else ▁ret ▁= ▁AVERROR _ EOF ▁; ▁} ▁else ▁{ ▁ret ▁= ▁0 ▁; ▁( ▁* ▁bufptr ▁) ▁[ ▁( ▁* ▁size ▁) ▁++ ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁fclose ▁( ▁f ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁void ▁av _ fast _ malloc ▁( ▁void ▁* ▁ptr ▁, ▁unsigned ▁int ▁* ▁size ▁, ▁size _ t ▁min _ size ▁) ▁{ ▁void ▁* ▁* ▁p ▁= ▁ptr ▁; ▁if ▁( ▁min _ size ▁< ▁* ▁size ▁) ▁return ▁; ▁min _ size ▁= ▁FF MAX ▁( ▁17 ▁* ▁min _ size ▁/ ▁16 ▁+ ▁32 ▁, ▁min _ size ▁) ▁; ▁av _ free ▁( ▁* ▁p ▁) ▁; ▁* ▁p ▁= ▁av _ malloc ▁( ▁min _ size ▁) ▁; ▁if ▁( ▁! ▁* ▁p ▁) ▁min _ size ▁= ▁0 ▁; ▁* ▁size ▁= ▁min _ size ▁; ▁}	1
▁static ▁int ▁decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁Four X Context ▁* ▁const ▁f ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁picture ▁= ▁data ▁; ▁AVFrame ▁* ▁p ▁, ▁temp ▁; ▁int ▁i ▁, ▁frame _4 cc ▁, ▁frame _ size ▁; ▁frame _4 cc ▁= ▁AV _ RL 32 ▁( ▁buf ▁) ▁; ▁if ▁( ▁buf _ size ▁!= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁4 ▁) ▁+ ▁8 ▁|| ▁buf _ size ▁< ▁20 ▁) ▁{ ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" size mismatch % d % d \ n " ▁, ▁buf _ size ▁, ▁AV _ RL 32 ▁( ▁buf ▁+ ▁4 ▁) ▁) ▁; ▁} ▁if ▁( ▁frame _4 cc ▁== ▁AV _ RL 32 ▁( ▁" c frm " ▁) ▁) ▁{ ▁int ▁free _ index ▁= ▁-1 ▁; ▁const ▁int ▁data _ size ▁= ▁buf _ size ▁- ▁20 ▁; ▁const ▁int ▁id ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁12 ▁) ▁; ▁const ▁int ▁whole _ size ▁= ▁AV _ RL 32 ▁( ▁buf ▁+ ▁16 ▁) ▁; ▁C FrameBuffer ▁* ▁c frm ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁C FRAME _ BUFFER _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁f ▁-> ▁c frm ▁[ ▁i ▁] ▁. ▁id ▁&& ▁f ▁-> ▁c frm ▁[ ▁i ▁] ▁. ▁id ▁< ▁avctx ▁-> ▁frame _ number ▁) ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" lost c frame % d \ n " ▁, ▁f ▁-> ▁c frm ▁[ ▁i ▁] ▁. ▁id ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁C FRAME _ BUFFER _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁f ▁-> ▁c frm ▁[ ▁i ▁] ▁. ▁id ▁== ▁id ▁) ▁break ▁; ▁if ▁( ▁f ▁-> ▁c frm ▁[ ▁i ▁] ▁. ▁size ▁== ▁0 ▁) ▁free _ index ▁= ▁i ▁; ▁} ▁if ▁( ▁i ▁>= ▁C FRAME _ BUFFER _ COUNT ▁) ▁{ ▁i ▁= ▁free _ index ▁; ▁f ▁-> ▁c frm ▁[ ▁i ▁] ▁. ▁id ▁= ▁id ▁; ▁} ▁c frm ▁= ▁& ▁f ▁-> ▁c frm ▁[ ▁i ▁] ▁; ▁c frm ▁-> ▁data ▁= ▁av _ fast _ realloc ▁( ▁c frm ▁-> ▁data ▁, ▁& ▁c frm ▁-> ▁allocated _ size ▁, ▁c frm ▁-> ▁size ▁+ ▁data _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁c frm ▁-> ▁data ▁) ▁{ ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" realloc f al ure " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁memcpy ▁( ▁c frm ▁-> ▁data ▁+ ▁c frm ▁-> ▁size ▁, ▁buf ▁+ ▁20 ▁, ▁data _ size ▁) ▁; ▁c frm ▁-> ▁size ▁+= ▁data _ size ▁; ▁if ▁( ▁c frm ▁-> ▁size ▁>= ▁whole _ size ▁) ▁{ ▁buf ▁= ▁c frm ▁-> ▁data ▁; ▁frame _ size ▁= ▁c frm ▁-> ▁size ▁; ▁if ▁( ▁id ▁!= ▁avctx ▁-> ▁frame _ number ▁) ▁{ ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" c frame id mismatch % d % d \ n " ▁, ▁id ▁, ▁avctx ▁-> ▁frame _ number ▁) ▁; ▁} ▁c frm ▁-> ▁size ▁= ▁c frm ▁-> ▁id ▁= ▁0 ▁; ▁frame _4 cc ▁= ▁AV _ RL 32 ▁( ▁" p frm " ▁) ▁; ▁} ▁else ▁return ▁buf _ size ▁; ▁} ▁else ▁{ ▁buf ▁= ▁buf ▁+ ▁12 ▁; ▁frame _ size ▁= ▁buf _ size ▁- ▁12 ▁; ▁} ▁temp ▁= ▁f ▁-> ▁current _ picture ▁; ▁f ▁-> ▁current _ picture ▁= ▁f ▁-> ▁last _ picture ▁; ▁f ▁-> ▁last _ picture ▁= ▁temp ▁; ▁p ▁= ▁& ▁f ▁-> ▁current _ picture ▁; ▁avctx ▁-> ▁coded _ frame ▁= ▁p ▁; ▁avctx ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ EMU _ EDGE ▁; ▁p ▁-> ▁reference ▁= ▁1 ▁; ▁if ▁( ▁avctx ▁-> ▁re get _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" re get _ buffer () failed \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁frame _4 cc ▁== ▁AV _ RL 32 ▁( ▁" if r 2" ▁) ▁) ▁{ ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁if ▁( ▁decode _ i 2_ frame ▁( ▁f ▁, ▁buf ▁- ▁4 ▁, ▁frame _ size ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁frame _4 cc ▁== ▁AV _ RL 32 ▁( ▁" if rm " ▁) ▁) ▁{ ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁if ▁( ▁decode _ i _ frame ▁( ▁f ▁, ▁buf ▁, ▁frame _ size ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁frame _4 cc ▁== ▁AV _ RL 32 ▁( ▁" p frm " ▁) ▁|| ▁frame _4 cc ▁== ▁AV _ RL 32 ▁( ▁" p fr 2" ▁) ▁) ▁{ ▁if ▁( ▁! ▁f ▁-> ▁last _ picture ▁. ▁data ▁[ ▁0 ▁] ▁) ▁{ ▁f ▁-> ▁last _ picture ▁. ▁reference ▁= ▁1 ▁; ▁if ▁( ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁& ▁f ▁-> ▁last _ picture ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁} ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ P ▁; ▁if ▁( ▁decode _ p _ frame ▁( ▁f ▁, ▁buf ▁, ▁frame _ size ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁frame _4 cc ▁== ▁AV _ RL 32 ▁( ▁" snd _" ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" ign or ings nd _ chunk length :% d \ n " ▁, ▁buf _ size ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" ign oring unknown chunk length :% d \ n " ▁, ▁buf _ size ▁) ▁; ▁} ▁p ▁-> ▁key _ frame ▁= ▁p ▁-> ▁pict _ type ▁== ▁AV _ PICTURE _ TYPE _ I ▁; ▁* ▁picture ▁= ▁* ▁p ▁; ▁* ▁data _ size ▁= ▁sizeof ▁( ▁AV Picture ▁) ▁; ▁e mm s _ c ▁( ▁) ▁; ▁return ▁buf _ size ▁; ▁}	1
▁static ▁int ▁query _ formats ▁( ▁AVFilter Graph ▁* ▁graph ▁, ▁AV Class ▁* ▁log _ ctx ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁ret ▁; ▁int ▁scal er _ count ▁= ▁0 ▁, ▁res ampler _ count ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁graph ▁-> ▁nb _ filters ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁graph ▁-> ▁filters ▁[ ▁i ▁] ▁-> ▁nb _ inputs ▁== ▁j ▁) ▁continue ▁; ▁if ▁( ▁graph ▁-> ▁filters ▁[ ▁i ▁] ▁-> ▁filter ▁-> ▁query _ formats ▁) ▁ret ▁= ▁filter _ query _ formats ▁( ▁graph ▁-> ▁filters ▁[ ▁i ▁] ▁) ▁; ▁else ▁ret ▁= ▁ff _ default _ query _ formats ▁( ▁graph ▁-> ▁filters ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁graph ▁-> ▁nb _ filters ▁; ▁i ▁++ ▁) ▁{ ▁AVFilter Context ▁* ▁filter ▁= ▁graph ▁-> ▁filters ▁[ ▁i ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁filter ▁-> ▁nb _ inputs ▁; ▁j ▁++ ▁) ▁{ ▁AVFilter Link ▁* ▁link ▁= ▁filter ▁-> ▁inputs ▁[ ▁j ▁] ▁; ▁int ▁convert _ needed ▁= ▁0 ▁; ▁if ▁( ▁! ▁link ▁) ▁continue ▁; ▁if ▁( ▁link ▁-> ▁in _ formats ▁!= ▁link ▁-> ▁out _ formats ▁&& ▁! ▁ff _ merge _ formats ▁( ▁link ▁-> ▁in _ formats ▁, ▁link ▁-> ▁out _ formats ▁, ▁link ▁-> ▁type ▁) ▁) ▁convert _ needed ▁= ▁1 ▁; ▁if ▁( ▁link ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁{ ▁if ▁( ▁link ▁-> ▁in _ channel _ layout s ▁!= ▁link ▁-> ▁out _ channel _ layout s ▁&& ▁! ▁ff _ merge _ channel _ layout s ▁( ▁link ▁-> ▁in _ channel _ layout s ▁, ▁link ▁-> ▁out _ channel _ layout s ▁) ▁) ▁convert _ needed ▁= ▁1 ▁; ▁if ▁( ▁link ▁-> ▁in _ sampler ates ▁!= ▁link ▁-> ▁out _ sampler ates ▁&& ▁! ▁ff _ merge _ sampler ates ▁( ▁link ▁-> ▁in _ sampler ates ▁, ▁link ▁-> ▁out _ sampler ates ▁) ▁) ▁convert _ needed ▁= ▁1 ▁; ▁} ▁if ▁( ▁convert _ needed ▁) ▁{ ▁AVFilter Context ▁* ▁convert ▁; ▁AVFilter ▁* ▁filter ▁; ▁AVFilter Link ▁* ▁inlink ▁, ▁* ▁out link ▁; ▁char ▁scale _ args ▁[ ▁256 ▁] ▁; ▁char ▁inst _ name ▁[ ▁30 ▁] ▁; ▁switch ▁( ▁link ▁-> ▁type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁if ▁( ▁! ▁( ▁filter ▁= ▁avfilter _ get _ by _ name ▁( ▁" scale " ▁) ▁) ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"' scale ' filter " ▁" not present , cannot con ver tp ixel formats .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁snprintf ▁( ▁inst _ name ▁, ▁sizeof ▁( ▁inst _ name ▁) ▁, ▁" auto - insert ed scaler % d " ▁, ▁scal er _ count ▁++ ▁) ▁; ▁if ▁( ▁graph ▁-> ▁scale _ s ws _ opts ▁) ▁snprintf ▁( ▁scale _ args ▁, ▁sizeof ▁( ▁scale _ args ▁) ▁, ▁"0 :0 :% s " ▁, ▁graph ▁-> ▁scale _ s ws _ opts ▁) ▁; ▁else ▁snprintf ▁( ▁scale _ args ▁, ▁sizeof ▁( ▁scale _ args ▁) ▁, ▁"0 : 0" ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁convert ▁, ▁filter ▁, ▁inst _ name ▁, ▁scale _ args ▁, ▁NULL ▁, ▁graph ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁if ▁( ▁! ▁( ▁filter ▁= ▁avfilter _ get _ by _ name ▁( ▁" are sample " ▁) ▁) ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"' are sample ' filter " ▁" not present , cannot convert aud iof orm ats .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁snprintf ▁( ▁inst _ name ▁, ▁sizeof ▁( ▁inst _ name ▁) ▁, ▁" auto - insert ed resampler % d " ▁, ▁res ampler _ count ▁++ ▁) ▁; ▁scale _ args ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁graph ▁-> ▁ares ample _ sw r _ opts ▁) ▁snprintf ▁( ▁scale _ args ▁, ▁sizeof ▁( ▁scale _ args ▁) ▁, ▁"% s " ▁, ▁graph ▁-> ▁ares ample _ sw r _ opts ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁avfilter _ graph _ create _ filter ▁( ▁& ▁convert ▁, ▁filter ▁, ▁inst _ name ▁, ▁graph ▁-> ▁ares ample _ sw r _ opts ▁, ▁NULL ▁, ▁graph ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁break ▁; ▁default ▁: ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁avfilter _ insert _ filter ▁( ▁link ▁, ▁convert ▁, ▁0 ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁filter _ query _ formats ▁( ▁convert ▁) ▁; ▁inlink ▁= ▁convert ▁-> ▁inputs ▁[ ▁0 ▁] ▁; ▁out link ▁= ▁convert ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁if ▁( ▁! ▁ff _ merge _ formats ▁( ▁inlink ▁-> ▁in _ formats ▁, ▁inlink ▁-> ▁out _ formats ▁, ▁inlink ▁-> ▁type ▁) ▁|| ▁! ▁ff _ merge _ formats ▁( ▁out link ▁-> ▁in _ formats ▁, ▁out link ▁-> ▁out _ formats ▁, ▁out link ▁-> ▁type ▁) ▁) ▁ret ▁|= ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁if ▁( ▁inlink ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁( ▁! ▁ff _ merge _ sampler ates ▁( ▁inlink ▁-> ▁in _ sampler ates ▁, ▁inlink ▁-> ▁out _ sampler ates ▁) ▁|| ▁! ▁ff _ merge _ channel _ layout s ▁( ▁inlink ▁-> ▁in _ channel _ layout s ▁, ▁inlink ▁-> ▁out _ channel _ layout s ▁) ▁) ▁) ▁ret ▁|= ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁if ▁( ▁out link ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁( ▁! ▁ff _ merge _ sampler ates ▁( ▁out link ▁-> ▁in _ sampler ates ▁, ▁out link ▁-> ▁out _ sampler ates ▁) ▁|| ▁! ▁ff _ merge _ channel _ layout s ▁( ▁out link ▁-> ▁in _ channel _ layout s ▁, ▁out link ▁-> ▁out _ channel _ layout s ▁) ▁) ▁) ▁ret ▁|= ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Imp oss ib let ocon vert b et we ent he format ss upported by the filter " ▁"'% s ' and the filter ' % s '\ n " ▁, ▁link ▁-> ▁src ▁-> ▁name ▁, ▁link ▁-> ▁dst ▁-> ▁name ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁ngx _ inline ▁uint 32_ t ▁ngx _ crc 32_ short ▁( ▁u _ char ▁* ▁p ▁, ▁size _ t ▁len ▁) ▁{ ▁u _ char ▁c ▁; ▁uint 32_ t ▁crc ▁; ▁crc ▁= ▁0 xffffffff ▁; ▁while ▁( ▁len ▁-- ▁) ▁{ ▁c ▁= ▁* ▁p ▁++ ▁; ▁crc ▁= ▁ngx _ crc 32_ table _ short ▁[ ▁( ▁crc ▁ ^ ▁( ▁c ▁& ▁0 xf ▁) ▁) ▁& ▁0 xf ▁] ▁ ^ ▁( ▁crc ▁>> ▁4 ▁) ▁; ▁crc ▁= ▁ngx _ crc 32_ table _ short ▁[ ▁( ▁crc ▁ ^ ▁( ▁c ▁>> ▁4 ▁) ▁) ▁& ▁0 xf ▁] ▁ ^ ▁( ▁crc ▁>> ▁4 ▁) ▁; ▁} ▁return ▁crc ▁ ^ ▁0 xffffffff ▁; ▁}	1
▁void ▁* ▁av _ fast _ realloc ▁( ▁void ▁* ▁ptr ▁, ▁unsigned ▁int ▁* ▁size ▁, ▁size _ t ▁min _ size ▁) ▁{ ▁if ▁( ▁min _ size ▁< ▁* ▁size ▁) ▁return ▁ptr ▁; ▁min _ size ▁= ▁FF MAX ▁( ▁17 ▁* ▁min _ size ▁/ ▁16 ▁+ ▁32 ▁, ▁min _ size ▁) ▁; ▁ptr ▁= ▁av _ realloc ▁( ▁ptr ▁, ▁min _ size ▁) ▁; ▁if ▁( ▁! ▁ptr ▁) ▁min _ size ▁= ▁0 ▁; ▁* ▁size ▁= ▁min _ size ▁; ▁return ▁ptr ▁; ▁}	1
▁unsigned ▁char ▁* ▁next _ protos _ parse ▁( ▁unsigned ▁short ▁* ▁outlen ▁, ▁const ▁char ▁* ▁in ▁) ▁{ ▁size _ t ▁len ▁; ▁unsigned ▁char ▁* ▁out ▁; ▁size _ t ▁i ▁, ▁start ▁= ▁0 ▁; ▁len ▁= ▁strlen ▁( ▁in ▁) ▁; ▁if ▁( ▁len ▁>= ▁65535 ▁) ▁return ▁NULL ▁; ▁out ▁= ▁app _ malloc ▁( ▁strlen ▁( ▁in ▁) ▁+ ▁1 ▁, ▁" NP N buffer " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁len ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁i ▁== ▁len ▁|| ▁in ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁i ▁- ▁start ▁> ▁255 ▁) ▁{ ▁OPENSSL _ free ▁( ▁out ▁) ▁; ▁return ▁NULL ▁; ▁} ▁out ▁[ ▁start ▁] ▁= ▁i ▁- ▁start ▁; ▁start ▁= ▁i ▁+ ▁1 ▁; ▁} ▁else ▁out ▁[ ▁i ▁+ ▁1 ▁] ▁= ▁in ▁[ ▁i ▁] ▁; ▁} ▁* ▁outlen ▁= ▁len ▁+ ▁1 ▁; ▁return ▁out ▁; ▁}	1
▁void ▁ngx _ http _ up stream _ free _ round _ ro bin _ peer ▁( ▁ngx _ peer _ connection _ t ▁* ▁pc ▁, ▁void ▁* ▁data ▁, ▁ngx _ uint _ t ▁state ▁) ▁{ ▁ngx _ http _ up stream _ rr _ peer _ data _ t ▁* ▁r rp ▁= ▁data ▁; ▁time _ t ▁now ▁; ▁ngx _ http _ up stream _ rr _ peer _ t ▁* ▁peer ▁; ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁pc ▁-> ▁log ▁, ▁0 ▁, ▁" fre err peer % ui % ui " ▁, ▁pc ▁-> ▁tries ▁, ▁state ▁) ▁; ▁peer ▁= ▁r rp ▁-> ▁current ▁; ▁if ▁( ▁r rp ▁-> ▁peers ▁-> ▁single ▁) ▁{ ▁peer ▁-> ▁con ns ▁-- ▁; ▁pc ▁-> ▁tries ▁= ▁0 ▁; ▁return ▁; ▁} ▁ngx _ http _ up stream _ rr _ pe ers _ r lock ▁( ▁r rp ▁-> ▁peers ▁) ▁; ▁ngx _ http _ up stream _ rr _ peer _ lock ▁( ▁r rp ▁-> ▁peers ▁, ▁peer ▁) ▁; ▁if ▁( ▁state ▁& ▁NGX _ PEER _ FAILED ▁) ▁{ ▁now ▁= ▁ngx _ time ▁( ▁) ▁; ▁peer ▁-> ▁fails ▁++ ▁; ▁peer ▁-> ▁accessed ▁= ▁now ▁; ▁peer ▁-> ▁checked ▁= ▁now ▁; ▁if ▁( ▁peer ▁-> ▁max _ fails ▁) ▁{ ▁peer ▁-> ▁effective _ weight ▁-= ▁peer ▁-> ▁weight ▁/ ▁peer ▁-> ▁max _ fails ▁; ▁} ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁pc ▁-> ▁log ▁, ▁0 ▁, ▁" fre err peer failed :% p % i " ▁, ▁peer ▁, ▁peer ▁-> ▁effective _ weight ▁) ▁; ▁if ▁( ▁peer ▁-> ▁effective _ weight ▁< ▁0 ▁) ▁{ ▁peer ▁-> ▁effective _ weight ▁= ▁0 ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁peer ▁-> ▁accessed ▁< ▁peer ▁-> ▁checked ▁) ▁{ ▁peer ▁-> ▁fails ▁= ▁0 ▁; ▁} ▁} ▁peer ▁-> ▁con ns ▁-- ▁; ▁ngx _ http _ up stream _ rr _ peer _ unlock ▁( ▁r rp ▁-> ▁peers ▁, ▁peer ▁) ▁; ▁ngx _ http _ up stream _ rr _ pe ers _ unlock ▁( ▁r rp ▁-> ▁peers ▁) ▁; ▁if ▁( ▁pc ▁-> ▁tries ▁) ▁{ ▁pc ▁-> ▁tries ▁-- ▁; ▁} ▁}	1
▁static ▁void ▁vc 1_ inv _ trans _4 x 8_ dc _ c ▁( ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁linesize ▁, ▁DCT ELEM ▁* ▁block ▁) ▁{ ▁int ▁i ▁; ▁int ▁dc ▁= ▁block ▁[ ▁0 ▁] ▁; ▁dc ▁= ▁( ▁17 ▁* ▁dc ▁+ ▁4 ▁) ▁>> ▁3 ▁; ▁dc ▁= ▁( ▁12 ▁* ▁dc ▁+ ▁64 ▁) ▁>> ▁7 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁{ ▁dest ▁[ ▁0 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dest ▁[ ▁0 ▁] ▁+ ▁dc ▁) ▁; ▁dest ▁[ ▁1 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dest ▁[ ▁1 ▁] ▁+ ▁dc ▁) ▁; ▁dest ▁[ ▁2 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dest ▁[ ▁2 ▁] ▁+ ▁dc ▁) ▁; ▁dest ▁[ ▁3 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dest ▁[ ▁3 ▁] ▁+ ▁dc ▁) ▁; ▁dest ▁+= ▁linesize ▁; ▁} ▁}	0
▁static ▁int ▁decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁AS V 1 Context ▁* ▁const ▁a ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁picture ▁= ▁data ▁; ▁AVFrame ▁* ▁const ▁p ▁= ▁& ▁a ▁-> ▁picture ▁; ▁int ▁mb _ x ▁, ▁mb _ y ▁; ▁if ▁( ▁p ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁; ▁p ▁-> ▁reference ▁= ▁0 ▁; ▁if ▁( ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁p ▁-> ▁key _ frame ▁= ▁1 ▁; ▁av _ fast _ malloc ▁( ▁& ▁a ▁-> ▁bitstream _ buffer ▁, ▁& ▁a ▁-> ▁bitstream _ buffer _ size ▁, ▁buf _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁a ▁-> ▁bitstream _ buffer ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memset ▁( ▁a ▁-> ▁bitstream _ buffer ▁+ ▁buf _ size ▁, ▁0 ▁, ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁avctx ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ AS V 1 ▁) ▁a ▁-> ▁dsp ▁. ▁bswap _ buf ▁( ▁( ▁uint 32_ t ▁* ▁) ▁a ▁-> ▁bitstream _ buffer ▁, ▁( ▁const ▁uint 32_ t ▁* ▁) ▁buf ▁, ▁buf _ size ▁/ ▁4 ▁) ▁; ▁else ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁buf _ size ▁; ▁i ▁++ ▁) ▁a ▁-> ▁bitstream _ buffer ▁[ ▁i ▁] ▁= ▁av _ reverse ▁[ ▁buf ▁[ ▁i ▁] ▁] ▁; ▁} ▁init _ get _ bits ▁( ▁& ▁a ▁-> ▁gb ▁, ▁a ▁-> ▁bitstream _ buffer ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁for ▁( ▁mb _ y ▁= ▁0 ▁; ▁mb _ y ▁< ▁a ▁-> ▁mb _ height 2 ▁; ▁mb _ y ▁++ ▁) ▁{ ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁a ▁-> ▁mb _ width 2 ▁; ▁mb _ x ▁++ ▁) ▁{ ▁if ▁( ▁decode _ mb ▁( ▁a ▁, ▁a ▁-> ▁block ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁idct _ put ▁( ▁a ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁} ▁} ▁if ▁( ▁a ▁-> ▁mb _ width 2 ▁!= ▁a ▁-> ▁mb _ width ▁) ▁{ ▁mb _ x ▁= ▁a ▁-> ▁mb _ width 2 ▁; ▁for ▁( ▁mb _ y ▁= ▁0 ▁; ▁mb _ y ▁< ▁a ▁-> ▁mb _ height 2 ▁; ▁mb _ y ▁++ ▁) ▁{ ▁if ▁( ▁decode _ mb ▁( ▁a ▁, ▁a ▁-> ▁block ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁idct _ put ▁( ▁a ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁} ▁} ▁if ▁( ▁a ▁-> ▁mb _ height 2 ▁!= ▁a ▁-> ▁mb _ height ▁) ▁{ ▁mb _ y ▁= ▁a ▁-> ▁mb _ height 2 ▁; ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁a ▁-> ▁mb _ width ▁; ▁mb _ x ▁++ ▁) ▁{ ▁if ▁( ▁decode _ mb ▁( ▁a ▁, ▁a ▁-> ▁block ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁idct _ put ▁( ▁a ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁} ▁} ▁* ▁picture ▁= ▁* ▁( ▁AVFrame ▁* ▁) ▁& ▁a ▁-> ▁picture ▁; ▁* ▁data _ size ▁= ▁sizeof ▁( ▁AV Picture ▁) ▁; ▁e mm s _ c ▁( ▁) ▁; ▁return ▁( ▁get _ bits _ count ▁( ▁& ▁a ▁-> ▁gb ▁) ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁4 ▁; ▁}	1
▁static ▁av _ always _ inline ▁int ▁vp 7 8_ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame ▁, ▁AVPacket ▁* ▁avpkt ▁, ▁int ▁is _ vp 7 ▁) ▁{ ▁VP 8 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁ret ▁, ▁i ▁, ▁referenced ▁, ▁num _ jobs ▁; ▁enum ▁AV Discard ▁skip _ thresh ▁; ▁VP 8 Frame ▁* ▁av _ uninit ▁( ▁cur frame ▁) ▁, ▁* ▁prev _ frame ▁; ▁if ▁( ▁is _ vp 7 ▁) ▁ret ▁= ▁vp 7_ decode _ frame _ header ▁( ▁s ▁, ▁avpkt ▁-> ▁data ▁, ▁avpkt ▁-> ▁size ▁) ▁; ▁else ▁ret ▁= ▁vp 8_ decode _ frame _ header ▁( ▁s ▁, ▁avpkt ▁-> ▁data ▁, ▁avpkt ▁-> ▁size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁err ▁; ▁prev _ frame ▁= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ CURRENT ▁] ▁; ▁referenced ▁= ▁s ▁-> ▁update _ last ▁|| ▁s ▁-> ▁update _ gold en ▁== ▁VP 5 6_ FRAME _ CURRENT ▁|| ▁s ▁-> ▁update _ alt ref ▁== ▁VP 5 6_ FRAME _ CURRENT ▁; ▁skip _ thresh ▁= ▁! ▁referenced ▁? ▁AV DISCARD _ NON REF ▁: ▁! ▁s ▁-> ▁keyframe ▁? ▁AV DISCARD _ NON KEY ▁: ▁AV DISCARD _ ALL ▁; ▁if ▁( ▁avctx ▁-> ▁skip _ frame ▁>= ▁skip _ thresh ▁) ▁{ ▁s ▁-> ▁invisible ▁= ▁1 ▁; ▁memcpy ▁( ▁& ▁s ▁-> ▁next _ frame p ▁[ ▁0 ▁] ▁, ▁& ▁s ▁-> ▁frame p ▁[ ▁0 ▁] ▁, ▁sizeof ▁( ▁s ▁-> ▁frame p ▁[ ▁0 ▁] ▁) ▁* ▁4 ▁) ▁; ▁goto ▁skip _ decode ▁; ▁} ▁s ▁-> ▁de block _ filter ▁= ▁s ▁-> ▁filter ▁. ▁level ▁&& ▁avctx ▁-> ▁skip _ loop _ filter ▁< ▁skip _ thresh ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁. ▁tf ▁. ▁f ▁-> ▁data ▁[ ▁0 ▁] ▁&& ▁& ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁!= ▁prev _ frame ▁&& ▁& ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁!= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ PREVIOUS ▁] ▁&& ▁& ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁!= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN ▁] ▁&& ▁& ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁!= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN 2 ▁] ▁) ▁vp 8_ release _ frame ▁( ▁s ▁, ▁& ▁s ▁-> ▁frames ▁[ ▁i ▁] ▁) ▁; ▁cur frame ▁= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ CURRENT ▁] ▁= ▁vp 8_ find _ free _ buffer ▁( ▁s ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁keyframe ▁&& ▁( ▁! ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ PREVIOUS ▁] ▁|| ▁! ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN ▁] ▁|| ▁! ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN 2 ▁] ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Disc arding inter frame without ap ri ork ey frame !\ n " ▁) ▁; ▁ret ▁= ▁AVERROR _ INVALIDDATA ▁; ▁goto ▁err ▁; ▁} ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁key _ frame ▁= ▁s ▁-> ▁keyframe ▁; ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁pict _ type ▁= ▁s ▁-> ▁keyframe ▁? ▁AV _ PICTURE _ TYPE _ I ▁: ▁AV _ PICTURE _ TYPE _ P ▁; ▁if ▁( ▁( ▁ret ▁= ▁vp 8_ alloc _ frame ▁( ▁s ▁, ▁cur frame ▁, ▁referenced ▁) ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁update _ alt ref ▁!= ▁VP 5 6_ FRAME _ NONE ▁) ▁s ▁-> ▁next _ frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN 2 ▁] ▁= ▁s ▁-> ▁frame p ▁[ ▁s ▁-> ▁update _ alt ref ▁] ▁; ▁else ▁s ▁-> ▁next _ frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN 2 ▁] ▁= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN 2 ▁] ▁; ▁if ▁( ▁s ▁-> ▁update _ gold en ▁!= ▁VP 5 6_ FRAME _ NONE ▁) ▁s ▁-> ▁next _ frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN ▁] ▁= ▁s ▁-> ▁frame p ▁[ ▁s ▁-> ▁update _ gold en ▁] ▁; ▁else ▁s ▁-> ▁next _ frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN ▁] ▁= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ G OL DEN ▁] ▁; ▁if ▁( ▁s ▁-> ▁update _ last ▁) ▁s ▁-> ▁next _ frame p ▁[ ▁VP 5 6_ FRAME _ PREVIOUS ▁] ▁= ▁cur frame ▁; ▁else ▁s ▁-> ▁next _ frame p ▁[ ▁VP 5 6_ FRAME _ PREVIOUS ▁] ▁= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ PREVIOUS ▁] ▁; ▁s ▁-> ▁next _ frame p ▁[ ▁VP 5 6_ FRAME _ CURRENT ▁] ▁= ▁cur frame ▁; ▁ff _ thread _ finish _ setup ▁( ▁avctx ▁) ▁; ▁s ▁-> ▁linesize ▁= ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁s ▁-> ▁uv lines ize ▁= ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁linesize ▁[ ▁1 ▁] ▁; ▁memset ▁( ▁s ▁-> ▁top _ nn z ▁, ▁0 ▁, ▁s ▁-> ▁mb _ width ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁top _ nn z ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁mb _ layout ▁) ▁memset ▁( ▁s ▁-> ▁macro blocks ▁+ ▁s ▁-> ▁mb _ height ▁* ▁2 ▁- ▁1 ▁, ▁0 ▁, ▁( ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁macro blocks ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁mb _ layout ▁&& ▁s ▁-> ▁keyframe ▁) ▁memset ▁( ▁s ▁-> ▁in tra 4 x 4_ pred _ mode _ top ▁, ▁DC _ PRED ▁, ▁s ▁-> ▁mb _ width ▁* ▁4 ▁) ▁; ▁memset ▁( ▁s ▁-> ▁ref _ count ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁ref _ count ▁) ▁) ▁; ▁if ▁( ▁s ▁-> ▁mb _ layout ▁== ▁1 ▁) ▁{ ▁if ▁( ▁prev _ frame ▁&& ▁s ▁-> ▁segment ation ▁. ▁enabled ▁&& ▁! ▁s ▁-> ▁segment ation ▁. ▁update _ map ▁) ▁ff _ thread _ await _ progress ▁( ▁& ▁prev _ frame ▁-> ▁tf ▁, ▁1 ▁, ▁0 ▁) ▁; ▁if ▁( ▁is _ vp 7 ▁) ▁vp 7_ decode _ mv _ mb _ modes ▁( ▁avctx ▁, ▁cur frame ▁, ▁prev _ frame ▁) ▁; ▁else ▁vp 8_ decode _ mv _ mb _ modes ▁( ▁avctx ▁, ▁cur frame ▁, ▁prev _ frame ▁) ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁active _ thread _ type ▁== ▁FF _ THREAD _ FRAME ▁) ▁num _ jobs ▁= ▁1 ▁; ▁else ▁num _ jobs ▁= ▁FF MIN ▁( ▁s ▁-> ▁num _ coeff _ partitions ▁, ▁avctx ▁-> ▁thread _ count ▁) ▁; ▁s ▁-> ▁num _ jobs ▁= ▁num _ jobs ▁; ▁s ▁-> ▁cur frame ▁= ▁cur frame ▁; ▁s ▁-> ▁prev _ frame ▁= ▁prev _ frame ▁; ▁s ▁-> ▁mv _ min ▁. ▁y ▁= ▁- ▁M ARGIN ▁; ▁s ▁-> ▁mv _ max ▁. ▁y ▁= ▁( ▁( ▁s ▁-> ▁mb _ height ▁- ▁1 ▁) ▁<< ▁6 ▁) ▁+ ▁M ARGIN ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ THREADS ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁thread _ data ▁[ ▁i ▁] ▁. ▁thread _ mb _ pos ▁= ▁0 ▁; ▁s ▁-> ▁thread _ data ▁[ ▁i ▁] ▁. ▁wait _ mb _ pos ▁= ▁INT _ MAX ▁; ▁} ▁if ▁( ▁is _ vp 7 ▁) ▁avctx ▁-> ▁execute 2 ▁( ▁avctx ▁, ▁vp 7_ decode _ mb _ row _ slic ed ▁, ▁s ▁-> ▁thread _ data ▁, ▁NULL ▁, ▁num _ jobs ▁) ▁; ▁else ▁avctx ▁-> ▁execute 2 ▁( ▁avctx ▁, ▁vp 8_ decode _ mb _ row _ slic ed ▁, ▁s ▁-> ▁thread _ data ▁, ▁NULL ▁, ▁num _ jobs ▁) ▁; ▁ff _ thread _ report _ progress ▁( ▁& ▁cur frame ▁-> ▁tf ▁, ▁INT _ MAX ▁, ▁0 ▁) ▁; ▁memcpy ▁( ▁& ▁s ▁-> ▁frame p ▁[ ▁0 ▁] ▁, ▁& ▁s ▁-> ▁next _ frame p ▁[ ▁0 ▁] ▁, ▁sizeof ▁( ▁s ▁-> ▁frame p ▁[ ▁0 ▁] ▁) ▁* ▁4 ▁) ▁; ▁skip _ decode ▁: ▁if ▁( ▁! ▁s ▁-> ▁update _ prob abilities ▁) ▁s ▁-> ▁prob ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁prob ▁[ ▁1 ▁] ▁; ▁if ▁( ▁! ▁s ▁-> ▁invisible ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁av _ frame _ ref ▁( ▁data ▁, ▁cur frame ▁-> ▁tf ▁. ▁f ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁got _ frame ▁= ▁1 ▁; ▁} ▁return ▁avpkt ▁-> ▁size ▁; ▁err ▁: ▁memcpy ▁( ▁& ▁s ▁-> ▁next _ frame p ▁[ ▁0 ▁] ▁, ▁& ▁s ▁-> ▁frame p ▁[ ▁0 ▁] ▁, ▁sizeof ▁( ▁s ▁-> ▁frame p ▁[ ▁0 ▁] ▁) ▁* ▁4 ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁char ▁* ▁make _ re vocation _ str ▁( ▁int ▁rev _ type ▁, ▁char ▁* ▁rev _ arg ▁) ▁{ ▁char ▁* ▁reason ▁= ▁NULL ▁, ▁* ▁other ▁= ▁NULL ▁, ▁* ▁str ▁; ▁ASN 1_ OBJECT ▁* ▁o tmp ▁; ▁ASN 1_ UTC TIME ▁* ▁rev tm ▁= ▁NULL ▁; ▁int ▁i ▁; ▁switch ▁( ▁rev _ type ▁) ▁{ ▁case ▁REV _ NONE ▁: ▁break ▁; ▁case ▁REV _ CRL _ REASON ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁8 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁strcasecmp ▁( ▁rev _ arg ▁, ▁crl _ reasons ▁[ ▁i ▁] ▁) ▁) ▁{ ▁reason ▁= ▁crl _ reasons ▁[ ▁i ▁] ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁reason ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Unknown CRL reason % s \ n " ▁, ▁rev _ arg ▁) ▁; ▁return ▁NULL ▁; ▁} ▁break ▁; ▁case ▁REV _ HOLD ▁: ▁o tmp ▁= ▁OBJ _ txt 2 obj ▁( ▁rev _ arg ▁, ▁0 ▁) ▁; ▁ASN 1_ OBJECT _ free ▁( ▁o tmp ▁) ▁; ▁if ▁( ▁o tmp ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Invalid object identifier % s \ n " ▁, ▁rev _ arg ▁) ▁; ▁return ▁NULL ▁; ▁} ▁reason ▁= ▁" hold Instruction " ▁; ▁other ▁= ▁rev _ arg ▁; ▁break ▁; ▁case ▁REV _ KEY _ COMP RO MI SE ▁: ▁case ▁REV _ CA _ COMP RO MI SE ▁: ▁if ▁( ▁! ▁ASN 1_ GENERAL IZED TIME _ set _ string ▁( ▁NULL ▁, ▁rev _ arg ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Invalid time format % s . Need YY YY MM DD HH MM SS Z \ n " ▁, ▁rev _ arg ▁) ▁; ▁return ▁NULL ▁; ▁} ▁other ▁= ▁rev _ arg ▁; ▁if ▁( ▁rev _ type ▁== ▁REV _ KEY _ COMP RO MI SE ▁) ▁reason ▁= ▁" key Time " ▁; ▁else ▁reason ▁= ▁" CA key Time " ▁; ▁break ▁; ▁} ▁rev tm ▁= ▁X 509_ gmt ime _ adj ▁( ▁NULL ▁, ▁0 ▁) ▁; ▁i ▁= ▁rev tm ▁-> ▁length ▁+ ▁1 ▁; ▁if ▁( ▁reason ▁) ▁i ▁+= ▁strlen ▁( ▁reason ▁) ▁+ ▁1 ▁; ▁if ▁( ▁other ▁) ▁i ▁+= ▁strlen ▁( ▁other ▁) ▁+ ▁1 ▁; ▁str ▁= ▁OPENSSL _ malloc ▁( ▁i ▁) ▁; ▁if ▁( ▁! ▁str ▁) ▁return ▁NULL ▁; ▁strcpy ▁( ▁str ▁, ▁( ▁char ▁* ▁) ▁rev tm ▁-> ▁data ▁) ▁; ▁if ▁( ▁reason ▁) ▁{ ▁strcat ▁( ▁str ▁, ▁"," ▁) ▁; ▁strcat ▁( ▁str ▁, ▁reason ▁) ▁; ▁} ▁if ▁( ▁other ▁) ▁{ ▁strcat ▁( ▁str ▁, ▁"," ▁) ▁; ▁strcat ▁( ▁str ▁, ▁other ▁) ▁; ▁} ▁ASN 1_ UTC TIME _ free ▁( ▁rev tm ▁) ▁; ▁return ▁str ▁; ▁}	1
▁static ▁int ▁check _ image _ pointers ▁( ▁uint 8_ t ▁* ▁data ▁[ ▁4 ▁] ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁const ▁int ▁lines izes ▁[ ▁4 ▁] ▁) ▁{ ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁pix _ fmt ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁plane ▁= ▁desc ▁-> ▁comp ▁[ ▁i ▁] ▁. ▁plane ▁; ▁if ▁( ▁! ▁data ▁[ ▁plane ▁] ▁|| ▁! ▁lines izes ▁[ ▁plane ▁] ▁) ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁h ls _ window ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁last ▁) ▁{ ▁H LS Context ▁* ▁h ls ▁= ▁s ▁-> ▁priv _ data ▁; ▁List Entry ▁* ▁en ▁; ▁int 64_ t ▁target _ duration ▁= ▁0 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁AVIO Context ▁* ▁out ▁= ▁NULL ▁; ▁char ▁temp _ filename ▁[ ▁1024 ▁] ▁; ▁int 64_ t ▁sequence ▁= ▁FF MAX ▁( ▁h ls ▁-> ▁start _ sequence ▁, ▁h ls ▁-> ▁sequence ▁- ▁h ls ▁-> ▁size ▁) ▁; ▁snprintf ▁( ▁temp _ filename ▁, ▁sizeof ▁( ▁temp _ filename ▁) ▁, ▁"% s . tmp " ▁, ▁s ▁-> ▁filename ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁s ▁-> ▁io _ open ▁( ▁s ▁, ▁& ▁out ▁, ▁temp _ filename ▁, ▁AVIO _ FLAG _ WRITE ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁for ▁( ▁en ▁= ▁h ls ▁-> ▁list ▁; ▁en ▁; ▁en ▁= ▁en ▁-> ▁next ▁) ▁{ ▁if ▁( ▁target _ duration ▁< ▁en ▁-> ▁duration ▁) ▁target _ duration ▁= ▁en ▁-> ▁duration ▁; ▁} ▁avio _ printf ▁( ▁out ▁, ▁"# EXT M 3 U \ n " ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"# EXT - X - VERSION :% d \ n " ▁, ▁h ls ▁-> ▁version ▁) ▁; ▁if ▁( ▁h ls ▁-> ▁allow cache ▁== ▁0 ▁|| ▁h ls ▁-> ▁allow cache ▁== ▁1 ▁) ▁{ ▁avio _ printf ▁( ▁out ▁, ▁"# EXT - X - ALLOW - CACHE :% s \ n " ▁, ▁h ls ▁-> ▁allow cache ▁== ▁0 ▁? ▁" NO " ▁: ▁" YES " ▁) ▁; ▁} ▁avio _ printf ▁( ▁out ▁, ▁"# EXT - X - TARGET DURATION :% " ▁PRId 64 ▁"\ n " ▁, ▁av _ re scale _ rnd ▁( ▁target _ duration ▁, ▁1 ▁, ▁AV _ TIME _ BASE ▁, ▁AV _ ROUND _ UP ▁) ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"# EXT - X - MEDIA - SEQUENCE :% " ▁PRId 64 ▁"\ n " ▁, ▁sequence ▁) ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" EXT - X - MEDIA - SEQUENCE :% " ▁PRId 64 ▁"\ n " ▁, ▁sequence ▁) ▁; ▁for ▁( ▁en ▁= ▁h ls ▁-> ▁list ▁; ▁en ▁; ▁en ▁= ▁en ▁-> ▁next ▁) ▁{ ▁if ▁( ▁h ls ▁-> ▁version ▁> ▁2 ▁) ▁avio _ printf ▁( ▁out ▁, ▁"# EXT INF :% f \ n " ▁, ▁( ▁double ▁) ▁en ▁-> ▁duration ▁/ ▁AV _ TIME _ BASE ▁) ▁; ▁else ▁avio _ printf ▁( ▁out ▁, ▁"# EXT INF :% " ▁PRId 64 ▁", \ n " ▁, ▁av _ re scale ▁( ▁en ▁-> ▁duration ▁, ▁1 ▁, ▁AV _ TIME _ BASE ▁) ▁) ▁; ▁if ▁( ▁h ls ▁-> ▁base url ▁) ▁avio _ printf ▁( ▁out ▁, ▁"% s " ▁, ▁h ls ▁-> ▁base url ▁) ▁; ▁avio _ printf ▁( ▁out ▁, ▁"% s \ n " ▁, ▁en ▁-> ▁name ▁) ▁; ▁} ▁if ▁( ▁last ▁) ▁avio _ printf ▁( ▁out ▁, ▁"# EXT - X - EN DL IST \ n " ▁) ▁; ▁fail ▁: ▁ff _ format _ io _ close ▁( ▁s ▁, ▁& ▁out ▁) ▁; ▁if ▁( ▁ret ▁>= ▁0 ▁) ▁ff _ rename ▁( ▁temp _ filename ▁, ▁s ▁-> ▁filename ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁inline ▁void ▁mc _ part _ weight ed ▁( ▁H 264 Context ▁* ▁h ▁, ▁int ▁n ▁, ▁int ▁square ▁, ▁int ▁chroma _ height ▁, ▁int ▁delta ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁x _ offset ▁, ▁int ▁y _ offset ▁, ▁q pel _ mc _ func ▁* ▁q pix _ put ▁, ▁h 264_ chroma _ mc _ func ▁chroma _ put ▁, ▁h 264_ weight _ func ▁lum a _ weight _ op ▁, ▁h 264_ weight _ func ▁chroma _ weight _ op ▁, ▁h 264_ bi weight _ func ▁lum a _ weight _ avg ▁, ▁h 264_ bi weight _ func ▁chroma _ weight _ avg ▁, ▁int ▁list 0 ▁, ▁int ▁list 1 ▁) ▁{ ▁Mpeg Enc Context ▁* ▁const ▁s ▁= ▁& ▁h ▁-> ▁s ▁; ▁dest _ y ▁+= ▁2 ▁* ▁x _ offset ▁+ ▁2 ▁* ▁y _ offset ▁* ▁h ▁-> ▁mb _ lines ize ▁; ▁dest _ cb ▁+= ▁x _ offset ▁+ ▁y _ offset ▁* ▁h ▁-> ▁mb _ uv lines ize ▁; ▁dest _ cr ▁+= ▁x _ offset ▁+ ▁y _ offset ▁* ▁h ▁-> ▁mb _ uv lines ize ▁; ▁x _ offset ▁+= ▁8 ▁* ▁s ▁-> ▁mb _ x ▁; ▁y _ offset ▁+= ▁8 ▁* ▁( ▁s ▁-> ▁mb _ y ▁>> ▁MB _ FIELD ▁) ▁; ▁if ▁( ▁list 0 ▁&& ▁list 1 ▁) ▁{ ▁uint 8_ t ▁* ▁tmp _ cb ▁= ▁s ▁-> ▁ob mc _ scratch pad ▁; ▁uint 8_ t ▁* ▁tmp _ cr ▁= ▁s ▁-> ▁ob mc _ scratch pad ▁+ ▁8 ▁; ▁uint 8_ t ▁* ▁tmp _ y ▁= ▁s ▁-> ▁ob mc _ scratch pad ▁+ ▁8 ▁* ▁h ▁-> ▁mb _ uv lines ize ▁; ▁int ▁ref n 0 ▁= ▁h ▁-> ▁ref _ cache ▁[ ▁0 ▁] ▁[ ▁scan 8 ▁[ ▁n ▁] ▁] ▁; ▁int ▁ref n 1 ▁= ▁h ▁-> ▁ref _ cache ▁[ ▁1 ▁] ▁[ ▁scan 8 ▁[ ▁n ▁] ▁] ▁; ▁mc _ dir _ part ▁( ▁h ▁, ▁& ▁h ▁-> ▁ref _ list ▁[ ▁0 ▁] ▁[ ▁ref n 0 ▁] ▁, ▁n ▁, ▁square ▁, ▁chroma _ height ▁, ▁delta ▁, ▁0 ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁x _ offset ▁, ▁y _ offset ▁, ▁q pix _ put ▁, ▁chroma _ put ▁) ▁; ▁mc _ dir _ part ▁( ▁h ▁, ▁& ▁h ▁-> ▁ref _ list ▁[ ▁1 ▁] ▁[ ▁ref n 1 ▁] ▁, ▁n ▁, ▁square ▁, ▁chroma _ height ▁, ▁delta ▁, ▁1 ▁, ▁tmp _ y ▁, ▁tmp _ cb ▁, ▁tmp _ cr ▁, ▁x _ offset ▁, ▁y _ offset ▁, ▁q pix _ put ▁, ▁chroma _ put ▁) ▁; ▁if ▁( ▁h ▁-> ▁use _ weight ▁== ▁2 ▁) ▁{ ▁int ▁weight 0 ▁= ▁h ▁-> ▁implicit _ weight ▁[ ▁ref n 0 ▁] ▁[ ▁ref n 1 ▁] ▁; ▁int ▁weight 1 ▁= ▁64 ▁- ▁weight 0 ▁; ▁lum a _ weight _ avg ▁( ▁dest _ y ▁, ▁tmp _ y ▁, ▁h ▁-> ▁mb _ lines ize ▁, ▁5 ▁, ▁weight 0 ▁, ▁weight 1 ▁, ▁0 ▁) ▁; ▁chroma _ weight _ avg ▁( ▁dest _ cb ▁, ▁tmp _ cb ▁, ▁h ▁-> ▁mb _ uv lines ize ▁, ▁5 ▁, ▁weight 0 ▁, ▁weight 1 ▁, ▁0 ▁) ▁; ▁chroma _ weight _ avg ▁( ▁dest _ cr ▁, ▁tmp _ cr ▁, ▁h ▁-> ▁mb _ uv lines ize ▁, ▁5 ▁, ▁weight 0 ▁, ▁weight 1 ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁lum a _ weight _ avg ▁( ▁dest _ y ▁, ▁tmp _ y ▁, ▁h ▁-> ▁mb _ lines ize ▁, ▁h ▁-> ▁lum a _ log 2_ weight _ den om ▁, ▁h ▁-> ▁lum a _ weight ▁[ ▁0 ▁] ▁[ ▁ref n 0 ▁] ▁, ▁h ▁-> ▁lum a _ weight ▁[ ▁1 ▁] ▁[ ▁ref n 1 ▁] ▁, ▁h ▁-> ▁lum a _ offset ▁[ ▁0 ▁] ▁[ ▁ref n 0 ▁] ▁+ ▁h ▁-> ▁lum a _ offset ▁[ ▁1 ▁] ▁[ ▁ref n 1 ▁] ▁) ▁; ▁chroma _ weight _ avg ▁( ▁dest _ cb ▁, ▁tmp _ cb ▁, ▁h ▁-> ▁mb _ uv lines ize ▁, ▁h ▁-> ▁chroma _ log 2_ weight _ den om ▁, ▁h ▁-> ▁chroma _ weight ▁[ ▁0 ▁] ▁[ ▁ref n 0 ▁] ▁[ ▁0 ▁] ▁, ▁h ▁-> ▁chroma _ weight ▁[ ▁1 ▁] ▁[ ▁ref n 1 ▁] ▁[ ▁0 ▁] ▁, ▁h ▁-> ▁chroma _ offset ▁[ ▁0 ▁] ▁[ ▁ref n 0 ▁] ▁[ ▁0 ▁] ▁+ ▁h ▁-> ▁chroma _ offset ▁[ ▁1 ▁] ▁[ ▁ref n 1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁chroma _ weight _ avg ▁( ▁dest _ cr ▁, ▁tmp _ cr ▁, ▁h ▁-> ▁mb _ uv lines ize ▁, ▁h ▁-> ▁chroma _ log 2_ weight _ den om ▁, ▁h ▁-> ▁chroma _ weight ▁[ ▁0 ▁] ▁[ ▁ref n 0 ▁] ▁[ ▁1 ▁] ▁, ▁h ▁-> ▁chroma _ weight ▁[ ▁1 ▁] ▁[ ▁ref n 1 ▁] ▁[ ▁1 ▁] ▁, ▁h ▁-> ▁chroma _ offset ▁[ ▁0 ▁] ▁[ ▁ref n 0 ▁] ▁[ ▁1 ▁] ▁+ ▁h ▁-> ▁chroma _ offset ▁[ ▁1 ▁] ▁[ ▁ref n 1 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁} ▁} ▁else ▁{ ▁int ▁list ▁= ▁list 1 ▁? ▁1 ▁: ▁0 ▁; ▁int ▁ref n ▁= ▁h ▁-> ▁ref _ cache ▁[ ▁list ▁] ▁[ ▁scan 8 ▁[ ▁n ▁] ▁] ▁; ▁Picture ▁* ▁ref ▁= ▁& ▁h ▁-> ▁ref _ list ▁[ ▁list ▁] ▁[ ▁ref n ▁] ▁; ▁mc _ dir _ part ▁( ▁h ▁, ▁ref ▁, ▁n ▁, ▁square ▁, ▁chroma _ height ▁, ▁delta ▁, ▁list ▁, ▁dest _ y ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁x _ offset ▁, ▁y _ offset ▁, ▁q pix _ put ▁, ▁chroma _ put ▁) ▁; ▁lum a _ weight _ op ▁( ▁dest _ y ▁, ▁h ▁-> ▁mb _ lines ize ▁, ▁h ▁-> ▁lum a _ log 2_ weight _ den om ▁, ▁h ▁-> ▁lum a _ weight ▁[ ▁list ▁] ▁[ ▁ref n ▁] ▁, ▁h ▁-> ▁lum a _ offset ▁[ ▁list ▁] ▁[ ▁ref n ▁] ▁) ▁; ▁if ▁( ▁h ▁-> ▁use _ weight _ chroma ▁) ▁{ ▁chroma _ weight _ op ▁( ▁dest _ cb ▁, ▁h ▁-> ▁mb _ uv lines ize ▁, ▁h ▁-> ▁chroma _ log 2_ weight _ den om ▁, ▁h ▁-> ▁chroma _ weight ▁[ ▁list ▁] ▁[ ▁ref n ▁] ▁[ ▁0 ▁] ▁, ▁h ▁-> ▁chroma _ offset ▁[ ▁list ▁] ▁[ ▁ref n ▁] ▁[ ▁0 ▁] ▁) ▁; ▁chroma _ weight _ op ▁( ▁dest _ cr ▁, ▁h ▁-> ▁mb _ uv lines ize ▁, ▁h ▁-> ▁chroma _ log 2_ weight _ den om ▁, ▁h ▁-> ▁chroma _ weight ▁[ ▁list ▁] ▁[ ▁ref n ▁] ▁[ ▁1 ▁] ▁, ▁h ▁-> ▁chroma _ offset ▁[ ▁list ▁] ▁[ ▁ref n ▁] ▁[ ▁1 ▁] ▁) ▁; ▁} ▁} ▁}	1
▁static ▁int ▁sam i _ par agraph _ to _ ass ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁char ▁* ▁src ▁) ▁{ ▁SAM I Context ▁* ▁sam i ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁ret ▁= ▁0 ▁; ▁char ▁* ▁tag ▁= ▁NULL ▁; ▁char ▁* ▁dup src ▁= ▁av _ strdup ▁( ▁src ▁) ▁; ▁char ▁* ▁p ▁= ▁dup src ▁; ▁AV B Print ▁* ▁dst _ content ▁= ▁& ▁sam i ▁-> ▁encoded _ content ▁; ▁AV B Print ▁* ▁dst _ source ▁= ▁& ▁sam i ▁-> ▁encoded _ source ▁; ▁if ▁( ▁! ▁dup src ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁av _ b print _ clear ▁( ▁& ▁sam i ▁-> ▁encoded _ content ▁) ▁; ▁av _ b print _ clear ▁( ▁& ▁sam i ▁-> ▁content ▁) ▁; ▁av _ b print _ clear ▁( ▁& ▁sam i ▁-> ▁encoded _ source ▁) ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁char ▁* ▁save ptr ▁= ▁NULL ▁; ▁int ▁prev _ chr _ is _ space ▁= ▁0 ▁; ▁AV B Print ▁* ▁dst ▁= ▁& ▁sam i ▁-> ▁content ▁; ▁p ▁= ▁av _ stri str ▁( ▁p ▁, ▁"< P " ▁) ▁; ▁if ▁( ▁! ▁p ▁) ▁break ▁; ▁if ▁( ▁p ▁[ ▁2 ▁] ▁!= ▁' ▁' ▁&& ▁! ▁av _ isspace ▁( ▁p ▁[ ▁2 ▁] ▁) ▁) ▁{ ▁p ▁++ ▁; ▁continue ▁; ▁} ▁if ▁( ▁dst ▁-> ▁len ▁) ▁av _ b printf ▁( ▁dst ▁, ▁"\\ N " ▁) ▁; ▁tag ▁= ▁av _ strto k ▁( ▁p ▁, ▁">" ▁, ▁& ▁save ptr ▁) ▁; ▁if ▁( ▁! ▁tag ▁|| ▁! ▁save ptr ▁) ▁break ▁; ▁p ▁= ▁save ptr ▁; ▁if ▁( ▁av _ stri str ▁( ▁tag ▁, ▁" ID = Source " ▁) ▁|| ▁av _ stri str ▁( ▁tag ▁, ▁" ID =\" Source \"" ▁) ▁) ▁{ ▁dst ▁= ▁& ▁sam i ▁-> ▁source ▁; ▁av _ b print _ clear ▁( ▁dst ▁) ▁; ▁} ▁while ▁( ▁av _ isspace ▁( ▁* ▁p ▁) ▁) ▁p ▁++ ▁; ▁if ▁( ▁! ▁strncmp ▁( ▁p ▁, ▁"& nbsp ;" ▁, ▁6 ▁) ▁) ▁{ ▁ret ▁= ▁-1 ▁; ▁goto ▁end ▁; ▁} ▁while ▁( ▁* ▁p ▁) ▁{ ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁! ▁av _ strncasecmp ▁( ▁p ▁, ▁"< P " ▁, ▁2 ▁) ▁&& ▁( ▁p ▁[ ▁2 ▁] ▁== ▁' ▁' ▁|| ▁av _ isspace ▁( ▁p ▁[ ▁2 ▁] ▁) ▁) ▁) ▁break ▁; ▁} ▁if ▁( ▁! ▁av _ strncasecmp ▁( ▁p ▁, ▁"< BR " ▁, ▁3 ▁) ▁) ▁{ ▁av _ b printf ▁( ▁dst ▁, ▁"\\ N " ▁) ▁; ▁p ▁++ ▁; ▁while ▁( ▁* ▁p ▁&& ▁* ▁p ▁!= ▁' ▁' ▁) ▁p ▁++ ▁; ▁if ▁( ▁! ▁* ▁p ▁) ▁break ▁; ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁) ▁p ▁++ ▁; ▁continue ▁; ▁} ▁if ▁( ▁! ▁av _ isspace ▁( ▁* ▁p ▁) ▁) ▁av _ b print _ chars ▁( ▁dst ▁, ▁* ▁p ▁, ▁1 ▁) ▁; ▁else ▁if ▁( ▁! ▁prev _ chr _ is _ space ▁) ▁av _ b print _ chars ▁( ▁dst ▁, ▁' ▁' ▁, ▁1 ▁) ▁; ▁prev _ chr _ is _ space ▁= ▁av _ isspace ▁( ▁* ▁p ▁) ▁; ▁p ▁++ ▁; ▁} ▁} ▁av _ b print _ clear ▁( ▁& ▁sam i ▁-> ▁full ▁) ▁; ▁if ▁( ▁sam i ▁-> ▁source ▁. ▁len ▁) ▁{ ▁ret ▁= ▁ff _ html mark up _ to _ ass ▁( ▁avctx ▁, ▁dst _ source ▁, ▁sam i ▁-> ▁source ▁. ▁str ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁end ▁; ▁av _ b printf ▁( ▁& ▁sam i ▁-> ▁full ▁, ▁"{ \\ i 1} % s { \\ i 0 } \\ N " ▁, ▁sam i ▁-> ▁encoded _ source ▁. ▁str ▁) ▁; ▁} ▁ret ▁= ▁ff _ html mark up _ to _ ass ▁( ▁avctx ▁, ▁dst _ content ▁, ▁sam i ▁-> ▁content ▁. ▁str ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁end ▁; ▁av _ b printf ▁( ▁& ▁sam i ▁-> ▁full ▁, ▁"% s " ▁, ▁sam i ▁-> ▁encoded _ content ▁. ▁str ▁) ▁; ▁end ▁: ▁av _ free ▁( ▁dup src ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁BN _ us ub ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁) ▁{ ▁int ▁max ▁, ▁min ▁, ▁dif ▁; ▁register ▁BN _ ULONG ▁t 1 ▁, ▁t 2 ▁, ▁* ▁ap ▁, ▁* ▁bp ▁, ▁* ▁rp ▁; ▁int ▁i ▁, ▁carry ▁; ▁# if ▁defined ▁( ▁IR IX _ CC _ BUG ▁) ▁&& ▁! ▁defined ▁( ▁L INT ▁) ▁int ▁dummy ▁; ▁# endif ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁max ▁= ▁a ▁-> ▁top ▁; ▁min ▁= ▁b ▁-> ▁top ▁; ▁dif ▁= ▁max ▁- ▁min ▁; ▁if ▁( ▁dif ▁< ▁0 ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ US UB ▁, ▁BN _ R _ ARG 2_ LT _ ARG 3 ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁bn _ w expand ▁( ▁r ▁, ▁max ▁) ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁ap ▁= ▁a ▁-> ▁d ▁; ▁bp ▁= ▁b ▁-> ▁d ▁; ▁rp ▁= ▁r ▁-> ▁d ▁; ▁# if ▁1 ▁carry ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁min ▁; ▁i ▁!= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁t 1 ▁= ▁* ▁( ▁ap ▁++ ▁) ▁; ▁t 2 ▁= ▁* ▁( ▁bp ▁++ ▁) ▁; ▁if ▁( ▁carry ▁) ▁{ ▁carry ▁= ▁( ▁t 1 ▁<= ▁t 2 ▁) ▁; ▁t 1 ▁= ▁( ▁t 1 ▁- ▁t 2 ▁- ▁1 ▁) ▁& ▁BN _ MASK 2 ▁; ▁} ▁else ▁{ ▁carry ▁= ▁( ▁t 1 ▁< ▁t 2 ▁) ▁; ▁t 1 ▁= ▁( ▁t 1 ▁- ▁t 2 ▁) ▁& ▁BN _ MASK 2 ▁; ▁} ▁# if ▁defined ▁( ▁IR IX _ CC _ BUG ▁) ▁&& ▁! ▁defined ▁( ▁L INT ▁) ▁dummy ▁= ▁t 1 ▁; ▁# endif ▁* ▁( ▁rp ▁++ ▁) ▁= ▁t 1 ▁& ▁BN _ MASK 2 ▁; ▁} ▁# else ▁carry ▁= ▁bn _ sub _ words ▁( ▁rp ▁, ▁ap ▁, ▁bp ▁, ▁min ▁) ▁; ▁ap ▁+= ▁min ▁; ▁bp ▁+= ▁min ▁; ▁rp ▁+= ▁min ▁; ▁# endif ▁if ▁( ▁carry ▁) ▁{ ▁if ▁( ▁! ▁dif ▁) ▁return ▁0 ▁; ▁while ▁( ▁dif ▁) ▁{ ▁dif ▁-- ▁; ▁t 1 ▁= ▁* ▁( ▁ap ▁++ ▁) ▁; ▁t 2 ▁= ▁( ▁t 1 ▁- ▁1 ▁) ▁& ▁BN _ MASK 2 ▁; ▁* ▁( ▁rp ▁++ ▁) ▁= ▁t 2 ▁; ▁if ▁( ▁t 1 ▁) ▁break ▁; ▁} ▁} ▁# if ▁0 ▁memcpy ▁( ▁rp ▁, ▁ap ▁, ▁sizeof ▁( ▁* ▁rp ▁) ▁* ▁( ▁max ▁- ▁i ▁) ▁) ▁; ▁# else ▁if ▁( ▁rp ▁!= ▁ap ▁) ▁{ ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁! ▁dif ▁-- ▁) ▁break ▁; ▁rp ▁[ ▁0 ▁] ▁= ▁ap ▁[ ▁0 ▁] ▁; ▁if ▁( ▁! ▁dif ▁-- ▁) ▁break ▁; ▁rp ▁[ ▁1 ▁] ▁= ▁ap ▁[ ▁1 ▁] ▁; ▁if ▁( ▁! ▁dif ▁-- ▁) ▁break ▁; ▁rp ▁[ ▁2 ▁] ▁= ▁ap ▁[ ▁2 ▁] ▁; ▁if ▁( ▁! ▁dif ▁-- ▁) ▁break ▁; ▁rp ▁[ ▁3 ▁] ▁= ▁ap ▁[ ▁3 ▁] ▁; ▁rp ▁+= ▁4 ▁; ▁ap ▁+= ▁4 ▁; ▁} ▁} ▁# endif ▁r ▁-> ▁top ▁= ▁max ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁bn _ correct _ top ▁( ▁r ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁void ▁encode _ window _ band s _ info ▁( ▁AAC Enc Context ▁* ▁s ▁, ▁Single Channel Element ▁* ▁sce ▁, ▁int ▁win ▁, ▁int ▁group _ len ▁, ▁const ▁float ▁lambda ▁) ▁{ ▁Band Coding Path ▁path ▁[ ▁120 ▁] ▁[ ▁CB _ TO T ▁] ▁; ▁int ▁w ▁, ▁sw b ▁, ▁cb ▁, ▁start ▁, ▁size ▁; ▁int ▁i ▁, ▁j ▁; ▁const ▁int ▁max _ s fb ▁= ▁sce ▁-> ▁ics ▁. ▁max _ s fb ▁; ▁const ▁int ▁run _ bits ▁= ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁1 ▁? ▁5 ▁: ▁3 ▁; ▁const ▁int ▁run _ esc ▁= ▁( ▁1 ▁<< ▁run _ bits ▁) ▁- ▁1 ▁; ▁int ▁idx ▁, ▁ppos ▁, ▁count ▁; ▁int ▁stack run ▁[ ▁120 ▁] ▁, ▁stack cb ▁[ ▁120 ▁] ▁, ▁stack _ len ▁; ▁float ▁next _ min rd ▁= ▁INFINITY ▁; ▁int ▁next _ min cb ▁= ▁0 ▁; ▁abs _ pow 34_ v ▁( ▁s ▁-> ▁sco efs ▁, ▁sce ▁-> ▁coeffs ▁, ▁1024 ▁) ▁; ▁start ▁= ▁win ▁* ▁128 ▁; ▁for ▁( ▁cb ▁= ▁0 ▁; ▁cb ▁< ▁CB _ TO T ▁; ▁cb ▁++ ▁) ▁{ ▁path ▁[ ▁0 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁0.0 f ▁; ▁path ▁[ ▁0 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁-1 ▁; ▁path ▁[ ▁0 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁0 ▁; ▁} ▁for ▁( ▁sw b ▁= ▁0 ▁; ▁sw b ▁< ▁max _ s fb ▁; ▁sw b ▁++ ▁) ▁{ ▁size ▁= ▁sce ▁-> ▁ics ▁. ▁sw b _ sizes ▁[ ▁sw b ▁] ▁; ▁if ▁( ▁sce ▁-> ▁zero es ▁[ ▁win ▁* ▁16 ▁+ ▁sw b ▁] ▁) ▁{ ▁for ▁( ▁cb ▁= ▁0 ▁; ▁cb ▁< ▁CB _ TO T ▁; ▁cb ▁++ ▁) ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁cb ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁run ▁+ ▁1 ▁; ▁} ▁} ▁else ▁{ ▁float ▁min rd ▁= ▁next _ min rd ▁; ▁int ▁min cb ▁= ▁next _ min cb ▁; ▁next _ min rd ▁= ▁INFINITY ▁; ▁next _ min cb ▁= ▁0 ▁; ▁for ▁( ▁cb ▁= ▁0 ▁; ▁cb ▁< ▁CB _ TO T ▁; ▁cb ▁++ ▁) ▁{ ▁float ▁cost _ st ay _ here ▁, ▁cost _ get _ here ▁; ▁float ▁rd ▁= ▁0.0 f ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁group _ len ▁; ▁w ▁++ ▁) ▁{ ▁F FP sy Band ▁* ▁band ▁= ▁& ▁s ▁-> ▁ps y ▁. ▁ch ▁[ ▁s ▁-> ▁cur _ channel ▁] ▁. ▁ps y _ band s ▁[ ▁( ▁win ▁+ ▁w ▁) ▁* ▁16 ▁+ ▁sw b ▁] ▁; ▁rd ▁+= ▁quant ize _ band _ cost ▁( ▁s ▁, ▁sce ▁-> ▁coeffs ▁+ ▁start ▁+ ▁w ▁* ▁128 ▁, ▁s ▁-> ▁sco efs ▁+ ▁start ▁+ ▁w ▁* ▁128 ▁, ▁size ▁, ▁sce ▁-> ▁sf _ idx ▁[ ▁( ▁win ▁+ ▁w ▁) ▁* ▁16 ▁+ ▁sw b ▁] ▁, ▁aac _ cb _ out _ map ▁[ ▁cb ▁] ▁, ▁lambda ▁/ ▁band ▁-> ▁threshold ▁, ▁INFINITY ▁, ▁NULL ▁) ▁; ▁} ▁cost _ st ay _ here ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁+ ▁rd ▁; ▁cost _ get _ here ▁= ▁min rd ▁+ ▁rd ▁+ ▁run _ bits ▁+ ▁4 ▁; ▁if ▁( ▁run _ value _ bits ▁[ ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁8 ▁] ▁[ ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁run ▁] ▁!= ▁run _ value _ bits ▁[ ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁8 ▁] ▁[ ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁run ▁+ ▁1 ▁] ▁) ▁cost _ st ay _ here ▁+= ▁run _ bits ▁; ▁if ▁( ▁cost _ get _ here ▁< ▁cost _ st ay _ here ▁) ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁min cb ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁cost _ get _ here ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁1 ▁; ▁} ▁else ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁cb ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁cost _ st ay _ here ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁run ▁+ ▁1 ▁; ▁} ▁if ▁( ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁< ▁next _ min rd ▁) ▁{ ▁next _ min rd ▁= ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁; ▁next _ min cb ▁= ▁cb ▁; ▁} ▁} ▁} ▁start ▁+= ▁sce ▁-> ▁ics ▁. ▁sw b _ sizes ▁[ ▁sw b ▁] ▁; ▁} ▁stack _ len ▁= ▁0 ▁; ▁idx ▁= ▁0 ▁; ▁for ▁( ▁cb ▁= ▁1 ▁; ▁cb ▁< ▁CB _ TO T ▁; ▁cb ▁++ ▁) ▁if ▁( ▁path ▁[ ▁max _ s fb ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁< ▁path ▁[ ▁max _ s fb ▁] ▁[ ▁idx ▁] ▁. ▁cost ▁) ▁idx ▁= ▁cb ▁; ▁ppos ▁= ▁max _ s fb ▁; ▁while ▁( ▁ppos ▁> ▁0 ▁) ▁{ ▁cb ▁= ▁idx ▁; ▁stack run ▁[ ▁stack _ len ▁] ▁= ▁path ▁[ ▁ppos ▁] ▁[ ▁cb ▁] ▁. ▁run ▁; ▁stack cb ▁[ ▁stack _ len ▁] ▁= ▁cb ▁; ▁idx ▁= ▁path ▁[ ▁ppos ▁- ▁path ▁[ ▁ppos ▁] ▁[ ▁cb ▁] ▁. ▁run ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁; ▁ppos ▁-= ▁path ▁[ ▁ppos ▁] ▁[ ▁cb ▁] ▁. ▁run ▁; ▁stack _ len ▁++ ▁; ▁} ▁start ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁stack _ len ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁cb ▁= ▁aac _ cb _ out _ map ▁[ ▁stack cb ▁[ ▁i ▁] ▁] ▁; ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁4 ▁, ▁cb ▁) ▁; ▁count ▁= ▁stack run ▁[ ▁i ▁] ▁; ▁memset ▁( ▁sce ▁-> ▁zero es ▁+ ▁win ▁* ▁16 ▁+ ▁start ▁, ▁! ▁cb ▁, ▁count ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁count ▁; ▁j ▁++ ▁) ▁{ ▁sce ▁-> ▁band _ type ▁[ ▁win ▁* ▁16 ▁+ ▁start ▁] ▁= ▁cb ▁; ▁start ▁++ ▁; ▁} ▁while ▁( ▁count ▁>= ▁run _ esc ▁) ▁{ ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁run _ bits ▁, ▁run _ esc ▁) ▁; ▁count ▁-= ▁run _ esc ▁; ▁} ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁run _ bits ▁, ▁count ▁) ▁; ▁} ▁}	0
▁static ▁int ▁build _ filter ▁( ▁Res ample Context ▁* ▁c ▁, ▁void ▁* ▁filter ▁, ▁double ▁factor ▁, ▁int ▁tap _ count ▁, ▁int ▁alloc ▁, ▁int ▁phase _ count ▁, ▁int ▁scale ▁, ▁int ▁filter _ type ▁, ▁int ▁ka iser _ beta ▁) ▁{ ▁int ▁ph ▁, ▁i ▁; ▁double ▁x ▁, ▁y ▁, ▁w ▁; ▁double ▁* ▁tab ▁= ▁av _ malloc _ array ▁( ▁tap _ count ▁, ▁sizeof ▁( ▁* ▁tab ▁) ▁) ▁; ▁const ▁int ▁center ▁= ▁( ▁tap _ count ▁- ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁! ▁tab ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁factor ▁> ▁1.0 ▁) ▁factor ▁= ▁1.0 ▁; ▁for ▁( ▁ph ▁= ▁0 ▁; ▁ph ▁< ▁phase _ count ▁; ▁ph ▁++ ▁) ▁{ ▁double ▁norm ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tap _ count ▁; ▁i ▁++ ▁) ▁{ ▁x ▁= ▁M _ PI ▁* ▁( ▁( ▁double ▁) ▁( ▁i ▁- ▁center ▁) ▁- ▁( ▁double ▁) ▁ph ▁/ ▁phase _ count ▁) ▁* ▁factor ▁; ▁if ▁( ▁x ▁== ▁0 ▁) ▁y ▁= ▁1.0 ▁; ▁else ▁y ▁= ▁sin ▁( ▁x ▁) ▁/ ▁x ▁; ▁switch ▁( ▁filter _ type ▁) ▁{ ▁case ▁S WR _ FILTER _ TYPE _ C UB IC ▁: ▁{ ▁const ▁float ▁d ▁= ▁-0.5 ▁; ▁x ▁= ▁fabs ▁( ▁( ▁( ▁double ▁) ▁( ▁i ▁- ▁center ▁) ▁- ▁( ▁double ▁) ▁ph ▁/ ▁phase _ count ▁) ▁* ▁factor ▁) ▁; ▁if ▁( ▁x ▁< ▁1.0 ▁) ▁y ▁= ▁1 ▁- ▁3 ▁* ▁x ▁* ▁x ▁+ ▁2 ▁* ▁x ▁* ▁x ▁* ▁x ▁+ ▁d ▁* ▁( ▁- ▁x ▁* ▁x ▁+ ▁x ▁* ▁x ▁* ▁x ▁) ▁; ▁else ▁y ▁= ▁d ▁* ▁( ▁-4 ▁+ ▁8 ▁* ▁x ▁- ▁5 ▁* ▁x ▁* ▁x ▁+ ▁x ▁* ▁x ▁* ▁x ▁) ▁; ▁break ▁; ▁} ▁case ▁S WR _ FILTER _ TYPE _ BLACK MAN _ N UT T ALL ▁: ▁w ▁= ▁2.0 ▁* ▁x ▁/ ▁( ▁factor ▁* ▁tap _ count ▁) ▁+ ▁M _ PI ▁; ▁y ▁*= ▁0. 36 35 819 ▁- ▁0.4 89 1 775 ▁* ▁cos ▁( ▁w ▁) ▁+ ▁0. 13 65 995 ▁* ▁cos ▁( ▁2 ▁* ▁w ▁) ▁- ▁0.0 10 64 11 ▁* ▁cos ▁( ▁3 ▁* ▁w ▁) ▁; ▁break ▁; ▁case ▁S WR _ FILTER _ TYPE _ KA IS ER ▁: ▁w ▁= ▁2.0 ▁* ▁x ▁/ ▁( ▁factor ▁* ▁tap _ count ▁* ▁M _ PI ▁) ▁; ▁y ▁*= ▁b essel ▁( ▁ka iser _ beta ▁* ▁sqrt ▁( ▁FF MAX ▁( ▁1 ▁- ▁w ▁* ▁w ▁, ▁0 ▁) ▁) ▁) ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁} ▁tab ▁[ ▁i ▁] ▁= ▁y ▁; ▁norm ▁+= ▁y ▁; ▁} ▁switch ▁( ▁c ▁-> ▁format ▁) ▁{ ▁case ▁AV _ SAMPLE _ FMT _ S 16 P ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tap _ count ▁; ▁i ▁++ ▁) ▁( ▁( ▁int 16_ t ▁* ▁) ▁filter ▁) ▁[ ▁ph ▁* ▁alloc ▁+ ▁i ▁] ▁= ▁av _ clip ▁( ▁l rintf ▁( ▁tab ▁[ ▁i ▁] ▁* ▁scale ▁/ ▁norm ▁) ▁, ▁INT 16_ MIN ▁, ▁INT 16_ MAX ▁) ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ S 32 P ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tap _ count ▁; ▁i ▁++ ▁) ▁( ▁( ▁int 32_ t ▁* ▁) ▁filter ▁) ▁[ ▁ph ▁* ▁alloc ▁+ ▁i ▁] ▁= ▁av _ clip l _ int 32 ▁( ▁ll rint ▁( ▁tab ▁[ ▁i ▁] ▁* ▁scale ▁/ ▁norm ▁) ▁) ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ FL TP ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tap _ count ▁; ▁i ▁++ ▁) ▁( ▁( ▁float ▁* ▁) ▁filter ▁) ▁[ ▁ph ▁* ▁alloc ▁+ ▁i ▁] ▁= ▁tab ▁[ ▁i ▁] ▁* ▁scale ▁/ ▁norm ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ DB LP ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tap _ count ▁; ▁i ▁++ ▁) ▁( ▁( ▁double ▁* ▁) ▁filter ▁) ▁[ ▁ph ▁* ▁alloc ▁+ ▁i ▁] ▁= ▁tab ▁[ ▁i ▁] ▁* ▁scale ▁/ ▁norm ▁; ▁break ▁; ▁} ▁} ▁# if ▁0 ▁{ ▁# define ▁LEN ▁1024 ▁int ▁j ▁, ▁k ▁; ▁double ▁sine ▁[ ▁LEN ▁+ ▁tap _ count ▁] ▁; ▁double ▁filtered ▁[ ▁LEN ▁] ▁; ▁double ▁max ff ▁= ▁-2 ▁, ▁min ff ▁= ▁2 ▁, ▁max sf ▁= ▁-2 ▁, ▁min sf ▁= ▁2 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁LEN ▁; ▁i ▁++ ▁) ▁{ ▁double ▁ss ▁= ▁0 ▁, ▁sf ▁= ▁0 ▁, ▁ff ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁LEN ▁+ ▁tap _ count ▁; ▁j ▁++ ▁) ▁sine ▁[ ▁j ▁] ▁= ▁cos ▁( ▁i ▁* ▁j ▁* ▁M _ PI ▁/ ▁LEN ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁LEN ▁; ▁j ▁++ ▁) ▁{ ▁double ▁sum ▁= ▁0 ▁; ▁ph ▁= ▁0 ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁tap _ count ▁; ▁k ▁++ ▁) ▁sum ▁+= ▁filter ▁[ ▁ph ▁* ▁tap _ count ▁+ ▁k ▁] ▁* ▁sine ▁[ ▁k ▁+ ▁j ▁] ▁; ▁filtered ▁[ ▁j ▁] ▁= ▁sum ▁/ ▁( ▁1 ▁<< ▁FILTER _ SHIFT ▁) ▁; ▁ss ▁+= ▁sine ▁[ ▁j ▁+ ▁center ▁] ▁* ▁sine ▁[ ▁j ▁+ ▁center ▁] ▁; ▁ff ▁+= ▁filtered ▁[ ▁j ▁] ▁* ▁filtered ▁[ ▁j ▁] ▁; ▁sf ▁+= ▁sine ▁[ ▁j ▁+ ▁center ▁] ▁* ▁filtered ▁[ ▁j ▁] ▁; ▁} ▁ss ▁= ▁sqrt ▁( ▁2 ▁* ▁ss ▁/ ▁LEN ▁) ▁; ▁ff ▁= ▁sqrt ▁( ▁2 ▁* ▁ff ▁/ ▁LEN ▁) ▁; ▁sf ▁= ▁2 ▁* ▁sf ▁/ ▁LEN ▁; ▁max ff ▁= ▁FF MAX ▁( ▁max ff ▁, ▁ff ▁) ▁; ▁min ff ▁= ▁FF MIN ▁( ▁min ff ▁, ▁ff ▁) ▁; ▁max sf ▁= ▁FF MAX ▁( ▁max sf ▁, ▁sf ▁) ▁; ▁min sf ▁= ▁FF MIN ▁( ▁min sf ▁, ▁sf ▁) ▁; ▁if ▁( ▁i ▁% ▁11 ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" i :% 4 dss :% fff :% 13. 6 e -% 13. 6 es f :% 13. 6 e -% 13. 6 e \ n " ▁, ▁i ▁, ▁ss ▁, ▁max ff ▁, ▁min ff ▁, ▁max sf ▁, ▁min sf ▁) ▁; ▁min ff ▁= ▁min sf ▁= ▁2 ▁; ▁max ff ▁= ▁max sf ▁= ▁-2 ▁; ▁} ▁} ▁} ▁# endif ▁av _ free ▁( ▁tab ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁char ▁* ▁make _ config _ name ▁( ▁) ▁{ ▁const ▁char ▁* ▁t ▁; ▁size _ t ▁len ▁; ▁char ▁* ▁p ▁; ▁if ▁( ▁( ▁t ▁= ▁getenv ▁( ▁" OPENSSL _ CONF " ▁) ▁) ▁!= ▁NULL ▁) ▁return ▁BUF _ strdup ▁( ▁t ▁) ▁; ▁t ▁= ▁X 509_ get _ default _ cert _ area ▁( ▁) ▁; ▁len ▁= ▁strlen ▁( ▁t ▁) ▁+ ▁1 ▁+ ▁strlen ▁( ▁OPENSSL _ CONF ▁) ▁+ ▁1 ▁; ▁p ▁= ▁app _ malloc ▁( ▁len ▁, ▁" config filename buffer " ▁) ▁; ▁strcpy ▁( ▁p ▁, ▁t ▁) ▁; ▁# ifndef ▁OPENSSL _ SYS _ VMS ▁strcat ▁( ▁p ▁, ▁"/" ▁) ▁; ▁# endif ▁strcat ▁( ▁p ▁, ▁OPENSSL _ CONF ▁) ▁; ▁return ▁p ▁; ▁}	1
▁void ▁ff _ ms pel _ motion ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁int ▁motion _ x ▁, ▁int ▁motion _ y ▁, ▁int ▁h ▁) ▁{ ▁W mv 2 Context ▁* ▁const ▁w ▁= ▁( ▁W mv 2 Context ▁* ▁) ▁s ▁; ▁uint 8_ t ▁* ▁ptr ▁; ▁int ▁d xy ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁, ▁v _ edge _ pos ▁; ▁ptrdiff _ t ▁offset ▁, ▁linesize ▁, ▁uv lines ize ▁; ▁int ▁emu ▁= ▁0 ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁d xy ▁= ▁2 ▁* ▁d xy ▁+ ▁w ▁-> ▁h shift ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁1 ▁) ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁16 ▁+ ▁( ▁motion _ y ▁>> ▁1 ▁) ▁; ▁v _ edge _ pos ▁= ▁s ▁-> ▁v _ edge _ pos ▁; ▁src _ x ▁= ▁av _ clip ▁( ▁src _ x ▁, ▁-16 ▁, ▁s ▁-> ▁width ▁) ▁; ▁src _ y ▁= ▁av _ clip ▁( ▁src _ y ▁, ▁-16 ▁, ▁s ▁-> ▁height ▁) ▁; ▁if ▁( ▁src _ x ▁<= ▁-16 ▁|| ▁src _ x ▁>= ▁s ▁-> ▁width ▁) ▁d xy ▁&= ▁ ~ ▁3 ▁; ▁if ▁( ▁src _ y ▁<= ▁-16 ▁|| ▁src _ y ▁>= ▁s ▁-> ▁height ▁) ▁d xy ▁&= ▁ ~ ▁4 ▁; ▁linesize ▁= ▁s ▁-> ▁linesize ▁; ▁uv lines ize ▁= ▁s ▁-> ▁uv lines ize ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁( ▁src _ y ▁* ▁linesize ▁) ▁+ ▁src _ x ▁; ▁if ▁( ▁src _ x ▁< ▁1 ▁|| ▁src _ y ▁< ▁1 ▁|| ▁src _ x ▁+ ▁17 ▁>= ▁s ▁-> ▁h _ edge _ pos ▁|| ▁src _ y ▁+ ▁h ▁+ ▁1 ▁>= ▁v _ edge _ pos ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁- ▁1 ▁- ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁linesize ▁, ▁19 ▁, ▁19 ▁, ▁src _ x ▁- ▁1 ▁, ▁src _ y ▁- ▁1 ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁+ ▁1 ▁+ ▁s ▁-> ▁linesize ▁; ▁emu ▁= ▁1 ▁; ▁} ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr ▁, ▁linesize ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁, ▁ptr ▁+ ▁8 ▁, ▁linesize ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁* ▁linesize ▁, ▁ptr ▁+ ▁8 ▁* ▁linesize ▁, ▁linesize ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁put _ ms pel _ pixels _ tab ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁+ ▁8 ▁* ▁linesize ▁, ▁ptr ▁+ ▁8 ▁+ ▁8 ▁* ▁linesize ▁, ▁linesize ▁) ▁; ▁if ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁return ▁; ▁if ▁( ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 263 ▁) ▁{ ▁d xy ▁= ▁0 ▁; ▁if ▁( ▁( ▁motion _ x ▁& ▁3 ▁) ▁!= ▁0 ▁) ▁d xy ▁|= ▁1 ▁; ▁if ▁( ▁( ▁motion _ y ▁& ▁3 ▁) ▁!= ▁0 ▁) ▁d xy ▁|= ▁2 ▁; ▁mx ▁= ▁motion _ x ▁>> ▁2 ▁; ▁my ▁= ▁motion _ y ▁>> ▁2 ▁; ▁} ▁else ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁/ ▁2 ▁; ▁d xy ▁= ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁mx ▁>>= ▁1 ▁; ▁my ▁>>= ▁1 ▁; ▁} ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁8 ▁+ ▁my ▁; ▁src _ x ▁= ▁av _ clip ▁( ▁src _ x ▁, ▁-8 ▁, ▁s ▁-> ▁width ▁>> ▁1 ▁) ▁; ▁if ▁( ▁src _ x ▁== ▁( ▁s ▁-> ▁width ▁>> ▁1 ▁) ▁) ▁d xy ▁&= ▁ ~ ▁1 ▁; ▁src _ y ▁= ▁av _ clip ▁( ▁src _ y ▁, ▁-8 ▁, ▁s ▁-> ▁height ▁>> ▁1 ▁) ▁; ▁if ▁( ▁src _ y ▁== ▁( ▁s ▁-> ▁height ▁>> ▁1 ▁) ▁) ▁d xy ▁&= ▁ ~ ▁2 ▁; ▁offset ▁= ▁( ▁src _ y ▁* ▁uv lines ize ▁) ▁+ ▁src _ x ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁offset ▁; ▁if ▁( ▁emu ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁} ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁offset ▁; ▁if ▁( ▁emu ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁} ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁}	0
▁static ▁int ▁test _ client _ hello ▁( ▁int ▁curr test ▁) ▁{ ▁SSL _ CTX ▁* ▁ctx ▁; ▁SSL ▁* ▁con ▁= ▁NULL ▁; ▁BIO ▁* ▁rb io ▁; ▁BIO ▁* ▁w bio ▁; ▁long ▁len ▁; ▁unsigned ▁char ▁* ▁data ▁; ▁PACKET ▁pkt ▁= ▁{ ▁0 ▁} ▁, ▁pkt 2 ▁= ▁{ ▁0 ▁} ▁, ▁pkt 3 ▁= ▁{ ▁0 ▁} ▁; ▁char ▁* ▁dummy tick ▁= ▁" HelloWorld !" ▁; ▁unsigned ▁int ▁type ▁= ▁0 ▁; ▁int ▁test result ▁= ▁0 ▁; ▁size _ t ▁msglen ▁; ▁BIO ▁* ▁sess bio ▁= ▁NULL ▁; ▁SSL _ SESSION ▁* ▁sess ▁= ▁NULL ▁; ▁# ifdef ▁OPENSSL _ NO _ TLS 1_ 3 ▁if ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING _ AND _ PS K ▁) ▁return ▁1 ▁; ▁# endif ▁ctx ▁= ▁SSL _ CTX _ new ▁( ▁TLS _ method ▁( ▁) ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁ctx ▁) ▁) ▁goto ▁end ▁; ▁switch ▁( ▁curr test ▁) ▁{ ▁case ▁TEST _ SET _ SESSION _ TICK _ DATA _ VER _ NEG ▁: ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ CTX _ set _ max _ proto _ version ▁( ▁ctx ▁, ▁TLS 1_ 2_ VERSION ▁) ▁) ▁) ▁goto ▁end ▁; ▁break ▁; ▁case ▁TEST _ ADD _ PADDING _ AND _ PS K ▁: ▁case ▁TEST _ ADD _ PADDING ▁: ▁case ▁TEST _ PADDING _ NOT _ NEEDED ▁: ▁SSL _ CTX _ set _ options ▁( ▁ctx ▁, ▁SSL _ OP _ TL SE XT _ PADDING ▁) ▁; ▁if ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING ▁&& ▁( ▁! ▁TEST _ false ▁( ▁SSL _ CTX _ set _ al pn _ protos ▁( ▁ctx ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁al pn _ pro ts ▁, ▁sizeof ▁( ▁al pn _ pro ts ▁) ▁- ▁1 ▁) ▁) ▁) ▁) ▁goto ▁end ▁; ▁break ▁; ▁default ▁: ▁goto ▁end ▁; ▁} ▁con ▁= ▁SSL _ new ▁( ▁ctx ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁con ▁) ▁) ▁goto ▁end ▁; ▁if ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING _ AND _ PS K ▁) ▁{ ▁sess bio ▁= ▁BIO _ new _ file ▁( ▁session file ▁, ▁" r " ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁sess bio ▁) ▁) ▁{ ▁TEST _ info ▁( ▁" Unable t oop ense ssion . pem " ▁) ▁; ▁goto ▁end ▁; ▁} ▁sess ▁= ▁PEM _ read _ bio _ SSL _ SESSION ▁( ▁sess bio ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁sess ▁) ▁) ▁{ ▁TEST _ info ▁( ▁" Unable to load SSL _ SESSION " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ SESSION _ set _ time ▁( ▁sess ▁, ▁time ▁( ▁NULL ▁) ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁SSL _ set _ session ▁( ▁con ▁, ▁sess ▁) ▁) ▁) ▁goto ▁end ▁; ▁} ▁rb io ▁= ▁BIO _ new ▁( ▁BIO _ s _ mem ▁( ▁) ▁) ▁; ▁w bio ▁= ▁BIO _ new ▁( ▁BIO _ s _ mem ▁( ▁) ▁) ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁rb io ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁w bio ▁) ▁) ▁{ ▁BIO _ free ▁( ▁rb io ▁) ▁; ▁BIO _ free ▁( ▁w bio ▁) ▁; ▁goto ▁end ▁; ▁} ▁SSL _ set _ bio ▁( ▁con ▁, ▁rb io ▁, ▁w bio ▁) ▁; ▁SSL _ set _ connect _ state ▁( ▁con ▁) ▁; ▁if ▁( ▁curr test ▁== ▁TEST _ SET _ SESSION _ TICK _ DATA _ VER _ NEG ▁) ▁{ ▁if ▁( ▁! ▁TEST _ true ▁( ▁SSL _ set _ session _ ticket _ ext ▁( ▁con ▁, ▁dummy tick ▁, ▁strlen ▁( ▁dummy tick ▁) ▁) ▁) ▁) ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁TEST _ int _ le ▁( ▁SSL _ connect ▁( ▁con ▁) ▁, ▁0 ▁) ▁) ▁{ ▁goto ▁end ▁; ▁} ▁len ▁= ▁BIO _ get _ mem _ data ▁( ▁w bio ▁, ▁( ▁char ▁* ▁* ▁) ▁& ▁data ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁PACKET _ buf _ init ▁( ▁& ▁pkt ▁, ▁data ▁, ▁len ▁) ▁) ▁|| ▁! ▁PACKET _ forward ▁( ▁& ▁pkt ▁, ▁SSL 3_ RT _ HEADER _ LENGTH ▁) ▁) ▁goto ▁end ▁; ▁msglen ▁= ▁PACKET _ remaining ▁( ▁& ▁pkt ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁PACKET _ forward ▁( ▁& ▁pkt ▁, ▁SSL 3_ HM _ HEADER _ LENGTH ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ forward ▁( ▁& ▁pkt ▁, ▁CLIENT _ VERSION _ LEN ▁+ ▁SSL 3_ RANDOM _ SIZE ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _1 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _1 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ as _ length _ pref ixed _2 ▁( ▁& ▁pkt ▁, ▁& ▁pkt 2 ▁) ▁) ▁) ▁goto ▁end ▁; ▁while ▁( ▁PACKET _ remaining ▁( ▁& ▁pkt 2 ▁) ▁) ▁{ ▁if ▁( ▁! ▁TEST _ true ▁( ▁PACKET _ get _ net _2 ▁( ▁& ▁pkt 2 ▁, ▁& ▁type ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁PACKET _ get _ length _ pref ixed _2 ▁( ▁& ▁pkt 2 ▁, ▁& ▁pkt 3 ▁) ▁) ▁) ▁goto ▁end ▁; ▁if ▁( ▁type ▁== ▁TL SE XT _ TYPE _ session _ ticket ▁) ▁{ ▁if ▁( ▁curr test ▁== ▁TEST _ SET _ SESSION _ TICK _ DATA _ VER _ NEG ▁) ▁{ ▁if ▁( ▁TEST _ true ▁( ▁PACKET _ equal ▁( ▁& ▁pkt 3 ▁, ▁dummy tick ▁, ▁strlen ▁( ▁dummy tick ▁) ▁) ▁) ▁) ▁{ ▁test result ▁= ▁1 ▁; ▁} ▁goto ▁end ▁; ▁} ▁} ▁if ▁( ▁type ▁== ▁TL SE XT _ TYPE _ padding ▁) ▁{ ▁if ▁( ▁! ▁TEST _ false ▁( ▁curr test ▁== ▁TEST _ PADDING _ NOT _ NEEDED ▁) ▁) ▁goto ▁end ▁; ▁else ▁if ▁( ▁TEST _ true ▁( ▁curr test ▁== ▁TEST _ ADD _ PADDING ▁|| ▁curr test ▁== ▁TEST _ ADD _ PADDING _ AND _ PS K ▁) ▁) ▁test result ▁= ▁TEST _ true ▁( ▁msglen ▁== ▁F 5_ WORKAROUND _ MAX _ MSG _ LEN ▁) ▁; ▁} ▁} ▁if ▁( ▁curr test ▁== ▁TEST _ PADDING _ NOT _ NEEDED ▁) ▁test result ▁= ▁1 ▁; ▁end ▁: ▁SSL _ free ▁( ▁con ▁) ▁; ▁SSL _ CTX _ free ▁( ▁ctx ▁) ▁; ▁SSL _ SESSION _ free ▁( ▁sess ▁) ▁; ▁BIO _ free ▁( ▁sess bio ▁) ▁; ▁return ▁test result ▁; ▁}	0
▁void ▁av _ dyn array _ add ▁( ▁void ▁* ▁tab _ ptr ▁, ▁int ▁* ▁nb _ ptr ▁, ▁void ▁* ▁elem ▁) ▁{ ▁void ▁* ▁* ▁tab ▁; ▁memcpy ▁( ▁& ▁tab ▁, ▁tab _ ptr ▁, ▁sizeof ▁( ▁tab ▁) ▁) ▁; ▁FF _ DYN ARRAY _ ADD ▁( ▁INT _ MAX ▁, ▁sizeof ▁( ▁* ▁tab ▁) ▁, ▁tab ▁, ▁* ▁nb _ ptr ▁, ▁{ ▁tab ▁[ ▁* ▁nb _ ptr ▁] ▁= ▁elem ▁; ▁memcpy ▁( ▁tab _ ptr ▁, ▁& ▁tab ▁, ▁sizeof ▁( ▁tab ▁) ▁) ▁; ▁} ▁, ▁{ ▁* ▁nb _ ptr ▁= ▁0 ▁; ▁av _ freep ▁( ▁tab _ ptr ▁) ▁; ▁} ▁) ▁; ▁}	1
▁int ▁BN _ mod _ exp _ mont ▁( ▁BIGNUM ▁* ▁rr ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁p ▁, ▁const ▁BIGNUM ▁* ▁m ▁, ▁BN _ CTX ▁* ▁ctx ▁, ▁BN _ M ONT _ CTX ▁* ▁in _ mont ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁bits ▁, ▁ret ▁= ▁0 ▁, ▁w start ▁, ▁w end ▁, ▁window ▁, ▁wvalue ▁; ▁int ▁start ▁= ▁1 ▁; ▁BIGNUM ▁* ▁d ▁, ▁* ▁r ▁; ▁const ▁BIGNUM ▁* ▁aa ▁; ▁BIGNUM ▁* ▁val ▁[ ▁TABLE _ SIZE ▁] ▁; ▁BN _ M ONT _ CTX ▁* ▁m ont ▁= ▁NULL ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁p ▁) ▁; ▁bn _ check _ top ▁( ▁m ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ odd ▁( ▁m ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ MOD _ EXP _ M ONT ▁, ▁BN _ R _ CALLED _ WITH _ EVEN _ MODUL US ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁bits ▁= ▁BN _ num _ bits ▁( ▁p ▁) ▁; ▁if ▁( ▁bits ▁== ▁0 ▁) ▁{ ▁ret ▁= ▁BN _ one ▁( ▁rr ▁) ▁; ▁return ▁ret ▁; ▁} ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁d ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁r ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁val ▁[ ▁0 ▁] ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁! ▁d ▁|| ▁! ▁r ▁|| ▁! ▁val ▁[ ▁0 ▁] ▁) ▁goto ▁err ▁; ▁if ▁( ▁in _ mont ▁!= ▁NULL ▁) ▁m ont ▁= ▁in _ mont ▁; ▁else ▁{ ▁if ▁( ▁( ▁m ont ▁= ▁BN _ M ONT _ CTX _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁m ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁a ▁-> ▁neg ▁|| ▁BN _ ucmp ▁( ▁a ▁, ▁m ▁) ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁! ▁BN _ nn mod ▁( ▁val ▁[ ▁0 ▁] ▁, ▁a ▁, ▁m ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁aa ▁= ▁val ▁[ ▁0 ▁] ▁; ▁} ▁else ▁aa ▁= ▁a ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁aa ▁) ▁) ▁{ ▁BN _ zero ▁( ▁rr ▁) ▁; ▁ret ▁= ▁1 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ to _ mon tg om ery ▁( ▁val ▁[ ▁0 ▁] ▁, ▁aa ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁window ▁= ▁BN _ window _ bits _ for _ exponent _ size ▁( ▁bits ▁) ▁; ▁if ▁( ▁window ▁> ▁1 ▁) ▁{ ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁d ▁, ▁val ▁[ ▁0 ▁] ▁, ▁val ▁[ ▁0 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁j ▁= ▁1 ▁<< ▁( ▁window ▁- ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁val ▁[ ▁i ▁] ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁|| ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁val ▁[ ▁i ▁] ▁, ▁val ▁[ ▁i ▁- ▁1 ▁] ▁, ▁d ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁} ▁start ▁= ▁1 ▁; ▁wvalue ▁= ▁0 ▁; ▁w start ▁= ▁bits ▁- ▁1 ▁; ▁w end ▁= ▁0 ▁; ▁if ▁( ▁! ▁BN _ to _ mon tg om ery ▁( ▁r ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁BN _ is _ bit _ set ▁( ▁p ▁, ▁w start ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁! ▁start ▁) ▁{ ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁r ▁, ▁r ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁w start ▁== ▁0 ▁) ▁break ▁; ▁w start ▁-- ▁; ▁continue ▁; ▁} ▁j ▁= ▁w start ▁; ▁wvalue ▁= ▁1 ▁; ▁w end ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁window ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁w start ▁- ▁i ▁< ▁0 ▁) ▁break ▁; ▁if ▁( ▁BN _ is _ bit _ set ▁( ▁p ▁, ▁w start ▁- ▁i ▁) ▁) ▁{ ▁wvalue ▁<<= ▁( ▁i ▁- ▁w end ▁) ▁; ▁wvalue ▁|= ▁1 ▁; ▁w end ▁= ▁i ▁; ▁} ▁} ▁j ▁= ▁w end ▁+ ▁1 ▁; ▁if ▁( ▁! ▁start ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁r ▁, ▁r ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁r ▁, ▁r ▁, ▁val ▁[ ▁wvalue ▁>> ▁1 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁w start ▁-= ▁w end ▁+ ▁1 ▁; ▁wvalue ▁= ▁0 ▁; ▁start ▁= ▁0 ▁; ▁if ▁( ▁w start ▁< ▁0 ▁) ▁break ▁; ▁} ▁if ▁( ▁! ▁BN _ from _ mon tg om ery ▁( ▁rr ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁( ▁in _ mont ▁== ▁NULL ▁) ▁&& ▁( ▁m ont ▁!= ▁NULL ▁) ▁) ▁BN _ M ONT _ CTX _ free ▁( ▁m ont ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁bn _ check _ top ▁( ▁rr ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁int ▁dt ls 1_ do _ write ▁( ▁SSL ▁* ▁s ▁, ▁int ▁type ▁) ▁{ ▁int ▁ret ▁; ▁unsigned ▁int ▁curr _ mtu ▁; ▁int ▁retry ▁= ▁1 ▁; ▁unsigned ▁int ▁len ▁, ▁frag _ off ▁, ▁mac _ size ▁, ▁blocksize ▁, ▁used _ len ▁; ▁if ▁( ▁! ▁dt ls 1_ query _ mtu ▁( ▁s ▁) ▁) ▁return ▁-1 ▁; ▁OPENSSL _ assert ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁>= ▁dt ls 1_ min _ mtu ▁( ▁s ▁) ▁) ▁; ▁if ▁( ▁s ▁-> ▁init _ off ▁== ▁0 ▁&& ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁) ▁OPENSSL _ assert ▁( ▁s ▁-> ▁init _ num ▁== ▁( ▁int ▁) ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁. ▁msg _ len ▁+ ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁if ▁( ▁s ▁-> ▁write _ hash ▁) ▁{ ▁if ▁( ▁s ▁-> ▁enc _ write _ ctx ▁&& ▁( ▁( ▁EVP _ CIPHER _ CTX _ mode ▁( ▁s ▁-> ▁enc _ write _ ctx ▁) ▁== ▁EVP _ C IPH _ GCM _ MODE ▁) ▁|| ▁( ▁EVP _ CIPHER _ CTX _ mode ▁( ▁s ▁-> ▁enc _ write _ ctx ▁) ▁== ▁EVP _ C IPH _ CCM _ MODE ▁) ▁) ▁) ▁mac _ size ▁= ▁0 ▁; ▁else ▁mac _ size ▁= ▁EVP _ MD _ CTX _ size ▁( ▁s ▁-> ▁write _ hash ▁) ▁; ▁} ▁else ▁mac _ size ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁enc _ write _ ctx ▁&& ▁( ▁EVP _ CIPHER _ CTX _ mode ▁( ▁s ▁-> ▁enc _ write _ ctx ▁) ▁== ▁EVP _ C IPH _ CBC _ MODE ▁) ▁) ▁blocksize ▁= ▁2 ▁* ▁EVP _ CIPHER _ block _ size ▁( ▁s ▁-> ▁enc _ write _ ctx ▁-> ▁cipher ▁) ▁; ▁else ▁blocksize ▁= ▁0 ▁; ▁frag _ off ▁= ▁0 ▁; ▁while ▁( ▁s ▁-> ▁init _ num ▁> ▁0 ▁) ▁{ ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁&& ▁s ▁-> ▁init _ off ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁frag _ off ▁> ▁0 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁init _ off ▁<= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁init _ off ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁s ▁-> ▁init _ num ▁+= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁} ▁else ▁{ ▁frag _ off ▁= ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁. ▁frag _ off ▁; ▁} ▁} ▁used _ len ▁= ▁BIO _ w pending ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁+ ▁DTLS 1_ RT _ HEADER _ LENGTH ▁+ ▁mac _ size ▁+ ▁blocksize ▁; ▁if ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁> ▁used _ len ▁) ▁curr _ mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁- ▁used _ len ▁; ▁else ▁curr _ mtu ▁= ▁0 ▁; ▁if ▁( ▁curr _ mtu ▁<= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁ret ▁= ▁BIO _ flush ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁) ▁return ▁ret ▁; ▁used _ len ▁= ▁DTLS 1_ RT _ HEADER _ LENGTH ▁+ ▁mac _ size ▁+ ▁blocksize ▁; ▁if ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁> ▁used _ len ▁+ ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁curr _ mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁- ▁used _ len ▁; ▁} ▁else ▁{ ▁return ▁-1 ▁; ▁} ▁} ▁if ▁( ▁( ▁( ▁unsigned ▁int ▁) ▁s ▁-> ▁init _ num ▁) ▁> ▁curr _ mtu ▁) ▁len ▁= ▁curr _ mtu ▁; ▁else ▁len ▁= ▁s ▁-> ▁init _ num ▁; ▁if ▁( ▁len ▁> ▁INT _ MAX ▁) ▁len ▁= ▁INT _ MAX ▁; ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁) ▁{ ▁if ▁( ▁len ▁< ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁dt ls 1_ fix _ message _ header ▁( ▁s ▁, ▁frag _ off ▁, ▁len ▁- ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁dt ls 1_ write _ message _ header ▁( ▁s ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁) ▁; ▁} ▁ret ▁= ▁dt ls 1_ write _ bytes ▁( ▁s ▁, ▁type ▁, ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁, ▁len ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁retry ▁&& ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ MTU _ EXCEEDED ▁, ▁0 ▁, ▁NULL ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁! ▁( ▁SSL _ get _ options ▁( ▁s ▁) ▁& ▁SSL _ OP _ NO _ QUERY _ MTU ▁) ▁) ▁{ ▁if ▁( ▁! ▁dt ls 1_ query _ mtu ▁( ▁s ▁) ▁) ▁return ▁-1 ▁; ▁retry ▁= ▁0 ▁; ▁} ▁else ▁return ▁-1 ▁; ▁} ▁else ▁{ ▁return ▁( ▁-1 ▁) ▁; ▁} ▁} ▁else ▁{ ▁OPENSSL _ assert ▁( ▁len ▁== ▁( ▁unsigned ▁int ▁) ▁ret ▁) ▁; ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁&& ▁! ▁s ▁-> ▁d 1 ▁-> ▁retrans mit ting ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁; ▁const ▁struct ▁hm _ header _ st ▁* ▁msg _ hdr ▁= ▁& ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁; ▁int ▁xlen ▁; ▁if ▁( ▁frag _ off ▁== ▁0 ▁&& ▁s ▁-> ▁version ▁!= ▁DTLS 1_ BAD _ VER ▁) ▁{ ▁* ▁p ▁++ ▁= ▁msg _ hdr ▁-> ▁type ▁; ▁l 2 n 3 ▁( ▁msg _ hdr ▁-> ▁msg _ len ▁, ▁p ▁) ▁; ▁s 2 n ▁( ▁msg _ hdr ▁-> ▁seq ▁, ▁p ▁) ▁; ▁l 2 n 3 ▁( ▁0 ▁, ▁p ▁) ▁; ▁l 2 n 3 ▁( ▁msg _ hdr ▁-> ▁msg _ len ▁, ▁p ▁) ▁; ▁p ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁xlen ▁= ▁ret ▁; ▁} ▁else ▁{ ▁p ▁+= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁xlen ▁= ▁ret ▁- ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁} ▁ssl 3_ finish _ mac ▁( ▁s ▁, ▁p ▁, ▁xlen ▁) ▁; ▁} ▁if ▁( ▁ret ▁== ▁s ▁-> ▁init _ num ▁) ▁{ ▁if ▁( ▁s ▁-> ▁msg _ callback ▁) ▁s ▁-> ▁msg _ callback ▁( ▁1 ▁, ▁s ▁-> ▁version ▁, ▁type ▁, ▁s ▁-> ▁init _ buf ▁-> ▁data ▁, ▁( ▁size _ t ▁) ▁( ▁s ▁-> ▁init _ off ▁+ ▁s ▁-> ▁init _ num ▁) ▁, ▁s ▁, ▁s ▁-> ▁msg _ callback _ arg ▁) ▁; ▁s ▁-> ▁init _ off ▁= ▁0 ▁; ▁s ▁-> ▁init _ num ▁= ▁0 ▁; ▁return ▁( ▁1 ▁) ▁; ▁} ▁s ▁-> ▁init _ off ▁+= ▁ret ▁; ▁s ▁-> ▁init _ num ▁-= ▁ret ▁; ▁ret ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁frag _ off ▁+= ▁ret ▁; ▁dt ls 1_ fix _ message _ header ▁( ▁s ▁, ▁frag _ off ▁, ▁0 ▁) ▁; ▁} ▁} ▁return ▁( ▁0 ▁) ▁; ▁}	0
▁static ▁inline ▁void ▁writer _ print _ string ▁( ▁Writer Context ▁* ▁w ctx ▁, ▁const ▁char ▁* ▁key ▁, ▁const ▁char ▁* ▁val ▁, ▁int ▁opt ▁) ▁{ ▁if ▁( ▁opt ▁&& ▁! ▁( ▁w ctx ▁-> ▁writer ▁-> ▁flags ▁& ▁WR ITER _ FLAG _ DISPLAY _ OPTIONAL _ FIELDS ▁) ▁) ▁return ▁; ▁w ctx ▁-> ▁writer ▁-> ▁print _ string ▁( ▁w ctx ▁, ▁key ▁, ▁val ▁) ▁; ▁w ctx ▁-> ▁nb _ item ▁++ ▁; ▁}	0
▁static ▁int ▁o ma _ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁int ▁ret ▁, ▁frames ize ▁, ▁js flag ▁, ▁sampler ate ▁; ▁uint 32_ t ▁codec _ params ▁, ▁channel _ id ▁; ▁int 16_ t ▁eid ▁; ▁uint 8_ t ▁buf ▁[ ▁EA 3_ HEADER _ SIZE ▁] ▁; ▁uint 8_ t ▁* ▁ed ata ▁; ▁AVStream ▁* ▁st ▁; ▁ID 3 v 2 Extra Meta ▁* ▁extra _ meta ▁= ▁NULL ▁; ▁O MA Context ▁* ▁oc ▁= ▁s ▁-> ▁priv _ data ▁; ▁ff _ id 3 v 2_ read ▁( ▁s ▁, ▁ID 3 v 2_ EA 3_ MAGIC ▁, ▁& ▁extra _ meta ▁, ▁0 ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ id 3 v 2_ parse _ ch apt ers ▁( ▁s ▁, ▁& ▁extra _ meta ▁) ▁) ▁< ▁0 ▁) ▁{ ▁ff _ id 3 v 2_ free _ extra _ meta ▁( ▁& ▁extra _ meta ▁) ▁; ▁return ▁ret ▁; ▁} ▁ret ▁= ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁buf ▁, ▁EA 3_ HEADER _ SIZE ▁) ▁; ▁if ▁( ▁ret ▁< ▁EA 3_ HEADER _ SIZE ▁) ▁return ▁-1 ▁; ▁if ▁( ▁memcmp ▁( ▁buf ▁, ▁( ▁( ▁const ▁uint 8_ t ▁[ ▁] ▁) ▁{ ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁} ▁) ▁, ▁3 ▁) ▁|| ▁buf ▁[ ▁4 ▁] ▁!= ▁0 ▁|| ▁buf ▁[ ▁5 ▁] ▁!= ▁EA 3_ HEADER _ SIZE ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Couldn ' t find the EA 3 header !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁oc ▁-> ▁content _ start ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁; ▁eid ▁= ▁AV _ RB 16 ▁( ▁& ▁buf ▁[ ▁6 ▁] ▁) ▁; ▁if ▁( ▁eid ▁!= ▁-1 ▁&& ▁eid ▁!= ▁-128 ▁&& ▁decrypt _ init ▁( ▁s ▁, ▁extra _ meta ▁, ▁buf ▁) ▁< ▁0 ▁) ▁{ ▁ff _ id 3 v 2_ free _ extra _ meta ▁( ▁& ▁extra _ meta ▁) ▁; ▁return ▁-1 ▁; ▁} ▁ff _ id 3 v 2_ free _ extra _ meta ▁( ▁& ▁extra _ meta ▁) ▁; ▁codec _ params ▁= ▁AV _ RB 24 ▁( ▁& ▁buf ▁[ ▁33 ▁] ▁) ▁; ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁st ▁-> ▁start _ time ▁= ▁0 ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ tag ▁= ▁buf ▁[ ▁32 ▁] ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁= ▁ff _ codec _ get _ id ▁( ▁ff _ om a _ codec _ tags ▁, ▁st ▁-> ▁codecpar ▁-> ▁codec _ tag ▁) ▁; ▁oc ▁-> ▁read _ packet ▁= ▁read _ packet ▁; ▁switch ▁( ▁buf ▁[ ▁32 ▁] ▁) ▁{ ▁case ▁O MA _ CODE CID _ ATR AC 3 ▁: ▁sampler ate ▁= ▁ff _ om a _ s rate _ tab ▁[ ▁( ▁codec _ params ▁>> ▁13 ▁) ▁& ▁7 ▁] ▁* ▁100 ▁; ▁if ▁( ▁! ▁sampler ate ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported sampler ate \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁sampler ate ▁!= ▁44100 ▁) ▁avpriv _ request _ sample ▁( ▁s ▁, ▁" Sampler ate % d " ▁, ▁sampler ate ▁) ▁; ▁frames ize ▁= ▁( ▁codec _ params ▁& ▁0 x 3 FF ▁) ▁* ▁8 ▁; ▁js flag ▁= ▁( ▁codec _ params ▁>> ▁17 ▁) ▁& ▁1 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁2 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ STEREO ▁; ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁sampler ate ▁; ▁st ▁-> ▁codecpar ▁-> ▁bit _ rate ▁= ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁* ▁frames ize ▁/ ▁( ▁1024 ▁/ ▁8 ▁) ▁; ▁if ▁( ▁ff _ alloc _ extr adata ▁( ▁st ▁-> ▁codecpar ▁, ▁14 ▁) ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁ed ata ▁= ▁st ▁-> ▁codecpar ▁-> ▁extradata ▁; ▁AV _ WL 16 ▁( ▁& ▁ed ata ▁[ ▁0 ▁] ▁, ▁1 ▁) ▁; ▁AV _ WL 32 ▁( ▁& ▁ed ata ▁[ ▁2 ▁] ▁, ▁sampler ate ▁) ▁; ▁AV _ WL 16 ▁( ▁& ▁ed ata ▁[ ▁6 ▁] ▁, ▁js flag ▁) ▁; ▁AV _ WL 16 ▁( ▁& ▁ed ata ▁[ ▁8 ▁] ▁, ▁js flag ▁) ▁; ▁AV _ WL 16 ▁( ▁& ▁ed ata ▁[ ▁10 ▁] ▁, ▁1 ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁) ▁; ▁break ▁; ▁case ▁O MA _ CODE CID _ ATR AC 3 P ▁: ▁channel _ id ▁= ▁( ▁codec _ params ▁>> ▁10 ▁) ▁& ▁7 ▁; ▁if ▁( ▁! ▁channel _ id ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid ATR AC - X channel id :% " ▁PRIu 32 ▁"\ n " ▁, ▁channel _ id ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁ff _ om a _ ch id _ to _ native _ layout ▁[ ▁channel _ id ▁- ▁1 ▁] ▁; ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁ff _ om a _ ch id _ to _ num _ channels ▁[ ▁channel _ id ▁- ▁1 ▁] ▁; ▁frames ize ▁= ▁( ▁( ▁codec _ params ▁& ▁0 x 3 FF ▁) ▁* ▁8 ▁) ▁+ ▁8 ▁; ▁sampler ate ▁= ▁ff _ om a _ s rate _ tab ▁[ ▁( ▁codec _ params ▁>> ▁13 ▁) ▁& ▁7 ▁] ▁* ▁100 ▁; ▁if ▁( ▁! ▁sampler ate ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported sampler ate \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁sampler ate ▁; ▁st ▁-> ▁codecpar ▁-> ▁bit _ rate ▁= ▁sampler ate ▁* ▁frames ize ▁/ ▁( ▁2048 ▁/ ▁8 ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁sampler ate ▁) ▁; ▁break ▁; ▁case ▁O MA _ CODE CID _ MP 3 ▁: ▁st ▁-> ▁need _ parsing ▁= ▁AV STREAM _ PARSE _ FULL _ RAW ▁; ▁frames ize ▁= ▁1024 ▁; ▁break ▁; ▁case ▁O MA _ CODE CID _ L PCM ▁: ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁2 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ STEREO ▁; ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁44100 ▁; ▁frames ize ▁= ▁1024 ▁; ▁st ▁-> ▁codecpar ▁-> ▁bit _ rate ▁= ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁* ▁32 ▁; ▁st ▁-> ▁codecpar ▁-> ▁bits _ per _ coded _ sample ▁= ▁av _ get _ bits _ per _ sample ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁) ▁; ▁break ▁; ▁case ▁O MA _ CODE CID _ ATR AC 3 AL ▁: ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁2 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ STEREO ▁; ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁44100 ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁44100 ▁) ▁; ▁oc ▁-> ▁read _ packet ▁= ▁a al _ read _ packet ▁; ▁frames ize ▁= ▁4096 ▁; ▁break ▁; ▁case ▁O MA _ CODE CID _ ATR AC 3 PAL ▁: ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ STEREO ▁; ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁2 ▁; ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁44100 ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁44100 ▁) ▁; ▁oc ▁-> ▁read _ packet ▁= ▁a al _ read _ packet ▁; ▁frames ize ▁= ▁4096 ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported codec % d !\ n " ▁, ▁buf ▁[ ▁32 ▁] ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁} ▁st ▁-> ▁codecpar ▁-> ▁block _ align ▁= ▁frames ize ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁av _ always _ inline ▁int ▁setup _ class ifs ▁( ▁vorbis _ context ▁* ▁vc ▁, ▁vorbis _ resid ue ▁* ▁vr ▁, ▁uint 8_ t ▁* ▁do _ not _ decode ▁, ▁unsigned ▁ch _ used ▁, ▁int ▁partition _ count ▁) ▁{ ▁int ▁p ▁, ▁j ▁, ▁i ▁; ▁unsigned ▁c _ p _ c ▁= ▁vc ▁-> ▁code books ▁[ ▁vr ▁-> ▁class book ▁] ▁. ▁dimensions ▁; ▁unsigned ▁inverse _ class ▁= ▁ff _ inverse ▁[ ▁vr ▁-> ▁class ifications ▁] ▁; ▁unsigned ▁temp ▁, ▁temp 2 ▁; ▁for ▁( ▁p ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁j ▁< ▁ch _ used ▁; ▁++ ▁j ▁) ▁{ ▁if ▁( ▁! ▁do _ not _ decode ▁[ ▁j ▁] ▁) ▁{ ▁temp ▁= ▁get _ vlc 2 ▁( ▁& ▁vc ▁-> ▁gb ▁, ▁vc ▁-> ▁code books ▁[ ▁vr ▁-> ▁class book ▁] ▁. ▁vlc ▁. ▁table ▁, ▁vc ▁-> ▁code books ▁[ ▁vr ▁-> ▁class book ▁] ▁. ▁nb _ bits ▁, ▁3 ▁) ▁; ▁av _ d log ▁( ▁NULL ▁, ▁" Class word :% u \ n " ▁, ▁temp ▁) ▁; ▁if ▁( ▁( ▁int ▁) ▁temp ▁< ▁0 ▁) ▁return ▁temp ▁; ▁av _ assert 0 ▁( ▁vr ▁-> ▁class ifications ▁> ▁1 ▁) ▁; ▁if ▁( ▁temp ▁<= ▁65536 ▁) ▁{ ▁for ▁( ▁i ▁= ▁partition _ count ▁+ ▁c _ p _ c ▁- ▁1 ▁; ▁i ▁>= ▁partition _ count ▁; ▁i ▁-- ▁) ▁{ ▁temp 2 ▁= ▁( ▁( ▁( ▁uint 64_ t ▁) ▁temp ▁) ▁* ▁inverse _ class ▁) ▁>> ▁32 ▁; ▁if ▁( ▁i ▁< ▁vr ▁-> ▁pt ns _ to _ read ▁) ▁vr ▁-> ▁class ifs ▁[ ▁p ▁+ ▁i ▁] ▁= ▁temp ▁- ▁temp 2 ▁* ▁vr ▁-> ▁class ifications ▁; ▁temp ▁= ▁temp 2 ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁partition _ count ▁+ ▁c _ p _ c ▁- ▁1 ▁; ▁i ▁>= ▁partition _ count ▁; ▁i ▁-- ▁) ▁{ ▁temp 2 ▁= ▁temp ▁/ ▁vr ▁-> ▁class ifications ▁; ▁if ▁( ▁i ▁< ▁vr ▁-> ▁pt ns _ to _ read ▁) ▁vr ▁-> ▁class ifs ▁[ ▁p ▁+ ▁i ▁] ▁= ▁temp ▁- ▁temp 2 ▁* ▁vr ▁-> ▁class ifications ▁; ▁temp ▁= ▁temp 2 ▁; ▁} ▁} ▁} ▁p ▁+= ▁vr ▁-> ▁pt ns _ to _ read ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁AV BitStream Filter Context ▁* ▁av _ bit stream _ filter _ init ▁( ▁const ▁char ▁* ▁name ▁) ▁{ ▁AV BitStream Filter ▁* ▁bs f ▁= ▁first _ bit stream _ filter ▁; ▁while ▁( ▁bs f ▁) ▁{ ▁if ▁( ▁! ▁strcmp ▁( ▁name ▁, ▁bs f ▁-> ▁name ▁) ▁) ▁{ ▁AV BitStream Filter Context ▁* ▁bs fc ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AV BitStream Filter Context ▁) ▁) ▁; ▁if ▁( ▁! ▁bs fc ▁) ▁return ▁NULL ▁; ▁bs fc ▁-> ▁filter ▁= ▁bs f ▁; ▁bs fc ▁-> ▁priv _ data ▁= ▁NULL ▁; ▁if ▁( ▁bs f ▁-> ▁priv _ data _ size ▁) ▁{ ▁bs fc ▁-> ▁priv _ data ▁= ▁av _ malloc z ▁( ▁bs f ▁-> ▁priv _ data _ size ▁) ▁; ▁if ▁( ▁! ▁bs fc ▁-> ▁priv _ data ▁) ▁{ ▁av _ freep ▁( ▁& ▁bs fc ▁) ▁; ▁return ▁NULL ▁; ▁} ▁} ▁return ▁bs fc ▁; ▁} ▁bs f ▁= ▁bs f ▁-> ▁next ▁; ▁} ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁decode _ n al _ units ▁( ▁H EV C Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁length ▁) ▁{ ▁int ▁i ▁, ▁ret ▁= ▁0 ▁; ▁s ▁-> ▁ref ▁= ▁NULL ▁; ▁s ▁-> ▁last _ e os ▁= ▁s ▁-> ▁eos ▁; ▁s ▁-> ▁eos ▁= ▁0 ▁; ▁ret ▁= ▁ff _ h 264 5_ packet _ split ▁( ▁& ▁s ▁-> ▁pkt ▁, ▁buf ▁, ▁length ▁, ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁is _ n al ff ▁, ▁s ▁-> ▁nal _ length _ size ▁, ▁s ▁-> ▁avctx ▁-> ▁codec _ id ▁, ▁1 ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Errors plit ting the input into NAL units .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁pkt ▁. ▁nb _ n als ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁pkt ▁. ▁n als ▁[ ▁i ▁] ▁. ▁type ▁== ▁N AL _ EO B _ N UT ▁|| ▁s ▁-> ▁pkt ▁. ▁n als ▁[ ▁i ▁] ▁. ▁type ▁== ▁N AL _ E OS _ N UT ▁) ▁s ▁-> ▁eos ▁= ▁1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁pkt ▁. ▁nb _ n als ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁= ▁decode _ n al _ unit ▁( ▁s ▁, ▁& ▁s ▁-> ▁pkt ▁. ▁n als ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Error parsing NAL unit #% d .\ n " ▁, ▁i ▁) ▁; ▁goto ▁fail ▁; ▁} ▁} ▁fail ▁: ▁if ▁( ▁s ▁-> ▁ref ▁&& ▁s ▁-> ▁threads _ type ▁== ▁FF _ THREAD _ FRAME ▁) ▁ff _ thread _ report _ progress ▁( ▁& ▁s ▁-> ▁ref ▁-> ▁tf ▁, ▁INT _ MAX ▁, ▁0 ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁ngx _ conf _ flush _ files ▁( ▁ngx _ cycle _ t ▁* ▁cycle ▁) ▁{ ▁ngx _ uint _ t ▁i ▁; ▁ngx _ list _ part _ t ▁* ▁part ▁; ▁ngx _ open _ file _ t ▁* ▁file ▁; ▁ngx _ log _ debug 0 ▁( ▁NGX _ LOG _ DEBUG _ CORE ▁, ▁cycle ▁-> ▁log ▁, ▁0 ▁, ▁" flush files " ▁) ▁; ▁part ▁= ▁& ▁cycle ▁-> ▁open _ files ▁. ▁part ▁; ▁file ▁= ▁part ▁-> ▁elts ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁>= ▁part ▁-> ▁nel ts ▁) ▁{ ▁if ▁( ▁part ▁-> ▁next ▁== ▁NULL ▁) ▁{ ▁break ▁; ▁} ▁part ▁= ▁part ▁-> ▁next ▁; ▁file ▁= ▁part ▁-> ▁elts ▁; ▁i ▁= ▁0 ▁; ▁} ▁if ▁( ▁file ▁[ ▁i ▁] ▁. ▁flush ▁) ▁{ ▁file ▁[ ▁i ▁] ▁. ▁flush ▁( ▁& ▁file ▁[ ▁i ▁] ▁, ▁cycle ▁-> ▁log ▁) ▁; ▁} ▁} ▁}	0
▁int ▁ff _ inter leave _ add _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁( ▁* ▁compare ▁) ▁( ▁AVFormatContext ▁* ▁, ▁AVPacket ▁* ▁, ▁AVPacket ▁* ▁) ▁) ▁{ ▁AVPacket List ▁* ▁* ▁next _ point ▁, ▁* ▁this _ pk tl ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁; ▁int ▁chunk ed ▁= ▁s ▁-> ▁max _ chunk _ size ▁|| ▁s ▁-> ▁max _ chunk _ duration ▁; ▁this _ pk tl ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVPacket List ▁) ▁) ▁; ▁if ▁( ▁! ▁this _ pk tl ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁this _ pk tl ▁-> ▁pkt ▁= ▁* ▁pkt ▁; ▁pkt ▁-> ▁destruct ▁= ▁NULL ▁; ▁av _ dup _ packet ▁( ▁& ▁this _ pk tl ▁-> ▁pkt ▁) ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁) ▁{ ▁next _ point ▁= ▁& ▁( ▁st ▁-> ▁last _ in _ packet _ buffer ▁-> ▁next ▁) ▁; ▁} ▁else ▁{ ▁next _ point ▁= ▁& ▁s ▁-> ▁packet _ buffer ▁; ▁} ▁if ▁( ▁chunk ed ▁) ▁{ ▁uint 64_ t ▁max ▁= ▁av _ re scale _ q _ rnd ▁( ▁s ▁-> ▁max _ chunk _ duration ▁, ▁AV _ TIME _ BASE _ Q ▁, ▁st ▁-> ▁time _ base ▁, ▁AV _ ROUND _ UP ▁) ▁; ▁st ▁-> ▁inter le aver _ chunk _ size ▁+= ▁pkt ▁-> ▁size ▁; ▁st ▁-> ▁inter le aver _ chunk _ duration ▁+= ▁pkt ▁-> ▁duration ▁; ▁if ▁( ▁( ▁s ▁-> ▁max _ chunk _ size ▁&& ▁st ▁-> ▁inter le aver _ chunk _ size ▁> ▁s ▁-> ▁max _ chunk _ size ▁) ▁|| ▁( ▁max ▁&& ▁st ▁-> ▁inter le aver _ chunk _ duration ▁> ▁max ▁) ▁) ▁{ ▁st ▁-> ▁inter le aver _ chunk _ size ▁= ▁st ▁-> ▁inter le aver _ chunk _ duration ▁= ▁0 ▁; ▁this _ pk tl ▁-> ▁pkt ▁. ▁flags ▁|= ▁CHUNK _ START ▁; ▁} ▁} ▁if ▁( ▁* ▁next _ point ▁) ▁{ ▁if ▁( ▁chunk ed ▁&& ▁! ▁( ▁this _ pk tl ▁-> ▁pkt ▁. ▁flags ▁& ▁CHUNK _ START ▁) ▁) ▁goto ▁next _ non _ null ▁; ▁if ▁( ▁compare ▁( ▁s ▁, ▁& ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁{ ▁while ▁( ▁* ▁next _ point ▁&& ▁( ▁( ▁chunk ed ▁&& ▁! ▁( ▁( ▁* ▁next _ point ▁) ▁-> ▁pkt ▁. ▁flags ▁& ▁CHUNK _ START ▁) ▁) ▁|| ▁! ▁compare ▁( ▁s ▁, ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁) ▁next _ point ▁= ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁next ▁; ▁if ▁( ▁* ▁next _ point ▁) ▁goto ▁next _ non _ null ▁; ▁} ▁else ▁{ ▁next _ point ▁= ▁& ▁( ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁next ▁) ▁; ▁} ▁} ▁av _ assert 1 ▁( ▁! ▁* ▁next _ point ▁) ▁; ▁s ▁-> ▁packet _ buffer _ end ▁= ▁this _ pk tl ▁; ▁next _ non _ null ▁: ▁this _ pk tl ▁-> ▁next ▁= ▁* ▁next _ point ▁; ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁= ▁* ▁next _ point ▁= ▁this _ pk tl ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁pkey _ set _ type ▁( ▁EVP _ PKEY ▁* ▁pkey ▁, ▁int ▁type ▁, ▁const ▁char ▁* ▁str ▁, ▁int ▁len ▁) ▁{ ▁const ▁EVP _ PKEY _ ASN 1_ METHOD ▁* ▁am eth ▁; ▁ENGINE ▁* ▁e ▁= ▁NULL ▁; ▁if ▁( ▁pkey ▁) ▁{ ▁if ▁( ▁pkey ▁-> ▁pkey ▁. ▁ptr ▁) ▁EVP _ PKEY _ free _ it ▁( ▁pkey ▁) ▁; ▁if ▁( ▁( ▁type ▁== ▁pkey ▁-> ▁save _ type ▁) ▁&& ▁pkey ▁-> ▁am eth ▁) ▁return ▁1 ▁; ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁ENGINE _ finish ▁( ▁pkey ▁-> ▁engine ▁) ▁; ▁pkey ▁-> ▁engine ▁= ▁NULL ▁; ▁# endif ▁} ▁if ▁( ▁str ▁) ▁am eth ▁= ▁EVP _ PKEY _ asn 1_ find _ str ▁( ▁& ▁e ▁, ▁str ▁, ▁len ▁) ▁; ▁else ▁am eth ▁= ▁EVP _ PKEY _ asn 1_ find ▁( ▁& ▁e ▁, ▁type ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁if ▁( ▁pkey ▁== ▁NULL ▁) ▁ENGINE _ finish ▁( ▁e ▁) ▁; ▁# endif ▁if ▁( ▁am eth ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ PKEY _ SET _ TYPE ▁, ▁EVP _ R _ UNSUPPORTED _ ALGORITHM ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁pkey ▁) ▁{ ▁pkey ▁-> ▁am eth ▁= ▁am eth ▁; ▁pkey ▁-> ▁engine ▁= ▁e ▁; ▁pkey ▁-> ▁type ▁= ▁pkey ▁-> ▁am eth ▁-> ▁pkey _ id ▁; ▁pkey ▁-> ▁save _ type ▁= ▁type ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int 64_ t ▁pv a _ read _ timestamp ▁( ▁struct ▁AVFormatContext ▁* ▁s ▁, ▁int ▁stream _ index ▁, ▁int 64_ t ▁* ▁pos ▁, ▁int 64_ t ▁pos _ limit ▁) ▁{ ▁Byte IO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁P VA Context ▁* ▁pv act x ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁length ▁, ▁stream id ▁; ▁int 64_ t ▁res ▁= ▁AV _ NOP TS _ VALUE ▁; ▁pos _ limit ▁= ▁FF MIN ▁( ▁* ▁pos ▁+ ▁P VA _ MAX _ PAYLOAD _ LENGTH ▁* ▁8 ▁, ▁( ▁uint 64_ t ▁) ▁* ▁pos ▁+ ▁pos _ limit ▁) ▁; ▁while ▁( ▁* ▁pos ▁< ▁pos _ limit ▁) ▁{ ▁res ▁= ▁AV _ NOP TS _ VALUE ▁; ▁url _ f seek ▁( ▁pb ▁, ▁* ▁pos ▁, ▁SEEK _ SET ▁) ▁; ▁pv act x ▁-> ▁continue _ pes ▁= ▁0 ▁; ▁if ▁( ▁read _ part _ of _ packet ▁( ▁s ▁, ▁& ▁res ▁, ▁& ▁length ▁, ▁& ▁stream id ▁, ▁0 ▁) ▁) ▁{ ▁( ▁* ▁pos ▁) ▁++ ▁; ▁continue ▁; ▁} ▁if ▁( ▁stream id ▁- ▁1 ▁!= ▁stream _ index ▁|| ▁res ▁== ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁* ▁pos ▁= ▁url _ f tell ▁( ▁pb ▁) ▁+ ▁length ▁; ▁continue ▁; ▁} ▁break ▁; ▁} ▁pv act x ▁-> ▁continue _ pes ▁= ▁0 ▁; ▁return ▁res ▁; ▁}	0
▁static ▁void ▁ff _ id 3 v 2_ parse ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁len ▁, ▁uint 8_ t ▁version ▁, ▁uint 8_ t ▁flags ▁) ▁{ ▁int ▁is v 34 ▁, ▁tlen ▁, ▁un sync ▁; ▁char ▁tag ▁[ ▁5 ▁] ▁; ▁int 64_ t ▁next ▁, ▁end ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁+ ▁len ▁; ▁int ▁tag hdrlen ▁; ▁const ▁char ▁* ▁reason ▁= ▁NULL ▁; ▁AVIO Context ▁pb ▁; ▁unsigned ▁char ▁* ▁buffer ▁= ▁NULL ▁; ▁int ▁buffer _ size ▁= ▁0 ▁; ▁switch ▁( ▁version ▁) ▁{ ▁case ▁2 ▁: ▁if ▁( ▁flags ▁& ▁0 x 40 ▁) ▁{ ▁reason ▁= ▁" compression " ▁; ▁goto ▁error ▁; ▁} ▁is v 34 ▁= ▁0 ▁; ▁tag hdrlen ▁= ▁6 ▁; ▁break ▁; ▁case ▁3 ▁: ▁case ▁4 ▁: ▁is v 34 ▁= ▁1 ▁; ▁tag hdrlen ▁= ▁10 ▁; ▁break ▁; ▁default ▁: ▁reason ▁= ▁" version " ▁; ▁goto ▁error ▁; ▁} ▁un sync ▁= ▁flags ▁& ▁0 x 80 ▁; ▁if ▁( ▁is v 34 ▁&& ▁flags ▁& ▁0 x 40 ▁) ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁get _ size ▁( ▁s ▁-> ▁pb ▁, ▁4 ▁) ▁) ▁; ▁while ▁( ▁len ▁>= ▁tag hdrlen ▁) ▁{ ▁unsigned ▁int ▁t flags ▁; ▁int ▁tun sync ▁= ▁0 ▁; ▁if ▁( ▁is v 34 ▁) ▁{ ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁tag ▁, ▁4 ▁) ▁; ▁tag ▁[ ▁4 ▁] ▁= ▁0 ▁; ▁if ▁( ▁version ▁== ▁3 ▁) ▁{ ▁tlen ▁= ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁} ▁else ▁tlen ▁= ▁get _ size ▁( ▁s ▁-> ▁pb ▁, ▁4 ▁) ▁; ▁t flags ▁= ▁avio _ rb 16 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁tun sync ▁= ▁t flags ▁& ▁ID 3 v 2_ FLAG _ UN SYN CH ▁; ▁} ▁else ▁{ ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁tag ▁, ▁3 ▁) ▁; ▁tag ▁[ ▁3 ▁] ▁= ▁0 ▁; ▁tlen ▁= ▁avio _ rb 24 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁} ▁if ▁( ▁tlen ▁< ▁0 ▁|| ▁tlen ▁> ▁len ▁- ▁tag hdrlen ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Invalid size in frame % s , sk ipping ther est oft ag .\ n " ▁, ▁tag ▁) ▁; ▁break ▁; ▁} ▁len ▁-= ▁tag hdrlen ▁+ ▁tlen ▁; ▁next ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁+ ▁tlen ▁; ▁if ▁( ▁t flags ▁& ▁ID 3 v 2_ FLAG _ D ATAL EN ▁) ▁{ ▁avio _ rb 32 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁tlen ▁-= ▁4 ▁; ▁} ▁if ▁( ▁t flags ▁& ▁( ▁ID 3 v 2_ FLAG _ ENCRYPTION ▁| ▁ID 3 v 2_ FLAG _ COMPRESSION ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Skipping encrypted / compressed ID 3 v 2 frame % s .\ n " ▁, ▁tag ▁) ▁; ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁tlen ▁) ▁; ▁} ▁else ▁if ▁( ▁tag ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁un sync ▁|| ▁tun sync ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁av _ fast _ malloc ▁( ▁& ▁buffer ▁, ▁& ▁buffer _ size ▁, ▁tlen ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁j ▁= ▁0 ▁; ▁i ▁< ▁tlen ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁{ ▁buffer ▁[ ▁j ▁] ▁= ▁avio _ r 8 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁if ▁( ▁j ▁> ▁0 ▁&& ▁! ▁buffer ▁[ ▁j ▁] ▁&& ▁buffer ▁[ ▁j ▁- ▁1 ▁] ▁== ▁0 xff ▁) ▁{ ▁j ▁-- ▁; ▁} ▁} ▁ff io _ init _ context ▁( ▁& ▁pb ▁, ▁buffer ▁, ▁j ▁, ▁0 ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁read _ tt ag ▁( ▁s ▁, ▁& ▁pb ▁, ▁j ▁, ▁tag ▁) ▁; ▁} ▁else ▁{ ▁read _ tt ag ▁( ▁s ▁, ▁s ▁-> ▁pb ▁, ▁tlen ▁, ▁tag ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁tag ▁[ ▁0 ▁] ▁) ▁{ ▁if ▁( ▁tag ▁[ ▁1 ▁] ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" invalid frame id , ass uming padding " ▁) ▁; ▁avio _ skip ▁( ▁s ▁-> ▁pb ▁, ▁tlen ▁) ▁; ▁break ▁; ▁} ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁next ▁, ▁SEEK _ SET ▁) ▁; ▁} ▁if ▁( ▁version ▁== ▁4 ▁&& ▁flags ▁& ▁0 x 10 ▁) ▁end ▁+= ▁10 ▁; ▁error ▁: ▁if ▁( ▁reason ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ INFO ▁, ▁" ID 3 v 2. % dt ag skipped , cannot handle % s \ n " ▁, ▁version ▁, ▁reason ▁) ▁; ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁end ▁, ▁SEEK _ SET ▁) ▁; ▁av _ free ▁( ▁buffer ▁) ▁; ▁return ▁; ▁}	0
▁int ▁av picture _ de inter lace ▁( ▁AV Picture ▁* ▁dst ▁, ▁const ▁AV Picture ▁* ▁src ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁int ▁i ▁, ▁ret ▁; ▁if ▁( ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ YUV 420 P ▁&& ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ YUV J 420 P ▁&& ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ YUV 422 P ▁&& ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ YUV J 422 P ▁&& ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ YUV 444 P ▁&& ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ YUV 411 P ▁&& ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ GRAY 8 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁( ▁width ▁& ▁3 ▁) ▁!= ▁0 ▁|| ▁( ▁height ▁& ▁3 ▁) ▁!= ▁0 ▁) ▁return ▁-1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁== ▁1 ▁) ▁{ ▁switch ▁( ▁pix _ fmt ▁) ▁{ ▁case ▁AV _ PIX _ FMT _ YUV J 420 P ▁: ▁case ▁AV _ PIX _ FMT _ YUV 420 P ▁: ▁width ▁>>= ▁1 ▁; ▁height ▁>>= ▁1 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ YUV 422 P ▁: ▁case ▁AV _ PIX _ FMT _ YUV J 422 P ▁: ▁width ▁>>= ▁1 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ YUV 411 P ▁: ▁width ▁>>= ▁2 ▁; ▁break ▁; ▁default ▁: ▁break ▁; ▁} ▁if ▁( ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ GRAY 8 ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁src ▁== ▁dst ▁) ▁{ ▁ret ▁= ▁de inter lace _ bottom _ field _ inplace ▁( ▁dst ▁-> ▁data ▁[ ▁i ▁] ▁, ▁dst ▁-> ▁linesize ▁[ ▁i ▁] ▁, ▁width ▁, ▁height ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁else ▁{ ▁de inter lace _ bottom _ field ▁( ▁dst ▁-> ▁data ▁[ ▁i ▁] ▁, ▁dst ▁-> ▁linesize ▁[ ▁i ▁] ▁, ▁src ▁-> ▁data ▁[ ▁i ▁] ▁, ▁src ▁-> ▁linesize ▁[ ▁i ▁] ▁, ▁width ▁, ▁height ▁) ▁; ▁} ▁} ▁e mm s _ c ▁( ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁BN _ ULONG ▁* ▁bn _ expand _ internal ▁( ▁const ▁BIGNUM ▁* ▁b ▁, ▁int ▁words ▁) ▁{ ▁BN _ ULONG ▁* ▁a ▁= ▁NULL ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁words ▁> ▁( ▁INT _ MAX ▁/ ▁( ▁4 ▁* ▁BN _ BITS 2 ▁) ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ EXPAND _ INTERNAL ▁, ▁BN _ R _ BIG NUM _ TOO _ LONG ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁BN _ get _ flags ▁( ▁b ▁, ▁BN _ FLG _ STATIC _ DATA ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ EXPAND _ INTERNAL ▁, ▁BN _ R _ EXPAND _ ON _ STATIC _ BIG NUM _ DATA ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁if ▁( ▁BN _ get _ flags ▁( ▁b ▁, ▁BN _ FLG _ SECURE ▁) ▁) ▁a ▁= ▁OPENSSL _ secure _ zalloc ▁( ▁words ▁* ▁sizeof ▁( ▁* ▁a ▁) ▁) ▁; ▁else ▁a ▁= ▁OPENSSL _ zalloc ▁( ▁words ▁* ▁sizeof ▁( ▁* ▁a ▁) ▁) ▁; ▁if ▁( ▁a ▁== ▁NULL ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ EXPAND _ INTERNAL ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁assert ▁( ▁b ▁-> ▁top ▁<= ▁words ▁) ▁; ▁if ▁( ▁b ▁-> ▁top ▁> ▁0 ▁) ▁memcpy ▁( ▁a ▁, ▁b ▁-> ▁d ▁, ▁sizeof ▁( ▁* ▁a ▁) ▁* ▁b ▁-> ▁top ▁) ▁; ▁return ▁a ▁; ▁}	1
▁static ▁void ▁proxy _ w st unnel _ callback ▁( ▁void ▁* ▁b ▁) ▁{ ▁int ▁status ▁; ▁apr _ socket _ t ▁* ▁sockets ▁[ ▁3 ▁] ▁= ▁{ ▁NULL ▁, ▁NULL ▁, ▁NULL ▁} ▁; ▁ws _ b aton _ t ▁* ▁bat on ▁= ▁( ▁ws _ b aton _ t ▁* ▁) ▁b ▁; ▁proxy ws _ dir _ conf ▁* ▁d conf ▁= ▁ap _ get _ module _ config ▁( ▁bat on ▁-> ▁r ▁-> ▁per _ dir _ config ▁, ▁& ▁proxy _ w st unnel _ module ▁) ▁; ▁apr _ pool _ clear ▁( ▁bat on ▁-> ▁sub pool ▁) ▁; ▁status ▁= ▁proxy _ w st unnel _ pu mp ▁( ▁bat on ▁, ▁d conf ▁-> ▁async _ delay ▁, ▁d conf ▁-> ▁is _ async ▁) ▁; ▁if ▁( ▁status ▁== ▁SUSP ENDED ▁) ▁{ ▁sockets ▁[ ▁0 ▁] ▁= ▁bat on ▁-> ▁client _ soc ▁; ▁sockets ▁[ ▁1 ▁] ▁= ▁bat on ▁-> ▁server _ soc ▁; ▁ap _ mp m _ register _ socket _ callback _ timeout ▁( ▁sockets ▁, ▁bat on ▁-> ▁sub pool ▁, ▁1 ▁, ▁proxy _ w st unnel _ callback ▁, ▁proxy _ w st unnel _ cancel _ callback ▁, ▁bat on ▁, ▁d conf ▁-> ▁idle _ timeout ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ TRACE 1 ▁, ▁0 ▁, ▁bat on ▁-> ▁r ▁, ▁" proxy _ w st unnel _ callback suspend " ▁) ▁; ▁} ▁else ▁{ ▁proxy _ w st unnel _ finish ▁( ▁bat on ▁) ▁; ▁} ▁}	0
▁static ▁int ▁ff _ as f _ get _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁) ▁{ ▁ASF Context ▁* ▁as f ▁= ▁s ▁-> ▁priv _ data ▁; ▁uint 32_ t ▁packet _ length ▁, ▁pad size ▁; ▁int ▁rsize ▁= ▁8 ▁; ▁int ▁c ▁, ▁d ▁, ▁e ▁, ▁off ▁; ▁off ▁= ▁32768 ▁; ▁if ▁( ▁s ▁-> ▁packet _ size ▁> ▁0 ▁) ▁off ▁= ▁( ▁avio _ tell ▁( ▁pb ▁) ▁- ▁s ▁-> ▁data _ offset ▁) ▁% ▁s ▁-> ▁packet _ size ▁+ ▁3 ▁; ▁c ▁= ▁d ▁= ▁e ▁= ▁-1 ▁; ▁while ▁( ▁off ▁-- ▁> ▁0 ▁) ▁{ ▁c ▁= ▁d ▁; ▁d ▁= ▁e ▁; ▁e ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁if ▁( ▁c ▁== ▁0 x 82 ▁&& ▁! ▁d ▁&& ▁! ▁e ▁) ▁break ▁; ▁} ▁if ▁( ▁c ▁!= ▁0 x 82 ▁) ▁{ ▁if ▁( ▁pb ▁-> ▁error ▁== ▁AVERROR ▁( ▁EAGAIN ▁) ▁) ▁return ▁AVERROR ▁( ▁EAGAIN ▁) ▁; ▁if ▁( ▁! ▁pb ▁-> ▁eof _ reached ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" ff as fb ad header % x at :% " ▁PRId 64 ▁"\ n " ▁, ▁c ▁, ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁} ▁if ▁( ▁( ▁c ▁& ▁0 x 8 f ▁) ▁== ▁0 x 82 ▁) ▁{ ▁if ▁( ▁d ▁|| ▁e ▁) ▁{ ▁if ▁( ▁! ▁pb ▁-> ▁eof _ reached ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" ff as fb ad non zero \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁c ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁d ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁rsize ▁+= ▁3 ▁; ▁} ▁else ▁{ ▁avio _ seek ▁( ▁pb ▁, ▁-1 ▁, ▁SEEK _ CUR ▁) ▁; ▁} ▁as f ▁-> ▁packet _ flags ▁= ▁c ▁; ▁as f ▁-> ▁packet _ property ▁= ▁d ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ flags ▁>> ▁5 ▁, ▁packet _ length ▁, ▁s ▁-> ▁packet _ size ▁) ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ flags ▁>> ▁1 ▁, ▁pad size ▁, ▁0 ▁) ▁; ▁DO _2 BITS ▁( ▁as f ▁-> ▁packet _ flags ▁>> ▁3 ▁, ▁pad size ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁packet _ length ▁|| ▁packet _ length ▁>= ▁( ▁1 U ▁<< ▁29 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid packet _ length % dat :% " ▁PRId 64 ▁"\ n " ▁, ▁packet _ length ▁, ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁pad size ▁>= ▁packet _ length ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid pad size % dat :% " ▁PRId 64 ▁"\ n " ▁, ▁pad size ▁, ▁avio _ tell ▁( ▁pb ▁) ▁) ▁; ▁return ▁-1 ▁; ▁} ▁as f ▁-> ▁packet _ timestamp ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁as f ▁-> ▁packet _ flags ▁& ▁0 x 01 ▁) ▁{ ▁as f ▁-> ▁packet _ segs iz etype ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁rsize ▁++ ▁; ▁as f ▁-> ▁packet _ segments ▁= ▁as f ▁-> ▁packet _ segs iz etype ▁& ▁0 x 3 f ▁; ▁} ▁else ▁{ ▁as f ▁-> ▁packet _ segments ▁= ▁1 ▁; ▁as f ▁-> ▁packet _ segs iz etype ▁= ▁0 x 80 ▁; ▁} ▁as f ▁-> ▁packet _ size _ left ▁= ▁packet _ length ▁- ▁pad size ▁- ▁rsize ▁; ▁if ▁( ▁packet _ length ▁< ▁as f ▁-> ▁hdr ▁. ▁min _ pkt size ▁) ▁pad size ▁+= ▁as f ▁-> ▁hdr ▁. ▁min _ pkt size ▁- ▁packet _ length ▁; ▁as f ▁-> ▁packet _ pad size ▁= ▁pad size ▁; ▁av _ d log ▁( ▁s ▁, ▁" packet : size =% dp ad size =% d left =% d \ n " ▁, ▁s ▁-> ▁packet _ size ▁, ▁as f ▁-> ▁packet _ pad size ▁, ▁as f ▁-> ▁packet _ size _ left ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁const ▁unsigned ▁char ▁* ▁authz _ find _ data ▁( ▁const ▁unsigned ▁char ▁* ▁authz ▁, ▁size _ t ▁authz _ length ▁, ▁unsigned ▁char ▁data _ type ▁, ▁size _ t ▁* ▁data _ length ▁) ▁{ ▁if ▁( ▁authz ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁! ▁authz _ validate ▁( ▁authz ▁, ▁authz _ length ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ AUTH Z _ FIND _ DATA ▁, ▁SSL _ R _ INVALID _ AUTH Z _ DATA ▁) ▁; ▁return ▁NULL ▁; ▁} ▁for ▁( ▁; ▁; ▁) ▁{ ▁unsigned ▁char ▁type ▁; ▁unsigned ▁short ▁len ▁; ▁if ▁( ▁! ▁authz _ length ▁) ▁return ▁NULL ▁; ▁type ▁= ▁* ▁( ▁authz ▁++ ▁) ▁; ▁authz _ length ▁-- ▁; ▁len ▁= ▁( ▁( ▁unsigned ▁short ▁) ▁authz ▁[ ▁0 ▁] ▁) ▁<< ▁8 ▁| ▁( ▁( ▁unsigned ▁short ▁) ▁authz ▁[ ▁1 ▁] ▁) ▁; ▁authz ▁+= ▁2 ▁; ▁authz _ length ▁-= ▁2 ▁; ▁if ▁( ▁type ▁== ▁data _ type ▁) ▁{ ▁* ▁data _ length ▁= ▁len ▁; ▁return ▁authz ▁; ▁} ▁authz ▁+= ▁len ▁; ▁authz _ length ▁-= ▁len ▁; ▁} ▁return ▁NULL ▁; ▁}	1
▁static ▁int 64_ t ▁scene _ s ad 16 ▁( ▁Frame Rate Context ▁* ▁s ▁, ▁const ▁uint 16_ t ▁* ▁p 1 ▁, ▁int ▁p 1_ lines ize ▁, ▁const ▁uint 16_ t ▁* ▁p 2 ▁, ▁int ▁p 2_ lines ize ▁, ▁const ▁int ▁width ▁, ▁const ▁int ▁height ▁) ▁{ ▁int 64_ t ▁sad ▁; ▁int ▁x ▁, ▁y ▁; ▁for ▁( ▁sad ▁= ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁- ▁7 ▁; ▁y ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁width ▁- ▁7 ▁; ▁x ▁+= ▁8 ▁) ▁{ ▁sad ▁+= ▁sad _8 x 8_ 16 ▁( ▁p 1 ▁+ ▁y ▁* ▁p 1_ lines ize ▁+ ▁x ▁, ▁p 1_ lines ize ▁, ▁p 2 ▁+ ▁y ▁* ▁p 2_ lines ize ▁+ ▁x ▁, ▁p 2_ lines ize ▁) ▁; ▁} ▁} ▁return ▁sad ▁; ▁}	0
▁static ▁apr _ status _ t ▁event _ register _ socket _ callback ▁( ▁apr _ socket _ t ▁* ▁* ▁s ▁, ▁apr _ pool _ t ▁* ▁p ▁, ▁int ▁for _ read ▁, ▁ap _ mp m _ callback _ fn _ t ▁* ▁cb fn ▁, ▁void ▁* ▁bat on ▁) ▁{ ▁apr _ status _ t ▁rc ▁, ▁final _ rc ▁= ▁APR _ SUCCESS ▁; ▁int ▁i ▁= ▁0 ▁, ▁ns ock ▁; ▁socket _ callback _ b aton _ t ▁* ▁scb ▁= ▁apr _ pc alloc ▁( ▁p ▁, ▁sizeof ▁( ▁* ▁scb ▁) ▁) ▁; ▁listener _ poll _ type ▁* ▁pt ▁= ▁apr _ palloc ▁( ▁p ▁, ▁sizeof ▁( ▁* ▁pt ▁) ▁) ▁; ▁apr _ pol lfd _ t ▁* ▁* ▁pf ds ▁= ▁NULL ▁; ▁while ▁( ▁s ▁[ ▁i ▁] ▁!= ▁NULL ▁) ▁{ ▁i ▁++ ▁; ▁} ▁ns ock ▁= ▁i ▁; ▁pf ds ▁= ▁apr _ palloc ▁( ▁p ▁, ▁ns ock ▁* ▁sizeof ▁( ▁apr _ pol lfd _ t ▁* ▁) ▁) ▁; ▁pt ▁-> ▁type ▁= ▁PT _ USER ▁; ▁pt ▁-> ▁bat on ▁= ▁scb ▁; ▁scb ▁-> ▁cb func ▁= ▁cb fn ▁; ▁scb ▁-> ▁user _ b aton ▁= ▁bat on ▁; ▁scb ▁-> ▁ns ock ▁= ▁ns ock ▁; ▁scb ▁-> ▁pf ds ▁= ▁pf ds ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ns ock ▁; ▁i ▁++ ▁) ▁{ ▁pf ds ▁[ ▁i ▁] ▁= ▁apr _ palloc ▁( ▁p ▁, ▁sizeof ▁( ▁apr _ pol lfd _ t ▁) ▁) ▁; ▁pf ds ▁[ ▁i ▁] ▁-> ▁desc _ type ▁= ▁APR _ POLL _ SOCKET ▁; ▁pf ds ▁[ ▁i ▁] ▁-> ▁req events ▁= ▁( ▁for _ read ▁? ▁APR _ POLL IN ▁: ▁APR _ POL LOUT ▁) ▁| ▁APR _ POLL ERR ▁| ▁APR _ POLL HUP ▁; ▁pf ds ▁[ ▁i ▁] ▁-> ▁desc ▁. ▁s ▁= ▁s ▁[ ▁i ▁] ▁; ▁pf ds ▁[ ▁i ▁] ▁-> ▁client _ data ▁= ▁pt ▁; ▁rc ▁= ▁apr _ poll set _ add ▁( ▁event _ poll set ▁, ▁pf ds ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁rc ▁!= ▁APR _ SUCCESS ▁) ▁final _ rc ▁= ▁rc ▁; ▁} ▁return ▁final _ rc ▁; ▁}	1
▁static ▁int ▁tg v _ decode _ inter ▁( ▁T gv Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁const ▁uint 8_ t ▁* ▁buf _ end ▁) ▁{ ▁int ▁num _ m vs ▁; ▁int ▁num _ blocks _ raw ▁; ▁int ▁num _ blocks _ packed ▁; ▁int ▁vector _ bits ▁; ▁int ▁i ▁, ▁j ▁, ▁x ▁, ▁y ▁; ▁Get Bit Context ▁gb ▁; ▁int ▁mv bits ▁; ▁const ▁unsigned ▁char ▁* ▁blocks _ raw ▁; ▁if ▁( ▁buf ▁+ ▁12 ▁> ▁buf _ end ▁) ▁return ▁-1 ▁; ▁num _ m vs ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁0 ▁] ▁) ▁; ▁num _ blocks _ raw ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁2 ▁] ▁) ▁; ▁num _ blocks _ packed ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁4 ▁] ▁) ▁; ▁vector _ bits ▁= ▁AV _ RL 16 ▁( ▁& ▁buf ▁[ ▁6 ▁] ▁) ▁; ▁buf ▁+= ▁12 ▁; ▁if ▁( ▁num _ m vs ▁> ▁s ▁-> ▁num _ m vs ▁) ▁{ ▁s ▁-> ▁mv _ code book ▁= ▁av _ realloc ▁( ▁s ▁-> ▁mv _ code book ▁, ▁num _ m vs ▁* ▁2 ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁s ▁-> ▁num _ m vs ▁= ▁num _ m vs ▁; ▁} ▁if ▁( ▁num _ blocks _ packed ▁> ▁s ▁-> ▁num _ blocks _ packed ▁) ▁{ ▁s ▁-> ▁block _ code book ▁= ▁av _ realloc ▁( ▁s ▁-> ▁block _ code book ▁, ▁num _ blocks _ packed ▁* ▁16 ▁* ▁sizeof ▁( ▁unsigned ▁char ▁) ▁) ▁; ▁s ▁-> ▁num _ blocks _ packed ▁= ▁num _ blocks _ packed ▁; ▁} ▁mv bits ▁= ▁( ▁num _ m vs ▁* ▁2 ▁* ▁10 ▁+ ▁31 ▁) ▁& ▁ ~ ▁31 ▁; ▁if ▁( ▁buf ▁+ ▁( ▁mv bits ▁>> ▁3 ▁) ▁+ ▁16 ▁* ▁num _ blocks _ raw ▁+ ▁8 ▁* ▁num _ blocks _ packed ▁> ▁buf _ end ▁) ▁return ▁-1 ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁mv bits ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ m vs ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁mv _ code book ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁get _ s bits ▁( ▁& ▁gb ▁, ▁10 ▁) ▁; ▁s ▁-> ▁mv _ code book ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁get _ s bits ▁( ▁& ▁gb ▁, ▁10 ▁) ▁; ▁} ▁buf ▁+= ▁mv bits ▁>> ▁3 ▁; ▁blocks _ raw ▁= ▁buf ▁; ▁buf ▁+= ▁num _ blocks _ raw ▁* ▁16 ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁( ▁buf _ end ▁- ▁buf ▁) ▁<< ▁3 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ blocks _ packed ▁; ▁i ▁++ ▁) ▁{ ▁int ▁tmp ▁[ ▁4 ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁tmp ▁[ ▁j ▁] ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁8 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁s ▁-> ▁block _ code book ▁[ ▁i ▁] ▁[ ▁15 ▁- ▁j ▁] ▁= ▁tmp ▁[ ▁get _ bits ▁( ▁& ▁gb ▁, ▁2 ▁) ▁] ▁; ▁} ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁gb ▁) ▁< ▁vector _ bits ▁* ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁/ ▁4 ▁) ▁* ▁( ▁s ▁-> ▁avctx ▁-> ▁width ▁/ ▁4 ▁) ▁) ▁return ▁-1 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁s ▁-> ▁avctx ▁-> ▁height ▁/ ▁4 ▁; ▁y ▁++ ▁) ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁s ▁-> ▁avctx ▁-> ▁width ▁/ ▁4 ▁; ▁x ▁++ ▁) ▁{ ▁unsigned ▁int ▁vector ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁vector _ bits ▁) ▁; ▁const ▁unsigned ▁char ▁* ▁src ▁; ▁int ▁src _ stride ▁; ▁if ▁( ▁vector ▁< ▁num _ m vs ▁) ▁{ ▁int ▁mx ▁= ▁x ▁* ▁4 ▁+ ▁s ▁-> ▁mv _ code book ▁[ ▁vector ▁] ▁[ ▁0 ▁] ▁; ▁int ▁my ▁= ▁y ▁* ▁4 ▁+ ▁s ▁-> ▁mv _ code book ▁[ ▁vector ▁] ▁[ ▁1 ▁] ▁; ▁if ▁( ▁mx ▁< ▁0 ▁|| ▁mx ▁+ ▁4 ▁> ▁s ▁-> ▁avctx ▁-> ▁width ▁|| ▁my ▁< ▁0 ▁|| ▁my ▁+ ▁4 ▁> ▁s ▁-> ▁avctx ▁-> ▁height ▁) ▁continue ▁; ▁src ▁= ▁s ▁-> ▁last _ frame ▁. ▁data ▁[ ▁0 ▁] ▁+ ▁mx ▁+ ▁my ▁* ▁s ▁-> ▁last _ frame ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁src _ stride ▁= ▁s ▁-> ▁last _ frame ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁} ▁else ▁{ ▁int ▁offset ▁= ▁vector ▁- ▁num _ m vs ▁; ▁if ▁( ▁offset ▁< ▁num _ blocks _ raw ▁) ▁src ▁= ▁blocks _ raw ▁+ ▁16 ▁* ▁offset ▁; ▁else ▁if ▁( ▁offset ▁- ▁num _ blocks _ raw ▁< ▁num _ blocks _ packed ▁) ▁src ▁= ▁s ▁-> ▁block _ code book ▁[ ▁offset ▁- ▁num _ blocks _ raw ▁] ▁; ▁else ▁continue ▁; ▁src _ stride ▁= ▁4 ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁0 ▁] ▁[ ▁( ▁y ▁* ▁4 ▁+ ▁j ▁) ▁* ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁+ ▁( ▁x ▁* ▁4 ▁+ ▁i ▁) ▁] ▁= ▁src ▁[ ▁j ▁* ▁src _ stride ▁+ ▁i ▁] ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁stereo _ processing ▁( ▁PS Context ▁* ▁ps ▁, ▁float ▁( ▁* ▁l ▁) ▁[ ▁32 ▁] ▁[ ▁2 ▁] ▁, ▁float ▁( ▁* ▁r ▁) ▁[ ▁32 ▁] ▁[ ▁2 ▁] ▁, ▁int ▁is 34 ▁) ▁{ ▁int ▁e ▁, ▁b ▁, ▁k ▁; ▁float ▁( ▁* ▁H 11 ▁) ▁[ ▁PS _ MAX _ NUM _ ENV ▁+ ▁1 ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁ps ▁-> ▁H 11 ▁; ▁float ▁( ▁* ▁H 12 ▁) ▁[ ▁PS _ MAX _ NUM _ ENV ▁+ ▁1 ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁ps ▁-> ▁H 12 ▁; ▁float ▁( ▁* ▁H 21 ▁) ▁[ ▁PS _ MAX _ NUM _ ENV ▁+ ▁1 ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁ps ▁-> ▁H 21 ▁; ▁float ▁( ▁* ▁H 22 ▁) ▁[ ▁PS _ MAX _ NUM _ ENV ▁+ ▁1 ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁ps ▁-> ▁H 22 ▁; ▁int 8_ t ▁* ▁o pd _ hist ▁= ▁ps ▁-> ▁o pd _ hist ▁; ▁int 8_ t ▁* ▁ipd _ hist ▁= ▁ps ▁-> ▁ipd _ hist ▁; ▁int 8_ t ▁iid _ mapped _ buf ▁[ ▁PS _ MAX _ NUM _ ENV ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁; ▁int 8_ t ▁ic c _ mapped _ buf ▁[ ▁PS _ MAX _ NUM _ ENV ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁; ▁int 8_ t ▁ipd _ mapped _ buf ▁[ ▁PS _ MAX _ NUM _ ENV ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁; ▁int 8_ t ▁o pd _ mapped _ buf ▁[ ▁PS _ MAX _ NUM _ ENV ▁] ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁; ▁int 8_ t ▁( ▁* ▁iid _ mapped ▁) ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁iid _ mapped _ buf ▁; ▁int 8_ t ▁( ▁* ▁ic c _ mapped ▁) ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁ic c _ mapped _ buf ▁; ▁int 8_ t ▁( ▁* ▁ipd _ mapped ▁) ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁ipd _ mapped _ buf ▁; ▁int 8_ t ▁( ▁* ▁o pd _ mapped ▁) ▁[ ▁PS _ MAX _ NR _ IID ICC ▁] ▁= ▁o pd _ mapped _ buf ▁; ▁const ▁int 8_ t ▁* ▁k _ to _ i ▁= ▁is 34 ▁? ▁k _ to _ i _ 34 ▁: ▁k _ to _ i _20 ▁; ▁TABLE _ CONST ▁float ▁( ▁* ▁H _ LUT ▁) ▁[ ▁8 ▁] ▁[ ▁4 ▁] ▁= ▁( ▁PS _ BAS ELINE ▁|| ▁ps ▁-> ▁ic c _ mode ▁< ▁3 ▁) ▁? ▁HA ▁: ▁H B ▁; ▁if ▁( ▁ps ▁-> ▁num _ env _ old ▁) ▁{ ▁memcpy ▁( ▁H 11 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁H 11 ▁[ ▁0 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 11 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁H 11 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁H 11 ▁[ ▁1 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 11 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁H 12 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁H 12 ▁[ ▁0 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 12 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁H 12 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁H 12 ▁[ ▁1 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 12 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁H 21 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁H 21 ▁[ ▁0 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 21 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁H 21 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁H 21 ▁[ ▁1 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 21 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁H 22 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁H 22 ▁[ ▁0 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 22 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁memcpy ▁( ▁H 22 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁H 22 ▁[ ▁1 ▁] ▁[ ▁ps ▁-> ▁num _ env _ old ▁] ▁, ▁PS _ MAX _ NR _ IID ICC ▁* ▁sizeof ▁( ▁H 22 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁} ▁if ▁( ▁is 34 ▁) ▁{ ▁remap 34 ▁( ▁& ▁iid _ mapped ▁, ▁ps ▁-> ▁iid _ par ▁, ▁ps ▁-> ▁nr _ i id _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁1 ▁) ▁; ▁remap 34 ▁( ▁& ▁ic c _ mapped ▁, ▁ps ▁-> ▁ic c _ par ▁, ▁ps ▁-> ▁nr _ icc _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁1 ▁) ▁; ▁if ▁( ▁ps ▁-> ▁enable _ ip d op d ▁) ▁{ ▁remap 34 ▁( ▁& ▁ipd _ mapped ▁, ▁ps ▁-> ▁ipd _ par ▁, ▁ps ▁-> ▁nr _ ip d op d _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁0 ▁) ▁; ▁remap 34 ▁( ▁& ▁o pd _ mapped ▁, ▁ps ▁-> ▁o pd _ par ▁, ▁ps ▁-> ▁nr _ ip d op d _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁0 ▁) ▁; ▁} ▁if ▁( ▁! ▁ps ▁-> ▁is 34 band s _ old ▁) ▁{ ▁map _ val _2 0_ to _ 34 ▁( ▁H 11 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _2 0_ to _ 34 ▁( ▁H 11 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _2 0_ to _ 34 ▁( ▁H 12 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _2 0_ to _ 34 ▁( ▁H 12 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _2 0_ to _ 34 ▁( ▁H 21 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _2 0_ to _ 34 ▁( ▁H 21 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _2 0_ to _ 34 ▁( ▁H 22 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _2 0_ to _ 34 ▁( ▁H 22 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁ipd op d _ reset ▁( ▁ipd _ hist ▁, ▁o pd _ hist ▁) ▁; ▁} ▁} ▁else ▁{ ▁remap 20 ▁( ▁& ▁iid _ mapped ▁, ▁ps ▁-> ▁iid _ par ▁, ▁ps ▁-> ▁nr _ i id _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁1 ▁) ▁; ▁remap 20 ▁( ▁& ▁ic c _ mapped ▁, ▁ps ▁-> ▁ic c _ par ▁, ▁ps ▁-> ▁nr _ icc _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁1 ▁) ▁; ▁if ▁( ▁ps ▁-> ▁enable _ ip d op d ▁) ▁{ ▁remap 20 ▁( ▁& ▁ipd _ mapped ▁, ▁ps ▁-> ▁ipd _ par ▁, ▁ps ▁-> ▁nr _ ip d op d _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁0 ▁) ▁; ▁remap 20 ▁( ▁& ▁o pd _ mapped ▁, ▁ps ▁-> ▁o pd _ par ▁, ▁ps ▁-> ▁nr _ ip d op d _ par ▁, ▁ps ▁-> ▁num _ env ▁, ▁0 ▁) ▁; ▁} ▁if ▁( ▁ps ▁-> ▁is 34 band s _ old ▁) ▁{ ▁map _ val _3 4_ to _20 ▁( ▁H 11 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _3 4_ to _20 ▁( ▁H 11 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _3 4_ to _20 ▁( ▁H 12 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _3 4_ to _20 ▁( ▁H 12 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _3 4_ to _20 ▁( ▁H 21 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _3 4_ to _20 ▁( ▁H 21 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _3 4_ to _20 ▁( ▁H 22 ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁map _ val _3 4_ to _20 ▁( ▁H 22 ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁ipd op d _ reset ▁( ▁ipd _ hist ▁, ▁o pd _ hist ▁) ▁; ▁} ▁} ▁for ▁( ▁e ▁= ▁0 ▁; ▁e ▁< ▁ps ▁-> ▁num _ env ▁; ▁e ▁++ ▁) ▁{ ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁< ▁NR _ PAR _ BAND S ▁[ ▁is 34 ▁] ▁; ▁b ▁++ ▁) ▁{ ▁float ▁h 11 ▁, ▁h 12 ▁, ▁h 21 ▁, ▁h 22 ▁; ▁h 11 ▁= ▁H _ LUT ▁[ ▁iid _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁+ ▁7 ▁+ ▁23 ▁* ▁ps ▁-> ▁iid _ quant ▁] ▁[ ▁ic c _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁] ▁[ ▁0 ▁] ▁; ▁h 12 ▁= ▁H _ LUT ▁[ ▁iid _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁+ ▁7 ▁+ ▁23 ▁* ▁ps ▁-> ▁iid _ quant ▁] ▁[ ▁ic c _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁] ▁[ ▁1 ▁] ▁; ▁h 21 ▁= ▁H _ LUT ▁[ ▁iid _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁+ ▁7 ▁+ ▁23 ▁* ▁ps ▁-> ▁iid _ quant ▁] ▁[ ▁ic c _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁] ▁[ ▁2 ▁] ▁; ▁h 22 ▁= ▁H _ LUT ▁[ ▁iid _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁+ ▁7 ▁+ ▁23 ▁* ▁ps ▁-> ▁iid _ quant ▁] ▁[ ▁ic c _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁] ▁[ ▁3 ▁] ▁; ▁if ▁( ▁! ▁PS _ BAS ELINE ▁&& ▁ps ▁-> ▁enable _ ip d op d ▁&& ▁b ▁< ▁NR _ IP D OP D _ BAND S ▁[ ▁is 34 ▁] ▁) ▁{ ▁float ▁h 11 i ▁, ▁h 12 i ▁, ▁h 21 i ▁, ▁h 22 i ▁; ▁float ▁ipd _ adj _ re ▁, ▁ipd _ adj _ im ▁; ▁int ▁o pd _ idx ▁= ▁o pd _ hist ▁[ ▁b ▁] ▁* ▁8 ▁+ ▁o pd _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁int ▁ipd _ idx ▁= ▁ipd _ hist ▁[ ▁b ▁] ▁* ▁8 ▁+ ▁ipd _ mapped ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁float ▁o pd _ re ▁= ▁pd _ re _ smooth ▁[ ▁o pd _ idx ▁] ▁; ▁float ▁o pd _ im ▁= ▁pd _ im _ smooth ▁[ ▁o pd _ idx ▁] ▁; ▁float ▁ipd _ re ▁= ▁pd _ re _ smooth ▁[ ▁ipd _ idx ▁] ▁; ▁float ▁ipd _ im ▁= ▁pd _ im _ smooth ▁[ ▁ipd _ idx ▁] ▁; ▁o pd _ hist ▁[ ▁b ▁] ▁= ▁o pd _ idx ▁& ▁0 x 3 F ▁; ▁ipd _ hist ▁[ ▁b ▁] ▁= ▁ipd _ idx ▁& ▁0 x 3 F ▁; ▁ipd _ adj _ re ▁= ▁o pd _ re ▁* ▁ipd _ re ▁+ ▁o pd _ im ▁* ▁ipd _ im ▁; ▁ipd _ adj _ im ▁= ▁o pd _ im ▁* ▁ipd _ re ▁- ▁o pd _ re ▁* ▁ipd _ im ▁; ▁h 11 i ▁= ▁h 11 ▁* ▁o pd _ im ▁; ▁h 11 ▁= ▁h 11 ▁* ▁o pd _ re ▁; ▁h 12 i ▁= ▁h 12 ▁* ▁ipd _ adj _ im ▁; ▁h 12 ▁= ▁h 12 ▁* ▁ipd _ adj _ re ▁; ▁h 21 i ▁= ▁h 21 ▁* ▁o pd _ im ▁; ▁h 21 ▁= ▁h 21 ▁* ▁o pd _ re ▁; ▁h 22 i ▁= ▁h 22 ▁* ▁ipd _ adj _ im ▁; ▁h 22 ▁= ▁h 22 ▁* ▁ipd _ adj _ re ▁; ▁H 11 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 11 i ▁; ▁H 12 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 12 i ▁; ▁H 21 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 21 i ▁; ▁H 22 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 22 i ▁; ▁} ▁H 11 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 11 ▁; ▁H 12 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 12 ▁; ▁H 21 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 21 ▁; ▁H 22 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁= ▁h 22 ▁; ▁} ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁NR _ BAND S ▁[ ▁is 34 ▁] ▁; ▁k ▁++ ▁) ▁{ ▁float ▁h ▁[ ▁2 ▁] ▁[ ▁4 ▁] ▁; ▁float ▁h _ step ▁[ ▁2 ▁] ▁[ ▁4 ▁] ▁; ▁int ▁start ▁= ▁ps ▁-> ▁border _ position ▁[ ▁e ▁] ▁; ▁int ▁stop ▁= ▁ps ▁-> ▁border _ position ▁[ ▁e ▁+ ▁1 ▁] ▁; ▁float ▁width ▁= ▁1. f ▁/ ▁( ▁stop ▁- ▁start ▁) ▁; ▁b ▁= ▁k _ to _ i ▁[ ▁k ▁] ▁; ▁h ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁H 11 ▁[ ▁0 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁H 12 ▁[ ▁0 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁0 ▁] ▁[ ▁2 ▁] ▁= ▁H 21 ▁[ ▁0 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁0 ▁] ▁[ ▁3 ▁] ▁= ▁H 22 ▁[ ▁0 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁if ▁( ▁! ▁PS _ BAS ELINE ▁&& ▁ps ▁-> ▁enable _ ip d op d ▁) ▁{ ▁if ▁( ▁( ▁is 34 ▁&& ▁k ▁<= ▁13 ▁&& ▁k ▁>= ▁9 ▁) ▁|| ▁( ▁! ▁is 34 ▁&& ▁k ▁<= ▁1 ▁) ▁) ▁{ ▁h ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁- ▁H 11 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁- ▁H 12 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁1 ▁] ▁[ ▁2 ▁] ▁= ▁- ▁H 21 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁1 ▁] ▁[ ▁3 ▁] ▁= ▁- ▁H 22 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁} ▁else ▁{ ▁h ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁H 11 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁H 12 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁1 ▁] ▁[ ▁2 ▁] ▁= ▁H 21 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁h ▁[ ▁1 ▁] ▁[ ▁3 ▁] ▁= ▁H 22 ▁[ ▁1 ▁] ▁[ ▁e ▁] ▁[ ▁b ▁] ▁; ▁} ▁} ▁h _ step ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁( ▁H 11 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁* ▁width ▁; ▁h _ step ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁( ▁H 12 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁) ▁* ▁width ▁; ▁h _ step ▁[ ▁0 ▁] ▁[ ▁2 ▁] ▁= ▁( ▁H 21 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁0 ▁] ▁[ ▁2 ▁] ▁) ▁* ▁width ▁; ▁h _ step ▁[ ▁0 ▁] ▁[ ▁3 ▁] ▁= ▁( ▁H 22 ▁[ ▁0 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁0 ▁] ▁[ ▁3 ▁] ▁) ▁* ▁width ▁; ▁if ▁( ▁! ▁PS _ BAS ELINE ▁&& ▁ps ▁-> ▁enable _ ip d op d ▁) ▁{ ▁h _ step ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁( ▁H 11 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁* ▁width ▁; ▁h _ step ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁( ▁H 12 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁* ▁width ▁; ▁h _ step ▁[ ▁1 ▁] ▁[ ▁2 ▁] ▁= ▁( ▁H 21 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁1 ▁] ▁[ ▁2 ▁] ▁) ▁* ▁width ▁; ▁h _ step ▁[ ▁1 ▁] ▁[ ▁3 ▁] ▁= ▁( ▁H 22 ▁[ ▁1 ▁] ▁[ ▁e ▁+ ▁1 ▁] ▁[ ▁b ▁] ▁- ▁h ▁[ ▁1 ▁] ▁[ ▁3 ▁] ▁) ▁* ▁width ▁; ▁} ▁ps ▁-> ▁dsp ▁. ▁stereo _ interpolate ▁[ ▁! ▁PS _ BAS ELINE ▁&& ▁ps ▁-> ▁enable _ ip d op d ▁] ▁( ▁l ▁[ ▁k ▁] ▁+ ▁start ▁+ ▁1 ▁, ▁r ▁[ ▁k ▁] ▁+ ▁start ▁+ ▁1 ▁, ▁h ▁, ▁h _ step ▁, ▁stop ▁- ▁start ▁) ▁; ▁} ▁} ▁}	0
▁static ▁inline ▁int ▁get _ e go lo mb ▁( ▁Get Bit Context ▁* ▁gb ▁) ▁{ ▁int ▁v ▁= ▁4 ▁; ▁while ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁v ▁++ ▁; ▁return ▁( ▁1 ▁<< ▁v ▁) ▁+ ▁get _ bits ▁( ▁gb ▁, ▁v ▁) ▁; ▁}	1
▁static ▁void ▁vc 1_ decode _ b _ blocks ▁( ▁VC 1 Context ▁* ▁v ▁) ▁{ ▁Mpeg Enc Context ▁* ▁s ▁= ▁& ▁v ▁-> ▁s ▁; ▁switch ▁( ▁v ▁-> ▁c _ ac _ table _ index ▁) ▁{ ▁case ▁0 ▁: ▁v ▁-> ▁coding set ▁= ▁( ▁v ▁-> ▁pq index ▁<= ▁8 ▁) ▁? ▁CS _ HIGH _ RATE _ INTR A ▁: ▁CS _ LOW _ MO T _ INTR A ▁; ▁break ▁; ▁case ▁1 ▁: ▁v ▁-> ▁coding set ▁= ▁CS _ HIGH _ MO T _ INTR A ▁; ▁break ▁; ▁case ▁2 ▁: ▁v ▁-> ▁coding set ▁= ▁CS _ MID _ RATE _ INTR A ▁; ▁break ▁; ▁} ▁switch ▁( ▁v ▁-> ▁c _ ac _ table _ index ▁) ▁{ ▁case ▁0 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁( ▁v ▁-> ▁pq index ▁<= ▁8 ▁) ▁? ▁CS _ HIGH _ RATE _ INTER ▁: ▁CS _ LOW _ MO T _ INTER ▁; ▁break ▁; ▁case ▁1 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁CS _ HIGH _ MO T _ INTER ▁; ▁break ▁; ▁case ▁2 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁CS _ MID _ RATE _ INTER ▁; ▁break ▁; ▁} ▁s ▁-> ▁first _ slice _ line ▁= ▁1 ▁; ▁for ▁( ▁s ▁-> ▁mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁mb _ y ▁< ▁s ▁-> ▁mb _ height ▁; ▁s ▁-> ▁mb _ y ▁++ ▁) ▁{ ▁for ▁( ▁s ▁-> ▁mb _ x ▁= ▁0 ▁; ▁s ▁-> ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁s ▁-> ▁mb _ x ▁++ ▁) ▁{ ▁ff _ init _ block _ index ▁( ▁s ▁) ▁; ▁ff _ update _ block _ index ▁( ▁s ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁clear _ blocks ▁( ▁s ▁-> ▁block ▁[ ▁0 ▁] ▁) ▁; ▁vc 1_ decode _ b _ mb ▁( ▁v ▁) ▁; ▁if ▁( ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁> ▁v ▁-> ▁bits ▁|| ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁0 ▁) ▁{ ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁0 ▁, ▁0 ▁, ▁s ▁-> ▁mb _ x ▁, ▁s ▁-> ▁mb _ y ▁, ▁( ▁AC _ END ▁| ▁DC _ END ▁| ▁MV _ END ▁) ▁) ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bits over cons umption :% i >% i at % ix % i \ n " ▁, ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁, ▁v ▁-> ▁bits ▁, ▁s ▁-> ▁mb _ x ▁, ▁s ▁-> ▁mb _ y ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁v ▁-> ▁s ▁. ▁loop _ filter ▁) ▁vc 1_ loop _ filter _ ib lk ▁( ▁s ▁, ▁s ▁-> ▁current _ picture ▁. ▁q scale _ table ▁[ ▁s ▁-> ▁mb _ x ▁+ ▁s ▁-> ▁mb _ y ▁* ▁s ▁-> ▁mb _ stride ▁] ▁) ▁; ▁} ▁ff _ draw _ h oriz _ band ▁( ▁s ▁, ▁s ▁-> ▁mb _ y ▁* ▁16 ▁, ▁16 ▁) ▁; ▁s ▁-> ▁first _ slice _ line ▁= ▁0 ▁; ▁} ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁0 ▁, ▁0 ▁, ▁s ▁-> ▁mb _ width ▁- ▁1 ▁, ▁s ▁-> ▁mb _ height ▁- ▁1 ▁, ▁( ▁AC _ END ▁| ▁DC _ END ▁| ▁MV _ END ▁) ▁) ▁; ▁}	1
▁static ▁int ▁instantiate ▁( ▁RAND _ DR BG ▁* ▁dr bg ▁, ▁DR BG _ SELF TEST _ DATA ▁* ▁td ▁, ▁TEST _ CTX ▁* ▁t ▁) ▁{ ▁if ▁( ▁! ▁TEST _ true ▁( ▁init ▁( ▁dr bg ▁, ▁td ▁, ▁t ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁RAND _ DR BG _ instantiate ▁( ▁dr bg ▁, ▁td ▁-> ▁pers ▁, ▁td ▁-> ▁pers len ▁) ▁) ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁}	0
▁void ▁BN _ CTX _ end ▁( ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁CTX DBG _ ENTRY ▁( ▁" BN _ CTX _ end " ▁, ▁ctx ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁err _ stack ▁) ▁ctx ▁-> ▁err _ stack ▁-- ▁; ▁else ▁{ ▁unsigned ▁int ▁fp ▁= ▁BN _ STACK _ pop ▁( ▁& ▁ctx ▁-> ▁stack ▁) ▁; ▁if ▁( ▁fp ▁< ▁ctx ▁-> ▁used ▁) ▁BN _ POOL _ release ▁( ▁& ▁ctx ▁-> ▁pool ▁, ▁ctx ▁-> ▁used ▁- ▁fp ▁) ▁; ▁ctx ▁-> ▁used ▁= ▁fp ▁; ▁ctx ▁-> ▁too _ many ▁= ▁0 ▁; ▁} ▁CTX DBG _ EXIT ▁( ▁ctx ▁) ▁; ▁}	1
▁static ▁void ▁put _ eb ml _ uint ▁( ▁Byte IO Context ▁* ▁pb ▁, ▁unsigned ▁int ▁element id ▁, ▁uint 64_ t ▁val ▁) ▁{ ▁int ▁i ▁, ▁bytes ▁= ▁1 ▁; ▁while ▁( ▁val ▁>> ▁bytes ▁* ▁8 ▁) ▁bytes ▁++ ▁; ▁put _ eb ml _ id ▁( ▁pb ▁, ▁element id ▁) ▁; ▁put _ eb ml _ num ▁( ▁pb ▁, ▁bytes ▁, ▁0 ▁) ▁; ▁for ▁( ▁i ▁= ▁bytes ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁put _ byte ▁( ▁pb ▁, ▁val ▁>> ▁i ▁* ▁8 ▁) ▁; ▁}	1
▁char ▁* ▁lh _ insert ▁( ▁L HASH ▁* ▁lh ▁, ▁char ▁* ▁data ▁) ▁{ ▁unsigned ▁long ▁hash ▁; ▁L HASH _ NODE ▁* ▁nn ▁, ▁* ▁* ▁rn ▁; ▁char ▁* ▁ret ▁; ▁lh ▁-> ▁error ▁= ▁0 ▁; ▁if ▁( ▁lh ▁-> ▁up _ load ▁<= ▁( ▁lh ▁-> ▁num _ items ▁* ▁L H _ LOAD _ MULT ▁/ ▁lh ▁-> ▁num _ nodes ▁) ▁) ▁expand ▁( ▁lh ▁) ▁; ▁rn ▁= ▁get rn ▁( ▁lh ▁, ▁data ▁, ▁& ▁hash ▁) ▁; ▁if ▁( ▁* ▁rn ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁nn ▁= ▁( ▁L HASH _ NODE ▁* ▁) ▁Malloc ▁( ▁sizeof ▁( ▁L HASH _ NODE ▁) ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁lh ▁-> ▁error ▁++ ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁nn ▁-> ▁data ▁= ▁data ▁; ▁nn ▁-> ▁next ▁= ▁NULL ▁; ▁# ifndef ▁NO _ HASH _ COMP ▁nn ▁-> ▁hash ▁= ▁hash ▁; ▁# endif ▁* ▁rn ▁= ▁nn ▁; ▁ret ▁= ▁NULL ▁; ▁lh ▁-> ▁num _ insert ▁++ ▁; ▁lh ▁-> ▁num _ items ▁++ ▁; ▁} ▁else ▁{ ▁ret ▁= ▁( ▁* ▁rn ▁) ▁-> ▁data ▁; ▁( ▁* ▁rn ▁) ▁-> ▁data ▁= ▁data ▁; ▁lh ▁-> ▁num _ replace ▁++ ▁; ▁} ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁int ▁ossl _ name map _ add ▁( ▁OSSL _ NAME MAP ▁* ▁name map ▁, ▁int ▁number ▁, ▁const ▁char ▁* ▁name ▁) ▁{ ▁NAM ENUM _ ENTRY ▁* ▁nam enum ▁= ▁NULL ▁; ▁int ▁tmp _ number ▁; ▁# ifndef ▁FIPS _ MODE ▁if ▁( ▁name map ▁== ▁NULL ▁) ▁name map ▁= ▁ossl _ name map _ stored ▁( ▁NULL ▁) ▁; ▁# endif ▁if ▁( ▁name ▁== ▁NULL ▁|| ▁name map ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁( ▁tmp _ number ▁= ▁ossl _ name map _ name 2 num ▁( ▁name map ▁, ▁name ▁) ▁) ▁!= ▁0 ▁) ▁return ▁tmp _ number ▁; ▁CRYPTO _ THREAD _ write _ lock ▁( ▁name map ▁-> ▁lock ▁) ▁; ▁if ▁( ▁( ▁nam enum ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁nam enum ▁) ▁) ▁) ▁== ▁NULL ▁|| ▁( ▁nam enum ▁-> ▁name ▁= ▁OPENSSL _ strdup ▁( ▁name ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁nam enum ▁-> ▁number ▁= ▁tmp _ number ▁= ▁number ▁!= ▁0 ▁? ▁number ▁: ▁++ ▁name map ▁-> ▁max _ number ▁; ▁( ▁void ▁) ▁lh _ NAM ENUM _ ENTRY _ insert ▁( ▁name map ▁-> ▁nam enum ▁, ▁nam enum ▁) ▁; ▁if ▁( ▁lh _ NAM ENUM _ ENTRY _ error ▁( ▁name map ▁-> ▁nam enum ▁) ▁) ▁goto ▁err ▁; ▁CRYPTO _ THREAD _ unlock ▁( ▁name map ▁-> ▁lock ▁) ▁; ▁return ▁tmp _ number ▁; ▁err ▁: ▁nam enum _ free ▁( ▁nam enum ▁) ▁; ▁CRYPTO _ THREAD _ unlock ▁( ▁name map ▁-> ▁lock ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁HMAC _ Init _ ex ▁( ▁HMAC _ CTX ▁* ▁ctx ▁, ▁const ▁void ▁* ▁key ▁, ▁int ▁len ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁ENGINE ▁* ▁impl ▁) ▁{ ▁int ▁rv ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁, ▁reset ▁= ▁0 ▁; ▁unsigned ▁char ▁pad ▁[ ▁HMAC _ MAX _ MD _ C BLOCK _ SIZE ▁] ▁; ▁if ▁( ▁md ▁!= ▁NULL ▁&& ▁md ▁!= ▁ctx ▁-> ▁md ▁&& ▁( ▁key ▁== ▁NULL ▁|| ▁len ▁< ▁0 ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁md ▁!= ▁NULL ▁) ▁{ ▁reset ▁= ▁1 ▁; ▁ctx ▁-> ▁md ▁= ▁md ▁; ▁} ▁else ▁if ▁( ▁ctx ▁-> ▁md ▁) ▁{ ▁md ▁= ▁ctx ▁-> ▁md ▁; ▁} ▁else ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁key ▁!= ▁NULL ▁) ▁{ ▁reset ▁= ▁1 ▁; ▁j ▁= ▁EVP _ MD _ block _ size ▁( ▁md ▁) ▁; ▁if ▁( ▁! ▁ossl _ assert ▁( ▁j ▁<= ▁( ▁int ▁) ▁sizeof ▁( ▁ctx ▁-> ▁key ▁) ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁j ▁< ▁len ▁) ▁{ ▁if ▁( ▁! ▁EVP _ Digest Init _ ex ▁( ▁ctx ▁-> ▁md _ ctx ▁, ▁md ▁, ▁impl ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁ctx ▁-> ▁md _ ctx ▁, ▁key ▁, ▁len ▁) ▁|| ▁! ▁EVP _ Digest Final _ ex ▁( ▁ctx ▁-> ▁md _ ctx ▁, ▁ctx ▁-> ▁key ▁, ▁& ▁ctx ▁-> ▁key _ length ▁) ▁) ▁return ▁0 ▁; ▁} ▁else ▁{ ▁if ▁( ▁len ▁< ▁0 ▁|| ▁len ▁> ▁( ▁int ▁) ▁sizeof ▁( ▁ctx ▁-> ▁key ▁) ▁) ▁return ▁0 ▁; ▁memcpy ▁( ▁ctx ▁-> ▁key ▁, ▁key ▁, ▁len ▁) ▁; ▁ctx ▁-> ▁key _ length ▁= ▁len ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁key _ length ▁!= ▁HMAC _ MAX _ MD _ C BLOCK _ SIZE ▁) ▁memset ▁( ▁& ▁ctx ▁-> ▁key ▁[ ▁ctx ▁-> ▁key _ length ▁] ▁, ▁0 ▁, ▁HMAC _ MAX _ MD _ C BLOCK _ SIZE ▁- ▁ctx ▁-> ▁key _ length ▁) ▁; ▁} ▁if ▁( ▁reset ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁HMAC _ MAX _ MD _ C BLOCK _ SIZE ▁; ▁i ▁++ ▁) ▁pad ▁[ ▁i ▁] ▁= ▁0 x 36 ▁ ^ ▁ctx ▁-> ▁key ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁EVP _ Digest Init _ ex ▁( ▁ctx ▁-> ▁i _ ctx ▁, ▁md ▁, ▁impl ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁ctx ▁-> ▁i _ ctx ▁, ▁pad ▁, ▁EVP _ MD _ block _ size ▁( ▁md ▁) ▁) ▁) ▁goto ▁err ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁HMAC _ MAX _ MD _ C BLOCK _ SIZE ▁; ▁i ▁++ ▁) ▁pad ▁[ ▁i ▁] ▁= ▁0 x 5 c ▁ ^ ▁ctx ▁-> ▁key ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁EVP _ Digest Init _ ex ▁( ▁ctx ▁-> ▁o _ ctx ▁, ▁md ▁, ▁impl ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁ctx ▁-> ▁o _ ctx ▁, ▁pad ▁, ▁EVP _ MD _ block _ size ▁( ▁md ▁) ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁EVP _ MD _ CTX _ copy _ ex ▁( ▁ctx ▁-> ▁md _ ctx ▁, ▁ctx ▁-> ▁i _ ctx ▁) ▁) ▁goto ▁err ▁; ▁rv ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁reset ▁) ▁OPENSSL _ cleanse ▁( ▁pad ▁, ▁sizeof ▁( ▁pad ▁) ▁) ▁; ▁return ▁rv ▁; ▁}	0
▁static ▁int ▁pc x _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁PC X Context ▁* ▁const ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁picture ▁= ▁data ▁; ▁AVFrame ▁* ▁const ▁p ▁= ▁& ▁s ▁-> ▁picture ▁; ▁int ▁compressed ▁, ▁xmin ▁, ▁ymin ▁, ▁xmax ▁, ▁ymax ▁; ▁unsigned ▁int ▁w ▁, ▁h ▁, ▁bits _ per _ pixel ▁, ▁bytes _ per _ line ▁, ▁n planes ▁, ▁stride ▁, ▁y ▁, ▁x ▁, ▁bytes _ per _ scanline ▁; ▁uint 8_ t ▁* ▁ptr ▁; ▁uint 8_ t ▁const ▁* ▁buf start ▁= ▁buf ▁; ▁uint 8_ t ▁* ▁scanline ▁; ▁int ▁ret ▁= ▁-1 ▁; ▁if ▁( ▁buf ▁[ ▁0 ▁] ▁!= ▁0 x 0 a ▁|| ▁buf ▁[ ▁1 ▁] ▁> ▁5 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" this is not PC X encode ddata \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁compressed ▁= ▁buf ▁[ ▁2 ▁] ▁; ▁xmin ▁= ▁AV _ RL 16 ▁( ▁buf ▁+ ▁4 ▁) ▁; ▁ymin ▁= ▁AV _ RL 16 ▁( ▁buf ▁+ ▁6 ▁) ▁; ▁xmax ▁= ▁AV _ RL 16 ▁( ▁buf ▁+ ▁8 ▁) ▁; ▁ymax ▁= ▁AV _ RL 16 ▁( ▁buf ▁+ ▁10 ▁) ▁; ▁if ▁( ▁xmax ▁< ▁xmin ▁|| ▁ymax ▁< ▁ymin ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid im aged im ensions \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁w ▁= ▁xmax ▁- ▁xmin ▁+ ▁1 ▁; ▁h ▁= ▁ymax ▁- ▁ymin ▁+ ▁1 ▁; ▁bits _ per _ pixel ▁= ▁buf ▁[ ▁3 ▁] ▁; ▁bytes _ per _ line ▁= ▁AV _ RL 16 ▁( ▁buf ▁+ ▁66 ▁) ▁; ▁n planes ▁= ▁buf ▁[ ▁65 ▁] ▁; ▁bytes _ per _ scanline ▁= ▁n planes ▁* ▁bytes _ per _ line ▁; ▁if ▁( ▁bytes _ per _ scanline ▁< ▁w ▁* ▁bits _ per _ pixel ▁* ▁n planes ▁/ ▁8 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" PC X data isc or rupted \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁switch ▁( ▁( ▁n planes ▁<< ▁8 ▁) ▁+ ▁bits _ per _ pixel ▁) ▁{ ▁case ▁0 x 030 8 ▁: ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ RGB 24 ▁; ▁break ▁; ▁case ▁0 x 01 08 ▁: ▁case ▁0 x 01 04 ▁: ▁case ▁0 x 01 02 ▁: ▁case ▁0 x 0101 ▁: ▁case ▁0 x 04 01 ▁: ▁case ▁0 x 0301 ▁: ▁case ▁0 x 0201 ▁: ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ PAL 8 ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid PC X file \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁buf ▁+= ▁128 ▁; ▁if ▁( ▁p ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁; ▁if ▁( ▁av _ image _ check _ size ▁( ▁w ▁, ▁h ▁, ▁0 ▁, ▁avctx ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁w ▁!= ▁avctx ▁-> ▁width ▁|| ▁h ▁!= ▁avctx ▁-> ▁height ▁) ▁avcodec _ set _ dimensions ▁( ▁avctx ▁, ▁w ▁, ▁h ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁ptr ▁= ▁p ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁stride ▁= ▁p ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁scanline ▁= ▁av _ malloc ▁( ▁bytes _ per _ scanline ▁) ▁; ▁if ▁( ▁! ▁scanline ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁n planes ▁== ▁3 ▁&& ▁bits _ per _ pixel ▁== ▁8 ▁) ▁{ ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁h ▁; ▁y ▁++ ▁) ▁{ ▁buf ▁= ▁pc x _ r le _ decode ▁( ▁buf ▁, ▁scanline ▁, ▁bytes _ per _ scanline ▁, ▁compressed ▁) ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁w ▁; ▁x ▁++ ▁) ▁{ ▁ptr ▁[ ▁3 ▁* ▁x ▁] ▁= ▁scanline ▁[ ▁x ▁] ▁; ▁ptr ▁[ ▁3 ▁* ▁x ▁+ ▁1 ▁] ▁= ▁scanline ▁[ ▁x ▁+ ▁bytes _ per _ line ▁] ▁; ▁ptr ▁[ ▁3 ▁* ▁x ▁+ ▁2 ▁] ▁= ▁scanline ▁[ ▁x ▁+ ▁( ▁bytes _ per _ line ▁<< ▁1 ▁) ▁] ▁; ▁} ▁ptr ▁+= ▁stride ▁; ▁} ▁} ▁else ▁if ▁( ▁n planes ▁== ▁1 ▁&& ▁bits _ per _ pixel ▁== ▁8 ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁pal start ▁= ▁buf start ▁+ ▁buf _ size ▁- ▁7 69 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁h ▁; ▁y ▁++ ▁, ▁ptr ▁+= ▁stride ▁) ▁{ ▁buf ▁= ▁pc x _ r le _ decode ▁( ▁buf ▁, ▁scanline ▁, ▁bytes _ per _ scanline ▁, ▁compressed ▁) ▁; ▁memcpy ▁( ▁ptr ▁, ▁scanline ▁, ▁w ▁) ▁; ▁} ▁if ▁( ▁buf ▁!= ▁pal start ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" im aged at ap ossibly cor rupted \ n " ▁) ▁; ▁buf ▁= ▁pal start ▁; ▁} ▁if ▁( ▁* ▁buf ▁++ ▁!= ▁12 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" expected palette after im aged ata \ n " ▁) ▁; ▁ret ▁= ▁AVERROR _ INVALIDDATA ▁; ▁goto ▁end ▁; ▁} ▁} ▁else ▁if ▁( ▁n planes ▁== ▁1 ▁) ▁{ ▁Get Bit Context ▁s ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁h ▁; ▁y ▁++ ▁) ▁{ ▁init _ get _ bits ▁( ▁& ▁s ▁, ▁scanline ▁, ▁bytes _ per _ scanline ▁<< ▁3 ▁) ▁; ▁buf ▁= ▁pc x _ r le _ decode ▁( ▁buf ▁, ▁scanline ▁, ▁bytes _ per _ scanline ▁, ▁compressed ▁) ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁w ▁; ▁x ▁++ ▁) ▁ptr ▁[ ▁x ▁] ▁= ▁get _ bits ▁( ▁& ▁s ▁, ▁bits _ per _ pixel ▁) ▁; ▁ptr ▁+= ▁stride ▁; ▁} ▁} ▁else ▁{ ▁int ▁i ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁h ▁; ▁y ▁++ ▁) ▁{ ▁buf ▁= ▁pc x _ r le _ decode ▁( ▁buf ▁, ▁scanline ▁, ▁bytes _ per _ scanline ▁, ▁compressed ▁) ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁w ▁; ▁x ▁++ ▁) ▁{ ▁int ▁m ▁= ▁0 x 80 ▁>> ▁( ▁x ▁& ▁7 ▁) ▁, ▁v ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁n planes ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁v ▁<<= ▁1 ▁; ▁v ▁+= ▁! ▁! ▁( ▁scanline ▁[ ▁i ▁* ▁bytes _ per _ line ▁+ ▁( ▁x ▁>> ▁3 ▁) ▁] ▁& ▁m ▁) ▁; ▁} ▁ptr ▁[ ▁x ▁] ▁= ▁v ▁; ▁} ▁ptr ▁+= ▁stride ▁; ▁} ▁} ▁if ▁( ▁n planes ▁== ▁1 ▁&& ▁bits _ per _ pixel ▁== ▁8 ▁) ▁{ ▁pc x _ palette ▁( ▁& ▁buf ▁, ▁( ▁uint 32_ t ▁* ▁) ▁p ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁256 ▁) ▁; ▁} ▁else ▁if ▁( ▁bits _ per _ pixel ▁* ▁n planes ▁== ▁1 ▁) ▁{ ▁AV _ WN 32 A ▁( ▁p ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁0 xFF 000000 ▁) ▁; ▁AV _ WN 32 A ▁( ▁p ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁4 ▁, ▁0 xFFFFFFFF ▁) ▁; ▁} ▁else ▁if ▁( ▁bits _ per _ pixel ▁< ▁8 ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁palette ▁= ▁buf start ▁+ ▁16 ▁; ▁pc x _ palette ▁( ▁& ▁palette ▁, ▁( ▁uint 32_ t ▁* ▁) ▁p ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁16 ▁) ▁; ▁} ▁* ▁picture ▁= ▁s ▁-> ▁picture ▁; ▁* ▁data _ size ▁= ▁sizeof ▁( ▁AVFrame ▁) ▁; ▁ret ▁= ▁buf ▁- ▁buf start ▁; ▁end ▁: ▁av _ free ▁( ▁scanline ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁int ▁ff _ mp v _ common _ frame _ size _ change ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁err ▁= ▁0 ▁; ▁if ▁( ▁! ▁s ▁-> ▁context _ initialized ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁s ▁-> ▁slice _ context _ count ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁free _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁else ▁free _ duplicate _ context ▁( ▁s ▁) ▁; ▁free _ context _ frame ▁( ▁s ▁) ▁; ▁if ▁( ▁s ▁-> ▁picture ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁needs _ realloc ▁= ▁1 ▁; ▁} ▁s ▁-> ▁last _ picture _ ptr ▁= ▁s ▁-> ▁next _ picture _ ptr ▁= ▁s ▁-> ▁current _ picture _ ptr ▁= ▁NULL ▁; ▁if ▁( ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁&& ▁! ▁s ▁-> ▁progress ive _ sequence ▁) ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁2 ▁; ▁else ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁15 ▁) ▁/ ▁16 ▁; ▁if ▁( ▁( ▁s ▁-> ▁width ▁|| ▁s ▁-> ▁height ▁) ▁&& ▁( ▁err ▁= ▁av _ image _ check _ size ▁( ▁s ▁-> ▁width ▁, ▁s ▁-> ▁height ▁, ▁0 ▁, ▁s ▁-> ▁avctx ▁) ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁if ▁( ▁( ▁err ▁= ▁init _ context _ frame ▁( ▁s ▁) ▁) ▁) ▁goto ▁fail ▁; ▁memset ▁( ▁s ▁-> ▁thread _ context ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁thread _ context ▁) ▁) ▁; ▁s ▁-> ▁thread _ context ▁[ ▁0 ▁] ▁= ▁s ▁; ▁if ▁( ▁s ▁-> ▁width ▁&& ▁s ▁-> ▁height ▁) ▁{ ▁int ▁nb _ s lices ▁= ▁s ▁-> ▁slice _ context _ count ▁; ▁if ▁( ▁nb _ s lices ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁) ▁{ ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁= ▁av _ mem dup ▁( ▁s ▁, ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁{ ▁err ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁} ▁if ▁( ▁( ▁err ▁= ▁init _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁start _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁end _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁} ▁} ▁else ▁{ ▁err ▁= ▁init _ duplicate _ context ▁( ▁s ▁) ▁; ▁if ▁( ▁err ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁start _ mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁end _ mb _ y ▁= ▁s ▁-> ▁mb _ height ▁; ▁} ▁s ▁-> ▁slice _ context _ count ▁= ▁nb _ s lices ▁; ▁} ▁return ▁0 ▁; ▁fail ▁: ▁ff _ mp v _ common _ end ▁( ▁s ▁) ▁; ▁return ▁err ▁; ▁}	0
▁static ▁int ▁parse _ picture _ segment ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁PG SS ub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁uint 8_ t ▁sequence _ desc ▁; ▁unsigned ▁int ▁r le _ bitmap _ len ▁, ▁width ▁, ▁height ▁; ▁if ▁( ▁buf _ size ▁<= ▁4 ▁) ▁return ▁-1 ▁; ▁buf _ size ▁-= ▁4 ▁; ▁buf ▁+= ▁3 ▁; ▁sequence _ desc ▁= ▁bytestream _ get _ byte ▁( ▁& ▁buf ▁) ▁; ▁if ▁( ▁! ▁( ▁sequence _ desc ▁& ▁0 x 80 ▁) ▁) ▁{ ▁if ▁( ▁buf _ size ▁> ▁ctx ▁-> ▁picture ▁. ▁r le _ remaining _ len ▁) ▁return ▁-1 ▁; ▁memcpy ▁( ▁ctx ▁-> ▁picture ▁. ▁r le ▁+ ▁ctx ▁-> ▁picture ▁. ▁r le _ data _ len ▁, ▁buf ▁, ▁buf _ size ▁) ▁; ▁ctx ▁-> ▁picture ▁. ▁r le _ data _ len ▁+= ▁buf _ size ▁; ▁ctx ▁-> ▁picture ▁. ▁r le _ remaining _ len ▁-= ▁buf _ size ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁buf _ size ▁<= ▁7 ▁) ▁return ▁-1 ▁; ▁buf _ size ▁-= ▁7 ▁; ▁r le _ bitmap _ len ▁= ▁bytestream _ get _ be 24 ▁( ▁& ▁buf ▁) ▁- ▁2 ▁* ▁2 ▁; ▁width ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁buf ▁) ▁; ▁height ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁buf ▁) ▁; ▁if ▁( ▁avctx ▁-> ▁width ▁< ▁width ▁|| ▁avctx ▁-> ▁height ▁< ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bitmap dimensions l arger than video .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁ctx ▁-> ▁picture ▁. ▁w ▁= ▁width ▁; ▁ctx ▁-> ▁picture ▁. ▁h ▁= ▁height ▁; ▁av _ fast _ malloc ▁( ▁& ▁ctx ▁-> ▁picture ▁. ▁r le ▁, ▁& ▁ctx ▁-> ▁picture ▁. ▁r le _ buffer _ size ▁, ▁r le _ bitmap _ len ▁) ▁; ▁if ▁( ▁! ▁ctx ▁-> ▁picture ▁. ▁r le ▁) ▁return ▁-1 ▁; ▁memcpy ▁( ▁ctx ▁-> ▁picture ▁. ▁r le ▁, ▁buf ▁, ▁buf _ size ▁) ▁; ▁ctx ▁-> ▁picture ▁. ▁r le _ data _ len ▁= ▁buf _ size ▁; ▁ctx ▁-> ▁picture ▁. ▁r le _ remaining _ len ▁= ▁r le _ bitmap _ len ▁- ▁buf _ size ▁; ▁return ▁0 ▁; ▁}	1
▁void ▁av _ frame _ unref ▁( ▁AVFrame ▁* ▁frame ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁! ▁frame ▁) ▁return ▁; ▁wipe _ side _ data ▁( ▁frame ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁frame ▁-> ▁buf ▁) ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁frame ▁-> ▁buf ▁[ ▁i ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁frame ▁-> ▁nb _ extended _ buf ▁; ▁i ▁++ ▁) ▁av _ buffer _ unref ▁( ▁& ▁frame ▁-> ▁extended _ buf ▁[ ▁i ▁] ▁) ▁; ▁av _ freep ▁( ▁& ▁frame ▁-> ▁extended _ buf ▁) ▁; ▁av _ dict _ free ▁( ▁& ▁frame ▁-> ▁metadata ▁) ▁; ▁# if ▁FF _ API _ FRAME _ QP ▁av _ buffer _ unref ▁( ▁& ▁frame ▁-> ▁qp _ table _ buf ▁) ▁; ▁# endif ▁av _ buffer _ unref ▁( ▁& ▁frame ▁-> ▁hw _ frames _ ctx ▁) ▁; ▁av _ buffer _ unref ▁( ▁& ▁frame ▁-> ▁opaque _ ref ▁) ▁; ▁get _ frame _ defaults ▁( ▁frame ▁) ▁; ▁}	1
▁void ▁rgb 24 to y v 12_ c ▁( ▁const ▁uint 8_ t ▁* ▁src ▁, ▁uint 8_ t ▁* ▁y dst ▁, ▁uint 8_ t ▁* ▁u dst ▁, ▁uint 8_ t ▁* ▁v dst ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁lum Stride ▁, ▁int ▁chrom Stride ▁, ▁int ▁src Stride ▁) ▁{ ▁int ▁y ▁; ▁const ▁int ▁chrom Width ▁= ▁width ▁>> ▁1 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁+= ▁2 ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁chrom Width ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁int ▁b ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁0 ▁] ▁; ▁unsigned ▁int ▁g ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁1 ▁] ▁; ▁unsigned ▁int ▁r ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁2 ▁] ▁; ▁unsigned ▁int ▁Y ▁= ▁( ▁( ▁R Y ▁* ▁r ▁+ ▁G Y ▁* ▁g ▁+ ▁BY ▁* ▁b ▁) ▁>> ▁RGB 2 YUV _ SHIFT ▁) ▁+ ▁16 ▁; ▁unsigned ▁int ▁V ▁= ▁( ▁( ▁R V ▁* ▁r ▁+ ▁GV ▁* ▁g ▁+ ▁BV ▁* ▁b ▁) ▁>> ▁RGB 2 YUV _ SHIFT ▁) ▁+ ▁128 ▁; ▁unsigned ▁int ▁U ▁= ▁( ▁( ▁R U ▁* ▁r ▁+ ▁GU ▁* ▁g ▁+ ▁BU ▁* ▁b ▁) ▁>> ▁RGB 2 YUV _ SHIFT ▁) ▁+ ▁128 ▁; ▁u dst ▁[ ▁i ▁] ▁= ▁U ▁; ▁v dst ▁[ ▁i ▁] ▁= ▁V ▁; ▁y dst ▁[ ▁2 ▁* ▁i ▁] ▁= ▁Y ▁; ▁b ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁3 ▁] ▁; ▁g ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁4 ▁] ▁; ▁r ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁5 ▁] ▁; ▁Y ▁= ▁( ▁( ▁R Y ▁* ▁r ▁+ ▁G Y ▁* ▁g ▁+ ▁BY ▁* ▁b ▁) ▁>> ▁RGB 2 YUV _ SHIFT ▁) ▁+ ▁16 ▁; ▁y dst ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁= ▁Y ▁; ▁} ▁y dst ▁+= ▁lum Stride ▁; ▁src ▁+= ▁src Stride ▁; ▁if ▁( ▁y ▁+ ▁1 ▁== ▁height ▁) ▁break ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁chrom Width ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁int ▁b ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁0 ▁] ▁; ▁unsigned ▁int ▁g ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁1 ▁] ▁; ▁unsigned ▁int ▁r ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁2 ▁] ▁; ▁unsigned ▁int ▁Y ▁= ▁( ▁( ▁R Y ▁* ▁r ▁+ ▁G Y ▁* ▁g ▁+ ▁BY ▁* ▁b ▁) ▁>> ▁RGB 2 YUV _ SHIFT ▁) ▁+ ▁16 ▁; ▁y dst ▁[ ▁2 ▁* ▁i ▁] ▁= ▁Y ▁; ▁b ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁3 ▁] ▁; ▁g ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁4 ▁] ▁; ▁r ▁= ▁src ▁[ ▁6 ▁* ▁i ▁+ ▁5 ▁] ▁; ▁Y ▁= ▁( ▁( ▁R Y ▁* ▁r ▁+ ▁G Y ▁* ▁g ▁+ ▁BY ▁* ▁b ▁) ▁>> ▁RGB 2 YUV _ SHIFT ▁) ▁+ ▁16 ▁; ▁y dst ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁= ▁Y ▁; ▁} ▁u dst ▁+= ▁chrom Stride ▁; ▁v dst ▁+= ▁chrom Stride ▁; ▁y dst ▁+= ▁lum Stride ▁; ▁src ▁+= ▁src Stride ▁; ▁} ▁}	1
▁int ▁av _ samples _ fill _ arrays ▁( ▁uint 8_ t ▁* ▁* ▁audio _ data ▁, ▁int ▁* ▁linesize ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁nb _ channels ▁, ▁int ▁nb _ samples ▁, ▁enum ▁AV Sample Format ▁sample _ fmt ▁, ▁int ▁align ▁) ▁{ ▁int ▁ch ▁, ▁plan ar ▁, ▁buf _ size ▁, ▁line _ size ▁; ▁plan ar ▁= ▁av _ sample _ fmt _ is _ planar ▁( ▁sample _ fmt ▁) ▁; ▁buf _ size ▁= ▁av _ samples _ get _ buffer _ size ▁( ▁& ▁line _ size ▁, ▁nb _ channels ▁, ▁nb _ samples ▁, ▁sample _ fmt ▁, ▁align ▁) ▁; ▁if ▁( ▁buf _ size ▁< ▁0 ▁) ▁return ▁buf _ size ▁; ▁audio _ data ▁[ ▁0 ▁] ▁= ▁( ▁uint 8_ t ▁* ▁) ▁buf ▁; ▁for ▁( ▁ch ▁= ▁1 ▁; ▁plan ar ▁&& ▁ch ▁< ▁nb _ channels ▁; ▁ch ▁++ ▁) ▁audio _ data ▁[ ▁ch ▁] ▁= ▁audio _ data ▁[ ▁ch ▁- ▁1 ▁] ▁+ ▁line _ size ▁; ▁if ▁( ▁linesize ▁) ▁* ▁linesize ▁= ▁line _ size ▁; ▁# if ▁FF _ API _ SAMPLES _ U TILS _ RETURN _ ZERO ▁return ▁0 ▁; ▁# else ▁return ▁buf _ size ▁; ▁# endif ▁}	1
▁int ▁av _ fifo _ realloc 2 ▁( ▁AV Fifo Buffer ▁* ▁f ▁, ▁unsigned ▁int ▁new _ size ▁) ▁{ ▁unsigned ▁int ▁old _ size ▁= ▁f ▁-> ▁end ▁- ▁f ▁-> ▁buffer ▁; ▁if ▁( ▁old _ size ▁< ▁new _ size ▁) ▁{ ▁int ▁len ▁= ▁av _ fifo _ size ▁( ▁f ▁) ▁; ▁AV Fifo Buffer ▁* ▁f 2 ▁= ▁av _ fifo _ alloc ▁( ▁new _ size ▁) ▁; ▁if ▁( ▁! ▁f 2 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁av _ fifo _ generic _ read ▁( ▁f ▁, ▁f 2 ▁-> ▁buffer ▁, ▁len ▁, ▁NULL ▁) ▁; ▁f 2 ▁-> ▁w ptr ▁+= ▁len ▁; ▁f 2 ▁-> ▁wnd x ▁+= ▁len ▁; ▁av _ free ▁( ▁f ▁-> ▁buffer ▁) ▁; ▁* ▁f ▁= ▁* ▁f 2 ▁; ▁av _ free ▁( ▁f 2 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁inline ▁void ▁flush _ put _ bits ▁( ▁Put Bit Context ▁* ▁s ▁) ▁{ ▁# ifdef ▁ALT _ BIT STREAM _ WR ITER ▁align _ put _ bits ▁( ▁s ▁) ▁; ▁# else ▁# ifndef ▁BIT STREAM _ WR ITER _ LE ▁s ▁-> ▁bit _ buf ▁<<= ▁s ▁-> ▁bit _ left ▁; ▁# endif ▁while ▁( ▁s ▁-> ▁bit _ left ▁< ▁32 ▁) ▁{ ▁# ifdef ▁BIT STREAM _ WR ITER _ LE ▁* ▁s ▁-> ▁buf _ ptr ▁++ ▁= ▁s ▁-> ▁bit _ buf ▁; ▁s ▁-> ▁bit _ buf ▁>>= ▁8 ▁; ▁# else ▁* ▁s ▁-> ▁buf _ ptr ▁++ ▁= ▁s ▁-> ▁bit _ buf ▁>> ▁24 ▁; ▁s ▁-> ▁bit _ buf ▁<<= ▁8 ▁; ▁# endif ▁s ▁-> ▁bit _ left ▁+= ▁8 ▁; ▁} ▁s ▁-> ▁bit _ left ▁= ▁32 ▁; ▁s ▁-> ▁bit _ buf ▁= ▁0 ▁; ▁# endif ▁}	1
▁static ▁inline ▁void ▁expand _ category ▁( ▁C OOK Context ▁* ▁q ▁, ▁int ▁* ▁category ▁, ▁int ▁* ▁category _ index ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁q ▁-> ▁num _ vectors ▁; ▁i ▁++ ▁) ▁++ ▁category ▁[ ▁category _ index ▁[ ▁i ▁] ▁] ▁; ▁}	1
▁static ▁int ▁h 264_ mp 4 to ann ex b _ filter ▁( ▁AV BitStream Filter Context ▁* ▁bs fc ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁char ▁* ▁args ▁, ▁uint 8_ t ▁* ▁* ▁poutbuf ▁, ▁int ▁* ▁poutbuf _ size ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁int ▁keyframe ▁) ▁{ ▁H 264 BS F Context ▁* ▁ctx ▁= ▁bs fc ▁-> ▁priv _ data ▁; ▁uint 8_ t ▁unit _ type ▁; ▁int 32_ t ▁nal _ size ▁; ▁uint 32_ t ▁c umul _ size ▁= ▁0 ▁; ▁const ▁uint 8_ t ▁* ▁buf _ end ▁= ▁buf ▁+ ▁buf _ size ▁; ▁if ▁( ▁! ▁avctx ▁-> ▁extradata ▁|| ▁avctx ▁-> ▁extradata _ size ▁< ▁6 ▁) ▁{ ▁* ▁poutbuf ▁= ▁( ▁uint 8_ t ▁* ▁) ▁buf ▁; ▁* ▁poutbuf _ size ▁= ▁buf _ size ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁! ▁ctx ▁-> ▁sps _ pps _ data ▁) ▁{ ▁uint 16_ t ▁unit _ size ▁; ▁uint 32_ t ▁total _ size ▁= ▁0 ▁; ▁uint 8_ t ▁* ▁out ▁= ▁NULL ▁, ▁unit _ nb ▁, ▁sps _ done ▁= ▁0 ▁; ▁const ▁uint 8_ t ▁* ▁extradata ▁= ▁avctx ▁-> ▁extradata ▁+ ▁4 ▁; ▁static ▁const ▁uint 8_ t ▁nal u _ header ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁ctx ▁-> ▁length _ size ▁= ▁( ▁* ▁extradata ▁++ ▁& ▁0 x 3 ▁) ▁+ ▁1 ▁; ▁if ▁( ▁ctx ▁-> ▁length _ size ▁== ▁3 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁unit _ nb ▁= ▁* ▁extradata ▁++ ▁& ▁0 x 1 f ▁; ▁if ▁( ▁! ▁unit _ nb ▁) ▁{ ▁unit _ nb ▁= ▁* ▁extradata ▁++ ▁; ▁sps _ done ▁++ ▁; ▁} ▁while ▁( ▁unit _ nb ▁-- ▁) ▁{ ▁unit _ size ▁= ▁AV _ RB 16 ▁( ▁extradata ▁) ▁; ▁total _ size ▁+= ▁unit _ size ▁+ ▁4 ▁; ▁if ▁( ▁extradata ▁+ ▁2 ▁+ ▁unit _ size ▁> ▁avctx ▁-> ▁extradata ▁+ ▁avctx ▁-> ▁extradata _ size ▁) ▁{ ▁av _ free ▁( ▁out ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁out ▁= ▁av _ realloc ▁( ▁out ▁, ▁total _ size ▁) ▁; ▁if ▁( ▁! ▁out ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁out ▁+ ▁total _ size ▁- ▁unit _ size ▁- ▁4 ▁, ▁nal u _ header ▁, ▁4 ▁) ▁; ▁memcpy ▁( ▁out ▁+ ▁total _ size ▁- ▁unit _ size ▁, ▁extradata ▁+ ▁2 ▁, ▁unit _ size ▁) ▁; ▁extradata ▁+= ▁2 ▁+ ▁unit _ size ▁; ▁if ▁( ▁! ▁unit _ nb ▁&& ▁! ▁sps _ done ▁++ ▁) ▁unit _ nb ▁= ▁* ▁extradata ▁++ ▁; ▁} ▁ctx ▁-> ▁sps _ pps _ data ▁= ▁out ▁; ▁ctx ▁-> ▁size ▁= ▁total _ size ▁; ▁ctx ▁-> ▁first _ idr ▁= ▁1 ▁; ▁} ▁* ▁poutbuf _ size ▁= ▁0 ▁; ▁* ▁poutbuf ▁= ▁NULL ▁; ▁do ▁{ ▁if ▁( ▁buf ▁+ ▁ctx ▁-> ▁length _ size ▁> ▁buf _ end ▁) ▁goto ▁fail ▁; ▁if ▁( ▁ctx ▁-> ▁length _ size ▁== ▁1 ▁) ▁nal _ size ▁= ▁buf ▁[ ▁0 ▁] ▁; ▁else ▁if ▁( ▁ctx ▁-> ▁length _ size ▁== ▁2 ▁) ▁nal _ size ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁; ▁else ▁nal _ size ▁= ▁AV _ RB 32 ▁( ▁buf ▁) ▁; ▁buf ▁+= ▁ctx ▁-> ▁length _ size ▁; ▁unit _ type ▁= ▁* ▁buf ▁& ▁0 x 1 f ▁; ▁if ▁( ▁buf ▁+ ▁nal _ size ▁> ▁buf _ end ▁|| ▁nal _ size ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁if ▁( ▁ctx ▁-> ▁first _ idr ▁&& ▁unit _ type ▁== ▁5 ▁) ▁{ ▁alloc _ and _ copy ▁( ▁poutbuf ▁, ▁poutbuf _ size ▁, ▁ctx ▁-> ▁sps _ pps _ data ▁, ▁ctx ▁-> ▁size ▁, ▁buf ▁, ▁nal _ size ▁) ▁; ▁ctx ▁-> ▁first _ idr ▁= ▁0 ▁; ▁} ▁else ▁{ ▁alloc _ and _ copy ▁( ▁poutbuf ▁, ▁poutbuf _ size ▁, ▁NULL ▁, ▁0 ▁, ▁buf ▁, ▁nal _ size ▁) ▁; ▁if ▁( ▁! ▁ctx ▁-> ▁first _ idr ▁&& ▁unit _ type ▁== ▁1 ▁) ▁ctx ▁-> ▁first _ idr ▁= ▁1 ▁; ▁} ▁buf ▁+= ▁nal _ size ▁; ▁c umul _ size ▁+= ▁nal _ size ▁+ ▁ctx ▁-> ▁length _ size ▁; ▁} ▁while ▁( ▁c umul _ size ▁< ▁buf _ size ▁) ▁; ▁return ▁1 ▁; ▁fail ▁: ▁av _ freep ▁( ▁poutbuf ▁) ▁; ▁* ▁poutbuf _ size ▁= ▁0 ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁}	0
▁static ▁void ▁sr _1 d 97_ int ▁( ▁int 32_ t ▁* ▁p ▁, ▁int ▁i 0 ▁, ▁int ▁i 1 ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁i 1 ▁<= ▁i 0 ▁+ ▁1 ▁) ▁{ ▁if ▁( ▁i 0 ▁== ▁1 ▁) ▁p ▁[ ▁1 ▁] ▁= ▁( ▁p ▁[ ▁1 ▁] ▁* ▁I _ L FT G _ K ▁+ ▁( ▁1 ▁<< ▁16 ▁) ▁) ▁>> ▁17 ▁; ▁else ▁p ▁[ ▁0 ▁] ▁= ▁( ▁p ▁[ ▁0 ▁] ▁* ▁I _ L FT G _ X ▁+ ▁( ▁1 ▁<< ▁15 ▁) ▁) ▁>> ▁16 ▁; ▁return ▁; ▁} ▁extend 97_ int ▁( ▁p ▁, ▁i 0 ▁, ▁i 1 ▁) ▁; ▁for ▁( ▁i ▁= ▁i 0 ▁/ ▁2 ▁- ▁1 ▁; ▁i ▁< ▁i 1 ▁/ ▁2 ▁+ ▁2 ▁; ▁i ▁++ ▁) ▁p ▁[ ▁2 ▁* ▁i ▁] ▁-= ▁( ▁I _ L FT G _ DELTA ▁* ▁( ▁p ▁[ ▁2 ▁* ▁i ▁- ▁1 ▁] ▁+ ▁p ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁) ▁+ ▁( ▁1 ▁<< ▁15 ▁) ▁) ▁>> ▁16 ▁; ▁for ▁( ▁i ▁= ▁i 0 ▁/ ▁2 ▁- ▁1 ▁; ▁i ▁< ▁i 1 ▁/ ▁2 ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁p ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁-= ▁( ▁I _ L FT G _ GAM MA ▁* ▁( ▁p ▁[ ▁2 ▁* ▁i ▁] ▁+ ▁p ▁[ ▁2 ▁* ▁i ▁+ ▁2 ▁] ▁) ▁+ ▁( ▁1 ▁<< ▁15 ▁) ▁) ▁>> ▁16 ▁; ▁for ▁( ▁i ▁= ▁i 0 ▁/ ▁2 ▁; ▁i ▁< ▁i 1 ▁/ ▁2 ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁p ▁[ ▁2 ▁* ▁i ▁] ▁+= ▁( ▁I _ L FT G _ B ETA ▁* ▁( ▁p ▁[ ▁2 ▁* ▁i ▁- ▁1 ▁] ▁+ ▁p ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁) ▁+ ▁( ▁1 ▁<< ▁15 ▁) ▁) ▁>> ▁16 ▁; ▁for ▁( ▁i ▁= ▁i 0 ▁/ ▁2 ▁; ▁i ▁< ▁i 1 ▁/ ▁2 ▁; ▁i ▁++ ▁) ▁p ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁+= ▁( ▁I _ L FT G _ ALPHA ▁* ▁( ▁p ▁[ ▁2 ▁* ▁i ▁] ▁+ ▁p ▁[ ▁2 ▁* ▁i ▁+ ▁2 ▁] ▁) ▁+ ▁( ▁1 ▁<< ▁15 ▁) ▁) ▁>> ▁16 ▁; ▁}	0
▁static ▁void ▁code book _ tre ll is _ rate ▁( ▁AAC Enc Context ▁* ▁s ▁, ▁Single Channel Element ▁* ▁sce ▁, ▁int ▁win ▁, ▁int ▁group _ len ▁, ▁const ▁float ▁lambda ▁) ▁{ ▁Band Coding Path ▁path ▁[ ▁120 ▁] ▁[ ▁12 ▁] ▁; ▁int ▁w ▁, ▁sw b ▁, ▁cb ▁, ▁start ▁, ▁size ▁; ▁int ▁i ▁, ▁j ▁; ▁const ▁int ▁max _ s fb ▁= ▁sce ▁-> ▁ics ▁. ▁max _ s fb ▁; ▁const ▁int ▁run _ bits ▁= ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁1 ▁? ▁5 ▁: ▁3 ▁; ▁const ▁int ▁run _ esc ▁= ▁( ▁1 ▁<< ▁run _ bits ▁) ▁- ▁1 ▁; ▁int ▁idx ▁, ▁ppos ▁, ▁count ▁; ▁int ▁stack run ▁[ ▁120 ▁] ▁, ▁stack cb ▁[ ▁120 ▁] ▁, ▁stack _ len ▁; ▁float ▁next _ min bits ▁= ▁INFINITY ▁; ▁int ▁next _ min cb ▁= ▁0 ▁; ▁abs _ pow 34_ v ▁( ▁s ▁-> ▁sco efs ▁, ▁sce ▁-> ▁coeffs ▁, ▁1024 ▁) ▁; ▁start ▁= ▁win ▁* ▁128 ▁; ▁for ▁( ▁cb ▁= ▁0 ▁; ▁cb ▁< ▁12 ▁; ▁cb ▁++ ▁) ▁{ ▁path ▁[ ▁0 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁run _ bits ▁+ ▁4 ▁; ▁path ▁[ ▁0 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁-1 ▁; ▁path ▁[ ▁0 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁0 ▁; ▁} ▁for ▁( ▁sw b ▁= ▁0 ▁; ▁sw b ▁< ▁max _ s fb ▁; ▁sw b ▁++ ▁) ▁{ ▁size ▁= ▁sce ▁-> ▁ics ▁. ▁sw b _ sizes ▁[ ▁sw b ▁] ▁; ▁if ▁( ▁sce ▁-> ▁zero es ▁[ ▁win ▁* ▁16 ▁+ ▁sw b ▁] ▁) ▁{ ▁float ▁cost _ st ay _ here ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁0 ▁] ▁. ▁cost ▁; ▁float ▁cost _ get _ here ▁= ▁next _ min bits ▁+ ▁run _ bits ▁+ ▁4 ▁; ▁if ▁( ▁run _ value _ bits ▁[ ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁8 ▁] ▁[ ▁path ▁[ ▁sw b ▁] ▁[ ▁0 ▁] ▁. ▁run ▁] ▁!= ▁run _ value _ bits ▁[ ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁8 ▁] ▁[ ▁path ▁[ ▁sw b ▁] ▁[ ▁0 ▁] ▁. ▁run ▁+ ▁1 ▁] ▁) ▁cost _ st ay _ here ▁+= ▁run _ bits ▁; ▁if ▁( ▁cost _ get _ here ▁< ▁cost _ st ay _ here ▁) ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁prev _ idx ▁= ▁next _ min cb ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁cost ▁= ▁cost _ get _ here ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁run ▁= ▁1 ▁; ▁} ▁else ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁prev _ idx ▁= ▁0 ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁cost ▁= ▁cost _ st ay _ here ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁run ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁0 ▁] ▁. ▁run ▁+ ▁1 ▁; ▁} ▁next _ min bits ▁= ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁cost ▁; ▁next _ min cb ▁= ▁0 ▁; ▁for ▁( ▁cb ▁= ▁1 ▁; ▁cb ▁< ▁12 ▁; ▁cb ▁++ ▁) ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁6 14 50 ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁-1 ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁0 ▁; ▁} ▁} ▁else ▁{ ▁float ▁min bits ▁= ▁next _ min bits ▁; ▁int ▁min cb ▁= ▁next _ min cb ▁; ▁int ▁start cb ▁= ▁sce ▁-> ▁band _ type ▁[ ▁win ▁* ▁16 ▁+ ▁sw b ▁] ▁; ▁next _ min bits ▁= ▁INFINITY ▁; ▁next _ min cb ▁= ▁0 ▁; ▁for ▁( ▁cb ▁= ▁0 ▁; ▁cb ▁< ▁start cb ▁; ▁cb ▁++ ▁) ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁6 14 50 ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁-1 ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁0 ▁; ▁} ▁for ▁( ▁cb ▁= ▁start cb ▁; ▁cb ▁< ▁12 ▁; ▁cb ▁++ ▁) ▁{ ▁float ▁cost _ st ay _ here ▁, ▁cost _ get _ here ▁; ▁float ▁bits ▁= ▁0.0 f ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁group _ len ▁; ▁w ▁++ ▁) ▁{ ▁bits ▁+= ▁quant ize _ band _ cost ▁( ▁s ▁, ▁sce ▁-> ▁coeffs ▁+ ▁start ▁+ ▁w ▁* ▁128 ▁, ▁s ▁-> ▁sco efs ▁+ ▁start ▁+ ▁w ▁* ▁128 ▁, ▁size ▁, ▁sce ▁-> ▁sf _ idx ▁[ ▁( ▁win ▁+ ▁w ▁) ▁* ▁16 ▁+ ▁sw b ▁] ▁, ▁cb ▁, ▁0 ▁, ▁INFINITY ▁, ▁NULL ▁) ▁; ▁} ▁cost _ st ay _ here ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁+ ▁bits ▁; ▁cost _ get _ here ▁= ▁min bits ▁+ ▁bits ▁+ ▁run _ bits ▁+ ▁4 ▁; ▁if ▁( ▁run _ value _ bits ▁[ ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁8 ▁] ▁[ ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁run ▁] ▁!= ▁run _ value _ bits ▁[ ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁== ▁8 ▁] ▁[ ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁run ▁+ ▁1 ▁] ▁) ▁cost _ st ay _ here ▁+= ▁run _ bits ▁; ▁if ▁( ▁cost _ get _ here ▁< ▁cost _ st ay _ here ▁) ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁min cb ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁cost _ get _ here ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁1 ▁; ▁} ▁else ▁{ ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁= ▁cb ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁= ▁cost _ st ay _ here ▁; ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁run ▁= ▁path ▁[ ▁sw b ▁] ▁[ ▁cb ▁] ▁. ▁run ▁+ ▁1 ▁; ▁} ▁if ▁( ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁< ▁next _ min bits ▁) ▁{ ▁next _ min bits ▁= ▁path ▁[ ▁sw b ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁; ▁next _ min cb ▁= ▁cb ▁; ▁} ▁} ▁} ▁start ▁+= ▁sce ▁-> ▁ics ▁. ▁sw b _ sizes ▁[ ▁sw b ▁] ▁; ▁} ▁stack _ len ▁= ▁0 ▁; ▁idx ▁= ▁0 ▁; ▁for ▁( ▁cb ▁= ▁1 ▁; ▁cb ▁< ▁12 ▁; ▁cb ▁++ ▁) ▁if ▁( ▁path ▁[ ▁max _ s fb ▁] ▁[ ▁cb ▁] ▁. ▁cost ▁< ▁path ▁[ ▁max _ s fb ▁] ▁[ ▁idx ▁] ▁. ▁cost ▁) ▁idx ▁= ▁cb ▁; ▁ppos ▁= ▁max _ s fb ▁; ▁while ▁( ▁ppos ▁> ▁0 ▁) ▁{ ▁av _ assert 1 ▁( ▁idx ▁>= ▁0 ▁) ▁; ▁cb ▁= ▁idx ▁; ▁stack run ▁[ ▁stack _ len ▁] ▁= ▁path ▁[ ▁ppos ▁] ▁[ ▁cb ▁] ▁. ▁run ▁; ▁stack cb ▁[ ▁stack _ len ▁] ▁= ▁cb ▁; ▁idx ▁= ▁path ▁[ ▁ppos ▁- ▁path ▁[ ▁ppos ▁] ▁[ ▁cb ▁] ▁. ▁run ▁+ ▁1 ▁] ▁[ ▁cb ▁] ▁. ▁prev _ idx ▁; ▁ppos ▁-= ▁path ▁[ ▁ppos ▁] ▁[ ▁cb ▁] ▁. ▁run ▁; ▁stack _ len ▁++ ▁; ▁} ▁start ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁stack _ len ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁4 ▁, ▁stack cb ▁[ ▁i ▁] ▁) ▁; ▁count ▁= ▁stack run ▁[ ▁i ▁] ▁; ▁memset ▁( ▁sce ▁-> ▁zero es ▁+ ▁win ▁* ▁16 ▁+ ▁start ▁, ▁! ▁stack cb ▁[ ▁i ▁] ▁, ▁count ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁count ▁; ▁j ▁++ ▁) ▁{ ▁sce ▁-> ▁band _ type ▁[ ▁win ▁* ▁16 ▁+ ▁start ▁] ▁= ▁stack cb ▁[ ▁i ▁] ▁; ▁start ▁++ ▁; ▁} ▁while ▁( ▁count ▁>= ▁run _ esc ▁) ▁{ ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁run _ bits ▁, ▁run _ esc ▁) ▁; ▁count ▁-= ▁run _ esc ▁; ▁} ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁run _ bits ▁, ▁count ▁) ▁; ▁} ▁}	1
▁static ▁void ▁bast ard ized _ rice _ decompress ▁( ▁AL AC Context ▁* ▁al ac ▁, ▁int 32_ t ▁* ▁output _ buffer ▁, ▁int ▁output _ size ▁, ▁int ▁read sample size ▁, ▁int ▁r ice _ initial history ▁, ▁int ▁r ice _ km od ifier ▁, ▁int ▁r ice _ history mult ▁, ▁int ▁r ice _ km od ifier _ mask ▁) ▁{ ▁int ▁output _ count ▁; ▁unsigned ▁int ▁history ▁= ▁r ice _ initial history ▁; ▁int ▁sign _ modifier ▁= ▁0 ▁; ▁for ▁( ▁output _ count ▁= ▁0 ▁; ▁output _ count ▁< ▁output _ size ▁; ▁output _ count ▁++ ▁) ▁{ ▁int 32_ t ▁x ▁; ▁int 32_ t ▁x _ modified ▁; ▁int 32_ t ▁final _ val ▁; ▁x ▁= ▁get _ unary _0_ 9 ▁( ▁& ▁al ac ▁-> ▁gb ▁) ▁; ▁if ▁( ▁x ▁> ▁8 ▁) ▁{ ▁x ▁= ▁get _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁read sample size ▁) ▁; ▁} ▁else ▁{ ▁int ▁extr ab its ▁; ▁int ▁k ▁; ▁k ▁= ▁31 ▁- ▁count _ leading _ zeros ▁( ▁( ▁history ▁>> ▁9 ▁) ▁+ ▁3 ▁) ▁; ▁if ▁( ▁k ▁>= ▁r ice _ km od ifier ▁) ▁k ▁= ▁r ice _ km od ifier ▁; ▁if ▁( ▁k ▁!= ▁1 ▁) ▁{ ▁extr ab its ▁= ▁show _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁k ▁) ▁; ▁x ▁= ▁( ▁x ▁<< ▁k ▁) ▁- ▁x ▁; ▁if ▁( ▁extr ab its ▁> ▁1 ▁) ▁{ ▁x ▁+= ▁extr ab its ▁- ▁1 ▁; ▁skip _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁k ▁) ▁; ▁} ▁else ▁skip _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁k ▁- ▁1 ▁) ▁; ▁} ▁} ▁x _ modified ▁= ▁sign _ modifier ▁+ ▁x ▁; ▁final _ val ▁= ▁( ▁x _ modified ▁+ ▁1 ▁) ▁/ ▁2 ▁; ▁if ▁( ▁x _ modified ▁& ▁1 ▁) ▁final _ val ▁*= ▁-1 ▁; ▁output _ buffer ▁[ ▁output _ count ▁] ▁= ▁final _ val ▁; ▁sign _ modifier ▁= ▁0 ▁; ▁history ▁+= ▁x _ modified ▁* ▁r ice _ history mult ▁- ▁( ▁( ▁history ▁* ▁r ice _ history mult ▁) ▁>> ▁9 ▁) ▁; ▁if ▁( ▁x _ modified ▁> ▁0 xffff ▁) ▁history ▁= ▁0 xffff ▁; ▁if ▁( ▁( ▁history ▁< ▁128 ▁) ▁&& ▁( ▁output _ count ▁+ ▁1 ▁< ▁output _ size ▁) ▁) ▁{ ▁int ▁block _ size ▁; ▁sign _ modifier ▁= ▁1 ▁; ▁x ▁= ▁get _ unary _0_ 9 ▁( ▁& ▁al ac ▁-> ▁gb ▁) ▁; ▁if ▁( ▁x ▁> ▁8 ▁) ▁{ ▁block _ size ▁= ▁get _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁16 ▁) ▁; ▁} ▁else ▁{ ▁int ▁k ▁; ▁int ▁extr ab its ▁; ▁k ▁= ▁count _ leading _ zeros ▁( ▁history ▁) ▁+ ▁( ▁( ▁history ▁+ ▁16 ▁) ▁>> ▁6 ▁) ▁- ▁24 ▁; ▁if ▁( ▁k ▁>= ▁r ice _ km od ifier ▁) ▁k ▁= ▁r ice _ km od ifier ▁; ▁x ▁= ▁( ▁x ▁<< ▁k ▁) ▁- ▁x ▁; ▁extr ab its ▁= ▁show _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁k ▁) ▁; ▁if ▁( ▁extr ab its ▁< ▁2 ▁) ▁{ ▁skip _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁k ▁- ▁1 ▁) ▁; ▁} ▁else ▁{ ▁x ▁+= ▁extr ab its ▁- ▁1 ▁; ▁skip _ bits ▁( ▁& ▁al ac ▁-> ▁gb ▁, ▁k ▁) ▁; ▁} ▁block _ size ▁= ▁x ▁; ▁} ▁if ▁( ▁block _ size ▁> ▁0 ▁) ▁{ ▁memset ▁( ▁& ▁output _ buffer ▁[ ▁output _ count ▁+ ▁1 ▁] ▁, ▁0 ▁, ▁block _ size ▁* ▁4 ▁) ▁; ▁output _ count ▁+= ▁block _ size ▁; ▁} ▁if ▁( ▁block _ size ▁> ▁0 xffff ▁) ▁sign _ modifier ▁= ▁0 ▁; ▁history ▁= ▁0 ▁; ▁} ▁} ▁}	0
▁static ▁void ▁sb r _ hf _ inverse _ filter ▁( ▁SB RD SP Context ▁* ▁dsp ▁, ▁int ▁( ▁* ▁alpha 0 ▁) ▁[ ▁2 ▁] ▁, ▁int ▁( ▁* ▁alpha 1 ▁) ▁[ ▁2 ▁] ▁, ▁const ▁int ▁X _ low ▁[ ▁32 ▁] ▁[ ▁40 ▁] ▁[ ▁2 ▁] ▁, ▁int ▁k 0 ▁) ▁{ ▁int ▁k ▁; ▁int ▁shift ▁, ▁round ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁k 0 ▁; ▁k ▁++ ▁) ▁{ ▁Soft Float ▁phi ▁[ ▁3 ▁] ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁; ▁Soft Float ▁a 00 ▁, ▁a 01 ▁, ▁a 10 ▁, ▁a 11 ▁; ▁Soft Float ▁dk ▁; ▁dsp ▁-> ▁aut oc or relate ▁( ▁X _ low ▁[ ▁k ▁] ▁, ▁phi ▁) ▁; ▁dk ▁= ▁av _ sub _ sf ▁( ▁av _ mul _ sf ▁( ▁phi ▁[ ▁2 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁, ▁av _ mul _ sf ▁( ▁av _ add _ sf ▁( ▁av _ mul _ sf ▁( ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁, ▁av _ mul _ sf ▁( ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁) ▁, ▁FLOAT _0 9999 99 ▁) ▁) ▁; ▁if ▁( ▁! ▁dk ▁. ▁mant ▁) ▁{ ▁a 10 ▁= ▁FLOAT _0 ▁; ▁a 11 ▁= ▁FLOAT _0 ▁; ▁} ▁else ▁{ ▁Soft Float ▁temp _ real ▁, ▁temp _ im ▁; ▁temp _ real ▁= ▁av _ sub _ sf ▁( ▁av _ sub _ sf ▁( ▁av _ mul _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁, ▁av _ mul _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁) ▁, ▁av _ mul _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁temp _ im ▁= ▁av _ sub _ sf ▁( ▁av _ add _ sf ▁( ▁av _ mul _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁, ▁av _ mul _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁, ▁av _ mul _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁a 10 ▁= ▁av _ div _ sf ▁( ▁temp _ real ▁, ▁dk ▁) ▁; ▁a 11 ▁= ▁av _ div _ sf ▁( ▁temp _ im ▁, ▁dk ▁) ▁; ▁} ▁if ▁( ▁! ▁phi ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁. ▁mant ▁) ▁{ ▁a 00 ▁= ▁FLOAT _0 ▁; ▁a 01 ▁= ▁FLOAT _0 ▁; ▁} ▁else ▁{ ▁Soft Float ▁temp _ real ▁, ▁temp _ im ▁; ▁temp _ real ▁= ▁av _ add _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁, ▁av _ add _ sf ▁( ▁av _ mul _ sf ▁( ▁a 10 ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁, ▁av _ mul _ sf ▁( ▁a 11 ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁) ▁) ▁; ▁temp _ im ▁= ▁av _ add _ sf ▁( ▁phi ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁, ▁av _ sub _ sf ▁( ▁av _ mul _ sf ▁( ▁a 11 ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁, ▁av _ mul _ sf ▁( ▁a 10 ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁) ▁) ▁; ▁temp _ real ▁. ▁mant ▁= ▁- ▁temp _ real ▁. ▁mant ▁; ▁temp _ im ▁. ▁mant ▁= ▁- ▁temp _ im ▁. ▁mant ▁; ▁a 00 ▁= ▁av _ div _ sf ▁( ▁temp _ real ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁a 01 ▁= ▁av _ div _ sf ▁( ▁temp _ im ▁, ▁phi ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁} ▁shift ▁= ▁a 00 ▁. ▁exp ▁; ▁if ▁( ▁shift ▁>= ▁3 ▁) ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 x 7 fffffff ▁; ▁else ▁if ▁( ▁shift ▁<= ▁-30 ▁) ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁else ▁{ ▁a 00 ▁. ▁mant ▁*= ▁2 ▁; ▁shift ▁= ▁2 ▁- ▁shift ▁; ▁if ▁( ▁shift ▁== ▁0 ▁) ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁a 00 ▁. ▁mant ▁; ▁else ▁{ ▁round ▁= ▁1 ▁<< ▁( ▁shift ▁- ▁1 ▁) ▁; ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁( ▁a 00 ▁. ▁mant ▁+ ▁round ▁) ▁>> ▁shift ▁; ▁} ▁} ▁shift ▁= ▁a 01 ▁. ▁exp ▁; ▁if ▁( ▁shift ▁>= ▁3 ▁) ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 x 7 fffffff ▁; ▁else ▁if ▁( ▁shift ▁<= ▁-30 ▁) ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁else ▁{ ▁a 01 ▁. ▁mant ▁*= ▁2 ▁; ▁shift ▁= ▁2 ▁- ▁shift ▁; ▁if ▁( ▁shift ▁== ▁0 ▁) ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁a 01 ▁. ▁mant ▁; ▁else ▁{ ▁round ▁= ▁1 ▁<< ▁( ▁shift ▁- ▁1 ▁) ▁; ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁( ▁a 01 ▁. ▁mant ▁+ ▁round ▁) ▁>> ▁shift ▁; ▁} ▁} ▁shift ▁= ▁a 10 ▁. ▁exp ▁; ▁if ▁( ▁shift ▁>= ▁3 ▁) ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 x 7 fffffff ▁; ▁else ▁if ▁( ▁shift ▁<= ▁-30 ▁) ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁else ▁{ ▁a 10 ▁. ▁mant ▁*= ▁2 ▁; ▁shift ▁= ▁2 ▁- ▁shift ▁; ▁if ▁( ▁shift ▁== ▁0 ▁) ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁a 10 ▁. ▁mant ▁; ▁else ▁{ ▁round ▁= ▁1 ▁<< ▁( ▁shift ▁- ▁1 ▁) ▁; ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁( ▁a 10 ▁. ▁mant ▁+ ▁round ▁) ▁>> ▁shift ▁; ▁} ▁} ▁shift ▁= ▁a 11 ▁. ▁exp ▁; ▁if ▁( ▁shift ▁>= ▁3 ▁) ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 x 7 fffffff ▁; ▁else ▁if ▁( ▁shift ▁<= ▁-30 ▁) ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁else ▁{ ▁a 11 ▁. ▁mant ▁*= ▁2 ▁; ▁shift ▁= ▁2 ▁- ▁shift ▁; ▁if ▁( ▁shift ▁== ▁0 ▁) ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁a 11 ▁. ▁mant ▁; ▁else ▁{ ▁round ▁= ▁1 ▁<< ▁( ▁shift ▁- ▁1 ▁) ▁; ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁( ▁a 11 ▁. ▁mant ▁+ ▁round ▁) ▁>> ▁shift ▁; ▁} ▁} ▁shift ▁= ▁( ▁int ▁) ▁( ▁( ▁( ▁int 64_ t ▁) ▁( ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁>> ▁1 ▁) ▁* ▁( ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁>> ▁1 ▁) ▁+ ▁( ▁int 64_ t ▁) ▁( ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁>> ▁1 ▁) ▁* ▁( ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁>> ▁1 ▁) ▁+ ▁0 x 40000000 ▁) ▁>> ▁31 ▁) ▁; ▁if ▁( ▁shift ▁>= ▁0 x 20000000 ▁) ▁{ ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁} ▁shift ▁= ▁( ▁int ▁) ▁( ▁( ▁( ▁int 64_ t ▁) ▁( ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁>> ▁1 ▁) ▁* ▁( ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁>> ▁1 ▁) ▁+ ▁( ▁int 64_ t ▁) ▁( ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁>> ▁1 ▁) ▁* ▁( ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁>> ▁1 ▁) ▁+ ▁0 x 40000000 ▁) ▁>> ▁31 ▁) ▁; ▁if ▁( ▁shift ▁>= ▁0 x 20000000 ▁) ▁{ ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁alpha 1 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁alpha 0 ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁} ▁} ▁}	1
▁BIGNUM ▁* ▁BN _ copy ▁( ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁) ▁{ ▁int ▁i ▁; ▁BN _ ULONG ▁* ▁A ▁; ▁const ▁BN _ ULONG ▁* ▁B ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁a ▁== ▁b ▁) ▁return ▁( ▁a ▁) ▁; ▁if ▁( ▁bn _ w expand ▁( ▁a ▁, ▁b ▁-> ▁top ▁) ▁== ▁NULL ▁) ▁return ▁( ▁NULL ▁) ▁; ▁# if ▁1 ▁A ▁= ▁a ▁-> ▁d ▁; ▁B ▁= ▁b ▁-> ▁d ▁; ▁for ▁( ▁i ▁= ▁b ▁-> ▁top ▁>> ▁2 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁+= ▁4 ▁, ▁B ▁+= ▁4 ▁) ▁{ ▁BN _ ULONG ▁a 0 ▁, ▁a 1 ▁, ▁a 2 ▁, ▁a 3 ▁; ▁a 0 ▁= ▁B ▁[ ▁0 ▁] ▁; ▁a 1 ▁= ▁B ▁[ ▁1 ▁] ▁; ▁a 2 ▁= ▁B ▁[ ▁2 ▁] ▁; ▁a 3 ▁= ▁B ▁[ ▁3 ▁] ▁; ▁A ▁[ ▁0 ▁] ▁= ▁a 0 ▁; ▁A ▁[ ▁1 ▁] ▁= ▁a 1 ▁; ▁A ▁[ ▁2 ▁] ▁= ▁a 2 ▁; ▁A ▁[ ▁3 ▁] ▁= ▁a 3 ▁; ▁} ▁switch ▁( ▁b ▁-> ▁top ▁& ▁3 ▁) ▁{ ▁case ▁3 ▁: ▁A ▁[ ▁2 ▁] ▁= ▁B ▁[ ▁2 ▁] ▁; ▁case ▁2 ▁: ▁A ▁[ ▁1 ▁] ▁= ▁B ▁[ ▁1 ▁] ▁; ▁case ▁1 ▁: ▁A ▁[ ▁0 ▁] ▁= ▁B ▁[ ▁0 ▁] ▁; ▁case ▁0 ▁: ▁; ▁} ▁# else ▁memcpy ▁( ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁, ▁sizeof ▁( ▁b ▁-> ▁d ▁[ ▁0 ▁] ▁) ▁* ▁b ▁-> ▁top ▁) ▁; ▁# endif ▁a ▁-> ▁top ▁= ▁b ▁-> ▁top ▁; ▁a ▁-> ▁neg ▁= ▁b ▁-> ▁neg ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁return ▁( ▁a ▁) ▁; ▁}	1
▁void ▁ff _ mpc _ de quantize _ and _ synth ▁( ▁MPC Context ▁* ▁c ▁, ▁int ▁max band ▁, ▁void ▁* ▁data ▁, ▁int ▁channels ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁ch ▁; ▁Band ▁* ▁bands ▁= ▁c ▁-> ▁bands ▁; ▁int ▁off ▁; ▁float ▁mul ▁; ▁memset ▁( ▁c ▁-> ▁sb _ samples ▁, ▁0 ▁, ▁sizeof ▁( ▁c ▁-> ▁sb _ samples ▁) ▁) ▁; ▁off ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁max band ▁; ▁i ▁++ ▁, ▁off ▁+= ▁SAM PLES _ PER _ BAND ▁) ▁{ ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁2 ▁; ▁ch ▁++ ▁) ▁{ ▁if ▁( ▁bands ▁[ ▁i ▁] ▁. ▁res ▁[ ▁ch ▁] ▁) ▁{ ▁j ▁= ▁0 ▁; ▁mul ▁= ▁mpc _ CC ▁[ ▁bands ▁[ ▁i ▁] ▁. ▁res ▁[ ▁ch ▁] ▁] ▁* ▁mpc _ SC F ▁[ ▁bands ▁[ ▁i ▁] ▁. ▁sc f _ idx ▁[ ▁ch ▁] ▁[ ▁0 ▁] ▁] ▁; ▁for ▁( ▁; ▁j ▁< ▁12 ▁; ▁j ▁++ ▁) ▁c ▁-> ▁sb _ samples ▁[ ▁ch ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁mul ▁* ▁c ▁-> ▁Q ▁[ ▁ch ▁] ▁[ ▁j ▁+ ▁off ▁] ▁; ▁mul ▁= ▁mpc _ CC ▁[ ▁bands ▁[ ▁i ▁] ▁. ▁res ▁[ ▁ch ▁] ▁] ▁* ▁mpc _ SC F ▁[ ▁bands ▁[ ▁i ▁] ▁. ▁sc f _ idx ▁[ ▁ch ▁] ▁[ ▁1 ▁] ▁] ▁; ▁for ▁( ▁; ▁j ▁< ▁24 ▁; ▁j ▁++ ▁) ▁c ▁-> ▁sb _ samples ▁[ ▁ch ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁mul ▁* ▁c ▁-> ▁Q ▁[ ▁ch ▁] ▁[ ▁j ▁+ ▁off ▁] ▁; ▁mul ▁= ▁mpc _ CC ▁[ ▁bands ▁[ ▁i ▁] ▁. ▁res ▁[ ▁ch ▁] ▁] ▁* ▁mpc _ SC F ▁[ ▁bands ▁[ ▁i ▁] ▁. ▁sc f _ idx ▁[ ▁ch ▁] ▁[ ▁2 ▁] ▁] ▁; ▁for ▁( ▁; ▁j ▁< ▁36 ▁; ▁j ▁++ ▁) ▁c ▁-> ▁sb _ samples ▁[ ▁ch ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁mul ▁* ▁c ▁-> ▁Q ▁[ ▁ch ▁] ▁[ ▁j ▁+ ▁off ▁] ▁; ▁} ▁} ▁if ▁( ▁bands ▁[ ▁i ▁] ▁. ▁ms f ▁) ▁{ ▁int ▁t 1 ▁, ▁t 2 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁SAM PLES _ PER _ BAND ▁; ▁j ▁++ ▁) ▁{ ▁t 1 ▁= ▁c ▁-> ▁sb _ samples ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁t 2 ▁= ▁c ▁-> ▁sb _ samples ▁[ ▁1 ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁; ▁c ▁-> ▁sb _ samples ▁[ ▁0 ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁t 1 ▁+ ▁t 2 ▁; ▁c ▁-> ▁sb _ samples ▁[ ▁1 ▁] ▁[ ▁j ▁] ▁[ ▁i ▁] ▁= ▁t 1 ▁- ▁t 2 ▁; ▁} ▁} ▁} ▁mpc _ synth ▁( ▁c ▁, ▁data ▁, ▁channels ▁) ▁; ▁}	1
▁static ▁inline ▁void ▁compute _ images _ m se ▁( ▁P SN R Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁main _ data ▁[ ▁4 ▁] ▁, ▁const ▁int ▁main _ lines izes ▁[ ▁4 ▁] ▁, ▁const ▁uint 8_ t ▁* ▁ref _ data ▁[ ▁4 ▁] ▁, ▁const ▁int ▁ref _ lines izes ▁[ ▁4 ▁] ▁, ▁int ▁w ▁, ▁int ▁h ▁, ▁double ▁mse ▁[ ▁4 ▁] ▁) ▁{ ▁int ▁i ▁, ▁c ▁; ▁for ▁( ▁c ▁= ▁0 ▁; ▁c ▁< ▁s ▁-> ▁nb _ components ▁; ▁c ▁++ ▁) ▁{ ▁const ▁int ▁outw ▁= ▁s ▁-> ▁plan ew idth ▁[ ▁c ▁] ▁; ▁const ▁int ▁out h ▁= ▁s ▁-> ▁plane height ▁[ ▁c ▁] ▁; ▁const ▁uint 8_ t ▁* ▁main _ line ▁= ▁main _ data ▁[ ▁c ▁] ▁; ▁const ▁uint 8_ t ▁* ▁ref _ line ▁= ▁ref _ data ▁[ ▁c ▁] ▁; ▁const ▁int ▁ref _ lines ize ▁= ▁ref _ lines izes ▁[ ▁c ▁] ▁; ▁const ▁int ▁main _ lines ize ▁= ▁main _ lines izes ▁[ ▁c ▁] ▁; ▁uint 64_ t ▁m ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁out h ▁; ▁i ▁++ ▁) ▁{ ▁m ▁+= ▁s ▁-> ▁dsp ▁. ▁sse _ line ▁( ▁main _ line ▁, ▁ref _ line ▁, ▁outw ▁) ▁; ▁ref _ line ▁+= ▁ref _ lines ize ▁; ▁main _ line ▁+= ▁main _ lines ize ▁; ▁} ▁mse ▁[ ▁c ▁] ▁= ▁m ▁/ ▁( ▁double ▁) ▁( ▁outw ▁* ▁out h ▁) ▁; ▁} ▁}	0
▁static ▁int ▁decode _ i _ frame ▁( ▁Four X Context ▁* ▁f ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁length ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁const ▁int ▁width ▁= ▁f ▁-> ▁avctx ▁-> ▁width ▁; ▁const ▁int ▁height ▁= ▁f ▁-> ▁avctx ▁-> ▁height ▁; ▁uint 16_ t ▁* ▁dst ▁= ▁( ▁uint 16_ t ▁* ▁) ▁f ▁-> ▁current _ picture ▁. ▁data ▁[ ▁0 ▁] ▁; ▁const ▁int ▁stride ▁= ▁f ▁-> ▁current _ picture ▁. ▁linesize ▁[ ▁0 ▁] ▁>> ▁1 ▁; ▁const ▁unsigned ▁int ▁bitstream _ size ▁= ▁AV _ RL 32 ▁( ▁buf ▁) ▁; ▁unsigned ▁int ▁pre stream _ size ▁; ▁const ▁uint 8_ t ▁* ▁pre stream ▁; ▁if ▁( ▁bitstream _ size ▁> ▁( ▁1 ▁<< ▁26 ▁) ▁|| ▁length ▁< ▁bitstream _ size ▁+ ▁12 ▁) ▁return ▁-1 ▁; ▁pre stream _ size ▁= ▁4 ▁* ▁AV _ RL 32 ▁( ▁buf ▁+ ▁bitstream _ size ▁+ ▁4 ▁) ▁; ▁pre stream ▁= ▁buf ▁+ ▁bitstream _ size ▁+ ▁12 ▁; ▁if ▁( ▁pre stream _ size ▁> ▁( ▁1 ▁<< ▁26 ▁) ▁|| ▁pre stream _ size ▁!= ▁length ▁- ▁( ▁bitstream _ size ▁+ ▁12 ▁) ▁) ▁{ ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" size mismatch % d % d % d \ n " ▁, ▁pre stream _ size ▁, ▁bitstream _ size ▁, ▁length ▁) ▁; ▁return ▁-1 ▁; ▁} ▁pre stream ▁= ▁read _ h uffman _ tables ▁( ▁f ▁, ▁pre stream ▁, ▁buf ▁+ ▁length ▁- ▁pre stream ▁) ▁; ▁if ▁( ▁! ▁pre stream ▁) ▁return ▁-1 ▁; ▁init _ get _ bits ▁( ▁& ▁f ▁-> ▁gb ▁, ▁buf ▁+ ▁4 ▁, ▁8 ▁* ▁bitstream _ size ▁) ▁; ▁pre stream _ size ▁= ▁length ▁+ ▁buf ▁- ▁pre stream ▁; ▁av _ fast _ malloc ▁( ▁& ▁f ▁-> ▁bitstream _ buffer ▁, ▁& ▁f ▁-> ▁bitstream _ buffer _ size ▁, ▁pre stream _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁f ▁-> ▁bitstream _ buffer ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁f ▁-> ▁dsp ▁. ▁bswap _ buf ▁( ▁f ▁-> ▁bitstream _ buffer ▁, ▁( ▁const ▁uint 32_ t ▁* ▁) ▁pre stream ▁, ▁pre stream _ size ▁/ ▁4 ▁) ▁; ▁memset ▁( ▁( ▁uint 8_ t ▁* ▁) ▁f ▁-> ▁bitstream _ buffer ▁+ ▁pre stream _ size ▁, ▁0 ▁, ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁init _ get _ bits ▁( ▁& ▁f ▁-> ▁pre _ gb ▁, ▁f ▁-> ▁bitstream _ buffer ▁, ▁8 ▁* ▁pre stream _ size ▁) ▁; ▁f ▁-> ▁last _ dc ▁= ▁0 ▁* ▁128 ▁* ▁8 ▁* ▁8 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁+= ▁16 ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁width ▁; ▁x ▁+= ▁16 ▁) ▁{ ▁if ▁( ▁decode _ i _ mb ▁( ▁f ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁idct _ put ▁( ▁f ▁, ▁x ▁, ▁y ▁) ▁; ▁} ▁dst ▁+= ▁16 ▁* ▁stride ▁; ▁} ▁if ▁( ▁get _ vlc 2 ▁( ▁& ▁f ▁-> ▁pre _ gb ▁, ▁f ▁-> ▁pre _ vlc ▁. ▁table ▁, ▁A CDC _ V LC _ BITS ▁, ▁3 ▁) ▁!= ▁256 ▁) ▁av _ log ▁( ▁f ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" end mismatch \ n " ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁ff _ MP V _ common _ frame _ size _ change ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁err ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁slice _ context _ count ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁free _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁else ▁free _ duplicate _ context ▁( ▁s ▁) ▁; ▁if ▁( ▁( ▁err ▁= ▁free _ context _ frame ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁err ▁; ▁if ▁( ▁s ▁-> ▁picture ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁needs _ realloc ▁= ▁1 ▁; ▁} ▁s ▁-> ▁last _ picture _ ptr ▁= ▁s ▁-> ▁next _ picture _ ptr ▁= ▁s ▁-> ▁current _ picture _ ptr ▁= ▁NULL ▁; ▁if ▁( ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁&& ▁! ▁s ▁-> ▁progress ive _ sequence ▁) ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁2 ▁; ▁else ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁15 ▁) ▁/ ▁16 ▁; ▁if ▁( ▁( ▁s ▁-> ▁width ▁|| ▁s ▁-> ▁height ▁) ▁&& ▁av _ image _ check _ size ▁( ▁s ▁-> ▁width ▁, ▁s ▁-> ▁height ▁, ▁0 ▁, ▁s ▁-> ▁avctx ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁( ▁err ▁= ▁init _ context _ frame ▁( ▁s ▁) ▁) ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁thread _ context ▁[ ▁0 ▁] ▁= ▁s ▁; ▁if ▁( ▁s ▁-> ▁width ▁&& ▁s ▁-> ▁height ▁) ▁{ ▁int ▁nb _ s lices ▁= ▁s ▁-> ▁slice _ context _ count ▁; ▁if ▁( ▁nb _ s lices ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁init _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁start _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁end _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁} ▁} ▁else ▁{ ▁err ▁= ▁init _ duplicate _ context ▁( ▁s ▁) ▁; ▁if ▁( ▁err ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁start _ mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁end _ mb _ y ▁= ▁s ▁-> ▁mb _ height ▁; ▁} ▁s ▁-> ▁slice _ context _ count ▁= ▁nb _ s lices ▁; ▁} ▁return ▁0 ▁; ▁fail ▁: ▁ff _ MP V _ common _ end ▁( ▁s ▁) ▁; ▁return ▁err ▁; ▁}	1
▁int ▁W PACKET _ reserve _ bytes ▁( ▁W PACKET ▁* ▁pkt ▁, ▁size _ t ▁len ▁, ▁unsigned ▁char ▁* ▁* ▁alloc bytes ▁) ▁{ ▁assert ▁( ▁pkt ▁-> ▁subs ▁!= ▁NULL ▁&& ▁len ▁!= ▁0 ▁) ▁; ▁if ▁( ▁pkt ▁-> ▁subs ▁== ▁NULL ▁|| ▁len ▁== ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁pkt ▁-> ▁maxsize ▁- ▁pkt ▁-> ▁written ▁< ▁len ▁) ▁return ▁0 ▁; ▁if ▁( ▁pkt ▁-> ▁static buf ▁== ▁NULL ▁&& ▁( ▁pkt ▁-> ▁buf ▁-> ▁length ▁- ▁pkt ▁-> ▁written ▁< ▁len ▁) ▁) ▁{ ▁size _ t ▁newlen ▁; ▁size _ t ▁ref len ▁; ▁ref len ▁= ▁( ▁len ▁> ▁pkt ▁-> ▁buf ▁-> ▁length ▁) ▁? ▁len ▁: ▁pkt ▁-> ▁buf ▁-> ▁length ▁; ▁if ▁( ▁ref len ▁> ▁SIZE _ MAX ▁/ ▁2 ▁) ▁{ ▁newlen ▁= ▁SIZE _ MAX ▁; ▁} ▁else ▁{ ▁newlen ▁= ▁ref len ▁* ▁2 ▁; ▁if ▁( ▁newlen ▁< ▁DEFAULT _ BUF _ SIZE ▁) ▁newlen ▁= ▁DEFAULT _ BUF _ SIZE ▁; ▁} ▁if ▁( ▁BUF _ MEM _ grow ▁( ▁pkt ▁-> ▁buf ▁, ▁newlen ▁) ▁== ▁0 ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁alloc bytes ▁!= ▁NULL ▁) ▁* ▁alloc bytes ▁= ▁W PACKET _ get _ curr ▁( ▁pkt ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁inline ▁void ▁skip _ bits _ long ▁( ▁Get Bit Context ▁* ▁s ▁, ▁int ▁n ▁) ▁{ ▁s ▁-> ▁index ▁+= ▁n ▁; ▁}	1
▁static ▁void ▁filter _ mb _ row _ simple ▁( ▁VP 8 Context ▁* ▁s ▁, ▁int ▁mb _ y ▁) ▁{ ▁uint 8_ t ▁* ▁dst ▁= ▁s ▁-> ▁frame p ▁[ ▁VP 5 6_ FRAME _ CURRENT ▁] ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁16 ▁* ▁mb _ y ▁* ▁s ▁-> ▁linesize ▁; ▁VP 8 Macro block ▁* ▁mb ▁= ▁s ▁-> ▁macro blocks ▁+ ▁mb _ y ▁* ▁s ▁-> ▁mb _ stride ▁; ▁int ▁mb _ x ▁; ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁mb _ x ▁++ ▁) ▁{ ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁, ▁NULL ▁, ▁NULL ▁, ▁s ▁-> ▁linesize ▁, ▁0 ▁, ▁1 ▁) ▁; ▁filter _ mb _ simple ▁( ▁s ▁, ▁dst ▁, ▁mb ▁++ ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁dst ▁+= ▁16 ▁; ▁} ▁}	0
▁int ▁ff _ init _ p oc ▁( ▁H 264 Context ▁* ▁h ▁, ▁int ▁pic _ field _ p oc ▁[ ▁2 ▁] ▁, ▁int ▁* ▁pic _ p oc ▁) ▁{ ▁const ▁SP S ▁* ▁sps ▁= ▁h ▁-> ▁ps ▁. ▁sps ▁; ▁const ▁int ▁max _ frame _ num ▁= ▁1 ▁<< ▁sps ▁-> ▁log 2_ max _ frame _ num ▁; ▁int ▁field _ p oc ▁[ ▁2 ▁] ▁; ▁h ▁-> ▁frame _ num _ offset ▁= ▁h ▁-> ▁prev _ frame _ num _ offset ▁; ▁if ▁( ▁h ▁-> ▁frame _ num ▁< ▁h ▁-> ▁prev _ frame _ num ▁) ▁h ▁-> ▁frame _ num _ offset ▁+= ▁max _ frame _ num ▁; ▁if ▁( ▁sps ▁-> ▁p oc _ type ▁== ▁0 ▁) ▁{ ▁const ▁int ▁max _ p oc _ lsb ▁= ▁1 ▁<< ▁sps ▁-> ▁log 2_ max _ p oc _ lsb ▁; ▁if ▁( ▁h ▁-> ▁p oc _ lsb ▁< ▁h ▁-> ▁prev _ p oc _ lsb ▁&& ▁h ▁-> ▁prev _ p oc _ lsb ▁- ▁h ▁-> ▁p oc _ lsb ▁>= ▁max _ p oc _ lsb ▁/ ▁2 ▁) ▁h ▁-> ▁p oc _ msb ▁= ▁h ▁-> ▁prev _ p oc _ msb ▁+ ▁max _ p oc _ lsb ▁; ▁else ▁if ▁( ▁h ▁-> ▁p oc _ lsb ▁> ▁h ▁-> ▁prev _ p oc _ lsb ▁&& ▁h ▁-> ▁prev _ p oc _ lsb ▁- ▁h ▁-> ▁p oc _ lsb ▁< ▁- ▁max _ p oc _ lsb ▁/ ▁2 ▁) ▁h ▁-> ▁p oc _ msb ▁= ▁h ▁-> ▁prev _ p oc _ msb ▁- ▁max _ p oc _ lsb ▁; ▁else ▁h ▁-> ▁p oc _ msb ▁= ▁h ▁-> ▁prev _ p oc _ msb ▁; ▁field _ p oc ▁[ ▁0 ▁] ▁= ▁field _ p oc ▁[ ▁1 ▁] ▁= ▁h ▁-> ▁p oc _ msb ▁+ ▁h ▁-> ▁p oc _ lsb ▁; ▁if ▁( ▁h ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁field _ p oc ▁[ ▁1 ▁] ▁+= ▁h ▁-> ▁delta _ p oc _ bottom ▁; ▁} ▁else ▁if ▁( ▁sps ▁-> ▁p oc _ type ▁== ▁1 ▁) ▁{ ▁int ▁abs _ frame _ num ▁, ▁expected _ delta _ per _ p oc _ cycle ▁, ▁expected p oc ▁; ▁int ▁i ▁; ▁if ▁( ▁sps ▁-> ▁p oc _ cycle _ length ▁!= ▁0 ▁) ▁abs _ frame _ num ▁= ▁h ▁-> ▁frame _ num _ offset ▁+ ▁h ▁-> ▁frame _ num ▁; ▁else ▁abs _ frame _ num ▁= ▁0 ▁; ▁if ▁( ▁h ▁-> ▁nal _ ref _ id c ▁== ▁0 ▁&& ▁abs _ frame _ num ▁> ▁0 ▁) ▁abs _ frame _ num ▁-- ▁; ▁expected _ delta _ per _ p oc _ cycle ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sps ▁-> ▁p oc _ cycle _ length ▁; ▁i ▁++ ▁) ▁expected _ delta _ per _ p oc _ cycle ▁+= ▁sps ▁-> ▁offset _ for _ ref _ frame ▁[ ▁i ▁] ▁; ▁if ▁( ▁abs _ frame _ num ▁> ▁0 ▁) ▁{ ▁int ▁p oc _ cycle _ cnt ▁= ▁( ▁abs _ frame _ num ▁- ▁1 ▁) ▁/ ▁sps ▁-> ▁p oc _ cycle _ length ▁; ▁int ▁frame _ num _ in _ p oc _ cycle ▁= ▁( ▁abs _ frame _ num ▁- ▁1 ▁) ▁% ▁sps ▁-> ▁p oc _ cycle _ length ▁; ▁expected p oc ▁= ▁p oc _ cycle _ cnt ▁* ▁expected _ delta _ per _ p oc _ cycle ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁frame _ num _ in _ p oc _ cycle ▁; ▁i ▁++ ▁) ▁expected p oc ▁= ▁expected p oc ▁+ ▁sps ▁-> ▁offset _ for _ ref _ frame ▁[ ▁i ▁] ▁; ▁} ▁else ▁expected p oc ▁= ▁0 ▁; ▁if ▁( ▁h ▁-> ▁nal _ ref _ id c ▁== ▁0 ▁) ▁expected p oc ▁= ▁expected p oc ▁+ ▁sps ▁-> ▁offset _ for _ non _ ref _ pic ▁; ▁field _ p oc ▁[ ▁0 ▁] ▁= ▁expected p oc ▁+ ▁h ▁-> ▁delta _ p oc ▁[ ▁0 ▁] ▁; ▁field _ p oc ▁[ ▁1 ▁] ▁= ▁field _ p oc ▁[ ▁0 ▁] ▁+ ▁sps ▁-> ▁offset _ for _ top _ to _ bottom _ field ▁; ▁if ▁( ▁h ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁field _ p oc ▁[ ▁1 ▁] ▁+= ▁h ▁-> ▁delta _ p oc ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁int ▁p oc ▁= ▁2 ▁* ▁( ▁h ▁-> ▁frame _ num _ offset ▁+ ▁h ▁-> ▁frame _ num ▁) ▁; ▁if ▁( ▁! ▁h ▁-> ▁nal _ ref _ id c ▁) ▁p oc ▁-- ▁; ▁field _ p oc ▁[ ▁0 ▁] ▁= ▁p oc ▁; ▁field _ p oc ▁[ ▁1 ▁] ▁= ▁p oc ▁; ▁} ▁if ▁( ▁h ▁-> ▁picture _ structure ▁!= ▁P ICT _ BOTTOM _ FIELD ▁) ▁pic _ field _ p oc ▁[ ▁0 ▁] ▁= ▁field _ p oc ▁[ ▁0 ▁] ▁; ▁if ▁( ▁h ▁-> ▁picture _ structure ▁!= ▁P ICT _ TOP _ FIELD ▁) ▁pic _ field _ p oc ▁[ ▁1 ▁] ▁= ▁field _ p oc ▁[ ▁1 ▁] ▁; ▁* ▁pic _ p oc ▁= ▁FF MIN ▁( ▁pic _ field _ p oc ▁[ ▁0 ▁] ▁, ▁pic _ field _ p oc ▁[ ▁1 ▁] ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁BN _ BL IND ING ▁* ▁BN _ BL IND ING _ new ▁( ▁const ▁BIGNUM ▁* ▁A ▁, ▁const ▁BIGNUM ▁* ▁Ai ▁, ▁BIGNUM ▁* ▁mod ▁) ▁{ ▁BN _ BL IND ING ▁* ▁ret ▁= ▁NULL ▁; ▁bn _ check _ top ▁( ▁mod ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁( ▁BN _ BL IND ING ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁BN _ BL IND ING ▁) ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ BL IND ING _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁memset ▁( ▁ret ▁, ▁0 ▁, ▁sizeof ▁( ▁BN _ BL IND ING ▁) ▁) ▁; ▁if ▁( ▁A ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ret ▁-> ▁A ▁= ▁BN _ dup ▁( ▁A ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁Ai ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ret ▁-> ▁Ai ▁= ▁BN _ dup ▁( ▁Ai ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁mod ▁= ▁BN _ dup ▁( ▁mod ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ get _ flags ▁( ▁mod ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁) ▁BN _ set _ flags ▁( ▁ret ▁-> ▁mod ▁, ▁BN _ FLG _ CONST TIME ▁) ▁; ▁ret ▁-> ▁counter ▁= ▁BN _ BL IND ING _ COUNTER ▁; ▁CRYPTO _ THREAD ID _ current ▁( ▁& ▁ret ▁-> ▁tid ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁err ▁: ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁BN _ BL IND ING _ free ▁( ▁ret ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	0
▁static ▁void ▁generate _ new _ code books ▁( ▁Ro q Context ▁* ▁enc ▁, ▁Ro q Temp data ▁* ▁temp Data ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁Ro q Code books ▁* ▁code books ▁= ▁& ▁temp Data ▁-> ▁code books ▁; ▁int ▁max ▁= ▁enc ▁-> ▁width ▁* ▁enc ▁-> ▁height ▁/ ▁16 ▁; ▁uint 8_ t ▁mb 2 ▁[ ▁3 ▁* ▁4 ▁] ▁; ▁ro q _ cell ▁* ▁results 4 ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁ro q _ cell ▁) ▁* ▁MAX _ CB S _4 x 4 ▁* ▁4 ▁) ▁; ▁uint 8_ t ▁* ▁yuv Clusters ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁int ▁) ▁* ▁max ▁* ▁6 ▁* ▁4 ▁) ▁; ▁int ▁* ▁points ▁= ▁av _ malloc ▁( ▁max ▁* ▁6 ▁* ▁4 ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁bias ▁; ▁create _ clusters ▁( ▁enc ▁-> ▁frame _ to _ enc ▁, ▁enc ▁-> ▁width ▁, ▁enc ▁-> ▁height ▁, ▁yuv Clusters ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁max ▁* ▁24 ▁; ▁i ▁++ ▁) ▁{ ▁bias ▁= ▁( ▁( ▁i ▁% ▁6 ▁) ▁< ▁4 ▁) ▁? ▁1 ▁: ▁CH RO MA _ BIAS ▁; ▁points ▁[ ▁i ▁] ▁= ▁bias ▁* ▁yuv Clusters ▁[ ▁i ▁] ▁; ▁} ▁generate _ code book ▁( ▁enc ▁, ▁temp Data ▁, ▁points ▁, ▁max ▁, ▁results 4 ▁, ▁4 ▁, ▁MAX _ CB S _4 x 4 ▁) ▁; ▁code books ▁-> ▁num CB 4 ▁= ▁MAX _ CB S _4 x 4 ▁; ▁temp Data ▁-> ▁closest _ cb 2 ▁= ▁av _ malloc ▁( ▁max ▁* ▁4 ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁generate _ code book ▁( ▁enc ▁, ▁temp Data ▁, ▁points ▁, ▁max ▁* ▁4 ▁, ▁enc ▁-> ▁cb 2 x 2 ▁, ▁2 ▁, ▁MAX _ CB S _2 x 2 ▁) ▁; ▁code books ▁-> ▁num CB 2 ▁= ▁MAX _ CB S _2 x 2 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁code books ▁-> ▁num CB 2 ▁; ▁i ▁++ ▁) ▁unpack _ ro q _ cell ▁( ▁enc ▁-> ▁cb 2 x 2 ▁+ ▁i ▁, ▁code books ▁-> ▁un packed _ cb 2 ▁+ ▁i ▁* ▁2 ▁* ▁2 ▁* ▁3 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁code books ▁-> ▁num CB 4 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁unpack _ ro q _ cell ▁( ▁& ▁results 4 ▁[ ▁4 ▁* ▁i ▁+ ▁j ▁] ▁, ▁mb 2 ▁) ▁; ▁index _ mb ▁( ▁mb 2 ▁, ▁code books ▁-> ▁un packed _ cb 2 ▁, ▁code books ▁-> ▁num CB 2 ▁, ▁& ▁enc ▁-> ▁cb 4 x 4 ▁[ ▁i ▁] ▁. ▁idx ▁[ ▁j ▁] ▁, ▁2 ▁) ▁; ▁} ▁unpack _ ro q _ q cell ▁( ▁code books ▁-> ▁un packed _ cb 2 ▁, ▁enc ▁-> ▁cb 4 x 4 ▁+ ▁i ▁, ▁code books ▁-> ▁un packed _ cb 4 ▁+ ▁i ▁* ▁4 ▁* ▁4 ▁* ▁3 ▁) ▁; ▁en large _ ro q _ mb 4 ▁( ▁code books ▁-> ▁un packed _ cb 4 ▁+ ▁i ▁* ▁4 ▁* ▁4 ▁* ▁3 ▁, ▁code books ▁-> ▁un packed _ cb 4_ en l arg ed ▁+ ▁i ▁* ▁8 ▁* ▁8 ▁* ▁3 ▁) ▁; ▁} ▁av _ free ▁( ▁yuv Clusters ▁) ▁; ▁av _ free ▁( ▁points ▁) ▁; ▁av _ free ▁( ▁results 4 ▁) ▁; ▁}	1
▁static ▁int ▁km vc _ decode _ inter _8 x 8 ▁( ▁K mvc Context ▁* ▁ctx ▁, ▁int ▁w ▁, ▁int ▁h ▁) ▁{ ▁Bit Buf ▁bb ▁; ▁int ▁res ▁, ▁val ▁; ▁int ▁i ▁, ▁j ▁; ▁int ▁bx ▁, ▁by ▁; ▁int ▁l 0 x ▁, ▁l 1 x ▁, ▁l 0 y ▁, ▁l 1 y ▁; ▁int ▁mx ▁, ▁my ▁; ▁km vc _ init _ get bits ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁for ▁( ▁by ▁= ▁0 ▁; ▁by ▁< ▁h ▁; ▁by ▁+= ▁8 ▁) ▁for ▁( ▁bx ▁= ▁0 ▁; ▁bx ▁< ▁w ▁; ▁bx ▁+= ▁8 ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁if ▁( ▁! ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Data over run \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁bx ▁+ ▁( ▁i ▁& ▁0 x 7 ▁) ▁, ▁by ▁+ ▁( ▁i ▁>> ▁3 ▁) ▁) ▁= ▁val ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁bx ▁+ ▁( ▁i ▁& ▁0 x 7 ▁) ▁, ▁by ▁+ ▁( ▁i ▁>> ▁3 ▁) ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁bx ▁+ ▁( ▁i ▁& ▁0 x 7 ▁) ▁, ▁by ▁+ ▁( ▁i ▁>> ▁3 ▁) ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁! ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Data over run \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁l 0 x ▁= ▁bx ▁+ ▁( ▁i ▁& ▁1 ▁) ▁* ▁4 ▁; ▁l 0 y ▁= ▁by ▁+ ▁( ▁i ▁& ▁2 ▁) ▁* ▁2 ▁; ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 0 x ▁+ ▁( ▁j ▁& ▁3 ▁) ▁, ▁l 0 y ▁+ ▁( ▁j ▁>> ▁2 ▁) ▁) ▁= ▁val ▁; ▁} ▁else ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁mx ▁= ▁( ▁val ▁& ▁0 xF ▁) ▁- ▁8 ▁; ▁my ▁= ▁( ▁val ▁>> ▁4 ▁) ▁- ▁8 ▁; ▁if ▁( ▁( ▁l 0 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 0 y ▁+ ▁my ▁) ▁< ▁0 ▁|| ▁( ▁l 0 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 0 y ▁+ ▁my ▁) ▁> ▁320 ▁* ▁19 7 ▁- ▁4 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid MV \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 0 x ▁+ ▁( ▁j ▁& ▁3 ▁) ▁, ▁l 0 y ▁+ ▁( ▁j ▁>> ▁2 ▁) ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 0 x ▁+ ▁( ▁j ▁& ▁3 ▁) ▁+ ▁mx ▁, ▁l 0 y ▁+ ▁( ▁j ▁>> ▁2 ▁) ▁+ ▁my ▁) ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁l 1 x ▁= ▁l 0 x ▁+ ▁( ▁j ▁& ▁1 ▁) ▁* ▁2 ▁; ▁l 1 y ▁= ▁l 0 y ▁+ ▁( ▁j ▁& ▁2 ▁) ▁; ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁) ▁= ▁val ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁) ▁= ▁val ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁val ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁val ▁; ▁} ▁else ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁mx ▁= ▁( ▁val ▁& ▁0 xF ▁) ▁- ▁8 ▁; ▁my ▁= ▁( ▁val ▁>> ▁4 ▁) ▁- ▁8 ▁; ▁if ▁( ▁( ▁l 1 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 1 y ▁+ ▁my ▁) ▁< ▁0 ▁|| ▁( ▁l 1 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 1 y ▁+ ▁my ▁) ▁> ▁320 ▁* ▁199 ▁- ▁2 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid MV \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁my ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁1 ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁my ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁1 ▁+ ▁my ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁1 ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁1 ▁+ ▁my ▁) ▁; ▁} ▁} ▁else ▁{ ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁asn 1_ ex _ i 2 c ▁( ▁ASN 1_ VALUE ▁* ▁* ▁pval ▁, ▁unsigned ▁char ▁* ▁cout ▁, ▁int ▁* ▁put ype ▁, ▁const ▁ASN 1_ ITEM ▁* ▁it ▁) ▁{ ▁ASN 1_ BOOLEAN ▁* ▁tb ool ▁= ▁NULL ▁; ▁ASN 1_ STRING ▁* ▁str tmp ▁; ▁ASN 1_ OBJECT ▁* ▁o tmp ▁; ▁int ▁ut ype ▁; ▁const ▁unsigned ▁char ▁* ▁cont ▁; ▁unsigned ▁char ▁c ▁; ▁int ▁len ▁; ▁const ▁ASN 1_ PRIMITIVE _ FUNCS ▁* ▁pf ▁; ▁pf ▁= ▁it ▁-> ▁funcs ▁; ▁if ▁( ▁pf ▁&& ▁pf ▁-> ▁prim _ i 2 c ▁) ▁return ▁pf ▁-> ▁prim _ i 2 c ▁( ▁pval ▁, ▁cout ▁, ▁put ype ▁, ▁it ▁) ▁; ▁if ▁( ▁( ▁it ▁-> ▁itype ▁!= ▁ASN 1_ ITY PE _ PRIMITIVE ▁) ▁|| ▁( ▁it ▁-> ▁ut ype ▁!= ▁V _ ASN 1_ BOOLEAN ▁) ▁) ▁{ ▁if ▁( ▁! ▁* ▁pval ▁) ▁return ▁-1 ▁; ▁} ▁if ▁( ▁it ▁-> ▁itype ▁== ▁ASN 1_ ITY PE _ M STRING ▁) ▁{ ▁str tmp ▁= ▁( ▁ASN 1_ STRING ▁* ▁) ▁* ▁pval ▁; ▁ut ype ▁= ▁str tmp ▁-> ▁type ▁; ▁* ▁put ype ▁= ▁ut ype ▁; ▁} ▁else ▁if ▁( ▁it ▁-> ▁ut ype ▁== ▁V _ ASN 1_ ANY ▁) ▁{ ▁ASN 1_ TYPE ▁* ▁typ ▁; ▁typ ▁= ▁( ▁ASN 1_ TYPE ▁* ▁) ▁* ▁pval ▁; ▁ut ype ▁= ▁typ ▁-> ▁type ▁; ▁* ▁put ype ▁= ▁ut ype ▁; ▁pval ▁= ▁& ▁typ ▁-> ▁value ▁. ▁asn 1_ value ▁; ▁} ▁else ▁ut ype ▁= ▁* ▁put ype ▁; ▁switch ▁( ▁ut ype ▁) ▁{ ▁case ▁V _ ASN 1_ OBJECT ▁: ▁o tmp ▁= ▁( ▁ASN 1_ OBJECT ▁* ▁) ▁* ▁pval ▁; ▁cont ▁= ▁o tmp ▁-> ▁data ▁; ▁len ▁= ▁o tmp ▁-> ▁length ▁; ▁break ▁; ▁case ▁V _ ASN 1_ NULL ▁: ▁cont ▁= ▁NULL ▁; ▁len ▁= ▁0 ▁; ▁break ▁; ▁case ▁V _ ASN 1_ BOOLEAN ▁: ▁tb ool ▁= ▁( ▁ASN 1_ BOOLEAN ▁* ▁) ▁pval ▁; ▁if ▁( ▁* ▁tb ool ▁== ▁-1 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁it ▁-> ▁ut ype ▁!= ▁V _ ASN 1_ ANY ▁) ▁{ ▁if ▁( ▁* ▁tb ool ▁&& ▁( ▁it ▁-> ▁size ▁> ▁0 ▁) ▁) ▁return ▁-1 ▁; ▁if ▁( ▁! ▁* ▁tb ool ▁&& ▁! ▁it ▁-> ▁size ▁) ▁return ▁-1 ▁; ▁} ▁c ▁= ▁( ▁unsigned ▁char ▁) ▁* ▁tb ool ▁; ▁cont ▁= ▁& ▁c ▁; ▁len ▁= ▁1 ▁; ▁break ▁; ▁case ▁V _ ASN 1_ BIT _ STRING ▁: ▁return ▁i 2 c _ ASN 1_ BIT _ STRING ▁( ▁( ▁ASN 1_ BIT _ STRING ▁* ▁) ▁* ▁pval ▁, ▁cout ▁? ▁& ▁cout ▁: ▁NULL ▁) ▁; ▁break ▁; ▁case ▁V _ ASN 1_ INTEGER ▁: ▁case ▁V _ ASN 1_ NEG _ INTEGER ▁: ▁case ▁V _ ASN 1_ ENUMERATED ▁: ▁case ▁V _ ASN 1_ NEG _ ENUMERATED ▁: ▁return ▁i 2 c _ ASN 1_ INTEGER ▁( ▁( ▁ASN 1_ INTEGER ▁* ▁) ▁* ▁pval ▁, ▁cout ▁? ▁& ▁cout ▁: ▁NULL ▁) ▁; ▁break ▁; ▁case ▁V _ ASN 1_ OCTET _ STRING ▁: ▁case ▁V _ ASN 1_ NUMERIC STRING ▁: ▁case ▁V _ ASN 1_ PR IN TABLES TRING ▁: ▁case ▁V _ ASN 1_ T 61 STRING ▁: ▁case ▁V _ ASN 1_ VIDE OT EX STRING ▁: ▁case ▁V _ ASN 1_ IA 5 STRING ▁: ▁case ▁V _ ASN 1_ UTC TIME ▁: ▁case ▁V _ ASN 1_ GENERAL IZED TIME ▁: ▁case ▁V _ ASN 1_ GRAPH IC STRING ▁: ▁case ▁V _ ASN 1_ VIS IB LES TRING ▁: ▁case ▁V _ ASN 1_ GENERAL STRING ▁: ▁case ▁V _ ASN 1_ UNIVERSAL STRING ▁: ▁case ▁V _ ASN 1_ BMP STRING ▁: ▁case ▁V _ ASN 1_ UTF 8 STRING ▁: ▁case ▁V _ ASN 1_ SEQUENCE ▁: ▁case ▁V _ ASN 1_ SET ▁: ▁default ▁: ▁str tmp ▁= ▁( ▁ASN 1_ STRING ▁* ▁) ▁* ▁pval ▁; ▁if ▁( ▁( ▁it ▁-> ▁size ▁== ▁ASN 1_ T FLG _ N DEF ▁) ▁&& ▁( ▁str tmp ▁-> ▁flags ▁& ▁ASN 1_ STRING _ FLAG _ N DEF ▁) ▁) ▁{ ▁if ▁( ▁cout ▁) ▁{ ▁str tmp ▁-> ▁data ▁= ▁cout ▁; ▁str tmp ▁-> ▁length ▁= ▁0 ▁; ▁} ▁return ▁-2 ▁; ▁} ▁cont ▁= ▁str tmp ▁-> ▁data ▁; ▁len ▁= ▁str tmp ▁-> ▁length ▁; ▁break ▁; ▁} ▁if ▁( ▁cout ▁&& ▁len ▁) ▁memcpy ▁( ▁cout ▁, ▁cont ▁, ▁len ▁) ▁; ▁return ▁len ▁; ▁}	1
▁static ▁int ▁sk _ reserve ▁( ▁OPENSSL _ STACK ▁* ▁st ▁, ▁int ▁n ▁, ▁int ▁exact ▁) ▁{ ▁const ▁void ▁* ▁* ▁tmp data ▁; ▁int ▁num _ alloc ▁; ▁if ▁( ▁n ▁> ▁max _ nodes ▁- ▁st ▁-> ▁num ▁) ▁return ▁0 ▁; ▁num _ alloc ▁= ▁st ▁-> ▁num ▁+ ▁n ▁; ▁if ▁( ▁num _ alloc ▁< ▁min _ nodes ▁) ▁num _ alloc ▁= ▁min _ nodes ▁; ▁if ▁( ▁st ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁st ▁-> ▁data ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁void ▁* ▁) ▁* ▁num _ alloc ▁) ▁; ▁if ▁( ▁st ▁-> ▁data ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁st ▁-> ▁num _ alloc ▁= ▁num _ alloc ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁! ▁exact ▁) ▁{ ▁if ▁( ▁num _ alloc ▁<= ▁st ▁-> ▁num _ alloc ▁) ▁return ▁1 ▁; ▁num _ alloc ▁= ▁compute _ grow th ▁( ▁num _ alloc ▁, ▁st ▁-> ▁num _ alloc ▁) ▁; ▁if ▁( ▁num _ alloc ▁== ▁0 ▁) ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁num _ alloc ▁== ▁st ▁-> ▁num _ alloc ▁) ▁{ ▁return ▁1 ▁; ▁} ▁tmp data ▁= ▁OPENSSL _ realloc ▁( ▁( ▁void ▁* ▁) ▁st ▁-> ▁data ▁, ▁sizeof ▁( ▁void ▁* ▁) ▁* ▁num _ alloc ▁) ▁; ▁if ▁( ▁tmp data ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁st ▁-> ▁data ▁= ▁tmp data ▁; ▁st ▁-> ▁num _ alloc ▁= ▁num _ alloc ▁; ▁return ▁1 ▁; ▁}	0
▁AVFilter Buffer Ref ▁* ▁avfilter _ ref _ buffer ▁( ▁AVFilter Buffer Ref ▁* ▁ref ▁, ▁int ▁p mask ▁) ▁{ ▁AVFilter Buffer Ref ▁* ▁ret ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVFilter Buffer Ref ▁) ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁return ▁NULL ▁; ▁* ▁ret ▁= ▁* ▁ref ▁; ▁if ▁( ▁ref ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁ret ▁-> ▁video ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVFilter Buffer Ref Video Props ▁) ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁video ▁) ▁{ ▁av _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁} ▁* ▁ret ▁-> ▁video ▁= ▁* ▁ref ▁-> ▁video ▁; ▁} ▁else ▁if ▁( ▁ref ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁{ ▁ret ▁-> ▁audio ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVFilter Buffer Ref Audio Props ▁) ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁audio ▁) ▁{ ▁av _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁} ▁* ▁ret ▁-> ▁audio ▁= ▁* ▁ref ▁-> ▁audio ▁; ▁} ▁ret ▁-> ▁perms ▁&= ▁p mask ▁; ▁ret ▁-> ▁buf ▁-> ▁refcount ▁++ ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁get _ s iz ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁g ▁) ▁< ▁36 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁s ▁-> ▁avctx ▁-> ▁profile ▁= ▁bytestream 2_ get _ be 16 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁width ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁height ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁image _ offset _ x ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁image _ offset _ y ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁tile _ width ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁tile _ height ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁tile _ offset _ x ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁tile _ offset _ y ▁= ▁bytestream 2_ get _ be 32 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁n components ▁= ▁bytestream 2_ get _ be 16 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁if ▁( ▁s ▁-> ▁n components ▁<= ▁0 ▁|| ▁s ▁-> ▁n components ▁> ▁4 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" unsupported / invalid n components :% d \ n " ▁, ▁s ▁-> ▁n components ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁tile _ width ▁<= ▁0 ▁|| ▁s ▁-> ▁tile _ height ▁<= ▁0 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁g ▁) ▁< ▁3 ▁* ▁s ▁-> ▁n components ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n components ▁; ▁i ▁++ ▁) ▁{ ▁uint 8_ t ▁x ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁cb ps ▁[ ▁i ▁] ▁= ▁( ▁x ▁& ▁0 x 7 f ▁) ▁+ ▁1 ▁; ▁s ▁-> ▁precision ▁= ▁FF MAX ▁( ▁s ▁-> ▁cb ps ▁[ ▁i ▁] ▁, ▁s ▁-> ▁precision ▁) ▁; ▁s ▁-> ▁sg nd ▁[ ▁i ▁] ▁= ▁( ▁x ▁& ▁0 x 80 ▁) ▁== ▁1 ▁; ▁s ▁-> ▁cd x ▁[ ▁i ▁] ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁s ▁-> ▁cd y ▁[ ▁i ▁] ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁} ▁s ▁-> ▁num X tiles ▁= ▁ff _ jpeg 2000_ ce ild iv ▁( ▁s ▁-> ▁width ▁- ▁s ▁-> ▁tile _ offset _ x ▁, ▁s ▁-> ▁tile _ width ▁) ▁; ▁s ▁-> ▁num Y tiles ▁= ▁ff _ jpeg 2000_ ce ild iv ▁( ▁s ▁-> ▁height ▁- ▁s ▁-> ▁tile _ offset _ y ▁, ▁s ▁-> ▁tile _ height ▁) ▁; ▁s ▁-> ▁tile ▁= ▁av _ malloc z ▁( ▁s ▁-> ▁num X tiles ▁* ▁s ▁-> ▁num Y tiles ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁tile ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁tile ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁num X tiles ▁* ▁s ▁-> ▁num Y tiles ▁; ▁i ▁++ ▁) ▁{ ▁J peg 2000 Tile ▁* ▁tile ▁= ▁s ▁-> ▁tile ▁+ ▁i ▁; ▁tile ▁-> ▁comp ▁= ▁av _ malloc z ▁( ▁s ▁-> ▁n components ▁* ▁sizeof ▁( ▁* ▁tile ▁-> ▁comp ▁) ▁) ▁; ▁if ▁( ▁! ▁tile ▁-> ▁comp ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁s ▁-> ▁avctx ▁-> ▁width ▁= ▁ff _ jpeg 2000_ ce ild iv pow 2 ▁( ▁s ▁-> ▁width ▁- ▁s ▁-> ▁image _ offset _ x ▁, ▁s ▁-> ▁reduction _ factor ▁) ▁; ▁s ▁-> ▁avctx ▁-> ▁height ▁= ▁ff _ jpeg 2000_ ce ild iv pow 2 ▁( ▁s ▁-> ▁height ▁- ▁s ▁-> ▁image _ offset _ y ▁, ▁s ▁-> ▁reduction _ factor ▁) ▁; ▁switch ▁( ▁s ▁-> ▁avctx ▁-> ▁profile ▁) ▁{ ▁case ▁FF _ PROFILE _ JPEG 2000_ DC INE MA _2 K ▁: ▁case ▁FF _ PROFILE _ JPEG 2000_ DC INE MA _4 K ▁: ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ XYZ 12 ▁; ▁break ▁; ▁default ▁: ▁switch ▁( ▁s ▁-> ▁n components ▁) ▁{ ▁case ▁1 ▁: ▁if ▁( ▁s ▁-> ▁precision ▁> ▁8 ▁) ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ GRAY 16 ▁; ▁else ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ GRAY 8 ▁; ▁break ▁; ▁case ▁3 ▁: ▁if ▁( ▁s ▁-> ▁precision ▁> ▁8 ▁) ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ RGB 48 ▁; ▁else ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ RGB 24 ▁; ▁break ▁; ▁case ▁4 ▁: ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ B GRA ▁; ▁break ▁; ▁default ▁: ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ NONE ▁; ▁break ▁; ▁} ▁break ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁encode _ block ▁( ▁N elly M oser Encode Context ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁output ▁, ▁int ▁output _ size ▁) ▁{ ▁Put Bit Context ▁pb ▁; ▁int ▁i ▁, ▁j ▁, ▁band ▁, ▁block ▁, ▁best _ idx ▁, ▁power _ idx ▁= ▁0 ▁; ▁float ▁power _ val ▁, ▁coeff ▁, ▁coeff _ sum ▁; ▁float ▁p ows ▁[ ▁N EL LY _ FILL _ LEN ▁] ▁; ▁int ▁bits ▁[ ▁N EL LY _ BUF _ LEN ▁] ▁, ▁idx _ table ▁[ ▁N EL LY _ BAND S ▁] ▁; ▁float ▁cand ▁[ ▁N EL LY _ BAND S ▁] ▁; ▁apply _ md ct ▁( ▁s ▁) ▁; ▁init _ put _ bits ▁( ▁& ▁pb ▁, ▁output ▁, ▁output _ size ▁* ▁8 ▁) ▁; ▁i ▁= ▁0 ▁; ▁for ▁( ▁band ▁= ▁0 ▁; ▁band ▁< ▁N EL LY _ BAND S ▁; ▁band ▁++ ▁) ▁{ ▁coeff _ sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁ff _ n elly _ band _ sizes _ table ▁[ ▁band ▁] ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁{ ▁coeff _ sum ▁+= ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁] ▁* ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁] ▁+ ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁+ ▁N EL LY _ BUF _ LEN ▁] ▁* ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁+ ▁N EL LY _ BUF _ LEN ▁] ▁; ▁} ▁cand ▁[ ▁band ▁] ▁= ▁log ▁( ▁FF MAX ▁( ▁1.0 ▁, ▁coeff _ sum ▁/ ▁( ▁ff _ n elly _ band _ sizes _ table ▁[ ▁band ▁] ▁<< ▁7 ▁) ▁) ▁) ▁* ▁1024.0 ▁/ ▁M _ LN 2 ▁; ▁} ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁tre ll is ▁) ▁{ ▁get _ exponent _ dynamic ▁( ▁s ▁, ▁cand ▁, ▁idx _ table ▁) ▁; ▁} ▁else ▁{ ▁get _ exponent _ g reedy ▁( ▁s ▁, ▁cand ▁, ▁idx _ table ▁) ▁; ▁} ▁i ▁= ▁0 ▁; ▁for ▁( ▁band ▁= ▁0 ▁; ▁band ▁< ▁N EL LY _ BAND S ▁; ▁band ▁++ ▁) ▁{ ▁if ▁( ▁band ▁) ▁{ ▁power _ idx ▁+= ▁ff _ n elly _ delta _ table ▁[ ▁idx _ table ▁[ ▁band ▁] ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁5 ▁, ▁idx _ table ▁[ ▁band ▁] ▁) ▁; ▁} ▁else ▁{ ▁power _ idx ▁= ▁ff _ n elly _ init _ table ▁[ ▁idx _ table ▁[ ▁0 ▁] ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁6 ▁, ▁idx _ table ▁[ ▁0 ▁] ▁) ▁; ▁} ▁power _ val ▁= ▁pow _ table ▁[ ▁power _ idx ▁& ▁0 x 7 FF ▁] ▁/ ▁( ▁1 ▁<< ▁( ▁( ▁power _ idx ▁>> ▁11 ▁) ▁+ ▁PO W _ TABLE _ OFFSET ▁) ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁ff _ n elly _ band _ sizes _ table ▁[ ▁band ▁] ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁{ ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁] ▁*= ▁power _ val ▁; ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁+ ▁N EL LY _ BUF _ LEN ▁] ▁*= ▁power _ val ▁; ▁p ows ▁[ ▁i ▁] ▁= ▁power _ idx ▁; ▁} ▁} ▁ff _ n elly _ get _ sample _ bits ▁( ▁p ows ▁, ▁bits ▁) ▁; ▁for ▁( ▁block ▁= ▁0 ▁; ▁block ▁< ▁2 ▁; ▁block ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N EL LY _ FILL _ LEN ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁bits ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁const ▁float ▁* ▁table ▁= ▁ff _ n elly _ de quant ization _ table ▁+ ▁( ▁1 ▁<< ▁bits ▁[ ▁i ▁] ▁) ▁- ▁1 ▁; ▁coeff ▁= ▁s ▁-> ▁md ct _ out ▁[ ▁block ▁* ▁N EL LY _ BUF _ LEN ▁+ ▁i ▁] ▁; ▁best _ idx ▁= ▁quant _ lut ▁[ ▁av _ clip ▁( ▁coeff ▁* ▁quant _ lut _ mul ▁[ ▁bits ▁[ ▁i ▁] ▁] ▁+ ▁quant _ lut _ add ▁[ ▁bits ▁[ ▁i ▁] ▁] ▁, ▁quant _ lut _ offset ▁[ ▁bits ▁[ ▁i ▁] ▁] ▁, ▁quant _ lut _ offset ▁[ ▁bits ▁[ ▁i ▁] ▁+ ▁1 ▁] ▁- ▁1 ▁) ▁] ▁; ▁if ▁( ▁fabs ▁( ▁coeff ▁- ▁table ▁[ ▁best _ idx ▁] ▁) ▁> ▁fabs ▁( ▁coeff ▁- ▁table ▁[ ▁best _ idx ▁+ ▁1 ▁] ▁) ▁) ▁best _ idx ▁++ ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁bits ▁[ ▁i ▁] ▁, ▁best _ idx ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁block ▁) ▁put _ bits ▁( ▁& ▁pb ▁, ▁N EL LY _ HEADER _ BITS ▁+ ▁N EL LY _ DETAIL _ BITS ▁- ▁put _ bits _ count ▁( ▁& ▁pb ▁) ▁, ▁0 ▁) ▁; ▁} ▁flush _ put _ bits ▁( ▁& ▁pb ▁) ▁; ▁memset ▁( ▁put _ bits _ ptr ▁( ▁& ▁pb ▁) ▁, ▁0 ▁, ▁output ▁+ ▁output _ size ▁- ▁put _ bits _ ptr ▁( ▁& ▁pb ▁) ▁) ▁; ▁}	1
▁int 64_ t ▁av _ re scale _ q _ rnd ▁( ▁int 64_ t ▁a ▁, ▁AVR ational ▁bq ▁, ▁AVR ational ▁cq ▁, ▁enum ▁AV Round ing ▁rnd ▁) ▁{ ▁int 64_ t ▁b ▁= ▁bq ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁cq ▁. ▁den ▁; ▁int 64_ t ▁c ▁= ▁cq ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁bq ▁. ▁den ▁; ▁return ▁av _ re scale _ rnd ▁( ▁a ▁, ▁b ▁, ▁c ▁, ▁rnd ▁) ▁; ▁}	1
▁static ▁int ▁pcm _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁int ▁ret ▁, ▁size ▁, ▁bps ▁; ▁size ▁= ▁RAW _ SAMPLES ▁* ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁-> ▁block _ align ▁; ▁ret ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁size ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁bps ▁= ▁av _ get _ bits _ per _ sample ▁( ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁-> ▁codec _ id ▁) ▁; ▁assert ▁( ▁bps ▁) ▁; ▁pkt ▁-> ▁dts ▁= ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁pos ▁* ▁8 ▁/ ▁( ▁bps ▁* ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁-> ▁channels ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁char ▁* ▁mk _ file _ path ▁( ▁const ▁char ▁* ▁dir ▁, ▁const ▁char ▁* ▁file ▁) ▁{ ▁char ▁* ▁full _ file ▁= ▁NULL ▁; ▁size _ t ▁full _ file _ l ▁= ▁0 ▁; ▁const ▁char ▁* ▁sep ▁= ▁"" ▁; ▁# ifndef ▁OPENSSL _ SYS _ VMS ▁sep ▁= ▁"/" ▁; ▁# endif ▁full _ file _ l ▁= ▁strlen ▁( ▁dir ▁) ▁+ ▁strlen ▁( ▁sep ▁) ▁+ ▁strlen ▁( ▁file ▁) ▁+ ▁1 ▁; ▁full _ file ▁= ▁OPENSSL _ zalloc ▁( ▁full _ file _ l ▁) ▁; ▁if ▁( ▁full _ file ▁!= ▁NULL ▁) ▁{ ▁OPENSSL _ strlcpy ▁( ▁full _ file ▁, ▁dir ▁, ▁full _ file _ l ▁) ▁; ▁OPENSSL _ strl cat ▁( ▁full _ file ▁, ▁sep ▁, ▁full _ file _ l ▁) ▁; ▁OPENSSL _ strl cat ▁( ▁full _ file ▁, ▁file ▁, ▁full _ file _ l ▁) ▁; ▁} ▁return ▁full _ file ▁; ▁}	1
▁static ▁int ▁opt _ stream id ▁( ▁const ▁char ▁* ▁opt ▁, ▁const ▁char ▁* ▁arg ▁) ▁{ ▁int ▁idx ▁; ▁char ▁* ▁p ▁; ▁char ▁idx _ str ▁[ ▁16 ▁] ▁; ▁av _ strlcpy ▁( ▁idx _ str ▁, ▁arg ▁, ▁sizeof ▁( ▁idx _ str ▁) ▁) ▁; ▁p ▁= ▁strchr ▁( ▁idx _ str ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁! ▁p ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Invalid value ' % s ' for option ' % s ', require ds yntax is ' index : value '\ n " ▁, ▁arg ▁, ▁opt ▁) ▁; ▁ffmpeg _ exit ▁( ▁1 ▁) ▁; ▁} ▁* ▁p ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁idx ▁= ▁parse _ number _ or _ die ▁( ▁opt ▁, ▁idx _ str ▁, ▁OPT _ INT ▁, ▁0 ▁, ▁INT _ MAX ▁) ▁; ▁stream id _ map ▁= ▁grow _ array ▁( ▁stream id _ map ▁, ▁sizeof ▁( ▁* ▁stream id _ map ▁) ▁, ▁& ▁nb _ stream id _ map ▁, ▁idx ▁+ ▁1 ▁) ▁; ▁stream id _ map ▁[ ▁idx ▁] ▁= ▁parse _ number _ or _ die ▁( ▁opt ▁, ▁p ▁, ▁OPT _ INT ▁, ▁0 ▁, ▁INT _ MAX ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁fix _ hostname ▁( ▁request _ rec ▁* ▁r ▁, ▁const ▁char ▁* ▁host _ header ▁) ▁{ ▁const ▁char ▁* ▁src ▁; ▁char ▁* ▁host ▁, ▁* ▁scope _ id ▁; ▁apr _ port _ t ▁port ▁; ▁apr _ status _ t ▁rv ▁; ▁const ▁char ▁* ▁c ▁; ▁src ▁= ▁host _ header ▁? ▁host _ header ▁: ▁r ▁-> ▁hostname ▁; ▁if ▁( ▁! ▁* ▁src ▁) ▁{ ▁return ▁; ▁} ▁for ▁( ▁c ▁= ▁src ▁; ▁apr _ is digit ▁( ▁* ▁c ▁) ▁; ▁++ ▁c ▁) ▁; ▁if ▁( ▁! ▁* ▁c ▁) ▁{ ▁r ▁-> ▁hostname ▁= ▁src ▁; ▁return ▁; ▁} ▁if ▁( ▁host _ header ▁) ▁{ ▁rv ▁= ▁apr _ parse _ addr _ port ▁( ▁& ▁host ▁, ▁& ▁scope _ id ▁, ▁& ▁port ▁, ▁src ▁, ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁|| ▁scope _ id ▁) ▁goto ▁bad ▁; ▁if ▁( ▁port ▁) ▁{ ▁r ▁-> ▁parsed _ uri ▁. ▁port ▁= ▁port ▁; ▁r ▁-> ▁parsed _ uri ▁. ▁port _ str ▁= ▁apr _ ito a ▁( ▁r ▁-> ▁pool ▁, ▁( ▁int ▁) ▁port ▁) ▁; ▁} ▁if ▁( ▁host _ header ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁rv ▁= ▁fix _ hostname _ v 6_ literal ▁( ▁r ▁, ▁host ▁) ▁; ▁else ▁rv ▁= ▁fix _ hostname _ non _ v 6 ▁( ▁r ▁, ▁host ▁) ▁; ▁} ▁else ▁{ ▁host ▁= ▁apr _ p strdup ▁( ▁r ▁-> ▁pool ▁, ▁r ▁-> ▁hostname ▁) ▁; ▁if ▁( ▁ap _ strchr ▁( ▁host ▁, ▁' ▁' ▁) ▁!= ▁NULL ▁) ▁rv ▁= ▁fix _ hostname _ v 6_ literal ▁( ▁r ▁, ▁host ▁) ▁; ▁else ▁rv ▁= ▁fix _ hostname _ non _ v 6 ▁( ▁r ▁, ▁host ▁) ▁; ▁} ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁goto ▁bad ▁; ▁r ▁-> ▁hostname ▁= ▁host ▁; ▁return ▁; ▁bad ▁: ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 05 50 ▁) ▁" Client sent m alformed Host header :% s " ▁, ▁r ▁-> ▁hostname ▁) ▁; ▁return ▁; ▁}	0
▁static ▁int ▁m xf _ read _ index _ entry _ array ▁( ▁AVIO Context ▁* ▁pb ▁, ▁MX F Index Table Segment ▁* ▁segment ▁) ▁{ ▁int ▁i ▁, ▁length ▁; ▁segment ▁-> ▁nb _ index _ entries ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁length ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁segment ▁-> ▁nb _ index _ entries ▁&& ▁length ▁< ▁11 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁! ▁( ▁segment ▁-> ▁temporal _ offset _ entries ▁= ▁av _ calloc ▁( ▁segment ▁-> ▁nb _ index _ entries ▁, ▁sizeof ▁( ▁* ▁segment ▁-> ▁temporal _ offset _ entries ▁) ▁) ▁) ▁|| ▁! ▁( ▁segment ▁-> ▁flag _ entries ▁= ▁av _ calloc ▁( ▁segment ▁-> ▁nb _ index _ entries ▁, ▁sizeof ▁( ▁* ▁segment ▁-> ▁flag _ entries ▁) ▁) ▁) ▁|| ▁! ▁( ▁segment ▁-> ▁stream _ offset _ entries ▁= ▁av _ calloc ▁( ▁segment ▁-> ▁nb _ index _ entries ▁, ▁sizeof ▁( ▁* ▁segment ▁-> ▁stream _ offset _ entries ▁) ▁) ▁) ▁) ▁{ ▁av _ freep ▁( ▁& ▁segment ▁-> ▁temporal _ offset _ entries ▁) ▁; ▁av _ freep ▁( ▁& ▁segment ▁-> ▁flag _ entries ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁segment ▁-> ▁nb _ index _ entries ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁avio _ fe of ▁( ▁pb ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁segment ▁-> ▁temporal _ offset _ entries ▁[ ▁i ▁] ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁segment ▁-> ▁flag _ entries ▁[ ▁i ▁] ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁segment ▁-> ▁stream _ offset _ entries ▁[ ▁i ▁] ▁= ▁avio _ rb 64 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁length ▁- ▁11 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁print _ report ▁( ▁OutputFile ▁* ▁output _ files ▁, ▁OutputStream ▁* ▁o st _ table ▁, ▁int ▁nb _ ostream s ▁, ▁int ▁is _ last _ report ▁, ▁int 64_ t ▁timer _ start ▁, ▁int 64_ t ▁cur _ time ▁) ▁{ ▁char ▁buf ▁[ ▁1024 ▁] ▁; ▁OutputStream ▁* ▁o st ▁; ▁AVFormatContext ▁* ▁oc ▁; ▁int 64_ t ▁total _ size ▁; ▁AVCodecContext ▁* ▁enc ▁; ▁int ▁frame _ number ▁, ▁vid ▁, ▁i ▁; ▁double ▁bitrate ▁; ▁int 64_ t ▁pts ▁= ▁INT 64_ MAX ▁; ▁static ▁int 64_ t ▁last _ time ▁= ▁-1 ▁; ▁static ▁int ▁qp _ histogram ▁[ ▁52 ▁] ▁; ▁int ▁hours ▁, ▁mins ▁, ▁secs ▁, ▁us ▁; ▁if ▁( ▁! ▁is _ last _ report ▁) ▁{ ▁if ▁( ▁last _ time ▁== ▁-1 ▁) ▁{ ▁last _ time ▁= ▁cur _ time ▁; ▁return ▁; ▁} ▁if ▁( ▁( ▁cur _ time ▁- ▁last _ time ▁) ▁< ▁500000 ▁) ▁return ▁; ▁last _ time ▁= ▁cur _ time ▁; ▁} ▁oc ▁= ▁output _ files ▁[ ▁0 ▁] ▁. ▁ctx ▁; ▁total _ size ▁= ▁avio _ size ▁( ▁oc ▁-> ▁pb ▁) ▁; ▁if ▁( ▁total _ size ▁< ▁0 ▁) ▁total _ size ▁= ▁avio _ tell ▁( ▁oc ▁-> ▁pb ▁) ▁; ▁buf ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁vid ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ ostream s ▁; ▁i ▁++ ▁) ▁{ ▁float ▁q ▁= ▁-1 ▁; ▁o st ▁= ▁& ▁o st _ table ▁[ ▁i ▁] ▁; ▁enc ▁= ▁o st ▁-> ▁st ▁-> ▁codec ▁; ▁if ▁( ▁! ▁o st ▁-> ▁st ▁-> ▁stream _ copy ▁&& ▁enc ▁-> ▁coded _ frame ▁) ▁q ▁= ▁enc ▁-> ▁coded _ frame ▁-> ▁quality ▁/ ▁( ▁float ▁) ▁FF _ QP 2 L AMBDA ▁; ▁if ▁( ▁vid ▁&& ▁enc ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" q =% 2.1 f " ▁, ▁q ▁) ▁; ▁} ▁if ▁( ▁! ▁vid ▁&& ▁enc ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁float ▁t ▁= ▁( ▁cur _ time ▁- ▁timer _ start ▁) ▁/ ▁1000000.0 ▁; ▁frame _ number ▁= ▁o st ▁-> ▁frame _ number ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" frame =% 5 df ps =% 3 dq =% 3.1 f " ▁, ▁frame _ number ▁, ▁( ▁t ▁> ▁1 ▁) ▁? ▁( ▁int ▁) ▁( ▁frame _ number ▁/ ▁t ▁+ ▁0.5 ▁) ▁: ▁0 ▁, ▁q ▁) ▁; ▁if ▁( ▁is _ last _ report ▁) ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" L " ▁) ▁; ▁if ▁( ▁qp _ hist ▁) ▁{ ▁int ▁j ▁; ▁int ▁qp ▁= ▁l rintf ▁( ▁q ▁) ▁; ▁if ▁( ▁qp ▁>= ▁0 ▁&& ▁qp ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁qp _ histogram ▁) ▁) ▁qp _ histogram ▁[ ▁qp ▁] ▁++ ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁32 ▁; ▁j ▁++ ▁) ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"% X " ▁, ▁( ▁int ▁) ▁l rintf ▁( ▁log ▁( ▁qp _ histogram ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁/ ▁log ▁( ▁2 ▁) ▁) ▁) ▁; ▁} ▁if ▁( ▁enc ▁-> ▁flags ▁& ▁CODEC _ FLAG _ PS NR ▁) ▁{ ▁int ▁j ▁; ▁double ▁error ▁, ▁error _ sum ▁= ▁0 ▁; ▁double ▁scale ▁, ▁scale _ sum ▁= ▁0 ▁; ▁char ▁type ▁[ ▁3 ▁] ▁= ▁{ ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁} ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" PS NR =" ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁3 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is _ last _ report ▁) ▁{ ▁error ▁= ▁enc ▁-> ▁error ▁[ ▁j ▁] ▁; ▁scale ▁= ▁enc ▁-> ▁width ▁* ▁enc ▁-> ▁height ▁* ▁255.0 ▁* ▁255.0 ▁* ▁frame _ number ▁; ▁} ▁else ▁{ ▁error ▁= ▁enc ▁-> ▁coded _ frame ▁-> ▁error ▁[ ▁j ▁] ▁; ▁scale ▁= ▁enc ▁-> ▁width ▁* ▁enc ▁-> ▁height ▁* ▁255.0 ▁* ▁255.0 ▁; ▁} ▁if ▁( ▁j ▁) ▁scale ▁/= ▁4 ▁; ▁error _ sum ▁+= ▁error ▁; ▁scale _ sum ▁+= ▁scale ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"% c :% 2.2 f " ▁, ▁type ▁[ ▁j ▁] ▁, ▁ps nr ▁( ▁error ▁/ ▁scale ▁) ▁) ▁; ▁} ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"* :% 2.2 f " ▁, ▁ps nr ▁( ▁error _ sum ▁/ ▁scale _ sum ▁) ▁) ▁; ▁} ▁vid ▁= ▁1 ▁; ▁} ▁pts ▁= ▁FF MIN ▁( ▁pts ▁, ▁av _ re scale _ q ▁( ▁o st ▁-> ▁st ▁-> ▁pts ▁. ▁val ▁, ▁o st ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁) ▁; ▁} ▁secs ▁= ▁pts ▁/ ▁AV _ TIME _ BASE ▁; ▁us ▁= ▁pts ▁% ▁AV _ TIME _ BASE ▁; ▁mins ▁= ▁secs ▁/ ▁60 ▁; ▁secs ▁%= ▁60 ▁; ▁hours ▁= ▁mins ▁/ ▁60 ▁; ▁mins ▁%= ▁60 ▁; ▁bitrate ▁= ▁pts ▁? ▁total _ size ▁* ▁8 ▁/ ▁( ▁pts ▁/ ▁1000.0 ▁) ▁: ▁0 ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" size =% 8 .0 f k B time =" ▁, ▁total _ size ▁/ ▁1024.0 ▁) ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"%02 d :%02 d :%02 d . %02 d " ▁, ▁hours ▁, ▁mins ▁, ▁secs ▁, ▁( ▁100 ▁* ▁us ▁) ▁/ ▁AV _ TIME _ BASE ▁) ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" bitrate =% 6.1 f k bits / s " ▁, ▁bitrate ▁) ▁; ▁if ▁( ▁nb _ frames _ dup ▁|| ▁nb _ frames _ drop ▁) ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" dup =% dd rop =% d " ▁, ▁nb _ frames _ dup ▁, ▁nb _ frames _ drop ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁is _ last _ report ▁? ▁AV _ LOG _ WARNING ▁: ▁AV _ LOG _ INFO ▁, ▁"% s \ r " ▁, ▁buf ▁) ▁; ▁fflush ▁( ▁stderr ▁) ▁; ▁if ▁( ▁is _ last _ report ▁) ▁{ ▁int 64_ t ▁raw ▁= ▁audio _ size ▁+ ▁video _ size ▁+ ▁extra _ size ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ INFO ▁, ▁"\ n " ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ INFO ▁, ▁" video :% 1.0 f k B audio :% 1.0 f k B global headers :% 1.0 f k B mux ing overhead % f %% \ n " ▁, ▁video _ size ▁/ ▁1024.0 ▁, ▁audio _ size ▁/ ▁1024.0 ▁, ▁extra _ size ▁/ ▁1024.0 ▁, ▁100.0 ▁* ▁( ▁total _ size ▁- ▁raw ▁) ▁/ ▁raw ▁) ▁; ▁} ▁}	0
▁static ▁int ▁dvb sub _ display _ end _ segment ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁AV Subtitle ▁* ▁sub ▁) ▁{ ▁DVB Sub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁DVB Sub Display Definition ▁* ▁display _ def ▁= ▁ctx ▁-> ▁display _ definition ▁; ▁DVB Sub Region ▁* ▁region ▁; ▁DVB Sub Region Display ▁* ▁display ▁; ▁AV Subtitle Rect ▁* ▁rect ▁; ▁DVB Sub CL UT ▁* ▁cl ut ▁; ▁uint 32_ t ▁* ▁cl ut _ table ▁; ▁int ▁i ▁; ▁int ▁offset _ x ▁= ▁0 ▁, ▁offset _ y ▁= ▁0 ▁; ▁sub ▁-> ▁rects ▁= ▁NULL ▁; ▁sub ▁-> ▁start _ display _ time ▁= ▁0 ▁; ▁sub ▁-> ▁end _ display _ time ▁= ▁ctx ▁-> ▁time _ out ▁* ▁1000 ▁; ▁sub ▁-> ▁format ▁= ▁0 ▁; ▁if ▁( ▁display _ def ▁) ▁{ ▁offset _ x ▁= ▁display _ def ▁-> ▁x ▁; ▁offset _ y ▁= ▁display _ def ▁-> ▁y ▁; ▁} ▁sub ▁-> ▁num _ rect s ▁= ▁ctx ▁-> ▁display _ list _ size ▁; ▁if ▁( ▁sub ▁-> ▁num _ rect s ▁> ▁0 ▁) ▁{ ▁sub ▁-> ▁rects ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁sub ▁-> ▁rects ▁) ▁* ▁sub ▁-> ▁num _ rect s ▁) ▁; ▁if ▁( ▁! ▁sub ▁-> ▁rects ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sub ▁-> ▁num _ rect s ▁; ▁i ▁++ ▁) ▁{ ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁) ▁) ▁; ▁if ▁( ▁! ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁} ▁} ▁i ▁= ▁0 ▁; ▁for ▁( ▁display ▁= ▁ctx ▁-> ▁display _ list ▁; ▁display ▁; ▁display ▁= ▁display ▁-> ▁next ▁) ▁{ ▁region ▁= ▁get _ region ▁( ▁ctx ▁, ▁display ▁-> ▁region _ id ▁) ▁; ▁rect ▁= ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁region ▁) ▁continue ▁; ▁rect ▁-> ▁x ▁= ▁display ▁-> ▁x _ pos ▁+ ▁offset _ x ▁; ▁rect ▁-> ▁y ▁= ▁display ▁-> ▁y _ pos ▁+ ▁offset _ y ▁; ▁rect ▁-> ▁w ▁= ▁region ▁-> ▁width ▁; ▁rect ▁-> ▁h ▁= ▁region ▁-> ▁height ▁; ▁rect ▁-> ▁nb _ colors ▁= ▁16 ▁; ▁rect ▁-> ▁type ▁= ▁SUB TITLE _ BITMAP ▁; ▁rect ▁-> ▁linesize ▁[ ▁0 ▁] ▁= ▁region ▁-> ▁width ▁; ▁cl ut ▁= ▁get _ cl ut ▁( ▁ctx ▁, ▁region ▁-> ▁cl ut ▁) ▁; ▁if ▁( ▁! ▁cl ut ▁) ▁cl ut ▁= ▁& ▁default _ cl ut ▁; ▁switch ▁( ▁region ▁-> ▁depth ▁) ▁{ ▁case ▁2 ▁: ▁cl ut _ table ▁= ▁cl ut ▁-> ▁cl ut 4 ▁; ▁break ▁; ▁case ▁8 ▁: ▁cl ut _ table ▁= ▁cl ut ▁-> ▁cl ut 256 ▁; ▁break ▁; ▁case ▁4 ▁: ▁default ▁: ▁cl ut _ table ▁= ▁cl ut ▁-> ▁cl ut 16 ▁; ▁break ▁; ▁} ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁= ▁av _ malloc z ▁( ▁AV PALETTE _ SIZE ▁) ▁; ▁if ▁( ▁! ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁) ▁{ ▁av _ free ▁( ▁sub ▁-> ▁rects ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁memcpy ▁( ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁cl ut _ table ▁, ▁( ▁1 ▁<< ▁region ▁-> ▁depth ▁) ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁) ▁; ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁= ▁av _ malloc ▁( ▁region ▁-> ▁buf _ size ▁) ▁; ▁if ▁( ▁! ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁{ ▁av _ free ▁( ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁) ▁; ▁av _ free ▁( ▁sub ▁-> ▁rects ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁memcpy ▁( ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁region ▁-> ▁pbuf ▁, ▁region ▁-> ▁buf _ size ▁) ▁; ▁# if ▁FF _ API _ AV PICTURE ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁rect ▁-> ▁pict ▁. ▁data ▁[ ▁j ▁] ▁= ▁rect ▁-> ▁data ▁[ ▁j ▁] ▁; ▁rect ▁-> ▁pict ▁. ▁linesize ▁[ ▁j ▁] ▁= ▁rect ▁-> ▁linesize ▁[ ▁j ▁] ▁; ▁} ▁} ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁# endif ▁i ▁++ ▁; ▁} ▁sub ▁-> ▁num _ rect s ▁= ▁i ▁; ▁# ifdef ▁DEBUG ▁save _ display _ set ▁( ▁ctx ▁) ▁; ▁# endif ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁y 41 p _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁AVFrame ▁* ▁pic ▁= ▁data ▁; ▁uint 8_ t ▁* ▁src ▁= ▁avpkt ▁-> ▁data ▁; ▁uint 8_ t ▁* ▁y ▁, ▁* ▁u ▁, ▁* ▁v ▁; ▁int ▁i ▁, ▁j ▁, ▁ret ▁; ▁if ▁( ▁avpkt ▁-> ▁size ▁< ▁3 LL ▁* ▁avctx ▁-> ▁height ▁* ▁avctx ▁-> ▁width ▁/ ▁2 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Ins ufficient input data .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁pic ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁pic ▁-> ▁key _ frame ▁= ▁1 ▁; ▁pic ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁for ▁( ▁i ▁= ▁avctx ▁-> ▁height ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁y ▁= ▁& ▁pic ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁i ▁* ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁; ▁u ▁= ▁& ▁pic ▁-> ▁data ▁[ ▁1 ▁] ▁[ ▁i ▁* ▁pic ▁-> ▁linesize ▁[ ▁1 ▁] ▁] ▁; ▁v ▁= ▁& ▁pic ▁-> ▁data ▁[ ▁2 ▁] ▁[ ▁i ▁* ▁pic ▁-> ▁linesize ▁[ ▁2 ▁] ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁avctx ▁-> ▁width ▁; ▁j ▁+= ▁8 ▁) ▁{ ▁* ▁( ▁u ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁v ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁u ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁v ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁* ▁( ▁y ▁++ ▁) ▁= ▁* ▁src ▁++ ▁; ▁} ▁} ▁* ▁got _ frame ▁= ▁1 ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁}	1
▁AP _ DECLARE ▁( ▁char ▁* ▁) ▁ap _ escape _ log item ▁( ▁apr _ pool _ t ▁* ▁p ▁, ▁const ▁char ▁* ▁str ▁) ▁{ ▁char ▁* ▁ret ▁; ▁unsigned ▁char ▁* ▁d ▁; ▁const ▁unsigned ▁char ▁* ▁s ▁; ▁apr _ size _ t ▁length ▁, ▁escap es ▁= ▁0 ▁; ▁if ▁( ▁! ▁str ▁) ▁{ ▁return ▁NULL ▁; ▁} ▁s ▁= ▁( ▁const ▁unsigned ▁char ▁* ▁) ▁str ▁; ▁for ▁( ▁; ▁* ▁s ▁; ▁++ ▁s ▁) ▁{ ▁if ▁( ▁TEST _ CHAR ▁( ▁* ▁s ▁, ▁T _ ESCAPE _ LOG ITEM ▁) ▁) ▁{ ▁escap es ▁++ ▁; ▁} ▁} ▁length ▁= ▁s ▁- ▁( ▁const ▁unsigned ▁char ▁* ▁) ▁str ▁+ ▁1 ▁; ▁if ▁( ▁escap es ▁== ▁0 ▁) ▁{ ▁return ▁apr _ pmem dup ▁( ▁p ▁, ▁str ▁, ▁length ▁) ▁; ▁} ▁ret ▁= ▁apr _ palloc ▁( ▁p ▁, ▁length ▁+ ▁3 ▁* ▁escap es ▁) ▁; ▁d ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁ret ▁; ▁s ▁= ▁( ▁const ▁unsigned ▁char ▁* ▁) ▁str ▁; ▁for ▁( ▁; ▁* ▁s ▁; ▁++ ▁s ▁) ▁{ ▁if ▁( ▁TEST _ CHAR ▁( ▁* ▁s ▁, ▁T _ ESCAPE _ LOG ITEM ▁) ▁) ▁{ ▁* ▁d ▁++ ▁= ▁' ▁\\ ▁' ▁; ▁switch ▁( ▁* ▁s ▁) ▁{ ▁case ▁' ▁\ b ▁' ▁: ▁* ▁d ▁++ ▁= ▁' ▁' ▁; ▁break ▁; ▁case ▁' ▁\ n ▁' ▁: ▁* ▁d ▁++ ▁= ▁' ▁' ▁; ▁break ▁; ▁case ▁' ▁\ r ▁' ▁: ▁* ▁d ▁++ ▁= ▁' ▁' ▁; ▁break ▁; ▁case ▁' ▁\ t ▁' ▁: ▁* ▁d ▁++ ▁= ▁' ▁' ▁; ▁break ▁; ▁case ▁' ▁\ v ▁' ▁: ▁* ▁d ▁++ ▁= ▁' ▁' ▁; ▁break ▁; ▁case ▁' ▁\\ ▁' ▁: ▁case ▁' ▁' ▁: ▁* ▁d ▁++ ▁= ▁* ▁s ▁; ▁break ▁; ▁default ▁: ▁c 2 x ▁( ▁* ▁s ▁, ▁' ▁' ▁, ▁d ▁) ▁; ▁d ▁+= ▁3 ▁; ▁} ▁} ▁else ▁{ ▁* ▁d ▁++ ▁= ▁* ▁s ▁; ▁} ▁} ▁* ▁d ▁= ▁' ▁\0 ▁' ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁scaling _ list _ data ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁Scaling List ▁* ▁sl ▁, ▁H EV C SP S ▁* ▁sps ▁) ▁{ ▁uint 8_ t ▁scaling _ list _ pred _ mode _ flag ▁; ▁int 32_ t ▁scaling _ list _ dc _ coef ▁[ ▁2 ▁] ▁[ ▁6 ▁] ▁; ▁int ▁size _ id ▁, ▁matrix _ id ▁, ▁pos ▁; ▁int ▁i ▁; ▁for ▁( ▁size _ id ▁= ▁0 ▁; ▁size _ id ▁< ▁4 ▁; ▁size _ id ▁++ ▁) ▁for ▁( ▁matrix _ id ▁= ▁0 ▁; ▁matrix _ id ▁< ▁6 ▁; ▁matrix _ id ▁+= ▁( ▁( ▁size _ id ▁== ▁3 ▁) ▁? ▁3 ▁: ▁1 ▁) ▁) ▁{ ▁scaling _ list _ pred _ mode _ flag ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁if ▁( ▁! ▁scaling _ list _ pred _ mode _ flag ▁) ▁{ ▁unsigned ▁int ▁delta ▁= ▁get _ ue _ go lo mb _ long ▁( ▁gb ▁) ▁; ▁if ▁( ▁delta ▁) ▁{ ▁if ▁( ▁matrix _ id ▁< ▁delta ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid del tain scaling list data :% d .\ n " ▁, ▁delta ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁memcpy ▁( ▁sl ▁-> ▁sl ▁[ ▁size _ id ▁] ▁[ ▁matrix _ id ▁] ▁, ▁sl ▁-> ▁sl ▁[ ▁size _ id ▁] ▁[ ▁matrix _ id ▁- ▁delta ▁] ▁, ▁size _ id ▁> ▁0 ▁? ▁64 ▁: ▁16 ▁) ▁; ▁if ▁( ▁size _ id ▁> ▁1 ▁) ▁sl ▁-> ▁sl _ dc ▁[ ▁size _ id ▁- ▁2 ▁] ▁[ ▁matrix _ id ▁] ▁= ▁sl ▁-> ▁sl _ dc ▁[ ▁size _ id ▁- ▁2 ▁] ▁[ ▁matrix _ id ▁- ▁delta ▁] ▁; ▁} ▁} ▁else ▁{ ▁int ▁next _ coef ▁, ▁coef _ num ▁; ▁int 32_ t ▁scaling _ list _ delta _ coef ▁; ▁next _ coef ▁= ▁8 ▁; ▁coef _ num ▁= ▁FF MIN ▁( ▁64 ▁, ▁1 ▁<< ▁( ▁4 ▁+ ▁( ▁size _ id ▁<< ▁1 ▁) ▁) ▁) ▁; ▁if ▁( ▁size _ id ▁> ▁1 ▁) ▁{ ▁scaling _ list _ dc _ coef ▁[ ▁size _ id ▁- ▁2 ▁] ▁[ ▁matrix _ id ▁] ▁= ▁get _ se _ go lo mb ▁( ▁gb ▁) ▁+ ▁8 ▁; ▁next _ coef ▁= ▁scaling _ list _ dc _ coef ▁[ ▁size _ id ▁- ▁2 ▁] ▁[ ▁matrix _ id ▁] ▁; ▁sl ▁-> ▁sl _ dc ▁[ ▁size _ id ▁- ▁2 ▁] ▁[ ▁matrix _ id ▁] ▁= ▁next _ coef ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁coef _ num ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁size _ id ▁== ▁0 ▁) ▁pos ▁= ▁4 ▁* ▁ff _ he vc _ diag _ scan 4 x 4_ y ▁[ ▁i ▁] ▁+ ▁ff _ he vc _ diag _ scan 4 x 4_ x ▁[ ▁i ▁] ▁; ▁else ▁pos ▁= ▁8 ▁* ▁ff _ he vc _ diag _ scan 8 x 8_ y ▁[ ▁i ▁] ▁+ ▁ff _ he vc _ diag _ scan 8 x 8_ x ▁[ ▁i ▁] ▁; ▁scaling _ list _ delta _ coef ▁= ▁get _ se _ go lo mb ▁( ▁gb ▁) ▁; ▁next _ coef ▁= ▁( ▁next _ coef ▁+ ▁scaling _ list _ delta _ coef ▁+ ▁256 ▁) ▁% ▁256 ▁; ▁sl ▁-> ▁sl ▁[ ▁size _ id ▁] ▁[ ▁matrix _ id ▁] ▁[ ▁pos ▁] ▁= ▁next _ coef ▁; ▁} ▁} ▁} ▁if ▁( ▁sps ▁-> ▁chroma _ format _ id c ▁== ▁3 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁{ ▁sl ▁-> ▁sl ▁[ ▁3 ▁] ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁sl ▁-> ▁sl ▁[ ▁2 ▁] ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁; ▁sl ▁-> ▁sl ▁[ ▁3 ▁] ▁[ ▁2 ▁] ▁[ ▁i ▁] ▁= ▁sl ▁-> ▁sl ▁[ ▁2 ▁] ▁[ ▁2 ▁] ▁[ ▁i ▁] ▁; ▁sl ▁-> ▁sl ▁[ ▁3 ▁] ▁[ ▁4 ▁] ▁[ ▁i ▁] ▁= ▁sl ▁-> ▁sl ▁[ ▁2 ▁] ▁[ ▁4 ▁] ▁[ ▁i ▁] ▁; ▁sl ▁-> ▁sl ▁[ ▁3 ▁] ▁[ ▁5 ▁] ▁[ ▁i ▁] ▁= ▁sl ▁-> ▁sl ▁[ ▁2 ▁] ▁[ ▁5 ▁] ▁[ ▁i ▁] ▁; ▁} ▁sl ▁-> ▁sl _ dc ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁sl ▁-> ▁sl _ dc ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁; ▁sl ▁-> ▁sl _ dc ▁[ ▁1 ▁] ▁[ ▁2 ▁] ▁= ▁sl ▁-> ▁sl _ dc ▁[ ▁0 ▁] ▁[ ▁2 ▁] ▁; ▁sl ▁-> ▁sl _ dc ▁[ ▁1 ▁] ▁[ ▁4 ▁] ▁= ▁sl ▁-> ▁sl _ dc ▁[ ▁0 ▁] ▁[ ▁4 ▁] ▁; ▁sl ▁-> ▁sl _ dc ▁[ ▁1 ▁] ▁[ ▁5 ▁] ▁= ▁sl ▁-> ▁sl _ dc ▁[ ▁0 ▁] ▁[ ▁5 ▁] ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁EVP _ Decrypt Final _ ex ▁( ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁int ▁* ▁outl ▁) ▁{ ▁int ▁i ▁, ▁n ▁; ▁unsigned ▁int ▁b ▁; ▁* ▁outl ▁= ▁0 ▁; ▁b ▁= ▁ctx ▁-> ▁cipher ▁-> ▁block _ size ▁; ▁if ▁( ▁ctx ▁-> ▁flags ▁& ▁EVP _ C IPH _ NO _ PADDING ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁buf _ len ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DECRYPT FINAL _ EX ▁, ▁EVP _ R _ DATA _ NOT _ MULTIPLE _ OF _ BLOCK _ LENGTH ▁) ▁; ▁return ▁0 ▁; ▁} ▁* ▁outl ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁b ▁> ▁1 ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁buf _ len ▁|| ▁! ▁ctx ▁-> ▁final _ used ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DECRYPT FINAL _ EX ▁, ▁EVP _ R _ WRONG _ FINAL _ BLOCK _ LENGTH ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁OPENSSL _ assert ▁( ▁b ▁<= ▁sizeof ▁ctx ▁-> ▁final ▁) ▁; ▁n ▁= ▁ctx ▁-> ▁final ▁[ ▁b ▁- ▁1 ▁] ▁; ▁if ▁( ▁n ▁== ▁0 ▁|| ▁n ▁> ▁( ▁int ▁) ▁b ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DECRYPT FINAL _ EX ▁, ▁EVP _ R _ BAD _ DECRYPT ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁final ▁[ ▁-- ▁b ▁] ▁!= ▁n ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DECRYPT FINAL _ EX ▁, ▁EVP _ R _ BAD _ DECRYPT ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁n ▁= ▁ctx ▁-> ▁cipher ▁-> ▁block _ size ▁- ▁n ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁out ▁[ ▁i ▁] ▁= ▁ctx ▁-> ▁final ▁[ ▁i ▁] ▁; ▁* ▁outl ▁= ▁n ▁; ▁} ▁else ▁* ▁outl ▁= ▁0 ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	0
▁static ▁av _ unused ▁int ▁vp 8_ rac _ get _ uint ▁( ▁VP 56 Range Coder ▁* ▁c ▁, ▁int ▁bits ▁) ▁{ ▁int ▁value ▁= ▁0 ▁; ▁while ▁( ▁bits ▁-- ▁) ▁{ ▁value ▁= ▁( ▁value ▁<< ▁1 ▁) ▁| ▁vp 8_ rac _ get ▁( ▁c ▁) ▁; ▁} ▁return ▁value ▁; ▁}	1
▁struct ▁S ws Context ▁* ▁s ws _ get Context ▁( ▁int ▁src W ▁, ▁int ▁src H ▁, ▁int ▁src Format ▁, ▁int ▁dst W ▁, ▁int ▁dst H ▁, ▁int ▁dst Format ▁, ▁int ▁flags ▁, ▁S ws Filter ▁* ▁src Filter ▁, ▁S ws Filter ▁* ▁dst Filter ▁, ▁double ▁* ▁param ▁) ▁{ ▁struct ▁S ws Context ▁* ▁ctx ▁; ▁ctx ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁struct ▁S ws Context ▁) ▁) ▁; ▁if ▁( ▁! ▁ctx ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Cannot allocate are sampling context !\ n " ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ctx ▁-> ▁av _ class ▁= ▁& ▁context _ class ▁; ▁if ▁( ▁( ▁src H ▁!= ▁dst H ▁) ▁|| ▁( ▁src W ▁!= ▁dst W ▁) ▁) ▁{ ▁if ▁( ▁( ▁src Format ▁!= ▁PIX _ FMT _ YUV 420 P ▁) ▁|| ▁( ▁dst Format ▁!= ▁PIX _ FMT _ YUV 420 P ▁) ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ INFO ▁, ▁" PIX _ FMT _ YUV 420 P will be used asan int erm ediate format for re scaling \ n " ▁) ▁; ▁} ▁ctx ▁-> ▁res ampling _ ctx ▁= ▁img _ res ample _ init ▁( ▁dst W ▁, ▁dst H ▁, ▁src W ▁, ▁src H ▁) ▁; ▁} ▁else ▁{ ▁ctx ▁-> ▁res ampling _ ctx ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁Img Re Sample Context ▁) ▁) ▁; ▁ctx ▁-> ▁res ampling _ ctx ▁-> ▁i height ▁= ▁src H ▁; ▁ctx ▁-> ▁res ampling _ ctx ▁-> ▁i width ▁= ▁src W ▁; ▁ctx ▁-> ▁res ampling _ ctx ▁-> ▁o height ▁= ▁dst H ▁; ▁ctx ▁-> ▁res ampling _ ctx ▁-> ▁o width ▁= ▁dst W ▁; ▁} ▁ctx ▁-> ▁src _ pix _ fmt ▁= ▁src Format ▁; ▁ctx ▁-> ▁dst _ pix _ fmt ▁= ▁dst Format ▁; ▁return ▁ctx ▁; ▁}	0
▁BIO ▁* ▁bio _ open _ default ▁( ▁const ▁char ▁* ▁filename ▁, ▁char ▁mode ▁, ▁int ▁format ▁) ▁{ ▁return ▁bio _ open _ default _ ▁( ▁filename ▁, ▁mode ▁, ▁format ▁, ▁0 ▁) ▁; ▁}	0
▁int ▁BN _ lshift ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁int ▁n ▁) ▁{ ▁int ▁i ▁, ▁nw ▁, ▁lb ▁, ▁rb ▁; ▁BN _ ULONG ▁* ▁t ▁, ▁* ▁f ▁; ▁BN _ ULONG ▁l ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁if ▁( ▁n ▁< ▁0 ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ LSHIFT ▁, ▁BN _ R _ INVALID _ SHIFT ▁) ▁; ▁return ▁0 ▁; ▁} ▁nw ▁= ▁n ▁/ ▁BN _ BITS 2 ▁; ▁if ▁( ▁bn _ w expand ▁( ▁r ▁, ▁a ▁-> ▁top ▁+ ▁nw ▁+ ▁1 ▁) ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁r ▁-> ▁neg ▁= ▁a ▁-> ▁neg ▁; ▁lb ▁= ▁n ▁% ▁BN _ BITS 2 ▁; ▁rb ▁= ▁BN _ BITS 2 ▁- ▁lb ▁; ▁f ▁= ▁a ▁-> ▁d ▁; ▁t ▁= ▁r ▁-> ▁d ▁; ▁t ▁[ ▁a ▁-> ▁top ▁+ ▁nw ▁] ▁= ▁0 ▁; ▁if ▁( ▁lb ▁== ▁0 ▁) ▁for ▁( ▁i ▁= ▁a ▁-> ▁top ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁t ▁[ ▁nw ▁+ ▁i ▁] ▁= ▁f ▁[ ▁i ▁] ▁; ▁else ▁for ▁( ▁i ▁= ▁a ▁-> ▁top ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁l ▁= ▁f ▁[ ▁i ▁] ▁; ▁t ▁[ ▁nw ▁+ ▁i ▁+ ▁1 ▁] ▁|= ▁( ▁l ▁>> ▁rb ▁) ▁& ▁BN _ MASK 2 ▁; ▁t ▁[ ▁nw ▁+ ▁i ▁] ▁= ▁( ▁l ▁<< ▁lb ▁) ▁& ▁BN _ MASK 2 ▁; ▁} ▁memset ▁( ▁t ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁t ▁) ▁* ▁nw ▁) ▁; ▁r ▁-> ▁top ▁= ▁a ▁-> ▁top ▁+ ▁nw ▁+ ▁1 ▁; ▁bn _ correct _ top ▁( ▁r ▁) ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁int ▁tls _ construct _ client _ verify ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁; ▁unsigned ▁char ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁+ ▁SHA _ DIGEST _ LENGTH ▁] ▁; ▁EVP _ PKEY ▁* ▁pkey ▁; ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁= ▁NULL ▁; ▁EVP _ MD _ CTX ▁mctx ▁; ▁unsigned ▁u ▁= ▁0 ▁; ▁unsigned ▁long ▁n ▁; ▁int ▁j ▁; ▁EVP _ MD _ CTX _ init ▁( ▁& ▁mctx ▁) ▁; ▁p ▁= ▁ssl _ handshake _ start ▁( ▁s ▁) ▁; ▁pkey ▁= ▁s ▁-> ▁cert ▁-> ▁key ▁-> ▁private key ▁; ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new ▁( ▁pkey ▁, ▁NULL ▁) ▁; ▁EVP _ PKEY _ sign _ init ▁( ▁pctx ▁) ▁; ▁if ▁( ▁EVP _ PKEY _ CTX _ set _ signature _ md ▁( ▁pctx ▁, ▁EVP _ sha 1 ▁( ▁) ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁! ▁SSL _ USE _ SIG ALG S ▁( ▁s ▁) ▁) ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ sha 1 ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁ERR _ clear _ error ▁( ▁) ▁; ▁} ▁if ▁( ▁SSL _ USE _ SIG ALG S ▁( ▁s ▁) ▁) ▁{ ▁long ▁hd atal en ▁= ▁0 ▁; ▁void ▁* ▁h data ▁; ▁const ▁EVP _ MD ▁* ▁md ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁md ▁[ ▁s ▁-> ▁cert ▁-> ▁key ▁- ▁s ▁-> ▁cert ▁-> ▁p keys ▁] ▁; ▁hd atal en ▁= ▁BIO _ get _ mem _ data ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ buffer ▁, ▁& ▁h data ▁) ▁; ▁if ▁( ▁hd atal en ▁<= ▁0 ▁|| ▁! ▁tls 12_ get _ sig and hash ▁( ▁p ▁, ▁pkey ▁, ▁md ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁p ▁+= ▁2 ▁; ▁# ifdef ▁SSL _ DEBUG ▁fprintf ▁( ▁stderr ▁, ▁" Using TLS 1.2 with client alg % s \ n " ▁, ▁EVP _ MD _ name ▁( ▁md ▁) ▁) ▁; ▁# endif ▁if ▁( ▁! ▁EVP _ Sign Init _ ex ▁( ▁& ▁mctx ▁, ▁md ▁, ▁NULL ▁) ▁|| ▁! ▁EVP _ Sign Update ▁( ▁& ▁mctx ▁, ▁h data ▁, ▁hd atal en ▁) ▁|| ▁! ▁EVP _ Sign Final ▁( ▁& ▁mctx ▁, ▁p ▁+ ▁2 ▁, ▁& ▁u ▁, ▁pkey ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ EVP _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁u ▁, ▁p ▁) ▁; ▁n ▁= ▁u ▁+ ▁4 ▁; ▁if ▁( ▁! ▁ssl 3_ digest _ cached _ records ▁( ▁s ▁, ▁0 ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ RSA ▁) ▁{ ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ md 5 ▁, ▁& ▁( ▁data ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁RSA _ sign ▁( ▁NID _ md 5_ sha 1 ▁, ▁data ▁, ▁MD 5_ DIGEST _ LENGTH ▁+ ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁& ▁u ▁, ▁pkey ▁-> ▁pkey ▁. ▁rsa ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ RSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁u ▁, ▁p ▁) ▁; ▁n ▁= ▁u ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DSA ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ DSA ▁) ▁{ ▁if ▁( ▁! ▁DSA _ sign ▁( ▁pkey ▁-> ▁save _ type ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁, ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁( ▁unsigned ▁int ▁* ▁) ▁& ▁j ▁, ▁pkey ▁-> ▁pkey ▁. ▁dsa ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ DSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ EC ▁) ▁{ ▁if ▁( ▁! ▁ECDSA _ sign ▁( ▁pkey ▁-> ▁save _ type ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁, ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁( ▁unsigned ▁int ▁* ▁) ▁& ▁j ▁, ▁pkey ▁-> ▁pkey ▁. ▁ec ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ ECDSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁NID _ id _ G ost R 34 10 _2 001 ▁) ▁{ ▁unsigned ▁char ▁sign buf ▁[ ▁64 ▁] ▁; ▁int ▁i ▁; ▁size _ t ▁sig size ▁= ▁64 ▁; ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ id _ G ost R 34 11_ 94 ▁, ▁data ▁) ▁; ▁if ▁( ▁EVP _ PKEY _ sign ▁( ▁pctx ▁, ▁sign buf ▁, ▁& ▁sig size ▁, ▁data ▁, ▁32 ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁for ▁( ▁i ▁= ▁63 ▁, ▁j ▁= ▁0 ▁; ▁i ▁>= ▁0 ▁; ▁j ▁++ ▁, ▁i ▁-- ▁) ▁{ ▁p ▁[ ▁2 ▁+ ▁j ▁] ▁= ▁sign buf ▁[ ▁i ▁] ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁ssl _ set _ handshake _ header ▁( ▁s ▁, ▁SSL 3_ MT _ CERTIFICATE _ VERIFY ▁, ▁n ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁mctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁1 ▁; ▁err ▁: ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁mctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁vp 8_ mc _ chroma ▁( ▁VP 8 Context ▁* ▁s ▁, ▁VP 8 Thread Data ▁* ▁td ▁, ▁uint 8_ t ▁* ▁dst 1 ▁, ▁uint 8_ t ▁* ▁dst 2 ▁, ▁Thread Frame ▁* ▁ref ▁, ▁const ▁VP 56 mv ▁* ▁mv ▁, ▁int ▁x _ off ▁, ▁int ▁y _ off ▁, ▁int ▁block _ w ▁, ▁int ▁block _ h ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁linesize ▁, ▁vp 8_ mc _ func ▁mc _ func ▁[ ▁3 ▁] ▁[ ▁3 ▁] ▁) ▁{ ▁uint 8_ t ▁* ▁src 1 ▁= ▁ref ▁-> ▁f ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁* ▁src 2 ▁= ▁ref ▁-> ▁f ▁-> ▁data ▁[ ▁2 ▁] ▁; ▁if ▁( ▁AV _ RN 32 A ▁( ▁mv ▁) ▁) ▁{ ▁int ▁mx ▁= ▁mv ▁-> ▁x ▁& ▁7 ▁, ▁mx _ idx ▁= ▁sub pel _ idx ▁[ ▁0 ▁] ▁[ ▁mx ▁] ▁; ▁int ▁my ▁= ▁mv ▁-> ▁y ▁& ▁7 ▁, ▁my _ idx ▁= ▁sub pel _ idx ▁[ ▁0 ▁] ▁[ ▁my ▁] ▁; ▁x _ off ▁+= ▁mv ▁-> ▁x ▁>> ▁3 ▁; ▁y _ off ▁+= ▁mv ▁-> ▁y ▁>> ▁3 ▁; ▁src 1 ▁+= ▁y _ off ▁* ▁linesize ▁+ ▁x _ off ▁; ▁src 2 ▁+= ▁y _ off ▁* ▁linesize ▁+ ▁x _ off ▁; ▁ff _ thread _ await _ progress ▁( ▁ref ▁, ▁( ▁3 ▁+ ▁y _ off ▁+ ▁block _ h ▁+ ▁sub pel _ idx ▁[ ▁2 ▁] ▁[ ▁my ▁] ▁) ▁>> ▁3 ▁, ▁0 ▁) ▁; ▁if ▁( ▁x _ off ▁< ▁mx _ idx ▁|| ▁x _ off ▁>= ▁width ▁- ▁block _ w ▁- ▁sub pel _ idx ▁[ ▁2 ▁] ▁[ ▁mx ▁] ▁|| ▁y _ off ▁< ▁my _ idx ▁|| ▁y _ off ▁>= ▁height ▁- ▁block _ h ▁- ▁sub pel _ idx ▁[ ▁2 ▁] ▁[ ▁my ▁] ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁td ▁-> ▁edge _ emu _ buffer ▁, ▁src 1 ▁- ▁my _ idx ▁* ▁linesize ▁- ▁mx _ idx ▁, ▁linesize ▁, ▁block _ w ▁+ ▁sub pel _ idx ▁[ ▁1 ▁] ▁[ ▁mx ▁] ▁, ▁block _ h ▁+ ▁sub pel _ idx ▁[ ▁1 ▁] ▁[ ▁my ▁] ▁, ▁x _ off ▁- ▁mx _ idx ▁, ▁y _ off ▁- ▁my _ idx ▁, ▁width ▁, ▁height ▁) ▁; ▁src 1 ▁= ▁td ▁-> ▁edge _ emu _ buffer ▁+ ▁mx _ idx ▁+ ▁linesize ▁* ▁my _ idx ▁; ▁mc _ func ▁[ ▁my _ idx ▁] ▁[ ▁mx _ idx ▁] ▁( ▁dst 1 ▁, ▁linesize ▁, ▁src 1 ▁, ▁linesize ▁, ▁block _ h ▁, ▁mx ▁, ▁my ▁) ▁; ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁td ▁-> ▁edge _ emu _ buffer ▁, ▁src 2 ▁- ▁my _ idx ▁* ▁linesize ▁- ▁mx _ idx ▁, ▁linesize ▁, ▁block _ w ▁+ ▁sub pel _ idx ▁[ ▁1 ▁] ▁[ ▁mx ▁] ▁, ▁block _ h ▁+ ▁sub pel _ idx ▁[ ▁1 ▁] ▁[ ▁my ▁] ▁, ▁x _ off ▁- ▁mx _ idx ▁, ▁y _ off ▁- ▁my _ idx ▁, ▁width ▁, ▁height ▁) ▁; ▁src 2 ▁= ▁td ▁-> ▁edge _ emu _ buffer ▁+ ▁mx _ idx ▁+ ▁linesize ▁* ▁my _ idx ▁; ▁mc _ func ▁[ ▁my _ idx ▁] ▁[ ▁mx _ idx ▁] ▁( ▁dst 2 ▁, ▁linesize ▁, ▁src 2 ▁, ▁linesize ▁, ▁block _ h ▁, ▁mx ▁, ▁my ▁) ▁; ▁} ▁else ▁{ ▁mc _ func ▁[ ▁my _ idx ▁] ▁[ ▁mx _ idx ▁] ▁( ▁dst 1 ▁, ▁linesize ▁, ▁src 1 ▁, ▁linesize ▁, ▁block _ h ▁, ▁mx ▁, ▁my ▁) ▁; ▁mc _ func ▁[ ▁my _ idx ▁] ▁[ ▁mx _ idx ▁] ▁( ▁dst 2 ▁, ▁linesize ▁, ▁src 2 ▁, ▁linesize ▁, ▁block _ h ▁, ▁mx ▁, ▁my ▁) ▁; ▁} ▁} ▁else ▁{ ▁ff _ thread _ await _ progress ▁( ▁ref ▁, ▁( ▁3 ▁+ ▁y _ off ▁+ ▁block _ h ▁) ▁>> ▁3 ▁, ▁0 ▁) ▁; ▁mc _ func ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁( ▁dst 1 ▁, ▁linesize ▁, ▁src 1 ▁+ ▁y _ off ▁* ▁linesize ▁+ ▁x _ off ▁, ▁linesize ▁, ▁block _ h ▁, ▁0 ▁, ▁0 ▁) ▁; ▁mc _ func ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁( ▁dst 2 ▁, ▁linesize ▁, ▁src 2 ▁+ ▁y _ off ▁* ▁linesize ▁+ ▁x _ off ▁, ▁linesize ▁, ▁block _ h ▁, ▁0 ▁, ▁0 ▁) ▁; ▁} ▁}	1
▁static ▁av _ always _ inline ▁void ▁decode _ intra 4 x 4_ modes ▁( ▁VP 8 Context ▁* ▁s ▁, ▁VP 56 Range Coder ▁* ▁c ▁, ▁VP 8 Macro block ▁* ▁mb ▁, ▁int ▁mb _ x ▁, ▁int ▁keyframe ▁, ▁int ▁layout ▁) ▁{ ▁uint 8_ t ▁* ▁in tra 4 x 4 ▁= ▁mb ▁-> ▁in tra 4 x 4_ pred _ mode _ mb ▁; ▁if ▁( ▁layout ▁== ▁1 ▁) ▁{ ▁VP 8 Macro block ▁* ▁mb _ top ▁= ▁mb ▁- ▁s ▁-> ▁mb _ width ▁- ▁1 ▁; ▁memcpy ▁( ▁mb ▁-> ▁in tra 4 x 4_ pred _ mode _ top ▁, ▁mb _ top ▁-> ▁in tra 4 x 4_ pred _ mode _ top ▁, ▁4 ▁) ▁; ▁} ▁if ▁( ▁keyframe ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁uint 8_ t ▁* ▁top ▁; ▁uint 8_ t ▁* ▁const ▁left ▁= ▁s ▁-> ▁in tra 4 x 4_ pred _ mode _ left ▁; ▁if ▁( ▁layout ▁== ▁1 ▁) ▁top ▁= ▁mb ▁-> ▁in tra 4 x 4_ pred _ mode _ top ▁; ▁else ▁top ▁= ▁s ▁-> ▁in tra 4 x 4_ pred _ mode _ top ▁+ ▁4 ▁* ▁mb _ x ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁4 ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁4 ▁; ▁x ▁++ ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁ctx ▁; ▁ctx ▁= ▁vp 8_ pred 4 x 4_ prob _ intra ▁[ ▁top ▁[ ▁x ▁] ▁] ▁[ ▁left ▁[ ▁y ▁] ▁] ▁; ▁* ▁in tra 4 x 4 ▁= ▁vp 8_ rac _ get _ tree ▁( ▁c ▁, ▁vp 8_ pred 4 x 4_ tree ▁, ▁ctx ▁) ▁; ▁left ▁[ ▁y ▁] ▁= ▁top ▁[ ▁x ▁] ▁= ▁* ▁in tra 4 x 4 ▁; ▁in tra 4 x 4 ▁++ ▁; ▁} ▁} ▁} ▁else ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁i ▁++ ▁) ▁in tra 4 x 4 ▁[ ▁i ▁] ▁= ▁vp 8_ rac _ get _ tree ▁( ▁c ▁, ▁vp 8_ pred 4 x 4_ tree ▁, ▁vp 8_ pred 4 x 4_ prob _ inter ▁) ▁; ▁} ▁}	1
▁void ▁av _ log _ format _ line ▁( ▁void ▁* ▁ptr ▁, ▁int ▁level ▁, ▁const ▁char ▁* ▁fmt ▁, ▁va _ list ▁vl ▁, ▁char ▁* ▁line ▁, ▁int ▁line _ size ▁, ▁int ▁* ▁print _ prefix ▁) ▁{ ▁char ▁part ▁[ ▁3 ▁] ▁[ ▁LINE _ SZ ▁] ▁; ▁format _ line ▁( ▁ptr ▁, ▁level ▁, ▁fmt ▁, ▁vl ▁, ▁part ▁, ▁sizeof ▁( ▁part ▁[ ▁0 ▁] ▁) ▁, ▁print _ prefix ▁, ▁NULL ▁) ▁; ▁snprintf ▁( ▁line ▁, ▁line _ size ▁, ▁"% s % s % s " ▁, ▁part ▁[ ▁0 ▁] ▁, ▁part ▁[ ▁1 ▁] ▁, ▁part ▁[ ▁2 ▁] ▁) ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁yuv 2 mono _2_ c _ template ▁( ▁S ws Context ▁* ▁c ▁, ▁const ▁int 16_ t ▁* ▁buf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁ubuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁vbuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁a buf ▁[ ▁2 ▁] ▁, ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁dst W ▁, ▁int ▁y alpha ▁, ▁int ▁u val pha ▁, ▁int ▁y ▁, ▁enum ▁PixelFormat ▁target ▁) ▁{ ▁const ▁int 16_ t ▁* ▁buf 0 ▁= ▁buf ▁[ ▁0 ▁] ▁, ▁* ▁buf 1 ▁= ▁buf ▁[ ▁1 ▁] ▁; ▁const ▁uint 8_ t ▁* ▁const ▁d 128 ▁= ▁d ither _8 x 8_ 220 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁int ▁y alpha 1 ▁= ▁4096 ▁- ▁y alpha ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁+= ▁8 ▁) ▁{ ▁int ▁Y ▁, ▁acc ▁= ▁0 ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁0 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁0 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁0 ▁] ▁) ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁1 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁1 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁1 ▁] ▁) ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁2 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁2 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁2 ▁] ▁) ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁3 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁3 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁3 ▁] ▁) ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁4 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁4 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁4 ▁] ▁) ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁5 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁5 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁5 ▁] ▁) ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁6 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁6 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁6 ▁] ▁) ▁; ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁+ ▁7 ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁+ ▁7 ▁] ▁* ▁y alpha ▁) ▁>> ▁19 ▁; ▁accumulate _ bit ▁( ▁acc ▁, ▁Y ▁+ ▁d 128 ▁[ ▁7 ▁] ▁) ▁; ▁output _ pixel ▁( ▁* ▁dest ▁++ ▁, ▁acc ▁) ▁; ▁} ▁}	0
▁static ▁int ▁Pix ar Log Encode ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 8 ▁* ▁bp ▁, ▁tm size _ t ▁cc ▁, ▁uint 16 ▁s ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" Pix ar Log Encode " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁Pix ar Log State ▁* ▁sp ▁= ▁Encoder State ▁( ▁tif ▁) ▁; ▁tm size _ t ▁i ▁; ▁tm size _ t ▁n ▁; ▁int ▁l len ▁; ▁unsigned ▁short ▁* ▁up ▁; ▁( ▁void ▁) ▁s ▁; ▁switch ▁( ▁sp ▁-> ▁user _ data fmt ▁) ▁{ ▁case ▁PIX AR LOG DATA FMT _ FLOAT ▁: ▁n ▁= ▁cc ▁/ ▁sizeof ▁( ▁float ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _16 BIT ▁: ▁case ▁PIX AR LOG DATA FMT _12 BIT PIC IO ▁: ▁case ▁PIX AR LOG DATA FMT _11 BIT LOG ▁: ▁n ▁= ▁cc ▁/ ▁sizeof ▁( ▁uint 16 ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _8 BIT ▁: ▁case ▁PIX AR LOG DATA FMT _8 BIT AB GR ▁: ▁n ▁= ▁cc ▁; ▁break ▁; ▁default ▁: ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁"% db it input not supported in Pix ar Log " ▁, ▁td ▁-> ▁td _ bits pers ample ▁) ▁; ▁return ▁0 ▁; ▁} ▁l len ▁= ▁sp ▁-> ▁stride ▁* ▁td ▁-> ▁td _ image width ▁; ▁if ▁( ▁n ▁> ▁( ▁tm size _ t ▁) ▁( ▁td ▁-> ▁td _ rows per strip ▁* ▁l len ▁) ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" T oom any input bytes provided " ▁) ▁; ▁return ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁, ▁up ▁= ▁sp ▁-> ▁tbuf ▁; ▁i ▁< ▁n ▁; ▁i ▁+= ▁l len ▁, ▁up ▁+= ▁l len ▁) ▁{ ▁switch ▁( ▁sp ▁-> ▁user _ data fmt ▁) ▁{ ▁case ▁PIX AR LOG DATA FMT _ FLOAT ▁: ▁horizontal Difference F ▁( ▁( ▁float ▁* ▁) ▁bp ▁, ▁l len ▁, ▁sp ▁-> ▁stride ▁, ▁up ▁, ▁sp ▁-> ▁From LT 2 ▁) ▁; ▁bp ▁+= ▁l len ▁* ▁sizeof ▁( ▁float ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _16 BIT ▁: ▁horizontal Difference 16 ▁( ▁( ▁uint 16 ▁* ▁) ▁bp ▁, ▁l len ▁, ▁sp ▁-> ▁stride ▁, ▁up ▁, ▁sp ▁-> ▁From 14 ▁) ▁; ▁bp ▁+= ▁l len ▁* ▁sizeof ▁( ▁uint 16 ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _8 BIT ▁: ▁horizontal Difference 8 ▁( ▁( ▁unsigned ▁char ▁* ▁) ▁bp ▁, ▁l len ▁, ▁sp ▁-> ▁stride ▁, ▁up ▁, ▁sp ▁-> ▁From 8 ▁) ▁; ▁bp ▁+= ▁l len ▁* ▁sizeof ▁( ▁unsigned ▁char ▁) ▁; ▁break ▁; ▁default ▁: ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁"% db it input not supported in Pix ar Log " ▁, ▁td ▁-> ▁td _ bits pers ample ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁sp ▁-> ▁stream ▁. ▁next _ in ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁sp ▁-> ▁tbuf ▁; ▁assert ▁( ▁sizeof ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁) ▁== ▁4 ▁) ▁; ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁= ▁( ▁uInt ▁) ▁( ▁n ▁* ▁sizeof ▁( ▁uint 16 ▁) ▁) ▁; ▁if ▁( ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁/ ▁sizeof ▁( ▁uint 16 ▁) ▁) ▁!= ▁( ▁uInt ▁) ▁n ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Z Lib cannot de al with buffer sth iss ize " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁do ▁{ ▁if ▁( ▁deflate ▁( ▁& ▁sp ▁-> ▁stream ▁, ▁Z _ NO _ FLUSH ▁) ▁!= ▁Z _ OK ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Encoder error :% s " ▁, ▁sp ▁-> ▁stream ▁. ▁msg ▁? ▁sp ▁-> ▁stream ▁. ▁msg ▁: ▁"( null )" ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ out ▁== ▁0 ▁) ▁{ ▁tif ▁-> ▁tif _ raw cc ▁= ▁tif ▁-> ▁tif _ raw datas ize ▁; ▁TI FFF lush Data 1 ▁( ▁tif ▁) ▁; ▁sp ▁-> ▁stream ▁. ▁next _ out ▁= ▁tif ▁-> ▁tif _ raw data ▁; ▁sp ▁-> ▁stream ▁. ▁avail _ out ▁= ▁( ▁uInt ▁) ▁tif ▁-> ▁tif _ raw datas ize ▁; ▁} ▁} ▁while ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁> ▁0 ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁int ▁ff _ inter leave _ add _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁( ▁* ▁compare ▁) ▁( ▁AVFormatContext ▁* ▁, ▁AVPacket ▁* ▁, ▁AVPacket ▁* ▁) ▁) ▁{ ▁AVPacket List ▁* ▁* ▁next _ point ▁, ▁* ▁this _ pk tl ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁; ▁int ▁chunk ed ▁= ▁s ▁-> ▁max _ chunk _ size ▁|| ▁s ▁-> ▁max _ chunk _ duration ▁; ▁this _ pk tl ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVPacket List ▁) ▁) ▁; ▁if ▁( ▁! ▁this _ pk tl ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁this _ pk tl ▁-> ▁pkt ▁= ▁* ▁pkt ▁; ▁pkt ▁-> ▁destruct ▁= ▁NULL ▁; ▁av _ dup _ packet ▁( ▁& ▁this _ pk tl ▁-> ▁pkt ▁) ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁) ▁{ ▁next _ point ▁= ▁& ▁( ▁st ▁-> ▁last _ in _ packet _ buffer ▁-> ▁next ▁) ▁; ▁} ▁else ▁{ ▁next _ point ▁= ▁& ▁s ▁-> ▁packet _ buffer ▁; ▁} ▁if ▁( ▁chunk ed ▁) ▁{ ▁uint 64_ t ▁max ▁= ▁av _ re scale _ q _ rnd ▁( ▁s ▁-> ▁max _ chunk _ duration ▁, ▁AV _ TIME _ BASE _ Q ▁, ▁st ▁-> ▁time _ base ▁, ▁AV _ ROUND _ UP ▁) ▁; ▁st ▁-> ▁inter le aver _ chunk _ size ▁+= ▁pkt ▁-> ▁size ▁; ▁st ▁-> ▁inter le aver _ chunk _ duration ▁+= ▁pkt ▁-> ▁duration ▁; ▁if ▁( ▁st ▁-> ▁inter le aver _ chunk _ size ▁> ▁s ▁-> ▁max _ chunk _ size ▁- ▁1 U ▁|| ▁st ▁-> ▁inter le aver _ chunk _ duration ▁> ▁max ▁- ▁1 U ▁) ▁{ ▁st ▁-> ▁inter le aver _ chunk _ size ▁= ▁st ▁-> ▁inter le aver _ chunk _ duration ▁= ▁0 ▁; ▁this _ pk tl ▁-> ▁pkt ▁. ▁flags ▁|= ▁CHUNK _ START ▁; ▁} ▁} ▁if ▁( ▁* ▁next _ point ▁) ▁{ ▁if ▁( ▁chunk ed ▁&& ▁! ▁( ▁this _ pk tl ▁-> ▁pkt ▁. ▁flags ▁& ▁CHUNK _ START ▁) ▁) ▁goto ▁next _ non _ null ▁; ▁if ▁( ▁compare ▁( ▁s ▁, ▁& ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁{ ▁while ▁( ▁* ▁next _ point ▁&& ▁( ▁( ▁chunk ed ▁&& ▁! ▁( ▁( ▁* ▁next _ point ▁) ▁-> ▁pkt ▁. ▁flags ▁& ▁CHUNK _ START ▁) ▁) ▁|| ▁! ▁compare ▁( ▁s ▁, ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁) ▁next _ point ▁= ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁next ▁; ▁if ▁( ▁* ▁next _ point ▁) ▁goto ▁next _ non _ null ▁; ▁} ▁else ▁{ ▁next _ point ▁= ▁& ▁( ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁next ▁) ▁; ▁} ▁} ▁av _ assert 1 ▁( ▁! ▁* ▁next _ point ▁) ▁; ▁s ▁-> ▁packet _ buffer _ end ▁= ▁this _ pk tl ▁; ▁next _ non _ null ▁: ▁this _ pk tl ▁-> ▁next ▁= ▁* ▁next _ point ▁; ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁= ▁* ▁next _ point ▁= ▁this _ pk tl ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁put _ line ▁( ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁size ▁, ▁int ▁width ▁, ▁const ▁int ▁* ▁runs ▁) ▁{ ▁Put Bit Context ▁pb ▁; ▁int ▁run ▁, ▁mode ▁= ▁ ~ ▁0 ▁, ▁pix _ left ▁= ▁width ▁, ▁run _ idx ▁= ▁0 ▁; ▁init _ put _ bits ▁( ▁& ▁pb ▁, ▁dst ▁, ▁size ▁* ▁8 ▁) ▁; ▁while ▁( ▁pix _ left ▁> ▁0 ▁) ▁{ ▁run ▁= ▁runs ▁[ ▁run _ idx ▁++ ▁] ▁; ▁mode ▁= ▁ ~ ▁mode ▁; ▁pix _ left ▁-= ▁run ▁; ▁for ▁( ▁; ▁run ▁> ▁16 ▁; ▁run ▁-= ▁16 ▁) ▁put _ s bits ▁( ▁& ▁pb ▁, ▁16 ▁, ▁mode ▁) ▁; ▁if ▁( ▁run ▁) ▁put _ s bits ▁( ▁& ▁pb ▁, ▁run ▁, ▁mode ▁) ▁; ▁} ▁flush _ put _ bits ▁( ▁& ▁pb ▁) ▁; ▁}	1
▁static ▁int ▁a 64 multi _ encode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁pkt ▁, ▁const ▁AVFrame ▁* ▁pict ▁, ▁int ▁* ▁got _ packet ▁) ▁{ ▁A 64 Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁const ▁p ▁= ▁( ▁AVFrame ▁* ▁) ▁& ▁c ▁-> ▁picture ▁; ▁int ▁frame ▁; ▁int ▁x ▁, ▁y ▁; ▁int ▁b _ height ▁; ▁int ▁b _ width ▁; ▁int ▁req _ size ▁, ▁ret ▁; ▁uint 8_ t ▁* ▁buf ▁= ▁NULL ▁; ▁int ▁* ▁char map ▁= ▁c ▁-> ▁mc _ char map ▁; ▁uint 8_ t ▁* ▁col ram ▁= ▁c ▁-> ▁mc _ col ram ▁; ▁uint 8_ t ▁* ▁charset ▁= ▁c ▁-> ▁mc _ charset ▁; ▁int ▁* ▁meta ▁= ▁c ▁-> ▁mc _ meta _ charset ▁; ▁int ▁* ▁best _ cb ▁= ▁c ▁-> ▁mc _ best _ cb ▁; ▁int ▁charset _ size ▁= ▁0 x 800 ▁* ▁( ▁INTER L ACED ▁+ ▁1 ▁) ▁; ▁int ▁col ram _ size ▁= ▁0 x 100 ▁* ▁c ▁-> ▁mc _ use _5 col ▁; ▁int ▁screen _ size ▁; ▁if ▁( ▁CR OP _ SCREEN S ▁) ▁{ ▁b _ height ▁= ▁FF MIN ▁( ▁avctx ▁-> ▁height ▁, ▁C 64 Y RES ▁) ▁>> ▁3 ▁; ▁b _ width ▁= ▁FF MIN ▁( ▁avctx ▁-> ▁width ▁, ▁C 64 X RES ▁) ▁>> ▁3 ▁; ▁screen _ size ▁= ▁b _ width ▁* ▁b _ height ▁; ▁} ▁else ▁{ ▁b _ height ▁= ▁C 64 Y RES ▁>> ▁3 ▁; ▁b _ width ▁= ▁C 64 X RES ▁>> ▁3 ▁; ▁screen _ size ▁= ▁0 x 400 ▁; ▁} ▁if ▁( ▁! ▁pict ▁) ▁{ ▁if ▁( ▁! ▁c ▁-> ▁mc _ l ifetime ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁c ▁-> ▁mc _ frame _ counter ▁) ▁{ ▁c ▁-> ▁mc _ l ifetime ▁= ▁0 ▁; ▁} ▁else ▁c ▁-> ▁mc _ l ifetime ▁= ▁c ▁-> ▁mc _ frame _ counter ▁; ▁} ▁else ▁{ ▁if ▁( ▁c ▁-> ▁mc _ frame _ counter ▁< ▁c ▁-> ▁mc _ l ifetime ▁) ▁{ ▁* ▁p ▁= ▁* ▁pict ▁; ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁p ▁-> ▁key _ frame ▁= ▁1 ▁; ▁to _ meta _ with _ crop ▁( ▁avctx ▁, ▁p ▁, ▁meta ▁+ ▁32000 ▁* ▁c ▁-> ▁mc _ frame _ counter ▁) ▁; ▁c ▁-> ▁mc _ frame _ counter ▁++ ▁; ▁if ▁( ▁c ▁-> ▁next _ pts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁c ▁-> ▁next _ pts ▁= ▁pict ▁-> ▁pts ▁; ▁return ▁0 ▁; ▁} ▁} ▁if ▁( ▁c ▁-> ▁mc _ frame _ counter ▁== ▁c ▁-> ▁mc _ l ifetime ▁) ▁{ ▁req _ size ▁= ▁0 ▁; ▁if ▁( ▁c ▁-> ▁mc _ l ifetime ▁) ▁{ ▁req _ size ▁= ▁charset _ size ▁+ ▁c ▁-> ▁mc _ l ifetime ▁* ▁( ▁screen _ size ▁+ ▁col ram _ size ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ alloc _ packet ▁( ▁pkt ▁, ▁req _ size ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error get ting output packet of size % d .\ n " ▁, ▁req _ size ▁) ▁; ▁return ▁ret ▁; ▁} ▁buf ▁= ▁pkt ▁-> ▁data ▁; ▁ff _ init _ el bg ▁( ▁meta ▁, ▁32 ▁, ▁1000 ▁* ▁c ▁-> ▁mc _ l ifetime ▁, ▁best _ cb ▁, ▁CHARSET _ CHARS ▁, ▁50 ▁, ▁char map ▁, ▁& ▁c ▁-> ▁rand ctx ▁) ▁; ▁ff _ do _ el bg ▁( ▁meta ▁, ▁32 ▁, ▁1000 ▁* ▁c ▁-> ▁mc _ l ifetime ▁, ▁best _ cb ▁, ▁CHARSET _ CHARS ▁, ▁50 ▁, ▁char map ▁, ▁& ▁c ▁-> ▁rand ctx ▁) ▁; ▁render _ charset ▁( ▁avctx ▁, ▁charset ▁, ▁col ram ▁) ▁; ▁memcpy ▁( ▁buf ▁, ▁charset ▁, ▁charset _ size ▁) ▁; ▁buf ▁+= ▁charset _ size ▁; ▁charset ▁+= ▁charset _ size ▁; ▁} ▁for ▁( ▁frame ▁= ▁0 ▁; ▁frame ▁< ▁c ▁-> ▁mc _ l ifetime ▁; ▁frame ▁++ ▁) ▁{ ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁b _ height ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁b _ width ▁; ▁x ▁++ ▁) ▁{ ▁buf ▁[ ▁y ▁* ▁b _ width ▁+ ▁x ▁] ▁= ▁char map ▁[ ▁y ▁* ▁b _ width ▁+ ▁x ▁] ▁; ▁} ▁} ▁buf ▁+= ▁screen _ size ▁; ▁req _ size ▁+= ▁screen _ size ▁; ▁if ▁( ▁c ▁-> ▁mc _ use _5 col ▁) ▁{ ▁a 64_ compress _ col ram ▁( ▁buf ▁, ▁char map ▁, ▁col ram ▁) ▁; ▁buf ▁+= ▁col ram _ size ▁; ▁req _ size ▁+= ▁col ram _ size ▁; ▁} ▁char map ▁+= ▁1000 ▁; ▁} ▁AV _ WB 32 ▁( ▁avctx ▁-> ▁extradata ▁+ ▁4 ▁, ▁c ▁-> ▁mc _ frame _ counter ▁) ▁; ▁AV _ WB 32 ▁( ▁avctx ▁-> ▁extradata ▁+ ▁8 ▁, ▁charset _ size ▁) ▁; ▁AV _ WB 32 ▁( ▁avctx ▁-> ▁extradata ▁+ ▁12 ▁, ▁screen _ size ▁+ ▁col ram _ size ▁) ▁; ▁c ▁-> ▁mc _ frame _ counter ▁= ▁0 ▁; ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁dts ▁= ▁c ▁-> ▁next _ pts ▁; ▁c ▁-> ▁next _ pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁pkt ▁-> ▁size ▁= ▁req _ size ▁; ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ KEY ▁; ▁* ▁got _ packet ▁= ▁! ▁! ▁req _ size ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁check _ output _ constraints ▁( ▁InputStream ▁* ▁ist ▁, ▁OutputStream ▁* ▁o st ▁) ▁{ ▁OutputFile ▁* ▁of ▁= ▁output _ files ▁[ ▁o st ▁-> ▁file _ index ▁] ▁; ▁int ▁ist _ index ▁= ▁input _ files ▁[ ▁ist ▁-> ▁file _ index ▁] ▁-> ▁ist _ index ▁+ ▁ist ▁-> ▁st ▁-> ▁index ▁; ▁if ▁( ▁o st ▁-> ▁source _ index ▁!= ▁ist _ index ▁) ▁return ▁0 ▁; ▁if ▁( ▁of ▁-> ▁start _ time ▁&& ▁ist ▁-> ▁pts ▁< ▁of ▁-> ▁start _ time ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁s iff _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁SI FF Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁if ▁( ▁c ▁-> ▁has _ video ▁) ▁{ ▁unsigned ▁int ▁size ▁; ▁if ▁( ▁c ▁-> ▁cur _ frame ▁>= ▁c ▁-> ▁frames ▁) ▁return ▁AVERROR _ EOF ▁; ▁if ▁( ▁c ▁-> ▁cur strm ▁== ▁-1 ▁) ▁{ ▁c ▁-> ▁pkt size ▁= ▁avio _ rl 32 ▁( ▁s ▁-> ▁pb ▁) ▁- ▁4 ▁; ▁c ▁-> ▁flags ▁= ▁avio _ rl 16 ▁( ▁s ▁-> ▁pb ▁) ▁; ▁c ▁-> ▁g mc size ▁= ▁( ▁c ▁-> ▁flags ▁& ▁VB _ HAS _ G MC ▁) ▁? ▁4 ▁: ▁0 ▁; ▁if ▁( ▁c ▁-> ▁g mc size ▁) ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁c ▁-> ▁g mc ▁, ▁c ▁-> ▁g mc size ▁) ▁; ▁c ▁-> ▁snd size ▁= ▁( ▁c ▁-> ▁flags ▁& ▁VB _ HAS _ AUDIO ▁) ▁? ▁avio _ rl 32 ▁( ▁s ▁-> ▁pb ▁) ▁: ▁0 ▁; ▁c ▁-> ▁cur strm ▁= ▁! ▁! ▁( ▁c ▁-> ▁flags ▁& ▁VB _ HAS _ AUDIO ▁) ▁; ▁} ▁if ▁( ▁! ▁c ▁-> ▁cur strm ▁) ▁{ ▁size ▁= ▁c ▁-> ▁pkt size ▁- ▁c ▁-> ▁snd size ▁- ▁c ▁-> ▁g mc size ▁- ▁2 ▁; ▁size ▁= ▁ff io _ limit ▁( ▁s ▁-> ▁pb ▁, ▁size ▁) ▁; ▁if ▁( ▁size ▁< ▁0 ▁|| ▁c ▁-> ▁pkt size ▁< ▁c ▁-> ▁snd size ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁size ▁+ ▁c ▁-> ▁g mc size ▁+ ▁2 ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁AV _ WL 16 ▁( ▁pkt ▁-> ▁data ▁, ▁c ▁-> ▁flags ▁) ▁; ▁if ▁( ▁c ▁-> ▁g mc size ▁) ▁memcpy ▁( ▁pkt ▁-> ▁data ▁+ ▁2 ▁, ▁c ▁-> ▁g mc ▁, ▁c ▁-> ▁g mc size ▁) ▁; ▁if ▁( ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁-> ▁data ▁+ ▁2 ▁+ ▁c ▁-> ▁g mc size ▁, ▁size ▁) ▁!= ▁size ▁) ▁{ ▁av _ free _ packet ▁( ▁pkt ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁c ▁-> ▁cur strm ▁= ▁-1 ▁; ▁} ▁else ▁{ ▁int ▁pkt size ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁c ▁-> ▁snd size ▁- ▁4 ▁) ▁; ▁if ▁( ▁pkt size ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁1 ▁; ▁pkt ▁-> ▁duration ▁= ▁pkt size ▁; ▁c ▁-> ▁cur strm ▁= ▁0 ▁; ▁} ▁if ▁( ▁! ▁c ▁-> ▁cur _ frame ▁|| ▁c ▁-> ▁cur strm ▁) ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ KEY ▁; ▁if ▁( ▁c ▁-> ▁cur strm ▁== ▁-1 ▁) ▁c ▁-> ▁cur _ frame ▁++ ▁; ▁} ▁else ▁{ ▁int ▁pkt size ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁c ▁-> ▁block _ align ▁) ▁; ▁if ▁( ▁! ▁pkt size ▁) ▁return ▁AVERROR _ EOF ▁; ▁if ▁( ▁pkt size ▁<= ▁0 ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁pkt ▁-> ▁duration ▁= ▁pkt size ▁; ▁} ▁return ▁pkt ▁-> ▁size ▁; ▁}	1
▁int ▁avio _ r 8 ▁( ▁AVIO Context ▁* ▁s ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ ptr ▁>= ▁s ▁-> ▁buf _ end ▁) ▁fill _ buffer ▁( ▁s ▁) ▁; ▁if ▁( ▁s ▁-> ▁buf _ ptr ▁< ▁s ▁-> ▁buf _ end ▁) ▁return ▁* ▁s ▁-> ▁buf _ ptr ▁++ ▁; ▁return ▁0 ▁; ▁}	1
▁int 64_ t ▁av _ get _ int ▁( ▁void ▁* ▁obj ▁, ▁const ▁char ▁* ▁name ▁, ▁const ▁AV Option ▁* ▁* ▁o _ out ▁) ▁{ ▁int 64_ t ▁int num ▁= ▁1 ▁; ▁double ▁num ▁= ▁1 ▁; ▁int ▁den ▁= ▁1 ▁; ▁if ▁( ▁av _ get _ number ▁( ▁obj ▁, ▁name ▁, ▁o _ out ▁, ▁& ▁num ▁, ▁& ▁den ▁, ▁& ▁int num ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁return ▁num ▁* ▁int num ▁/ ▁den ▁; ▁}	0
▁static ▁inline ▁int ▁get _ len ▁( ▁LZO Context ▁* ▁c ▁, ▁int ▁x ▁, ▁int ▁mask ▁) ▁{ ▁int ▁cnt ▁= ▁x ▁& ▁mask ▁; ▁if ▁( ▁! ▁cnt ▁) ▁{ ▁while ▁( ▁! ▁( ▁x ▁= ▁get _ byte ▁( ▁c ▁) ▁) ▁) ▁{ ▁if ▁( ▁cnt ▁>= ▁INT _ MAX ▁- ▁1000 ▁) ▁{ ▁c ▁-> ▁error ▁|= ▁AV _ LZ O _ ERROR ▁; ▁break ▁; ▁} ▁cnt ▁+= ▁255 ▁; ▁} ▁cnt ▁+= ▁mask ▁+ ▁x ▁; ▁} ▁return ▁cnt ▁; ▁}	0
▁static ▁int ▁parse _ key frames _ index ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁ioc ▁, ▁AVStream ▁* ▁v stream ▁, ▁int 64_ t ▁max _ pos ▁) ▁{ ▁unsigned ▁int ▁array len ▁= ▁0 ▁, ▁times len ▁= ▁0 ▁, ▁file pos len ▁= ▁0 ▁, ▁i ▁; ▁double ▁num _ val ▁; ▁char ▁str _ val ▁[ ▁256 ▁] ▁; ▁int 64_ t ▁* ▁times ▁= ▁NULL ▁; ▁int 64_ t ▁* ▁file positions ▁= ▁NULL ▁; ▁int ▁ret ▁= ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁int 64_ t ▁initial _ pos ▁= ▁avio _ tell ▁( ▁ioc ▁) ▁; ▁AV Dictionary Entry ▁* ▁creator ▁= ▁av _ dict _ get ▁( ▁s ▁-> ▁metadata ▁, ▁" met ad at ac re ator " ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁if ▁( ▁creator ▁&& ▁! ▁strcmp ▁( ▁creator ▁-> ▁value ▁, ▁" ME GA " ▁) ▁) ▁{ ▁return ▁0 ▁; ▁} ▁while ▁( ▁avio _ tell ▁( ▁ioc ▁) ▁< ▁max _ pos ▁- ▁2 ▁&& ▁am f _ get _ string ▁( ▁ioc ▁, ▁str _ val ▁, ▁sizeof ▁( ▁str _ val ▁) ▁) ▁> ▁0 ▁) ▁{ ▁int 64_ t ▁* ▁current _ array ▁; ▁if ▁( ▁avio _ r 8 ▁( ▁ioc ▁) ▁!= ▁AM F _ DATA _ TYPE _ ARRAY ▁) ▁break ▁; ▁array len ▁= ▁avio _ rb 32 ▁( ▁ioc ▁) ▁; ▁if ▁( ▁! ▁strcmp ▁( ▁KEY FRAMES _ TIMESTAMP _ TAG ▁, ▁str _ val ▁) ▁&& ▁! ▁times ▁) ▁{ ▁if ▁( ▁! ▁( ▁times ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁times ▁) ▁* ▁array len ▁) ▁) ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁finish ▁; ▁} ▁times len ▁= ▁array len ▁; ▁current _ array ▁= ▁times ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁KEY FRAMES _ BYTE OFFSET _ TAG ▁, ▁str _ val ▁) ▁&& ▁! ▁file positions ▁) ▁{ ▁if ▁( ▁! ▁( ▁file positions ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁file positions ▁) ▁* ▁array len ▁) ▁) ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁finish ▁; ▁} ▁file pos len ▁= ▁array len ▁; ▁current _ array ▁= ▁file positions ▁; ▁} ▁else ▁break ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁array len ▁&& ▁avio _ tell ▁( ▁ioc ▁) ▁< ▁max _ pos ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁avio _ r 8 ▁( ▁ioc ▁) ▁!= ▁AM F _ DATA _ TYPE _ NUMBER ▁) ▁goto ▁finish ▁; ▁num _ val ▁= ▁av _ int 2 dbl ▁( ▁avio _ rb 64 ▁( ▁ioc ▁) ▁) ▁; ▁current _ array ▁[ ▁i ▁] ▁= ▁num _ val ▁; ▁} ▁if ▁( ▁times ▁&& ▁file positions ▁) ▁{ ▁ret ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁ret ▁&& ▁times len ▁== ▁file pos len ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁file pos len ▁; ▁i ▁++ ▁) ▁av _ add _ index _ entry ▁( ▁v stream ▁, ▁file positions ▁[ ▁i ▁] ▁, ▁times ▁[ ▁i ▁] ▁* ▁1000 ▁, ▁0 ▁, ▁0 ▁, ▁AV INDEX _ KEY FRAME ▁) ▁; ▁else ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Invalid key frames object , sk ipping .\ n " ▁) ▁; ▁finish ▁: ▁av _ freep ▁( ▁& ▁times ▁) ▁; ▁av _ freep ▁( ▁& ▁file positions ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁&& ▁avio _ seek ▁( ▁ioc ▁, ▁initial _ pos ▁, ▁SEEK _ SET ▁) ▁> ▁0 ▁) ▁return ▁0 ▁; ▁return ▁ret ▁; ▁}	0
▁void ▁BN _ CTX _ start ▁( ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁depth ▁< ▁BN _ CTX _ NUM _ POS ▁) ▁ctx ▁-> ▁pos ▁[ ▁ctx ▁-> ▁depth ▁] ▁= ▁ctx ▁-> ▁tos ▁; ▁ctx ▁-> ▁depth ▁++ ▁; ▁}	1
▁static ▁int ▁allocate _ buffers ▁( ▁AL AC Context ▁* ▁al ac ▁) ▁{ ▁int ▁ch ▁; ▁int ▁buf _ size ▁; ▁if ▁( ▁al ac ▁-> ▁max _ samples _ per _ frame ▁> ▁INT _ MAX ▁/ ▁sizeof ▁( ▁int 32_ t ▁) ▁) ▁goto ▁buf _ alloc _ fail ▁; ▁buf _ size ▁= ▁al ac ▁-> ▁max _ samples _ per _ frame ▁* ▁sizeof ▁( ▁int 32_ t ▁) ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁FF MIN ▁( ▁al ac ▁-> ▁channels ▁, ▁2 ▁) ▁; ▁ch ▁++ ▁) ▁{ ▁FF _ ALLOC _ OR _ GOTO ▁( ▁al ac ▁-> ▁avctx ▁, ▁al ac ▁-> ▁predict _ error _ buffer ▁[ ▁ch ▁] ▁, ▁buf _ size ▁, ▁buf _ alloc _ fail ▁) ▁; ▁al ac ▁-> ▁direct _ output ▁= ▁al ac ▁-> ▁sample _ size ▁> ▁16 ▁&& ▁av _ sample _ fmt _ is _ planar ▁( ▁al ac ▁-> ▁avctx ▁-> ▁sample _ fmt ▁) ▁; ▁if ▁( ▁! ▁al ac ▁-> ▁direct _ output ▁) ▁{ ▁FF _ ALLOC _ OR _ GOTO ▁( ▁al ac ▁-> ▁avctx ▁, ▁al ac ▁-> ▁output _ samples _ buffer ▁[ ▁ch ▁] ▁, ▁buf _ size ▁, ▁buf _ alloc _ fail ▁) ▁; ▁} ▁FF _ ALLOC _ OR _ GOTO ▁( ▁al ac ▁-> ▁avctx ▁, ▁al ac ▁-> ▁extra _ bits _ buffer ▁[ ▁ch ▁] ▁, ▁buf _ size ▁, ▁buf _ alloc _ fail ▁) ▁; ▁} ▁return ▁0 ▁; ▁buf _ alloc _ fail ▁: ▁al ac _ decode _ close ▁( ▁al ac ▁-> ▁avctx ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁}	0
▁static ▁int ▁read _ sl _ header ▁( ▁P ES Context ▁* ▁p es ▁, ▁SL Config Descr ▁* ▁sl ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁Get Bit Context ▁gb ▁; ▁int ▁au _ start _ flag ▁= ▁0 ▁, ▁au _ end _ flag ▁= ▁0 ▁, ▁ocr _ flag ▁= ▁0 ▁, ▁idle _ flag ▁= ▁0 ▁; ▁int ▁padding _ flag ▁= ▁0 ▁, ▁padding _ bits ▁= ▁0 ▁, ▁inst _ bitrate _ flag ▁= ▁0 ▁; ▁int ▁dts _ flag ▁= ▁-1 ▁, ▁cts _ flag ▁= ▁-1 ▁; ▁int 64_ t ▁dts ▁= ▁AV _ NOP TS _ VALUE ▁, ▁cts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁if ▁( ▁sl ▁-> ▁use _ au _ start ▁) ▁au _ start _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁sl ▁-> ▁use _ au _ end ▁) ▁au _ end _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁! ▁sl ▁-> ▁use _ au _ start ▁&& ▁! ▁sl ▁-> ▁use _ au _ end ▁) ▁au _ start _ flag ▁= ▁au _ end _ flag ▁= ▁1 ▁; ▁if ▁( ▁sl ▁-> ▁ocr _ len ▁> ▁0 ▁) ▁ocr _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁sl ▁-> ▁use _ idle ▁) ▁idle _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁sl ▁-> ▁use _ padding ▁) ▁padding _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁padding _ flag ▁) ▁padding _ bits ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁3 ▁) ▁; ▁if ▁( ▁! ▁idle _ flag ▁&& ▁( ▁! ▁padding _ flag ▁|| ▁padding _ bits ▁!= ▁0 ▁) ▁) ▁{ ▁if ▁( ▁sl ▁-> ▁packet _ seq _ num _ len ▁) ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁packet _ seq _ num _ len ▁) ▁; ▁if ▁( ▁sl ▁-> ▁de gr _ pri or _ len ▁) ▁if ▁( ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁) ▁skip _ bits ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁de gr _ pri or _ len ▁) ▁; ▁if ▁( ▁ocr _ flag ▁) ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁ocr _ len ▁) ▁; ▁if ▁( ▁au _ start _ flag ▁) ▁{ ▁if ▁( ▁sl ▁-> ▁use _ rand _ acc _ pt ▁) ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁sl ▁-> ▁au _ seq _ num _ len ▁> ▁0 ▁) ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁au _ seq _ num _ len ▁) ▁; ▁if ▁( ▁sl ▁-> ▁use _ timestamp s ▁) ▁{ ▁dts _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁cts _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁} ▁} ▁if ▁( ▁sl ▁-> ▁inst _ bitrate _ len ▁) ▁inst _ bitrate _ flag ▁= ▁get _ bits 1 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁dts _ flag ▁== ▁1 ▁) ▁dts ▁= ▁get _ ts 64 ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁timestamp _ len ▁) ▁; ▁if ▁( ▁cts _ flag ▁== ▁1 ▁) ▁cts ▁= ▁get _ ts 64 ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁timestamp _ len ▁) ▁; ▁if ▁( ▁sl ▁-> ▁au _ len ▁> ▁0 ▁) ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁au _ len ▁) ▁; ▁if ▁( ▁inst _ bitrate _ flag ▁) ▁skip _ bits _ long ▁( ▁& ▁gb ▁, ▁sl ▁-> ▁inst _ bitrate _ len ▁) ▁; ▁} ▁if ▁( ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁p es ▁-> ▁dts ▁= ▁dts ▁; ▁if ▁( ▁cts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁p es ▁-> ▁pts ▁= ▁cts ▁; ▁if ▁( ▁sl ▁-> ▁timestamp _ len ▁&& ▁sl ▁-> ▁timestamp _ res ▁) ▁avpriv _ set _ pts _ info ▁( ▁p es ▁-> ▁st ▁, ▁sl ▁-> ▁timestamp _ len ▁, ▁1 ▁, ▁sl ▁-> ▁timestamp _ res ▁) ▁; ▁return ▁( ▁get _ bits _ count ▁( ▁& ▁gb ▁) ▁+ ▁7 ▁) ▁>> ▁3 ▁; ▁}	1
▁static ▁void ▁wm v 2_ add _ block ▁( ▁W mv 2 Context ▁* ▁w ▁, ▁DCT ELEM ▁* ▁block 1 ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁stride ▁, ▁int ▁n ▁) ▁{ ▁Mpeg Enc Context ▁* ▁const ▁s ▁= ▁& ▁w ▁-> ▁s ▁; ▁if ▁( ▁s ▁-> ▁block _ last _ index ▁[ ▁n ▁] ▁>= ▁0 ▁) ▁{ ▁switch ▁( ▁w ▁-> ▁ab t _ type _ table ▁[ ▁n ▁] ▁) ▁{ ▁case ▁0 ▁: ▁s ▁-> ▁dsp ▁. ▁idct _ add ▁( ▁dst ▁, ▁stride ▁, ▁block 1 ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁ff _ simple _ idct 84_ add ▁( ▁dst ▁, ▁stride ▁, ▁block 1 ▁) ▁; ▁ff _ simple _ idct 84_ add ▁( ▁dst ▁+ ▁4 ▁* ▁stride ▁, ▁stride ▁, ▁w ▁-> ▁ab t _ block 2 ▁[ ▁n ▁] ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁clear _ block ▁( ▁w ▁-> ▁ab t _ block 2 ▁[ ▁n ▁] ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁ff _ simple _ idct 48_ add ▁( ▁dst ▁, ▁stride ▁, ▁block 1 ▁) ▁; ▁ff _ simple _ idct 48_ add ▁( ▁dst ▁+ ▁4 ▁, ▁stride ▁, ▁w ▁-> ▁ab t _ block 2 ▁[ ▁n ▁] ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁clear _ block ▁( ▁w ▁-> ▁ab t _ block 2 ▁[ ▁n ▁] ▁) ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" internal error in WM V 2 ab t \ n " ▁) ▁; ▁} ▁} ▁}	1
▁int ▁i 2 d _ PrivateKey ▁( ▁EVP _ PKEY ▁* ▁a ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁) ▁{ ▁if ▁( ▁a ▁-> ▁am eth ▁&& ▁a ▁-> ▁am eth ▁-> ▁old _ priv _ encode ▁) ▁{ ▁return ▁a ▁-> ▁am eth ▁-> ▁old _ priv _ encode ▁( ▁a ▁, ▁pp ▁) ▁; ▁} ▁if ▁( ▁a ▁-> ▁am eth ▁&& ▁a ▁-> ▁am eth ▁-> ▁priv _ encode ▁) ▁{ ▁PKCS 8_ PRIV _ KEY _ INFO ▁* ▁p 8 ▁= ▁EVP _ PKEY 2 PKCS 8 ▁( ▁a ▁) ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁p 8 ▁!= ▁NULL ▁) ▁{ ▁ret ▁= ▁i 2 d _ PKCS 8_ PRIV _ KEY _ INFO ▁( ▁p 8 ▁, ▁pp ▁) ▁; ▁PKCS 8_ PRIV _ KEY _ INFO _ free ▁( ▁p 8 ▁) ▁; ▁} ▁return ▁ret ▁; ▁} ▁ASN 1 err ▁( ▁ASN 1_ F _ I 2 D _ PRIVATE KEY ▁, ▁ASN 1_ R _ UNSUPPORTED _ PUBLIC _ KEY _ TYPE ▁) ▁; ▁return ▁-1 ▁; ▁}	0
▁void ▁EVP _ PKEY _ CTX _ free ▁( ▁EVP _ PKEY _ CTX ▁* ▁ctx ▁) ▁{ ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁return ▁; ▁if ▁( ▁ctx ▁-> ▁pm eth ▁&& ▁ctx ▁-> ▁pm eth ▁-> ▁cleanup ▁) ▁ctx ▁-> ▁pm eth ▁-> ▁cleanup ▁( ▁ctx ▁) ▁; ▁EVP _ PKEY _ free ▁( ▁ctx ▁-> ▁pkey ▁) ▁; ▁EVP _ PKEY _ free ▁( ▁ctx ▁-> ▁peer key ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁ENGINE _ finish ▁( ▁ctx ▁-> ▁engine ▁) ▁; ▁# endif ▁OPENSSL _ free ▁( ▁ctx ▁) ▁; ▁}	0
▁static ▁inline ▁void ▁apply _8 x 8 ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁dir ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁q pel _ mc _ func ▁( ▁* ▁q pix _ op ▁) ▁[ ▁16 ▁] ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁) ▁{ ▁int ▁d xy ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁; ▁int ▁i ▁; ▁int ▁mb _ x ▁= ▁s ▁-> ▁mb _ x ▁; ▁int ▁mb _ y ▁= ▁s ▁-> ▁mb _ y ▁; ▁uint 8_ t ▁* ▁ptr ▁, ▁* ▁dest ▁; ▁mx ▁= ▁0 ▁; ▁my ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁qu arter _ sample ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁motion _ x ▁= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁int ▁motion _ y ▁= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁3 ▁) ▁<< ▁2 ▁) ▁| ▁( ▁motion _ x ▁& ▁3 ▁) ▁; ▁src _ x ▁= ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁2 ▁) ▁+ ▁( ▁i ▁& ▁1 ▁) ▁* ▁8 ▁; ▁src _ y ▁= ▁mb _ y ▁* ▁16 ▁+ ▁( ▁motion _ y ▁>> ▁2 ▁) ▁+ ▁( ▁i ▁>> ▁1 ▁) ▁* ▁8 ▁; ▁src _ x ▁= ▁av _ clip ▁( ▁src _ x ▁, ▁-16 ▁, ▁s ▁-> ▁width ▁) ▁; ▁if ▁( ▁src _ x ▁== ▁s ▁-> ▁width ▁) ▁d xy ▁&= ▁ ~ ▁3 ▁; ▁src _ y ▁= ▁av _ clip ▁( ▁src _ y ▁, ▁-16 ▁, ▁s ▁-> ▁height ▁) ▁; ▁if ▁( ▁src _ y ▁== ▁s ▁-> ▁height ▁) ▁d xy ▁&= ▁ ~ ▁12 ▁; ▁ptr ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁( ▁src _ y ▁* ▁s ▁-> ▁linesize ▁) ▁+ ▁( ▁src _ x ▁) ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁src _ x ▁>= ▁FF MAX ▁( ▁s ▁-> ▁h _ edge _ pos ▁- ▁( ▁motion _ x ▁& ▁3 ▁) ▁- ▁7 ▁, ▁0 ▁) ▁|| ▁( ▁unsigned ▁) ▁src _ y ▁>= ▁FF MAX ▁( ▁s ▁-> ▁v _ edge _ pos ▁- ▁( ▁motion _ y ▁& ▁3 ▁) ▁- ▁7 ▁, ▁0 ▁) ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁linesize ▁, ▁9 ▁, ▁9 ▁, ▁src _ x ▁, ▁src _ y ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁} ▁dest ▁= ▁dest _ y ▁+ ▁( ▁( ▁i ▁& ▁1 ▁) ▁* ▁8 ▁) ▁+ ▁( ▁i ▁>> ▁1 ▁) ▁* ▁8 ▁* ▁s ▁-> ▁linesize ▁; ▁q pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest ▁, ▁ptr ▁, ▁s ▁-> ▁linesize ▁) ▁; ▁mx ▁+= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁/ ▁2 ▁; ▁my ▁+= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁/ ▁2 ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁h pel _ motion ▁( ▁s ▁, ▁dest _ y ▁+ ▁( ▁( ▁i ▁& ▁1 ▁) ▁* ▁8 ▁) ▁+ ▁( ▁i ▁>> ▁1 ▁) ▁* ▁8 ▁* ▁s ▁-> ▁linesize ▁, ▁ref _ picture ▁[ ▁0 ▁] ▁, ▁mb _ x ▁* ▁16 ▁+ ▁( ▁i ▁& ▁1 ▁) ▁* ▁8 ▁, ▁mb _ y ▁* ▁16 ▁+ ▁( ▁i ▁>> ▁1 ▁) ▁* ▁8 ▁, ▁pix _ op ▁[ ▁1 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁) ▁; ▁mx ▁+= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁; ▁my ▁+= ▁s ▁-> ▁mv ▁[ ▁dir ▁] ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁; ▁} ▁} ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁chroma _4 mv _ motion ▁( ▁s ▁, ▁dest _ cb ▁, ▁dest _ cr ▁, ▁ref _ picture ▁, ▁pix _ op ▁[ ▁1 ▁] ▁, ▁mx ▁, ▁my ▁) ▁; ▁}	0
▁static ▁int ▁get _ q cx ▁( ▁J 2 k Decoder Context ▁* ▁s ▁, ▁int ▁n ▁, ▁J 2 k Quant Style ▁* ▁q ▁) ▁{ ▁int ▁i ▁, ▁x ▁; ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁1 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁x ▁= ▁bytestream _ get _ byte ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁q ▁-> ▁n guard bits ▁= ▁x ▁>> ▁5 ▁; ▁q ▁-> ▁quant st y ▁= ▁x ▁& ▁0 x 1 f ▁; ▁if ▁( ▁q ▁-> ▁quant st y ▁== ▁J 2 K _ Q STY _ NONE ▁) ▁{ ▁n ▁-= ▁3 ▁; ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁n ▁|| ▁32 ▁* ▁3 ▁< ▁n ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁q ▁-> ▁exp n ▁[ ▁i ▁] ▁= ▁bytestream _ get _ byte ▁( ▁& ▁s ▁-> ▁buf ▁) ▁>> ▁3 ▁; ▁} ▁else ▁if ▁( ▁q ▁-> ▁quant st y ▁== ▁J 2 K _ Q STY _ SI ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁2 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁x ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁q ▁-> ▁exp n ▁[ ▁0 ▁] ▁= ▁x ▁>> ▁11 ▁; ▁q ▁-> ▁mant ▁[ ▁0 ▁] ▁= ▁x ▁& ▁0 x 7 ff ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁32 ▁* ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁c ure x pn ▁= ▁FF MAX ▁( ▁0 ▁, ▁q ▁-> ▁exp n ▁[ ▁0 ▁] ▁- ▁( ▁i ▁- ▁1 ▁) ▁/ ▁3 ▁) ▁; ▁q ▁-> ▁exp n ▁[ ▁i ▁] ▁= ▁c ure x pn ▁; ▁q ▁-> ▁mant ▁[ ▁i ▁] ▁= ▁q ▁-> ▁mant ▁[ ▁0 ▁] ▁; ▁} ▁} ▁else ▁{ ▁n ▁= ▁( ▁n ▁- ▁3 ▁) ▁>> ▁1 ▁; ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁n ▁|| ▁32 ▁* ▁3 ▁< ▁n ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁x ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁q ▁-> ▁exp n ▁[ ▁i ▁] ▁= ▁x ▁>> ▁11 ▁; ▁q ▁-> ▁mant ▁[ ▁i ▁] ▁= ▁x ▁& ▁0 x 7 ff ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁encode _ block ▁( ▁N elly M oser Encode Context ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁output ▁, ▁int ▁output _ size ▁) ▁{ ▁Put Bit Context ▁pb ▁; ▁int ▁i ▁, ▁j ▁, ▁band ▁, ▁block ▁, ▁best _ idx ▁, ▁power _ idx ▁= ▁0 ▁; ▁float ▁power _ val ▁, ▁coeff ▁, ▁coeff _ sum ▁; ▁float ▁p ows ▁[ ▁N EL LY _ FILL _ LEN ▁] ▁; ▁int ▁bits ▁[ ▁N EL LY _ BUF _ LEN ▁] ▁, ▁idx _ table ▁[ ▁N EL LY _ BAND S ▁] ▁; ▁float ▁cand ▁[ ▁N EL LY _ BAND S ▁] ▁; ▁apply _ md ct ▁( ▁s ▁) ▁; ▁init _ put _ bits ▁( ▁& ▁pb ▁, ▁output ▁, ▁output _ size ▁) ▁; ▁i ▁= ▁0 ▁; ▁for ▁( ▁band ▁= ▁0 ▁; ▁band ▁< ▁N EL LY _ BAND S ▁; ▁band ▁++ ▁) ▁{ ▁coeff _ sum ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁ff _ n elly _ band _ sizes _ table ▁[ ▁band ▁] ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁{ ▁coeff _ sum ▁+= ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁] ▁* ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁] ▁+ ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁+ ▁N EL LY _ BUF _ LEN ▁] ▁* ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁+ ▁N EL LY _ BUF _ LEN ▁] ▁; ▁} ▁cand ▁[ ▁band ▁] ▁= ▁log ▁( ▁FF MAX ▁( ▁1.0 ▁, ▁coeff _ sum ▁/ ▁( ▁ff _ n elly _ band _ sizes _ table ▁[ ▁band ▁] ▁<< ▁7 ▁) ▁) ▁) ▁* ▁1024.0 ▁/ ▁M _ LN 2 ▁; ▁} ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁tre ll is ▁) ▁{ ▁get _ exponent _ dynamic ▁( ▁s ▁, ▁cand ▁, ▁idx _ table ▁) ▁; ▁} ▁else ▁{ ▁get _ exponent _ g reedy ▁( ▁s ▁, ▁cand ▁, ▁idx _ table ▁) ▁; ▁} ▁i ▁= ▁0 ▁; ▁for ▁( ▁band ▁= ▁0 ▁; ▁band ▁< ▁N EL LY _ BAND S ▁; ▁band ▁++ ▁) ▁{ ▁if ▁( ▁band ▁) ▁{ ▁power _ idx ▁+= ▁ff _ n elly _ delta _ table ▁[ ▁idx _ table ▁[ ▁band ▁] ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁5 ▁, ▁idx _ table ▁[ ▁band ▁] ▁) ▁; ▁} ▁else ▁{ ▁power _ idx ▁= ▁ff _ n elly _ init _ table ▁[ ▁idx _ table ▁[ ▁0 ▁] ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁6 ▁, ▁idx _ table ▁[ ▁0 ▁] ▁) ▁; ▁} ▁power _ val ▁= ▁pow _ table ▁[ ▁power _ idx ▁& ▁0 x 7 FF ▁] ▁/ ▁( ▁1 ▁<< ▁( ▁( ▁power _ idx ▁>> ▁11 ▁) ▁+ ▁PO W _ TABLE _ OFFSET ▁) ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁ff _ n elly _ band _ sizes _ table ▁[ ▁band ▁] ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁{ ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁] ▁*= ▁power _ val ▁; ▁s ▁-> ▁md ct _ out ▁[ ▁i ▁+ ▁N EL LY _ BUF _ LEN ▁] ▁*= ▁power _ val ▁; ▁p ows ▁[ ▁i ▁] ▁= ▁power _ idx ▁; ▁} ▁} ▁ff _ n elly _ get _ sample _ bits ▁( ▁p ows ▁, ▁bits ▁) ▁; ▁for ▁( ▁block ▁= ▁0 ▁; ▁block ▁< ▁2 ▁; ▁block ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁N EL LY _ FILL _ LEN ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁bits ▁[ ▁i ▁] ▁> ▁0 ▁) ▁{ ▁const ▁float ▁* ▁table ▁= ▁ff _ n elly _ de quant ization _ table ▁+ ▁( ▁1 ▁<< ▁bits ▁[ ▁i ▁] ▁) ▁- ▁1 ▁; ▁coeff ▁= ▁s ▁-> ▁md ct _ out ▁[ ▁block ▁* ▁N EL LY _ BUF _ LEN ▁+ ▁i ▁] ▁; ▁best _ idx ▁= ▁quant _ lut ▁[ ▁av _ clip ▁( ▁coeff ▁* ▁quant _ lut _ mul ▁[ ▁bits ▁[ ▁i ▁] ▁] ▁+ ▁quant _ lut _ add ▁[ ▁bits ▁[ ▁i ▁] ▁] ▁, ▁quant _ lut _ offset ▁[ ▁bits ▁[ ▁i ▁] ▁] ▁, ▁quant _ lut _ offset ▁[ ▁bits ▁[ ▁i ▁] ▁+ ▁1 ▁] ▁- ▁1 ▁) ▁] ▁; ▁if ▁( ▁fabs ▁( ▁coeff ▁- ▁table ▁[ ▁best _ idx ▁] ▁) ▁> ▁fabs ▁( ▁coeff ▁- ▁table ▁[ ▁best _ idx ▁+ ▁1 ▁] ▁) ▁) ▁best _ idx ▁++ ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁bits ▁[ ▁i ▁] ▁, ▁best _ idx ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁block ▁) ▁put _ bits ▁( ▁& ▁pb ▁, ▁N EL LY _ HEADER _ BITS ▁+ ▁N EL LY _ DETAIL _ BITS ▁- ▁put _ bits _ count ▁( ▁& ▁pb ▁) ▁, ▁0 ▁) ▁; ▁} ▁flush _ put _ bits ▁( ▁& ▁pb ▁) ▁; ▁memset ▁( ▁put _ bits _ ptr ▁( ▁& ▁pb ▁) ▁, ▁0 ▁, ▁output ▁+ ▁output _ size ▁- ▁put _ bits _ ptr ▁( ▁& ▁pb ▁) ▁) ▁; ▁}	0
▁int ▁av _ compare _ ts ▁( ▁int 64_ t ▁ts _ a ▁, ▁AVR ational ▁tb _ a ▁, ▁int 64_ t ▁ts _ b ▁, ▁AVR ational ▁tb _ b ▁) ▁{ ▁int 64_ t ▁a ▁= ▁tb _ a ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁tb _ b ▁. ▁den ▁; ▁int 64_ t ▁b ▁= ▁tb _ b ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁tb _ a ▁. ▁den ▁; ▁if ▁( ▁( ▁FF ABS ▁( ▁ts _ a ▁) ▁| ▁a ▁| ▁FF ABS ▁( ▁ts _ b ▁) ▁| ▁b ▁) ▁<= ▁INT _ MAX ▁) ▁return ▁( ▁ts _ a ▁* ▁a ▁> ▁ts _ b ▁* ▁b ▁) ▁- ▁( ▁ts _ a ▁* ▁a ▁< ▁ts _ b ▁* ▁b ▁) ▁; ▁if ▁( ▁av _ re scale _ rnd ▁( ▁ts _ a ▁, ▁a ▁, ▁b ▁, ▁AV _ ROUND _ DOWN ▁) ▁< ▁ts _ b ▁) ▁return ▁-1 ▁; ▁if ▁( ▁av _ re scale _ rnd ▁( ▁ts _ b ▁, ▁b ▁, ▁a ▁, ▁AV _ ROUND _ DOWN ▁) ▁< ▁ts _ a ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁* ▁APR _ THREAD _ FUNC ▁start _ threads ▁( ▁apr _ thread _ t ▁* ▁thd ▁, ▁void ▁* ▁dummy ▁) ▁{ ▁thread _ star ter ▁* ▁ts ▁= ▁dummy ▁; ▁apr _ thread _ t ▁* ▁* ▁threads ▁= ▁ts ▁-> ▁threads ▁; ▁apr _ thread attr _ t ▁* ▁thread _ attr ▁= ▁ts ▁-> ▁thread attr ▁; ▁int ▁child _ num _ arg ▁= ▁ts ▁-> ▁child _ num _ arg ▁; ▁int ▁my _ child _ num ▁= ▁child _ num _ arg ▁; ▁proc _ info ▁* ▁my _ info ▁; ▁apr _ status _ t ▁rv ▁; ▁int ▁i ▁; ▁int ▁threads _ created ▁= ▁0 ▁; ▁int ▁listener _ started ▁= ▁0 ▁; ▁int ▁loops ▁; ▁int ▁prev _ threads _ created ▁; ▁int ▁max _ re cy cled _ pools ▁= ▁-1 ▁; ▁worker _ queue ▁= ▁apr _ pc alloc ▁( ▁p child ▁, ▁sizeof ▁( ▁* ▁worker _ queue ▁) ▁) ▁; ▁rv ▁= ▁ap _ queue _ init ▁( ▁worker _ queue ▁, ▁threads _ per _ child ▁, ▁p child ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ALERT ▁, ▁rv ▁, ▁ap _ server _ conf ▁, ▁" ap _ queue _ init () failed " ▁) ▁; ▁clean _ child _ exit ▁( ▁A PE X IT _ CH IL DF ATAL ▁) ▁; ▁} ▁if ▁( ▁ap _ max _ mem _ free ▁!= ▁APR _ ALLOCATOR _ MAX _ FREE _ UN LIMITED ▁) ▁{ ▁max _ re cy cled _ pools ▁= ▁threads _ per _ child ▁* ▁3 ▁/ ▁4 ▁; ▁} ▁rv ▁= ▁ap _ queue _ info _ create ▁( ▁& ▁worker _ queue _ info ▁, ▁p child ▁, ▁threads _ per _ child ▁, ▁max _ re cy cled _ pools ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ALERT ▁, ▁rv ▁, ▁ap _ server _ conf ▁, ▁" ap _ queue _ info _ create () failed " ▁) ▁; ▁clean _ child _ exit ▁( ▁A PE X IT _ CH IL DF ATAL ▁) ▁; ▁} ▁rv ▁= ▁apr _ poll set _ create ▁( ▁& ▁event _ poll set ▁, ▁threads _ per _ child ▁, ▁p child ▁, ▁APR _ POLL SET _ WAKE ABLE ▁| ▁APR _ POLL SET _ NO COPY ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁rv ▁, ▁ap _ server _ conf ▁, ▁" apr _ poll set _ create failed ; check system or user limits " ▁) ▁; ▁clean _ child _ exit ▁( ▁A PE X IT _ CH IL DF ATAL ▁) ▁; ▁} ▁worker _ sockets ▁= ▁apr _ pc alloc ▁( ▁p child ▁, ▁threads _ per _ child ▁* ▁sizeof ▁( ▁apr _ socket _ t ▁* ▁) ▁) ▁; ▁worker _ e queues ▁= ▁apr _ palloc ▁( ▁p child ▁, ▁threads _ per _ child ▁* ▁sizeof ▁( ▁ap _ e queue _ t ▁* ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁threads _ per _ child ▁; ▁i ▁++ ▁) ▁{ ▁ap _ e queue _ t ▁* ▁eq ▁= ▁NULL ▁; ▁ap _ e queue _ create ▁( ▁p child ▁, ▁16 ▁, ▁sizeof ▁( ▁poll set _ op _ t ▁) ▁, ▁& ▁eq ▁) ▁; ▁worker _ e queues ▁[ ▁i ▁] ▁= ▁eq ▁; ▁} ▁loops ▁= ▁prev _ threads _ created ▁= ▁0 ▁; ▁while ▁( ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁threads _ per _ child ▁; ▁i ▁++ ▁) ▁{ ▁int ▁status ▁= ▁ap _ score board _ image ▁-> ▁servers ▁[ ▁child _ num _ arg ▁] ▁[ ▁i ▁] ▁. ▁status ▁; ▁if ▁( ▁status ▁!= ▁SERVER _ GR ACE FUL ▁&& ▁status ▁!= ▁SERVER _ DEAD ▁) ▁{ ▁continue ▁; ▁} ▁my _ info ▁= ▁( ▁proc _ info ▁* ▁) ▁ap _ malloc ▁( ▁sizeof ▁( ▁proc _ info ▁) ▁) ▁; ▁my _ info ▁-> ▁pid ▁= ▁my _ child _ num ▁; ▁my _ info ▁-> ▁tid ▁= ▁i ▁; ▁my _ info ▁-> ▁sd ▁= ▁0 ▁; ▁ap _ update _ child _ status _ from _ indexes ▁( ▁my _ child _ num ▁, ▁i ▁, ▁SERVER _ START ING ▁, ▁NULL ▁) ▁; ▁rv ▁= ▁apr _ thread _ create ▁( ▁& ▁threads ▁[ ▁i ▁] ▁, ▁thread _ attr ▁, ▁worker _ thread ▁, ▁my _ info ▁, ▁p child ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ALERT ▁, ▁rv ▁, ▁ap _ server _ conf ▁, ▁" apr _ thread _ create : unable toc reate worker thread " ▁) ▁; ▁clean _ child _ exit ▁( ▁A PE X IT _ CH IL DS ICK ▁) ▁; ▁} ▁threads _ created ▁++ ▁; ▁} ▁if ▁( ▁! ▁listener _ started ▁&& ▁threads _ created ▁) ▁{ ▁create _ listener _ thread ▁( ▁ts ▁) ▁; ▁listener _ started ▁= ▁1 ▁; ▁} ▁if ▁( ▁start _ thread _ may _ exit ▁|| ▁threads _ created ▁== ▁threads _ per _ child ▁) ▁{ ▁break ▁; ▁} ▁apr _ sleep ▁( ▁apr _ time _ from _ sec ▁( ▁1 ▁) ▁) ▁; ▁++ ▁loops ▁; ▁if ▁( ▁loops ▁% ▁120 ▁== ▁0 ▁) ▁{ ▁if ▁( ▁prev _ threads _ created ▁== ▁threads _ created ▁) ▁{ ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁ap _ server _ conf ▁, ▁" child %" ▁APR _ PID _ T _ FMT ▁" is n ' tt aking over " ▁" slots very quick ly (% d of % d )" ▁, ▁ap _ my _ pid ▁, ▁threads _ created ▁, ▁threads _ per _ child ▁) ▁; ▁} ▁prev _ threads _ created ▁= ▁threads _ created ▁; ▁} ▁} ▁apr _ thread _ exit ▁( ▁thd ▁, ▁APR _ SUCCESS ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁int ▁poll _ filters ▁( ▁void ▁) ▁{ ▁AVFilter Buffer Ref ▁* ▁pic ref ▁; ▁AVFrame ▁* ▁filtered _ frame ▁= ▁NULL ▁; ▁int ▁i ▁, ▁ret ▁, ▁ret _ all ▁; ▁unsigned ▁nb _ success ▁, ▁nb _ eof ▁; ▁int 64_ t ▁frame _ pts ▁; ▁while ▁( ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁OutputFile ▁* ▁of ▁= ▁output _ files ▁[ ▁o st ▁-> ▁file _ index ▁] ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁! ▁o st ▁-> ▁filter ▁|| ▁o st ▁-> ▁is _ p ast _ recording _ time ▁) ▁continue ▁; ▁if ▁( ▁! ▁o st ▁-> ▁filtered _ frame ▁&& ▁! ▁( ▁o st ▁-> ▁filtered _ frame ▁= ▁avcodec _ alloc _ frame ▁( ▁) ▁) ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁else ▁avcodec _ get _ frame _ defaults ▁( ▁o st ▁-> ▁filtered _ frame ▁) ▁; ▁filtered _ frame ▁= ▁o st ▁-> ▁filtered _ frame ▁; ▁while ▁( ▁1 ▁) ▁{ ▁AVR ational ▁ist _ pts _ tb ▁= ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁time _ base ▁; ▁if ▁( ▁o st ▁-> ▁enc ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁! ▁( ▁o st ▁-> ▁enc ▁-> ▁capabilities ▁& ▁CODEC _ CAP _ VARIABLE _ FRAME _ SIZE ▁) ▁) ▁ret ▁= ▁av _ buffers ink _ read _ samples ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁frame _ size ▁) ▁; ▁else ▁# ifdef ▁S INK A ▁ret ▁= ▁av _ buffers ink _ read ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁) ▁; ▁# else ▁ret ▁= ▁av _ buffers ink _ get _ buffer _ ref ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁, ▁AV _ BUFFER SINK _ FLAG _ NO _ REQUEST ▁) ▁; ▁# endif ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ret ▁!= ▁AVERROR ▁( ▁EAGAIN ▁) ▁&& ▁ret ▁!= ▁AVERROR _ EOF ▁) ▁{ ▁char ▁buf ▁[ ▁256 ▁] ▁; ▁av _ strerror ▁( ▁ret ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" Error in av _ buffers ink _ get _ buffer _ ref () :% s \ n " ▁, ▁buf ▁) ▁; ▁} ▁break ▁; ▁} ▁if ▁( ▁o st ▁-> ▁enc ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁= ▁av _ re scale _ q ▁( ▁pic ref ▁-> ▁pts ▁, ▁ist _ pts _ tb ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁else ▁if ▁( ▁pic ref ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁= ▁av _ re scale _ q ▁( ▁pic ref ▁-> ▁pts ▁, ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁time _ base ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁) ▁- ▁av _ re scale _ q ▁( ▁of ▁-> ▁start _ time ▁, ▁AV _ TIME _ BASE _ Q ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁) ▁; ▁if ▁( ▁of ▁-> ▁start _ time ▁&& ▁filtered _ frame ▁-> ▁pts ▁< ▁of ▁-> ▁start _ time ▁) ▁{ ▁avfilter _ unref _ buffer ▁( ▁pic ref ▁) ▁; ▁continue ▁; ▁} ▁switch ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁avfilter _ fill _ frame _ from _ video _ buffer _ ref ▁( ▁filtered _ frame ▁, ▁pic ref ▁) ▁; ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁; ▁if ▁( ▁! ▁o st ▁-> ▁frame _ aspect _ ratio ▁) ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁sample _ aspect _ ratio ▁= ▁pic ref ▁-> ▁video ▁-> ▁sample _ aspect _ ratio ▁; ▁do _ video _ out ▁( ▁of ▁-> ▁ctx ▁, ▁o st ▁, ▁filtered _ frame ▁, ▁same _ quant ▁? ▁o st ▁-> ▁last _ quality ▁: ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁global _ quality ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁avfilter _ copy _ buf _ props ▁( ▁filtered _ frame ▁, ▁pic ref ▁) ▁; ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁; ▁do _ audio _ out ▁( ▁of ▁-> ▁ctx ▁, ▁o st ▁, ▁filtered _ frame ▁) ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁} ▁avfilter _ unref _ buffer ▁( ▁pic ref ▁) ▁; ▁} ▁} ▁ret _ all ▁= ▁nb _ success ▁= ▁nb _ eof ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ filter graph s ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁= ▁avfilter _ graph _ request _ ol dest ▁( ▁filter graph s ▁[ ▁i ▁] ▁-> ▁graph ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁{ ▁nb _ success ▁++ ▁; ▁} ▁else ▁if ▁( ▁ret ▁== ▁AVERROR _ EOF ▁) ▁{ ▁nb _ eof ▁++ ▁; ▁} ▁else ▁if ▁( ▁ret ▁!= ▁AVERROR ▁( ▁EAGAIN ▁) ▁) ▁{ ▁char ▁buf ▁[ ▁256 ▁] ▁; ▁av _ strerror ▁( ▁ret ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" Error in request _ frame () :% s \ n " ▁, ▁buf ▁) ▁; ▁ret _ all ▁= ▁ret ▁; ▁} ▁} ▁if ▁( ▁! ▁nb _ success ▁) ▁break ▁; ▁} ▁return ▁nb _ eof ▁== ▁nb _ filter graph s ▁? ▁AVERROR _ EOF ▁: ▁ret _ all ▁; ▁}	1
▁char ▁* ▁X 509_ NAME _ on eline ▁( ▁const ▁X 509_ NAME ▁* ▁a ▁, ▁char ▁* ▁buf ▁, ▁int ▁len ▁) ▁{ ▁const ▁X 509_ NAME _ ENTRY ▁* ▁ne ▁; ▁int ▁i ▁; ▁int ▁n ▁, ▁l old ▁, ▁l ▁, ▁l 1 ▁, ▁l 2 ▁, ▁num ▁, ▁j ▁, ▁type ▁; ▁const ▁char ▁* ▁s ▁; ▁char ▁* ▁p ▁; ▁unsigned ▁char ▁* ▁q ▁; ▁BUF _ MEM ▁* ▁b ▁= ▁NULL ▁; ▁static ▁const ▁char ▁hex ▁[ ▁17 ▁] ▁= ▁"0123456789 ABCDEF " ▁; ▁int ▁gs _ doit ▁[ ▁4 ▁] ▁; ▁char ▁tmp _ buf ▁[ ▁80 ▁] ▁; ▁# ifdef ▁CHARSET _ EBCDIC ▁unsigned ▁char ▁ebc dic _ buf ▁[ ▁1024 ▁] ▁; ▁# endif ▁if ▁( ▁buf ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁b ▁= ▁BUF _ MEM _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BUF _ MEM _ grow ▁( ▁b ▁, ▁200 ▁) ▁) ▁goto ▁err ▁; ▁b ▁-> ▁data ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁len ▁= ▁200 ▁; ▁} ▁else ▁if ▁( ▁len ▁== ▁0 ▁) ▁{ ▁return ▁NULL ▁; ▁} ▁if ▁( ▁a ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁b ▁) ▁{ ▁buf ▁= ▁b ▁-> ▁data ▁; ▁OPENSSL _ free ▁( ▁b ▁) ▁; ▁} ▁strncpy ▁( ▁buf ▁, ▁" NO X 509_ NAME " ▁, ▁len ▁) ▁; ▁buf ▁[ ▁len ▁- ▁1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁return ▁buf ▁; ▁} ▁len ▁-- ▁; ▁l ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ X 509_ NAME _ ENTRY _ num ▁( ▁a ▁-> ▁entries ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ne ▁= ▁sk _ X 509_ NAME _ ENTRY _ value ▁( ▁a ▁-> ▁entries ▁, ▁i ▁) ▁; ▁n ▁= ▁OBJ _ obj 2 nid ▁( ▁ne ▁-> ▁object ▁) ▁; ▁if ▁( ▁( ▁n ▁== ▁NID _ undef ▁) ▁|| ▁( ▁( ▁s ▁= ▁OBJ _ nid 2 sn ▁( ▁n ▁) ▁) ▁== ▁NULL ▁) ▁) ▁{ ▁i 2 t _ ASN 1_ OBJECT ▁( ▁tmp _ buf ▁, ▁sizeof ▁( ▁tmp _ buf ▁) ▁, ▁ne ▁-> ▁object ▁) ▁; ▁s ▁= ▁tmp _ buf ▁; ▁} ▁l 1 ▁= ▁strlen ▁( ▁s ▁) ▁; ▁type ▁= ▁ne ▁-> ▁value ▁-> ▁type ▁; ▁num ▁= ▁ne ▁-> ▁value ▁-> ▁length ▁; ▁if ▁( ▁num ▁> ▁NAME _ ON ELINE _ MAX ▁) ▁{ ▁X 509 err ▁( ▁X 509_ F _ X 509_ NAME _ ON ELINE ▁, ▁X 509_ R _ NAME _ TOO _ LONG ▁) ▁; ▁goto ▁end ▁; ▁} ▁q ▁= ▁ne ▁-> ▁value ▁-> ▁data ▁; ▁# ifdef ▁CHARSET _ EBCDIC ▁if ▁( ▁type ▁== ▁V _ ASN 1_ GENERAL STRING ▁|| ▁type ▁== ▁V _ ASN 1_ VIS IB LES TRING ▁|| ▁type ▁== ▁V _ ASN 1_ PR IN TABLES TRING ▁|| ▁type ▁== ▁V _ ASN 1_ TE LE TEX STRING ▁|| ▁type ▁== ▁V _ ASN 1_ IA 5 STRING ▁) ▁{ ▁if ▁( ▁num ▁> ▁( ▁int ▁) ▁sizeof ▁( ▁ebc dic _ buf ▁) ▁) ▁num ▁= ▁sizeof ▁( ▁ebc dic _ buf ▁) ▁; ▁ascii 2 ebc dic ▁( ▁ebc dic _ buf ▁, ▁q ▁, ▁num ▁) ▁; ▁q ▁= ▁ebc dic _ buf ▁; ▁} ▁# endif ▁if ▁( ▁( ▁type ▁== ▁V _ ASN 1_ GENERAL STRING ▁) ▁&& ▁( ▁( ▁num ▁% ▁4 ▁) ▁== ▁0 ▁) ▁) ▁{ ▁gs _ doit ▁[ ▁0 ▁] ▁= ▁gs _ doit ▁[ ▁1 ▁] ▁= ▁gs _ doit ▁[ ▁2 ▁] ▁= ▁gs _ doit ▁[ ▁3 ▁] ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁num ▁; ▁j ▁++ ▁) ▁if ▁( ▁q ▁[ ▁j ▁] ▁!= ▁0 ▁) ▁gs _ doit ▁[ ▁j ▁& ▁3 ▁] ▁= ▁1 ▁; ▁if ▁( ▁gs _ doit ▁[ ▁0 ▁] ▁| ▁gs _ doit ▁[ ▁1 ▁] ▁| ▁gs _ doit ▁[ ▁2 ▁] ▁) ▁gs _ doit ▁[ ▁0 ▁] ▁= ▁gs _ doit ▁[ ▁1 ▁] ▁= ▁gs _ doit ▁[ ▁2 ▁] ▁= ▁gs _ doit ▁[ ▁3 ▁] ▁= ▁1 ▁; ▁else ▁{ ▁gs _ doit ▁[ ▁0 ▁] ▁= ▁gs _ doit ▁[ ▁1 ▁] ▁= ▁gs _ doit ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁gs _ doit ▁[ ▁3 ▁] ▁= ▁1 ▁; ▁} ▁} ▁else ▁gs _ doit ▁[ ▁0 ▁] ▁= ▁gs _ doit ▁[ ▁1 ▁] ▁= ▁gs _ doit ▁[ ▁2 ▁] ▁= ▁gs _ doit ▁[ ▁3 ▁] ▁= ▁1 ▁; ▁for ▁( ▁l 2 ▁= ▁j ▁= ▁0 ▁; ▁j ▁< ▁num ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁! ▁gs _ doit ▁[ ▁j ▁& ▁3 ▁] ▁) ▁continue ▁; ▁l 2 ▁++ ▁; ▁# ifndef ▁CHARSET _ EBCDIC ▁if ▁( ▁( ▁q ▁[ ▁j ▁] ▁< ▁' ▁' ▁) ▁|| ▁( ▁q ▁[ ▁j ▁] ▁> ▁' ▁' ▁) ▁) ▁l 2 ▁+= ▁3 ▁; ▁# else ▁if ▁( ▁( ▁os _ to ascii ▁[ ▁q ▁[ ▁j ▁] ▁] ▁< ▁os _ to ascii ▁[ ▁' ▁' ▁] ▁) ▁|| ▁( ▁os _ to ascii ▁[ ▁q ▁[ ▁j ▁] ▁] ▁> ▁os _ to ascii ▁[ ▁' ▁' ▁] ▁) ▁) ▁l 2 ▁+= ▁3 ▁; ▁# endif ▁} ▁l old ▁= ▁l ▁; ▁l ▁+= ▁1 ▁+ ▁l 1 ▁+ ▁1 ▁+ ▁l 2 ▁; ▁if ▁( ▁l ▁> ▁NAME _ ON ELINE _ MAX ▁) ▁{ ▁X 509 err ▁( ▁X 509_ F _ X 509_ NAME _ ON ELINE ▁, ▁X 509_ R _ NAME _ TOO _ LONG ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁b ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁BUF _ MEM _ grow ▁( ▁b ▁, ▁l ▁+ ▁1 ▁) ▁) ▁goto ▁err ▁; ▁p ▁= ▁& ▁( ▁b ▁-> ▁data ▁[ ▁l old ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁l ▁> ▁len ▁) ▁{ ▁break ▁; ▁} ▁else ▁p ▁= ▁& ▁( ▁buf ▁[ ▁l old ▁] ▁) ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁memcpy ▁( ▁p ▁, ▁s ▁, ▁( ▁unsigned ▁int ▁) ▁l 1 ▁) ▁; ▁p ▁+= ▁l 1 ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁# ifndef ▁CHARSET _ EBCDIC ▁q ▁= ▁ne ▁-> ▁value ▁-> ▁data ▁; ▁# endif ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁num ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁! ▁gs _ doit ▁[ ▁j ▁& ▁3 ▁] ▁) ▁continue ▁; ▁# ifndef ▁CHARSET _ EBCDIC ▁n ▁= ▁q ▁[ ▁j ▁] ▁; ▁if ▁( ▁( ▁n ▁< ▁' ▁' ▁) ▁|| ▁( ▁n ▁> ▁' ▁' ▁) ▁) ▁{ ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁\\ ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁hex ▁[ ▁( ▁n ▁>> ▁4 ▁) ▁& ▁0 x 0 f ▁] ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁hex ▁[ ▁n ▁& ▁0 x 0 f ▁] ▁; ▁} ▁else ▁* ▁( ▁p ▁++ ▁) ▁= ▁n ▁; ▁# else ▁n ▁= ▁os _ to ascii ▁[ ▁q ▁[ ▁j ▁] ▁] ▁; ▁if ▁( ▁( ▁n ▁< ▁os _ to ascii ▁[ ▁' ▁' ▁] ▁) ▁|| ▁( ▁n ▁> ▁os _ to ascii ▁[ ▁' ▁' ▁] ▁) ▁) ▁{ ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁\\ ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁hex ▁[ ▁( ▁n ▁>> ▁4 ▁) ▁& ▁0 x 0 f ▁] ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁hex ▁[ ▁n ▁& ▁0 x 0 f ▁] ▁; ▁} ▁else ▁* ▁( ▁p ▁++ ▁) ▁= ▁q ▁[ ▁j ▁] ▁; ▁# endif ▁} ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁b ▁!= ▁NULL ▁) ▁{ ▁p ▁= ▁b ▁-> ▁data ▁; ▁OPENSSL _ free ▁( ▁b ▁) ▁; ▁} ▁else ▁p ▁= ▁buf ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁return ▁( ▁p ▁) ▁; ▁err ▁: ▁X 509 err ▁( ▁X 509_ F _ X 509_ NAME _ ON ELINE ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁end ▁: ▁BUF _ MEM _ free ▁( ▁b ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	1
▁static ▁int ▁h ls _ read ▁( ▁URL Context ▁* ▁h ▁, ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁size ▁) ▁{ ▁H LS Context ▁* ▁s ▁= ▁h ▁-> ▁priv _ data ▁; ▁const ▁char ▁* ▁url ▁; ▁int ▁ret ▁; ▁int 64_ t ▁reload _ interval ▁; ▁start ▁: ▁if ▁( ▁s ▁-> ▁seg _ hd ▁) ▁{ ▁ret ▁= ▁ff url _ read ▁( ▁s ▁-> ▁seg _ hd ▁, ▁buf ▁, ▁size ▁) ▁; ▁if ▁( ▁ret ▁> ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁s ▁-> ▁seg _ hd ▁) ▁{ ▁ff url _ close ▁( ▁s ▁-> ▁seg _ hd ▁) ▁; ▁s ▁-> ▁seg _ hd ▁= ▁NULL ▁; ▁s ▁-> ▁cur _ seq _ no ▁++ ▁; ▁} ▁reload _ interval ▁= ▁s ▁-> ▁n _ segments ▁> ▁0 ▁? ▁s ▁-> ▁segments ▁[ ▁s ▁-> ▁n _ segments ▁- ▁1 ▁] ▁-> ▁duration ▁: ▁s ▁-> ▁target _ duration ▁; ▁reload _ interval ▁*= ▁1000000 ▁; ▁retry ▁: ▁if ▁( ▁! ▁s ▁-> ▁finished ▁) ▁{ ▁int 64_ t ▁now ▁= ▁av _ gettime ▁( ▁) ▁; ▁if ▁( ▁now ▁- ▁s ▁-> ▁last _ load _ time ▁>= ▁reload _ interval ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁parse _ playlist ▁( ▁h ▁, ▁s ▁-> ▁playlist url ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁reload _ interval ▁= ▁s ▁-> ▁target _ duration ▁* ▁500000 ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁cur _ seq _ no ▁< ▁s ▁-> ▁start _ seq _ no ▁) ▁{ ▁av _ log ▁( ▁h ▁, ▁AV _ LOG _ WARNING ▁, ▁" sk ipping % d segments ahead , expired f ro mp lay list \ n " ▁, ▁s ▁-> ▁start _ seq _ no ▁- ▁s ▁-> ▁cur _ seq _ no ▁) ▁; ▁s ▁-> ▁cur _ seq _ no ▁= ▁s ▁-> ▁start _ seq _ no ▁; ▁} ▁if ▁( ▁s ▁-> ▁cur _ seq _ no ▁- ▁s ▁-> ▁start _ seq _ no ▁>= ▁s ▁-> ▁n _ segments ▁) ▁{ ▁if ▁( ▁s ▁-> ▁finished ▁) ▁return ▁AVERROR _ EOF ▁; ▁while ▁( ▁av _ gettime ▁( ▁) ▁- ▁s ▁-> ▁last _ load _ time ▁< ▁reload _ interval ▁) ▁{ ▁if ▁( ▁ff _ check _ interrupt ▁( ▁& ▁h ▁-> ▁interrupt _ callback ▁) ▁) ▁return ▁AVERROR _ EXIT ▁; ▁av _ us leep ▁( ▁100 ▁* ▁1000 ▁) ▁; ▁} ▁goto ▁retry ▁; ▁} ▁url ▁= ▁s ▁-> ▁segments ▁[ ▁s ▁-> ▁cur _ seq _ no ▁- ▁s ▁-> ▁start _ seq _ no ▁] ▁-> ▁url ▁, ▁av _ log ▁( ▁h ▁, ▁AV _ LOG _ DEBUG ▁, ▁" open ing % s \ n " ▁, ▁url ▁) ▁; ▁ret ▁= ▁ff url _ open ▁( ▁& ▁s ▁-> ▁seg _ hd ▁, ▁url ▁, ▁AVIO _ FLAG _ READ ▁, ▁& ▁h ▁-> ▁interrupt _ callback ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ff _ check _ interrupt ▁( ▁& ▁h ▁-> ▁interrupt _ callback ▁) ▁) ▁return ▁AVERROR _ EXIT ▁; ▁av _ log ▁( ▁h ▁, ▁AV _ LOG _ WARNING ▁, ▁" Unable too pen % s \ n " ▁, ▁url ▁) ▁; ▁s ▁-> ▁cur _ seq _ no ▁++ ▁; ▁goto ▁retry ▁; ▁} ▁goto ▁start ▁; ▁}	1
▁int ▁av _ parse _ time ▁( ▁int 64_ t ▁* ▁timeval ▁, ▁const ▁char ▁* ▁tim estr ▁, ▁int ▁duration ▁) ▁{ ▁const ▁char ▁* ▁p ▁; ▁int 64_ t ▁t ▁; ▁struct ▁tm ▁dt ▁= ▁{ ▁0 ▁} ▁; ▁int ▁i ▁; ▁static ▁const ▁char ▁* ▁const ▁date _ fmt ▁[ ▁] ▁= ▁{ ▁"% Y -% m -% d " ▁, ▁"% Y % m % d " ▁, ▁} ▁; ▁static ▁const ▁char ▁* ▁const ▁time _ fmt ▁[ ▁] ▁= ▁{ ▁"% H :% M :% S " ▁, ▁"% H % M % S " ▁, ▁} ▁; ▁const ▁char ▁* ▁q ▁; ▁int ▁is _ ut c ▁, ▁len ▁; ▁char ▁last ch ▁; ▁int ▁negative ▁= ▁0 ▁; ▁# undef ▁time ▁time _ t ▁now ▁= ▁time ▁( ▁0 ▁) ▁; ▁len ▁= ▁strlen ▁( ▁tim estr ▁) ▁; ▁if ▁( ▁len ▁> ▁0 ▁) ▁last ch ▁= ▁tim estr ▁[ ▁len ▁- ▁1 ▁] ▁; ▁else ▁last ch ▁= ▁' ▁\0 ▁' ▁; ▁is _ ut c ▁= ▁( ▁last ch ▁== ▁' ▁' ▁|| ▁last ch ▁== ▁' ▁' ▁) ▁; ▁p ▁= ▁tim estr ▁; ▁q ▁= ▁NULL ▁; ▁if ▁( ▁! ▁duration ▁) ▁{ ▁if ▁( ▁! ▁av _ strncasecmp ▁( ▁tim estr ▁, ▁" now " ▁, ▁len ▁) ▁) ▁{ ▁* ▁timeval ▁= ▁( ▁int 64_ t ▁) ▁now ▁* ▁1000000 ▁; ▁return ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁date _ fmt ▁) ▁; ▁i ▁++ ▁) ▁{ ▁q ▁= ▁small _ str ptime ▁( ▁p ▁, ▁date _ fmt ▁[ ▁i ▁] ▁, ▁& ▁dt ▁) ▁; ▁if ▁( ▁q ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁q ▁) ▁{ ▁if ▁( ▁is _ ut c ▁) ▁{ ▁dt ▁= ▁* ▁gmt ime ▁( ▁& ▁now ▁) ▁; ▁} ▁else ▁{ ▁dt ▁= ▁* ▁localtime ▁( ▁& ▁now ▁) ▁; ▁} ▁dt ▁. ▁tm _ hour ▁= ▁dt ▁. ▁tm _ min ▁= ▁dt ▁. ▁tm _ sec ▁= ▁0 ▁; ▁} ▁else ▁{ ▁p ▁= ▁q ▁; ▁} ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁|| ▁* ▁p ▁== ▁' ▁' ▁|| ▁* ▁p ▁== ▁' ▁' ▁) ▁p ▁++ ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁time _ fmt ▁) ▁; ▁i ▁++ ▁) ▁{ ▁q ▁= ▁small _ str ptime ▁( ▁p ▁, ▁time _ fmt ▁[ ▁i ▁] ▁, ▁& ▁dt ▁) ▁; ▁if ▁( ▁q ▁) ▁{ ▁break ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁p ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁negative ▁= ▁1 ▁; ▁++ ▁p ▁; ▁} ▁q ▁= ▁small _ str ptime ▁( ▁p ▁, ▁time _ fmt ▁[ ▁0 ▁] ▁, ▁& ▁dt ▁) ▁; ▁if ▁( ▁! ▁q ▁) ▁{ ▁dt ▁. ▁tm _ sec ▁= ▁strtol ▁( ▁p ▁, ▁( ▁void ▁* ▁) ▁& ▁q ▁, ▁10 ▁) ▁; ▁if ▁( ▁q ▁== ▁p ▁) ▁{ ▁* ▁timeval ▁= ▁INT 64_ MIN ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁dt ▁. ▁tm _ min ▁= ▁0 ▁; ▁dt ▁. ▁tm _ hour ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁! ▁q ▁) ▁{ ▁* ▁timeval ▁= ▁INT 64_ MIN ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁duration ▁) ▁{ ▁t ▁= ▁dt ▁. ▁tm _ hour ▁* ▁3600 ▁+ ▁dt ▁. ▁tm _ min ▁* ▁60 ▁+ ▁dt ▁. ▁tm _ sec ▁; ▁} ▁else ▁{ ▁dt ▁. ▁tm _ is dst ▁= ▁-1 ▁; ▁if ▁( ▁is _ ut c ▁) ▁{ ▁t ▁= ▁av _ time gm ▁( ▁& ▁dt ▁) ▁; ▁} ▁else ▁{ ▁t ▁= ▁mktime ▁( ▁& ▁dt ▁) ▁; ▁} ▁} ▁t ▁*= ▁1000000 ▁; ▁if ▁( ▁* ▁q ▁== ▁' ▁' ▁) ▁{ ▁int ▁val ▁, ▁n ▁; ▁q ▁++ ▁; ▁for ▁( ▁val ▁= ▁0 ▁, ▁n ▁= ▁100000 ▁; ▁n ▁>= ▁1 ▁; ▁n ▁/= ▁10 ▁, ▁q ▁++ ▁) ▁{ ▁if ▁( ▁! ▁isdigit ▁( ▁* ▁q ▁) ▁) ▁break ▁; ▁val ▁+= ▁n ▁* ▁( ▁* ▁q ▁- ▁' ▁' ▁) ▁; ▁} ▁t ▁+= ▁val ▁; ▁} ▁* ▁timeval ▁= ▁negative ▁? ▁- ▁t ▁: ▁t ▁; ▁return ▁0 ▁; ▁}	1
▁AP _ DECLARE ▁( ▁void ▁) ▁ap _ get _ mime _ headers _ core ▁( ▁request _ rec ▁* ▁r ▁, ▁apr _ bucket _ b rig ade ▁* ▁bb ▁) ▁{ ▁char ▁* ▁last _ field ▁= ▁NULL ▁; ▁apr _ size _ t ▁last _ len ▁= ▁0 ▁; ▁apr _ size _ t ▁alloc _ len ▁= ▁0 ▁; ▁char ▁* ▁field ▁; ▁char ▁* ▁value ▁; ▁apr _ size _ t ▁len ▁; ▁int ▁fields _ read ▁= ▁0 ▁; ▁char ▁* ▁tmp _ field ▁; ▁core _ server _ config ▁* ▁conf ▁= ▁ap _ get _ core _ module _ config ▁( ▁r ▁-> ▁server ▁-> ▁module _ config ▁) ▁; ▁int ▁strict ▁= ▁( ▁conf ▁-> ▁http _ con formance ▁!= ▁AP _ HTTP _ CON FORM ANCE _ UN SAFE ▁) ▁; ▁while ▁( ▁1 ▁) ▁{ ▁apr _ status _ t ▁rv ▁; ▁field ▁= ▁NULL ▁; ▁rv ▁= ▁ap _ r get line ▁( ▁& ▁field ▁, ▁r ▁-> ▁server ▁-> ▁limit _ req _ field size ▁+ ▁2 ▁, ▁& ▁len ▁, ▁r ▁, ▁0 ▁, ▁bb ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁if ▁( ▁APR _ STATUS _ IS _ TIME UP ▁( ▁rv ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ REQUEST _ TIME _ OUT ▁; ▁} ▁else ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁} ▁if ▁( ▁rv ▁== ▁APR _ ENO SPC ▁) ▁{ ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Size of are quest header field " ▁" e xce ed ss erver limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 1 ▁) ▁" Request header e xce eds Limit Request Field Size % s " ▁"%.* s " ▁, ▁( ▁field ▁&& ▁* ▁field ▁) ▁? ▁":" ▁: ▁"" ▁, ▁( ▁field ▁) ▁? ▁field _ name _ len ▁( ▁field ▁) ▁: ▁0 ▁, ▁( ▁field ▁) ▁? ▁field ▁: ▁"" ▁) ▁; ▁} ▁return ▁; ▁} ▁if ▁( ▁strict ▁&& ▁strp brk ▁( ▁field ▁, ▁"\ n \ v \ f \ r " ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 51 ▁) ▁" Request header line present ed bad whitespace " ▁"( dis allowed by Strict Whitespace )" ▁) ▁; ▁return ▁; ▁} ▁else ▁{ ▁char ▁* ▁ll ▁= ▁field ▁; ▁while ▁( ▁( ▁ll ▁= ▁strp brk ▁( ▁ll ▁, ▁"\ n \ v \ f \ r " ▁) ▁) ▁) ▁* ▁( ▁ll ▁++ ▁) ▁= ▁' ▁' ▁; ▁} ▁while ▁( ▁len ▁> ▁1 ▁&& ▁( ▁field ▁[ ▁len ▁- ▁1 ▁] ▁== ▁' ▁\ t ▁' ▁|| ▁field ▁[ ▁len ▁- ▁1 ▁] ▁== ▁' ▁' ▁) ▁) ▁{ ▁field ▁[ ▁-- ▁len ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁* ▁field ▁== ▁' ▁\ t ▁' ▁|| ▁* ▁field ▁== ▁' ▁' ▁) ▁{ ▁apr _ size _ t ▁fold _ len ▁; ▁if ▁( ▁last _ field ▁== ▁NULL ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 42 ▁) ▁" Line f olding en countered be fo ref irst " ▁" header line " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁field ▁[ ▁1 ▁] ▁== ▁' ▁\0 ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 43 ▁) ▁" Empty fol ded line en countered " ▁) ▁; ▁return ▁; ▁} ▁while ▁( ▁field ▁[ ▁1 ▁] ▁== ▁' ▁\ t ▁' ▁|| ▁field ▁[ ▁1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁++ ▁field ▁; ▁-- ▁len ▁; ▁} ▁fold _ len ▁= ▁last _ len ▁+ ▁len ▁+ ▁1 ▁; ▁if ▁( ▁fold _ len ▁>= ▁( ▁apr _ size _ t ▁) ▁( ▁r ▁-> ▁server ▁-> ▁limit _ req _ field size ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Size of are quest header field " ▁" e xce ed ss erver limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 2 ▁) ▁" Request header e xce eds Limit Request Field Size " ▁" after f olding :% .* s " ▁, ▁field _ name _ len ▁( ▁last _ field ▁) ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁fold _ len ▁> ▁alloc _ len ▁) ▁{ ▁char ▁* ▁fold _ buf ▁; ▁alloc _ len ▁+= ▁alloc _ len ▁; ▁if ▁( ▁fold _ len ▁> ▁alloc _ len ▁) ▁{ ▁alloc _ len ▁= ▁fold _ len ▁; ▁} ▁fold _ buf ▁= ▁( ▁char ▁* ▁) ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁alloc _ len ▁) ▁; ▁memcpy ▁( ▁fold _ buf ▁, ▁last _ field ▁, ▁last _ len ▁) ▁; ▁last _ field ▁= ▁fold _ buf ▁; ▁} ▁memcpy ▁( ▁last _ field ▁+ ▁last _ len ▁, ▁field ▁, ▁len ▁+ ▁1 ▁) ▁; ▁last _ field ▁[ ▁last _ len ▁] ▁= ▁' ▁' ▁; ▁last _ len ▁+= ▁len ▁; ▁continue ▁; ▁} ▁else ▁if ▁( ▁last _ field ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁r ▁-> ▁server ▁-> ▁limit _ req _ fields ▁&& ▁( ▁++ ▁fields _ read ▁> ▁r ▁-> ▁server ▁-> ▁limit _ req _ fields ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Th enum ber of request header fields " ▁" e xce ed sth iss erver ' s limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 3 ▁) ▁" Number of request header se xce eds " ▁" Limit Request Fields " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁strict ▁) ▁{ ▁if ▁( ▁! ▁( ▁value ▁= ▁strchr ▁( ▁last _ field ▁, ▁' ▁' ▁) ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 05 64 ▁) ▁" Request header field ism issing ': '" ▁" separator :% .* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁tmp _ field ▁= ▁value ▁- ▁( ▁value ▁> ▁last _ field ▁? ▁1 ▁: ▁0 ▁) ▁; ▁* ▁value ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁strict ▁&& ▁strp brk ▁( ▁last _ field ▁, ▁"\ t " ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 52 ▁) ▁" Request header field name with whitespace " ▁"( dis allowed by Strict Whitespace )" ▁) ▁; ▁return ▁; ▁} ▁while ▁( ▁* ▁value ▁== ▁' ▁' ▁|| ▁* ▁value ▁== ▁' ▁\ t ▁' ▁) ▁{ ▁++ ▁value ▁; ▁} ▁while ▁( ▁tmp _ field ▁> ▁last _ field ▁&& ▁( ▁* ▁tmp _ field ▁== ▁' ▁' ▁|| ▁* ▁tmp _ field ▁== ▁' ▁\ t ▁' ▁) ▁) ▁{ ▁* ▁( ▁tmp _ field ▁-- ▁) ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁tmp _ field ▁== ▁last _ field ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 53 ▁) ▁" Request header field name w ase mpty " ▁) ▁; ▁return ▁; ▁} ▁} ▁else ▁{ ▁value ▁= ▁( ▁char ▁* ▁) ▁ap _ scan _ http _ token ▁( ▁last _ field ▁) ▁; ▁if ▁( ▁( ▁value ▁== ▁last _ field ▁) ▁|| ▁* ▁value ▁!= ▁' ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 24 26 ▁) ▁" Request header field name ism alformed :" ▁"%.* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁* ▁value ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁while ▁( ▁* ▁value ▁== ▁' ▁' ▁|| ▁* ▁value ▁== ▁' ▁\ t ▁' ▁) ▁{ ▁++ ▁value ▁; ▁} ▁tmp _ field ▁= ▁( ▁char ▁* ▁) ▁ap _ scan _ http _ field _ content ▁( ▁value ▁) ▁; ▁if ▁( ▁* ▁tmp _ field ▁!= ▁' ▁\0 ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 24 27 ▁) ▁" Request header value ism alformed :" ▁"%.* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁value ▁) ▁; ▁return ▁; ▁} ▁} ▁apr _ table _ add n ▁( ▁r ▁-> ▁headers _ in ▁, ▁last _ field ▁, ▁value ▁) ▁; ▁} ▁if ▁( ▁len ▁== ▁0 ▁) ▁{ ▁break ▁; ▁} ▁alloc _ len ▁= ▁0 ▁; ▁last _ field ▁= ▁field ▁; ▁last _ len ▁= ▁len ▁; ▁} ▁apr _ table _ compress ▁( ▁r ▁-> ▁headers _ in ▁, ▁APR _ OVER LAP _ TABLES _ MERGE ▁) ▁; ▁apr _ table _ do ▁( ▁table _ do _ fn _ check _ length s ▁, ▁r ▁, ▁r ▁-> ▁headers _ in ▁, ▁NULL ▁) ▁; ▁}	1
▁static ▁int ▁ast _ write _ trail er ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁AST Mux Context ▁* ▁ast ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVCodecContext ▁* ▁enc ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁; ▁int 64_ t ▁file _ size ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁int 64_ t ▁samples ▁= ▁( ▁file _ size ▁- ▁64 ▁- ▁( ▁32 ▁* ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁nb _ frames ▁) ▁) ▁/ ▁enc ▁-> ▁block _ align ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" total samples :% " ▁PRId 64 ▁"\ n " ▁, ▁samples ▁) ▁; ▁if ▁( ▁s ▁-> ▁pb ▁-> ▁seek able ▁) ▁{ ▁avio _ seek ▁( ▁pb ▁, ▁ast ▁-> ▁samples ▁, ▁SEEK _ SET ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁samples ▁) ▁; ▁if ▁( ▁ast ▁-> ▁loop start ▁> ▁0 ▁) ▁{ ▁if ▁( ▁ast ▁-> ▁loop start ▁>= ▁samples ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Loop start value is out of range and will be ignored \ n " ▁) ▁; ▁ast ▁-> ▁loop start ▁= ▁-1 ▁; ▁avio _ skip ▁( ▁pb ▁, ▁4 ▁) ▁; ▁} ▁else ▁avio _ wb 32 ▁( ▁pb ▁, ▁ast ▁-> ▁loop start ▁) ▁; ▁} ▁else ▁avio _ skip ▁( ▁pb ▁, ▁4 ▁) ▁; ▁if ▁( ▁ast ▁-> ▁loop end ▁&& ▁ast ▁-> ▁loop start ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁ast ▁-> ▁loop end ▁> ▁samples ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Loop end value is out of range and will be ignored \ n " ▁) ▁; ▁ast ▁-> ▁loop end ▁= ▁samples ▁; ▁} ▁avio _ wb 32 ▁( ▁pb ▁, ▁ast ▁-> ▁loop end ▁) ▁; ▁} ▁else ▁{ ▁avio _ wb 32 ▁( ▁pb ▁, ▁samples ▁) ▁; ▁} ▁avio _ wb 32 ▁( ▁pb ▁, ▁ast ▁-> ▁fb s ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁ast ▁-> ▁size ▁, ▁SEEK _ SET ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁file _ size ▁- ▁64 ▁) ▁; ▁if ▁( ▁ast ▁-> ▁loop start ▁>= ▁0 ▁) ▁{ ▁avio _ skip ▁( ▁pb ▁, ▁6 ▁) ▁; ▁avio _ wb 16 ▁( ▁pb ▁, ▁0 xFFFF ▁) ▁; ▁} ▁avio _ seek ▁( ▁pb ▁, ▁file _ size ▁, ▁SEEK _ SET ▁) ▁; ▁avio _ flush ▁( ▁pb ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁expand ▁( ▁L HASH ▁* ▁lh ▁) ▁{ ▁L HASH _ NODE ▁* ▁* ▁n ▁, ▁* ▁* ▁n 1 ▁, ▁* ▁* ▁n 2 ▁, ▁* ▁np ▁; ▁unsigned ▁int ▁p ▁, ▁i ▁, ▁j ▁; ▁unsigned ▁long ▁hash ▁, ▁n ni ▁; ▁lh ▁-> ▁num _ nodes ▁++ ▁; ▁lh ▁-> ▁num _ expand s ▁++ ▁; ▁p ▁= ▁( ▁int ▁) ▁lh ▁-> ▁p ▁++ ▁; ▁n 1 ▁= ▁& ▁( ▁lh ▁-> ▁b ▁[ ▁p ▁] ▁) ▁; ▁n 2 ▁= ▁& ▁( ▁lh ▁-> ▁b ▁[ ▁p ▁+ ▁( ▁int ▁) ▁lh ▁-> ▁p max ▁] ▁) ▁; ▁* ▁n 2 ▁= ▁NULL ▁; ▁n ni ▁= ▁lh ▁-> ▁num _ alloc _ nodes ▁; ▁for ▁( ▁np ▁= ▁* ▁n 1 ▁; ▁np ▁!= ▁NULL ▁; ▁) ▁{ ▁# ifndef ▁NO _ HASH _ COMP ▁hash ▁= ▁np ▁-> ▁hash ▁; ▁# else ▁hash ▁= ▁( ▁* ▁( ▁lh ▁-> ▁hash ▁) ▁) ▁( ▁np ▁-> ▁data ▁) ▁; ▁lh ▁-> ▁num _ hash _ calls ▁++ ▁; ▁# endif ▁if ▁( ▁( ▁hash ▁% ▁n ni ▁) ▁!= ▁p ▁) ▁{ ▁* ▁n 1 ▁= ▁( ▁* ▁n 1 ▁) ▁-> ▁next ▁; ▁np ▁-> ▁next ▁= ▁* ▁n 2 ▁; ▁* ▁n 2 ▁= ▁np ▁; ▁} ▁else ▁n 1 ▁= ▁& ▁( ▁( ▁* ▁n 1 ▁) ▁-> ▁next ▁) ▁; ▁np ▁= ▁* ▁n 1 ▁; ▁} ▁if ▁( ▁( ▁lh ▁-> ▁p ▁) ▁>= ▁lh ▁-> ▁p max ▁) ▁{ ▁j ▁= ▁( ▁int ▁) ▁lh ▁-> ▁num _ alloc _ nodes ▁* ▁2 ▁; ▁n ▁= ▁( ▁L HASH _ NODE ▁* ▁* ▁) ▁OPENSSL _ realloc ▁( ▁lh ▁-> ▁b ▁, ▁( ▁unsigned ▁int ▁) ▁sizeof ▁( ▁L HASH _ NODE ▁* ▁) ▁* ▁j ▁) ▁; ▁if ▁( ▁n ▁== ▁NULL ▁) ▁{ ▁lh ▁-> ▁error ▁++ ▁; ▁lh ▁-> ▁p ▁= ▁0 ▁; ▁return ▁; ▁} ▁for ▁( ▁i ▁= ▁( ▁int ▁) ▁lh ▁-> ▁num _ alloc _ nodes ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁n ▁[ ▁i ▁] ▁= ▁NULL ▁; ▁lh ▁-> ▁p max ▁= ▁lh ▁-> ▁num _ alloc _ nodes ▁; ▁lh ▁-> ▁num _ alloc _ nodes ▁= ▁j ▁; ▁lh ▁-> ▁num _ expand _ realloc s ▁++ ▁; ▁lh ▁-> ▁p ▁= ▁0 ▁; ▁lh ▁-> ▁b ▁= ▁n ▁; ▁} ▁}	1
▁ngx _ int _ t ▁ngx _ create _ temp _ file ▁( ▁ngx _ file _ t ▁* ▁file ▁, ▁ngx _ path _ t ▁* ▁path ▁, ▁ngx _ pool _ t ▁* ▁pool ▁, ▁ngx _ uint _ t ▁persistent ▁, ▁ngx _ uint _ t ▁clean ▁, ▁ngx _ uint _ t ▁access ▁) ▁{ ▁uint 32_ t ▁n ▁; ▁ngx _ err _ t ▁err ▁; ▁ngx _ pool _ cleanup _ t ▁* ▁cl n ▁; ▁ngx _ pool _ cleanup _ file _ t ▁* ▁cl nf ▁; ▁file ▁-> ▁name ▁. ▁len ▁= ▁path ▁-> ▁name ▁. ▁len ▁+ ▁1 ▁+ ▁path ▁-> ▁len ▁+ ▁10 ▁; ▁file ▁-> ▁name ▁. ▁data ▁= ▁ngx _ pn alloc ▁( ▁pool ▁, ▁file ▁-> ▁name ▁. ▁len ▁+ ▁1 ▁) ▁; ▁if ▁( ▁file ▁-> ▁name ▁. ▁data ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁# if ▁0 ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁file ▁-> ▁name ▁. ▁len ▁; ▁i ▁++ ▁) ▁{ ▁file ▁-> ▁name ▁. ▁data ▁[ ▁i ▁] ▁= ▁' ▁' ▁; ▁} ▁# endif ▁ngx _ memcpy ▁( ▁file ▁-> ▁name ▁. ▁data ▁, ▁path ▁-> ▁name ▁. ▁data ▁, ▁path ▁-> ▁name ▁. ▁len ▁) ▁; ▁n ▁= ▁( ▁uint 32_ t ▁) ▁ngx _ next _ temp _ number ▁( ▁0 ▁) ▁; ▁cl n ▁= ▁ngx _ pool _ cleanup _ add ▁( ▁pool ▁, ▁sizeof ▁( ▁ngx _ pool _ cleanup _ file _ t ▁) ▁) ▁; ▁if ▁( ▁cl n ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁for ▁( ▁; ▁; ▁) ▁{ ▁( ▁void ▁) ▁ngx _ sprintf ▁( ▁file ▁-> ▁name ▁. ▁data ▁+ ▁path ▁-> ▁name ▁. ▁len ▁+ ▁1 ▁+ ▁path ▁-> ▁len ▁, ▁"% 010 uD % Z " ▁, ▁n ▁) ▁; ▁ngx _ create _ hash ed _ filename ▁( ▁path ▁, ▁file ▁-> ▁name ▁. ▁data ▁, ▁file ▁-> ▁name ▁. ▁len ▁) ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ CORE ▁, ▁file ▁-> ▁log ▁, ▁0 ▁, ▁" hash ed path :% s " ▁, ▁file ▁-> ▁name ▁. ▁data ▁) ▁; ▁file ▁-> ▁fd ▁= ▁ngx _ open _ temp file ▁( ▁file ▁-> ▁name ▁. ▁data ▁, ▁persistent ▁, ▁access ▁) ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ CORE ▁, ▁file ▁-> ▁log ▁, ▁0 ▁, ▁" temp fd :% d " ▁, ▁file ▁-> ▁fd ▁) ▁; ▁if ▁( ▁file ▁-> ▁fd ▁!= ▁NGX _ INVALID _ FILE ▁) ▁{ ▁cl n ▁-> ▁handler ▁= ▁clean ▁? ▁ngx _ pool _ delete _ file ▁: ▁ngx _ pool _ cleanup _ file ▁; ▁cl nf ▁= ▁cl n ▁-> ▁data ▁; ▁cl nf ▁-> ▁fd ▁= ▁file ▁-> ▁fd ▁; ▁cl nf ▁-> ▁name ▁= ▁file ▁-> ▁name ▁. ▁data ▁; ▁cl nf ▁-> ▁log ▁= ▁pool ▁-> ▁log ▁; ▁return ▁NGX _ OK ▁; ▁} ▁err ▁= ▁ngx _ errno ▁; ▁if ▁( ▁err ▁== ▁NGX _ E EXIST ▁) ▁{ ▁n ▁= ▁( ▁uint 32_ t ▁) ▁ngx _ next _ temp _ number ▁( ▁1 ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁( ▁path ▁-> ▁level ▁[ ▁0 ▁] ▁== ▁0 ▁) ▁|| ▁( ▁err ▁!= ▁NGX _ EN OP ATH ▁) ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁file ▁-> ▁log ▁, ▁err ▁, ▁ngx _ open _ temp file _ n ▁"\"% s \" failed " ▁, ▁file ▁-> ▁name ▁. ▁data ▁) ▁; ▁return ▁NGX _ ERROR ▁; ▁} ▁if ▁( ▁ngx _ create _ path ▁( ▁file ▁, ▁path ▁) ▁== ▁NGX _ ERROR ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁} ▁}	1
▁int ▁av _ cold ▁ff _ iv i _ init _ tiles ▁( ▁IV IP lane Desc ▁* ▁planes ▁, ▁int ▁tile _ width ▁, ▁int ▁tile _ height ▁) ▁{ ▁int ▁p ▁, ▁b ▁, ▁x ▁, ▁y ▁, ▁x _ tiles ▁, ▁y _ tiles ▁, ▁t _ width ▁, ▁t _ height ▁; ▁IV IB and Desc ▁* ▁band ▁; ▁IV IT ile ▁* ▁tile ▁, ▁* ▁ref _ tile ▁; ▁for ▁( ▁p ▁= ▁0 ▁; ▁p ▁< ▁3 ▁; ▁p ▁++ ▁) ▁{ ▁t _ width ▁= ▁! ▁p ▁? ▁tile _ width ▁: ▁( ▁tile _ width ▁+ ▁3 ▁) ▁>> ▁2 ▁; ▁t _ height ▁= ▁! ▁p ▁? ▁tile _ height ▁: ▁( ▁tile _ height ▁+ ▁3 ▁) ▁>> ▁2 ▁; ▁if ▁( ▁! ▁p ▁&& ▁planes ▁[ ▁0 ▁] ▁. ▁num _ band s ▁== ▁4 ▁) ▁{ ▁t _ width ▁>>= ▁1 ▁; ▁t _ height ▁>>= ▁1 ▁; ▁} ▁if ▁( ▁t _ width ▁<= ▁0 ▁|| ▁t _ height ▁<= ▁0 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁< ▁planes ▁[ ▁p ▁] ▁. ▁num _ band s ▁; ▁b ▁++ ▁) ▁{ ▁band ▁= ▁& ▁planes ▁[ ▁p ▁] ▁. ▁bands ▁[ ▁b ▁] ▁; ▁x _ tiles ▁= ▁I VI _ NUM _ TI LES ▁( ▁band ▁-> ▁width ▁, ▁t _ width ▁) ▁; ▁y _ tiles ▁= ▁I VI _ NUM _ TI LES ▁( ▁band ▁-> ▁height ▁, ▁t _ height ▁) ▁; ▁band ▁-> ▁num _ tiles ▁= ▁x _ tiles ▁* ▁y _ tiles ▁; ▁av _ freep ▁( ▁& ▁band ▁-> ▁tiles ▁) ▁; ▁band ▁-> ▁tiles ▁= ▁av _ malloc z ▁( ▁band ▁-> ▁num _ tiles ▁* ▁sizeof ▁( ▁IV IT ile ▁) ▁) ▁; ▁if ▁( ▁! ▁band ▁-> ▁tiles ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁tile ▁= ▁band ▁-> ▁tiles ▁; ▁ref _ tile ▁= ▁planes ▁[ ▁0 ▁] ▁. ▁bands ▁[ ▁0 ▁] ▁. ▁tiles ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁band ▁-> ▁height ▁; ▁y ▁+= ▁t _ height ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁band ▁-> ▁width ▁; ▁x ▁+= ▁t _ width ▁) ▁{ ▁tile ▁-> ▁xpos ▁= ▁x ▁; ▁tile ▁-> ▁ypos ▁= ▁y ▁; ▁tile ▁-> ▁width ▁= ▁FF MIN ▁( ▁band ▁-> ▁width ▁- ▁x ▁, ▁t _ width ▁) ▁; ▁tile ▁-> ▁height ▁= ▁FF MIN ▁( ▁band ▁-> ▁height ▁- ▁y ▁, ▁t _ height ▁) ▁; ▁tile ▁-> ▁is _ empty ▁= ▁tile ▁-> ▁data _ size ▁= ▁0 ▁; ▁tile ▁-> ▁num _ MB s ▁= ▁I VI _ MB s _ PER _ TILE ▁( ▁tile ▁-> ▁width ▁, ▁tile ▁-> ▁height ▁, ▁band ▁-> ▁mb _ size ▁) ▁; ▁av _ freep ▁( ▁& ▁tile ▁-> ▁mbs ▁) ▁; ▁tile ▁-> ▁mbs ▁= ▁av _ malloc ▁( ▁tile ▁-> ▁num _ MB s ▁* ▁sizeof ▁( ▁IV IM b Info ▁) ▁) ▁; ▁if ▁( ▁! ▁tile ▁-> ▁mbs ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁tile ▁-> ▁ref _ mb s ▁= ▁0 ▁; ▁if ▁( ▁p ▁|| ▁b ▁) ▁{ ▁tile ▁-> ▁ref _ mb s ▁= ▁ref _ tile ▁-> ▁mbs ▁; ▁ref _ tile ▁++ ▁; ▁} ▁tile ▁++ ▁; ▁} ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁i 2 d _ X 509_ AUX ▁( ▁X 509 ▁* ▁a ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁) ▁{ ▁int ▁length ▁; ▁length ▁= ▁i 2 d _ X 509 ▁( ▁a ▁, ▁pp ▁) ▁; ▁if ▁( ▁a ▁) ▁length ▁+= ▁i 2 d _ X 509_ CERT _ AUX ▁( ▁a ▁-> ▁aux ▁, ▁pp ▁) ▁; ▁return ▁length ▁; ▁}	1
▁static ▁void ▁write _ request ▁( ▁struct ▁connection ▁* ▁c ▁) ▁{ ▁do ▁{ ▁apr _ time _ t ▁t now ▁= ▁apr _ time _ now ▁( ▁) ▁; ▁apr _ size _ t ▁l ▁= ▁c ▁-> ▁r write ▁; ▁apr _ status _ t ▁e ▁= ▁APR _ SUCCESS ▁; ▁if ▁( ▁c ▁-> ▁r write ▁== ▁0 ▁) ▁{ ▁apr _ socket _ timeout _ set ▁( ▁c ▁-> ▁apr sock ▁, ▁0 ▁) ▁; ▁c ▁-> ▁connect ▁= ▁t now ▁; ▁c ▁-> ▁r write ▁= ▁req len ▁; ▁c ▁-> ▁rw rote ▁= ▁0 ▁; ▁if ▁( ▁post ing ▁) ▁c ▁-> ▁r write ▁+= ▁post len ▁; ▁} ▁else ▁if ▁( ▁t now ▁> ▁c ▁-> ▁connect ▁+ ▁apr timeout ▁) ▁{ ▁printf ▁( ▁" Send request timed out !\ n " ▁) ▁; ▁close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁# ifdef ▁USE _ SSL ▁if ▁( ▁c ▁-> ▁ssl ▁) ▁{ ▁apr _ size _ t ▁e _ ssl ▁; ▁e _ ssl ▁= ▁SSL _ write ▁( ▁c ▁-> ▁ssl ▁, ▁request ▁+ ▁c ▁-> ▁rw rote ▁, ▁l ▁) ▁; ▁if ▁( ▁e _ ssl ▁!= ▁l ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" SSL write failed - closing connection \ n " ▁) ▁; ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁close _ connection ▁( ▁c ▁) ▁; ▁return ▁; ▁} ▁l ▁= ▁e _ ssl ▁; ▁e ▁= ▁APR _ SUCCESS ▁; ▁} ▁else ▁# endif ▁e ▁= ▁apr _ socket _ send ▁( ▁c ▁-> ▁apr sock ▁, ▁request ▁+ ▁c ▁-> ▁rw rote ▁, ▁& ▁l ▁) ▁; ▁if ▁( ▁l ▁== ▁c ▁-> ▁r write ▁) ▁break ▁; ▁if ▁( ▁e ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁if ▁( ▁! ▁APR _ STATUS _ IS _ E AGAIN ▁( ▁e ▁) ▁) ▁{ ▁e pipe ▁++ ▁; ▁printf ▁( ▁" Send request failed !\ n " ▁) ▁; ▁close _ connection ▁( ▁c ▁) ▁; ▁} ▁return ▁; ▁} ▁c ▁-> ▁rw rote ▁+= ▁l ▁; ▁c ▁-> ▁r write ▁-= ▁l ▁; ▁} ▁while ▁( ▁1 ▁) ▁; ▁total post ed ▁+= ▁c ▁-> ▁r write ▁; ▁c ▁-> ▁state ▁= ▁STATE _ READ ▁; ▁c ▁-> ▁end write ▁= ▁apr _ time _ now ▁( ▁) ▁; ▁{ ▁apr _ pol lfd _ t ▁new _ pol lfd ▁; ▁new _ pol lfd ▁. ▁desc _ type ▁= ▁APR _ POLL _ SOCKET ▁; ▁new _ pol lfd ▁. ▁req events ▁= ▁APR _ POLL IN ▁; ▁new _ pol lfd ▁. ▁desc ▁. ▁s ▁= ▁c ▁-> ▁apr sock ▁; ▁new _ pol lfd ▁. ▁client _ data ▁= ▁c ▁; ▁apr _ poll set _ add ▁( ▁read bits ▁, ▁& ▁new _ pol lfd ▁) ▁; ▁} ▁}	1
▁static ▁void ▁ctr _ df ▁( ▁DR BG _ CTR _ CTX ▁* ▁cctx ▁, ▁const ▁unsigned ▁char ▁* ▁in 1 ▁, ▁size _ t ▁in 1 len ▁, ▁const ▁unsigned ▁char ▁* ▁in 2 ▁, ▁size _ t ▁in 2 len ▁, ▁const ▁unsigned ▁char ▁* ▁in 3 ▁, ▁size _ t ▁in 3 len ▁) ▁{ ▁static ▁unsigned ▁char ▁c 80 ▁= ▁0 x 80 ▁; ▁size _ t ▁inlen ▁; ▁unsigned ▁char ▁* ▁p ▁= ▁cctx ▁-> ▁blt mp ▁; ▁ctr _ B CC _ init ▁( ▁cctx ▁) ▁; ▁if ▁( ▁in 1 ▁== ▁NULL ▁) ▁in 1 len ▁= ▁0 ▁; ▁if ▁( ▁in 2 ▁== ▁NULL ▁) ▁in 2 len ▁= ▁0 ▁; ▁if ▁( ▁in 3 ▁== ▁NULL ▁) ▁in 3 len ▁= ▁0 ▁; ▁inlen ▁= ▁in 1 len ▁+ ▁in 2 len ▁+ ▁in 3 len ▁; ▁* ▁p ▁++ ▁= ▁( ▁inlen ▁>> ▁24 ▁) ▁& ▁0 xff ▁; ▁* ▁p ▁++ ▁= ▁( ▁inlen ▁>> ▁16 ▁) ▁& ▁0 xff ▁; ▁* ▁p ▁++ ▁= ▁( ▁inlen ▁>> ▁8 ▁) ▁& ▁0 xff ▁; ▁* ▁p ▁++ ▁= ▁inlen ▁& ▁0 xff ▁; ▁* ▁p ▁++ ▁= ▁0 ▁; ▁* ▁p ▁++ ▁= ▁0 ▁; ▁* ▁p ▁++ ▁= ▁0 ▁; ▁* ▁p ▁= ▁( ▁unsigned ▁char ▁) ▁( ▁( ▁cctx ▁-> ▁keylen ▁+ ▁16 ▁) ▁& ▁0 xff ▁) ▁; ▁cctx ▁-> ▁blt mp _ pos ▁= ▁8 ▁; ▁ctr _ B CC _ update ▁( ▁cctx ▁, ▁in 1 ▁, ▁in 1 len ▁) ▁; ▁ctr _ B CC _ update ▁( ▁cctx ▁, ▁in 2 ▁, ▁in 2 len ▁) ▁; ▁ctr _ B CC _ update ▁( ▁cctx ▁, ▁in 3 ▁, ▁in 3 len ▁) ▁; ▁ctr _ B CC _ update ▁( ▁cctx ▁, ▁& ▁c 80 ▁, ▁1 ▁) ▁; ▁ctr _ B CC _ final ▁( ▁cctx ▁) ▁; ▁AES _ set _ encrypt _ key ▁( ▁cctx ▁-> ▁K X ▁, ▁cctx ▁-> ▁keylen ▁* ▁8 ▁, ▁& ▁cctx ▁-> ▁df _ k x ks ▁) ▁; ▁AES _ encrypt ▁( ▁cctx ▁-> ▁K X ▁+ ▁cctx ▁-> ▁keylen ▁, ▁cctx ▁-> ▁K X ▁, ▁& ▁cctx ▁-> ▁df _ k x ks ▁) ▁; ▁AES _ encrypt ▁( ▁cctx ▁-> ▁K X ▁, ▁cctx ▁-> ▁K X ▁+ ▁16 ▁, ▁& ▁cctx ▁-> ▁df _ k x ks ▁) ▁; ▁if ▁( ▁cctx ▁-> ▁keylen ▁!= ▁16 ▁) ▁AES _ encrypt ▁( ▁cctx ▁-> ▁K X ▁+ ▁16 ▁, ▁cctx ▁-> ▁K X ▁+ ▁32 ▁, ▁& ▁cctx ▁-> ▁df _ k x ks ▁) ▁; ▁}	1
▁static ▁ASN 1_ INTEGER ▁* ▁x 509_ load _ serial ▁( ▁char ▁* ▁CA file ▁, ▁char ▁* ▁serial file ▁, ▁int ▁create ▁) ▁{ ▁char ▁* ▁buf ▁= ▁NULL ▁, ▁* ▁p ▁; ▁ASN 1_ INTEGER ▁* ▁bs ▁= ▁NULL ▁; ▁BIGNUM ▁* ▁serial ▁= ▁NULL ▁; ▁buf ▁= ▁OPENSSL _ malloc ▁( ▁( ▁( ▁serial file ▁== ▁NULL ▁) ▁? ▁( ▁strlen ▁( ▁CA file ▁) ▁+ ▁strlen ▁( ▁POST FIX ▁) ▁+ ▁1 ▁) ▁: ▁( ▁strlen ▁( ▁serial file ▁) ▁) ▁) ▁+ ▁1 ▁) ▁; ▁if ▁( ▁buf ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" out of mem \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁serial file ▁== ▁NULL ▁) ▁{ ▁strcpy ▁( ▁buf ▁, ▁CA file ▁) ▁; ▁for ▁( ▁p ▁= ▁buf ▁; ▁* ▁p ▁; ▁p ▁++ ▁) ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁) ▁{ ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁break ▁; ▁} ▁strcat ▁( ▁buf ▁, ▁POST FIX ▁) ▁; ▁} ▁else ▁strcpy ▁( ▁buf ▁, ▁serial file ▁) ▁; ▁serial ▁= ▁load _ serial ▁( ▁buf ▁, ▁create ▁, ▁NULL ▁) ▁; ▁if ▁( ▁serial ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁if ▁( ▁! ▁BN _ add _ word ▁( ▁serial ▁, ▁1 ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" add _ word failure \ n " ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁save _ serial ▁( ▁buf ▁, ▁NULL ▁, ▁serial ▁, ▁& ▁bs ▁) ▁) ▁goto ▁end ▁; ▁end ▁: ▁if ▁( ▁buf ▁) ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁BN _ free ▁( ▁serial ▁) ▁; ▁return ▁bs ▁; ▁}	1
▁static ▁int ▁handle _ packet ▁( ▁Mpeg TS Context ▁* ▁ts ▁, ▁const ▁uint 8_ t ▁* ▁packet ▁) ▁{ ▁AVFormatContext ▁* ▁s ▁= ▁ts ▁-> ▁stream ▁; ▁Mpeg TS Filter ▁* ▁tss ▁; ▁int ▁len ▁, ▁pid ▁, ▁cc ▁, ▁expected _ cc ▁, ▁cc _ ok ▁, ▁a fc ▁, ▁is _ start ▁, ▁is _ dis contin uity ▁, ▁has _ adapt ation ▁, ▁has _ payload ▁; ▁const ▁uint 8_ t ▁* ▁p ▁, ▁* ▁p _ end ▁; ▁int 64_ t ▁pos ▁; ▁pid ▁= ▁AV _ RB 16 ▁( ▁packet ▁+ ▁1 ▁) ▁& ▁0 x 1 fff ▁; ▁if ▁( ▁pid ▁&& ▁discard _ pid ▁( ▁ts ▁, ▁pid ▁) ▁) ▁return ▁0 ▁; ▁is _ start ▁= ▁packet ▁[ ▁1 ▁] ▁& ▁0 x 40 ▁; ▁tss ▁= ▁ts ▁-> ▁pids ▁[ ▁pid ▁] ▁; ▁if ▁( ▁ts ▁-> ▁auto _ guess ▁&& ▁tss ▁== ▁NULL ▁&& ▁is _ start ▁) ▁{ ▁add _ pes _ stream ▁( ▁ts ▁, ▁pid ▁, ▁-1 ▁) ▁; ▁tss ▁= ▁ts ▁-> ▁pids ▁[ ▁pid ▁] ▁; ▁} ▁if ▁( ▁! ▁tss ▁) ▁return ▁0 ▁; ▁a fc ▁= ▁( ▁packet ▁[ ▁3 ▁] ▁>> ▁4 ▁) ▁& ▁3 ▁; ▁if ▁( ▁a fc ▁== ▁0 ▁) ▁return ▁0 ▁; ▁has _ adapt ation ▁= ▁a fc ▁& ▁2 ▁; ▁has _ payload ▁= ▁a fc ▁& ▁1 ▁; ▁is _ dis contin uity ▁= ▁has _ adapt ation ▁&& ▁packet ▁[ ▁4 ▁] ▁!= ▁0 ▁&& ▁( ▁packet ▁[ ▁5 ▁] ▁& ▁0 x 80 ▁) ▁; ▁cc ▁= ▁( ▁packet ▁[ ▁3 ▁] ▁& ▁0 xf ▁) ▁; ▁expected _ cc ▁= ▁has _ payload ▁? ▁( ▁tss ▁-> ▁last _ cc ▁+ ▁1 ▁) ▁& ▁0 x 0 f ▁: ▁tss ▁-> ▁last _ cc ▁; ▁cc _ ok ▁= ▁pid ▁== ▁0 x 1 FFF ▁|| ▁is _ dis contin uity ▁|| ▁tss ▁-> ▁last _ cc ▁< ▁0 ▁|| ▁expected _ cc ▁== ▁cc ▁; ▁tss ▁-> ▁last _ cc ▁= ▁cc ▁; ▁if ▁( ▁! ▁cc _ ok ▁) ▁{ ▁av _ log ▁( ▁ts ▁-> ▁stream ▁, ▁AV _ LOG _ WARNING ▁, ▁" Contin uity check failed f orp id % dex pected % dg ot % d \ n " ▁, ▁pid ▁, ▁expected _ cc ▁, ▁cc ▁) ▁; ▁if ▁( ▁tss ▁-> ▁type ▁== ▁M PEG TS _ P ES ▁) ▁{ ▁P ES Context ▁* ▁pc ▁= ▁tss ▁-> ▁u ▁. ▁p es _ filter ▁. ▁opaque ▁; ▁pc ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ COR RUP T ▁; ▁} ▁} ▁if ▁( ▁! ▁has _ payload ▁) ▁return ▁0 ▁; ▁p ▁= ▁packet ▁+ ▁4 ▁; ▁if ▁( ▁has _ adapt ation ▁) ▁{ ▁p ▁+= ▁p ▁[ ▁0 ▁] ▁+ ▁1 ▁; ▁} ▁p _ end ▁= ▁packet ▁+ ▁TS _ PACKET _ SIZE ▁; ▁if ▁( ▁p ▁>= ▁p _ end ▁) ▁return ▁0 ▁; ▁pos ▁= ▁avio _ tell ▁( ▁ts ▁-> ▁stream ▁-> ▁pb ▁) ▁; ▁ts ▁-> ▁pos 47 ▁= ▁pos ▁% ▁ts ▁-> ▁raw _ packet _ size ▁; ▁if ▁( ▁tss ▁-> ▁type ▁== ▁M PEG TS _ SECTION ▁) ▁{ ▁if ▁( ▁is _ start ▁) ▁{ ▁len ▁= ▁* ▁p ▁++ ▁; ▁if ▁( ▁p ▁+ ▁len ▁> ▁p _ end ▁) ▁return ▁0 ▁; ▁if ▁( ▁len ▁&& ▁cc _ ok ▁) ▁{ ▁write _ section _ data ▁( ▁s ▁, ▁tss ▁, ▁p ▁, ▁len ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁ts ▁-> ▁pids ▁[ ▁pid ▁] ▁) ▁return ▁0 ▁; ▁} ▁p ▁+= ▁len ▁; ▁if ▁( ▁p ▁< ▁p _ end ▁) ▁{ ▁write _ section _ data ▁( ▁s ▁, ▁tss ▁, ▁p ▁, ▁p _ end ▁- ▁p ▁, ▁1 ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁cc _ ok ▁) ▁{ ▁write _ section _ data ▁( ▁s ▁, ▁tss ▁, ▁p ▁, ▁p _ end ▁- ▁p ▁, ▁0 ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁int ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁tss ▁-> ▁u ▁. ▁p es _ filter ▁. ▁p es _ cb ▁( ▁tss ▁, ▁p ▁, ▁p _ end ▁- ▁p ▁, ▁is _ start ▁, ▁pos ▁- ▁ts ▁-> ▁raw _ packet _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁mov _ write _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁MOV Context ▁* ▁mov ▁= ▁s ▁-> ▁priv _ data ▁; ▁Byte IO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁MOV Track ▁* ▁tr k ▁= ▁& ▁mov ▁-> ▁tracks ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁; ▁AVCodecContext ▁* ▁enc ▁= ▁tr k ▁-> ▁enc ▁; ▁unsigned ▁int ▁samples In Chunk ▁= ▁0 ▁; ▁int ▁size ▁= ▁pkt ▁-> ▁size ▁; ▁if ▁( ▁url _ is _ stream ed ▁( ▁s ▁-> ▁pb ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁size ▁) ▁return ▁0 ▁; ▁if ▁( ▁enc ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ AM R _ NB ▁) ▁{ ▁static ▁uint 16_ t ▁packed _ size ▁[ ▁16 ▁] ▁= ▁{ ▁13 ▁, ▁14 ▁, ▁16 ▁, ▁18 ▁, ▁20 ▁, ▁21 ▁, ▁27 ▁, ▁32 ▁, ▁6 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁int ▁len ▁= ▁0 ▁; ▁while ▁( ▁len ▁< ▁size ▁&& ▁samples In Chunk ▁< ▁100 ▁) ▁{ ▁len ▁+= ▁packed _ size ▁[ ▁( ▁pkt ▁-> ▁data ▁[ ▁len ▁] ▁>> ▁3 ▁) ▁& ▁0 x 0 F ▁] ▁; ▁samples In Chunk ▁++ ▁; ▁} ▁if ▁( ▁samples In Chunk ▁> ▁1 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" fatal error , input is not as ingle packet , implement a AV Parser for it \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁} ▁else ▁if ▁( ▁tr k ▁-> ▁sample Size ▁) ▁samples In Chunk ▁= ▁size ▁/ ▁tr k ▁-> ▁sample Size ▁; ▁else ▁samples In Chunk ▁= ▁1 ▁; ▁if ▁( ▁tr k ▁-> ▁vo s Len ▁== ▁0 ▁&& ▁enc ▁-> ▁extradata _ size ▁> ▁0 ▁) ▁{ ▁tr k ▁-> ▁vo s Len ▁= ▁enc ▁-> ▁extradata _ size ▁; ▁tr k ▁-> ▁vo s Data ▁= ▁av _ malloc ▁( ▁tr k ▁-> ▁vo s Len ▁) ▁; ▁memcpy ▁( ▁tr k ▁-> ▁vo s Data ▁, ▁enc ▁-> ▁extradata ▁, ▁tr k ▁-> ▁vo s Len ▁) ▁; ▁} ▁if ▁( ▁enc ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ H 264 ▁&& ▁tr k ▁-> ▁vo s Len ▁> ▁0 ▁&& ▁* ▁( ▁uint 8_ t ▁* ▁) ▁tr k ▁-> ▁vo s Data ▁!= ▁1 ▁) ▁{ ▁int ▁ret ▁= ▁ff _ avc _ parse _ n al _ units ▁( ▁pkt ▁-> ▁data ▁, ▁& ▁pkt ▁-> ▁data ▁, ▁& ▁pkt ▁-> ▁size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁assert ▁( ▁pkt ▁-> ▁size ▁) ▁; ▁size ▁= ▁pkt ▁-> ▁size ▁; ▁} ▁else ▁if ▁( ▁enc ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ DN X HD ▁&& ▁! ▁tr k ▁-> ▁vo s Len ▁) ▁{ ▁if ▁( ▁size ▁< ▁640 ▁) ▁return ▁-1 ▁; ▁tr k ▁-> ▁vo s Len ▁= ▁640 ▁; ▁tr k ▁-> ▁vo s Data ▁= ▁av _ malloc ▁( ▁tr k ▁-> ▁vo s Len ▁) ▁; ▁memcpy ▁( ▁tr k ▁-> ▁vo s Data ▁, ▁pkt ▁-> ▁data ▁, ▁640 ▁) ▁; ▁} ▁if ▁( ▁! ▁( ▁tr k ▁-> ▁entry ▁% ▁MOV _ INDEX _ CLUSTER _ SIZE ▁) ▁) ▁{ ▁tr k ▁-> ▁cluster ▁= ▁av _ realloc ▁( ▁tr k ▁-> ▁cluster ▁, ▁( ▁tr k ▁-> ▁entry ▁+ ▁MOV _ INDEX _ CLUSTER _ SIZE ▁) ▁* ▁sizeof ▁( ▁* ▁tr k ▁-> ▁cluster ▁) ▁) ▁; ▁if ▁( ▁! ▁tr k ▁-> ▁cluster ▁) ▁return ▁-1 ▁; ▁} ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁pos ▁= ▁url _ f tell ▁( ▁pb ▁) ▁; ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁samples In Chunk ▁= ▁samples In Chunk ▁; ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁size ▁= ▁size ▁; ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁entries ▁= ▁samples In Chunk ▁; ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁dts ▁= ▁pkt ▁-> ▁dts ▁; ▁tr k ▁-> ▁track Duration ▁= ▁pkt ▁-> ▁dts ▁- ▁tr k ▁-> ▁cluster ▁[ ▁0 ▁] ▁. ▁dts ▁+ ▁pkt ▁-> ▁duration ▁; ▁if ▁( ▁pkt ▁-> ▁dts ▁!= ▁pkt ▁-> ▁pts ▁) ▁tr k ▁-> ▁has B frames ▁= ▁1 ▁; ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁cts ▁= ▁pkt ▁-> ▁pts ▁- ▁pkt ▁-> ▁dts ▁; ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁key _ frame ▁= ▁! ▁! ▁( ▁pkt ▁-> ▁flags ▁& ▁PK T _ FLAG _ KEY ▁) ▁; ▁if ▁( ▁tr k ▁-> ▁cluster ▁[ ▁tr k ▁-> ▁entry ▁] ▁. ▁key _ frame ▁) ▁tr k ▁-> ▁has Key frames ▁++ ▁; ▁tr k ▁-> ▁entry ▁++ ▁; ▁tr k ▁-> ▁sample Count ▁+= ▁samples In Chunk ▁; ▁mov ▁-> ▁md at _ size ▁+= ▁size ▁; ▁put _ buffer ▁( ▁pb ▁, ▁pkt ▁-> ▁data ▁, ▁size ▁) ▁; ▁put _ flush _ packet ▁( ▁pb ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁char ▁* ▁BN _ bn 2 dec ▁( ▁const ▁BIGNUM ▁* ▁a ▁) ▁{ ▁int ▁i ▁= ▁0 ▁, ▁num ▁, ▁ok ▁= ▁0 ▁; ▁char ▁* ▁buf ▁= ▁NULL ▁; ▁char ▁* ▁p ▁; ▁BIGNUM ▁* ▁t ▁= ▁NULL ▁; ▁BN _ ULONG ▁* ▁bn _ data ▁= ▁NULL ▁, ▁* ▁lp ▁; ▁int ▁bn _ data _ num ▁; ▁i ▁= ▁BN _ num _ bits ▁( ▁a ▁) ▁* ▁3 ▁; ▁num ▁= ▁( ▁i ▁/ ▁10 ▁+ ▁i ▁/ ▁1000 ▁+ ▁1 ▁) ▁+ ▁1 ▁; ▁bn _ data _ num ▁= ▁num ▁/ ▁BN _ DEC _ NUM ▁+ ▁1 ▁; ▁bn _ data ▁= ▁OPENSSL _ malloc ▁( ▁bn _ data _ num ▁* ▁sizeof ▁( ▁BN _ ULONG ▁) ▁) ▁; ▁buf ▁= ▁OPENSSL _ malloc ▁( ▁num ▁+ ▁3 ▁) ▁; ▁if ▁( ▁( ▁buf ▁== ▁NULL ▁) ▁|| ▁( ▁bn _ data ▁== ▁NULL ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ BN 2 DEC ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁t ▁= ▁BN _ dup ▁( ▁a ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁p ▁= ▁buf ▁; ▁lp ▁= ▁bn _ data ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁t ▁) ▁) ▁{ ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁\0 ▁' ▁; ▁} ▁else ▁{ ▁if ▁( ▁BN _ is _ negative ▁( ▁t ▁) ▁) ▁* ▁p ▁++ ▁= ▁' ▁' ▁; ▁while ▁( ▁! ▁BN _ is _ zero ▁( ▁t ▁) ▁) ▁{ ▁if ▁( ▁lp ▁- ▁bn _ data ▁>= ▁bn _ data _ num ▁) ▁goto ▁err ▁; ▁* ▁lp ▁= ▁BN _ div _ word ▁( ▁t ▁, ▁BN _ DEC _ CONV ▁) ▁; ▁if ▁( ▁* ▁lp ▁== ▁( ▁BN _ ULONG ▁) ▁- ▁1 ▁) ▁goto ▁err ▁; ▁lp ▁++ ▁; ▁} ▁lp ▁-- ▁; ▁sprintf ▁( ▁p ▁, ▁BN _ DEC _ FMT 1 ▁, ▁* ▁lp ▁) ▁; ▁while ▁( ▁* ▁p ▁) ▁p ▁++ ▁; ▁while ▁( ▁lp ▁!= ▁bn _ data ▁) ▁{ ▁lp ▁-- ▁; ▁sprintf ▁( ▁p ▁, ▁BN _ DEC _ FMT 2 ▁, ▁* ▁lp ▁) ▁; ▁while ▁( ▁* ▁p ▁) ▁p ▁++ ▁; ▁} ▁} ▁ok ▁= ▁1 ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁bn _ data ▁) ▁; ▁BN _ free ▁( ▁t ▁) ▁; ▁if ▁( ▁ok ▁) ▁return ▁buf ▁; ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁H 264 Context ▁* ▁h ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁pict ▁= ▁data ▁; ▁int ▁buf _ index ▁= ▁0 ▁; ▁Picture ▁* ▁out ▁; ▁int ▁i ▁, ▁out _ idx ▁; ▁int ▁ret ▁; ▁h ▁-> ▁flags ▁= ▁avctx ▁-> ▁flags ▁; ▁if ▁( ▁buf _ size ▁== ▁0 ▁) ▁{ ▁out ▁: ▁h ▁-> ▁cur _ pic _ ptr ▁= ▁NULL ▁; ▁h ▁-> ▁first _ field ▁= ▁0 ▁; ▁out ▁= ▁h ▁-> ▁delayed _ pic ▁[ ▁0 ▁] ▁; ▁out _ idx ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁] ▁&& ▁! ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁] ▁-> ▁f ▁. ▁key _ frame ▁&& ▁! ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁] ▁-> ▁mm co _ reset ▁; ▁i ▁++ ▁) ▁if ▁( ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁] ▁-> ▁p oc ▁< ▁out ▁-> ▁p oc ▁) ▁{ ▁out ▁= ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁] ▁; ▁out _ idx ▁= ▁i ▁; ▁} ▁for ▁( ▁i ▁= ▁out _ idx ▁; ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁] ▁= ▁h ▁-> ▁delayed _ pic ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁if ▁( ▁out ▁) ▁{ ▁out ▁-> ▁reference ▁&= ▁ ~ ▁DELAY ED _ PIC _ REF ▁; ▁ret ▁= ▁output _ frame ▁( ▁h ▁, ▁pict ▁, ▁out ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁got _ frame ▁= ▁1 ▁; ▁} ▁return ▁buf _ index ▁; ▁} ▁if ▁( ▁h ▁-> ▁is _ avc ▁&& ▁buf _ size ▁>= ▁9 ▁&& ▁buf ▁[ ▁0 ▁] ▁== ▁1 ▁&& ▁buf ▁[ ▁2 ▁] ▁== ▁0 ▁&& ▁( ▁buf ▁[ ▁4 ▁] ▁& ▁0 xFC ▁) ▁== ▁0 xFC ▁&& ▁( ▁buf ▁[ ▁5 ▁] ▁& ▁0 x 1 F ▁) ▁&& ▁buf ▁[ ▁8 ▁] ▁== ▁0 x 67 ▁) ▁{ ▁int ▁cnt ▁= ▁buf ▁[ ▁5 ▁] ▁& ▁0 x 1 f ▁; ▁const ▁uint 8_ t ▁* ▁p ▁= ▁buf ▁+ ▁6 ▁; ▁while ▁( ▁cnt ▁-- ▁) ▁{ ▁int ▁nal size ▁= ▁AV _ RB 16 ▁( ▁p ▁) ▁+ ▁2 ▁; ▁if ▁( ▁nal size ▁> ▁buf _ size ▁- ▁( ▁p ▁- ▁buf ▁) ▁|| ▁p ▁[ ▁2 ▁] ▁!= ▁0 x 67 ▁) ▁goto ▁not _ extra ▁; ▁p ▁+= ▁nal size ▁; ▁} ▁cnt ▁= ▁* ▁( ▁p ▁++ ▁) ▁; ▁if ▁( ▁! ▁cnt ▁) ▁goto ▁not _ extra ▁; ▁while ▁( ▁cnt ▁-- ▁) ▁{ ▁int ▁nal size ▁= ▁AV _ RB 16 ▁( ▁p ▁) ▁+ ▁2 ▁; ▁if ▁( ▁nal size ▁> ▁buf _ size ▁- ▁( ▁p ▁- ▁buf ▁) ▁|| ▁p ▁[ ▁2 ▁] ▁!= ▁0 x 68 ▁) ▁goto ▁not _ extra ▁; ▁p ▁+= ▁nal size ▁; ▁} ▁return ▁ff _ h 264_ decode _ extr adata ▁( ▁h ▁, ▁buf ▁, ▁buf _ size ▁) ▁; ▁} ▁not _ extra ▁: ▁buf _ index ▁= ▁decode _ n al _ units ▁( ▁h ▁, ▁buf ▁, ▁buf _ size ▁, ▁0 ▁) ▁; ▁if ▁( ▁buf _ index ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁if ▁( ▁! ▁h ▁-> ▁cur _ pic _ ptr ▁&& ▁h ▁-> ▁nal _ unit _ type ▁== ▁N AL _ END _ SEQUENCE ▁) ▁{ ▁av _ assert 0 ▁( ▁buf _ index ▁<= ▁buf _ size ▁) ▁; ▁goto ▁out ▁; ▁} ▁if ▁( ▁! ▁( ▁avctx ▁-> ▁flags 2 ▁& ▁CODEC _ FLAG 2_ CHUNK S ▁) ▁&& ▁! ▁h ▁-> ▁cur _ pic _ ptr ▁) ▁{ ▁if ▁( ▁avctx ▁-> ▁skip _ frame ▁>= ▁AV DISCARD _ NON REF ▁|| ▁buf _ size ▁>= ▁4 ▁&& ▁! ▁memcmp ▁( ▁" Q 2 64" ▁, ▁buf ▁, ▁4 ▁) ▁) ▁return ▁buf _ size ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" nof rame !\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁! ▁( ▁avctx ▁-> ▁flags 2 ▁& ▁CODEC _ FLAG 2_ CHUNK S ▁) ▁|| ▁( ▁h ▁-> ▁mb _ y ▁>= ▁h ▁-> ▁mb _ height ▁&& ▁h ▁-> ▁mb _ height ▁) ▁) ▁{ ▁if ▁( ▁avctx ▁-> ▁flags 2 ▁& ▁CODEC _ FLAG 2_ CHUNK S ▁) ▁decode _ post init ▁( ▁h ▁, ▁1 ▁) ▁; ▁field _ end ▁( ▁h ▁, ▁0 ▁) ▁; ▁* ▁got _ frame ▁= ▁0 ▁; ▁if ▁( ▁h ▁-> ▁next _ output _ pic ▁&& ▁( ▁h ▁-> ▁next _ output _ pic ▁-> ▁sync ▁|| ▁h ▁-> ▁sync ▁> ▁1 ▁) ▁) ▁{ ▁ret ▁= ▁output _ frame ▁( ▁h ▁, ▁pict ▁, ▁h ▁-> ▁next _ output _ pic ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁* ▁got _ frame ▁= ▁1 ▁; ▁if ▁( ▁CONFIG _ MPEG VIDEO ▁) ▁{ ▁ff _ print _ debug _ info 2 ▁( ▁h ▁-> ▁avctx ▁, ▁h ▁-> ▁next _ output _ pic ▁, ▁pict ▁, ▁h ▁-> ▁er ▁. ▁mb skip _ table ▁, ▁& ▁h ▁-> ▁low _ delay ▁, ▁h ▁-> ▁mb _ width ▁, ▁h ▁-> ▁mb _ height ▁, ▁h ▁-> ▁mb _ stride ▁, ▁1 ▁) ▁; ▁} ▁} ▁} ▁assert ▁( ▁pict ▁-> ▁data ▁[ ▁0 ▁] ▁|| ▁! ▁* ▁got _ frame ▁) ▁; ▁return ▁get _ consumed _ bytes ▁( ▁buf _ index ▁, ▁buf _ size ▁) ▁; ▁}	0
▁static ▁int ▁wm av oice _ decode _ packet ▁( ▁AVCodecContext ▁* ▁ctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame _ ptr ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁W MA Voice Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv _ data ▁; ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁gb ▁; ▁int ▁size ▁, ▁res ▁, ▁pos ▁; ▁for ▁( ▁size ▁= ▁avpkt ▁-> ▁size ▁; ▁size ▁> ▁ctx ▁-> ▁block _ align ▁; ▁size ▁-= ▁ctx ▁-> ▁block _ align ▁) ▁; ▁if ▁( ▁! ▁size ▁) ▁{ ▁* ▁got _ frame _ ptr ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁init _ get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁avpkt ▁-> ▁data ▁, ▁size ▁<< ▁3 ▁) ▁; ▁if ▁( ▁size ▁== ▁ctx ▁-> ▁block _ align ▁) ▁{ ▁if ▁( ▁( ▁res ▁= ▁parse _ packet _ header ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁res ▁; ▁if ▁( ▁s ▁-> ▁sp illo ver _ n bits ▁> ▁0 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁sf rame _ cache _ size ▁> ▁0 ▁) ▁{ ▁int ▁cnt ▁= ▁get _ bits _ count ▁( ▁gb ▁) ▁; ▁copy _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁avpkt ▁-> ▁data ▁, ▁size ▁, ▁gb ▁, ▁s ▁-> ▁sp illo ver _ n bits ▁) ▁; ▁flush _ put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁) ▁; ▁s ▁-> ▁sf rame _ cache _ size ▁+= ▁s ▁-> ▁sp illo ver _ n bits ▁; ▁if ▁( ▁( ▁res ▁= ▁synth _ super frame ▁( ▁ctx ▁, ▁data ▁, ▁got _ frame _ ptr ▁) ▁) ▁== ▁0 ▁&& ▁* ▁got _ frame _ ptr ▁) ▁{ ▁cnt ▁+= ▁s ▁-> ▁sp illo ver _ n bits ▁; ▁s ▁-> ▁skip _ bits _ next ▁= ▁cnt ▁& ▁7 ▁; ▁res ▁= ▁cnt ▁>> ▁3 ▁; ▁if ▁( ▁res ▁> ▁avpkt ▁-> ▁size ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Trying tos kip % db ytes in packet of size % d \ n " ▁, ▁res ▁, ▁avpkt ▁-> ▁size ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁return ▁res ▁; ▁} ▁else ▁skip _ bits _ long ▁( ▁gb ▁, ▁s ▁-> ▁sp illo ver _ n bits ▁- ▁cnt ▁+ ▁get _ bits _ count ▁( ▁gb ▁) ▁) ▁; ▁} ▁else ▁skip _ bits _ long ▁( ▁gb ▁, ▁s ▁-> ▁sp illo ver _ n bits ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁s ▁-> ▁skip _ bits _ next ▁) ▁skip _ bits ▁( ▁gb ▁, ▁s ▁-> ▁skip _ bits _ next ▁) ▁; ▁s ▁-> ▁sf rame _ cache _ size ▁= ▁0 ▁; ▁s ▁-> ▁skip _ bits _ next ▁= ▁0 ▁; ▁pos ▁= ▁get _ bits _ left ▁( ▁gb ▁) ▁; ▁if ▁( ▁( ▁res ▁= ▁synth _ super frame ▁( ▁ctx ▁, ▁data ▁, ▁got _ frame _ ptr ▁) ▁) ▁< ▁0 ▁) ▁{ ▁return ▁res ▁; ▁} ▁else ▁if ▁( ▁* ▁got _ frame _ ptr ▁) ▁{ ▁int ▁cnt ▁= ▁get _ bits _ count ▁( ▁gb ▁) ▁; ▁s ▁-> ▁skip _ bits _ next ▁= ▁cnt ▁& ▁7 ▁; ▁res ▁= ▁cnt ▁>> ▁3 ▁; ▁if ▁( ▁res ▁> ▁avpkt ▁-> ▁size ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Trying tos kip % db ytes in packet of size % d \ n " ▁, ▁res ▁, ▁avpkt ▁-> ▁size ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁return ▁res ▁; ▁} ▁else ▁if ▁( ▁( ▁s ▁-> ▁sf rame _ cache _ size ▁= ▁pos ▁) ▁> ▁0 ▁) ▁{ ▁init _ get _ bits ▁( ▁gb ▁, ▁avpkt ▁-> ▁data ▁, ▁size ▁<< ▁3 ▁) ▁; ▁skip _ bits _ long ▁( ▁gb ▁, ▁( ▁size ▁<< ▁3 ▁) ▁- ▁pos ▁) ▁; ▁av _ assert 1 ▁( ▁get _ bits _ left ▁( ▁gb ▁) ▁== ▁pos ▁) ▁; ▁init _ put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁s ▁-> ▁sf rame _ cache ▁, ▁S FRAME _ CACHE _ MAX SIZE ▁) ▁; ▁copy _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁avpkt ▁-> ▁data ▁, ▁size ▁, ▁gb ▁, ▁s ▁-> ▁sf rame _ cache _ size ▁) ▁; ▁} ▁return ▁size ▁; ▁}	1
▁static ▁int ▁mov _ write _ ct ts _ tag ▁( ▁AVIO Context ▁* ▁pb ▁, ▁MOV Track ▁* ▁track ▁) ▁{ ▁MOV St ts ▁* ▁c tt s _ entries ▁; ▁uint 32_ t ▁entries ▁= ▁0 ▁; ▁uint 32_ t ▁atom _ size ▁; ▁int ▁i ▁; ▁c tt s _ entries ▁= ▁av _ malloc _ array ▁( ▁( ▁track ▁-> ▁entry ▁+ ▁1 ▁) ▁, ▁sizeof ▁( ▁* ▁c tt s _ entries ▁) ▁) ▁; ▁c tt s _ entries ▁[ ▁0 ▁] ▁. ▁count ▁= ▁1 ▁; ▁c tt s _ entries ▁[ ▁0 ▁] ▁. ▁duration ▁= ▁track ▁-> ▁cluster ▁[ ▁0 ▁] ▁. ▁cts ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁track ▁-> ▁entry ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁track ▁-> ▁cluster ▁[ ▁i ▁] ▁. ▁cts ▁== ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁duration ▁) ▁{ ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁count ▁++ ▁; ▁} ▁else ▁{ ▁entries ▁++ ▁; ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁duration ▁= ▁track ▁-> ▁cluster ▁[ ▁i ▁] ▁. ▁cts ▁; ▁c tt s _ entries ▁[ ▁entries ▁] ▁. ▁count ▁= ▁1 ▁; ▁} ▁} ▁entries ▁++ ▁; ▁atom _ size ▁= ▁16 ▁+ ▁( ▁entries ▁* ▁8 ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁atom _ size ▁) ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁" ct ts " ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁entries ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁entries ▁; ▁i ▁++ ▁) ▁{ ▁avio _ wb 32 ▁( ▁pb ▁, ▁c tt s _ entries ▁[ ▁i ▁] ▁. ▁count ▁) ▁; ▁avio _ wb 32 ▁( ▁pb ▁, ▁c tt s _ entries ▁[ ▁i ▁] ▁. ▁duration ▁) ▁; ▁} ▁av _ free ▁( ▁c tt s _ entries ▁) ▁; ▁return ▁atom _ size ▁; ▁}	1
▁static ▁int ▁w ma _ decode _ super frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame _ ptr ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁W MAC ode c Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁nb _ frames ▁, ▁bit _ offset ▁, ▁i ▁, ▁pos ▁, ▁len ▁, ▁ret ▁; ▁uint 8_ t ▁* ▁q ▁; ▁int 16_ t ▁* ▁samples ▁; ▁t printf ▁( ▁avctx ▁, ▁"*** decode _ super frame :\ n " ▁) ▁; ▁if ▁( ▁buf _ size ▁== ▁0 ▁) ▁{ ▁s ▁-> ▁last _ super frame _ len ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁buf _ size ▁< ▁s ▁-> ▁block _ align ▁) ▁return ▁0 ▁; ▁buf _ size ▁= ▁s ▁-> ▁block _ align ▁; ▁init _ get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁if ▁( ▁s ▁-> ▁use _ bit _ re serv o ir ▁) ▁{ ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁; ▁nb _ frames ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁4 ▁) ▁- ▁( ▁s ▁-> ▁last _ super frame _ len ▁<= ▁0 ▁) ▁; ▁} ▁else ▁{ ▁nb _ frames ▁= ▁1 ▁; ▁} ▁s ▁-> ▁frame ▁. ▁nb _ samples ▁= ▁nb _ frames ▁* ▁s ▁-> ▁frame _ len ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁& ▁s ▁-> ▁frame ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁samples ▁= ▁( ▁int 16_ t ▁* ▁) ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁0 ▁] ▁; ▁if ▁( ▁s ▁-> ▁use _ bit _ re serv o ir ▁) ▁{ ▁bit _ offset ▁= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁byte _ offset _ bits ▁+ ▁3 ▁) ▁; ▁if ▁( ▁s ▁-> ▁last _ super frame _ len ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁last _ super frame _ len ▁+ ▁( ▁( ▁bit _ offset ▁+ ▁7 ▁) ▁>> ▁3 ▁) ▁) ▁> ▁MAX _ CODED _ SUPER FRAME _ SIZE ▁) ▁goto ▁fail ▁; ▁q ▁= ▁s ▁-> ▁last _ super frame ▁+ ▁s ▁-> ▁last _ super frame _ len ▁; ▁len ▁= ▁bit _ offset ▁; ▁while ▁( ▁len ▁> ▁7 ▁) ▁{ ▁* ▁q ▁++ ▁= ▁( ▁get _ bits ▁) ▁( ▁& ▁s ▁-> ▁gb ▁, ▁8 ▁) ▁; ▁len ▁-= ▁8 ▁; ▁} ▁if ▁( ▁len ▁> ▁0 ▁) ▁{ ▁* ▁q ▁++ ▁= ▁( ▁get _ bits ▁) ▁( ▁& ▁s ▁-> ▁gb ▁, ▁len ▁) ▁<< ▁( ▁8 ▁- ▁len ▁) ▁; ▁} ▁init _ get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁last _ super frame ▁, ▁MAX _ CODED _ SUPER FRAME _ SIZE ▁* ▁8 ▁) ▁; ▁if ▁( ▁s ▁-> ▁last _ bit offset ▁> ▁0 ▁) ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁last _ bit offset ▁) ▁; ▁if ▁( ▁w ma _ decode _ frame ▁( ▁s ▁, ▁samples ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁samples ▁+= ▁s ▁-> ▁nb _ channels ▁* ▁s ▁-> ▁frame _ len ▁; ▁nb _ frames ▁-- ▁; ▁} ▁pos ▁= ▁bit _ offset ▁+ ▁4 ▁+ ▁4 ▁+ ▁s ▁-> ▁byte _ offset _ bits ▁+ ▁3 ▁; ▁if ▁( ▁pos ▁>= ▁MAX _ CODED _ SUPER FRAME _ SIZE ▁* ▁8 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁init _ get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁buf ▁+ ▁( ▁pos ▁>> ▁3 ▁) ▁, ▁( ▁MAX _ CODED _ SUPER FRAME _ SIZE ▁- ▁( ▁pos ▁>> ▁3 ▁) ▁) ▁* ▁8 ▁) ▁; ▁len ▁= ▁pos ▁& ▁7 ▁; ▁if ▁( ▁len ▁> ▁0 ▁) ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁len ▁) ▁; ▁s ▁-> ▁reset _ block _ length s ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ frames ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁w ma _ decode _ frame ▁( ▁s ▁, ▁samples ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁samples ▁+= ▁s ▁-> ▁nb _ channels ▁* ▁s ▁-> ▁frame _ len ▁; ▁} ▁pos ▁= ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁+ ▁( ▁( ▁bit _ offset ▁+ ▁4 ▁+ ▁4 ▁+ ▁s ▁-> ▁byte _ offset _ bits ▁+ ▁3 ▁) ▁& ▁ ~ ▁7 ▁) ▁; ▁s ▁-> ▁last _ bit offset ▁= ▁pos ▁& ▁7 ▁; ▁pos ▁>>= ▁3 ▁; ▁len ▁= ▁buf _ size ▁- ▁pos ▁; ▁if ▁( ▁len ▁> ▁MAX _ CODED _ SUPER FRAME _ SIZE ▁|| ▁len ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" len % d invalid \ n " ▁, ▁len ▁) ▁; ▁goto ▁fail ▁; ▁} ▁s ▁-> ▁last _ super frame _ len ▁= ▁len ▁; ▁memcpy ▁( ▁s ▁-> ▁last _ super frame ▁, ▁buf ▁+ ▁pos ▁, ▁len ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁w ma _ decode _ frame ▁( ▁s ▁, ▁samples ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁samples ▁+= ▁s ▁-> ▁nb _ channels ▁* ▁s ▁-> ▁frame _ len ▁; ▁} ▁* ▁got _ frame _ ptr ▁= ▁1 ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁s ▁-> ▁frame ▁; ▁return ▁s ▁-> ▁block _ align ▁; ▁fail ▁: ▁s ▁-> ▁last _ super frame _ len ▁= ▁0 ▁; ▁return ▁-1 ▁; ▁}	0
▁static ▁int ▁ac 3_ encode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁unsigned ▁char ▁* ▁frame ▁, ▁int ▁buf _ size ▁, ▁void ▁* ▁data ▁) ▁{ ▁AC 3 Encode Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁SampleType ▁* ▁samples ▁= ▁data ▁; ▁int ▁ret ▁; ▁if ▁( ▁s ▁-> ▁bit _ alloc ▁. ▁sr _ code ▁== ▁1 ▁) ▁adjust _ frame _ size ▁( ▁s ▁) ▁; ▁de inter leave _ input _ samples ▁( ▁s ▁, ▁samples ▁) ▁; ▁apply _ md ct ▁( ▁s ▁) ▁; ▁scale _ coeff icients ▁( ▁s ▁) ▁; ▁compute _ rem atrix ing _ strategy ▁( ▁s ▁) ▁; ▁apply _ rem atrix ing ▁( ▁s ▁) ▁; ▁process _ ex pon ents ▁( ▁s ▁) ▁; ▁ret ▁= ▁compute _ bit _ allocation ▁( ▁s ▁) ▁; ▁if ▁( ▁ret ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bit allocation failed . Try in creasing the bitrate .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁quant ize _ mant iss as ▁( ▁s ▁) ▁; ▁output _ frame ▁( ▁s ▁, ▁frame ▁) ▁; ▁return ▁s ▁-> ▁frame _ size ▁; ▁}	0
▁int ▁ff _ draw _ slice ▁( ▁AVFilter Link ▁* ▁link ▁, ▁int ▁y ▁, ▁int ▁h ▁, ▁int ▁slice _ dir ▁) ▁{ ▁uint 8_ t ▁* ▁src ▁[ ▁4 ▁] ▁, ▁* ▁dst ▁[ ▁4 ▁] ▁; ▁int ▁i ▁, ▁j ▁, ▁v sub ▁, ▁ret ▁; ▁int ▁( ▁* ▁draw _ slice ▁) ▁( ▁AVFilter Link ▁* ▁, ▁int ▁, ▁int ▁, ▁int ▁) ▁; ▁FF _ T PRINTF _ START ▁( ▁NULL ▁, ▁draw _ slice ▁) ▁; ▁ff _ t log _ link ▁( ▁NULL ▁, ▁link ▁, ▁0 ▁) ▁; ▁ff _ t log ▁( ▁NULL ▁, ▁" y :% dh :% dd ir :% d \ n " ▁, ▁y ▁, ▁h ▁, ▁slice _ dir ▁) ▁; ▁if ▁( ▁link ▁-> ▁src _ buf ▁) ▁{ ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁link ▁-> ▁format ▁) ▁; ▁v sub ▁= ▁desc ▁-> ▁log 2_ chroma _ h ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁link ▁-> ▁src _ buf ▁-> ▁data ▁[ ▁i ▁] ▁) ▁{ ▁src ▁[ ▁i ▁] ▁= ▁link ▁-> ▁src _ buf ▁-> ▁data ▁[ ▁i ▁] ▁+ ▁( ▁y ▁>> ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁? ▁v sub ▁: ▁0 ▁) ▁) ▁* ▁link ▁-> ▁src _ buf ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁dst ▁[ ▁i ▁] ▁= ▁link ▁-> ▁cur _ buf _ copy ▁-> ▁data ▁[ ▁i ▁] ▁+ ▁( ▁y ▁>> ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁? ▁v sub ▁: ▁0 ▁) ▁) ▁* ▁link ▁-> ▁cur _ buf _ copy ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁} ▁else ▁src ▁[ ▁i ▁] ▁= ▁dst ▁[ ▁i ▁] ▁= ▁NULL ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁plan ew ▁= ▁av _ image _ get _ lines ize ▁( ▁link ▁-> ▁format ▁, ▁link ▁-> ▁cur _ buf _ copy ▁-> ▁video ▁-> ▁w ▁, ▁i ▁) ▁; ▁if ▁( ▁! ▁src ▁[ ▁i ▁] ▁) ▁continue ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁h ▁>> ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁? ▁v sub ▁: ▁0 ▁) ▁; ▁j ▁++ ▁) ▁{ ▁memcpy ▁( ▁dst ▁[ ▁i ▁] ▁, ▁src ▁[ ▁i ▁] ▁, ▁plan ew ▁) ▁; ▁src ▁[ ▁i ▁] ▁+= ▁link ▁-> ▁src _ buf ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁dst ▁[ ▁i ▁] ▁+= ▁link ▁-> ▁cur _ buf _ copy ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁} ▁} ▁} ▁if ▁( ▁! ▁( ▁draw _ slice ▁= ▁link ▁-> ▁dst pad ▁-> ▁draw _ slice ▁) ▁) ▁draw _ slice ▁= ▁default _ draw _ slice ▁; ▁ret ▁= ▁draw _ slice ▁( ▁link ▁, ▁y ▁, ▁h ▁, ▁slice _ dir ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁clear _ link ▁( ▁link ▁) ▁; ▁else ▁av _ assert 1 ▁( ▁link ▁-> ▁cur _ buf _ copy ▁-> ▁buf ▁-> ▁refcount ▁> ▁0 ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁size _ t ▁i 2 c _ i buf ▁( ▁const ▁unsigned ▁char ▁* ▁b ▁, ▁size _ t ▁blen ▁, ▁int ▁neg ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁) ▁{ ▁int ▁pad ▁= ▁0 ▁; ▁size _ t ▁ret ▁, ▁i ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁pb ▁= ▁0 ▁; ▁const ▁unsigned ▁char ▁* ▁n ▁; ▁if ▁( ▁b ▁== ▁NULL ▁|| ▁blen ▁== ▁0 ▁) ▁ret ▁= ▁1 ▁; ▁else ▁{ ▁ret ▁= ▁blen ▁; ▁i ▁= ▁b ▁[ ▁0 ▁] ▁; ▁if ▁( ▁ret ▁== ▁1 ▁&& ▁i ▁== ▁0 ▁) ▁neg ▁= ▁0 ▁; ▁if ▁( ▁! ▁neg ▁&& ▁( ▁i ▁> ▁127 ▁) ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁pb ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁neg ▁) ▁{ ▁if ▁( ▁i ▁> ▁128 ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁pb ▁= ▁0 xFF ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁128 ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁blen ▁; ▁i ▁++ ▁) ▁if ▁( ▁b ▁[ ▁i ▁] ▁) ▁{ ▁pad ▁= ▁1 ▁; ▁pb ▁= ▁0 xFF ▁; ▁break ▁; ▁} ▁} ▁} ▁ret ▁+= ▁pad ▁; ▁} ▁if ▁( ▁pp ▁== ▁NULL ▁) ▁return ▁ret ▁; ▁p ▁= ▁* ▁pp ▁; ▁if ▁( ▁pad ▁) ▁* ▁( ▁p ▁++ ▁) ▁= ▁pb ▁; ▁if ▁( ▁b ▁== ▁NULL ▁|| ▁blen ▁== ▁0 ▁) ▁* ▁p ▁= ▁0 ▁; ▁else ▁if ▁( ▁! ▁neg ▁) ▁memcpy ▁( ▁p ▁, ▁b ▁, ▁blen ▁) ▁; ▁else ▁{ ▁n ▁= ▁b ▁+ ▁blen ▁- ▁1 ▁; ▁p ▁+= ▁blen ▁- ▁1 ▁; ▁i ▁= ▁blen ▁; ▁while ▁( ▁! ▁* ▁n ▁&& ▁i ▁> ▁1 ▁) ▁{ ▁* ▁( ▁p ▁-- ▁) ▁= ▁0 ▁; ▁n ▁-- ▁; ▁i ▁-- ▁; ▁} ▁* ▁( ▁p ▁-- ▁) ▁= ▁( ▁( ▁* ▁( ▁n ▁-- ▁) ▁) ▁ ^ ▁0 xff ▁) ▁+ ▁1 ▁; ▁i ▁-- ▁; ▁for ▁( ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁* ▁( ▁p ▁-- ▁) ▁= ▁* ▁( ▁n ▁-- ▁) ▁ ^ ▁0 xff ▁; ▁} ▁* ▁pp ▁+= ▁ret ▁; ▁return ▁ret ▁; ▁}	1
▁void ▁ff _ inter leave _ add _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁( ▁* ▁compare ▁) ▁( ▁AVFormatContext ▁* ▁, ▁AVPacket ▁* ▁, ▁AVPacket ▁* ▁) ▁) ▁{ ▁AVPacket List ▁* ▁* ▁next _ point ▁, ▁* ▁this _ pk tl ▁; ▁this _ pk tl ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVPacket List ▁) ▁) ▁; ▁this _ pk tl ▁-> ▁pkt ▁= ▁* ▁pkt ▁; ▁# if ▁FF _ API _ DES TRUCT _ PACKET ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁pkt ▁-> ▁destruct ▁= ▁NULL ▁; ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁# endif ▁pkt ▁-> ▁buf ▁= ▁NULL ▁; ▁av _ dup _ packet ▁( ▁& ▁this _ pk tl ▁-> ▁pkt ▁) ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁) ▁{ ▁next _ point ▁= ▁& ▁( ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁-> ▁next ▁) ▁; ▁} ▁else ▁next _ point ▁= ▁& ▁s ▁-> ▁packet _ buffer ▁; ▁if ▁( ▁* ▁next _ point ▁) ▁{ ▁if ▁( ▁compare ▁( ▁s ▁, ▁& ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁{ ▁while ▁( ▁! ▁compare ▁( ▁s ▁, ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁next _ point ▁= ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁next ▁; ▁goto ▁next _ non _ null ▁; ▁} ▁else ▁{ ▁next _ point ▁= ▁& ▁( ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁next ▁) ▁; ▁} ▁} ▁assert ▁( ▁! ▁* ▁next _ point ▁) ▁; ▁s ▁-> ▁packet _ buffer _ end ▁= ▁this _ pk tl ▁; ▁next _ non _ null ▁: ▁this _ pk tl ▁-> ▁next ▁= ▁* ▁next _ point ▁; ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁= ▁* ▁next _ point ▁= ▁this _ pk tl ▁; ▁}	1
▁static ▁int ▁poll _ filters ▁( ▁void ▁) ▁{ ▁AVFilter Buffer Ref ▁* ▁pic ref ▁; ▁AVFrame ▁* ▁filtered _ frame ▁= ▁NULL ▁; ▁int ▁i ▁, ▁ret ▁, ▁ret _ all ▁; ▁unsigned ▁nb _ success ▁, ▁nb _ eof ▁; ▁int 64_ t ▁frame _ pts ▁; ▁while ▁( ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁OutputFile ▁* ▁of ▁= ▁output _ files ▁[ ▁o st ▁-> ▁file _ index ▁] ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁! ▁o st ▁-> ▁filter ▁|| ▁o st ▁-> ▁is _ p ast _ recording _ time ▁) ▁continue ▁; ▁if ▁( ▁! ▁o st ▁-> ▁filtered _ frame ▁&& ▁! ▁( ▁o st ▁-> ▁filtered _ frame ▁= ▁avcodec _ alloc _ frame ▁( ▁) ▁) ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁else ▁avcodec _ get _ frame _ defaults ▁( ▁o st ▁-> ▁filtered _ frame ▁) ▁; ▁filtered _ frame ▁= ▁o st ▁-> ▁filtered _ frame ▁; ▁while ▁( ▁1 ▁) ▁{ ▁AVR ational ▁ist _ pts _ tb ▁= ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁time _ base ▁; ▁if ▁( ▁o st ▁-> ▁enc ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁! ▁( ▁o st ▁-> ▁enc ▁-> ▁capabilities ▁& ▁CODEC _ CAP _ VARIABLE _ FRAME _ SIZE ▁) ▁) ▁ret ▁= ▁av _ buffers ink _ read _ samples ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁frame _ size ▁) ▁; ▁else ▁# ifdef ▁S INK A ▁ret ▁= ▁av _ buffers ink _ read ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁) ▁; ▁# else ▁ret ▁= ▁av _ buffers ink _ get _ buffer _ ref ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁, ▁& ▁pic ref ▁, ▁AV _ BUFFER SINK _ FLAG _ NO _ REQUEST ▁) ▁; ▁# endif ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁ret ▁!= ▁AVERROR ▁( ▁EAGAIN ▁) ▁) ▁{ ▁char ▁buf ▁[ ▁256 ▁] ▁; ▁av _ strerror ▁( ▁ret ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" Error in av _ buffers ink _ get _ buffer _ ref () :% s \ n " ▁, ▁buf ▁) ▁; ▁} ▁break ▁; ▁} ▁if ▁( ▁o st ▁-> ▁enc ▁-> ▁type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁= ▁av _ re scale _ q ▁( ▁pic ref ▁-> ▁pts ▁, ▁ist _ pts _ tb ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁else ▁if ▁( ▁pic ref ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁= ▁av _ re scale _ q ▁( ▁pic ref ▁-> ▁pts ▁, ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁time _ base ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁) ▁- ▁av _ re scale _ q ▁( ▁of ▁-> ▁start _ time ▁, ▁AV _ TIME _ BASE _ Q ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁) ▁; ▁if ▁( ▁of ▁-> ▁start _ time ▁&& ▁filtered _ frame ▁-> ▁pts ▁< ▁of ▁-> ▁start _ time ▁) ▁return ▁0 ▁; ▁switch ▁( ▁o st ▁-> ▁filter ▁-> ▁filter ▁-> ▁inputs ▁[ ▁0 ▁] ▁-> ▁type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁avfilter _ fill _ frame _ from _ video _ buffer _ ref ▁( ▁filtered _ frame ▁, ▁pic ref ▁) ▁; ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁; ▁if ▁( ▁! ▁o st ▁-> ▁frame _ aspect _ ratio ▁) ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁sample _ aspect _ ratio ▁= ▁pic ref ▁-> ▁video ▁-> ▁sample _ aspect _ ratio ▁; ▁do _ video _ out ▁( ▁of ▁-> ▁ctx ▁, ▁o st ▁, ▁filtered _ frame ▁, ▁same _ quant ▁? ▁o st ▁-> ▁last _ quality ▁: ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁global _ quality ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁avfilter _ copy _ buf _ props ▁( ▁filtered _ frame ▁, ▁pic ref ▁) ▁; ▁filtered _ frame ▁-> ▁pts ▁= ▁frame _ pts ▁; ▁do _ audio _ out ▁( ▁of ▁-> ▁ctx ▁, ▁o st ▁, ▁filtered _ frame ▁) ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁} ▁avfilter _ unref _ buffer ▁( ▁pic ref ▁) ▁; ▁} ▁} ▁ret _ all ▁= ▁nb _ success ▁= ▁nb _ eof ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ filter graph s ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁= ▁avfilter _ graph _ request _ ol dest ▁( ▁filter graph s ▁[ ▁i ▁] ▁-> ▁graph ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁{ ▁nb _ success ▁++ ▁; ▁} ▁else ▁if ▁( ▁ret ▁== ▁AVERROR _ EOF ▁) ▁{ ▁nb _ eof ▁++ ▁; ▁} ▁else ▁if ▁( ▁ret ▁!= ▁AVERROR ▁( ▁EAGAIN ▁) ▁) ▁{ ▁char ▁buf ▁[ ▁256 ▁] ▁; ▁av _ strerror ▁( ▁ret ▁, ▁buf ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" Error in request _ frame () :% s \ n " ▁, ▁buf ▁) ▁; ▁ret _ all ▁= ▁ret ▁; ▁} ▁} ▁if ▁( ▁! ▁nb _ success ▁) ▁break ▁; ▁} ▁return ▁nb _ eof ▁== ▁nb _ filter graph s ▁? ▁AVERROR _ EOF ▁: ▁ret _ all ▁; ▁}	0
▁static ▁int ▁normalize _ samples ▁( ▁AC 3 Encode Context ▁* ▁s ▁) ▁{ ▁int ▁v ▁= ▁14 ▁- ▁log 2_ tab ▁( ▁s ▁, ▁s ▁-> ▁window ed _ samples ▁, ▁AC 3_ WINDOW _ SIZE ▁) ▁; ▁l shift _ tab ▁( ▁s ▁-> ▁window ed _ samples ▁, ▁AC 3_ WINDOW _ SIZE ▁, ▁v ▁) ▁; ▁return ▁v ▁+ ▁6 ▁; ▁}	0
▁static ▁int ▁get _ key ▁( ▁const ▁char ▁* ▁* ▁ro pts ▁, ▁const ▁char ▁* ▁delim ▁, ▁char ▁* ▁key ▁, ▁unsigned ▁key _ size ▁) ▁{ ▁unsigned ▁key _ pos ▁= ▁0 ▁; ▁const ▁char ▁* ▁opts ▁= ▁* ▁ro pts ▁; ▁opts ▁+= ▁str spn ▁( ▁opts ▁, ▁WH IT ESP ACES ▁) ▁; ▁while ▁( ▁is _ key _ char ▁( ▁* ▁opts ▁) ▁) ▁{ ▁key ▁[ ▁key _ pos ▁++ ▁] ▁= ▁* ▁opts ▁; ▁if ▁( ▁key _ pos ▁== ▁key _ size ▁) ▁key _ pos ▁-- ▁; ▁( ▁opts ▁) ▁++ ▁; ▁} ▁opts ▁+= ▁str spn ▁( ▁opts ▁, ▁WH IT ESP ACES ▁) ▁; ▁if ▁( ▁! ▁* ▁opts ▁|| ▁! ▁strchr ▁( ▁delim ▁, ▁* ▁opts ▁) ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁opts ▁++ ▁; ▁key ▁[ ▁key _ pos ▁++ ▁] ▁= ▁0 ▁; ▁if ▁( ▁key _ pos ▁== ▁key _ size ▁) ▁key ▁[ ▁key _ pos ▁- ▁4 ▁] ▁= ▁key ▁[ ▁key _ pos ▁- ▁3 ▁] ▁= ▁key ▁[ ▁key _ pos ▁- ▁2 ▁] ▁= ▁' ▁' ▁; ▁* ▁ro pts ▁= ▁opts ▁; ▁return ▁0 ▁; ▁}	1
▁EVP _ PKEY ▁* ▁EVP _ PKCS 82 PKEY ▁( ▁PKCS 8_ PRIV _ KEY _ INFO ▁* ▁p 8 ▁) ▁{ ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁ASN 1_ OBJECT ▁* ▁alg oid ▁; ▁const ▁EVP _ PKEY _ ASN 1_ METHOD ▁* ▁meth ▁; ▁char ▁obj _ tmp ▁[ ▁80 ▁] ▁; ▁if ▁( ▁! ▁PKCS 8_ pkey _ get 0 ▁( ▁& ▁alg oid ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁p 8 ▁) ▁) ▁return ▁NULL ▁; ▁if ▁( ▁! ▁( ▁pkey ▁= ▁EVP _ PKEY _ new ▁( ▁) ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ PKCS 82 PKEY ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁meth ▁= ▁EVP _ PKEY _ ASN 1_ find ▁( ▁OBJ _ obj 2 nid ▁( ▁alg oid ▁) ▁) ▁; ▁if ▁( ▁meth ▁) ▁{ ▁if ▁( ▁meth ▁-> ▁priv _ decode ▁) ▁{ ▁if ▁( ▁! ▁meth ▁-> ▁priv _ decode ▁( ▁pkey ▁, ▁p 8 ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ PKCS 82 PKEY ▁, ▁EVP _ R _ PRIVATE _ KEY _ DECODE _ ERROR ▁) ▁; ▁goto ▁error ▁; ▁} ▁} ▁else ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ PKCS 82 PKEY ▁, ▁EVP _ R _ METHOD _ NOT _ SUPPORTED ▁) ▁; ▁goto ▁error ▁; ▁} ▁} ▁else ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ PKCS 82 PKEY ▁, ▁EVP _ R _ UNSUPPORTED _ PRIVATE _ KEY _ ALGORITHM ▁) ▁; ▁i 2 t _ ASN 1_ OBJECT ▁( ▁obj _ tmp ▁, ▁80 ▁, ▁alg oid ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁2 ▁, ▁" TYPE =" ▁, ▁obj _ tmp ▁) ▁; ▁goto ▁error ▁; ▁} ▁return ▁pkey ▁; ▁error ▁: ▁EVP _ PKEY _ free ▁( ▁pkey ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁RAND _ DR BG ▁* ▁RAND _ DR BG _ new ▁( ▁int ▁type ▁, ▁unsigned ▁int ▁flags ▁, ▁RAND _ DR BG ▁* ▁parent ▁) ▁{ ▁RAND _ DR BG ▁* ▁dr bg ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁dr bg ▁) ▁) ▁; ▁if ▁( ▁dr bg ▁== ▁NULL ▁) ▁{ ▁RAND err ▁( ▁RAND _ F _ RAND _ DR BG _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁dr bg ▁-> ▁fork _ count ▁= ▁rand _ fork _ count ▁; ▁dr bg ▁-> ▁parent ▁= ▁parent ▁; ▁if ▁( ▁RAND _ DR BG _ set ▁( ▁dr bg ▁, ▁type ▁, ▁flags ▁) ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁parent ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁RAND _ DR BG _ set _ callbacks ▁( ▁dr bg ▁, ▁rand _ drbg _ get _ entropy ▁, ▁rand _ drbg _ cleanup _ entropy ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁goto ▁err ▁; ▁} ▁return ▁dr bg ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁dr bg ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁void ▁ngx _ http _ file _ cache _ lock _ wait _ handler ▁( ▁ngx _ event _ t ▁* ▁ev ▁) ▁{ ▁ngx _ uint _ t ▁wait ▁; ▁ngx _ msec _ t ▁now ▁, ▁timer ▁; ▁ngx _ http _ cache _ t ▁* ▁c ▁; ▁ngx _ http _ request _ t ▁* ▁r ▁; ▁ngx _ http _ file _ cache _ t ▁* ▁cache ▁; ▁r ▁= ▁ev ▁-> ▁data ▁; ▁c ▁= ▁r ▁-> ▁cache ▁; ▁now ▁= ▁ngx _ current _ msec ▁; ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁ev ▁-> ▁log ▁, ▁0 ▁, ▁" http file cache wa ith andler wt :% M cur :% M " ▁, ▁c ▁-> ▁wait _ time ▁, ▁now ▁) ▁; ▁timer ▁= ▁c ▁-> ▁wait _ time ▁- ▁now ▁; ▁if ▁( ▁( ▁ngx _ msec _ int _ t ▁) ▁timer ▁<= ▁0 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ INFO ▁, ▁ev ▁-> ▁log ▁, ▁0 ▁, ▁" cache lock timeout " ▁) ▁; ▁c ▁-> ▁lock _ timeout ▁= ▁0 ▁; ▁goto ▁wakeup ▁; ▁} ▁cache ▁= ▁c ▁-> ▁file _ cache ▁; ▁wait ▁= ▁0 ▁; ▁ngx _ shm tx _ lock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁timer ▁= ▁c ▁-> ▁node ▁-> ▁lock _ time ▁- ▁now ▁; ▁if ▁( ▁c ▁-> ▁node ▁-> ▁updating ▁&& ▁( ▁ngx _ msec _ int _ t ▁) ▁timer ▁> ▁0 ▁) ▁{ ▁wait ▁= ▁1 ▁; ▁} ▁ngx _ shm tx _ unlock ▁( ▁& ▁cache ▁-> ▁sh pool ▁-> ▁mutex ▁) ▁; ▁if ▁( ▁wait ▁) ▁{ ▁ngx _ add _ timer ▁( ▁ev ▁, ▁( ▁timer ▁> ▁500 ▁) ▁? ▁500 ▁: ▁timer ▁) ▁; ▁return ▁; ▁} ▁wakeup ▁: ▁c ▁-> ▁waiting ▁= ▁0 ▁; ▁r ▁-> ▁main ▁-> ▁blocked ▁-- ▁; ▁r ▁-> ▁connection ▁-> ▁write ▁-> ▁handler ▁( ▁r ▁-> ▁connection ▁-> ▁write ▁) ▁; ▁}	0
▁int ▁show _ help ▁( ▁void ▁* ▁opt ctx ▁, ▁const ▁char ▁* ▁opt ▁, ▁const ▁char ▁* ▁arg ▁) ▁{ ▁char ▁* ▁topic ▁, ▁* ▁par ▁; ▁av _ log _ set _ callback ▁( ▁log _ callback _ help ▁) ▁; ▁topic ▁= ▁av _ strdup ▁( ▁arg ▁? ▁arg ▁: ▁"" ▁) ▁; ▁par ▁= ▁strchr ▁( ▁topic ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁par ▁) ▁* ▁par ▁++ ▁= ▁0 ▁; ▁if ▁( ▁! ▁* ▁topic ▁) ▁{ ▁show _ help _ default ▁( ▁topic ▁, ▁par ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" decoder " ▁) ▁) ▁{ ▁show _ help _ codec ▁( ▁par ▁, ▁0 ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" encoder " ▁) ▁) ▁{ ▁show _ help _ codec ▁( ▁par ▁, ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" demuxer " ▁) ▁) ▁{ ▁show _ help _ demuxer ▁( ▁par ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" mux er " ▁) ▁) ▁{ ▁show _ help _ mux er ▁( ▁par ▁) ▁; ▁# if ▁CONFIG _ AV FILTER ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" filter " ▁) ▁) ▁{ ▁show _ help _ filter ▁( ▁par ▁) ▁; ▁# endif ▁} else { ▁show _ help _ default ▁( ▁topic ▁, ▁par ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁topic ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁BIGNUM ▁* ▁bn _ expand 2 ▁( ▁BIGNUM ▁* ▁b ▁, ▁int ▁words ▁) ▁{ ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁words ▁> ▁b ▁-> ▁dmax ▁) ▁{ ▁BN _ ULONG ▁* ▁a ▁= ▁bn _ expand _ internal ▁( ▁b ▁, ▁words ▁) ▁; ▁if ▁( ▁! ▁a ▁) ▁return ▁NULL ▁; ▁if ▁( ▁b ▁-> ▁d ▁) ▁OPENSSL _ free ▁( ▁b ▁-> ▁d ▁) ▁; ▁b ▁-> ▁d ▁= ▁a ▁; ▁b ▁-> ▁dmax ▁= ▁words ▁; ▁} ▁# if ▁0 ▁if ▁( ▁b ▁-> ▁top ▁< ▁b ▁-> ▁dmax ▁) ▁{ ▁int ▁i ▁; ▁BN _ ULONG ▁* ▁A ▁= ▁& ▁( ▁b ▁-> ▁d ▁[ ▁b ▁-> ▁top ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁( ▁b ▁-> ▁dmax ▁- ▁b ▁-> ▁top ▁) ▁>> ▁3 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁+= ▁8 ▁) ▁{ ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁3 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁4 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁5 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁6 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁7 ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁( ▁b ▁-> ▁dmax ▁- ▁b ▁-> ▁top ▁) ▁& ▁7 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁++ ▁) ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁assert ▁( ▁A ▁== ▁& ▁( ▁b ▁-> ▁d ▁[ ▁b ▁-> ▁dmax ▁] ▁) ▁) ▁; ▁} ▁# endif ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁return ▁b ▁; ▁}	0
▁static ▁inline ▁int ▁get _ se _ go lo mb ▁( ▁Get Bit Context ▁* ▁gb ▁) ▁{ ▁unsigned ▁int ▁buf ▁; ▁int ▁log ▁; ▁OPEN _ READER ▁( ▁re ▁, ▁gb ▁) ▁; ▁UPDATE _ CACHE ▁( ▁re ▁, ▁gb ▁) ▁; ▁buf ▁= ▁GET _ CACHE ▁( ▁re ▁, ▁gb ▁) ▁; ▁if ▁( ▁buf ▁>= ▁( ▁1 ▁<< ▁27 ▁) ▁) ▁{ ▁buf ▁>>= ▁32 ▁- ▁9 ▁; ▁LAST _ SKIP _ BITS ▁( ▁re ▁, ▁gb ▁, ▁ff _ go lo mb _ vlc _ len ▁[ ▁buf ▁] ▁) ▁; ▁CLOSE _ READER ▁( ▁re ▁, ▁gb ▁) ▁; ▁return ▁ff _ se _ go lo mb _ vlc _ code ▁[ ▁buf ▁] ▁; ▁} ▁else ▁{ ▁log ▁= ▁2 ▁* ▁av _ log 2 ▁( ▁buf ▁) ▁- ▁31 ▁; ▁buf ▁>>= ▁log ▁; ▁LAST _ SKIP _ BITS ▁( ▁re ▁, ▁gb ▁, ▁32 ▁- ▁log ▁) ▁; ▁CLOSE _ READER ▁( ▁re ▁, ▁gb ▁) ▁; ▁if ▁( ▁buf ▁& ▁1 ▁) ▁buf ▁= ▁- ▁( ▁buf ▁>> ▁1 ▁) ▁; ▁else ▁buf ▁= ▁( ▁buf ▁>> ▁1 ▁) ▁; ▁return ▁buf ▁; ▁} ▁}	1
▁int ▁show _ help ▁( ▁void ▁* ▁opt ctx ▁, ▁const ▁char ▁* ▁opt ▁, ▁const ▁char ▁* ▁arg ▁) ▁{ ▁char ▁* ▁topic ▁, ▁* ▁par ▁; ▁av _ log _ set _ callback ▁( ▁log _ callback _ help ▁) ▁; ▁topic ▁= ▁av _ strdup ▁( ▁arg ▁? ▁arg ▁: ▁"" ▁) ▁; ▁if ▁( ▁! ▁topic ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁par ▁= ▁strchr ▁( ▁topic ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁par ▁) ▁* ▁par ▁++ ▁= ▁0 ▁; ▁if ▁( ▁! ▁* ▁topic ▁) ▁{ ▁show _ help _ default ▁( ▁topic ▁, ▁par ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" decoder " ▁) ▁) ▁{ ▁show _ help _ codec ▁( ▁par ▁, ▁0 ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" encoder " ▁) ▁) ▁{ ▁show _ help _ codec ▁( ▁par ▁, ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" demuxer " ▁) ▁) ▁{ ▁show _ help _ demuxer ▁( ▁par ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" mux er " ▁) ▁) ▁{ ▁show _ help _ mux er ▁( ▁par ▁) ▁; ▁# if ▁CONFIG _ AV FILTER ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁topic ▁, ▁" filter " ▁) ▁) ▁{ ▁show _ help _ filter ▁( ▁par ▁) ▁; ▁# endif ▁} else { ▁show _ help _ default ▁( ▁topic ▁, ▁par ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁topic ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁const ▁void ▁* ▁OBJ _ b search _ ex _ ▁( ▁const ▁void ▁* ▁key ▁, ▁const ▁void ▁* ▁base _ ▁, ▁int ▁num ▁, ▁int ▁size ▁, ▁int ▁( ▁* ▁cmp ▁) ▁( ▁const ▁void ▁* ▁, ▁const ▁void ▁* ▁) ▁, ▁int ▁flags ▁) ▁{ ▁const ▁char ▁* ▁base ▁= ▁base _ ▁; ▁int ▁l ▁, ▁h ▁, ▁i ▁= ▁0 ▁, ▁c ▁= ▁0 ▁; ▁const ▁char ▁* ▁p ▁= ▁NULL ▁; ▁if ▁( ▁num ▁== ▁0 ▁) ▁return ▁( ▁NULL ▁) ▁; ▁l ▁= ▁0 ▁; ▁h ▁= ▁num ▁; ▁while ▁( ▁l ▁< ▁h ▁) ▁{ ▁i ▁= ▁( ▁l ▁+ ▁h ▁) ▁/ ▁2 ▁; ▁p ▁= ▁& ▁( ▁base ▁[ ▁i ▁* ▁size ▁] ▁) ▁; ▁c ▁= ▁( ▁* ▁cmp ▁) ▁( ▁key ▁, ▁p ▁) ▁; ▁if ▁( ▁c ▁< ▁0 ▁) ▁h ▁= ▁i ▁; ▁else ▁if ▁( ▁c ▁> ▁0 ▁) ▁l ▁= ▁i ▁+ ▁1 ▁; ▁else ▁break ▁; ▁} ▁# ifdef ▁CHARSET _ EBCDIC ▁if ▁( ▁c ▁!= ▁0 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁; ▁++ ▁i ▁) ▁{ ▁p ▁= ▁& ▁( ▁base ▁[ ▁i ▁* ▁size ▁] ▁) ▁; ▁c ▁= ▁( ▁* ▁cmp ▁) ▁( ▁key ▁, ▁p ▁) ▁; ▁if ▁( ▁c ▁== ▁0 ▁|| ▁( ▁c ▁< ▁0 ▁&& ▁( ▁flags ▁& ▁OBJ _ B SEARCH _ VALUE _ ON _ NOMATCH ▁) ▁) ▁) ▁return ▁p ▁; ▁} ▁} ▁# endif ▁if ▁( ▁c ▁!= ▁0 ▁&& ▁! ▁( ▁flags ▁& ▁OBJ _ B SEARCH _ VALUE _ ON _ NOMATCH ▁) ▁) ▁p ▁= ▁NULL ▁; ▁else ▁if ▁( ▁c ▁== ▁0 ▁&& ▁( ▁flags ▁& ▁OBJ _ B SEARCH _ FIRST _ VALUE _ ON _ MATCH ▁) ▁) ▁{ ▁while ▁( ▁i ▁> ▁0 ▁&& ▁( ▁* ▁cmp ▁) ▁( ▁key ▁, ▁& ▁( ▁base ▁[ ▁( ▁i ▁- ▁1 ▁) ▁* ▁size ▁] ▁) ▁) ▁== ▁0 ▁) ▁i ▁-- ▁; ▁p ▁= ▁& ▁( ▁base ▁[ ▁i ▁* ▁size ▁] ▁) ▁; ▁} ▁return ▁( ▁p ▁) ▁; ▁}	1
▁int ▁ff _ init _ filters ▁( ▁S ws Context ▁* ▁c ▁) ▁{ ▁int ▁i ▁; ▁int ▁index ▁; ▁int ▁num _ y desc ▁; ▁int ▁num _ c desc ▁; ▁int ▁num _ v desc ▁= ▁is Planar YUV ▁( ▁c ▁-> ▁dst Format ▁) ▁&& ▁! ▁is Gray ▁( ▁c ▁-> ▁dst Format ▁) ▁? ▁2 ▁: ▁1 ▁; ▁int ▁need _ l um _ conv ▁= ▁c ▁-> ▁lum To Y V 12 ▁|| ▁c ▁-> ▁read L um Planar ▁|| ▁c ▁-> ▁alp To Y V 12 ▁|| ▁c ▁-> ▁read Al p Planar ▁; ▁int ▁need _ chr _ conv ▁= ▁c ▁-> ▁chr To Y V 12 ▁|| ▁c ▁-> ▁read Ch r Planar ▁; ▁int ▁src Idx ▁, ▁dst Idx ▁; ▁int ▁dst _ stride ▁= ▁FF ALIGN ▁( ▁c ▁-> ▁dst W ▁* ▁sizeof ▁( ▁int 16_ t ▁) ▁+ ▁66 ▁, ▁16 ▁) ▁; ▁uint 32_ t ▁* ▁pal ▁= ▁use Pal ▁( ▁c ▁-> ▁src Format ▁) ▁? ▁c ▁-> ▁pal _ yuv ▁: ▁( ▁uint 32_ t ▁* ▁) ▁c ▁-> ▁input _ rgb 2 yuv _ table ▁; ▁int ▁res ▁= ▁0 ▁; ▁if ▁( ▁c ▁-> ▁dst B pc ▁== ▁16 ▁) ▁dst _ stride ▁<<= ▁1 ▁; ▁num _ y desc ▁= ▁need _ l um _ conv ▁? ▁2 ▁: ▁1 ▁; ▁num _ c desc ▁= ▁need _ chr _ conv ▁? ▁2 ▁: ▁1 ▁; ▁c ▁-> ▁num Slice ▁= ▁FF MAX ▁( ▁num _ y desc ▁, ▁num _ c desc ▁) ▁+ ▁2 ▁; ▁c ▁-> ▁num Desc ▁= ▁num _ y desc ▁+ ▁num _ c desc ▁+ ▁num _ v desc ▁; ▁c ▁-> ▁desc Index ▁[ ▁0 ▁] ▁= ▁num _ y desc ▁; ▁c ▁-> ▁desc Index ▁[ ▁1 ▁] ▁= ▁num _ y desc ▁+ ▁num _ c desc ▁; ▁c ▁-> ▁desc ▁= ▁av _ malloc z _ array ▁( ▁sizeof ▁( ▁S ws Filter Descriptor ▁) ▁, ▁c ▁-> ▁num Desc ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁desc ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁c ▁-> ▁slice ▁= ▁av _ malloc z _ array ▁( ▁sizeof ▁( ▁S ws Slice ▁) ▁, ▁c ▁-> ▁num Slice ▁) ▁; ▁res ▁= ▁alloc _ slice ▁( ▁& ▁c ▁-> ▁slice ▁[ ▁0 ▁] ▁, ▁c ▁-> ▁src Format ▁, ▁c ▁-> ▁src H ▁, ▁c ▁-> ▁chr Src H ▁, ▁c ▁-> ▁chr Src H Sub Sample ▁, ▁c ▁-> ▁chr Src V Sub Sample ▁, ▁0 ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁goto ▁cleanup ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁c ▁-> ▁num Slice ▁- ▁2 ▁; ▁++ ▁i ▁) ▁{ ▁res ▁= ▁alloc _ slice ▁( ▁& ▁c ▁-> ▁slice ▁[ ▁i ▁] ▁, ▁c ▁-> ▁src Format ▁, ▁c ▁-> ▁v L um Filter Size ▁+ ▁MAX _ LINES _ A HEAD ▁, ▁c ▁-> ▁v Ch r Filter Size ▁+ ▁MAX _ LINES _ A HEAD ▁, ▁c ▁-> ▁chr Src H Sub Sample ▁, ▁c ▁-> ▁chr Src V Sub Sample ▁, ▁0 ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁goto ▁cleanup ▁; ▁res ▁= ▁alloc _ lines ▁( ▁& ▁c ▁-> ▁slice ▁[ ▁i ▁] ▁, ▁FF ALIGN ▁( ▁c ▁-> ▁src W ▁* ▁2 ▁+ ▁78 ▁, ▁16 ▁) ▁, ▁c ▁-> ▁src W ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁goto ▁cleanup ▁; ▁} ▁res ▁= ▁alloc _ slice ▁( ▁& ▁c ▁-> ▁slice ▁[ ▁i ▁] ▁, ▁c ▁-> ▁src Format ▁, ▁c ▁-> ▁v L um Filter Size ▁+ ▁MAX _ LINES _ A HEAD ▁, ▁c ▁-> ▁v Ch r Filter Size ▁+ ▁MAX _ LINES _ A HEAD ▁, ▁c ▁-> ▁chr Dst H Sub Sample ▁, ▁c ▁-> ▁chr Dst V Sub Sample ▁, ▁1 ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁goto ▁cleanup ▁; ▁res ▁= ▁alloc _ lines ▁( ▁& ▁c ▁-> ▁slice ▁[ ▁i ▁] ▁, ▁dst _ stride ▁, ▁c ▁-> ▁dst W ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁goto ▁cleanup ▁; ▁fill _ ones ▁( ▁& ▁c ▁-> ▁slice ▁[ ▁i ▁] ▁, ▁dst _ stride ▁>> ▁1 ▁, ▁c ▁-> ▁dst B pc ▁== ▁16 ▁) ▁; ▁++ ▁i ▁; ▁res ▁= ▁alloc _ slice ▁( ▁& ▁c ▁-> ▁slice ▁[ ▁i ▁] ▁, ▁c ▁-> ▁dst Format ▁, ▁c ▁-> ▁dst H ▁, ▁c ▁-> ▁chr Dst H ▁, ▁c ▁-> ▁chr Dst H Sub Sample ▁, ▁c ▁-> ▁chr Dst V Sub Sample ▁, ▁0 ▁) ▁; ▁if ▁( ▁res ▁< ▁0 ▁) ▁goto ▁cleanup ▁; ▁index ▁= ▁0 ▁; ▁src Idx ▁= ▁0 ▁; ▁dst Idx ▁= ▁1 ▁; ▁if ▁( ▁need _ l um _ conv ▁) ▁{ ▁ff _ init _ desc _ fmt _ convert ▁( ▁& ▁c ▁-> ▁desc ▁[ ▁index ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁src Idx ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁dst Idx ▁] ▁, ▁pal ▁) ▁; ▁c ▁-> ▁desc ▁[ ▁index ▁] ▁. ▁alpha ▁= ▁c ▁-> ▁alp Pix Buf ▁!= ▁0 ▁; ▁++ ▁index ▁; ▁src Idx ▁= ▁dst Idx ▁; ▁} ▁dst Idx ▁= ▁FF MAX ▁( ▁num _ y desc ▁, ▁num _ c desc ▁) ▁; ▁ff _ init _ desc _ h scale ▁( ▁& ▁c ▁-> ▁desc ▁[ ▁index ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁index ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁dst Idx ▁] ▁, ▁c ▁-> ▁h L um Filter ▁, ▁c ▁-> ▁h L um Filter Pos ▁, ▁c ▁-> ▁h L um Filter Size ▁, ▁c ▁-> ▁lum X Inc ▁) ▁; ▁c ▁-> ▁desc ▁[ ▁index ▁] ▁. ▁alpha ▁= ▁c ▁-> ▁alp Pix Buf ▁!= ▁0 ▁; ▁++ ▁index ▁; ▁{ ▁src Idx ▁= ▁0 ▁; ▁dst Idx ▁= ▁1 ▁; ▁if ▁( ▁need _ chr _ conv ▁) ▁{ ▁ff _ init _ desc _ c fmt _ convert ▁( ▁& ▁c ▁-> ▁desc ▁[ ▁index ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁src Idx ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁dst Idx ▁] ▁, ▁pal ▁) ▁; ▁++ ▁index ▁; ▁src Idx ▁= ▁dst Idx ▁; ▁} ▁dst Idx ▁= ▁FF MAX ▁( ▁num _ y desc ▁, ▁num _ c desc ▁) ▁; ▁if ▁( ▁c ▁-> ▁needs _ hc scale ▁) ▁ff _ init _ desc _ ch scale ▁( ▁& ▁c ▁-> ▁desc ▁[ ▁index ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁src Idx ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁dst Idx ▁] ▁, ▁c ▁-> ▁h Ch r Filter ▁, ▁c ▁-> ▁h Ch r Filter Pos ▁, ▁c ▁-> ▁h Ch r Filter Size ▁, ▁c ▁-> ▁chr X Inc ▁) ▁; ▁else ▁ff _ init _ desc _ no _ chr ▁( ▁& ▁c ▁-> ▁desc ▁[ ▁index ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁src Idx ▁] ▁, ▁& ▁c ▁-> ▁slice ▁[ ▁dst Idx ▁] ▁) ▁; ▁} ▁++ ▁index ▁; ▁{ ▁src Idx ▁= ▁c ▁-> ▁num Slice ▁- ▁2 ▁; ▁dst Idx ▁= ▁c ▁-> ▁num Slice ▁- ▁1 ▁; ▁ff _ init _ v scale ▁( ▁c ▁, ▁c ▁-> ▁desc ▁+ ▁index ▁, ▁c ▁-> ▁slice ▁+ ▁src Idx ▁, ▁c ▁-> ▁slice ▁+ ▁dst Idx ▁) ▁; ▁} ▁return ▁0 ▁; ▁cleanup ▁: ▁ff _ free _ filters ▁( ▁c ▁) ▁; ▁return ▁res ▁; ▁}	1
▁int ▁test _ gf 2 m _ mod _ exp ▁( ▁BIO ▁* ▁bp ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁[ ▁2 ▁] ▁, ▁* ▁c ▁, ▁* ▁d ▁, ▁* ▁e ▁, ▁* ▁f ▁; ▁int ▁i ▁, ▁j ▁, ▁ret ▁= ▁0 ▁; ▁int ▁p 0 ▁[ ▁] ▁= ▁{ ▁16 3 ▁, ▁7 ▁, ▁6 ▁, ▁3 ▁, ▁0 ▁, ▁-1 ▁} ▁; ▁int ▁p 1 ▁[ ▁] ▁= ▁{ ▁19 3 ▁, ▁15 ▁, ▁0 ▁, ▁-1 ▁} ▁; ▁a ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁[ ▁0 ▁] ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁[ ▁1 ▁] ▁= ▁BN _ new ▁( ▁) ▁; ▁c ▁= ▁BN _ new ▁( ▁) ▁; ▁d ▁= ▁BN _ new ▁( ▁) ▁; ▁e ▁= ▁BN _ new ▁( ▁) ▁; ▁f ▁= ▁BN _ new ▁( ▁) ▁; ▁BN _ GF 2 m _ arr 2 poly ▁( ▁p 0 ▁, ▁b ▁[ ▁0 ▁] ▁) ▁; ▁BN _ GF 2 m _ arr 2 poly ▁( ▁p 1 ▁, ▁b ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num 0 ▁; ▁i ▁++ ▁) ▁{ ▁BN _ bn test _ rand ▁( ▁a ▁, ▁512 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁BN _ bn test _ rand ▁( ▁c ▁, ▁512 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁BN _ bn test _ rand ▁( ▁d ▁, ▁512 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁BN _ GF 2 m _ mod _ exp ▁( ▁e ▁, ▁a ▁, ▁c ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁BN _ GF 2 m _ mod _ exp ▁( ▁f ▁, ▁a ▁, ▁d ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁BN _ GF 2 m _ mod _ mul ▁( ▁e ▁, ▁e ▁, ▁f ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁BN _ add ▁( ▁f ▁, ▁c ▁, ▁d ▁) ▁; ▁BN _ GF 2 m _ mod _ exp ▁( ▁f ▁, ▁a ▁, ▁f ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁# if ▁0 ▁if ▁( ▁bp ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁results ▁) ▁{ ▁BN _ print ▁( ▁bp ▁, ▁a ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁" ^ (" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁c ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"+" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁d ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁") =" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁e ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"; -" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁f ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"%" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁b ▁[ ▁j ▁] ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"\ n " ▁) ▁; ▁} ▁} ▁# endif ▁BN _ GF 2 m _ add ▁( ▁f ▁, ▁e ▁, ▁f ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ zero ▁( ▁f ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" GF (2 ^ m ) mod ul are x ponent iation test failed !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁} ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ free ▁( ▁a ▁) ▁; ▁BN _ free ▁( ▁b ▁[ ▁0 ▁] ▁) ▁; ▁BN _ free ▁( ▁b ▁[ ▁1 ▁] ▁) ▁; ▁BN _ free ▁( ▁c ▁) ▁; ▁BN _ free ▁( ▁d ▁) ▁; ▁BN _ free ▁( ▁e ▁) ▁; ▁BN _ free ▁( ▁f ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁void ▁* ▁OPENSSL _ SA _ get ▁( ▁const ▁OPENSSL _ SA ▁* ▁sa ▁, ▁ossl _ uint max _ t ▁n ▁) ▁{ ▁int ▁level ▁; ▁void ▁* ▁* ▁p ▁, ▁* ▁r ▁= ▁NULL ▁; ▁if ▁( ▁sa ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁n ▁<= ▁sa ▁-> ▁top ▁) ▁{ ▁p ▁= ▁sa ▁-> ▁nodes ▁; ▁for ▁( ▁level ▁= ▁sa ▁-> ▁levels ▁- ▁1 ▁; ▁p ▁!= ▁NULL ▁&& ▁level ▁> ▁0 ▁; ▁level ▁-- ▁) ▁p ▁= ▁( ▁void ▁* ▁* ▁) ▁p ▁[ ▁( ▁n ▁>> ▁( ▁OPENSSL _ SA _ BLOCK _ BITS ▁* ▁level ▁) ▁) ▁& ▁SA _ BLOCK _ MASK ▁] ▁; ▁r ▁= ▁p ▁== ▁NULL ▁? ▁NULL ▁: ▁p ▁[ ▁n ▁& ▁SA _ BLOCK _ MASK ▁] ▁; ▁} ▁return ▁r ▁; ▁}	1
▁void ▁CRYPTO _ cbc 128_ encrypt ▁( ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁size _ t ▁len ▁, ▁const ▁void ▁* ▁key ▁, ▁unsigned ▁char ▁ivec ▁[ ▁16 ▁] ▁, ▁block 128_ f ▁block ▁) ▁{ ▁size _ t ▁n ▁; ▁const ▁unsigned ▁char ▁* ▁iv ▁= ▁ivec ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁return ▁; ▁# if ▁! ▁defined ▁( ▁OPENSSL _ SMALL _ F OOT PRINT ▁) ▁if ▁( ▁STRICT _ ALIGNMENT ▁&& ▁( ▁( ▁size _ t ▁) ▁in ▁| ▁( ▁size _ t ▁) ▁out ▁| ▁( ▁size _ t ▁) ▁ivec ▁) ▁% ▁sizeof ▁( ▁size _ t ▁) ▁!= ▁0 ▁) ▁{ ▁while ▁( ▁len ▁>= ▁16 ▁) ▁{ ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁16 ▁; ▁++ ▁n ▁) ▁out ▁[ ▁n ▁] ▁= ▁in ▁[ ▁n ▁] ▁ ^ ▁iv ▁[ ▁n ▁] ▁; ▁( ▁* ▁block ▁) ▁( ▁out ▁, ▁out ▁, ▁key ▁) ▁; ▁iv ▁= ▁out ▁; ▁len ▁-= ▁16 ▁; ▁in ▁+= ▁16 ▁; ▁out ▁+= ▁16 ▁; ▁} ▁} ▁else ▁{ ▁while ▁( ▁len ▁>= ▁16 ▁) ▁{ ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁16 ▁; ▁n ▁+= ▁sizeof ▁( ▁size _ t ▁) ▁) ▁* ▁( ▁size _ t ▁* ▁) ▁( ▁out ▁+ ▁n ▁) ▁= ▁* ▁( ▁size _ t ▁* ▁) ▁( ▁in ▁+ ▁n ▁) ▁ ^ ▁* ▁( ▁size _ t ▁* ▁) ▁( ▁iv ▁+ ▁n ▁) ▁; ▁( ▁* ▁block ▁) ▁( ▁out ▁, ▁out ▁, ▁key ▁) ▁; ▁iv ▁= ▁out ▁; ▁len ▁-= ▁16 ▁; ▁in ▁+= ▁16 ▁; ▁out ▁+= ▁16 ▁; ▁} ▁} ▁# endif ▁while ▁( ▁len ▁) ▁{ ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁16 ▁&& ▁n ▁< ▁len ▁; ▁++ ▁n ▁) ▁out ▁[ ▁n ▁] ▁= ▁in ▁[ ▁n ▁] ▁ ^ ▁iv ▁[ ▁n ▁] ▁; ▁for ▁( ▁; ▁n ▁< ▁16 ▁; ▁++ ▁n ▁) ▁out ▁[ ▁n ▁] ▁= ▁iv ▁[ ▁n ▁] ▁; ▁( ▁* ▁block ▁) ▁( ▁out ▁, ▁out ▁, ▁key ▁) ▁; ▁iv ▁= ▁out ▁; ▁if ▁( ▁len ▁<= ▁16 ▁) ▁break ▁; ▁len ▁-= ▁16 ▁; ▁in ▁+= ▁16 ▁; ▁out ▁+= ▁16 ▁; ▁} ▁memcpy ▁( ▁ivec ▁, ▁iv ▁, ▁16 ▁) ▁; ▁}	1
▁static ▁void ▁new _ audio _ stream ▁( ▁AVFormatContext ▁* ▁oc ▁, ▁int ▁file _ idx ▁) ▁{ ▁AVStream ▁* ▁st ▁; ▁AV OutputStream ▁* ▁o st ▁; ▁AVCodec ▁* ▁codec ▁= ▁NULL ▁; ▁AVCodecContext ▁* ▁audio _ enc ▁; ▁enum ▁Codec ID ▁codec _ id ▁= ▁CODEC _ ID _ NONE ▁; ▁st ▁= ▁av _ new _ stream ▁( ▁oc ▁, ▁oc ▁-> ▁nb _ streams ▁< ▁nb _ stream id _ map ▁? ▁stream id _ map ▁[ ▁oc ▁-> ▁nb _ streams ▁] ▁: ▁0 ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Could not alloc stream \ n " ▁) ▁; ▁ffmpeg _ exit ▁( ▁1 ▁) ▁; ▁} ▁o st ▁= ▁new _ output _ stream ▁( ▁oc ▁, ▁file _ idx ▁) ▁; ▁output _ codecs ▁= ▁grow _ array ▁( ▁output _ codecs ▁, ▁sizeof ▁( ▁* ▁output _ codecs ▁) ▁, ▁& ▁nb _ output _ codecs ▁, ▁nb _ output _ codecs ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁audio _ stream _ copy ▁) ▁{ ▁if ▁( ▁audio _ codec _ name ▁) ▁{ ▁codec _ id ▁= ▁find _ codec _ or _ die ▁( ▁audio _ codec _ name ▁, ▁AVMEDIA _ TYPE _ AUDIO ▁, ▁1 ▁, ▁avcodec _ opts ▁[ ▁AVMEDIA _ TYPE _ AUDIO ▁] ▁-> ▁strict _ std _ comp liance ▁) ▁; ▁codec ▁= ▁avcodec _ find _ encoder _ by _ name ▁( ▁audio _ codec _ name ▁) ▁; ▁output _ codecs ▁[ ▁nb _ output _ codecs ▁- ▁1 ▁] ▁= ▁codec ▁; ▁} ▁else ▁{ ▁codec _ id ▁= ▁av _ guess _ codec ▁( ▁oc ▁-> ▁of orm at ▁, ▁NULL ▁, ▁oc ▁-> ▁filename ▁, ▁NULL ▁, ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁; ▁codec ▁= ▁avcodec _ find _ encoder ▁( ▁codec _ id ▁) ▁; ▁} ▁} ▁avcodec _ get _ context _ defaults 3 ▁( ▁st ▁-> ▁codec ▁, ▁codec ▁) ▁; ▁o st ▁-> ▁bitstream _ filters ▁= ▁audio _ bit stream _ filters ▁; ▁audio _ bit stream _ filters ▁= ▁NULL ▁; ▁avcodec _ thread _ init ▁( ▁st ▁-> ▁codec ▁, ▁thread _ count ▁) ▁; ▁audio _ enc ▁= ▁st ▁-> ▁codec ▁; ▁audio _ enc ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁if ▁( ▁audio _ codec _ tag ▁) ▁audio _ enc ▁-> ▁codec _ tag ▁= ▁audio _ codec _ tag ▁; ▁if ▁( ▁oc ▁-> ▁of orm at ▁-> ▁flags ▁& ▁AV FMT _ GLOBAL HEADER ▁) ▁{ ▁audio _ enc ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ GLOBAL _ HEADER ▁; ▁avcodec _ opts ▁[ ▁AVMEDIA _ TYPE _ AUDIO ▁] ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ GLOBAL _ HEADER ▁; ▁} ▁if ▁( ▁audio _ stream _ copy ▁) ▁{ ▁st ▁-> ▁stream _ copy ▁= ▁1 ▁; ▁audio _ enc ▁-> ▁channels ▁= ▁audio _ channels ▁; ▁audio _ enc ▁-> ▁sample _ rate ▁= ▁audio _ sample _ rate ▁; ▁} ▁else ▁{ ▁audio _ enc ▁-> ▁codec _ id ▁= ▁codec _ id ▁; ▁set _ context _ opts ▁( ▁audio _ enc ▁, ▁avcodec _ opts ▁[ ▁AVMEDIA _ TYPE _ AUDIO ▁] ▁, ▁AV _ OPT _ FLAG _ AUDIO _ PARAM ▁| ▁AV _ OPT _ FLAG _ ENCODING _ PARAM ▁, ▁codec ▁) ▁; ▁if ▁( ▁audio _ q scale ▁> ▁Q SCALE _ NONE ▁) ▁{ ▁audio _ enc ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ Q SCALE ▁; ▁audio _ enc ▁-> ▁global _ quality ▁= ▁st ▁-> ▁quality ▁= ▁FF _ QP 2 L AMBDA ▁* ▁audio _ q scale ▁; ▁} ▁audio _ enc ▁-> ▁channels ▁= ▁audio _ channels ▁; ▁audio _ enc ▁-> ▁sample _ fmt ▁= ▁audio _ sample _ fmt ▁; ▁audio _ enc ▁-> ▁sample _ rate ▁= ▁audio _ sample _ rate ▁; ▁audio _ enc ▁-> ▁channel _ layout ▁= ▁channel _ layout ▁; ▁if ▁( ▁av _ get _ channel _ layout _ nb _ channels ▁( ▁channel _ layout ▁) ▁!= ▁audio _ channels ▁) ▁audio _ enc ▁-> ▁channel _ layout ▁= ▁0 ▁; ▁choose _ sample _ fmt ▁( ▁st ▁, ▁codec ▁) ▁; ▁choose _ sample _ rate ▁( ▁st ▁, ▁codec ▁) ▁; ▁} ▁audio _ enc ▁-> ▁time _ base ▁= ▁( ▁AVR ational ▁) ▁{ ▁1 ▁, ▁audio _ sample _ rate ▁} ▁; ▁if ▁( ▁audio _ language ▁) ▁{ ▁av _ metadata _ set 2 ▁( ▁& ▁st ▁-> ▁metadata ▁, ▁" language " ▁, ▁audio _ language ▁, ▁0 ▁) ▁; ▁av _ freep ▁( ▁& ▁audio _ language ▁) ▁; ▁} ▁audio _ disable ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁audio _ codec _ name ▁) ▁; ▁audio _ stream _ copy ▁= ▁0 ▁; ▁}	0
▁static ▁int ▁test _ mode xp _ mont 5 ▁( ▁void ▁) ▁{ ▁BIGNUM ▁* ▁a ▁= ▁NULL ▁, ▁* ▁p ▁= ▁NULL ▁, ▁* ▁m ▁= ▁NULL ▁, ▁* ▁d ▁= ▁NULL ▁, ▁* ▁e ▁= ▁NULL ▁; ▁BIGNUM ▁* ▁b ▁= ▁NULL ▁, ▁* ▁n ▁= ▁NULL ▁, ▁* ▁c ▁= ▁NULL ▁; ▁BN _ M ONT _ CTX ▁* ▁m ont ▁= ▁NULL ▁; ▁int ▁st ▁= ▁0 ▁; ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁a ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁p ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁m ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁d ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁e ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁b ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁n ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁c ▁= ▁BN _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁m ont ▁= ▁BN _ M ONT _ CTX _ new ▁( ▁) ▁) ▁) ▁goto ▁err ▁; ▁BN _ bn test _ rand ▁( ▁m ▁, ▁1024 ▁, ▁0 ▁, ▁1 ▁) ▁; ▁BN _ bn test _ rand ▁( ▁a ▁, ▁1024 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁BN _ zero ▁( ▁p ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁BN _ mod _ exp _ mont _ const time ▁( ▁d ▁, ▁a ▁, ▁p ▁, ▁m ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁TEST _ BN _ eq _ one ▁( ▁d ▁) ▁) ▁goto ▁err ▁; ▁BN _ hex 2 bn ▁( ▁& ▁a ▁, ▁" 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 " ▁" 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 " ▁" 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 " ▁" 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 78 " ▁) ▁; ▁BN _ hex 2 bn ▁( ▁& ▁b ▁, ▁" 09 5 D 72 C 08 C 09 7 BA 4 88 C 5 E 4 39 C 655 A 192 E AF B 6 38 00 73 D 8 C 26 64 66 8 ED DB 406 07 44 " ▁" E 16 E 57 FB 4 ED B 9 AE 10 A 0 CE F CDC 28 A 89 4 F 6 89 A 128 379 DB 27 9 D 48 A 2 E 20 84 9 D 6 85 93" ▁"9 B 7 803 B CF 46 CE BF 5 C 5 33 FB 0 DD 35 B 080 5 93 DE 54 72 E 3 FE 5 DB 95 1 B 8 B FF 9 B 4 CB 8 F 03" ▁"9 CC 6 38 A 5 EE 8 CD D 7 037 19 F 8000 E 6 A 9 F 63 BE ED 5 F 2 F CD 52 FF 29 3 EA 05 A 251 BB 4 AB 8 1" ▁) ▁; ▁BN _ hex 2 bn ▁( ▁& ▁n ▁, ▁" D 78 AF 684 E 71 DB 0 C 39 C FF 4 E 64 FB 9 DB 56 71 32 CB 9 C 50 CC 98 009 FE B 820 B 26 F 2 DED 9 B " ▁" 91 B 9 B 5 E 2 B 83 AE 0 AE 4 EB 4 E 05 23 CA 726 BF BE 969 B 89 FD 754 F 6 74 CE 99 118 C 3 F 2 D 1 C 5" ▁" D 81 FDC 7 C 54 E 02 B 6 02 62 B 24 1 D 53 C 040 E 99 E 45 826 EC A 37 A 804 66 8 E 6 90 E 1 A FC 1 CA 4" ▁"2 C 9 A 15 D 84 D 49 5 44 25 F 0 B 764 2 FC 0 BD 9 D 7 B 24 E 26 18 D 2 DCC 9 B 7 29 D 9 44 BAD AC FD DA F " ▁) ▁; ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁n ▁, ▁ctx ▁) ▁; ▁BN _ mod _ mul _ mon tg om ery ▁( ▁c ▁, ▁a ▁, ▁b ▁, ▁m ont ▁, ▁ctx ▁) ▁; ▁BN _ mod _ mul _ mon tg om ery ▁( ▁d ▁, ▁b ▁, ▁a ▁, ▁m ont ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁TEST _ BN _ eq ▁( ▁c ▁, ▁d ▁) ▁) ▁goto ▁err ▁; ▁parse _ big BN ▁( ▁& ▁n ▁, ▁bn 1 strings ▁) ▁; ▁parse _ big BN ▁( ▁& ▁a ▁, ▁bn 2 strings ▁) ▁; ▁BN _ free ▁( ▁b ▁) ▁; ▁b ▁= ▁BN _ dup ▁( ▁a ▁) ▁; ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁n ▁, ▁ctx ▁) ▁; ▁BN _ mod _ mul _ mon tg om ery ▁( ▁c ▁, ▁a ▁, ▁a ▁, ▁m ont ▁, ▁ctx ▁) ▁; ▁BN _ mod _ mul _ mon tg om ery ▁( ▁d ▁, ▁a ▁, ▁b ▁, ▁m ont ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁TEST _ BN _ eq ▁( ▁c ▁, ▁d ▁) ▁) ▁goto ▁err ▁; ▁{ ▁static ▁const ▁char ▁* ▁a hex ▁[ ▁] ▁= ▁{ ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF F 8 FF EAD B CF C 4 DA E 7 FFF 9 08 E 9 28 20 306 B " ▁, ▁" 95 44 D 954 00000000 6 C 0000000000000000 0000000000000000 00000000000000 " ▁, ▁" 0000000000000000 0000 FF 03 02 02 FFFFF 8 FF EB DB CF C 4 DA E 7 FFF 9 08 E 9 28 20 306 B " ▁, ▁" 95 44 D 954 00000000 6 C 000000 FF 03 02 03 0000000000 FFFFFFFF FFFFFFFFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFF 01 FC 00 FF 02 FFFFFFFF " ▁, ▁"00 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 00 F CF D " ▁, ▁" FC FFFFFFFF FF 000000000000 000000 FF 03 02 03 0000000000 FFFFFFFF FFFFFFFF " ▁, ▁" FF 00 F CF DF D FF 03 02 02 FF 00000000 FFFFFFFF FFFFFFFF FF 00 F CF D FC FFFFFFFF FF " ▁, ▁NULL ▁} ▁; ▁static ▁const ▁char ▁* ▁n hex ▁[ ▁] ▁= ▁{ ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFF 8 F 8 F 8 F 8000000 " ▁, ▁" 0000001 00000000 06 C 0000000000000000 0000000000000000 00000000000000 " ▁, ▁" 0000000000000000 0000000000000000 000000 FFFFFFFF FFFFF 8 F 8 F 8 F 8000000 " ▁, ▁" 0000001 00000000 06 C 0000000000000000 00000000 FFFFFFFF FFFFFFFFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁, ▁"00 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFF " ▁, ▁" FFFFFFFF FFFF 0000000000000000 0000000000000000 0000 FFFFFFFF FFFFFFFF " ▁, ▁" FFFFFFFF FFFFFFFF FFFF 00000000 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFF " ▁, ▁NULL ▁} ▁; ▁parse _ big BN ▁( ▁& ▁a ▁, ▁a hex ▁) ▁; ▁parse _ big BN ▁( ▁& ▁n ▁, ▁n hex ▁) ▁; ▁} ▁BN _ free ▁( ▁b ▁) ▁; ▁b ▁= ▁BN _ dup ▁( ▁a ▁) ▁; ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁n ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁BN _ mod _ mul _ mon tg om ery ▁( ▁c ▁, ▁a ▁, ▁a ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁BN _ mod _ mul _ mon tg om ery ▁( ▁d ▁, ▁a ▁, ▁b ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁|| ▁! ▁TEST _ BN _ eq ▁( ▁c ▁, ▁d ▁) ▁) ▁goto ▁err ▁; ▁BN _ hex 2 bn ▁( ▁& ▁a ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁) ▁; ▁BN _ hex 2 bn ▁( ▁& ▁n ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁) ▁; ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁n ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁TEST _ false ▁( ▁BN _ mod _ mul _ mon tg om ery ▁( ▁d ▁, ▁a ▁, ▁a ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁) ▁goto ▁err ▁; ▁BN _ hex 2 bn ▁( ▁& ▁a ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFF 202 02 02 020 DF " ▁) ▁; ▁BN _ hex 2 bn ▁( ▁& ▁b ▁, ▁" 202 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 0" ▁" 202 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 0" ▁" 202 02 02 02 02 020 FF 202 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 0" ▁" 202 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 0" ▁) ▁; ▁BN _ hex 2 bn ▁( ▁& ▁n ▁, ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF " ▁" FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFF 202 02 02 020 FF " ▁) ▁; ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁n ▁, ▁ctx ▁) ▁; ▁BN _ mod _ exp _ mont _ const time ▁( ▁c ▁, ▁a ▁, ▁b ▁, ▁n ▁, ▁ctx ▁, ▁m ont ▁) ▁; ▁BN _ mod _ exp _ mont ▁( ▁d ▁, ▁a ▁, ▁b ▁, ▁n ▁, ▁ctx ▁, ▁m ont ▁) ▁; ▁if ▁( ▁! ▁TEST _ BN _ eq ▁( ▁c ▁, ▁d ▁) ▁) ▁goto ▁err ▁; ▁BN _ bn test _ rand ▁( ▁p ▁, ▁1024 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁BN _ zero ▁( ▁a ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁BN _ mod _ exp _ mont _ const time ▁( ▁d ▁, ▁a ▁, ▁p ▁, ▁m ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁|| ▁! ▁TEST _ BN _ eq _ zero ▁( ▁d ▁) ▁) ▁goto ▁err ▁; ▁BN _ one ▁( ▁a ▁) ▁; ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁m ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁BN _ from _ mon tg om ery ▁( ▁e ▁, ▁a ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁BN _ mod _ exp _ mont _ const time ▁( ▁d ▁, ▁e ▁, ▁p ▁, ▁m ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁BN _ mod _ exp _ simple ▁( ▁a ▁, ▁e ▁, ▁p ▁, ▁m ▁, ▁ctx ▁) ▁) ▁|| ▁! ▁TEST _ BN _ eq ▁( ▁a ▁, ▁d ▁) ▁) ▁goto ▁err ▁; ▁BN _ bn test _ rand ▁( ▁e ▁, ▁1024 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁TEST _ true ▁( ▁BN _ mod _ exp _ mont _ const time ▁( ▁d ▁, ▁e ▁, ▁p ▁, ▁m ▁, ▁ctx ▁, ▁NULL ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁BN _ mod _ exp _ simple ▁( ▁a ▁, ▁e ▁, ▁p ▁, ▁m ▁, ▁ctx ▁) ▁) ▁|| ▁! ▁TEST _ BN _ eq ▁( ▁a ▁, ▁d ▁) ▁) ▁goto ▁err ▁; ▁st ▁= ▁1 ▁; ▁err ▁: ▁BN _ M ONT _ CTX _ free ▁( ▁m ont ▁) ▁; ▁BN _ free ▁( ▁a ▁) ▁; ▁BN _ free ▁( ▁p ▁) ▁; ▁BN _ free ▁( ▁m ▁) ▁; ▁BN _ free ▁( ▁d ▁) ▁; ▁BN _ free ▁( ▁e ▁) ▁; ▁BN _ free ▁( ▁b ▁) ▁; ▁BN _ free ▁( ▁n ▁) ▁; ▁BN _ free ▁( ▁c ▁) ▁; ▁return ▁st ▁; ▁}	0
▁UI _ METHOD ▁* ▁UI _ create _ method ▁( ▁char ▁* ▁name ▁) ▁{ ▁UI _ METHOD ▁* ▁ui _ method ▁= ▁( ▁UI _ METHOD ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁UI _ METHOD ▁) ▁) ▁; ▁if ▁( ▁ui _ method ▁) ▁memset ▁( ▁ui _ method ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁ui _ method ▁) ▁) ▁; ▁ui _ method ▁-> ▁name ▁= ▁BUF _ strdup ▁( ▁name ▁) ▁; ▁return ▁ui _ method ▁; ▁}	1
▁static ▁void ▁m xf _ write _ generic _ desc ▁( ▁Byte IO Context ▁* ▁pb ▁, ▁const ▁MX F Descriptor Write TableEntry ▁* ▁desc _ tbl ▁, ▁AVStream ▁* ▁st ▁) ▁{ ▁MX F Stream Context ▁* ▁sc ▁= ▁st ▁-> ▁priv _ data ▁; ▁put _ buffer ▁( ▁pb ▁, ▁desc _ tbl ▁-> ▁key ▁, ▁16 ▁) ▁; ▁k lv _ encode _ ber _ length ▁( ▁pb ▁, ▁108 ▁) ▁; ▁m xf _ write _ local _ tag ▁( ▁pb ▁, ▁16 ▁, ▁0 x 3 C 0 A ▁) ▁; ▁m xf _ write _ uuid ▁( ▁pb ▁, ▁Sub Descriptor ▁, ▁st ▁-> ▁index ▁) ▁; ▁m xf _ write _ local _ tag ▁( ▁pb ▁, ▁4 ▁, ▁0 x 300 6 ▁) ▁; ▁put _ be 32 ▁( ▁pb ▁, ▁st ▁-> ▁index ▁) ▁; ▁m xf _ write _ local _ tag ▁( ▁pb ▁, ▁8 ▁, ▁0 x 3 001 ▁) ▁; ▁put _ be 32 ▁( ▁pb ▁, ▁st ▁-> ▁time _ base ▁. ▁den ▁) ▁; ▁put _ be 32 ▁( ▁pb ▁, ▁st ▁-> ▁time _ base ▁. ▁num ▁) ▁; ▁m xf _ write _ local _ tag ▁( ▁pb ▁, ▁16 ▁, ▁0 x 3 004 ▁) ▁; ▁put _ buffer ▁( ▁pb ▁, ▁* ▁sc ▁-> ▁ess ence _ container _ ul ▁, ▁16 ▁) ▁; ▁}	0
▁static ▁int ▁JPEG Decode Raw ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 8 ▁* ▁buf ▁, ▁tm size _ t ▁cc ▁, ▁uint 16 ▁s ▁) ▁{ ▁JPEG State ▁* ▁sp ▁= ▁J State ▁( ▁tif ▁) ▁; ▁tm size _ t ▁nrows ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁( ▁void ▁) ▁s ▁; ▁nrows ▁= ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁image _ height ▁; ▁if ▁( ▁( ▁uint 32 ▁) ▁nrows ▁> ▁td ▁-> ▁td _ image length ▁- ▁tif ▁-> ▁tif _ row ▁&& ▁! ▁is Tiled ▁( ▁tif ▁) ▁) ▁nrows ▁= ▁td ▁-> ▁td _ image length ▁- ▁tif ▁-> ▁tif _ row ▁; ▁if ▁( ▁nrows ▁!= ▁0 ▁) ▁{ ▁JDIMENSION ▁c lu mps _ per _ line ▁= ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁comp _ info ▁[ ▁1 ▁] ▁. ▁down sample d _ width ▁; ▁int ▁samples _ per _ clu mp ▁= ▁sp ▁-> ▁samples per clu mp ▁; ▁# if ▁defined ▁( ▁JPEG _ LIB _ MK 1_ OR _12 BIT ▁) ▁unsigned ▁short ▁* ▁tmpbuf ▁= ▁_ TIFF malloc ▁( ▁sizeof ▁( ▁unsigned ▁short ▁) ▁* ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁output _ width ▁* ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁num _ components ▁) ▁; ▁if ▁( ▁tmpbuf ▁== ▁NULL ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁" JPEG Decode Raw " ▁, ▁" Out of memory " ▁) ▁; ▁return ▁0 ▁; ▁} ▁# endif ▁do ▁{ ▁jpeg _ component _ info ▁* ▁comp ptr ▁; ▁int ▁ci ▁, ▁c lu mp offset ▁; ▁if ▁( ▁cc ▁< ▁sp ▁-> ▁bytes per line ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁" JPEG Decode Raw " ▁, ▁" application buffer not large en ough for all data ." ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁sp ▁-> ▁scan count ▁>= ▁DCTSIZE ▁) ▁{ ▁int ▁n ▁= ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁max _ v _ s amp _ factor ▁* ▁DCTSIZE ▁; ▁if ▁( ▁TIFF jpeg _ read _ raw _ data ▁( ▁sp ▁, ▁sp ▁-> ▁ds _ buffer ▁, ▁n ▁) ▁!= ▁n ▁) ▁return ▁( ▁0 ▁) ▁; ▁sp ▁-> ▁scan count ▁= ▁0 ▁; ▁} ▁c lu mp offset ▁= ▁0 ▁; ▁for ▁( ▁ci ▁= ▁0 ▁, ▁comp ptr ▁= ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁comp _ info ▁; ▁ci ▁< ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁num _ components ▁; ▁ci ▁++ ▁, ▁comp ptr ▁++ ▁) ▁{ ▁int ▁hs amp ▁= ▁comp ptr ▁-> ▁h _ s amp _ factor ▁; ▁int ▁vs amp ▁= ▁comp ptr ▁-> ▁v _ s amp _ factor ▁; ▁int ▁ypos ▁; ▁for ▁( ▁ypos ▁= ▁0 ▁; ▁ypos ▁< ▁vs amp ▁; ▁ypos ▁++ ▁) ▁{ ▁J SAMPLE ▁* ▁inptr ▁= ▁sp ▁-> ▁ds _ buffer ▁[ ▁ci ▁] ▁[ ▁sp ▁-> ▁scan count ▁* ▁vs amp ▁+ ▁ypos ▁] ▁; ▁JDIMENSION ▁n clu mp ▁; ▁# if ▁defined ▁( ▁JPEG _ LIB _ MK 1_ OR _12 BIT ▁) ▁J SAMPLE ▁* ▁outptr ▁= ▁( ▁J SAMPLE ▁* ▁) ▁tmpbuf ▁+ ▁c lu mp offset ▁; ▁# else ▁J SAMPLE ▁* ▁outptr ▁= ▁( ▁J SAMPLE ▁* ▁) ▁buf ▁+ ▁c lu mp offset ▁; ▁if ▁( ▁cc ▁< ▁( ▁c lu mp offset ▁+ ▁( ▁tm size _ t ▁) ▁samples _ per _ clu mp ▁* ▁( ▁c lu mps _ per _ line ▁- ▁1 ▁) ▁+ ▁hs amp ▁) ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁" JPEG Decode Raw " ▁, ▁" application buffer not large en ough for all data , possible sub sampling issue " ▁) ▁; ▁return ▁0 ▁; ▁} ▁# endif ▁if ▁( ▁hs amp ▁== ▁1 ▁) ▁{ ▁for ▁( ▁n clu mp ▁= ▁c lu mps _ per _ line ▁; ▁n clu mp ▁-- ▁> ▁0 ▁; ▁) ▁{ ▁outptr ▁[ ▁0 ▁] ▁= ▁* ▁inptr ▁++ ▁; ▁outptr ▁+= ▁samples _ per _ clu mp ▁; ▁} ▁} ▁else ▁{ ▁int ▁xpos ▁; ▁for ▁( ▁n clu mp ▁= ▁c lu mps _ per _ line ▁; ▁n clu mp ▁-- ▁> ▁0 ▁; ▁) ▁{ ▁for ▁( ▁xpos ▁= ▁0 ▁; ▁xpos ▁< ▁hs amp ▁; ▁xpos ▁++ ▁) ▁outptr ▁[ ▁xpos ▁] ▁= ▁* ▁inptr ▁++ ▁; ▁outptr ▁+= ▁samples _ per _ clu mp ▁; ▁} ▁} ▁c lu mp offset ▁+= ▁hs amp ▁; ▁} ▁} ▁# if ▁defined ▁( ▁JPEG _ LIB _ MK 1_ OR _12 BIT ▁) ▁{ ▁if ▁( ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁data _ precision ▁== ▁8 ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁int ▁len ▁= ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁output _ width ▁* ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁num _ components ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁( ▁( ▁unsigned ▁char ▁* ▁) ▁buf ▁) ▁[ ▁i ▁] ▁= ▁tmpbuf ▁[ ▁i ▁] ▁& ▁0 xff ▁; ▁} ▁} ▁else ▁{ ▁int ▁value _ pairs ▁= ▁( ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁output _ width ▁* ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁num _ components ▁) ▁/ ▁2 ▁; ▁int ▁i Pair ▁; ▁for ▁( ▁i Pair ▁= ▁0 ▁; ▁i Pair ▁< ▁value _ pairs ▁; ▁i Pair ▁++ ▁) ▁{ ▁unsigned ▁char ▁* ▁out _ ptr ▁= ▁( ▁( ▁unsigned ▁char ▁* ▁) ▁buf ▁) ▁+ ▁i Pair ▁* ▁3 ▁; ▁J SAMPLE ▁* ▁in _ ptr ▁= ▁( ▁J SAMPLE ▁* ▁) ▁( ▁tmpbuf ▁+ ▁i Pair ▁* ▁2 ▁) ▁; ▁out _ ptr ▁[ ▁0 ▁] ▁= ▁( ▁unsigned ▁char ▁) ▁( ▁( ▁in _ ptr ▁[ ▁0 ▁] ▁& ▁0 xff 0 ▁) ▁>> ▁4 ▁) ▁; ▁out _ ptr ▁[ ▁1 ▁] ▁= ▁( ▁unsigned ▁char ▁) ▁( ▁( ▁( ▁in _ ptr ▁[ ▁0 ▁] ▁& ▁0 xf ▁) ▁<< ▁4 ▁) ▁| ▁( ▁( ▁in _ ptr ▁[ ▁1 ▁] ▁& ▁0 xf 00 ▁) ▁>> ▁8 ▁) ▁) ▁; ▁out _ ptr ▁[ ▁2 ▁] ▁= ▁( ▁unsigned ▁char ▁) ▁( ▁( ▁( ▁in _ ptr ▁[ ▁1 ▁] ▁& ▁0 xff ▁) ▁>> ▁0 ▁) ▁) ▁; ▁} ▁} ▁} ▁# endif ▁sp ▁-> ▁scan count ▁++ ▁; ▁tif ▁-> ▁tif _ row ▁+= ▁sp ▁-> ▁v _ sampling ▁; ▁buf ▁+= ▁sp ▁-> ▁bytes per line ▁; ▁cc ▁-= ▁sp ▁-> ▁bytes per line ▁; ▁nrows ▁-= ▁sp ▁-> ▁v _ sampling ▁; ▁} ▁while ▁( ▁nrows ▁> ▁0 ▁) ▁; ▁# if ▁defined ▁( ▁JPEG _ LIB _ MK 1_ OR _12 BIT ▁) ▁_ TIFF free ▁( ▁tmpbuf ▁) ▁; ▁# endif ▁} ▁return ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁output _ scanline ▁< ▁sp ▁-> ▁cinfo ▁. ▁d ▁. ▁output _ height ▁|| ▁TIFF jpeg _ finish _ decompress ▁( ▁sp ▁) ▁; ▁}	0
▁static ▁void ▁add _ input _ streams ▁( ▁Options Context ▁* ▁o ▁, ▁AVFormatContext ▁* ▁ic ▁) ▁{ ▁int ▁i ▁; ▁char ▁* ▁next ▁, ▁* ▁codec _ tag ▁= ▁NULL ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ic ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁ic ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁AVCodecContext ▁* ▁dec ▁= ▁st ▁-> ▁codec ▁; ▁InputStream ▁* ▁ist ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁ist ▁) ▁) ▁; ▁if ▁( ▁! ▁ist ▁) ▁exit _ program ▁( ▁1 ▁) ▁; ▁input _ streams ▁= ▁grow _ array ▁( ▁input _ streams ▁, ▁sizeof ▁( ▁* ▁input _ streams ▁) ▁, ▁& ▁nb _ input _ streams ▁, ▁nb _ input _ streams ▁+ ▁1 ▁) ▁; ▁input _ streams ▁[ ▁nb _ input _ streams ▁- ▁1 ▁] ▁= ▁ist ▁; ▁ist ▁-> ▁st ▁= ▁st ▁; ▁ist ▁-> ▁file _ index ▁= ▁nb _ input _ files ▁; ▁ist ▁-> ▁discard ▁= ▁1 ▁; ▁st ▁-> ▁discard ▁= ▁AV DISCARD _ ALL ▁; ▁ist ▁-> ▁opts ▁= ▁filter _ codec _ opts ▁( ▁codec _ opts ▁, ▁choose _ decoder ▁( ▁o ▁, ▁ic ▁, ▁st ▁) ▁, ▁ic ▁, ▁st ▁) ▁; ▁ist ▁-> ▁ts _ scale ▁= ▁1.0 ▁; ▁MATCH _ PER _ STREAM _ OPT ▁( ▁ts _ scale ▁, ▁dbl ▁, ▁ist ▁-> ▁ts _ scale ▁, ▁ic ▁, ▁st ▁) ▁; ▁MATCH _ PER _ STREAM _ OPT ▁( ▁codec _ tags ▁, ▁str ▁, ▁codec _ tag ▁, ▁ic ▁, ▁st ▁) ▁; ▁if ▁( ▁codec _ tag ▁) ▁{ ▁uint 32_ t ▁tag ▁= ▁strtol ▁( ▁codec _ tag ▁, ▁& ▁next ▁, ▁0 ▁) ▁; ▁if ▁( ▁* ▁next ▁) ▁tag ▁= ▁AV _ RL 32 ▁( ▁codec _ tag ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁= ▁tag ▁; ▁} ▁ist ▁-> ▁dec ▁= ▁choose _ decoder ▁( ▁o ▁, ▁ic ▁, ▁st ▁) ▁; ▁switch ▁( ▁dec ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁if ▁( ▁! ▁ist ▁-> ▁dec ▁) ▁ist ▁-> ▁dec ▁= ▁avcodec _ find _ decoder ▁( ▁dec ▁-> ▁codec _ id ▁) ▁; ▁if ▁( ▁dec ▁-> ▁low res ▁) ▁{ ▁dec ▁-> ▁flags ▁|= ▁CODEC _ FLAG _ EMU _ EDGE ▁; ▁} ▁ist ▁-> ▁res ample _ height ▁= ▁dec ▁-> ▁height ▁; ▁ist ▁-> ▁res ample _ width ▁= ▁dec ▁-> ▁width ▁; ▁ist ▁-> ▁res ample _ pix _ fmt ▁= ▁dec ▁-> ▁pix _ fmt ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁guess _ input _ channel _ layout ▁( ▁ist ▁) ▁; ▁ist ▁-> ▁res ample _ sample _ fmt ▁= ▁dec ▁-> ▁sample _ fmt ▁; ▁ist ▁-> ▁res ample _ sample _ rate ▁= ▁dec ▁-> ▁sample _ rate ▁; ▁ist ▁-> ▁res ample _ channels ▁= ▁dec ▁-> ▁channels ▁; ▁ist ▁-> ▁res ample _ channel _ layout ▁= ▁dec ▁-> ▁channel _ layout ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ DATA ▁: ▁case ▁AVMEDIA _ TYPE _ SUBTITLE ▁: ▁if ▁( ▁! ▁ist ▁-> ▁dec ▁) ▁ist ▁-> ▁dec ▁= ▁avcodec _ find _ decoder ▁( ▁dec ▁-> ▁codec _ id ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ ATTACHMENT ▁: ▁case ▁AVMEDIA _ TYPE _ UNKNOWN ▁: ▁break ▁; ▁default ▁: ▁abort ▁( ▁) ▁; ▁} ▁} ▁}	0
▁static ▁int ▁km vc _ decode _ inter _8 x 8 ▁( ▁K mvc Context ▁* ▁ctx ▁, ▁int ▁w ▁, ▁int ▁h ▁) ▁{ ▁Bit Buf ▁bb ▁; ▁int ▁res ▁, ▁val ▁; ▁int ▁i ▁, ▁j ▁; ▁int ▁bx ▁, ▁by ▁; ▁int ▁l 0 x ▁, ▁l 1 x ▁, ▁l 0 y ▁, ▁l 1 y ▁; ▁int ▁mx ▁, ▁my ▁; ▁km vc _ init _ get bits ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁for ▁( ▁by ▁= ▁0 ▁; ▁by ▁< ▁h ▁; ▁by ▁+= ▁8 ▁) ▁for ▁( ▁bx ▁= ▁0 ▁; ▁bx ▁< ▁w ▁; ▁bx ▁+= ▁8 ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁if ▁( ▁! ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Data over run \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁bx ▁+ ▁( ▁i ▁& ▁0 x 7 ▁) ▁, ▁by ▁+ ▁( ▁i ▁>> ▁3 ▁) ▁) ▁= ▁val ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁bx ▁+ ▁( ▁i ▁& ▁0 x 7 ▁) ▁, ▁by ▁+ ▁( ▁i ▁>> ▁3 ▁) ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁bx ▁+ ▁( ▁i ▁& ▁0 x 7 ▁) ▁, ▁by ▁+ ▁( ▁i ▁>> ▁3 ▁) ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁! ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Data over run \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁l 0 x ▁= ▁bx ▁+ ▁( ▁i ▁& ▁1 ▁) ▁* ▁4 ▁; ▁l 0 y ▁= ▁by ▁+ ▁( ▁i ▁& ▁2 ▁) ▁* ▁2 ▁; ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 0 x ▁+ ▁( ▁j ▁& ▁3 ▁) ▁, ▁l 0 y ▁+ ▁( ▁j ▁>> ▁2 ▁) ▁) ▁= ▁val ▁; ▁} ▁else ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁mx ▁= ▁( ▁val ▁& ▁0 xF ▁) ▁- ▁8 ▁; ▁my ▁= ▁( ▁val ▁>> ▁4 ▁) ▁- ▁8 ▁; ▁if ▁( ▁( ▁l 0 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 0 y ▁+ ▁my ▁) ▁< ▁0 ▁|| ▁( ▁l 0 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 0 y ▁+ ▁my ▁) ▁> ▁3 18 ▁* ▁19 8 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid MV \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 0 x ▁+ ▁( ▁j ▁& ▁3 ▁) ▁, ▁l 0 y ▁+ ▁( ▁j ▁>> ▁2 ▁) ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 0 x ▁+ ▁( ▁j ▁& ▁3 ▁) ▁+ ▁mx ▁, ▁l 0 y ▁+ ▁( ▁j ▁>> ▁2 ▁) ▁+ ▁my ▁) ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁l 1 x ▁= ▁l 0 x ▁+ ▁( ▁j ▁& ▁1 ▁) ▁* ▁2 ▁; ▁l 1 y ▁= ▁l 0 y ▁+ ▁( ▁j ▁& ▁2 ▁) ▁; ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁km vc _ get bit ▁( ▁bb ▁, ▁& ▁ctx ▁-> ▁g ▁, ▁res ▁) ▁; ▁if ▁( ▁! ▁res ▁) ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁) ▁= ▁val ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁) ▁= ▁val ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁val ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁val ▁; ▁} ▁else ▁{ ▁val ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁mx ▁= ▁( ▁val ▁& ▁0 xF ▁) ▁- ▁8 ▁; ▁my ▁= ▁( ▁val ▁>> ▁4 ▁) ▁- ▁8 ▁; ▁if ▁( ▁( ▁l 1 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 1 y ▁+ ▁my ▁) ▁< ▁0 ▁|| ▁( ▁l 1 x ▁+ ▁mx ▁) ▁+ ▁320 ▁* ▁( ▁l 1 y ▁+ ▁my ▁) ▁> ▁3 18 ▁* ▁19 8 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid MV \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁my ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁1 ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁my ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁1 ▁+ ▁my ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁BLK ▁( ▁ctx ▁-> ▁prev ▁, ▁l 1 x ▁+ ▁1 ▁+ ▁mx ▁, ▁l 1 y ▁+ ▁1 ▁+ ▁my ▁) ▁; ▁} ▁} ▁else ▁{ ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁BLK ▁( ▁ctx ▁-> ▁cur ▁, ▁l 1 x ▁+ ▁1 ▁, ▁l 1 y ▁+ ▁1 ▁) ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁g ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁draw _ rectangle ▁( ▁unsigned ▁val ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁dst _ lines ize ▁, ▁int ▁segment _ width ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁int ▁w ▁, ▁int ▁h ▁) ▁{ ▁int ▁i ▁; ▁int ▁step ▁= ▁3 ▁; ▁dst ▁+= ▁segment _ width ▁* ▁( ▁step ▁* ▁x ▁+ ▁y ▁* ▁dst _ lines ize ▁) ▁; ▁w ▁*= ▁segment _ width ▁* ▁step ▁; ▁h ▁*= ▁segment _ width ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁; ▁i ▁++ ▁) ▁{ ▁memset ▁( ▁dst ▁, ▁val ▁, ▁w ▁) ▁; ▁dst ▁+= ▁dst _ lines ize ▁; ▁} ▁}	0
▁int 64_ t ▁parse _ date ▁( ▁const ▁char ▁* ▁date str ▁, ▁int ▁duration ▁) ▁{ ▁const ▁char ▁* ▁p ▁; ▁int 64_ t ▁t ▁; ▁struct ▁tm ▁dt ▁; ▁int ▁i ▁; ▁static ▁const ▁char ▁* ▁const ▁date _ fmt ▁[ ▁] ▁= ▁{ ▁"% Y -% m -% d " ▁, ▁"% Y % m % d " ▁, ▁} ▁; ▁static ▁const ▁char ▁* ▁const ▁time _ fmt ▁[ ▁] ▁= ▁{ ▁"% H :% M :% S " ▁, ▁"% H % M % S " ▁, ▁} ▁; ▁const ▁char ▁* ▁q ▁; ▁int ▁is _ ut c ▁, ▁len ▁; ▁char ▁last ch ▁; ▁int ▁negative ▁= ▁0 ▁; ▁# undef ▁time ▁time _ t ▁now ▁= ▁time ▁( ▁0 ▁) ▁; ▁len ▁= ▁strlen ▁( ▁date str ▁) ▁; ▁if ▁( ▁len ▁> ▁0 ▁) ▁last ch ▁= ▁date str ▁[ ▁len ▁- ▁1 ▁] ▁; ▁else ▁last ch ▁= ▁' ▁\0 ▁' ▁; ▁is _ ut c ▁= ▁( ▁last ch ▁== ▁' ▁' ▁|| ▁last ch ▁== ▁' ▁' ▁) ▁; ▁memset ▁( ▁& ▁dt ▁, ▁0 ▁, ▁sizeof ▁( ▁dt ▁) ▁) ▁; ▁p ▁= ▁date str ▁; ▁q ▁= ▁NULL ▁; ▁if ▁( ▁! ▁duration ▁) ▁{ ▁if ▁( ▁! ▁strncasecmp ▁( ▁date str ▁, ▁" now " ▁, ▁len ▁) ▁) ▁return ▁( ▁int 64_ t ▁) ▁now ▁* ▁1000000 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁date _ fmt ▁) ▁; ▁i ▁++ ▁) ▁{ ▁q ▁= ▁small _ str ptime ▁( ▁p ▁, ▁date _ fmt ▁[ ▁i ▁] ▁, ▁& ▁dt ▁) ▁; ▁if ▁( ▁q ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁q ▁) ▁{ ▁if ▁( ▁is _ ut c ▁) ▁{ ▁dt ▁= ▁* ▁gmt ime ▁( ▁& ▁now ▁) ▁; ▁} ▁else ▁{ ▁dt ▁= ▁* ▁localtime ▁( ▁& ▁now ▁) ▁; ▁} ▁dt ▁. ▁tm _ hour ▁= ▁dt ▁. ▁tm _ min ▁= ▁dt ▁. ▁tm _ sec ▁= ▁0 ▁; ▁} ▁else ▁{ ▁p ▁= ▁q ▁; ▁} ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁|| ▁* ▁p ▁== ▁' ▁' ▁|| ▁* ▁p ▁== ▁' ▁' ▁) ▁p ▁++ ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁time _ fmt ▁) ▁; ▁i ▁++ ▁) ▁{ ▁q ▁= ▁small _ str ptime ▁( ▁p ▁, ▁time _ fmt ▁[ ▁i ▁] ▁, ▁& ▁dt ▁) ▁; ▁if ▁( ▁q ▁) ▁{ ▁break ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁p ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁negative ▁= ▁1 ▁; ▁++ ▁p ▁; ▁} ▁q ▁= ▁small _ str ptime ▁( ▁p ▁, ▁time _ fmt ▁[ ▁0 ▁] ▁, ▁& ▁dt ▁) ▁; ▁if ▁( ▁! ▁q ▁) ▁{ ▁dt ▁. ▁tm _ sec ▁= ▁strtol ▁( ▁p ▁, ▁( ▁char ▁* ▁* ▁) ▁& ▁q ▁, ▁10 ▁) ▁; ▁if ▁( ▁q ▁== ▁p ▁) ▁return ▁INT 64_ MIN ▁; ▁dt ▁. ▁tm _ min ▁= ▁0 ▁; ▁dt ▁. ▁tm _ hour ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁! ▁q ▁) ▁{ ▁return ▁INT 64_ MIN ▁; ▁} ▁if ▁( ▁duration ▁) ▁{ ▁t ▁= ▁dt ▁. ▁tm _ hour ▁* ▁3600 ▁+ ▁dt ▁. ▁tm _ min ▁* ▁60 ▁+ ▁dt ▁. ▁tm _ sec ▁; ▁} ▁else ▁{ ▁dt ▁. ▁tm _ is dst ▁= ▁-1 ▁; ▁if ▁( ▁is _ ut c ▁) ▁{ ▁t ▁= ▁mktime gm ▁( ▁& ▁dt ▁) ▁; ▁} ▁else ▁{ ▁t ▁= ▁mktime ▁( ▁& ▁dt ▁) ▁; ▁} ▁} ▁t ▁*= ▁1000000 ▁; ▁if ▁( ▁* ▁q ▁== ▁' ▁' ▁) ▁{ ▁int ▁val ▁, ▁n ▁; ▁q ▁++ ▁; ▁for ▁( ▁val ▁= ▁0 ▁, ▁n ▁= ▁100000 ▁; ▁n ▁>= ▁1 ▁; ▁n ▁/= ▁10 ▁, ▁q ▁++ ▁) ▁{ ▁if ▁( ▁! ▁isdigit ▁( ▁* ▁q ▁) ▁) ▁break ▁; ▁val ▁+= ▁n ▁* ▁( ▁* ▁q ▁- ▁' ▁' ▁) ▁; ▁} ▁t ▁+= ▁val ▁; ▁} ▁return ▁negative ▁? ▁- ▁t ▁: ▁t ▁; ▁}	1
▁void ▁* ▁ngx _ palloc ▁( ▁ngx _ pool _ t ▁* ▁pool ▁, ▁size _ t ▁size ▁) ▁{ ▁u _ char ▁* ▁m ▁; ▁ngx _ pool _ t ▁* ▁p ▁; ▁if ▁( ▁size ▁<= ▁pool ▁-> ▁max ▁) ▁{ ▁p ▁= ▁pool ▁-> ▁current ▁; ▁do ▁{ ▁m ▁= ▁ngx _ align _ ptr ▁( ▁p ▁-> ▁d ▁. ▁last ▁, ▁NGX _ ALIGNMENT ▁) ▁; ▁if ▁( ▁( ▁size _ t ▁) ▁( ▁p ▁-> ▁d ▁. ▁end ▁- ▁m ▁) ▁>= ▁size ▁) ▁{ ▁p ▁-> ▁d ▁. ▁last ▁= ▁m ▁+ ▁size ▁; ▁return ▁m ▁; ▁} ▁p ▁= ▁p ▁-> ▁d ▁. ▁next ▁; ▁} ▁while ▁( ▁p ▁) ▁; ▁return ▁ngx _ palloc _ block ▁( ▁pool ▁, ▁size ▁) ▁; ▁} ▁return ▁ngx _ palloc _ large ▁( ▁pool ▁, ▁size ▁) ▁; ▁}	1
▁int ▁tls 13_ h kdf _ expand ▁( ▁SSL ▁* ▁s ▁, ▁const ▁unsigned ▁char ▁* ▁secret ▁, ▁const ▁unsigned ▁char ▁* ▁label ▁, ▁size _ t ▁label len ▁, ▁const ▁unsigned ▁char ▁* ▁hash ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁size _ t ▁outlen ▁) ▁{ ▁const ▁unsigned ▁char ▁label _ prefix ▁[ ▁] ▁= ▁" TLS 1. 3, " ▁; ▁const ▁EVP _ MD ▁* ▁md ▁= ▁ssl _ handshake _ md ▁( ▁s ▁) ▁; ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new _ id ▁( ▁EVP _ PKEY _ HK DF ▁, ▁NULL ▁) ▁; ▁int ▁ret ▁; ▁size _ t ▁hk df label len ▁; ▁size _ t ▁hash len ▁; ▁unsigned ▁char ▁hk df label ▁[ ▁sizeof ▁( ▁uint 16_ t ▁) ▁+ ▁sizeof ▁( ▁uint 8_ t ▁) ▁+ ▁+ ▁sizeof ▁( ▁label _ prefix ▁) ▁+ ▁TLS 13_ MAX _ LABEL _ LEN ▁+ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁W PACKET ▁pkt ▁; ▁if ▁( ▁pctx ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁hash len ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁if ▁( ▁! ▁W PACKET _ init _ static _ len ▁( ▁& ▁pkt ▁, ▁hk df label ▁, ▁sizeof ▁( ▁hk df label ▁) ▁, ▁0 ▁) ▁|| ▁! ▁W PACKET _ put _ bytes _ u 16 ▁( ▁& ▁pkt ▁, ▁outlen ▁) ▁|| ▁! ▁W PACKET _ start _ sub _ packet _ u 8 ▁( ▁& ▁pkt ▁) ▁|| ▁! ▁W PACKET _ memcpy ▁( ▁& ▁pkt ▁, ▁label _ prefix ▁, ▁sizeof ▁( ▁label _ prefix ▁) ▁- ▁1 ▁) ▁|| ▁! ▁W PACKET _ memcpy ▁( ▁& ▁pkt ▁, ▁label ▁, ▁label len ▁) ▁|| ▁! ▁W PACKET _ close ▁( ▁& ▁pkt ▁) ▁|| ▁! ▁W PACKET _ sub _ memcpy _ u 8 ▁( ▁& ▁pkt ▁, ▁hash ▁, ▁( ▁hash ▁== ▁NULL ▁) ▁? ▁0 ▁: ▁hash len ▁) ▁|| ▁! ▁W PACKET _ get _ total _ written ▁( ▁& ▁pkt ▁, ▁& ▁hk df label len ▁) ▁|| ▁! ▁W PACKET _ finish ▁( ▁& ▁pkt ▁) ▁) ▁{ ▁W PACKET _ cleanup ▁( ▁& ▁pkt ▁) ▁; ▁return ▁0 ▁; ▁} ▁ret ▁= ▁EVP _ PKEY _ der ive _ init ▁( ▁pctx ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ h kdf _ mode ▁( ▁pctx ▁, ▁EVP _ PKEY _ HK DEF _ MODE _ EXPAND _ ONLY ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set _ h kdf _ md ▁( ▁pctx ▁, ▁md ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set 1_ h kdf _ key ▁( ▁pctx ▁, ▁secret ▁, ▁hash len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ add 1_ h kdf _ info ▁( ▁pctx ▁, ▁hk df label ▁, ▁hk df label len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ der ive ▁( ▁pctx ▁, ▁out ▁, ▁& ▁outlen ▁) ▁<= ▁0 ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁ret ▁== ▁0 ▁; ▁}	0
▁static ▁int ▁JPEG Encode Raw ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 8 ▁* ▁buf ▁, ▁tm size _ t ▁cc ▁, ▁uint 16 ▁s ▁) ▁{ ▁JPEG State ▁* ▁sp ▁= ▁J State ▁( ▁tif ▁) ▁; ▁J SAMPLE ▁* ▁inptr ▁; ▁J SAMPLE ▁* ▁outptr ▁; ▁tm size _ t ▁nrows ▁; ▁JDIMENSION ▁c lu mps _ per _ line ▁, ▁n clu mp ▁; ▁int ▁c lu mp offset ▁, ▁ci ▁, ▁xpos ▁, ▁ypos ▁; ▁jpeg _ component _ info ▁* ▁comp ptr ▁; ▁int ▁samples _ per _ clu mp ▁= ▁sp ▁-> ▁samples per clu mp ▁; ▁tm size _ t ▁bytes per clu mpl ine ▁; ▁( ▁void ▁) ▁s ▁; ▁assert ▁( ▁sp ▁!= ▁NULL ▁) ▁; ▁bytes per clu mpl ine ▁= ▁( ▁( ▁( ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁image _ width ▁+ ▁sp ▁-> ▁h _ sampling ▁- ▁1 ▁) ▁/ ▁sp ▁-> ▁h _ sampling ▁) ▁* ▁( ▁sp ▁-> ▁h _ sampling ▁* ▁sp ▁-> ▁v _ sampling ▁+ ▁2 ▁) ▁* ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁data _ precision ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁nrows ▁= ▁( ▁cc ▁/ ▁bytes per clu mpl ine ▁) ▁* ▁sp ▁-> ▁v _ sampling ▁; ▁if ▁( ▁cc ▁% ▁bytes per clu mpl ine ▁) ▁TIFF Warning Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁tif ▁-> ▁tif _ name ▁, ▁" fraction al scan lined isc arded " ▁) ▁; ▁c lu mps _ per _ line ▁= ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁comp _ info ▁[ ▁1 ▁] ▁. ▁down sample d _ width ▁; ▁while ▁( ▁nrows ▁> ▁0 ▁) ▁{ ▁c lu mp offset ▁= ▁0 ▁; ▁for ▁( ▁ci ▁= ▁0 ▁, ▁comp ptr ▁= ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁comp _ info ▁; ▁ci ▁< ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁num _ components ▁; ▁ci ▁++ ▁, ▁comp ptr ▁++ ▁) ▁{ ▁int ▁hs amp ▁= ▁comp ptr ▁-> ▁h _ s amp _ factor ▁; ▁int ▁vs amp ▁= ▁comp ptr ▁-> ▁v _ s amp _ factor ▁; ▁int ▁padding ▁= ▁( ▁int ▁) ▁( ▁comp ptr ▁-> ▁width _ in _ blocks ▁* ▁DCTSIZE ▁- ▁c lu mps _ per _ line ▁* ▁hs amp ▁) ▁; ▁for ▁( ▁ypos ▁= ▁0 ▁; ▁ypos ▁< ▁vs amp ▁; ▁ypos ▁++ ▁) ▁{ ▁inptr ▁= ▁( ▁( ▁J SAMPLE ▁* ▁) ▁buf ▁) ▁+ ▁c lu mp offset ▁; ▁outptr ▁= ▁sp ▁-> ▁ds _ buffer ▁[ ▁ci ▁] ▁[ ▁sp ▁-> ▁scan count ▁* ▁vs amp ▁+ ▁ypos ▁] ▁; ▁if ▁( ▁hs amp ▁== ▁1 ▁) ▁{ ▁for ▁( ▁n clu mp ▁= ▁c lu mps _ per _ line ▁; ▁n clu mp ▁-- ▁> ▁0 ▁; ▁) ▁{ ▁* ▁outptr ▁++ ▁= ▁inptr ▁[ ▁0 ▁] ▁; ▁inptr ▁+= ▁samples _ per _ clu mp ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁n clu mp ▁= ▁c lu mps _ per _ line ▁; ▁n clu mp ▁-- ▁> ▁0 ▁; ▁) ▁{ ▁for ▁( ▁xpos ▁= ▁0 ▁; ▁xpos ▁< ▁hs amp ▁; ▁xpos ▁++ ▁) ▁* ▁outptr ▁++ ▁= ▁inptr ▁[ ▁xpos ▁] ▁; ▁inptr ▁+= ▁samples _ per _ clu mp ▁; ▁} ▁} ▁for ▁( ▁xpos ▁= ▁0 ▁; ▁xpos ▁< ▁padding ▁; ▁xpos ▁++ ▁) ▁{ ▁* ▁outptr ▁= ▁outptr ▁[ ▁-1 ▁] ▁; ▁outptr ▁++ ▁; ▁} ▁c lu mp offset ▁+= ▁hs amp ▁; ▁} ▁} ▁sp ▁-> ▁scan count ▁++ ▁; ▁if ▁( ▁sp ▁-> ▁scan count ▁>= ▁DCTSIZE ▁) ▁{ ▁int ▁n ▁= ▁sp ▁-> ▁cinfo ▁. ▁c ▁. ▁max _ v _ s amp _ factor ▁* ▁DCTSIZE ▁; ▁if ▁( ▁TIFF jpeg _ write _ raw _ data ▁( ▁sp ▁, ▁sp ▁-> ▁ds _ buffer ▁, ▁n ▁) ▁!= ▁n ▁) ▁return ▁( ▁0 ▁) ▁; ▁sp ▁-> ▁scan count ▁= ▁0 ▁; ▁} ▁tif ▁-> ▁tif _ row ▁+= ▁sp ▁-> ▁v _ sampling ▁; ▁buf ▁+= ▁bytes per clu mpl ine ▁; ▁nrows ▁-= ▁sp ▁-> ▁v _ sampling ▁; ▁} ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁int ▁m j pe ga _ dump _ header ▁( ▁AV BitStream Filter Context ▁* ▁bs fc ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁char ▁* ▁args ▁, ▁uint 8_ t ▁* ▁* ▁poutbuf ▁, ▁int ▁* ▁poutbuf _ size ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁int ▁keyframe ▁) ▁{ ▁uint 8_ t ▁* ▁poutbuf p ▁; ▁unsigned ▁dq t ▁= ▁0 ▁, ▁dht ▁= ▁0 ▁, ▁sof 0 ▁= ▁0 ▁; ▁int ▁i ▁; ▁if ▁( ▁avctx ▁-> ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ M JPEG ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" m jpeg ab it stream filter only app liest om jpeg codec \ n " ▁) ▁; ▁return ▁0 ▁; ▁} ▁* ▁poutbuf _ size ▁= ▁0 ▁; ▁* ▁poutbuf ▁= ▁av _ malloc ▁( ▁buf _ size ▁+ ▁44 ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁poutbuf p ▁= ▁* ▁poutbuf ▁; ▁bytestream _ put _ byte ▁( ▁& ▁poutbuf p ▁, ▁0 xff ▁) ▁; ▁bytestream _ put _ byte ▁( ▁& ▁poutbuf p ▁, ▁SO I ▁) ▁; ▁bytestream _ put _ byte ▁( ▁& ▁poutbuf p ▁, ▁0 xff ▁) ▁; ▁bytestream _ put _ byte ▁( ▁& ▁poutbuf p ▁, ▁APP 1 ▁) ▁; ▁bytestream _ put _ be 16 ▁( ▁& ▁poutbuf p ▁, ▁42 ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁0 ▁) ▁; ▁bytestream _ put _ buffer ▁( ▁& ▁poutbuf p ▁, ▁" m jpg " ▁, ▁4 ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁buf _ size ▁+ ▁44 ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁buf _ size ▁+ ▁44 ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁0 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁buf _ size ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁buf ▁[ ▁i ▁] ▁== ▁0 xff ▁) ▁{ ▁switch ▁( ▁buf ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁{ ▁case ▁D QT ▁: ▁dq t ▁= ▁i ▁+ ▁46 ▁; ▁break ▁; ▁case ▁DHT ▁: ▁dht ▁= ▁i ▁+ ▁46 ▁; ▁break ▁; ▁case ▁SOF 0 ▁: ▁sof 0 ▁= ▁i ▁+ ▁46 ▁; ▁break ▁; ▁case ▁S OS ▁: ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁dq t ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁dht ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁sof 0 ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁i ▁+ ▁46 ▁) ▁; ▁bytestream _ put _ be 32 ▁( ▁& ▁poutbuf p ▁, ▁i ▁+ ▁46 ▁+ ▁AV _ RB 16 ▁( ▁buf ▁+ ▁i ▁+ ▁2 ▁) ▁) ▁; ▁bytestream _ put _ buffer ▁( ▁& ▁poutbuf p ▁, ▁buf ▁+ ▁2 ▁, ▁buf _ size ▁- ▁2 ▁) ▁; ▁* ▁poutbuf _ size ▁= ▁poutbuf p ▁- ▁* ▁poutbuf ▁; ▁return ▁1 ▁; ▁case ▁APP 1 ▁: ▁if ▁( ▁i ▁+ ▁8 ▁< ▁buf _ size ▁&& ▁AV _ RL 32 ▁( ▁buf ▁+ ▁i ▁+ ▁8 ▁) ▁== ▁AV _ RL 32 ▁( ▁" m jpg " ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" bit stream already formatted \ n " ▁) ▁; ▁memcpy ▁( ▁* ▁poutbuf ▁, ▁buf ▁, ▁buf _ size ▁) ▁; ▁* ▁poutbuf _ size ▁= ▁buf _ size ▁; ▁return ▁1 ▁; ▁} ▁} ▁} ▁} ▁av _ freep ▁( ▁poutbuf ▁) ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" could not find S OS marker in bit stream \ n " ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁ssl _ get _ prev _ session ▁( ▁SSL ▁* ▁s ▁, ▁const ▁PACKET ▁* ▁ext ▁, ▁const ▁PACKET ▁* ▁session _ id ▁) ▁{ ▁SSL _ SESSION ▁* ▁ret ▁= ▁NULL ▁; ▁int ▁fatal ▁= ▁0 ▁; ▁int ▁try _ session _ cache ▁= ▁1 ▁; ▁int ▁r ▁; ▁size _ t ▁len ▁= ▁PACKET _ remaining ▁( ▁session _ id ▁) ▁; ▁if ▁( ▁len ▁> ▁SSL _ MAX _ SSL _ SESSION _ ID _ LENGTH ▁) ▁goto ▁err ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁try _ session _ cache ▁= ▁0 ▁; ▁r ▁= ▁tls 1_ process _ ticket ▁( ▁s ▁, ▁ext ▁, ▁session _ id ▁, ▁& ▁ret ▁) ▁; ▁switch ▁( ▁r ▁) ▁{ ▁case ▁-1 ▁: ▁fatal ▁= ▁1 ▁; ▁goto ▁err ▁; ▁case ▁0 ▁: ▁case ▁1 ▁: ▁break ▁; ▁case ▁2 ▁: ▁case ▁3 ▁: ▁try _ session _ cache ▁= ▁0 ▁; ▁break ▁; ▁default ▁: ▁abort ▁( ▁) ▁; ▁} ▁if ▁( ▁try _ session _ cache ▁&& ▁ret ▁== ▁NULL ▁&& ▁! ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁session _ cache _ mode ▁& ▁SSL _ S ESS _ CACHE _ NO _ INTERNAL _ LOOKUP ▁) ▁) ▁{ ▁SSL _ SESSION ▁data ▁; ▁data ▁. ▁ssl _ version ▁= ▁s ▁-> ▁version ▁; ▁data ▁. ▁session _ id _ length ▁= ▁len ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁return ▁0 ▁; ▁memcpy ▁( ▁data ▁. ▁session _ id ▁, ▁PACKET _ data ▁( ▁session _ id ▁) ▁, ▁len ▁) ▁; ▁CRYPTO _ r _ lock ▁( ▁CRYPTO _ LOCK _ SSL _ CTX ▁) ▁; ▁ret ▁= ▁lh _ SSL _ SESSION _ ret rieve ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁sessions ▁, ▁& ▁data ▁) ▁; ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁{ ▁CRYPTO _ add ▁( ▁& ▁ret ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ SSL _ SESSION ▁) ▁; ▁} ▁CRYPTO _ r _ unlock ▁( ▁CRYPTO _ LOCK _ SSL _ CTX ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ miss ▁++ ▁; ▁} ▁if ▁( ▁try _ session _ cache ▁&& ▁ret ▁== ▁NULL ▁&& ▁s ▁-> ▁session _ ctx ▁-> ▁get _ session _ cb ▁!= ▁NULL ▁) ▁{ ▁int ▁copy ▁= ▁1 ▁; ▁if ▁( ▁( ▁ret ▁= ▁s ▁-> ▁session _ ctx ▁-> ▁get _ session _ cb ▁( ▁s ▁, ▁PACKET _ data ▁( ▁session _ id ▁) ▁, ▁len ▁, ▁& ▁copy ▁) ▁) ▁) ▁{ ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ cb _ hit ▁++ ▁; ▁if ▁( ▁copy ▁) ▁CRYPTO _ add ▁( ▁& ▁ret ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ SSL _ SESSION ▁) ▁; ▁if ▁( ▁! ▁( ▁s ▁-> ▁session _ ctx ▁-> ▁session _ cache _ mode ▁& ▁SSL _ S ESS _ CACHE _ NO _ INTERNAL _ STORE ▁) ▁) ▁{ ▁if ▁( ▁SSL _ CTX _ add _ session ▁( ▁s ▁-> ▁session _ ctx ▁, ▁ret ▁) ▁) ▁goto ▁err ▁; ▁} ▁} ▁} ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁ret ▁-> ▁sid _ ctx _ length ▁!= ▁s ▁-> ▁sid _ ctx _ length ▁|| ▁memcmp ▁( ▁ret ▁-> ▁sid _ ctx ▁, ▁s ▁-> ▁sid _ ctx ▁, ▁ret ▁-> ▁sid _ ctx _ length ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁s ▁-> ▁verify _ mode ▁& ▁SSL _ VERIFY _ PEER ▁) ▁&& ▁s ▁-> ▁sid _ ctx _ length ▁== ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ GET _ PREV _ SESSION ▁, ▁SSL _ R _ SESSION _ ID _ CONTEXT _ UN INITIALIZED ▁) ▁; ▁fatal ▁= ▁1 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁ret ▁-> ▁cipher ▁== ▁NULL ▁) ▁{ ▁unsigned ▁char ▁buf ▁[ ▁5 ▁] ▁, ▁* ▁p ▁; ▁unsigned ▁long ▁l ▁; ▁p ▁= ▁buf ▁; ▁l ▁= ▁ret ▁-> ▁cipher _ id ▁; ▁l 2 n ▁( ▁l ▁, ▁p ▁) ▁; ▁if ▁( ▁( ▁ret ▁-> ▁ssl _ version ▁>> ▁8 ▁) ▁>= ▁SSL 3_ VERSION _ MAJOR ▁) ▁ret ▁-> ▁cipher ▁= ▁ssl _ get _ cipher _ by _ char ▁( ▁s ▁, ▁& ▁( ▁buf ▁[ ▁2 ▁] ▁) ▁) ▁; ▁else ▁ret ▁-> ▁cipher ▁= ▁ssl _ get _ cipher _ by _ char ▁( ▁s ▁, ▁& ▁( ▁buf ▁[ ▁1 ▁] ▁) ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cipher ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁ret ▁-> ▁timeout ▁< ▁( ▁long ▁) ▁( ▁time ▁( ▁NULL ▁) ▁- ▁ret ▁-> ▁time ▁) ▁) ▁{ ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ timeout ▁++ ▁; ▁if ▁( ▁try _ session _ cache ▁) ▁{ ▁SSL _ CTX _ remove _ session ▁( ▁s ▁-> ▁session _ ctx ▁, ▁ret ▁) ▁; ▁} ▁goto ▁err ▁; ▁} ▁s ▁-> ▁session _ ctx ▁-> ▁stats ▁. ▁sess _ hit ▁++ ▁; ▁SSL _ SESSION _ free ▁( ▁s ▁-> ▁session ▁) ▁; ▁s ▁-> ▁session ▁= ▁ret ▁; ▁s ▁-> ▁verify _ result ▁= ▁s ▁-> ▁session ▁-> ▁verify _ result ▁; ▁return ▁1 ▁; ▁err ▁: ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁{ ▁SSL _ SESSION _ free ▁( ▁ret ▁) ▁; ▁if ▁( ▁! ▁try _ session _ cache ▁) ▁{ ▁s ▁-> ▁tl se xt _ ticket _ expected ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁fatal ▁) ▁return ▁-1 ▁; ▁else ▁return ▁0 ▁; ▁}	0
▁void ▁SSL _ free ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁s ▁== ▁NULL ▁) ▁return ▁; ▁CRYPTO _ DOWN _ REF ▁( ▁& ▁s ▁-> ▁references ▁, ▁& ▁i ▁, ▁s ▁-> ▁lock ▁) ▁; ▁REF _ PRINT _ COUNT ▁( ▁" SSL " ▁, ▁s ▁) ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁return ▁; ▁REF _ ASSERT _ IS NT ▁( ▁i ▁< ▁0 ▁) ▁; ▁X 509_ VERIFY _ PARAM _ free ▁( ▁s ▁-> ▁param ▁) ▁; ▁d ane _ final ▁( ▁& ▁s ▁-> ▁d ane ▁) ▁; ▁CRYPTO _ free _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL ▁, ▁s ▁, ▁& ▁s ▁-> ▁ex _ data ▁) ▁; ▁ssl _ free _ wb io _ buffer ▁( ▁s ▁) ▁; ▁BIO _ free _ all ▁( ▁s ▁-> ▁w bio ▁) ▁; ▁BIO _ free _ all ▁( ▁s ▁-> ▁rb io ▁) ▁; ▁BUF _ MEM _ free ▁( ▁s ▁-> ▁init _ buf ▁) ▁; ▁sk _ SSL _ CIPHER _ free ▁( ▁s ▁-> ▁cipher _ list ▁) ▁; ▁sk _ SSL _ CIPHER _ free ▁( ▁s ▁-> ▁cipher _ list _ by _ id ▁) ▁; ▁sk _ SSL _ CIPHER _ free ▁( ▁s ▁-> ▁tls 13_ c iphers u ites ▁) ▁; ▁if ▁( ▁s ▁-> ▁session ▁!= ▁NULL ▁) ▁{ ▁ssl _ clear _ bad _ session ▁( ▁s ▁) ▁; ▁SSL _ SESSION _ free ▁( ▁s ▁-> ▁session ▁) ▁; ▁} ▁SSL _ SESSION _ free ▁( ▁s ▁-> ▁p sk session ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁p sk session _ id ▁) ▁; ▁clear _ c iphers ▁( ▁s ▁) ▁; ▁ssl _ cert _ free ▁( ▁s ▁-> ▁cert ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁hostname ▁) ▁; ▁SSL _ CTX _ free ▁( ▁s ▁-> ▁session _ ctx ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ EC ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁ec point formats ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁supported groups ▁) ▁; ▁# endif ▁sk _ X 509_ EXTENSION _ pop _ free ▁( ▁s ▁-> ▁ext ▁. ▁oc sp ▁. ▁exts ▁, ▁X 509_ EXTENSION _ free ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ OCSP ▁sk _ OCSP _ RES PID _ pop _ free ▁( ▁s ▁-> ▁ext ▁. ▁oc sp ▁. ▁ids ▁, ▁OCSP _ RES PID _ free ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ CT ▁SCT _ LIST _ free ▁( ▁s ▁-> ▁sct s ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁sct s ▁) ▁; ▁# endif ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁oc sp ▁. ▁resp ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁al pn ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁tls 13_ cookie ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁client hello ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁ph a _ context ▁) ▁; ▁EVP _ MD _ CTX _ free ▁( ▁s ▁-> ▁ph a _ dg st ▁) ▁; ▁sk _ X 509_ NAME _ pop _ free ▁( ▁s ▁-> ▁ca _ names ▁, ▁X 509_ NAME _ free ▁) ▁; ▁sk _ X 509_ pop _ free ▁( ▁s ▁-> ▁verified _ chain ▁, ▁X 509_ free ▁) ▁; ▁if ▁( ▁s ▁-> ▁method ▁!= ▁NULL ▁) ▁s ▁-> ▁method ▁-> ▁ssl _ free ▁( ▁s ▁) ▁; ▁RECORD _ LAYER _ release ▁( ▁& ▁s ▁-> ▁r layer ▁) ▁; ▁SSL _ CTX _ free ▁( ▁s ▁-> ▁ctx ▁) ▁; ▁ASYNC _ WAIT _ CTX _ free ▁( ▁s ▁-> ▁wait ctx ▁) ▁; ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ NEXT PROT ONE G ▁) ▁OPENSSL _ free ▁( ▁s ▁-> ▁ext ▁. ▁np n ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ SR TP ▁sk _ SR TP _ PROTECTION _ PROFILE _ free ▁( ▁s ▁-> ▁srtp _ profiles ▁) ▁; ▁# endif ▁CRYPTO _ THREAD _ lock _ free ▁( ▁s ▁-> ▁lock ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁) ▁; ▁}	0
▁int ▁X 509_ cmp ▁( ▁const ▁X 509 ▁* ▁a ▁, ▁const ▁X 509 ▁* ▁b ▁) ▁{ ▁int ▁rv ▁; ▁X 509_ check _ p urpose ▁( ▁( ▁X 509 ▁* ▁) ▁a ▁, ▁-1 ▁, ▁0 ▁) ▁; ▁X 509_ check _ p urpose ▁( ▁( ▁X 509 ▁* ▁) ▁b ▁, ▁-1 ▁, ▁0 ▁) ▁; ▁rv ▁= ▁memcmp ▁( ▁a ▁-> ▁sha 1_ hash ▁, ▁b ▁-> ▁sha 1_ hash ▁, ▁SHA _ DIGEST _ LENGTH ▁) ▁; ▁if ▁( ▁rv ▁) ▁return ▁rv ▁; ▁if ▁( ▁! ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁modified ▁&& ▁! ▁b ▁-> ▁cert _ info ▁. ▁enc ▁. ▁modified ▁) ▁{ ▁if ▁( ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁< ▁b ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁) ▁return ▁-1 ▁; ▁if ▁( ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁> ▁b ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁) ▁return ▁1 ▁; ▁return ▁memcmp ▁( ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁enc ▁, ▁b ▁-> ▁cert _ info ▁. ▁enc ▁. ▁enc ▁, ▁a ▁-> ▁cert _ info ▁. ▁enc ▁. ▁len ▁) ▁; ▁} ▁return ▁rv ▁; ▁}	0
▁char ▁* ▁CRYPTO _ strdup ▁( ▁const ▁char ▁* ▁str ▁, ▁const ▁char ▁* ▁file ▁, ▁int ▁line ▁) ▁{ ▁char ▁* ▁ret ▁; ▁if ▁( ▁str ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁ret ▁= ▁CRYPTO _ malloc ▁( ▁strlen ▁( ▁str ▁) ▁+ ▁1 ▁, ▁file ▁, ▁line ▁) ▁; ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁strcpy ▁( ▁ret ▁, ▁str ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁int ▁av _ packet _ split _ side _ data ▁( ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁if ▁( ▁! ▁pkt ▁-> ▁side _ data _ elems ▁&& ▁pkt ▁-> ▁size ▁> ▁12 ▁&& ▁AV _ RB 64 ▁( ▁pkt ▁-> ▁data ▁+ ▁pkt ▁-> ▁size ▁- ▁8 ▁) ▁== ▁FF _ MERGE _ MARKER ▁) ▁{ ▁int ▁i ▁; ▁unsigned ▁int ▁size ▁; ▁uint 8_ t ▁* ▁p ▁; ▁av _ dup _ packet ▁( ▁pkt ▁) ▁; ▁p ▁= ▁pkt ▁-> ▁data ▁+ ▁pkt ▁-> ▁size ▁- ▁8 ▁- ▁5 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁; ▁i ▁++ ▁) ▁{ ▁size ▁= ▁AV _ RB 32 ▁( ▁p ▁) ▁; ▁if ▁( ▁size ▁> ▁INT _ MAX ▁|| ▁p ▁- ▁pkt ▁-> ▁data ▁<= ▁size ▁) ▁return ▁0 ▁; ▁if ▁( ▁p ▁[ ▁4 ▁] ▁& ▁128 ▁) ▁break ▁; ▁p ▁-= ▁size ▁+ ▁5 ▁; ▁} ▁pkt ▁-> ▁side _ data ▁= ▁av _ malloc ▁( ▁i ▁* ▁sizeof ▁( ▁* ▁pkt ▁-> ▁side _ data ▁) ▁) ▁; ▁if ▁( ▁! ▁pkt ▁-> ▁side _ data ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁p ▁= ▁pkt ▁-> ▁data ▁+ ▁pkt ▁-> ▁size ▁- ▁8 ▁- ▁5 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁; ▁i ▁++ ▁) ▁{ ▁size ▁= ▁AV _ RB 32 ▁( ▁p ▁) ▁; ▁av _ assert 0 ▁( ▁size ▁<= ▁INT _ MAX ▁&& ▁p ▁- ▁pkt ▁-> ▁data ▁> ▁size ▁) ▁; ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁data ▁= ▁av _ malloc ▁( ▁size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁size ▁= ▁size ▁; ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁type ▁= ▁p ▁[ ▁4 ▁] ▁& ▁127 ▁; ▁if ▁( ▁! ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁data ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁pkt ▁-> ▁side _ data ▁[ ▁i ▁] ▁. ▁data ▁, ▁p ▁- ▁size ▁, ▁size ▁) ▁; ▁pkt ▁-> ▁size ▁-= ▁size ▁+ ▁5 ▁; ▁if ▁( ▁p ▁[ ▁4 ▁] ▁& ▁128 ▁) ▁break ▁; ▁p ▁-= ▁size ▁+ ▁5 ▁; ▁} ▁pkt ▁-> ▁size ▁-= ▁8 ▁; ▁pkt ▁-> ▁side _ data _ elems ▁= ▁i ▁+ ▁1 ▁; ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁avi _ read _ seek ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁stream _ index ▁, ▁int 64_ t ▁timestamp ▁, ▁int ▁flags ▁) ▁{ ▁AV I Context ▁* ▁avi ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVStream ▁* ▁st ▁; ▁int ▁i ▁, ▁index ▁; ▁int 64_ t ▁pos ▁, ▁pos _ min ▁; ▁AV I Stream ▁* ▁ast ▁; ▁if ▁( ▁avi ▁-> ▁dv _ demux ▁) ▁stream _ index ▁= ▁0 ▁; ▁if ▁( ▁! ▁avi ▁-> ▁index _ loaded ▁) ▁{ ▁avi _ load _ index ▁( ▁s ▁) ▁; ▁avi ▁-> ▁index _ loaded ▁|= ▁1 ▁; ▁} ▁av _ assert 0 ▁( ▁stream _ index ▁>= ▁0 ▁) ▁; ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁stream _ index ▁] ▁; ▁ast ▁= ▁st ▁-> ▁priv _ data ▁; ▁index ▁= ▁av _ index _ search _ timestamp ▁( ▁st ▁, ▁timestamp ▁* ▁FF MAX ▁( ▁ast ▁-> ▁sample _ size ▁, ▁1 ▁) ▁, ▁flags ▁) ▁; ▁if ▁( ▁index ▁< ▁0 ▁) ▁{ ▁if ▁( ▁st ▁-> ▁nb _ index _ entries ▁> ▁0 ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Failed tof ind timestamp %" ▁PRId 64 ▁" in index %" ▁PRId 64 ▁".. %" ▁PRId 64 ▁"\ n " ▁, ▁timestamp ▁* ▁FF MAX ▁( ▁ast ▁-> ▁sample _ size ▁, ▁1 ▁) ▁, ▁st ▁-> ▁index _ entries ▁[ ▁0 ▁] ▁. ▁timestamp ▁, ▁st ▁-> ▁index _ entries ▁[ ▁st ▁-> ▁nb _ index _ entries ▁- ▁1 ▁] ▁. ▁timestamp ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁pos ▁= ▁st ▁-> ▁index _ entries ▁[ ▁index ▁] ▁. ▁pos ▁; ▁timestamp ▁= ▁st ▁-> ▁index _ entries ▁[ ▁index ▁] ▁. ▁timestamp ▁/ ▁FF MAX ▁( ▁ast ▁-> ▁sample _ size ▁, ▁1 ▁) ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ TRACE ▁, ▁" XX %" ▁PRId 64 ▁"% d %" ▁PRId 64 ▁"\ n " ▁, ▁timestamp ▁, ▁index ▁, ▁st ▁-> ▁index _ entries ▁[ ▁index ▁] ▁. ▁timestamp ▁) ▁; ▁if ▁( ▁CONFIG _ DV _ DE MUX ER ▁&& ▁avi ▁-> ▁dv _ demux ▁) ▁{ ▁if ▁( ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁pos ▁, ▁SEEK _ SET ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁ff _ dv _ offset _ reset ▁( ▁avi ▁-> ▁dv _ demux ▁, ▁timestamp ▁) ▁; ▁avi ▁-> ▁stream _ index ▁= ▁-1 ▁; ▁return ▁0 ▁; ▁} ▁pos _ min ▁= ▁pos ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁st 2 ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁AV I Stream ▁* ▁ast 2 ▁= ▁st 2 ▁-> ▁priv _ data ▁; ▁ast 2 ▁-> ▁packet _ size ▁= ▁ast 2 ▁-> ▁remaining ▁= ▁0 ▁; ▁if ▁( ▁ast 2 ▁-> ▁sub _ ctx ▁) ▁{ ▁seek _ sub title ▁( ▁st ▁, ▁st 2 ▁, ▁timestamp ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁st 2 ▁-> ▁nb _ index _ entries ▁<= ▁0 ▁) ▁continue ▁; ▁index ▁= ▁av _ index _ search _ timestamp ▁( ▁st 2 ▁, ▁av _ re scale _ q ▁( ▁timestamp ▁, ▁st ▁-> ▁time _ base ▁, ▁st 2 ▁-> ▁time _ base ▁) ▁* ▁FF MAX ▁( ▁ast 2 ▁-> ▁sample _ size ▁, ▁1 ▁) ▁, ▁flags ▁| ▁AV SEEK _ FLAG _ BACK WARD ▁| ▁( ▁st 2 ▁-> ▁codecpar ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ VIDEO ▁? ▁AV SEEK _ FLAG _ ANY ▁: ▁0 ▁) ▁) ▁; ▁if ▁( ▁index ▁< ▁0 ▁) ▁index ▁= ▁0 ▁; ▁ast 2 ▁-> ▁seek _ pos ▁= ▁st 2 ▁-> ▁index _ entries ▁[ ▁index ▁] ▁. ▁pos ▁; ▁pos _ min ▁= ▁FF MIN ▁( ▁pos _ min ▁, ▁ast 2 ▁-> ▁seek _ pos ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁st 2 ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁AV I Stream ▁* ▁ast 2 ▁= ▁st 2 ▁-> ▁priv _ data ▁; ▁if ▁( ▁ast 2 ▁-> ▁sub _ ctx ▁|| ▁st 2 ▁-> ▁nb _ index _ entries ▁<= ▁0 ▁) ▁continue ▁; ▁index ▁= ▁av _ index _ search _ timestamp ▁( ▁st 2 ▁, ▁av _ re scale _ q ▁( ▁timestamp ▁, ▁st ▁-> ▁time _ base ▁, ▁st 2 ▁-> ▁time _ base ▁) ▁* ▁FF MAX ▁( ▁ast 2 ▁-> ▁sample _ size ▁, ▁1 ▁) ▁, ▁flags ▁| ▁AV SEEK _ FLAG _ BACK WARD ▁| ▁( ▁st 2 ▁-> ▁codecpar ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ VIDEO ▁? ▁AV SEEK _ FLAG _ ANY ▁: ▁0 ▁) ▁) ▁; ▁if ▁( ▁index ▁< ▁0 ▁) ▁index ▁= ▁0 ▁; ▁while ▁( ▁! ▁avi ▁-> ▁non _ inter leaved ▁&& ▁index ▁> ▁0 ▁&& ▁st 2 ▁-> ▁index _ entries ▁[ ▁index ▁- ▁1 ▁] ▁. ▁pos ▁>= ▁pos _ min ▁) ▁index ▁-- ▁; ▁ast 2 ▁-> ▁frame _ offset ▁= ▁st 2 ▁-> ▁index _ entries ▁[ ▁index ▁] ▁. ▁timestamp ▁; ▁} ▁if ▁( ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁pos _ min ▁, ▁SEEK _ SET ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Seek failed \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁avi ▁-> ▁stream _ index ▁= ▁-1 ▁; ▁avi ▁-> ▁dts _ max ▁= ▁INT _ MIN ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁decode ▁( ▁RA 288 Context ▁* ▁r act x ▁, ▁float ▁gain ▁, ▁int ▁cb _ coef ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁double ▁sum sum ▁; ▁float ▁sum ▁, ▁buffer ▁[ ▁5 ▁] ▁; ▁float ▁* ▁block ▁= ▁r act x ▁-> ▁sp _ block ▁+ ▁36 ▁; ▁memmove ▁( ▁r act x ▁-> ▁sp _ block ▁, ▁r act x ▁-> ▁sp _ block ▁+ ▁5 ▁, ▁36 ▁* ▁sizeof ▁( ▁* ▁r act x ▁-> ▁sp _ block ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁block ▁[ ▁i ▁] ▁= ▁0. ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁36 ▁; ▁j ▁++ ▁) ▁block ▁[ ▁i ▁] ▁-= ▁block ▁[ ▁i ▁- ▁1 ▁- ▁j ▁] ▁* ▁r act x ▁-> ▁sp _ lpc ▁[ ▁j ▁] ▁; ▁} ▁sum ▁= ▁32 . ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁sum ▁-= ▁r act x ▁-> ▁gain _ block ▁[ ▁9 ▁- ▁i ▁] ▁* ▁r act x ▁-> ▁gain _ lpc ▁[ ▁i ▁] ▁; ▁sum ▁= ▁av _ clip f ▁( ▁sum ▁, ▁0 ▁, ▁60 ▁) ▁; ▁sum sum ▁= ▁exp ▁( ▁sum ▁* ▁0. 11 512 9 254 64 97 ▁) ▁* ▁gain ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁buffer ▁[ ▁i ▁] ▁= ▁code table ▁[ ▁cb _ coef ▁] ▁[ ▁i ▁] ▁* ▁sum sum ▁; ▁sum ▁= ▁scalar _ product _ float ▁( ▁buffer ▁, ▁buffer ▁, ▁5 ▁) ▁/ ▁5 ▁; ▁sum ▁= ▁FF MAX ▁( ▁sum ▁, ▁1 ▁) ▁; ▁memmove ▁( ▁r act x ▁-> ▁gain _ block ▁, ▁r act x ▁-> ▁gain _ block ▁+ ▁1 ▁, ▁9 ▁* ▁sizeof ▁( ▁* ▁r act x ▁-> ▁gain _ block ▁) ▁) ▁; ▁r act x ▁-> ▁gain _ block ▁[ ▁9 ▁] ▁= ▁10 ▁* ▁log 10 ▁( ▁sum ▁) ▁- ▁32 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁i ▁- ▁1 ▁; ▁j ▁>= ▁0 ▁; ▁j ▁-- ▁) ▁buffer ▁[ ▁i ▁] ▁-= ▁r act x ▁-> ▁sp _ lpc ▁[ ▁i ▁- ▁j ▁- ▁1 ▁] ▁* ▁buffer ▁[ ▁j ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁block ▁[ ▁i ▁] ▁= ▁av _ clip f ▁( ▁block ▁[ ▁i ▁] ▁+ ▁buffer ▁[ ▁i ▁] ▁, ▁-40 95 ▁, ▁4095 ▁) ▁; ▁}	0
▁void ▁ff _ thread _ release _ buffer ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁Thread Frame ▁* ▁f ▁) ▁{ ▁Per ThreadContext ▁* ▁p ▁= ▁avctx ▁-> ▁internal ▁-> ▁thread _ ctx ▁; ▁Frame ThreadContext ▁* ▁fctx ▁; ▁AVFrame ▁* ▁dst ▁, ▁* ▁tmp ▁; ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁int ▁can _ direct _ free ▁= ▁! ▁( ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ FRAME ▁) ▁|| ▁avctx ▁-> ▁thread _ safe _ callbacks ▁|| ▁( ▁# if ▁FF _ API _ GET _ BUFFER ▁! ▁avctx ▁-> ▁get _ buffer ▁&& ▁# endif ▁avctx ▁-> ▁get _ buffer 2 ▁== ▁avcodec _ default _ get _ buffer 2 ▁) ▁; ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁if ▁( ▁! ▁f ▁-> ▁f ▁|| ▁! ▁f ▁-> ▁f ▁-> ▁buf ▁[ ▁0 ▁] ▁) ▁return ▁; ▁if ▁( ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ BUFFER S ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" thread _ release _ buffer called on pic % p \ n " ▁, ▁f ▁) ▁; ▁av _ buffer _ unref ▁( ▁& ▁f ▁-> ▁progress ▁) ▁; ▁f ▁-> ▁owner ▁= ▁NULL ▁; ▁if ▁( ▁can _ direct _ free ▁) ▁{ ▁av _ frame _ unref ▁( ▁f ▁-> ▁f ▁) ▁; ▁return ▁; ▁} ▁fctx ▁= ▁p ▁-> ▁parent ▁; ▁pthread _ mutex _ lock ▁( ▁& ▁fctx ▁-> ▁buffer _ mutex ▁) ▁; ▁if ▁( ▁p ▁-> ▁num _ release d _ buffers ▁+ ▁1 ▁>= ▁INT _ MAX ▁/ ▁sizeof ▁( ▁* ▁p ▁-> ▁released _ buffers ▁) ▁) ▁goto ▁fail ▁; ▁tmp ▁= ▁av _ fast _ realloc ▁( ▁p ▁-> ▁released _ buffers ▁, ▁& ▁p ▁-> ▁released _ buffers _ allocated ▁, ▁( ▁p ▁-> ▁num _ release d _ buffers ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁* ▁p ▁-> ▁released _ buffers ▁) ▁) ▁; ▁if ▁( ▁! ▁tmp ▁) ▁goto ▁fail ▁; ▁p ▁-> ▁released _ buffers ▁= ▁tmp ▁; ▁dst ▁= ▁& ▁p ▁-> ▁released _ buffers ▁[ ▁p ▁-> ▁num _ release d _ buffers ▁] ▁; ▁av _ frame _ move _ ref ▁( ▁dst ▁, ▁f ▁-> ▁f ▁) ▁; ▁p ▁-> ▁num _ release d _ buffers ▁++ ▁; ▁fail ▁: ▁pthread _ mutex _ unlock ▁( ▁& ▁fctx ▁-> ▁buffer _ mutex ▁) ▁; ▁}	0
▁static ▁void ▁extr ap olate _ is f ▁( ▁float ▁out ▁[ ▁LP _ ORDER _16 k ▁] ▁, ▁float ▁is f ▁[ ▁LP _ ORDER ▁] ▁) ▁{ ▁float ▁diff _ is f ▁[ ▁LP _ ORDER ▁- ▁2 ▁] ▁, ▁diff _ mean ▁; ▁float ▁* ▁diff _ hi ▁= ▁diff _ is f ▁- ▁LP _ ORDER ▁+ ▁1 ▁; ▁float ▁corr _ lag ▁[ ▁3 ▁] ▁; ▁float ▁est ▁, ▁scale ▁; ▁int ▁i ▁, ▁i _ max _ corr ▁; ▁memcpy ▁( ▁out ▁, ▁is f ▁, ▁( ▁LP _ ORDER ▁- ▁1 ▁) ▁* ▁sizeof ▁( ▁float ▁) ▁) ▁; ▁out ▁[ ▁LP _ ORDER _16 k ▁- ▁1 ▁] ▁= ▁is f ▁[ ▁LP _ ORDER ▁- ▁1 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁LP _ ORDER ▁- ▁2 ▁; ▁i ▁++ ▁) ▁diff _ is f ▁[ ▁i ▁] ▁= ▁is f ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁is f ▁[ ▁i ▁] ▁; ▁diff _ mean ▁= ▁0.0 ▁; ▁for ▁( ▁i ▁= ▁2 ▁; ▁i ▁< ▁LP _ ORDER ▁- ▁2 ▁; ▁i ▁++ ▁) ▁diff _ mean ▁+= ▁diff _ is f ▁[ ▁i ▁] ▁* ▁( ▁1.0 f ▁/ ▁( ▁LP _ ORDER ▁- ▁4 ▁) ▁) ▁; ▁i _ max _ corr ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁corr _ lag ▁[ ▁i ▁] ▁= ▁auto _ cor relation ▁( ▁diff _ is f ▁, ▁diff _ mean ▁, ▁i ▁+ ▁2 ▁) ▁; ▁if ▁( ▁corr _ lag ▁[ ▁i ▁] ▁> ▁corr _ lag ▁[ ▁i _ max _ corr ▁] ▁) ▁i _ max _ corr ▁= ▁i ▁; ▁} ▁i _ max _ corr ▁++ ▁; ▁for ▁( ▁i ▁= ▁LP _ ORDER ▁- ▁1 ▁; ▁i ▁< ▁LP _ ORDER _16 k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁out ▁[ ▁i ▁] ▁= ▁is f ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁is f ▁[ ▁i ▁- ▁1 ▁- ▁i _ max _ corr ▁] ▁- ▁is f ▁[ ▁i ▁- ▁2 ▁- ▁i _ max _ corr ▁] ▁; ▁est ▁= ▁79 65 ▁+ ▁( ▁out ▁[ ▁2 ▁] ▁- ▁out ▁[ ▁3 ▁] ▁- ▁out ▁[ ▁4 ▁] ▁) ▁/ ▁6.0 ▁; ▁scale ▁= ▁0.5 ▁* ▁( ▁FF MIN ▁( ▁est ▁, ▁7 600 ▁) ▁- ▁out ▁[ ▁LP _ ORDER ▁- ▁2 ▁] ▁) ▁/ ▁( ▁out ▁[ ▁LP _ ORDER _16 k ▁- ▁2 ▁] ▁- ▁out ▁[ ▁LP _ ORDER ▁- ▁2 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁LP _ ORDER ▁- ▁1 ▁; ▁i ▁< ▁LP _ ORDER _16 k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁diff _ hi ▁[ ▁i ▁] ▁= ▁scale ▁* ▁( ▁out ▁[ ▁i ▁] ▁- ▁out ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁LP _ ORDER ▁; ▁i ▁< ▁LP _ ORDER _16 k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁if ▁( ▁diff _ hi ▁[ ▁i ▁] ▁+ ▁diff _ hi ▁[ ▁i ▁- ▁1 ▁] ▁< ▁5.0 ▁) ▁{ ▁if ▁( ▁diff _ hi ▁[ ▁i ▁] ▁> ▁diff _ hi ▁[ ▁i ▁- ▁1 ▁] ▁) ▁{ ▁diff _ hi ▁[ ▁i ▁- ▁1 ▁] ▁= ▁5.0 ▁- ▁diff _ hi ▁[ ▁i ▁] ▁; ▁} ▁else ▁diff _ hi ▁[ ▁i ▁] ▁= ▁5.0 ▁- ▁diff _ hi ▁[ ▁i ▁- ▁1 ▁] ▁; ▁} ▁for ▁( ▁i ▁= ▁LP _ ORDER ▁- ▁1 ▁; ▁i ▁< ▁LP _ ORDER _16 k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁out ▁[ ▁i ▁] ▁= ▁out ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁diff _ hi ▁[ ▁i ▁] ▁* ▁( ▁1.0 f ▁/ ▁( ▁1 ▁<< ▁15 ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁LP _ ORDER _16 k ▁- ▁1 ▁; ▁i ▁++ ▁) ▁out ▁[ ▁i ▁] ▁*= ▁0.8 ▁; ▁}	1
▁int ▁BLAKE 2 b _ Update ▁( ▁BLAKE 2 B _ CTX ▁* ▁c ▁, ▁const ▁void ▁* ▁data ▁, ▁size _ t ▁datalen ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁in ▁= ▁data ▁; ▁size _ t ▁fill ▁; ▁while ▁( ▁datalen ▁> ▁0 ▁) ▁{ ▁fill ▁= ▁sizeof ▁( ▁c ▁-> ▁buf ▁) ▁- ▁c ▁-> ▁buflen ▁; ▁if ▁( ▁datalen ▁> ▁fill ▁) ▁{ ▁memcpy ▁( ▁c ▁-> ▁buf ▁+ ▁c ▁-> ▁buflen ▁, ▁in ▁, ▁fill ▁) ▁; ▁blake 2 b _ increment _ counter ▁( ▁c ▁, ▁BLAKE 2 B _ BLOCK BYTES ▁) ▁; ▁blake 2 b _ compress ▁( ▁c ▁, ▁c ▁-> ▁buf ▁) ▁; ▁c ▁-> ▁buflen ▁= ▁0 ▁; ▁in ▁+= ▁fill ▁; ▁datalen ▁-= ▁fill ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁c ▁-> ▁buf ▁+ ▁c ▁-> ▁buflen ▁, ▁in ▁, ▁datalen ▁) ▁; ▁c ▁-> ▁buflen ▁+= ▁datalen ▁; ▁return ▁1 ▁; ▁} ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁void ▁block _ in ▁( ▁BIO ▁* ▁b ▁) ▁{ ▁BIO _ OK _ CTX ▁* ▁ctx ▁; ▁EVP _ MD _ CTX ▁* ▁md ▁; ▁long ▁tl ▁= ▁0 ▁; ▁unsigned ▁char ▁tmp ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁ctx ▁= ▁( ▁BIO _ OK _ CTX ▁* ▁) ▁b ▁-> ▁ptr ▁; ▁md ▁= ▁& ▁( ▁ctx ▁-> ▁md ▁) ▁; ▁memcpy ▁( ▁& ▁tl ▁, ▁ctx ▁-> ▁buf ▁, ▁OK _ BLOCK _ BLOCK ▁) ▁; ▁tl ▁= ▁sw ape m ▁( ▁tl ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁buf _ len ▁< ▁tl ▁+ ▁OK _ BLOCK _ BLOCK ▁+ ▁md ▁-> ▁digest ▁-> ▁md _ size ▁) ▁return ▁; ▁EVP _ DigestUpdate ▁( ▁md ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁( ▁ctx ▁-> ▁buf ▁[ ▁OK _ BLOCK _ BLOCK ▁] ▁) ▁, ▁tl ▁) ▁; ▁md ▁-> ▁digest ▁-> ▁final ▁( ▁tmp ▁, ▁& ▁( ▁md ▁-> ▁md ▁. ▁base ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁memcmp ▁( ▁& ▁( ▁ctx ▁-> ▁buf ▁[ ▁tl ▁+ ▁OK _ BLOCK _ BLOCK ▁] ▁) ▁, ▁tmp ▁, ▁md ▁-> ▁digest ▁-> ▁md _ size ▁) ▁== ▁0 ▁) ▁{ ▁ctx ▁-> ▁buf _ off _ save ▁= ▁tl ▁+ ▁OK _ BLOCK _ BLOCK ▁+ ▁md ▁-> ▁digest ▁-> ▁md _ size ▁; ▁ctx ▁-> ▁buf _ len _ save ▁= ▁ctx ▁-> ▁buf _ len ▁; ▁ctx ▁-> ▁buf _ off ▁= ▁OK _ BLOCK _ BLOCK ▁; ▁ctx ▁-> ▁buf _ len ▁= ▁tl ▁+ ▁OK _ BLOCK _ BLOCK ▁; ▁ctx ▁-> ▁block out ▁= ▁1 ▁; ▁} ▁else ▁{ ▁ctx ▁-> ▁cont ▁= ▁0 ▁; ▁} ▁}	1
▁static ▁int ▁ir 2_ decode _ plane ▁( ▁I r 2 Context ▁* ▁ctx ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁pitch ▁, ▁const ▁uint 8_ t ▁* ▁table ▁) ▁{ ▁int ▁i ▁; ▁int ▁j ▁; ▁int ▁out ▁= ▁0 ▁; ▁if ▁( ▁width ▁& ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁while ▁( ▁out ▁< ▁width ▁) ▁{ ▁int ▁c ▁= ▁ir 2_ get _ code ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁if ▁( ▁c ▁>= ▁0 x 80 ▁) ▁{ ▁c ▁-= ▁0 x 7 F ▁; ▁if ▁( ▁out ▁+ ▁c ▁* ▁2 ▁> ▁width ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁* ▁2 ▁; ▁i ▁++ ▁) ▁dst ▁[ ▁out ▁++ ▁] ▁= ▁0 x 80 ▁; ▁} ▁else ▁{ ▁dst ▁[ ▁out ▁++ ▁] ▁= ▁table ▁[ ▁c ▁* ▁2 ▁] ▁; ▁dst ▁[ ▁out ▁++ ▁] ▁= ▁table ▁[ ▁( ▁c ▁* ▁2 ▁) ▁+ ▁1 ▁] ▁; ▁} ▁} ▁dst ▁+= ▁pitch ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁height ▁; ▁j ▁++ ▁) ▁{ ▁out ▁= ▁0 ▁; ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁<= ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁while ▁( ▁out ▁< ▁width ▁) ▁{ ▁int ▁c ▁= ▁ir 2_ get _ code ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁if ▁( ▁c ▁>= ▁0 x 80 ▁) ▁{ ▁c ▁-= ▁0 x 7 F ▁; ▁if ▁( ▁out ▁+ ▁c ▁* ▁2 ▁> ▁width ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁* ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁dst ▁[ ▁out ▁] ▁= ▁dst ▁[ ▁out ▁- ▁pitch ▁] ▁; ▁out ▁++ ▁; ▁} ▁} ▁else ▁{ ▁int ▁t ▁= ▁dst ▁[ ▁out ▁- ▁pitch ▁] ▁+ ▁( ▁table ▁[ ▁c ▁* ▁2 ▁] ▁- ▁128 ▁) ▁; ▁t ▁= ▁av _ clip _ uint 8 ▁( ▁t ▁) ▁; ▁dst ▁[ ▁out ▁] ▁= ▁t ▁; ▁out ▁++ ▁; ▁t ▁= ▁dst ▁[ ▁out ▁- ▁pitch ▁] ▁+ ▁( ▁table ▁[ ▁( ▁c ▁* ▁2 ▁) ▁+ ▁1 ▁] ▁- ▁128 ▁) ▁; ▁t ▁= ▁av _ clip _ uint 8 ▁( ▁t ▁) ▁; ▁dst ▁[ ▁out ▁] ▁= ▁t ▁; ▁out ▁++ ▁; ▁} ▁} ▁dst ▁+= ▁pitch ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁ap ng _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁AP NG Demux Context ▁* ▁ctx ▁= ▁s ▁-> ▁priv _ data ▁; ▁int 64_ t ▁ret ▁; ▁int 64_ t ▁size ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁uint 32_ t ▁len ▁, ▁tag ▁; ▁if ▁( ▁ctx ▁-> ▁num _ play ▁== ▁1 ▁&& ▁( ▁ret ▁= ▁ff io _ ensure _ seek back ▁( ▁pb ▁, ▁46 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁len ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁switch ▁( ▁tag ▁) ▁{ ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁if ▁( ▁len ▁!= ▁26 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁( ▁ret ▁= ▁decode _ f ctl _ chunk ▁( ▁s ▁, ▁ctx ▁, ▁pkt ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁len ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁len ▁> ▁0 x 7 fffffff ▁|| ▁tag ▁!= ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁&& ▁tag ▁!= ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁size ▁= ▁38 ▁+ ▁8 ▁+ ▁len ▁+ ▁4 ▁; ▁if ▁( ▁size ▁> ▁INT _ MAX ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁avio _ seek ▁( ▁pb ▁, ▁- 46 ▁, ▁SEEK _ CUR ▁) ▁) ▁< ▁0 ▁|| ▁( ▁ret ▁= ▁av _ append _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁ctx ▁-> ▁num _ play ▁== ▁1 ▁&& ▁( ▁ret ▁= ▁ff io _ ensure _ seek back ▁( ▁pb ▁, ▁8 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁len ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁while ▁( ▁tag ▁&& ▁tag ▁!= ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁&& ▁tag ▁!= ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁if ▁( ▁len ▁> ▁0 x 7 fffffff ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁( ▁ret ▁= ▁avio _ seek ▁( ▁pb ▁, ▁-8 ▁, ▁SEEK _ CUR ▁) ▁) ▁< ▁0 ▁|| ▁( ▁ret ▁= ▁av _ append _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁len ▁+ ▁12 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁ctx ▁-> ▁num _ play ▁== ▁1 ▁&& ▁( ▁ret ▁= ▁ff io _ ensure _ seek back ▁( ▁pb ▁, ▁8 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁len ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁avio _ seek ▁( ▁pb ▁, ▁-8 ▁, ▁SEEK _ CUR ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁ctx ▁-> ▁is _ key _ frame ▁) ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ KEY ▁; ▁pkt ▁-> ▁pts ▁= ▁ctx ▁-> ▁pkt _ pts ▁; ▁pkt ▁-> ▁duration ▁= ▁ctx ▁-> ▁pkt _ duration ▁; ▁ctx ▁-> ▁pkt _ pts ▁+= ▁ctx ▁-> ▁pkt _ duration ▁; ▁return ▁ret ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁ctx ▁-> ▁cur _ loop ▁++ ▁; ▁if ▁( ▁ctx ▁-> ▁ignore _ loop ▁|| ▁ctx ▁-> ▁num _ play ▁>= ▁1 ▁&& ▁ctx ▁-> ▁cur _ loop ▁== ▁ctx ▁-> ▁num _ play ▁) ▁{ ▁avio _ seek ▁( ▁pb ▁, ▁-8 ▁, ▁SEEK _ CUR ▁) ▁; ▁return ▁AVERROR _ EOF ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁avio _ seek ▁( ▁pb ▁, ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codecpar ▁-> ▁extradata _ size ▁+ ▁8 ▁, ▁SEEK _ SET ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁return ▁0 ▁; ▁default ▁: ▁{ ▁char ▁tag _ buf ▁[ ▁32 ▁] ▁; ▁av _ get _ codec _ tag _ string ▁( ▁tag _ buf ▁, ▁sizeof ▁( ▁tag _ buf ▁) ▁, ▁tag ▁) ▁; ▁avpriv _ request _ sample ▁( ▁s ▁, ▁" In - stream tag =% s (0 x %08 X ) len =% " ▁PRIu 32 ▁, ▁tag _ buf ▁, ▁tag ▁, ▁len ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁len ▁+ ▁4 ▁) ▁; ▁} ▁} ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁}	0
▁static ▁int ▁sh _ init ▁( ▁size _ t ▁size ▁, ▁int ▁min size ▁) ▁{ ▁int ▁i ▁, ▁ret ▁; ▁size _ t ▁pg size ▁; ▁size _ t ▁aligned ▁; ▁memset ▁( ▁& ▁sh ▁, ▁0 ▁, ▁sizeof ▁sh ▁) ▁; ▁OPENSSL _ assert ▁( ▁size ▁> ▁0 ▁) ▁; ▁OPENSSL _ assert ▁( ▁( ▁size ▁& ▁( ▁size ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁; ▁OPENSSL _ assert ▁( ▁min size ▁> ▁0 ▁) ▁; ▁OPENSSL _ assert ▁( ▁( ▁min size ▁& ▁( ▁min size ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁; ▁if ▁( ▁size ▁<= ▁0 ▁|| ▁( ▁size ▁& ▁( ▁size ▁- ▁1 ▁) ▁) ▁!= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁min size ▁<= ▁0 ▁|| ▁( ▁min size ▁& ▁( ▁min size ▁- ▁1 ▁) ▁) ▁!= ▁0 ▁) ▁goto ▁err ▁; ▁sh ▁. ▁arena _ size ▁= ▁size ▁; ▁sh ▁. ▁min size ▁= ▁min size ▁; ▁sh ▁. ▁bit table _ size ▁= ▁( ▁sh ▁. ▁arena _ size ▁/ ▁sh ▁. ▁min size ▁) ▁* ▁2 ▁; ▁sh ▁. ▁fre elist _ size ▁= ▁-1 ▁; ▁for ▁( ▁i ▁= ▁sh ▁. ▁bit table _ size ▁; ▁i ▁; ▁i ▁>>= ▁1 ▁) ▁sh ▁. ▁fre elist _ size ▁++ ▁; ▁sh ▁. ▁fre elist ▁= ▁OPENSSL _ zalloc ▁( ▁sh ▁. ▁fre elist _ size ▁* ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁OPENSSL _ assert ▁( ▁sh ▁. ▁fre elist ▁!= ▁NULL ▁) ▁; ▁if ▁( ▁sh ▁. ▁fre elist ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁sh ▁. ▁bit table ▁= ▁OPENSSL _ zalloc ▁( ▁sh ▁. ▁bit table _ size ▁>> ▁3 ▁) ▁; ▁OPENSSL _ assert ▁( ▁sh ▁. ▁bit table ▁!= ▁NULL ▁) ▁; ▁if ▁( ▁sh ▁. ▁bit table ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁sh ▁. ▁bit malloc ▁= ▁OPENSSL _ zalloc ▁( ▁sh ▁. ▁bit table _ size ▁>> ▁3 ▁) ▁; ▁OPENSSL _ assert ▁( ▁sh ▁. ▁bit malloc ▁!= ▁NULL ▁) ▁; ▁if ▁( ▁sh ▁. ▁bit malloc ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁# if ▁defined ▁( ▁_ SC _ PAGE _ SIZE ▁) ▁|| ▁defined ▁( ▁_ SC _ PAGESIZE ▁) ▁{ ▁# if ▁defined ▁( ▁_ SC _ PAGE _ SIZE ▁) ▁long ▁tmp pg size ▁= ▁sysconf ▁( ▁_ SC _ PAGE _ SIZE ▁) ▁; ▁# else ▁long ▁tmp pg size ▁= ▁sysconf ▁( ▁_ SC _ PAGESIZE ▁) ▁; ▁# endif ▁if ▁( ▁tmp pg size ▁< ▁1 ▁) ▁pg size ▁= ▁PAGE _ SIZE ▁; ▁else ▁pg size ▁= ▁( ▁size _ t ▁) ▁tmp pg size ▁; ▁} ▁# else ▁pg size ▁= ▁PAGE _ SIZE ▁; ▁# endif ▁sh ▁. ▁map _ size ▁= ▁pg size ▁+ ▁sh ▁. ▁arena _ size ▁+ ▁pg size ▁; ▁if ▁( ▁1 ▁) ▁{ ▁# ifdef ▁MAP _ ANON ▁sh ▁. ▁map _ result ▁= ▁mmap ▁( ▁NULL ▁, ▁sh ▁. ▁map _ size ▁, ▁PROT _ READ ▁| ▁PROT _ WRITE ▁, ▁MAP _ ANON ▁| ▁MAP _ PRIVATE ▁, ▁-1 ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁# endif ▁int fd ; ▁sh ▁. ▁map _ result ▁= ▁MAP _ FAILED ▁; ▁if ▁( ▁( ▁fd ▁= ▁open ▁( ▁"/ dev / zero " ▁, ▁O _ RDWR ▁) ▁) ▁>= ▁0 ▁) ▁{ ▁sh ▁. ▁map _ result ▁= ▁mmap ▁( ▁NULL ▁, ▁sh ▁. ▁map _ size ▁, ▁PROT _ READ ▁| ▁PROT _ WRITE ▁, ▁MAP _ PRIVATE ▁, ▁fd ▁, ▁0 ▁) ▁; ▁close ▁( ▁fd ▁) ▁; ▁} ▁} ▁OPENSSL _ assert ▁( ▁sh ▁. ▁map _ result ▁!= ▁MAP _ FAILED ▁) ▁; ▁if ▁( ▁sh ▁. ▁map _ result ▁== ▁MAP _ FAILED ▁) ▁goto ▁err ▁; ▁sh ▁. ▁arena ▁= ▁( ▁char ▁* ▁) ▁( ▁sh ▁. ▁map _ result ▁+ ▁pg size ▁) ▁; ▁sh _ set bit ▁( ▁sh ▁. ▁arena ▁, ▁0 ▁, ▁sh ▁. ▁bit table ▁) ▁; ▁sh _ add _ to _ list ▁( ▁& ▁sh ▁. ▁fre elist ▁[ ▁0 ▁] ▁, ▁sh ▁. ▁arena ▁) ▁; ▁ret ▁= ▁1 ▁; ▁if ▁( ▁mp rotect ▁( ▁sh ▁. ▁map _ result ▁, ▁pg size ▁, ▁PROT _ NONE ▁) ▁< ▁0 ▁) ▁ret ▁= ▁2 ▁; ▁aligned ▁= ▁( ▁pg size ▁+ ▁sh ▁. ▁arena _ size ▁+ ▁( ▁pg size ▁- ▁1 ▁) ▁) ▁& ▁ ~ ▁( ▁pg size ▁- ▁1 ▁) ▁; ▁if ▁( ▁mp rotect ▁( ▁sh ▁. ▁map _ result ▁+ ▁aligned ▁, ▁pg size ▁, ▁PROT _ NONE ▁) ▁< ▁0 ▁) ▁ret ▁= ▁2 ▁; ▁if ▁( ▁m lock ▁( ▁sh ▁. ▁arena ▁, ▁sh ▁. ▁arena _ size ▁) ▁< ▁0 ▁) ▁ret ▁= ▁2 ▁; ▁# ifdef ▁M ADV _ DONT DUMP ▁if ▁( ▁m advise ▁( ▁sh ▁. ▁arena ▁, ▁sh ▁. ▁arena _ size ▁, ▁M ADV _ DONT DUMP ▁) ▁< ▁0 ▁) ▁ret ▁= ▁2 ▁; ▁# endif ▁return ▁ret ▁; ▁err ▁: ▁sh _ done ▁( ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁pkey param _ main ▁( ▁int ▁argc ▁, ▁char ▁* ▁* ▁argv ▁) ▁{ ▁ENGINE ▁* ▁e ▁= ▁NULL ▁; ▁BIO ▁* ▁in ▁= ▁NULL ▁, ▁* ▁out ▁= ▁NULL ▁; ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁int ▁text ▁= ▁0 ▁, ▁n oo ut ▁= ▁0 ▁, ▁ret ▁= ▁1 ▁, ▁check ▁= ▁0 ▁; ▁OPTION _ CHOICE ▁o ▁; ▁char ▁* ▁infile ▁= ▁NULL ▁, ▁* ▁outfile ▁= ▁NULL ▁, ▁* ▁prog ▁; ▁prog ▁= ▁opt _ init ▁( ▁argc ▁, ▁argv ▁, ▁pkey param _ options ▁) ▁; ▁while ▁( ▁( ▁o ▁= ▁opt _ next ▁( ▁) ▁) ▁!= ▁OPT _ EOF ▁) ▁{ ▁switch ▁( ▁o ▁) ▁{ ▁case ▁OPT _ EOF ▁: ▁case ▁OPT _ ERR ▁: ▁opt help ▁: ▁BIO _ printf ▁( ▁bio _ err ▁, ▁"% s : Use - help for summary .\ n " ▁, ▁prog ▁) ▁; ▁goto ▁end ▁; ▁case ▁OPT _ HELP ▁: ▁opt _ help ▁( ▁pkey param _ options ▁) ▁; ▁ret ▁= ▁0 ▁; ▁goto ▁end ▁; ▁case ▁OPT _ IN ▁: ▁infile ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ OUT ▁: ▁outfile ▁= ▁opt _ arg ▁( ▁) ▁; ▁break ▁; ▁case ▁OPT _ ENGINE ▁: ▁e ▁= ▁setup _ engine ▁( ▁opt _ arg ▁( ▁) ▁, ▁0 ▁) ▁; ▁break ▁; ▁case ▁OPT _ TEXT ▁: ▁text ▁= ▁1 ▁; ▁break ▁; ▁case ▁OPT _ NO OUT ▁: ▁n oo ut ▁= ▁1 ▁; ▁break ▁; ▁case ▁OPT _ CHECK ▁: ▁check ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁argc ▁= ▁opt _ num _ rest ▁( ▁) ▁; ▁if ▁( ▁argc ▁!= ▁0 ▁) ▁goto ▁opt help ▁; ▁in ▁= ▁bio _ open _ default ▁( ▁infile ▁, ▁' ▁' ▁, ▁FORMAT _ PEM ▁) ▁; ▁if ▁( ▁in ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁out ▁= ▁bio _ open _ default ▁( ▁outfile ▁, ▁' ▁' ▁, ▁FORMAT _ PEM ▁) ▁; ▁if ▁( ▁out ▁== ▁NULL ▁) ▁goto ▁end ▁; ▁pkey ▁= ▁PEM _ read _ bio _ Parameters ▁( ▁in ▁, ▁NULL ▁) ▁; ▁if ▁( ▁pkey ▁== ▁NULL ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Error reading parameters \ n " ▁) ▁; ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁check ▁) ▁{ ▁int ▁r ▁; ▁EVP _ PKEY _ CTX ▁* ▁ctx ▁; ▁ctx ▁= ▁EVP _ PKEY _ CTX _ new ▁( ▁pkey ▁, ▁e ▁) ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁ERR _ print _ errors ▁( ▁bio _ err ▁) ▁; ▁goto ▁end ▁; ▁} ▁r ▁= ▁EVP _ PKEY _ param _ check ▁( ▁ctx ▁) ▁; ▁if ▁( ▁r ▁== ▁1 ▁) ▁{ ▁BIO _ printf ▁( ▁out ▁, ▁" Parameters are valid \ n " ▁) ▁; ▁} ▁else ▁{ ▁unsigned ▁long ▁err ▁; ▁BIO _ printf ▁( ▁out ▁, ▁" Parameters are invalid \ n " ▁) ▁; ▁while ▁( ▁( ▁err ▁= ▁ERR _ peek _ error ▁( ▁) ▁) ▁!= ▁0 ▁) ▁{ ▁BIO _ printf ▁( ▁out ▁, ▁" D eta ile derr or :% s \ n " ▁, ▁ERR _ reason _ error _ string ▁( ▁err ▁) ▁) ▁; ▁ERR _ get _ error ▁( ▁) ▁; ▁} ▁} ▁EVP _ PKEY _ CTX _ free ▁( ▁ctx ▁) ▁; ▁} ▁if ▁( ▁! ▁n oo ut ▁) ▁PEM _ write _ bio _ Parameters ▁( ▁out ▁, ▁pkey ▁) ▁; ▁if ▁( ▁text ▁) ▁EVP _ PKEY _ print _ params ▁( ▁out ▁, ▁pkey ▁, ▁0 ▁, ▁NULL ▁) ▁; ▁ret ▁= ▁0 ▁; ▁end ▁: ▁EVP _ PKEY _ free ▁( ▁pkey ▁) ▁; ▁release _ engine ▁( ▁e ▁) ▁; ▁BIO _ free _ all ▁( ▁out ▁) ▁; ▁BIO _ free ▁( ▁in ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁void ▁PS Data Color Cont ig ▁( ▁FILE ▁* ▁fd ▁, ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁w ▁, ▁uint 32 ▁h ▁, ▁int ▁nc ▁) ▁{ ▁uint 32 ▁row ▁; ▁int ▁break len ▁= ▁MAX LINE ▁, ▁es ▁= ▁samples per pixel ▁- ▁nc ▁; ▁tsize _ t ▁cc ▁; ▁unsigned ▁char ▁* ▁tf _ buf ▁; ▁unsigned ▁char ▁* ▁cp ▁, ▁c ▁; ▁( ▁void ▁) ▁w ▁; ▁if ▁( ▁es ▁<= ▁0 ▁) ▁{ ▁TIFF Error ▁( ▁filename ▁, ▁" In consistent value of es :% d " ▁, ▁es ▁) ▁; ▁return ▁; ▁} ▁tf _ buf ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁_ TIFF malloc ▁( ▁tf _ bytes per row ▁) ▁; ▁if ▁( ▁tf _ buf ▁== ▁NULL ▁) ▁{ ▁TIFF Error ▁( ▁filename ▁, ▁" N os pace for scanline buffer " ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁row ▁= ▁0 ▁; ▁row ▁< ▁h ▁; ▁row ▁++ ▁) ▁{ ▁if ▁( ▁TIFF Read Scan line ▁( ▁tif ▁, ▁tf _ buf ▁, ▁row ▁, ▁0 ▁) ▁< ▁0 ▁) ▁break ▁; ▁cp ▁= ▁tf _ buf ▁; ▁if ▁( ▁bits pers ample ▁== ▁16 ▁&& ▁! ▁HOST _ BIG ENDIAN ▁) ▁{ ▁PS _ Flip Bytes ▁( ▁cp ▁, ▁tf _ bytes per row ▁) ▁; ▁} ▁if ▁( ▁alpha ▁) ▁{ ▁int ▁adjust ▁; ▁cc ▁= ▁0 ▁; ▁for ▁( ▁; ▁cc ▁< ▁tf _ bytes per row ▁; ▁cc ▁+= ▁samples per pixel ▁) ▁{ ▁DO BREAK ▁( ▁break len ▁, ▁nc ▁, ▁fd ▁) ▁; ▁adjust ▁= ▁255 ▁- ▁cp ▁[ ▁nc ▁] ▁; ▁switch ▁( ▁nc ▁) ▁{ ▁case ▁4 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁+ ▁adjust ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁case ▁3 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁+ ▁adjust ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁case ▁2 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁+ ▁adjust ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁case ▁1 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁+ ▁adjust ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁} ▁cp ▁+= ▁es ▁; ▁} ▁} ▁else ▁{ ▁cc ▁= ▁0 ▁; ▁for ▁( ▁; ▁cc ▁< ▁tf _ bytes per row ▁; ▁cc ▁+= ▁samples per pixel ▁) ▁{ ▁DO BREAK ▁( ▁break len ▁, ▁nc ▁, ▁fd ▁) ▁; ▁switch ▁( ▁nc ▁) ▁{ ▁case ▁4 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁case ▁3 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁case ▁2 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁case ▁1 ▁: ▁c ▁= ▁* ▁cp ▁++ ▁; ▁P UTH EX ▁( ▁c ▁, ▁fd ▁) ▁; ▁} ▁cp ▁+= ▁es ▁; ▁} ▁} ▁} ▁_ TIFF free ▁( ▁( ▁char ▁* ▁) ▁tf _ buf ▁) ▁; ▁}	1
▁int ▁OCSP _ parse _ url ▁( ▁const ▁char ▁* ▁url ▁, ▁char ▁* ▁* ▁phost ▁, ▁char ▁* ▁* ▁p port ▁, ▁char ▁* ▁* ▁p path ▁, ▁int ▁* ▁p ssl ▁) ▁{ ▁char ▁* ▁p ▁, ▁* ▁buf ▁; ▁char ▁* ▁host ▁, ▁* ▁port ▁; ▁* ▁phost ▁= ▁NULL ▁; ▁* ▁p port ▁= ▁NULL ▁; ▁* ▁p path ▁= ▁NULL ▁; ▁buf ▁= ▁OPENSSL _ strdup ▁( ▁url ▁) ▁; ▁if ▁( ▁! ▁buf ▁) ▁goto ▁mem _ err ▁; ▁p ▁= ▁strchr ▁( ▁buf ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁! ▁p ▁) ▁goto ▁parse _ err ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁strcmp ▁( ▁buf ▁, ▁" http " ▁) ▁== ▁0 ▁) ▁{ ▁* ▁p ssl ▁= ▁0 ▁; ▁port ▁= ▁" 80" ▁; ▁} ▁else ▁if ▁( ▁strcmp ▁( ▁buf ▁, ▁" https " ▁) ▁== ▁0 ▁) ▁{ ▁* ▁p ssl ▁= ▁1 ▁; ▁port ▁= ▁" 44 3" ▁; ▁} ▁else ▁goto ▁parse _ err ▁; ▁if ▁( ▁( ▁p ▁[ ▁0 ▁] ▁!= ▁' ▁' ▁) ▁|| ▁( ▁p ▁[ ▁1 ▁] ▁!= ▁' ▁' ▁) ▁) ▁goto ▁parse _ err ▁; ▁p ▁+= ▁2 ▁; ▁host ▁= ▁p ▁; ▁p ▁= ▁strchr ▁( ▁p ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁! ▁p ▁) ▁* ▁p path ▁= ▁OPENSSL _ strdup ▁( ▁"/" ▁) ▁; ▁else ▁{ ▁* ▁p path ▁= ▁OPENSSL _ strdup ▁( ▁p ▁) ▁; ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁! ▁* ▁p path ▁) ▁goto ▁mem _ err ▁; ▁p ▁= ▁host ▁; ▁if ▁( ▁host ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁host ▁++ ▁; ▁p ▁= ▁strchr ▁( ▁host ▁, ▁' ▁' ▁) ▁; ▁if ▁( ▁! ▁p ▁) ▁goto ▁parse _ err ▁; ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁p ▁++ ▁; ▁} ▁if ▁( ▁( ▁p ▁= ▁strchr ▁( ▁p ▁, ▁' ▁' ▁) ▁) ▁) ▁{ ▁* ▁p ▁= ▁0 ▁; ▁port ▁= ▁p ▁+ ▁1 ▁; ▁} ▁* ▁p port ▁= ▁OPENSSL _ strdup ▁( ▁port ▁) ▁; ▁if ▁( ▁! ▁* ▁p port ▁) ▁goto ▁mem _ err ▁; ▁* ▁phost ▁= ▁OPENSSL _ strdup ▁( ▁host ▁) ▁; ▁if ▁( ▁! ▁* ▁phost ▁) ▁goto ▁mem _ err ▁; ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁return ▁1 ▁; ▁mem _ err ▁: ▁OCSP err ▁( ▁OCSP _ F _ OCSP _ PARSE _ URL ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁parse _ err ▁: ▁OCSP err ▁( ▁OCSP _ F _ OCSP _ PARSE _ URL ▁, ▁OCSP _ R _ ERROR _ PAR SING _ URL ▁) ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁OPENSSL _ free ▁( ▁* ▁p path ▁) ▁; ▁OPENSSL _ free ▁( ▁* ▁p port ▁) ▁; ▁OPENSSL _ free ▁( ▁* ▁phost ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int 64_ t ▁get _ pts ▁( ▁const ▁char ▁* ▁* ▁buf ▁, ▁int ▁* ▁duration ▁, ▁int 32_ t ▁* ▁x 1 ▁, ▁int 32_ t ▁* ▁y 1 ▁, ▁int 32_ t ▁* ▁x 2 ▁, ▁int 32_ t ▁* ▁y 2 ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁hh 1 ▁, ▁mm 1 ▁, ▁ss 1 ▁, ▁ms 1 ▁; ▁int ▁hh 2 ▁, ▁mm 2 ▁, ▁ss 2 ▁, ▁ms 2 ▁; ▁if ▁( ▁sscanf ▁( ▁* ▁buf ▁, ▁"% d :% 2 d :% 2 d % * 1 [ , .] %3 d -- >% d :% 2 d :% 2 d % * 1 [ , .] %3 d " ▁"%* [] X 1 :% u X 2 :% uY 1 :% uY 2 :% u " ▁, ▁& ▁hh 1 ▁, ▁& ▁mm 1 ▁, ▁& ▁ss 1 ▁, ▁& ▁ms 1 ▁, ▁& ▁hh 2 ▁, ▁& ▁mm 2 ▁, ▁& ▁ss 2 ▁, ▁& ▁ms 2 ▁, ▁x 1 ▁, ▁x 2 ▁, ▁y 1 ▁, ▁y 2 ▁) ▁>= ▁8 ▁) ▁{ ▁int 64_ t ▁start ▁= ▁( ▁hh 1 ▁* ▁3600 LL ▁+ ▁mm 1 ▁* ▁60 LL ▁+ ▁ss 1 ▁) ▁* ▁1000 LL ▁+ ▁ms 1 ▁; ▁int 64_ t ▁end ▁= ▁( ▁hh 2 ▁* ▁3600 LL ▁+ ▁mm 2 ▁* ▁60 LL ▁+ ▁ss 2 ▁) ▁* ▁1000 LL ▁+ ▁ms 2 ▁; ▁* ▁duration ▁= ▁end ▁- ▁start ▁; ▁* ▁buf ▁+= ▁strcspn ▁( ▁* ▁buf ▁, ▁"\ n " ▁) ▁+ ▁1 ▁; ▁return ▁start ▁; ▁} ▁* ▁buf ▁+= ▁strcspn ▁( ▁* ▁buf ▁, ▁"\ n " ▁) ▁+ ▁1 ▁; ▁} ▁return ▁AV _ NOP TS _ VALUE ▁; ▁}	1
▁static ▁ngx _ int _ t ▁ngx _ http _ limit _ req _ lookup ▁( ▁ngx _ http _ limit _ req _ conf _ t ▁* ▁l rc f ▁, ▁ngx _ uint _ t ▁hash ▁, ▁u _ char ▁* ▁data ▁, ▁size _ t ▁len ▁, ▁ngx _ http _ limit _ req _ node _ t ▁* ▁* ▁l rp ▁) ▁{ ▁ngx _ int _ t ▁rc ▁, ▁exce ss ▁; ▁ngx _ time _ t ▁* ▁tp ▁; ▁ngx _ msec _ t ▁now ▁; ▁ngx _ msec _ int _ t ▁ms ▁; ▁ngx _ rbtree _ node _ t ▁* ▁node ▁, ▁* ▁sentinel ▁; ▁ngx _ http _ limit _ req _ ctx _ t ▁* ▁ctx ▁; ▁ngx _ http _ limit _ req _ node _ t ▁* ▁lr ▁; ▁ctx ▁= ▁l rc f ▁-> ▁shm _ zone ▁-> ▁data ▁; ▁node ▁= ▁ctx ▁-> ▁sh ▁-> ▁r btree ▁. ▁root ▁; ▁sentinel ▁= ▁ctx ▁-> ▁sh ▁-> ▁r btree ▁. ▁sentinel ▁; ▁while ▁( ▁node ▁!= ▁sentinel ▁) ▁{ ▁if ▁( ▁hash ▁< ▁node ▁-> ▁key ▁) ▁{ ▁node ▁= ▁node ▁-> ▁left ▁; ▁continue ▁; ▁} ▁if ▁( ▁hash ▁> ▁node ▁-> ▁key ▁) ▁{ ▁node ▁= ▁node ▁-> ▁right ▁; ▁continue ▁; ▁} ▁do ▁{ ▁lr ▁= ▁( ▁ngx _ http _ limit _ req _ node _ t ▁* ▁) ▁& ▁node ▁-> ▁color ▁; ▁rc ▁= ▁ngx _ mem n 2 cmp ▁( ▁data ▁, ▁lr ▁-> ▁data ▁, ▁len ▁, ▁( ▁size _ t ▁) ▁lr ▁-> ▁len ▁) ▁; ▁if ▁( ▁rc ▁== ▁0 ▁) ▁{ ▁tp ▁= ▁ngx _ timeofday ▁( ▁) ▁; ▁now ▁= ▁( ▁ngx _ msec _ t ▁) ▁( ▁tp ▁-> ▁sec ▁* ▁1000 ▁+ ▁tp ▁-> ▁msec ▁) ▁; ▁ms ▁= ▁( ▁ngx _ msec _ int _ t ▁) ▁( ▁now ▁- ▁lr ▁-> ▁last ▁) ▁; ▁exce ss ▁= ▁lr ▁-> ▁exce ss ▁- ▁ctx ▁-> ▁rate ▁* ▁ngx _ abs ▁( ▁ms ▁) ▁/ ▁1000 ▁+ ▁1000 ▁; ▁if ▁( ▁exce ss ▁< ▁0 ▁) ▁{ ▁exce ss ▁= ▁0 ▁; ▁} ▁if ▁( ▁( ▁ngx _ uint _ t ▁) ▁exce ss ▁> ▁l rc f ▁-> ▁burst ▁) ▁{ ▁* ▁l rp ▁= ▁lr ▁; ▁return ▁NGX _ BUSY ▁; ▁} ▁lr ▁-> ▁exce ss ▁= ▁exce ss ▁; ▁lr ▁-> ▁last ▁= ▁now ▁; ▁* ▁l rp ▁= ▁lr ▁; ▁if ▁( ▁exce ss ▁) ▁{ ▁return ▁NGX _ AGAIN ▁; ▁} ▁return ▁NGX _ OK ▁; ▁} ▁node ▁= ▁( ▁rc ▁< ▁0 ▁) ▁? ▁node ▁-> ▁left ▁: ▁node ▁-> ▁right ▁; ▁} ▁while ▁( ▁node ▁!= ▁sentinel ▁&& ▁hash ▁== ▁node ▁-> ▁key ▁) ▁; ▁break ▁; ▁} ▁* ▁l rp ▁= ▁NULL ▁; ▁return ▁NGX _ DECL INED ▁; ▁}	1
▁STACK _ OF ▁( ▁X 509_ INFO ▁) ▁* ▁PEM _ X 509_ INFO _ read _ bio ▁( ▁BIO ▁* ▁bp ▁, ▁STACK _ OF ▁( ▁X 509_ INFO ▁) ▁* ▁sk ▁, ▁int ▁( ▁* ▁cb ▁) ▁( ▁) ▁) ▁{ ▁X 509_ INFO ▁* ▁xi ▁= ▁NULL ▁; ▁char ▁* ▁name ▁= ▁NULL ▁, ▁* ▁header ▁= ▁NULL ▁, ▁* ▁* ▁pp ▁; ▁unsigned ▁char ▁* ▁data ▁= ▁NULL ▁, ▁* ▁p ▁; ▁long ▁len ▁, ▁error ▁= ▁0 ▁; ▁int ▁ok ▁= ▁0 ▁; ▁STACK _ OF ▁( ▁X 509_ INFO ▁) ▁* ▁ret ▁= ▁NULL ▁; ▁unsigned ▁int ▁i ▁, ▁raw ▁; ▁char ▁* ▁( ▁* ▁d 2 i ▁) ▁( ▁) ▁; ▁if ▁( ▁sk ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁sk _ X 509_ INFO _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁PEM err ▁( ▁PEM _ F _ PEM _ X 509_ INFO _ READ _ BIO ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁else ▁ret ▁= ▁sk ▁; ▁if ▁( ▁( ▁xi ▁= ▁X 509_ INFO _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁raw ▁= ▁0 ▁; ▁i ▁= ▁PEM _ read _ bio ▁( ▁bp ▁, ▁& ▁name ▁, ▁& ▁header ▁, ▁& ▁data ▁, ▁& ▁len ▁) ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁error ▁= ▁ERR _ GET _ REASON ▁( ▁ERR _ peek _ error ▁( ▁) ▁) ▁; ▁if ▁( ▁error ▁== ▁PEM _ R _ NO _ START _ LINE ▁) ▁{ ▁ERR _ clear _ error ▁( ▁) ▁; ▁break ▁; ▁} ▁goto ▁err ▁; ▁} ▁start ▁: ▁if ▁( ▁( ▁strcmp ▁( ▁name ▁, ▁PEM _ STRING _ X 509 ▁) ▁== ▁0 ▁) ▁|| ▁( ▁strcmp ▁( ▁name ▁, ▁PEM _ STRING _ X 509_ OLD ▁) ▁== ▁0 ▁) ▁) ▁{ ▁d 2 i ▁= ▁( ▁char ▁* ▁( ▁* ▁) ▁( ▁) ▁) ▁d 2 i _ X 509 ▁; ▁if ▁( ▁xi ▁-> ▁x 509 ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁sk _ X 509_ INFO _ push ▁( ▁ret ▁, ▁xi ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁xi ▁= ▁X 509_ INFO _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁goto ▁start ▁; ▁} ▁pp ▁= ▁( ▁char ▁* ▁* ▁) ▁& ▁( ▁xi ▁-> ▁x 509 ▁) ▁; ▁} ▁else ▁if ▁( ▁strcmp ▁( ▁name ▁, ▁PEM _ STRING _ X 509_ CRL ▁) ▁== ▁0 ▁) ▁{ ▁d 2 i ▁= ▁( ▁char ▁* ▁( ▁* ▁) ▁( ▁) ▁) ▁d 2 i _ X 509_ CRL ▁; ▁if ▁( ▁xi ▁-> ▁crl ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁sk _ X 509_ INFO _ push ▁( ▁ret ▁, ▁xi ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁xi ▁= ▁X 509_ INFO _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁goto ▁start ▁; ▁} ▁pp ▁= ▁( ▁char ▁* ▁* ▁) ▁& ▁( ▁xi ▁-> ▁crl ▁) ▁; ▁} ▁else ▁# ifndef ▁NO _ RSA ▁if ▁( ▁strcmp ▁( ▁name ▁, ▁PEM _ STRING _ RSA ▁) ▁== ▁0 ▁) ▁{ ▁d 2 i ▁= ▁( ▁char ▁* ▁( ▁* ▁) ▁( ▁) ▁) ▁d 2 i _ RSA PrivateKey ▁; ▁if ▁( ▁xi ▁-> ▁x _ pkey ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁sk _ X 509_ INFO _ push ▁( ▁ret ▁, ▁xi ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁xi ▁= ▁X 509_ INFO _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁goto ▁start ▁; ▁} ▁xi ▁-> ▁enc _ data ▁= ▁NULL ▁; ▁xi ▁-> ▁enc _ len ▁= ▁0 ▁; ▁xi ▁-> ▁x _ pkey ▁= ▁X 509_ PKEY _ new ▁( ▁) ▁; ▁if ▁( ▁( ▁xi ▁-> ▁x _ pkey ▁-> ▁dec _ pkey ▁= ▁EVP _ PKEY _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁xi ▁-> ▁x _ pkey ▁-> ▁dec _ pkey ▁-> ▁type ▁= ▁EVP _ PKEY _ RSA ▁; ▁pp ▁= ▁( ▁char ▁* ▁* ▁) ▁& ▁( ▁xi ▁-> ▁x _ pkey ▁-> ▁dec _ pkey ▁-> ▁pkey ▁. ▁rsa ▁) ▁; ▁if ▁( ▁( ▁int ▁) ▁strlen ▁( ▁header ▁) ▁> ▁10 ▁) ▁raw ▁= ▁1 ▁; ▁} ▁else ▁# endif ▁# ifndef ▁NO _ DSA ▁if ▁( ▁strcmp ▁( ▁name ▁, ▁PEM _ STRING _ DSA ▁) ▁== ▁0 ▁) ▁{ ▁d 2 i ▁= ▁( ▁char ▁* ▁( ▁* ▁) ▁( ▁) ▁) ▁d 2 i _ DSA PrivateKey ▁; ▁if ▁( ▁xi ▁-> ▁x _ pkey ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁sk _ X 509_ INFO _ push ▁( ▁ret ▁, ▁xi ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁xi ▁= ▁X 509_ INFO _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁goto ▁start ▁; ▁} ▁xi ▁-> ▁enc _ data ▁= ▁NULL ▁; ▁xi ▁-> ▁enc _ len ▁= ▁0 ▁; ▁xi ▁-> ▁x _ pkey ▁= ▁X 509_ PKEY _ new ▁( ▁) ▁; ▁if ▁( ▁( ▁xi ▁-> ▁x _ pkey ▁-> ▁dec _ pkey ▁= ▁EVP _ PKEY _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁xi ▁-> ▁x _ pkey ▁-> ▁dec _ pkey ▁-> ▁type ▁= ▁EVP _ PKEY _ DSA ▁; ▁pp ▁= ▁( ▁char ▁* ▁* ▁) ▁& ▁( ▁xi ▁-> ▁x _ pkey ▁-> ▁dec _ pkey ▁-> ▁pkey ▁. ▁dsa ▁) ▁; ▁if ▁( ▁( ▁int ▁) ▁strlen ▁( ▁header ▁) ▁> ▁10 ▁) ▁raw ▁= ▁1 ▁; ▁} ▁else ▁# endif ▁{ ▁d 2 i ▁= ▁NULL ▁; ▁pp ▁= ▁NULL ▁; ▁} ▁if ▁( ▁d 2 i ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁raw ▁) ▁{ ▁EVP _ CIPHER _ INFO ▁cipher ▁; ▁if ▁( ▁! ▁PEM _ get _ EVP _ CIPHER _ INFO ▁( ▁header ▁, ▁& ▁cipher ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁PEM _ do _ header ▁( ▁& ▁cipher ▁, ▁data ▁, ▁& ▁len ▁, ▁cb ▁) ▁) ▁goto ▁err ▁; ▁p ▁= ▁data ▁; ▁if ▁( ▁d 2 i ▁( ▁pp ▁, ▁& ▁p ▁, ▁len ▁) ▁== ▁NULL ▁) ▁{ ▁PEM err ▁( ▁PEM _ F _ PEM _ X 509_ INFO _ READ _ BIO ▁, ▁ERR _ R _ ASN 1_ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁! ▁PEM _ get _ EVP _ CIPHER _ INFO ▁( ▁header ▁, ▁& ▁xi ▁-> ▁enc _ cipher ▁) ▁) ▁goto ▁err ▁; ▁xi ▁-> ▁enc _ data ▁= ▁( ▁char ▁* ▁) ▁data ▁; ▁xi ▁-> ▁enc _ len ▁= ▁( ▁int ▁) ▁len ▁; ▁data ▁= ▁NULL ▁; ▁} ▁} ▁else ▁{ ▁} ▁if ▁( ▁name ▁!= ▁NULL ▁) ▁Free ▁( ▁name ▁) ▁; ▁if ▁( ▁header ▁!= ▁NULL ▁) ▁Free ▁( ▁header ▁) ▁; ▁if ▁( ▁data ▁!= ▁NULL ▁) ▁Free ▁( ▁data ▁) ▁; ▁name ▁= ▁NULL ▁; ▁header ▁= ▁NULL ▁; ▁data ▁= ▁NULL ▁; ▁} ▁if ▁( ▁( ▁xi ▁-> ▁x 509 ▁!= ▁NULL ▁) ▁|| ▁( ▁xi ▁-> ▁crl ▁!= ▁NULL ▁) ▁|| ▁( ▁xi ▁-> ▁x _ pkey ▁!= ▁NULL ▁) ▁|| ▁( ▁xi ▁-> ▁enc _ data ▁!= ▁NULL ▁) ▁) ▁{ ▁if ▁( ▁! ▁sk _ X 509_ INFO _ push ▁( ▁ret ▁, ▁xi ▁) ▁) ▁goto ▁err ▁; ▁xi ▁= ▁NULL ▁; ▁} ▁ok ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁xi ▁!= ▁NULL ▁) ▁X 509_ INFO _ free ▁( ▁xi ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁( ▁( ▁int ▁) ▁i ▁) ▁< ▁sk _ X 509_ INFO _ num ▁( ▁ret ▁) ▁; ▁i ▁++ ▁) ▁{ ▁xi ▁= ▁sk _ X 509_ INFO _ value ▁( ▁ret ▁, ▁i ▁) ▁; ▁X 509_ INFO _ free ▁( ▁xi ▁) ▁; ▁} ▁if ▁( ▁ret ▁!= ▁sk ▁) ▁sk _ X 509_ INFO _ free ▁( ▁ret ▁) ▁; ▁ret ▁= ▁NULL ▁; ▁} ▁if ▁( ▁name ▁!= ▁NULL ▁) ▁Free ▁( ▁name ▁) ▁; ▁if ▁( ▁header ▁!= ▁NULL ▁) ▁Free ▁( ▁header ▁) ▁; ▁if ▁( ▁data ▁!= ▁NULL ▁) ▁Free ▁( ▁data ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁int ▁get _ video _ buffer ▁( ▁AVFrame ▁* ▁frame ▁, ▁int ▁align ▁) ▁{ ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁frame ▁-> ▁format ▁) ▁; ▁int ▁ret ▁, ▁i ▁; ▁if ▁( ▁! ▁desc ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ check _ size ▁( ▁frame ▁-> ▁width ▁, ▁frame ▁-> ▁height ▁, ▁0 ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁! ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁<= ▁align ▁; ▁i ▁+= ▁i ▁) ▁{ ▁ret ▁= ▁av _ image _ fill _ lines izes ▁( ▁frame ▁-> ▁linesize ▁, ▁frame ▁-> ▁format ▁, ▁FF ALIGN ▁( ▁frame ▁-> ▁width ▁, ▁i ▁) ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁! ▁( ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁& ▁( ▁align ▁- ▁1 ▁) ▁) ▁) ▁break ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁&& ▁frame ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁frame ▁-> ▁linesize ▁[ ▁i ▁] ▁= ▁FF ALIGN ▁( ▁frame ▁-> ▁linesize ▁[ ▁i ▁] ▁, ▁align ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁&& ▁frame ▁-> ▁linesize ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁{ ▁int ▁h ▁= ▁FF ALIGN ▁( ▁frame ▁-> ▁height ▁, ▁32 ▁) ▁; ▁if ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁) ▁h ▁= ▁FF _ CE IL _ RSHIFT ▁( ▁h ▁, ▁desc ▁-> ▁log 2_ chroma _ h ▁) ▁; ▁frame ▁-> ▁buf ▁[ ▁i ▁] ▁= ▁av _ buffer _ alloc ▁( ▁frame ▁-> ▁linesize ▁[ ▁i ▁] ▁* ▁h ▁+ ▁16 ▁+ ▁16 ▁- ▁1 ▁) ▁; ▁if ▁( ▁! ▁frame ▁-> ▁buf ▁[ ▁i ▁] ▁) ▁goto ▁fail ▁; ▁frame ▁-> ▁data ▁[ ▁i ▁] ▁= ▁frame ▁-> ▁buf ▁[ ▁i ▁] ▁-> ▁data ▁; ▁} ▁if ▁( ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PAL ▁|| ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PSE UD OP AL ▁) ▁{ ▁av _ buffer _ unref ▁( ▁& ▁frame ▁-> ▁buf ▁[ ▁1 ▁] ▁) ▁; ▁frame ▁-> ▁buf ▁[ ▁1 ▁] ▁= ▁av _ buffer _ alloc ▁( ▁1024 ▁) ▁; ▁if ▁( ▁! ▁frame ▁-> ▁buf ▁[ ▁1 ▁] ▁) ▁goto ▁fail ▁; ▁frame ▁-> ▁data ▁[ ▁1 ▁] ▁= ▁frame ▁-> ▁buf ▁[ ▁1 ▁] ▁-> ▁data ▁; ▁} ▁frame ▁-> ▁extended _ data ▁= ▁frame ▁-> ▁data ▁; ▁return ▁0 ▁; ▁fail ▁: ▁av _ frame _ unref ▁( ▁frame ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁}	1
▁static ▁int ▁the ora _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁idx ▁) ▁{ ▁struct ▁ogg ▁* ▁ogg ▁= ▁s ▁-> ▁priv _ data ▁; ▁struct ▁ogg _ stream ▁* ▁os ▁= ▁ogg ▁-> ▁streams ▁+ ▁idx ▁; ▁int ▁duration ▁; ▁if ▁( ▁( ▁! ▁os ▁-> ▁last pts ▁|| ▁os ▁-> ▁last pts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁&& ▁! ▁( ▁os ▁-> ▁flags ▁& ▁O GG _ FLAG _ E OS ▁) ▁) ▁{ ▁int ▁seg ▁; ▁duration ▁= ▁1 ▁; ▁for ▁( ▁seg ▁= ▁os ▁-> ▁seg p ▁; ▁seg ▁< ▁os ▁-> ▁n segs ▁; ▁seg ▁++ ▁) ▁{ ▁if ▁( ▁os ▁-> ▁segments ▁[ ▁seg ▁] ▁< ▁255 ▁) ▁duration ▁++ ▁; ▁} ▁os ▁-> ▁last pts ▁= ▁os ▁-> ▁last dts ▁= ▁the ora _ gpt opts ▁( ▁s ▁, ▁idx ▁, ▁os ▁-> ▁gran ule ▁, ▁NULL ▁) ▁- ▁duration ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁idx ▁] ▁-> ▁start _ time ▁== ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁s ▁-> ▁streams ▁[ ▁idx ▁] ▁-> ▁start _ time ▁= ▁os ▁-> ▁last pts ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁idx ▁] ▁-> ▁duration ▁> ▁0 ▁) ▁s ▁-> ▁streams ▁[ ▁idx ▁] ▁-> ▁duration ▁-= ▁s ▁-> ▁streams ▁[ ▁idx ▁] ▁-> ▁start _ time ▁; ▁} ▁} ▁if ▁( ▁os ▁-> ▁psize ▁> ▁0 ▁) ▁{ ▁os ▁-> ▁pd uration ▁= ▁1 ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁yuv 2 yuv X 16_ c _ template ▁( ▁const ▁int 16_ t ▁* ▁lum Filter ▁, ▁const ▁int 32_ t ▁* ▁* ▁lum Src ▁, ▁int ▁lum Filter Size ▁, ▁const ▁int 16_ t ▁* ▁chr Filter ▁, ▁const ▁int 32_ t ▁* ▁* ▁chr US rc ▁, ▁const ▁int 32_ t ▁* ▁* ▁chr V Src ▁, ▁int ▁chr Filter Size ▁, ▁const ▁int 32_ t ▁* ▁* ▁alp Src ▁, ▁uint 16_ t ▁* ▁dest ▁[ ▁4 ▁] ▁, ▁int ▁dst W ▁, ▁int ▁chr Dst W ▁, ▁int ▁big _ endian ▁, ▁int ▁output _ bits ▁) ▁{ ▁int ▁i ▁; ▁int ▁dword ▁= ▁output _ bits ▁== ▁16 ▁; ▁uint 16_ t ▁* ▁y Dest ▁= ▁dest ▁[ ▁0 ▁] ▁, ▁* ▁u Dest ▁= ▁dest ▁[ ▁1 ▁] ▁, ▁* ▁v Dest ▁= ▁dest ▁[ ▁2 ▁] ▁, ▁* ▁a Dest ▁= ▁CONFIG _ SW SCALE _ ALPHA ▁? ▁dest ▁[ ▁3 ▁] ▁: ▁NULL ▁; ▁int ▁shift ▁= ▁11 ▁+ ▁4 ▁* ▁dword ▁+ ▁16 ▁- ▁output _ bits ▁- ▁1 ▁; ▁# define ▁output _ pixel ▁( ▁pos ▁, ▁val ▁) ▁\ if ( big _ endian ){ \ if ( output _ bits == 16) {\ AV _ WB 16 ( pos , av _ clip _ uint 16 ( val >> shift )); \ } else {\ AV _ WB 16 ( pos , av _ clip _ uint p 2( val >> shift , output _ bits )); \ }\ } else {\ if ( output _ bits == 16) {\ AV _ WL 16 ( pos , av _ clip _ uint 16 ( val >> shift )); \ } else {\ AV _ WL 16 ( pos , av _ clip _ uint p 2( val >> shift , output _ bits )); \ }\ } ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁val ▁= ▁1 ▁<< ▁( ▁26 ▁- ▁output _ bits ▁+ ▁4 ▁* ▁dword ▁- ▁1 ▁) ▁; ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁lum Filter Size ▁; ▁j ▁++ ▁) ▁val ▁+= ▁( ▁( ▁dword ▁? ▁lum Src ▁[ ▁j ▁] ▁[ ▁i ▁] ▁: ▁( ▁( ▁int 16_ t ▁* ▁* ▁) ▁lum Src ▁) ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁* ▁lum Filter ▁[ ▁j ▁] ▁) ▁>> ▁1 ▁; ▁output _ pixel ▁( ▁& ▁y Dest ▁[ ▁i ▁] ▁, ▁val ▁) ▁; ▁} ▁if ▁( ▁u Dest ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁chr Dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁u ▁= ▁1 ▁<< ▁( ▁26 ▁- ▁output _ bits ▁+ ▁4 ▁* ▁dword ▁- ▁1 ▁) ▁; ▁int ▁v ▁= ▁1 ▁<< ▁( ▁26 ▁- ▁output _ bits ▁+ ▁4 ▁* ▁dword ▁- ▁1 ▁) ▁; ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁chr Filter Size ▁; ▁j ▁++ ▁) ▁{ ▁u ▁+= ▁( ▁( ▁dword ▁? ▁chr US rc ▁[ ▁j ▁] ▁[ ▁i ▁] ▁: ▁( ▁( ▁int 16_ t ▁* ▁* ▁) ▁chr US rc ▁) ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁* ▁chr Filter ▁[ ▁j ▁] ▁) ▁>> ▁1 ▁; ▁v ▁+= ▁( ▁( ▁dword ▁? ▁chr V Src ▁[ ▁j ▁] ▁[ ▁i ▁] ▁: ▁( ▁( ▁int 16_ t ▁* ▁* ▁) ▁chr V Src ▁) ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁* ▁chr Filter ▁[ ▁j ▁] ▁) ▁>> ▁1 ▁; ▁} ▁output _ pixel ▁( ▁& ▁u Dest ▁[ ▁i ▁] ▁, ▁u ▁) ▁; ▁output _ pixel ▁( ▁& ▁v Dest ▁[ ▁i ▁] ▁, ▁v ▁) ▁; ▁} ▁} ▁if ▁( ▁CONFIG _ SW SCALE _ ALPHA ▁&& ▁a Dest ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁val ▁= ▁1 ▁<< ▁( ▁26 ▁- ▁output _ bits ▁+ ▁4 ▁* ▁dword ▁- ▁1 ▁) ▁; ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁lum Filter Size ▁; ▁j ▁++ ▁) ▁val ▁+= ▁( ▁( ▁dword ▁? ▁alp Src ▁[ ▁j ▁] ▁[ ▁i ▁] ▁: ▁( ▁( ▁int 16_ t ▁* ▁* ▁) ▁alp Src ▁) ▁[ ▁j ▁] ▁[ ▁i ▁] ▁) ▁* ▁lum Filter ▁[ ▁j ▁] ▁) ▁>> ▁1 ▁; ▁output _ pixel ▁( ▁& ▁a Dest ▁[ ▁i ▁] ▁, ▁val ▁) ▁; ▁} ▁} ▁# undef ▁output _ pixel ▁}	0
▁static ▁ngx _ inline ▁void ▁ngx _ event _ add _ timer ▁( ▁ngx _ event _ t ▁* ▁ev ▁, ▁ngx _ msec _ t ▁timer ▁) ▁{ ▁ngx _ msec _ t ▁key ▁; ▁ngx _ msec _ int _ t ▁diff ▁; ▁key ▁= ▁ngx _ current _ msec ▁+ ▁timer ▁; ▁if ▁( ▁ev ▁-> ▁timer _ set ▁) ▁{ ▁diff ▁= ▁( ▁ngx _ msec _ int _ t ▁) ▁( ▁key ▁- ▁ev ▁-> ▁timer ▁. ▁key ▁) ▁; ▁if ▁( ▁ngx _ abs ▁( ▁diff ▁) ▁< ▁NGX _ TIMER _ LAZY _ DELAY ▁) ▁{ ▁ngx _ log _ debug 3 ▁( ▁NGX _ LOG _ DEBUG _ EVENT ▁, ▁ev ▁-> ▁log ▁, ▁0 ▁, ▁" event timer :% d , old :% M , new :% M " ▁, ▁ngx _ event _ ident ▁( ▁ev ▁-> ▁data ▁) ▁, ▁ev ▁-> ▁timer ▁. ▁key ▁, ▁key ▁) ▁; ▁return ▁; ▁} ▁ngx _ del _ timer ▁( ▁ev ▁) ▁; ▁} ▁ev ▁-> ▁timer ▁. ▁key ▁= ▁key ▁; ▁ngx _ log _ debug 3 ▁( ▁NGX _ LOG _ DEBUG _ EVENT ▁, ▁ev ▁-> ▁log ▁, ▁0 ▁, ▁" event timer add :% d :% M :% M " ▁, ▁ngx _ event _ ident ▁( ▁ev ▁-> ▁data ▁) ▁, ▁timer ▁, ▁ev ▁-> ▁timer ▁. ▁key ▁) ▁; ▁ngx _ rbtree _ insert ▁( ▁& ▁ngx _ event _ timer _ rbtree ▁, ▁& ▁ev ▁-> ▁timer ▁) ▁; ▁ev ▁-> ▁timer _ set ▁= ▁1 ▁; ▁}	1
▁int ▁BUF _ MEM _ grow ▁( ▁BUF _ MEM ▁* ▁str ▁, ▁size _ t ▁len ▁) ▁{ ▁char ▁* ▁ret ▁; ▁size _ t ▁n ▁; ▁if ▁( ▁str ▁-> ▁length ▁>= ▁len ▁) ▁{ ▁str ▁-> ▁length ▁= ▁len ▁; ▁return ▁( ▁len ▁) ▁; ▁} ▁if ▁( ▁str ▁-> ▁max ▁>= ▁len ▁) ▁{ ▁memset ▁( ▁& ▁str ▁-> ▁data ▁[ ▁str ▁-> ▁length ▁] ▁, ▁0 ▁, ▁len ▁- ▁str ▁-> ▁length ▁) ▁; ▁str ▁-> ▁length ▁= ▁len ▁; ▁return ▁( ▁len ▁) ▁; ▁} ▁if ▁( ▁len ▁> ▁LIMIT _ BEFORE _ EXP AN SION ▁) ▁{ ▁BUF err ▁( ▁BUF _ F _ BUF _ MEM _ G ROW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁n ▁= ▁( ▁len ▁+ ▁3 ▁) ▁/ ▁3 ▁* ▁4 ▁; ▁if ▁( ▁str ▁-> ▁data ▁== ▁NULL ▁) ▁ret ▁= ▁OPENSSL _ malloc ▁( ▁n ▁) ▁; ▁else ▁ret ▁= ▁OPENSSL _ realloc ▁( ▁str ▁-> ▁data ▁, ▁n ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁BUF err ▁( ▁BUF _ F _ BUF _ MEM _ G ROW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁len ▁= ▁0 ▁; ▁} ▁else ▁{ ▁str ▁-> ▁data ▁= ▁ret ▁; ▁str ▁-> ▁max ▁= ▁n ▁; ▁memset ▁( ▁& ▁str ▁-> ▁data ▁[ ▁str ▁-> ▁length ▁] ▁, ▁0 ▁, ▁len ▁- ▁str ▁-> ▁length ▁) ▁; ▁str ▁-> ▁length ▁= ▁len ▁; ▁} ▁return ▁( ▁len ▁) ▁; ▁}	1
▁void ▁* ▁av _ realloc ▁( ▁void ▁* ▁ptr ▁, ▁size _ t ▁size ▁) ▁{ ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁int ▁diff ▁; ▁# endif ▁if ▁( ▁size ▁> ▁( ▁INT _ MAX ▁- ▁16 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁if ▁( ▁! ▁ptr ▁) ▁return ▁av _ malloc ▁( ▁size ▁) ▁; ▁diff ▁= ▁( ▁( ▁char ▁* ▁) ▁ptr ▁) ▁[ ▁-1 ▁] ▁; ▁return ▁( ▁char ▁* ▁) ▁realloc ▁( ▁( ▁char ▁* ▁) ▁ptr ▁- ▁diff ▁, ▁size ▁+ ▁diff ▁) ▁+ ▁diff ▁; ▁# elif ▁HAVE _ ALIGNED _ MALLOC ▁return ▁_ aligned _ realloc ▁( ▁ptr ▁, ▁size ▁, ▁32 ▁) ▁; ▁# else ▁return ▁realloc ▁( ▁ptr ▁, ▁size ▁) ▁; ▁# endif ▁}	1
▁static ▁int ▁decor relate ▁( ▁T AK Dec Context ▁* ▁s ▁, ▁int ▁c 1 ▁, ▁int ▁c 2 ▁, ▁int ▁length ▁) ▁{ ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁gb ▁; ▁int 32_ t ▁* ▁p 1 ▁= ▁s ▁-> ▁decoded ▁[ ▁c 1 ▁] ▁+ ▁1 ▁; ▁int 32_ t ▁* ▁p 2 ▁= ▁s ▁-> ▁decoded ▁[ ▁c 2 ▁] ▁+ ▁1 ▁; ▁int ▁i ▁; ▁int ▁d shift ▁, ▁df actor ▁; ▁switch ▁( ▁s ▁-> ▁d mode ▁) ▁{ ▁case ▁1 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁a ▁= ▁p 1 ▁[ ▁i ▁] ▁; ▁int 32_ t ▁b ▁= ▁p 2 ▁[ ▁i ▁] ▁; ▁p 2 ▁[ ▁i ▁] ▁= ▁a ▁+ ▁b ▁; ▁} ▁break ▁; ▁case ▁2 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁a ▁= ▁p 1 ▁[ ▁i ▁] ▁; ▁int 32_ t ▁b ▁= ▁p 2 ▁[ ▁i ▁] ▁; ▁p 1 ▁[ ▁i ▁] ▁= ▁b ▁- ▁a ▁; ▁} ▁break ▁; ▁case ▁3 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁a ▁= ▁p 1 ▁[ ▁i ▁] ▁; ▁int 32_ t ▁b ▁= ▁p 2 ▁[ ▁i ▁] ▁; ▁a ▁-= ▁b ▁>> ▁1 ▁; ▁p 1 ▁[ ▁i ▁] ▁= ▁a ▁; ▁p 2 ▁[ ▁i ▁] ▁= ▁a ▁+ ▁b ▁; ▁} ▁break ▁; ▁case ▁4 ▁: ▁F FS W AP ▁( ▁int 32_ t ▁* ▁, ▁p 1 ▁, ▁p 2 ▁) ▁; ▁case ▁5 ▁: ▁d shift ▁= ▁get _ bits _ esc 4 ▁( ▁gb ▁) ▁; ▁df actor ▁= ▁get _ s bits ▁( ▁gb ▁, ▁10 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁a ▁= ▁p 1 ▁[ ▁i ▁] ▁; ▁int 32_ t ▁b ▁= ▁p 2 ▁[ ▁i ▁] ▁; ▁b ▁= ▁df actor ▁* ▁( ▁b ▁>> ▁d shift ▁) ▁+ ▁128 ▁>> ▁8 ▁<< ▁d shift ▁; ▁p 1 ▁[ ▁i ▁] ▁= ▁b ▁- ▁a ▁; ▁} ▁break ▁; ▁case ▁6 ▁: ▁F FS W AP ▁( ▁int 32_ t ▁* ▁, ▁p 1 ▁, ▁p 2 ▁) ▁; ▁case ▁7 ▁: ▁{ ▁int ▁length 2 ▁, ▁order _ half ▁, ▁filter _ order ▁, ▁d val 1 ▁, ▁d val 2 ▁; ▁int ▁tmp ▁, ▁x ▁, ▁code _ size ▁; ▁if ▁( ▁length ▁< ▁256 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁d shift ▁= ▁get _ bits _ esc 4 ▁( ▁gb ▁) ▁; ▁filter _ order ▁= ▁8 ▁<< ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁d val 1 ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁d val 2 ▁= ▁get _ bits 1 ▁( ▁gb ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁filter _ order ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁i ▁& ▁3 ▁) ▁) ▁code _ size ▁= ▁14 ▁- ▁get _ bits ▁( ▁gb ▁, ▁3 ▁) ▁; ▁s ▁-> ▁filter ▁[ ▁i ▁] ▁= ▁get _ s bits ▁( ▁gb ▁, ▁code _ size ▁) ▁; ▁} ▁order _ half ▁= ▁filter _ order ▁/ ▁2 ▁; ▁length 2 ▁= ▁length ▁- ▁( ▁filter _ order ▁- ▁1 ▁) ▁; ▁if ▁( ▁d val 1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁order _ half ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁a ▁= ▁p 1 ▁[ ▁i ▁] ▁; ▁int 32_ t ▁b ▁= ▁p 2 ▁[ ▁i ▁] ▁; ▁p 1 ▁[ ▁i ▁] ▁= ▁a ▁+ ▁b ▁; ▁} ▁} ▁if ▁( ▁d val 2 ▁) ▁{ ▁for ▁( ▁i ▁= ▁length 2 ▁+ ▁order _ half ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁int 32_ t ▁a ▁= ▁p 1 ▁[ ▁i ▁] ▁; ▁int 32_ t ▁b ▁= ▁p 2 ▁[ ▁i ▁] ▁; ▁p 1 ▁[ ▁i ▁] ▁= ▁a ▁+ ▁b ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁filter _ order ▁; ▁i ▁++ ▁) ▁s ▁-> ▁resid ues ▁[ ▁i ▁] ▁= ▁* ▁p 2 ▁++ ▁>> ▁d shift ▁; ▁p 1 ▁+= ▁order _ half ▁; ▁x ▁= ▁FF _ ARRAY _ ELEMS ▁( ▁s ▁-> ▁resid ues ▁) ▁- ▁filter _ order ▁; ▁for ▁( ▁; ▁length 2 ▁> ▁0 ▁; ▁length 2 ▁-= ▁tmp ▁) ▁{ ▁tmp ▁= ▁FF MIN ▁( ▁length 2 ▁, ▁x ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tmp ▁; ▁i ▁++ ▁) ▁s ▁-> ▁resid ues ▁[ ▁filter _ order ▁+ ▁i ▁] ▁= ▁* ▁p 2 ▁++ ▁>> ▁d shift ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁tmp ▁; ▁i ▁++ ▁) ▁{ ▁int ▁v ▁= ▁1 ▁<< ▁9 ▁; ▁if ▁( ▁filter _ order ▁== ▁16 ▁) ▁{ ▁v ▁+= ▁s ▁-> ▁a dsp ▁. ▁scalar product _ int 16 ▁( ▁& ▁s ▁-> ▁resid ues ▁[ ▁i ▁] ▁, ▁s ▁-> ▁filter ▁, ▁filter _ order ▁) ▁; ▁} ▁else ▁{ ▁v ▁+= ▁s ▁-> ▁resid ues ▁[ ▁i ▁+ ▁7 ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁7 ▁] ▁+ ▁s ▁-> ▁resid ues ▁[ ▁i ▁+ ▁6 ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁6 ▁] ▁+ ▁s ▁-> ▁resid ues ▁[ ▁i ▁+ ▁5 ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁5 ▁] ▁+ ▁s ▁-> ▁resid ues ▁[ ▁i ▁+ ▁4 ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁4 ▁] ▁+ ▁s ▁-> ▁resid ues ▁[ ▁i ▁+ ▁3 ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁3 ▁] ▁+ ▁s ▁-> ▁resid ues ▁[ ▁i ▁+ ▁2 ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁2 ▁] ▁+ ▁s ▁-> ▁resid ues ▁[ ▁i ▁+ ▁1 ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁1 ▁] ▁+ ▁s ▁-> ▁resid ues ▁[ ▁i ▁] ▁* ▁s ▁-> ▁filter ▁[ ▁0 ▁] ▁; ▁} ▁v ▁= ▁( ▁av _ clip _ int p 2 ▁( ▁v ▁>> ▁10 ▁, ▁13 ▁) ▁<< ▁d shift ▁) ▁- ▁* ▁p 1 ▁; ▁* ▁p 1 ▁++ ▁= ▁v ▁; ▁} ▁memcpy ▁( ▁s ▁-> ▁resid ues ▁, ▁& ▁s ▁-> ▁resid ues ▁[ ▁tmp ▁] ▁, ▁2 ▁* ▁filter _ order ▁) ▁; ▁} ▁e mm s _ c ▁( ▁) ▁; ▁break ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁ECDSA _ SIG ▁* ▁ossl _ ecdsa _ sign _ sig ▁( ▁const ▁unsigned ▁char ▁* ▁dgst ▁, ▁int ▁dgst _ len ▁, ▁const ▁BIGNUM ▁* ▁in _ k inv ▁, ▁const ▁BIGNUM ▁* ▁in _ r ▁, ▁EC _ KEY ▁* ▁e ckey ▁) ▁{ ▁int ▁ok ▁= ▁0 ▁, ▁i ▁; ▁BIGNUM ▁* ▁k inv ▁= ▁NULL ▁, ▁* ▁s ▁, ▁* ▁m ▁= ▁NULL ▁, ▁* ▁tmp ▁= ▁NULL ▁; ▁const ▁BIGNUM ▁* ▁order ▁, ▁* ▁ck inv ▁; ▁BN _ CTX ▁* ▁ctx ▁= ▁NULL ▁; ▁const ▁EC _ GROUP ▁* ▁group ▁; ▁ECDSA _ SIG ▁* ▁ret ▁; ▁const ▁BIGNUM ▁* ▁priv _ key ▁; ▁group ▁= ▁EC _ KEY _ get 0_ group ▁( ▁e ckey ▁) ▁; ▁priv _ key ▁= ▁EC _ KEY _ get 0_ private _ key ▁( ▁e ckey ▁) ▁; ▁if ▁( ▁group ▁== ▁NULL ▁|| ▁priv _ key ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ PASSED _ NULL _ PARAMETER ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁! ▁EC _ KEY _ can _ sign ▁( ▁e ckey ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁EC _ R _ CURVE _ DOES _ NOT _ SUPPORT _ SIGN ING ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ret ▁= ▁ECDSA _ SIG _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ret ▁-> ▁r ▁= ▁BN _ new ▁( ▁) ▁; ▁ret ▁-> ▁s ▁= ▁BN _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁r ▁== ▁NULL ▁|| ▁ret ▁-> ▁s ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁s ▁= ▁ret ▁-> ▁s ▁; ▁if ▁( ▁( ▁ctx ▁= ▁BN _ CTX _ new ▁( ▁) ▁) ▁== ▁NULL ▁|| ▁( ▁tmp ▁= ▁BN _ new ▁( ▁) ▁) ▁== ▁NULL ▁|| ▁( ▁m ▁= ▁BN _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁order ▁= ▁EC _ GROUP _ get 0_ order ▁( ▁group ▁) ▁; ▁if ▁( ▁order ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ EC _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁i ▁= ▁BN _ num _ bits ▁( ▁order ▁) ▁; ▁if ▁( ▁8 ▁* ▁dgst _ len ▁> ▁i ▁) ▁dgst _ len ▁= ▁( ▁i ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁if ▁( ▁! ▁BN _ bin 2 bn ▁( ▁dgst ▁, ▁dgst _ len ▁, ▁m ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ BN _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁8 ▁* ▁dgst _ len ▁> ▁i ▁) ▁&& ▁! ▁BN _ rshift ▁( ▁m ▁, ▁m ▁, ▁8 ▁- ▁( ▁i ▁& ▁0 x 7 ▁) ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ BN _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁do ▁{ ▁if ▁( ▁in _ k inv ▁== ▁NULL ▁|| ▁in _ r ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁ecdsa _ sign _ setup ▁( ▁e ckey ▁, ▁ctx ▁, ▁& ▁k inv ▁, ▁& ▁ret ▁-> ▁r ▁, ▁dgst ▁, ▁dgst _ len ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ ECDSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁ck inv ▁= ▁k inv ▁; ▁} ▁else ▁{ ▁ck inv ▁= ▁in _ k inv ▁; ▁if ▁( ▁BN _ copy ▁( ▁ret ▁-> ▁r ▁, ▁in _ r ▁) ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁if ▁( ▁! ▁BN _ mod _ mul ▁( ▁tmp ▁, ▁priv _ key ▁, ▁ret ▁-> ▁r ▁, ▁order ▁, ▁ctx ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ BN _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ mod _ add _ quick ▁( ▁s ▁, ▁tmp ▁, ▁m ▁, ▁order ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ BN _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ mod _ mul ▁( ▁s ▁, ▁s ▁, ▁ck inv ▁, ▁order ▁, ▁ctx ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁ERR _ R _ BN _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁BN _ is _ zero ▁( ▁s ▁) ▁) ▁{ ▁if ▁( ▁in _ k inv ▁!= ▁NULL ▁&& ▁in _ r ▁!= ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ O SSL _ ECDSA _ SIGN _ SIG ▁, ▁EC _ R _ NEED _ NEW _ SETUP _ VALUES ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁else ▁break ▁; ▁} ▁while ▁( ▁1 ▁) ▁; ▁ok ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁! ▁ok ▁) ▁{ ▁ECDSA _ SIG _ free ▁( ▁ret ▁) ▁; ▁ret ▁= ▁NULL ▁; ▁} ▁BN _ CTX _ free ▁( ▁ctx ▁) ▁; ▁BN _ clear _ free ▁( ▁m ▁) ▁; ▁BN _ clear _ free ▁( ▁tmp ▁) ▁; ▁BN _ clear _ free ▁( ▁k inv ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁cin audio _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁C in Audio Context ▁* ▁cin ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁uint 8_ t ▁* ▁buf _ end ▁= ▁buf ▁+ ▁avpkt ▁-> ▁size ▁; ▁int 16_ t ▁* ▁samples ▁= ▁data ▁; ▁int ▁delta ▁, ▁out _ size ▁; ▁out _ size ▁= ▁( ▁avpkt ▁-> ▁size ▁- ▁cin ▁-> ▁initial _ decode _ frame ▁) ▁* ▁av _ get _ bytes _ per _ sample ▁( ▁avctx ▁-> ▁sample _ fmt ▁) ▁; ▁if ▁( ▁* ▁data _ size ▁< ▁out _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Output buffer ist oo small \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁delta ▁= ▁cin ▁-> ▁delta ▁; ▁if ▁( ▁cin ▁-> ▁initial _ decode _ frame ▁) ▁{ ▁cin ▁-> ▁initial _ decode _ frame ▁= ▁0 ▁; ▁delta ▁= ▁( ▁int 16_ t ▁) ▁AV _ RL 16 ▁( ▁buf ▁) ▁; ▁buf ▁+= ▁2 ▁; ▁* ▁samples ▁++ ▁= ▁delta ▁; ▁} ▁while ▁( ▁buf ▁< ▁buf _ end ▁) ▁{ ▁delta ▁+= ▁cin audio _ delta 16_ table ▁[ ▁* ▁buf ▁++ ▁] ▁; ▁delta ▁= ▁av _ clip _ int 16 ▁( ▁delta ▁) ▁; ▁* ▁samples ▁++ ▁= ▁delta ▁; ▁} ▁cin ▁-> ▁delta ▁= ▁delta ▁; ▁* ▁data _ size ▁= ▁out _ size ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁}	0
▁static ▁float ▁pv q _ band _ cost ▁( ▁C elt PV Q ▁* ▁pv q ▁, ▁C elt Frame ▁* ▁f ▁, ▁Op us Range Coder ▁* ▁rc ▁, ▁int ▁band ▁, ▁float ▁* ▁bits ▁, ▁float ▁lambda ▁) ▁{ ▁int ▁i ▁, ▁b ▁= ▁0 ▁; ▁uint 32_ t ▁cm ▁[ ▁2 ▁] ▁= ▁{ ▁( ▁1 ▁<< ▁f ▁-> ▁blocks ▁) ▁- ▁1 ▁, ▁( ▁1 ▁<< ▁f ▁-> ▁blocks ▁) ▁- ▁1 ▁} ▁; ▁const ▁int ▁band _ size ▁= ▁ff _ ce lt _ freq _ range ▁[ ▁band ▁] ▁<< ▁f ▁-> ▁size ▁; ▁float ▁buf ▁[ ▁176 ▁* ▁2 ▁] ▁, ▁low band _ scratch ▁[ ▁176 ▁] ▁, ▁norm 1 ▁[ ▁176 ▁] ▁, ▁norm 2 ▁[ ▁176 ▁] ▁; ▁float ▁dist ▁, ▁cost ▁, ▁err _ x ▁= ▁0.0 f ▁, ▁err _ y ▁= ▁0.0 f ▁; ▁float ▁* ▁X ▁= ▁buf ▁; ▁float ▁* ▁X _ orig ▁= ▁f ▁-> ▁block ▁[ ▁0 ▁] ▁. ▁coeffs ▁+ ▁( ▁ff _ ce lt _ freq _ band s ▁[ ▁band ▁] ▁<< ▁f ▁-> ▁size ▁) ▁; ▁float ▁* ▁Y ▁= ▁( ▁f ▁-> ▁channels ▁== ▁2 ▁) ▁? ▁& ▁buf ▁[ ▁176 ▁] ▁: ▁NULL ▁; ▁float ▁* ▁Y _ orig ▁= ▁f ▁-> ▁block ▁[ ▁1 ▁] ▁. ▁coeffs ▁+ ▁( ▁ff _ ce lt _ freq _ band s ▁[ ▁band ▁] ▁<< ▁f ▁-> ▁size ▁) ▁; ▁OPUS _ RC _ CHECK POINT _ SP A WN ▁( ▁rc ▁) ▁; ▁memcpy ▁( ▁X ▁, ▁X _ orig ▁, ▁band _ size ▁* ▁sizeof ▁( ▁float ▁) ▁) ▁; ▁if ▁( ▁Y ▁) ▁memcpy ▁( ▁Y ▁, ▁Y _ orig ▁, ▁band _ size ▁* ▁sizeof ▁( ▁float ▁) ▁) ▁; ▁f ▁-> ▁remaining 2 ▁= ▁( ▁( ▁f ▁-> ▁frame bits ▁<< ▁3 ▁) ▁- ▁f ▁-> ▁ant icol lapse _ needed ▁) ▁- ▁opus _ rc _ tell _ frac ▁( ▁rc ▁) ▁- ▁1 ▁; ▁if ▁( ▁band ▁<= ▁f ▁-> ▁coded _ band s ▁- ▁1 ▁) ▁{ ▁int ▁curr _ balance ▁= ▁f ▁-> ▁remaining ▁/ ▁FF MIN ▁( ▁3 ▁, ▁f ▁-> ▁coded _ band s ▁- ▁band ▁) ▁; ▁b ▁= ▁av _ clip _ uint p 2 ▁( ▁FF MIN ▁( ▁f ▁-> ▁remaining 2 ▁+ ▁1 ▁, ▁f ▁-> ▁pul ses ▁[ ▁band ▁] ▁+ ▁curr _ balance ▁) ▁, ▁14 ▁) ▁; ▁} ▁if ▁( ▁f ▁-> ▁dual _ stereo ▁) ▁{ ▁pv q ▁-> ▁quant _ band ▁( ▁pv q ▁, ▁f ▁, ▁rc ▁, ▁band ▁, ▁X ▁, ▁NULL ▁, ▁band _ size ▁, ▁b ▁/ ▁2 ▁, ▁f ▁-> ▁blocks ▁, ▁NULL ▁, ▁f ▁-> ▁size ▁, ▁norm 1 ▁, ▁0 ▁, ▁1.0 f ▁, ▁low band _ scratch ▁, ▁cm ▁[ ▁0 ▁] ▁) ▁; ▁pv q ▁-> ▁quant _ band ▁( ▁pv q ▁, ▁f ▁, ▁rc ▁, ▁band ▁, ▁Y ▁, ▁NULL ▁, ▁band _ size ▁, ▁b ▁/ ▁2 ▁, ▁f ▁-> ▁blocks ▁, ▁NULL ▁, ▁f ▁-> ▁size ▁, ▁norm 2 ▁, ▁0 ▁, ▁1.0 f ▁, ▁low band _ scratch ▁, ▁cm ▁[ ▁1 ▁] ▁) ▁; ▁} ▁else ▁{ ▁pv q ▁-> ▁quant _ band ▁( ▁pv q ▁, ▁f ▁, ▁rc ▁, ▁band ▁, ▁X ▁, ▁Y ▁, ▁band _ size ▁, ▁b ▁, ▁f ▁-> ▁blocks ▁, ▁NULL ▁, ▁f ▁-> ▁size ▁, ▁norm 1 ▁, ▁0 ▁, ▁1.0 f ▁, ▁low band _ scratch ▁, ▁cm ▁[ ▁0 ▁] ▁| ▁cm ▁[ ▁1 ▁] ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁band _ size ▁; ▁i ▁++ ▁) ▁{ ▁err _ x ▁+= ▁( ▁X ▁[ ▁i ▁] ▁- ▁X _ orig ▁[ ▁i ▁] ▁) ▁* ▁( ▁X ▁[ ▁i ▁] ▁- ▁X _ orig ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁Y ▁) ▁err _ y ▁+= ▁( ▁Y ▁[ ▁i ▁] ▁- ▁Y _ orig ▁[ ▁i ▁] ▁) ▁* ▁( ▁Y ▁[ ▁i ▁] ▁- ▁Y _ orig ▁[ ▁i ▁] ▁) ▁; ▁} ▁dist ▁= ▁sqrtf ▁( ▁err _ x ▁) ▁+ ▁sqrtf ▁( ▁err _ y ▁) ▁; ▁cost ▁= ▁OPUS _ RC _ CHECK POINT _ BITS ▁( ▁rc ▁) ▁/ ▁8.0 f ▁; ▁* ▁bits ▁+= ▁cost ▁; ▁OPUS _ RC _ CHECK POINT _ ROLL BACK ▁( ▁rc ▁) ▁; ▁return ▁lambda ▁* ▁dist ▁* ▁cost ▁; ▁}	1
▁static ▁int ▁decode _ residual _ block ▁( ▁AV S Context ▁* ▁h ▁, ▁Get Bit Context ▁* ▁gb ▁, ▁const ▁struct ▁dec _2 d vlc ▁* ▁r ▁, ▁int ▁esc _ go lo mb _ order ▁, ▁int ▁qp ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁stride ▁) ▁{ ▁int ▁i ▁, ▁level _ code ▁, ▁esc _ code ▁, ▁level ▁, ▁run ▁, ▁mask ▁; ▁DCT ELEM ▁level _ buf ▁[ ▁65 ▁] ▁; ▁uint 8_ t ▁run _ buf ▁[ ▁65 ▁] ▁; ▁DCT ELEM ▁* ▁block ▁= ▁h ▁-> ▁block ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁65 ▁; ▁i ▁++ ▁) ▁{ ▁level _ code ▁= ▁get _ ue _ code ▁( ▁gb ▁, ▁r ▁-> ▁go lo mb _ order ▁) ▁; ▁if ▁( ▁level _ code ▁>= ▁E SCAPE _ CODE ▁) ▁{ ▁run ▁= ▁( ▁( ▁level _ code ▁- ▁E SCAPE _ CODE ▁) ▁>> ▁1 ▁) ▁+ ▁1 ▁; ▁esc _ code ▁= ▁get _ ue _ code ▁( ▁gb ▁, ▁esc _ go lo mb _ order ▁) ▁; ▁level ▁= ▁esc _ code ▁+ ▁( ▁run ▁> ▁r ▁-> ▁max _ run ▁? ▁1 ▁: ▁r ▁-> ▁level _ add ▁[ ▁run ▁] ▁) ▁; ▁while ▁( ▁level ▁> ▁r ▁-> ▁inc _ limit ▁) ▁r ▁++ ▁; ▁mask ▁= ▁- ▁( ▁level _ code ▁& ▁1 ▁) ▁; ▁level ▁= ▁( ▁level ▁ ^ ▁mask ▁) ▁- ▁mask ▁; ▁} ▁else ▁if ▁( ▁level _ code ▁>= ▁0 ▁) ▁{ ▁level ▁= ▁r ▁-> ▁r lt ab ▁[ ▁level _ code ▁] ▁[ ▁0 ▁] ▁; ▁if ▁( ▁! ▁level ▁) ▁break ▁; ▁run ▁= ▁r ▁-> ▁r lt ab ▁[ ▁level _ code ▁] ▁[ ▁1 ▁] ▁; ▁r ▁+= ▁r ▁-> ▁r lt ab ▁[ ▁level _ code ▁] ▁[ ▁2 ▁] ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁level _ buf ▁[ ▁i ▁] ▁= ▁level ▁; ▁run _ buf ▁[ ▁i ▁] ▁= ▁run ▁; ▁} ▁if ▁( ▁de quant ▁( ▁h ▁, ▁level _ buf ▁, ▁run _ buf ▁, ▁block ▁, ▁ff _ c av s _ de quant _ mul ▁[ ▁qp ▁] ▁, ▁ff _ c av s _ de quant _ shift ▁[ ▁qp ▁] ▁, ▁i ▁) ▁) ▁return ▁-1 ▁; ▁h ▁-> ▁c dsp ▁. ▁cav s _ idct 8_ add ▁( ▁dst ▁, ▁block ▁, ▁stride ▁) ▁; ▁h ▁-> ▁s ▁. ▁dsp ▁. ▁clear _ block ▁( ▁block ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁sk _ insert ▁( ▁STACK ▁* ▁st ▁, ▁char ▁* ▁data ▁, ▁int ▁loc ▁) ▁{ ▁char ▁* ▁* ▁s ▁; ▁if ▁( ▁st ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁st ▁-> ▁num _ alloc ▁<= ▁st ▁-> ▁num ▁+ ▁1 ▁) ▁{ ▁s ▁= ▁( ▁char ▁* ▁* ▁) ▁OPENSSL _ realloc ▁( ▁( ▁char ▁* ▁) ▁st ▁-> ▁data ▁, ▁( ▁unsigned ▁int ▁) ▁sizeof ▁( ▁char ▁* ▁) ▁* ▁st ▁-> ▁num _ alloc ▁* ▁2 ▁) ▁; ▁if ▁( ▁s ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁st ▁-> ▁data ▁= ▁s ▁; ▁st ▁-> ▁num _ alloc ▁*= ▁2 ▁; ▁} ▁if ▁( ▁( ▁loc ▁>= ▁( ▁int ▁) ▁st ▁-> ▁num ▁) ▁|| ▁( ▁loc ▁< ▁0 ▁) ▁) ▁st ▁-> ▁data ▁[ ▁st ▁-> ▁num ▁] ▁= ▁data ▁; ▁else ▁{ ▁int ▁i ▁; ▁char ▁* ▁* ▁f ▁, ▁* ▁* ▁t ▁; ▁f ▁= ▁( ▁char ▁* ▁* ▁) ▁st ▁-> ▁data ▁; ▁t ▁= ▁( ▁char ▁* ▁* ▁) ▁& ▁( ▁st ▁-> ▁data ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁st ▁-> ▁num ▁; ▁i ▁>= ▁loc ▁; ▁i ▁-- ▁) ▁t ▁[ ▁i ▁] ▁= ▁f ▁[ ▁i ▁] ▁; ▁# ifdef ▁undef ▁memmove ▁( ▁( ▁char ▁* ▁) ▁& ▁( ▁st ▁-> ▁data ▁[ ▁loc ▁+ ▁1 ▁] ▁) ▁, ▁( ▁char ▁* ▁) ▁& ▁( ▁st ▁-> ▁data ▁[ ▁loc ▁] ▁) ▁, ▁sizeof ▁( ▁char ▁* ▁) ▁* ▁( ▁st ▁-> ▁num ▁- ▁loc ▁) ▁) ▁; ▁# endif ▁st ▁-> ▁data ▁[ ▁loc ▁] ▁= ▁data ▁; ▁} ▁st ▁-> ▁num ▁++ ▁; ▁st ▁-> ▁sorted ▁= ▁0 ▁; ▁return ▁( ▁st ▁-> ▁num ▁) ▁; ▁}	1
▁static ▁int ▁asn 1_ cb ▁( ▁const ▁char ▁* ▁elem ▁, ▁int ▁len ▁, ▁void ▁* ▁bit str ▁) ▁{ ▁tag _ exp _ arg ▁* ▁arg ▁= ▁bit str ▁; ▁int ▁i ▁; ▁int ▁ut ype ▁; ▁int ▁vlen ▁; ▁const ▁char ▁* ▁p ▁, ▁* ▁v start ▁= ▁NULL ▁; ▁int ▁tmp _ tag ▁, ▁tmp _ class ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁p ▁= ▁elem ▁; ▁i ▁< ▁len ▁; ▁p ▁++ ▁, ▁i ▁++ ▁) ▁{ ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁) ▁{ ▁v start ▁= ▁p ▁+ ▁1 ▁; ▁vlen ▁= ▁len ▁- ▁( ▁v start ▁- ▁elem ▁) ▁; ▁len ▁= ▁p ▁- ▁elem ▁; ▁break ▁; ▁} ▁} ▁ut ype ▁= ▁asn 1_ str 2 tag ▁( ▁elem ▁, ▁len ▁) ▁; ▁if ▁( ▁ut ype ▁== ▁-1 ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ UNKNOWN _ TAG ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁2 ▁, ▁" tag =" ▁, ▁elem ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁! ▁( ▁ut ype ▁& ▁ASN 1_ GEN _ FLAG ▁) ▁) ▁{ ▁arg ▁-> ▁ut ype ▁= ▁ut ype ▁; ▁arg ▁-> ▁str ▁= ▁v start ▁; ▁if ▁( ▁! ▁v start ▁&& ▁elem ▁[ ▁len ▁] ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ MISSING _ VALUE ▁) ▁; ▁return ▁-1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁switch ▁( ▁ut ype ▁) ▁{ ▁case ▁ASN 1_ GEN _ FLAG _ IMP ▁: ▁if ▁( ▁arg ▁-> ▁imp _ tag ▁!= ▁-1 ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ ILLEGAL _ NEST ED _ TAG GING ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁! ▁parse _ tag ging ▁( ▁v start ▁, ▁vlen ▁, ▁& ▁arg ▁-> ▁imp _ tag ▁, ▁& ▁arg ▁-> ▁imp _ class ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ EXP ▁: ▁if ▁( ▁! ▁parse _ tag ging ▁( ▁v start ▁, ▁vlen ▁, ▁& ▁tmp _ tag ▁, ▁& ▁tmp _ class ▁) ▁) ▁return ▁-1 ▁; ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁tmp _ tag ▁, ▁tmp _ class ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ SEQ WRAP ▁: ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁V _ ASN 1_ SEQUENCE ▁, ▁V _ ASN 1_ UNIVERSAL ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ BIT WRAP ▁: ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁V _ ASN 1_ BIT _ STRING ▁, ▁V _ ASN 1_ UNIVERSAL ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ O CT WRAP ▁: ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁V _ ASN 1_ OCTET _ STRING ▁, ▁V _ ASN 1_ UNIVERSAL ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ FORMAT ▁: ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" ASCII " ▁, ▁5 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ ASCII ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" UTF 8" ▁, ▁4 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ UTF 8 ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" HEX " ▁, ▁3 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ HEX ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" BIT LIST " ▁, ▁3 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ BIT LIST ▁; ▁else ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ UNK OWN _ FORMAT ▁) ▁; ▁return ▁-1 ▁; ▁} ▁break ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁int ▁RSA _ X 9 31_ generate _ key _ ex ▁( ▁RSA ▁* ▁rsa ▁, ▁int ▁bits ▁, ▁const ▁BIGNUM ▁* ▁e ▁, ▁BN _ GENCB ▁* ▁cb ▁) ▁{ ▁int ▁ok ▁= ▁0 ▁; ▁BIGNUM ▁* ▁X p ▁= ▁NULL ▁, ▁* ▁X q ▁= ▁NULL ▁; ▁BN _ CTX ▁* ▁ctx ▁= ▁NULL ▁; ▁ctx ▁= ▁BN _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁goto ▁error ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁X p ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁X q ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁X q ▁== ▁NULL ▁) ▁goto ▁error ▁; ▁if ▁( ▁! ▁BN _ X 9 31_ generate _ X pq ▁( ▁X p ▁, ▁X q ▁, ▁bits ▁, ▁ctx ▁) ▁) ▁goto ▁error ▁; ▁rsa ▁-> ▁p ▁= ▁BN _ new ▁( ▁) ▁; ▁rsa ▁-> ▁q ▁= ▁BN _ new ▁( ▁) ▁; ▁if ▁( ▁rsa ▁-> ▁p ▁== ▁NULL ▁|| ▁rsa ▁-> ▁q ▁== ▁NULL ▁) ▁goto ▁error ▁; ▁if ▁( ▁! ▁BN _ X 9 31_ generate _ prime _ ex ▁( ▁rsa ▁-> ▁p ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁X p ▁, ▁e ▁, ▁ctx ▁, ▁cb ▁) ▁) ▁goto ▁error ▁; ▁if ▁( ▁! ▁BN _ X 9 31_ generate _ prime _ ex ▁( ▁rsa ▁-> ▁q ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁X q ▁, ▁e ▁, ▁ctx ▁, ▁cb ▁) ▁) ▁goto ▁error ▁; ▁if ▁( ▁! ▁RSA _ X 9 31_ der ive _ ex ▁( ▁rsa ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁e ▁, ▁cb ▁) ▁) ▁goto ▁error ▁; ▁ok ▁= ▁1 ▁; ▁error ▁: ▁if ▁( ▁ctx ▁) ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁BN _ CTX _ free ▁( ▁ctx ▁) ▁; ▁if ▁( ▁ok ▁) ▁return ▁1 ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁BN _ div _ re cp ▁( ▁BIGNUM ▁* ▁dv ▁, ▁BIGNUM ▁* ▁rem ▁, ▁BIGNUM ▁* ▁m ▁, ▁BN _ RE CP _ CTX ▁* ▁recp ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁ret ▁= ▁0 ▁, ▁ex ▁; ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁, ▁* ▁d ▁, ▁* ▁r ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁a ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁b ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁dv ▁!= ▁NULL ▁) ▁d ▁= ▁dv ▁; ▁else ▁d ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁rem ▁!= ▁NULL ▁) ▁r ▁= ▁rem ▁; ▁else ▁r ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁a ▁== ▁NULL ▁|| ▁b ▁== ▁NULL ▁|| ▁d ▁== ▁NULL ▁|| ▁r ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ ucmp ▁( ▁m ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁) ▁< ▁0 ▁) ▁{ ▁BN _ zero ▁( ▁d ▁) ▁; ▁BN _ copy ▁( ▁r ▁, ▁m ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁} ▁i ▁= ▁BN _ num _ bits ▁( ▁m ▁) ▁; ▁if ▁( ▁i ▁% ▁2 ▁) ▁i ▁-- ▁; ▁j ▁= ▁recp ▁-> ▁num _ bits ▁* ▁2 ▁; ▁if ▁( ▁j ▁> ▁i ▁) ▁{ ▁i ▁= ▁j ▁; ▁ex ▁= ▁0 ▁; ▁} ▁else ▁{ ▁ex ▁= ▁( ▁i ▁- ▁j ▁) ▁/ ▁2 ▁; ▁} ▁j ▁= ▁i ▁/ ▁2 ▁; ▁if ▁( ▁i ▁!= ▁recp ▁-> ▁shift ▁) ▁recp ▁-> ▁shift ▁= ▁BN _ rec ip rocal ▁( ▁& ▁( ▁recp ▁-> ▁N r ▁) ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁, ▁i ▁, ▁ctx ▁) ▁; ▁if ▁( ▁! ▁BN _ rshift ▁( ▁a ▁, ▁m ▁, ▁j ▁- ▁ex ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ mul ▁( ▁b ▁, ▁a ▁, ▁& ▁( ▁recp ▁-> ▁N r ▁) ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ rshift ▁( ▁d ▁, ▁b ▁, ▁j ▁+ ▁ex ▁) ▁) ▁goto ▁err ▁; ▁d ▁-> ▁neg ▁= ▁0 ▁; ▁if ▁( ▁! ▁BN _ mul ▁( ▁b ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁, ▁d ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ us ub ▁( ▁r ▁, ▁m ▁, ▁b ▁) ▁) ▁goto ▁err ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁j ▁= ▁0 ▁; ▁# if ▁1 ▁while ▁( ▁BN _ ucmp ▁( ▁r ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁) ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁j ▁++ ▁> ▁2 ▁) ▁{ ▁# if ▁1 ▁ret ▁= ▁BN _ div ▁( ▁dv ▁, ▁rem ▁, ▁m ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁, ▁ctx ▁) ▁; ▁# else ▁BN err ▁( ▁BN _ F _ BN _ MOD _ MUL _ REC IP RO CAL ▁, ▁BN _ R _ BAD _ REC IP RO CAL ▁) ▁; ▁# endif ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ us ub ▁( ▁r ▁, ▁r ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ add _ word ▁( ▁d ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁} ▁# endif ▁r ▁-> ▁neg ▁= ▁BN _ is _ zero ▁( ▁r ▁) ▁? ▁0 ▁: ▁m ▁-> ▁neg ▁; ▁d ▁-> ▁neg ▁= ▁m ▁-> ▁neg ▁ ^ ▁recp ▁-> ▁N ▁. ▁neg ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁void ▁* ▁av _ malloc ▁( ▁size _ t ▁size ▁) ▁{ ▁void ▁* ▁ptr ▁= ▁NULL ▁; ▁if ▁( ▁size ▁> ▁( ▁max _ alloc _ size ▁- ▁32 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁HAVE _ POSIX _ MEM ALIGN ▁if ▁( ▁size ▁) ▁if ▁( ▁posix _ memalign ▁( ▁& ▁ptr ▁, ▁ALIGN ▁, ▁size ▁) ▁) ▁ptr ▁= ▁NULL ▁; ▁# elif ▁HAVE _ ALIGNED _ MALLOC ▁ptr ▁= ▁_ aligned _ malloc ▁( ▁size ▁, ▁ALIGN ▁) ▁; ▁# elif ▁HAVE _ MEM ALIGN ▁# ifndef ▁__ D J GPP __ ▁ptr ▁= ▁mem align ▁( ▁ALIGN ▁, ▁size ▁) ▁; ▁# else ▁ptr ▁= ▁mem align ▁( ▁size ▁, ▁ALIGN ▁) ▁; ▁# endif ▁# else ▁ptr ▁= ▁malloc ▁( ▁size ▁) ▁; ▁# endif ▁if ▁( ▁! ▁ptr ▁&& ▁! ▁size ▁) ▁{ ▁size ▁= ▁1 ▁; ▁ptr ▁= ▁av _ malloc ▁( ▁1 ▁) ▁; ▁} ▁# if ▁CONFIG _ MEMORY _ POISON ING ▁if ▁( ▁ptr ▁) ▁memset ▁( ▁ptr ▁, ▁FF _ MEMORY _ POISON ▁, ▁size ▁) ▁; ▁# endif ▁return ▁ptr ▁; ▁}	1
▁static ▁void ▁h Scale 16_ c ▁( ▁S ws Context ▁* ▁c ▁, ▁int 16_ t ▁* ▁_ dst ▁, ▁int ▁dst W ▁, ▁const ▁uint 8_ t ▁* ▁_ src ▁, ▁const ▁int 16_ t ▁* ▁filter ▁, ▁const ▁int 16_ t ▁* ▁filter Pos ▁, ▁int ▁filter Size ▁) ▁{ ▁int ▁i ▁; ▁int 32_ t ▁* ▁dst ▁= ▁( ▁int 32_ t ▁* ▁) ▁_ dst ▁; ▁const ▁uint 16_ t ▁* ▁src ▁= ▁( ▁const ▁uint 16_ t ▁* ▁) ▁_ src ▁; ▁int ▁bits ▁= ▁av _ pix _ fmt _ descriptors ▁[ ▁c ▁-> ▁src Format ▁] ▁. ▁comp ▁[ ▁0 ▁] ▁. ▁depth _ minus 1 ▁; ▁int ▁sh ▁= ▁( ▁bits ▁<= ▁7 ▁) ▁? ▁11 ▁: ▁( ▁bits ▁- ▁4 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁int ▁src Pos ▁= ▁filter Pos ▁[ ▁i ▁] ▁; ▁int ▁val ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁filter Size ▁; ▁j ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁src Pos ▁+ ▁j ▁] ▁* ▁filter ▁[ ▁filter Size ▁* ▁i ▁+ ▁j ▁] ▁; ▁} ▁dst ▁[ ▁i ▁] ▁= ▁FF MIN ▁( ▁val ▁>> ▁sh ▁, ▁( ▁1 ▁<< ▁19 ▁) ▁- ▁1 ▁) ▁; ▁} ▁}	0
▁static ▁int ▁ready _ resid ue ▁( ▁vorbis _ enc _ resid ue ▁* ▁rc ▁, ▁vorbis _ enc _ context ▁* ▁v enc ▁) ▁{ ▁int ▁i ▁; ▁assert ▁( ▁rc ▁-> ▁type ▁== ▁2 ▁) ▁; ▁rc ▁-> ▁max es ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁float ▁[ ▁2 ▁] ▁) ▁* ▁rc ▁-> ▁class ifications ▁) ▁; ▁if ▁( ▁! ▁rc ▁-> ▁max es ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁rc ▁-> ▁class ifications ▁; ▁i ▁++ ▁) ▁{ ▁int ▁j ▁; ▁vorbis _ enc _ code book ▁* ▁cb ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁8 ▁; ▁j ▁++ ▁) ▁if ▁( ▁rc ▁-> ▁books ▁[ ▁i ▁] ▁[ ▁j ▁] ▁!= ▁-1 ▁) ▁break ▁; ▁if ▁( ▁j ▁== ▁8 ▁) ▁continue ▁; ▁cb ▁= ▁& ▁v enc ▁-> ▁code books ▁[ ▁rc ▁-> ▁books ▁[ ▁i ▁] ▁[ ▁j ▁] ▁] ▁; ▁assert ▁( ▁cb ▁-> ▁ndim entions ▁>= ▁2 ▁) ▁; ▁assert ▁( ▁cb ▁-> ▁lookup ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁cb ▁-> ▁n entries ▁; ▁j ▁++ ▁) ▁{ ▁float ▁a ▁; ▁if ▁( ▁! ▁cb ▁-> ▁lens ▁[ ▁j ▁] ▁) ▁continue ▁; ▁a ▁= ▁fabs ▁( ▁cb ▁-> ▁dim entions ▁[ ▁j ▁* ▁cb ▁-> ▁ndim entions ▁] ▁) ▁; ▁if ▁( ▁a ▁> ▁rc ▁-> ▁max es ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁) ▁rc ▁-> ▁max es ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁= ▁a ▁; ▁a ▁= ▁fabs ▁( ▁cb ▁-> ▁dim entions ▁[ ▁j ▁* ▁cb ▁-> ▁ndim entions ▁+ ▁1 ▁] ▁) ▁; ▁if ▁( ▁a ▁> ▁rc ▁-> ▁max es ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁) ▁rc ▁-> ▁max es ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁= ▁a ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁rc ▁-> ▁class ifications ▁; ▁i ▁++ ▁) ▁{ ▁rc ▁-> ▁max es ▁[ ▁i ▁] ▁[ ▁0 ▁] ▁+= ▁0.8 ▁; ▁rc ▁-> ▁max es ▁[ ▁i ▁] ▁[ ▁1 ▁] ▁+= ▁0.8 ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁mat ro sk a _ deliver _ packet ▁( ▁Mat ro sk a Demux Context ▁* ▁mat ro sk a ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁if ▁( ▁mat ro sk a ▁-> ▁num _ packets ▁> ▁0 ▁) ▁{ ▁memcpy ▁( ▁pkt ▁, ▁mat ro sk a ▁-> ▁packets ▁[ ▁0 ▁] ▁, ▁sizeof ▁( ▁AVPacket ▁) ▁) ▁; ▁av _ freep ▁( ▁& ▁mat ro sk a ▁-> ▁packets ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁mat ro sk a ▁-> ▁num _ packets ▁> ▁1 ▁) ▁{ ▁void ▁* ▁new packets ▁; ▁memmove ▁( ▁& ▁mat ro sk a ▁-> ▁packets ▁[ ▁0 ▁] ▁, ▁& ▁mat ro sk a ▁-> ▁packets ▁[ ▁1 ▁] ▁, ▁( ▁mat ro sk a ▁-> ▁num _ packets ▁- ▁1 ▁) ▁* ▁sizeof ▁( ▁AVPacket ▁* ▁) ▁) ▁; ▁new packets ▁= ▁av _ realloc ▁( ▁mat ro sk a ▁-> ▁packets ▁, ▁( ▁mat ro sk a ▁-> ▁num _ packets ▁- ▁1 ▁) ▁* ▁sizeof ▁( ▁AVPacket ▁* ▁) ▁) ▁; ▁if ▁( ▁new packets ▁) ▁mat ro sk a ▁-> ▁packets ▁= ▁new packets ▁; ▁} ▁else ▁{ ▁av _ freep ▁( ▁& ▁mat ro sk a ▁-> ▁packets ▁) ▁; ▁mat ro sk a ▁-> ▁prev _ pkt ▁= ▁NULL ▁; ▁} ▁mat ro sk a ▁-> ▁num _ packets ▁-- ▁; ▁return ▁0 ▁; ▁} ▁return ▁-1 ▁; ▁}	1
▁static ▁av _ always _ inline ▁int ▁check _ block ▁( ▁Snow Context ▁* ▁s ▁, ▁int ▁mb _ x ▁, ▁int ▁mb _ y ▁, ▁int ▁p ▁[ ▁3 ▁] ▁, ▁int ▁in tra ▁, ▁const ▁uint 8_ t ▁* ▁ob mc _ ed ged ▁, ▁int ▁* ▁best _ rd ▁) ▁{ ▁const ▁int ▁b _ stride ▁= ▁s ▁-> ▁b _ width ▁<< ▁s ▁-> ▁block _ max _ depth ▁; ▁Block Node ▁* ▁block ▁= ▁& ▁s ▁-> ▁block ▁[ ▁mb _ x ▁+ ▁mb _ y ▁* ▁b _ stride ▁] ▁; ▁Block Node ▁backup ▁= ▁* ▁block ▁; ▁int ▁rd ▁, ▁index ▁, ▁value ▁; ▁assert ▁( ▁mb _ x ▁>= ▁0 ▁&& ▁mb _ y ▁>= ▁0 ▁) ▁; ▁assert ▁( ▁mb _ x ▁< ▁b _ stride ▁) ▁; ▁if ▁( ▁in tra ▁) ▁{ ▁block ▁-> ▁color ▁[ ▁0 ▁] ▁= ▁p ▁[ ▁0 ▁] ▁; ▁block ▁-> ▁color ▁[ ▁1 ▁] ▁= ▁p ▁[ ▁1 ▁] ▁; ▁block ▁-> ▁color ▁[ ▁2 ▁] ▁= ▁p ▁[ ▁2 ▁] ▁; ▁block ▁-> ▁type ▁|= ▁BLOCK _ INTR A ▁; ▁} ▁else ▁{ ▁index ▁= ▁( ▁p ▁[ ▁0 ▁] ▁+ ▁31 ▁* ▁p ▁[ ▁1 ▁] ▁) ▁& ▁( ▁ME _ CACHE _ SIZE ▁- ▁1 ▁) ▁; ▁value ▁= ▁s ▁-> ▁me _ cache _ generation ▁+ ▁( ▁p ▁[ ▁0 ▁] ▁>> ▁10 ▁) ▁+ ▁( ▁p ▁[ ▁1 ▁] ▁<< ▁6 ▁) ▁+ ▁( ▁block ▁-> ▁ref ▁<< ▁12 ▁) ▁; ▁if ▁( ▁s ▁-> ▁me _ cache ▁[ ▁index ▁] ▁== ▁value ▁) ▁return ▁0 ▁; ▁s ▁-> ▁me _ cache ▁[ ▁index ▁] ▁= ▁value ▁; ▁block ▁-> ▁mx ▁= ▁p ▁[ ▁0 ▁] ▁; ▁block ▁-> ▁my ▁= ▁p ▁[ ▁1 ▁] ▁; ▁block ▁-> ▁type ▁&= ▁ ~ ▁BLOCK _ INTR A ▁; ▁} ▁rd ▁= ▁get _ block _ rd ▁( ▁s ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁0 ▁, ▁ob mc _ ed ged ▁) ▁; ▁if ▁( ▁rd ▁< ▁* ▁best _ rd ▁) ▁{ ▁* ▁best _ rd ▁= ▁rd ▁; ▁return ▁1 ▁; ▁} ▁else ▁{ ▁* ▁block ▁= ▁backup ▁; ▁return ▁0 ▁; ▁} ▁}	1
▁void ▁ff _ MP V _ common _ end ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁; ▁if ▁( ▁s ▁-> ▁slice _ context _ count ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁free _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁slice _ context _ count ▁; ▁i ▁++ ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁; ▁} ▁s ▁-> ▁slice _ context _ count ▁= ▁1 ▁; ▁} ▁else ▁free _ duplicate _ context ▁( ▁s ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁parse _ context ▁. ▁buffer ▁) ▁; ▁s ▁-> ▁parse _ context ▁. ▁buffer _ size ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁mb _ type ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁p _ mv _ table _ base ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁b _ for w _ mv _ table _ base ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁b _ back _ mv _ table _ base ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁b _ bid ir _ for w _ mv _ table _ base ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁b _ bid ir _ back _ mv _ table _ base ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁b _ direct _ mv _ table _ base ▁) ▁; ▁s ▁-> ▁p _ mv _ table ▁= ▁NULL ▁; ▁s ▁-> ▁b _ for w _ mv _ table ▁= ▁NULL ▁; ▁s ▁-> ▁b _ back _ mv _ table ▁= ▁NULL ▁; ▁s ▁-> ▁b _ bid ir _ for w _ mv _ table ▁= ▁NULL ▁; ▁s ▁-> ▁b _ bid ir _ back _ mv _ table ▁= ▁NULL ▁; ▁s ▁-> ▁b _ direct _ mv _ table ▁= ▁NULL ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁2 ▁; ▁k ▁++ ▁) ▁{ ▁av _ freep ▁( ▁& ▁s ▁-> ▁b _ field _ mv _ table _ base ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁) ▁; ▁s ▁-> ▁b _ field _ mv _ table ▁[ ▁i ▁] ▁[ ▁j ▁] ▁[ ▁k ▁] ▁= ▁NULL ▁; ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁b _ field _ select _ table ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁p _ field _ mv _ table _ base ▁[ ▁i ▁] ▁[ ▁j ▁] ▁) ▁; ▁s ▁-> ▁p _ field _ mv _ table ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁NULL ▁; ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁p _ field _ select _ table ▁[ ▁i ▁] ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁dc _ val _ base ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁coded _ block _ base ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁m bin tra _ table ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁cb p _ table ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁pred _ dir _ table ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁mb skip _ table ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁bitstream _ buffer ▁) ▁; ▁s ▁-> ▁allocated _ bit stream _ buffer _ size ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁avctx ▁-> ▁stats _ out ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁ac _ stats ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁error _ status _ table ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁mb _ index 2 xy ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁lambda _ table ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁q _ intra _ matrix ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁q _ inter _ matrix ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁q _ intra _ matrix 16 ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁q _ inter _ matrix 16 ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁input _ picture ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁re ordered _ input _ picture ▁) ▁; ▁av _ freep ▁( ▁& ▁s ▁-> ▁dct _ offset ▁) ▁; ▁if ▁( ▁s ▁-> ▁picture ▁&& ▁! ▁s ▁-> ▁avctx ▁-> ▁internal ▁-> ▁is _ copy ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁picture _ count ▁; ▁i ▁++ ▁) ▁{ ▁free _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁av _ freep ▁( ▁& ▁s ▁-> ▁picture ▁) ▁; ▁s ▁-> ▁context _ initialized ▁= ▁0 ▁; ▁s ▁-> ▁last _ picture _ ptr ▁= ▁s ▁-> ▁next _ picture _ ptr ▁= ▁s ▁-> ▁current _ picture _ ptr ▁= ▁NULL ▁; ▁s ▁-> ▁linesize ▁= ▁s ▁-> ▁uv lines ize ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁av _ freep ▁( ▁& ▁s ▁-> ▁visualization _ buffer ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁! ▁( ▁s ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ FRAME ▁) ▁) ▁avcodec _ default _ free _ buffers ▁( ▁s ▁-> ▁avctx ▁) ▁; ▁}	1
▁static ▁int ▁trans code _ sub title s ▁( ▁InputStream ▁* ▁ist ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁* ▁got _ output ▁) ▁{ ▁AV Subtitle ▁subtitle ▁; ▁int ▁i ▁, ▁ret ▁= ▁avcodec _ decode _ sub title 2 ▁( ▁ist ▁-> ▁dec _ ctx ▁, ▁& ▁subtitle ▁, ▁got _ output ▁, ▁pkt ▁) ▁; ▁check _ decode _ result ▁( ▁got _ output ▁, ▁ret ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁|| ▁! ▁* ▁got _ output ▁) ▁{ ▁if ▁( ▁! ▁pkt ▁-> ▁size ▁) ▁sub 2 video _ flush ▁( ▁ist ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁ist ▁-> ▁fix _ sub _ duration ▁) ▁{ ▁int ▁end ▁= ▁1 ▁; ▁if ▁( ▁ist ▁-> ▁prev _ sub ▁. ▁got _ output ▁) ▁{ ▁end ▁= ▁av _ re scale ▁( ▁subtitle ▁. ▁pts ▁- ▁ist ▁-> ▁prev _ sub ▁. ▁subtitle ▁. ▁pts ▁, ▁1000 ▁, ▁AV _ TIME _ BASE ▁) ▁; ▁if ▁( ▁end ▁< ▁ist ▁-> ▁prev _ sub ▁. ▁subtitle ▁. ▁end _ display _ time ▁) ▁{ ▁av _ log ▁( ▁ist ▁-> ▁dec _ ctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Sub t itled uration red uced from % d to % d % s \ n " ▁, ▁ist ▁-> ▁prev _ sub ▁. ▁subtitle ▁. ▁end _ display _ time ▁, ▁end ▁, ▁end ▁<= ▁0 ▁? ▁", dro pping it " ▁: ▁"" ▁) ▁; ▁ist ▁-> ▁prev _ sub ▁. ▁subtitle ▁. ▁end _ display _ time ▁= ▁end ▁; ▁} ▁} ▁F FS W AP ▁( ▁int ▁, ▁* ▁got _ output ▁, ▁ist ▁-> ▁prev _ sub ▁. ▁got _ output ▁) ▁; ▁F FS W AP ▁( ▁int ▁, ▁ret ▁, ▁ist ▁-> ▁prev _ sub ▁. ▁ret ▁) ▁; ▁F FS W AP ▁( ▁AV Subtitle ▁, ▁subtitle ▁, ▁ist ▁-> ▁prev _ sub ▁. ▁subtitle ▁) ▁; ▁if ▁( ▁end ▁<= ▁0 ▁) ▁goto ▁out ▁; ▁} ▁if ▁( ▁! ▁* ▁got _ output ▁) ▁return ▁ret ▁; ▁sub 2 video _ update ▁( ▁ist ▁, ▁& ▁subtitle ▁) ▁; ▁if ▁( ▁! ▁subtitle ▁. ▁num _ rect s ▁) ▁goto ▁out ▁; ▁ist ▁-> ▁frames _ decoded ▁++ ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁check _ output _ constraints ▁( ▁ist ▁, ▁o st ▁) ▁|| ▁! ▁o st ▁-> ▁encoding _ needed ▁|| ▁o st ▁-> ▁enc ▁-> ▁type ▁!= ▁AVMEDIA _ TYPE _ SUBTITLE ▁) ▁continue ▁; ▁do _ sub title _ out ▁( ▁output _ files ▁[ ▁o st ▁-> ▁file _ index ▁] ▁-> ▁ctx ▁, ▁o st ▁, ▁ist ▁, ▁& ▁subtitle ▁) ▁; ▁} ▁out ▁: ▁av sub title _ free ▁( ▁& ▁subtitle ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁cd xl _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁CDXL Video Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁const ▁p ▁= ▁& ▁c ▁-> ▁frame ▁; ▁int ▁ret ▁, ▁w ▁, ▁h ▁, ▁encoding ▁, ▁format ▁, ▁buf _ size ▁= ▁pkt ▁-> ▁size ▁; ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁pkt ▁-> ▁data ▁; ▁if ▁( ▁buf _ size ▁< ▁32 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁encoding ▁= ▁buf ▁[ ▁1 ▁] ▁& ▁7 ▁; ▁format ▁= ▁buf ▁[ ▁1 ▁] ▁& ▁0 xE 0 ▁; ▁w ▁= ▁AV _ RB 16 ▁( ▁& ▁buf ▁[ ▁14 ▁] ▁) ▁; ▁h ▁= ▁AV _ RB 16 ▁( ▁& ▁buf ▁[ ▁16 ▁] ▁) ▁; ▁c ▁-> ▁bpp ▁= ▁buf ▁[ ▁19 ▁] ▁; ▁c ▁-> ▁palette _ size ▁= ▁AV _ RB 16 ▁( ▁& ▁buf ▁[ ▁20 ▁] ▁) ▁; ▁c ▁-> ▁palette ▁= ▁buf ▁+ ▁32 ▁; ▁c ▁-> ▁video ▁= ▁c ▁-> ▁palette ▁+ ▁c ▁-> ▁palette _ size ▁; ▁c ▁-> ▁video _ size ▁= ▁buf _ size ▁- ▁c ▁-> ▁palette _ size ▁- ▁32 ▁; ▁if ▁( ▁c ▁-> ▁palette _ size ▁> ▁512 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁buf _ size ▁< ▁c ▁-> ▁palette _ size ▁+ ▁32 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁c ▁-> ▁bpp ▁< ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁c ▁-> ▁bpp ▁> ▁8 ▁) ▁{ ▁av _ log _ ask _ for _ sample ▁( ▁avctx ▁, ▁" unsupported pixel size :% d \ n " ▁, ▁c ▁-> ▁bpp ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁format ▁) ▁{ ▁av _ log _ ask _ for _ sample ▁( ▁avctx ▁, ▁" unsupported pixel format :% d \ n " ▁, ▁format ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁av _ image _ check _ size ▁( ▁w ▁, ▁h ▁, ▁0 ▁, ▁avctx ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁w ▁!= ▁avctx ▁-> ▁width ▁|| ▁h ▁!= ▁avctx ▁-> ▁height ▁) ▁avcodec _ set _ dimensions ▁( ▁avctx ▁, ▁w ▁, ▁h ▁) ▁; ▁if ▁( ▁c ▁-> ▁video _ size ▁< ▁FF ALIGN ▁( ▁avctx ▁-> ▁width ▁, ▁16 ▁) ▁* ▁avctx ▁-> ▁height ▁* ▁c ▁-> ▁bpp ▁/ ▁8 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁! ▁encoding ▁&& ▁c ▁-> ▁palette _ size ▁&& ▁c ▁-> ▁bpp ▁<= ▁8 ▁) ▁{ ▁avctx ▁-> ▁pix _ fmt ▁= ▁PIX _ FMT _ PAL 8 ▁; ▁} ▁else ▁if ▁( ▁encoding ▁== ▁1 ▁&& ▁( ▁c ▁-> ▁bpp ▁== ▁6 ▁|| ▁c ▁-> ▁bpp ▁== ▁8 ▁) ▁) ▁{ ▁if ▁( ▁c ▁-> ▁palette _ size ▁!= ▁( ▁1 ▁<< ▁( ▁c ▁-> ▁bpp ▁- ▁1 ▁) ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avctx ▁-> ▁pix _ fmt ▁= ▁PIX _ FMT _ BGR 24 ▁; ▁} ▁else ▁{ ▁av _ log _ ask _ for _ sample ▁( ▁avctx ▁, ▁" unsupported encoding % d and bpp % d \ n " ▁, ▁encoding ▁, ▁c ▁-> ▁bpp ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁p ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁avctx ▁-> ▁release _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁; ▁p ▁-> ▁reference ▁= ▁0 ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁p ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁p ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁if ▁( ▁encoding ▁) ▁{ ▁av _ fast _ pad ded _ malloc ▁( ▁& ▁c ▁-> ▁new _ video ▁, ▁& ▁c ▁-> ▁new _ video _ size ▁, ▁h ▁* ▁w ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁new _ video ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁c ▁-> ▁bpp ▁== ▁8 ▁) ▁cd xl _ decode _ ham 8 ▁( ▁c ▁) ▁; ▁else ▁cd xl _ decode _ ham 6 ▁( ▁c ▁) ▁; ▁} ▁else ▁{ ▁cd xl _ decode _ rgb ▁( ▁c ▁) ▁; ▁} ▁* ▁data _ size ▁= ▁sizeof ▁( ▁AVFrame ▁) ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁c ▁-> ▁frame ▁; ▁return ▁buf _ size ▁; ▁}	1
▁void ▁_ TIFF memset ▁( ▁void ▁* ▁p ▁, ▁int ▁v ▁, ▁tm size _ t ▁c ▁) ▁{ ▁memset ▁( ▁p ▁, ▁v ▁, ▁( ▁size _ t ▁) ▁c ▁) ▁; ▁}	1
▁static ▁void ▁implicit _ weight _ table ▁( ▁const ▁H 264 Context ▁* ▁h ▁, ▁H 264 Slice Context ▁* ▁sl ▁, ▁int ▁field ▁) ▁{ ▁int ▁ref 0 ▁, ▁ref 1 ▁, ▁i ▁, ▁cur _ p oc ▁, ▁ref _ start ▁, ▁ref _ count 0 ▁, ▁ref _ count 1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁sl ▁-> ▁lum a _ weight _ flag ▁[ ▁i ▁] ▁= ▁0 ▁; ▁sl ▁-> ▁chroma _ weight _ flag ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁if ▁( ▁field ▁< ▁0 ▁) ▁{ ▁if ▁( ▁h ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁{ ▁cur _ p oc ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁p oc ▁; ▁} ▁else ▁{ ▁cur _ p oc ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁field _ p oc ▁[ ▁h ▁-> ▁picture _ structure ▁- ▁1 ▁] ▁; ▁} ▁if ▁( ▁sl ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁== ▁1 ▁&& ▁sl ▁-> ▁ref _ count ▁[ ▁1 ▁] ▁== ▁1 ▁&& ▁! ▁FRAME _ MB AFF ▁( ▁h ▁) ▁&& ▁sl ▁-> ▁ref _ list ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁. ▁p oc ▁+ ▁sl ▁-> ▁ref _ list ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁. ▁p oc ▁== ▁2 ▁* ▁cur _ p oc ▁) ▁{ ▁sl ▁-> ▁use _ weight ▁= ▁0 ▁; ▁sl ▁-> ▁use _ weight _ chroma ▁= ▁0 ▁; ▁return ▁; ▁} ▁ref _ start ▁= ▁0 ▁; ▁ref _ count 0 ▁= ▁sl ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁; ▁ref _ count 1 ▁= ▁sl ▁-> ▁ref _ count ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁cur _ p oc ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁field _ p oc ▁[ ▁field ▁] ▁; ▁ref _ start ▁= ▁16 ▁; ▁ref _ count 0 ▁= ▁16 ▁+ ▁2 ▁* ▁sl ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁; ▁ref _ count 1 ▁= ▁16 ▁+ ▁2 ▁* ▁sl ▁-> ▁ref _ count ▁[ ▁1 ▁] ▁; ▁} ▁sl ▁-> ▁use _ weight ▁= ▁2 ▁; ▁sl ▁-> ▁use _ weight _ chroma ▁= ▁2 ▁; ▁sl ▁-> ▁lum a _ log 2_ weight _ den om ▁= ▁5 ▁; ▁sl ▁-> ▁chroma _ log 2_ weight _ den om ▁= ▁5 ▁; ▁for ▁( ▁ref 0 ▁= ▁ref _ start ▁; ▁ref 0 ▁< ▁ref _ count 0 ▁; ▁ref 0 ▁++ ▁) ▁{ ▁int ▁p oc 0 ▁= ▁sl ▁-> ▁ref _ list ▁[ ▁0 ▁] ▁[ ▁ref 0 ▁] ▁. ▁p oc ▁; ▁for ▁( ▁ref 1 ▁= ▁ref _ start ▁; ▁ref 1 ▁< ▁ref _ count 1 ▁; ▁ref 1 ▁++ ▁) ▁{ ▁int ▁w ▁= ▁32 ▁; ▁if ▁( ▁! ▁sl ▁-> ▁ref _ list ▁[ ▁0 ▁] ▁[ ▁ref 0 ▁] ▁. ▁parent ▁-> ▁long _ ref ▁&& ▁! ▁sl ▁-> ▁ref _ list ▁[ ▁1 ▁] ▁[ ▁ref 1 ▁] ▁. ▁parent ▁-> ▁long _ ref ▁) ▁{ ▁int ▁p oc 1 ▁= ▁sl ▁-> ▁ref _ list ▁[ ▁1 ▁] ▁[ ▁ref 1 ▁] ▁. ▁p oc ▁; ▁int ▁td ▁= ▁av _ clip _ int 8 ▁( ▁p oc 1 ▁- ▁p oc 0 ▁) ▁; ▁if ▁( ▁td ▁) ▁{ ▁int ▁tb ▁= ▁av _ clip _ int 8 ▁( ▁cur _ p oc ▁- ▁p oc 0 ▁) ▁; ▁int ▁tx ▁= ▁( ▁16384 ▁+ ▁( ▁FF ABS ▁( ▁td ▁) ▁>> ▁1 ▁) ▁) ▁/ ▁td ▁; ▁int ▁dist _ scale _ factor ▁= ▁( ▁tb ▁* ▁tx ▁+ ▁32 ▁) ▁>> ▁8 ▁; ▁if ▁( ▁dist _ scale _ factor ▁>= ▁- 64 ▁&& ▁dist _ scale _ factor ▁<= ▁128 ▁) ▁w ▁= ▁64 ▁- ▁dist _ scale _ factor ▁; ▁} ▁} ▁if ▁( ▁field ▁< ▁0 ▁) ▁{ ▁sl ▁-> ▁implicit _ weight ▁[ ▁ref 0 ▁] ▁[ ▁ref 1 ▁] ▁[ ▁0 ▁] ▁= ▁sl ▁-> ▁implicit _ weight ▁[ ▁ref 0 ▁] ▁[ ▁ref 1 ▁] ▁[ ▁1 ▁] ▁= ▁w ▁; ▁} ▁else ▁{ ▁sl ▁-> ▁implicit _ weight ▁[ ▁ref 0 ▁] ▁[ ▁ref 1 ▁] ▁[ ▁field ▁] ▁= ▁w ▁; ▁} ▁} ▁} ▁}	1
▁int ▁url _ open _ protocol ▁( ▁URL Context ▁* ▁* ▁puc ▁, ▁struct ▁URL Protocol ▁* ▁up ▁, ▁const ▁char ▁* ▁filename ▁, ▁int ▁flags ▁) ▁{ ▁URL Context ▁* ▁uc ▁; ▁int ▁err ▁; ▁uc ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁URL Context ▁) ▁+ ▁strlen ▁( ▁filename ▁) ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁uc ▁) ▁{ ▁err ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁# if ▁LIB AV FORMAT _ VERSION _ MAJOR ▁>= ▁53 ▁uc ▁-> ▁av _ class ▁= ▁& ▁url context _ class ▁; ▁# endif ▁uc ▁-> ▁filename ▁= ▁( ▁char ▁* ▁) ▁& ▁uc ▁[ ▁1 ▁] ▁; ▁strcpy ▁( ▁uc ▁-> ▁filename ▁, ▁filename ▁) ▁; ▁uc ▁-> ▁prot ▁= ▁up ▁; ▁uc ▁-> ▁flags ▁= ▁flags ▁; ▁uc ▁-> ▁is _ stream ed ▁= ▁0 ▁; ▁uc ▁-> ▁max _ packet _ size ▁= ▁0 ▁; ▁err ▁= ▁up ▁-> ▁url _ open ▁( ▁uc ▁, ▁filename ▁, ▁flags ▁) ▁; ▁if ▁( ▁err ▁< ▁0 ▁) ▁{ ▁av _ free ▁( ▁uc ▁) ▁; ▁* ▁puc ▁= ▁NULL ▁; ▁return ▁err ▁; ▁} ▁if ▁( ▁( ▁flags ▁& ▁( ▁URL _ WRONLY ▁| ▁URL _ RDWR ▁) ▁) ▁|| ▁! ▁strcmp ▁( ▁up ▁-> ▁name ▁, ▁" file " ▁) ▁) ▁if ▁( ▁! ▁uc ▁-> ▁is _ stream ed ▁&& ▁url _ seek ▁( ▁uc ▁, ▁0 ▁, ▁SEEK _ SET ▁) ▁< ▁0 ▁) ▁uc ▁-> ▁is _ stream ed ▁= ▁1 ▁; ▁* ▁puc ▁= ▁uc ▁; ▁return ▁0 ▁; ▁fail ▁: ▁* ▁puc ▁= ▁NULL ▁; ▁return ▁err ▁; ▁}	1
▁static ▁int ▁gif _ read _ image ▁( ▁Gif State ▁* ▁s ▁, ▁AVFrame ▁* ▁frame ▁) ▁{ ▁int ▁left ▁, ▁top ▁, ▁width ▁, ▁height ▁, ▁bits _ per _ pixel ▁, ▁code _ size ▁, ▁flags ▁, ▁pw ▁; ▁int ▁is _ inter leaved ▁, ▁has _ local _ palette ▁, ▁y ▁, ▁pass ▁, ▁y 1 ▁, ▁linesize ▁, ▁pal _ size ▁; ▁uint 32_ t ▁* ▁ptr ▁, ▁* ▁pal ▁, ▁* ▁px ▁, ▁* ▁pr ▁, ▁* ▁ptr 1 ▁; ▁int ▁ret ▁; ▁uint 8_ t ▁* ▁idx ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁9 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁left ▁= ▁bytestream 2_ get _ le 16 u ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁top ▁= ▁bytestream 2_ get _ le 16 u ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁width ▁= ▁bytestream 2_ get _ le 16 u ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁height ▁= ▁bytestream 2_ get _ le 16 u ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁flags ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁is _ inter leaved ▁= ▁flags ▁& ▁0 x 40 ▁; ▁has _ local _ palette ▁= ▁flags ▁& ▁0 x 80 ▁; ▁bits _ per _ pixel ▁= ▁( ▁flags ▁& ▁0 x 07 ▁) ▁+ ▁1 ▁; ▁av _ d log ▁( ▁s ▁-> ▁avctx ▁, ▁" image x =% dy =% dw =% dh =% d \ n " ▁, ▁left ▁, ▁top ▁, ▁width ▁, ▁height ▁) ▁; ▁if ▁( ▁has _ local _ palette ▁) ▁{ ▁pal _ size ▁= ▁1 ▁<< ▁bits _ per _ pixel ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁pal _ size ▁* ▁3 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁gif _ read _ palette ▁( ▁s ▁, ▁s ▁-> ▁local _ palette ▁, ▁pal _ size ▁) ▁; ▁pal ▁= ▁s ▁-> ▁local _ palette ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁s ▁-> ▁has _ global _ palette ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" picture does n ' th av ee ither global or local palette .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁pal ▁= ▁s ▁-> ▁global _ palette ▁; ▁} ▁if ▁( ▁s ▁-> ▁keyframe ▁) ▁{ ▁if ▁( ▁s ▁-> ▁transparent _ color _ index ▁== ▁-1 ▁&& ▁s ▁-> ▁has _ global _ palette ▁) ▁{ ▁gif _ fill ▁( ▁frame ▁, ▁s ▁-> ▁bg _ color ▁) ▁; ▁} ▁else ▁{ ▁gif _ fill ▁( ▁frame ▁, ▁s ▁-> ▁trans _ color ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁width ▁|| ▁width ▁> ▁s ▁-> ▁screen _ width ▁|| ▁left ▁>= ▁s ▁-> ▁screen _ width ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid image width .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁! ▁height ▁|| ▁height ▁> ▁s ▁-> ▁screen _ height ▁|| ▁top ▁>= ▁s ▁-> ▁screen _ height ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid image height .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁left ▁+ ▁width ▁> ▁s ▁-> ▁screen _ width ▁) ▁{ ▁pw ▁= ▁s ▁-> ▁screen _ width ▁- ▁left ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Im aget oo wide by % d , trunc ating .\ n " ▁, ▁left ▁+ ▁width ▁- ▁s ▁-> ▁screen _ width ▁) ▁; ▁} ▁else ▁{ ▁pw ▁= ▁width ▁; ▁} ▁if ▁( ▁top ▁+ ▁height ▁> ▁s ▁-> ▁screen _ height ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Im aget oo high by % d , trunc ating .\ n " ▁, ▁top ▁+ ▁height ▁- ▁s ▁-> ▁screen _ height ▁) ▁; ▁height ▁= ▁s ▁-> ▁screen _ height ▁- ▁top ▁; ▁} ▁if ▁( ▁s ▁-> ▁g ce _ prev _ disp os al ▁== ▁G CE _ DIS POS AL _ BACKGROUND ▁) ▁{ ▁gif _ fill _ rect ▁( ▁frame ▁, ▁s ▁-> ▁stored _ bg _ color ▁, ▁s ▁-> ▁g ce _ l ▁, ▁s ▁-> ▁g ce _ t ▁, ▁s ▁-> ▁g ce _ w ▁, ▁s ▁-> ▁g ce _ h ▁) ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁g ce _ prev _ disp os al ▁== ▁G CE _ DIS POS AL _ RESTORE ▁) ▁{ ▁gif _ copy _ img _ rect ▁( ▁s ▁-> ▁stored _ img ▁, ▁( ▁uint 32_ t ▁* ▁) ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁/ ▁sizeof ▁( ▁uint 32_ t ▁) ▁, ▁s ▁-> ▁g ce _ l ▁, ▁s ▁-> ▁g ce _ t ▁, ▁s ▁-> ▁g ce _ w ▁, ▁s ▁-> ▁g ce _ h ▁) ▁; ▁} ▁s ▁-> ▁g ce _ prev _ disp os al ▁= ▁s ▁-> ▁g ce _ disp os al ▁; ▁if ▁( ▁s ▁-> ▁g ce _ disp os al ▁!= ▁G CE _ DIS POS AL _ NONE ▁) ▁{ ▁s ▁-> ▁g ce _ l ▁= ▁left ▁; ▁s ▁-> ▁g ce _ t ▁= ▁top ▁; ▁s ▁-> ▁g ce _ w ▁= ▁pw ▁; ▁s ▁-> ▁g ce _ h ▁= ▁height ▁; ▁if ▁( ▁s ▁-> ▁g ce _ disp os al ▁== ▁G CE _ DIS POS AL _ BACKGROUND ▁) ▁{ ▁if ▁( ▁s ▁-> ▁transparent _ color _ index ▁>= ▁0 ▁) ▁s ▁-> ▁stored _ bg _ color ▁= ▁s ▁-> ▁trans _ color ▁; ▁else ▁s ▁-> ▁stored _ bg _ color ▁= ▁s ▁-> ▁bg _ color ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁g ce _ disp os al ▁== ▁G CE _ DIS POS AL _ RESTORE ▁) ▁{ ▁av _ fast _ malloc ▁( ▁& ▁s ▁-> ▁stored _ img ▁, ▁& ▁s ▁-> ▁stored _ img _ size ▁, ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁* ▁frame ▁-> ▁height ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁stored _ img ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁gif _ copy _ img _ rect ▁( ▁( ▁uint 32_ t ▁* ▁) ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁stored _ img ▁, ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁/ ▁sizeof ▁( ▁uint 32_ t ▁) ▁, ▁left ▁, ▁top ▁, ▁pw ▁, ▁height ▁) ▁; ▁} ▁} ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁2 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁code _ size ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ lz w _ decode _ init ▁( ▁s ▁-> ▁lz w ▁, ▁code _ size ▁, ▁s ▁-> ▁gb ▁. ▁buffer ▁, ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁, ▁FF _ LZ W _ GIF ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" LZ W init failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁linesize ▁= ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁/ ▁sizeof ▁( ▁uint 32_ t ▁) ▁; ▁ptr 1 ▁= ▁( ▁uint 32_ t ▁* ▁) ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁top ▁* ▁linesize ▁+ ▁left ▁; ▁ptr ▁= ▁ptr 1 ▁; ▁pass ▁= ▁0 ▁; ▁y 1 ▁= ▁0 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁++ ▁) ▁{ ▁int ▁count ▁= ▁ff _ lz w _ decode ▁( ▁s ▁-> ▁lz w ▁, ▁s ▁-> ▁idx _ line ▁, ▁width ▁) ▁; ▁if ▁( ▁count ▁!= ▁width ▁) ▁{ ▁if ▁( ▁count ▁) ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" LZ W deco def ailed \ n " ▁) ▁; ▁goto ▁decode _ tail ▁; ▁} ▁pr ▁= ▁ptr ▁+ ▁pw ▁; ▁for ▁( ▁px ▁= ▁ptr ▁, ▁idx ▁= ▁s ▁-> ▁idx _ line ▁; ▁px ▁< ▁pr ▁; ▁px ▁++ ▁, ▁idx ▁++ ▁) ▁{ ▁if ▁( ▁* ▁idx ▁!= ▁s ▁-> ▁transparent _ color _ index ▁) ▁* ▁px ▁= ▁pal ▁[ ▁* ▁idx ▁] ▁; ▁} ▁if ▁( ▁is _ inter leaved ▁) ▁{ ▁switch ▁( ▁pass ▁) ▁{ ▁default ▁: ▁case ▁0 ▁: ▁case ▁1 ▁: ▁y 1 ▁+= ▁8 ▁; ▁ptr ▁+= ▁linesize ▁* ▁8 ▁; ▁if ▁( ▁y 1 ▁>= ▁height ▁) ▁{ ▁y 1 ▁= ▁pass ▁? ▁2 ▁: ▁4 ▁; ▁ptr ▁= ▁ptr 1 ▁+ ▁linesize ▁* ▁y 1 ▁; ▁pass ▁++ ▁; ▁} ▁break ▁; ▁case ▁2 ▁: ▁y 1 ▁+= ▁4 ▁; ▁ptr ▁+= ▁linesize ▁* ▁4 ▁; ▁if ▁( ▁y 1 ▁>= ▁height ▁) ▁{ ▁y 1 ▁= ▁1 ▁; ▁ptr ▁= ▁ptr 1 ▁+ ▁linesize ▁; ▁pass ▁++ ▁; ▁} ▁break ▁; ▁case ▁3 ▁: ▁y 1 ▁+= ▁2 ▁; ▁ptr ▁+= ▁linesize ▁* ▁2 ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁ptr ▁+= ▁linesize ▁; ▁} ▁} ▁decode _ tail ▁: ▁ff _ lz w _ decode _ tail ▁( ▁s ▁-> ▁lz w ▁) ▁; ▁s ▁-> ▁transparent _ color _ index ▁= ▁-1 ▁; ▁s ▁-> ▁g ce _ disp os al ▁= ▁G CE _ DIS POS AL _ NONE ▁; ▁return ▁0 ▁; ▁}	0
▁void ▁sw ri _ get _ d ither ▁( ▁S wr Context ▁* ▁s ▁, ▁void ▁* ▁dst ▁, ▁int ▁len ▁, ▁unsigned ▁seed ▁, ▁enum ▁AV Sample Format ▁noise _ fmt ▁) ▁{ ▁double ▁scale ▁= ▁s ▁-> ▁d ither ▁. ▁noise _ scale ▁; ▁# define ▁TMP _ EXTRA ▁2 ▁double ▁* ▁tmp ▁= ▁av _ malloc _ array ▁( ▁len ▁+ ▁TMP _ EXTRA ▁, ▁sizeof ▁( ▁double ▁) ▁) ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁+ ▁TMP _ EXTRA ▁; ▁i ▁++ ▁) ▁{ ▁double ▁v ▁; ▁seed ▁= ▁seed ▁* ▁16 645 25 ▁+ ▁101 39 04 223 ▁; ▁switch ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁) ▁{ ▁case ▁S WR _ DIT HER _ RECT ANG ULAR ▁: ▁v ▁= ▁( ▁( ▁double ▁) ▁seed ▁) ▁/ ▁UINT _ MAX ▁- ▁0.5 ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁< ▁S WR _ DIT HER _ NB ▁) ▁; ▁v ▁= ▁( ▁( ▁double ▁) ▁seed ▁) ▁/ ▁UINT _ MAX ▁; ▁seed ▁= ▁seed ▁* ▁16 645 25 ▁+ ▁101 39 04 223 ▁; ▁v ▁-= ▁( ▁( ▁double ▁) ▁seed ▁) ▁/ ▁UINT _ MAX ▁; ▁break ▁; ▁} ▁tmp ▁[ ▁i ▁] ▁= ▁v ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁double ▁v ▁; ▁switch ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁) ▁{ ▁default ▁: ▁av _ assert 0 ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁< ▁S WR _ DIT HER _ NB ▁) ▁; ▁v ▁= ▁tmp ▁[ ▁i ▁] ▁; ▁break ▁; ▁case ▁S WR _ DIT HER _ TRIAN G ULAR _ HIGH PASS ▁: ▁v ▁= ▁( ▁- ▁tmp ▁[ ▁i ▁] ▁+ ▁2 ▁* ▁tmp ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁tmp ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁/ ▁sqrt ▁( ▁6 ▁) ▁; ▁break ▁; ▁} ▁v ▁*= ▁scale ▁; ▁switch ▁( ▁noise _ fmt ▁) ▁{ ▁case ▁AV _ SAMPLE _ FMT _ S 16 P ▁: ▁( ▁( ▁int 16_ t ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ S 32 P ▁: ▁( ▁( ▁int 32_ t ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ FL TP ▁: ▁( ▁( ▁float ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ DB LP ▁: ▁( ▁( ▁double ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁} ▁} ▁av _ free ▁( ▁tmp ▁) ▁; ▁}	1
▁static ▁void ▁search _ for _ quant izers _ fast ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AAC Enc Context ▁* ▁s ▁, ▁Single Channel Element ▁* ▁sce ▁, ▁const ▁float ▁lambda ▁) ▁{ ▁int ▁i ▁, ▁w ▁, ▁w 2 ▁, ▁g ▁; ▁int ▁min q ▁= ▁255 ▁; ▁memset ▁( ▁sce ▁-> ▁sf _ idx ▁, ▁0 ▁, ▁sizeof ▁( ▁sce ▁-> ▁sf _ idx ▁) ▁) ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁; ▁w ▁+= ▁sce ▁-> ▁ics ▁. ▁group _ len ▁[ ▁w ▁] ▁) ▁{ ▁for ▁( ▁g ▁= ▁0 ▁; ▁g ▁< ▁sce ▁-> ▁ics ▁. ▁num _ sw b ▁; ▁g ▁++ ▁) ▁{ ▁for ▁( ▁w 2 ▁= ▁0 ▁; ▁w 2 ▁< ▁sce ▁-> ▁ics ▁. ▁group _ len ▁[ ▁w ▁] ▁; ▁w 2 ▁++ ▁) ▁{ ▁F FP sy Band ▁* ▁band ▁= ▁& ▁s ▁-> ▁ps y ▁. ▁ch ▁[ ▁s ▁-> ▁cur _ channel ▁] ▁. ▁ps y _ band s ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁; ▁if ▁( ▁band ▁-> ▁energy ▁<= ▁band ▁-> ▁threshold ▁) ▁{ ▁sce ▁-> ▁sf _ idx ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁= ▁2 18 ▁; ▁sce ▁-> ▁zero es ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁= ▁1 ▁; ▁} ▁else ▁{ ▁sce ▁-> ▁sf _ idx ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁= ▁av _ clip ▁( ▁SCALE _ ONE _ POS ▁- ▁SCALE _ DIV _512 ▁+ ▁log 2 f ▁( ▁band ▁-> ▁threshold ▁) ▁, ▁80 ▁, ▁2 18 ▁) ▁; ▁sce ▁-> ▁zero es ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁= ▁0 ▁; ▁} ▁min q ▁= ▁FF MIN ▁( ▁min q ▁, ▁sce ▁-> ▁sf _ idx ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁) ▁; ▁} ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁128 ▁; ▁i ▁++ ▁) ▁{ ▁sce ▁-> ▁sf _ idx ▁[ ▁i ▁] ▁= ▁140 ▁; ▁} ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁; ▁w ▁+= ▁sce ▁-> ▁ics ▁. ▁group _ len ▁[ ▁w ▁] ▁) ▁for ▁( ▁g ▁= ▁0 ▁; ▁g ▁< ▁sce ▁-> ▁ics ▁. ▁num _ sw b ▁; ▁g ▁++ ▁) ▁for ▁( ▁w 2 ▁= ▁1 ▁; ▁w 2 ▁< ▁sce ▁-> ▁ics ▁. ▁group _ len ▁[ ▁w ▁] ▁; ▁w 2 ▁++ ▁) ▁sce ▁-> ▁sf _ idx ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁= ▁sce ▁-> ▁sf _ idx ▁[ ▁w ▁* ▁16 ▁+ ▁g ▁] ▁; ▁}	1
▁int ▁ff _ h 264 5_ packet _ split ▁( ▁H 264 5 Packet ▁* ▁pkt ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁length ▁, ▁void ▁* ▁log ctx ▁, ▁int ▁is _ n al ff ▁, ▁int ▁nal _ length _ size ▁, ▁enum ▁AVCodec ID ▁codec _ id ▁, ▁int ▁small _ padding ▁) ▁{ ▁int ▁consumed ▁, ▁ret ▁= ▁0 ▁; ▁const ▁uint 8_ t ▁* ▁next _ avc ▁= ▁is _ n al ff ▁? ▁buf ▁: ▁buf ▁+ ▁length ▁; ▁pkt ▁-> ▁nb _ n als ▁= ▁0 ▁; ▁while ▁( ▁length ▁>= ▁4 ▁) ▁{ ▁H 264 5 NAL ▁* ▁nal ▁; ▁int ▁extract _ length ▁= ▁0 ▁; ▁int ▁skip _ trailing _ zeros ▁= ▁1 ▁; ▁if ▁( ▁buf ▁== ▁next _ avc ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nal _ length _ size ▁; ▁i ▁++ ▁) ▁extract _ length ▁= ▁( ▁extract _ length ▁<< ▁8 ▁) ▁| ▁buf ▁[ ▁i ▁] ▁; ▁buf ▁+= ▁nal _ length _ size ▁; ▁length ▁-= ▁nal _ length _ size ▁; ▁if ▁( ▁extract _ length ▁> ▁length ▁) ▁{ ▁av _ log ▁( ▁log ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid NAL unit size .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁next _ avc ▁= ▁buf ▁+ ▁extract _ length ▁; ▁} ▁else ▁{ ▁if ▁( ▁buf ▁> ▁next _ avc ▁) ▁av _ log ▁( ▁log ctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Exceeded next NAL FF position , re - sync ing .\ n " ▁) ▁; ▁while ▁( ▁buf ▁[ ▁0 ▁] ▁!= ▁0 ▁|| ▁buf ▁[ ▁1 ▁] ▁!= ▁0 ▁|| ▁buf ▁[ ▁2 ▁] ▁!= ▁1 ▁) ▁{ ▁++ ▁buf ▁; ▁-- ▁length ▁; ▁if ▁( ▁length ▁< ▁4 ▁) ▁{ ▁if ▁( ▁pkt ▁-> ▁nb _ n als ▁> ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁log ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" N ostart code is found .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁else ▁if ▁( ▁buf ▁>= ▁( ▁next _ avc ▁- ▁3 ▁) ▁) ▁break ▁; ▁} ▁buf ▁+= ▁3 ▁; ▁length ▁-= ▁3 ▁; ▁extract _ length ▁= ▁FF MIN ▁( ▁length ▁, ▁next _ avc ▁- ▁buf ▁) ▁; ▁if ▁( ▁buf ▁>= ▁next _ avc ▁) ▁{ ▁int ▁offset ▁= ▁next _ avc ▁- ▁buf ▁; ▁buf ▁+= ▁offset ▁; ▁length ▁-= ▁offset ▁; ▁continue ▁; ▁} ▁} ▁if ▁( ▁pkt ▁-> ▁n als _ allocated ▁< ▁pkt ▁-> ▁nb _ n als ▁+ ▁1 ▁) ▁{ ▁int ▁new _ size ▁= ▁pkt ▁-> ▁n als _ allocated ▁+ ▁1 ▁; ▁void ▁* ▁tmp ▁= ▁av _ realloc _ array ▁( ▁pkt ▁-> ▁n als ▁, ▁new _ size ▁, ▁sizeof ▁( ▁* ▁pkt ▁-> ▁n als ▁) ▁) ▁; ▁if ▁( ▁! ▁tmp ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁pkt ▁-> ▁n als ▁= ▁tmp ▁; ▁memset ▁( ▁pkt ▁-> ▁n als ▁+ ▁pkt ▁-> ▁n als _ allocated ▁, ▁0 ▁, ▁( ▁new _ size ▁- ▁pkt ▁-> ▁n als _ allocated ▁) ▁* ▁sizeof ▁( ▁* ▁pkt ▁-> ▁n als ▁) ▁) ▁; ▁nal ▁= ▁& ▁pkt ▁-> ▁n als ▁[ ▁pkt ▁-> ▁nb _ n als ▁] ▁; ▁nal ▁-> ▁skipped _ bytes _ pos _ size ▁= ▁1024 ▁; ▁nal ▁-> ▁skipped _ bytes _ pos ▁= ▁av _ malloc _ array ▁( ▁nal ▁-> ▁skipped _ bytes _ pos _ size ▁, ▁sizeof ▁( ▁* ▁nal ▁-> ▁skipped _ bytes _ pos ▁) ▁) ▁; ▁if ▁( ▁! ▁nal ▁-> ▁skipped _ bytes _ pos ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁pkt ▁-> ▁n als _ allocated ▁= ▁new _ size ▁; ▁} ▁nal ▁= ▁& ▁pkt ▁-> ▁n als ▁[ ▁pkt ▁-> ▁nb _ n als ▁] ▁; ▁consumed ▁= ▁ff _ h 264 5_ extract _ rb sp ▁( ▁buf ▁, ▁extract _ length ▁, ▁nal ▁, ▁small _ padding ▁) ▁; ▁if ▁( ▁consumed ▁< ▁0 ▁) ▁return ▁consumed ▁; ▁if ▁( ▁is _ n al ff ▁&& ▁( ▁extract _ length ▁!= ▁consumed ▁) ▁&& ▁extract _ length ▁) ▁av _ log ▁( ▁log ctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" NAL FF : Consumed only % db ytes inst ead of % d \ n " ▁, ▁consumed ▁, ▁extract _ length ▁) ▁; ▁pkt ▁-> ▁nb _ n als ▁++ ▁; ▁if ▁( ▁consumed ▁< ▁length ▁- ▁3 ▁&& ▁buf ▁[ ▁consumed ▁] ▁== ▁0 x 00 ▁&& ▁buf ▁[ ▁consumed ▁+ ▁1 ▁] ▁== ▁0 x 00 ▁&& ▁buf ▁[ ▁consumed ▁+ ▁2 ▁] ▁== ▁0 x 01 ▁&& ▁buf ▁[ ▁consumed ▁+ ▁3 ▁] ▁== ▁0 xE 0 ▁) ▁skip _ trailing _ zeros ▁= ▁0 ▁; ▁nal ▁-> ▁size _ bits ▁= ▁get _ bit _ length ▁( ▁nal ▁, ▁skip _ trailing _ zeros ▁) ▁; ▁ret ▁= ▁init _ get _ bits ▁( ▁& ▁nal ▁-> ▁gb ▁, ▁nal ▁-> ▁data ▁, ▁nal ▁-> ▁size _ bits ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁codec _ id ▁== ▁AV _ CODEC _ ID _ H EV C ▁) ▁ret ▁= ▁he vc _ parse _ n al _ header ▁( ▁nal ▁, ▁log ctx ▁) ▁; ▁else ▁ret ▁= ▁h 264_ parse _ n al _ header ▁( ▁nal ▁, ▁log ctx ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁|| ▁nal ▁-> ▁size ▁<= ▁0 ▁) ▁{ ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁log ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid NAL unit % d , sk ipping .\ n " ▁, ▁nal ▁-> ▁type ▁) ▁; ▁} ▁pkt ▁-> ▁nb _ n als ▁-- ▁; ▁} ▁buf ▁+= ▁consumed ▁; ▁length ▁-= ▁consumed ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁ff _ h 264_ execute _ ref _ pic _ mark ing ▁( ▁H 264 Context ▁* ▁h ▁, ▁MM CO ▁* ▁mm co ▁, ▁int ▁mm co _ count ▁) ▁{ ▁int ▁i ▁, ▁av _ uninit ▁( ▁j ▁) ▁; ▁int ▁current _ ref _ assigned ▁= ▁0 ▁, ▁err ▁= ▁0 ▁; ▁H 264 Picture ▁* ▁av _ uninit ▁( ▁pic ▁) ▁; ▁if ▁( ▁( ▁h ▁-> ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ MM CO ▁) ▁&& ▁mm co _ count ▁== ▁0 ▁) ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" nom m co here \ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁mm co _ count ▁; ▁i ▁++ ▁) ▁{ ▁int ▁av _ uninit ▁( ▁structure ▁) ▁, ▁av _ uninit ▁( ▁frame _ num ▁) ▁; ▁if ▁( ▁h ▁-> ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ MM CO ▁) ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" mm co :% d % d % d \ n " ▁, ▁h ▁-> ▁mm co ▁[ ▁i ▁] ▁. ▁opcode ▁, ▁h ▁-> ▁mm co ▁[ ▁i ▁] ▁. ▁short _ pic _ num ▁, ▁h ▁-> ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁) ▁; ▁if ▁( ▁mm co ▁[ ▁i ▁] ▁. ▁opcode ▁== ▁MM CO _ SHORT 2 UNUSED ▁|| ▁mm co ▁[ ▁i ▁] ▁. ▁opcode ▁== ▁MM CO _ SHORT 2 LONG ▁) ▁{ ▁frame _ num ▁= ▁pic _ num _ extract ▁( ▁h ▁, ▁mm co ▁[ ▁i ▁] ▁. ▁short _ pic _ num ▁, ▁& ▁structure ▁) ▁; ▁pic ▁= ▁find _ short ▁( ▁h ▁, ▁frame _ num ▁, ▁& ▁j ▁) ▁; ▁if ▁( ▁! ▁pic ▁) ▁{ ▁if ▁( ▁mm co ▁[ ▁i ▁] ▁. ▁opcode ▁!= ▁MM CO _ SHORT 2 LONG ▁|| ▁! ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁|| ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁-> ▁frame _ num ▁!= ▁frame _ num ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" mm co : unref short failure \ n " ▁) ▁; ▁err ▁= ▁AVERROR _ INVALIDDATA ▁; ▁} ▁continue ▁; ▁} ▁} ▁switch ▁( ▁mm co ▁[ ▁i ▁] ▁. ▁opcode ▁) ▁{ ▁case ▁MM CO _ SHORT 2 UNUSED ▁: ▁if ▁( ▁h ▁-> ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ MM CO ▁) ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" mm co : unref short % d count % d \ n " ▁, ▁h ▁-> ▁mm co ▁[ ▁i ▁] ▁. ▁short _ pic _ num ▁, ▁h ▁-> ▁short _ ref _ count ▁) ▁; ▁remove _ short ▁( ▁h ▁, ▁frame _ num ▁, ▁structure ▁ ^ ▁P ICT _ FRAME ▁) ▁; ▁break ▁; ▁case ▁MM CO _ SHORT 2 LONG ▁: ▁if ▁( ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁!= ▁pic ▁) ▁remove _ long ▁( ▁h ▁, ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁, ▁0 ▁) ▁; ▁remove _ short _ at _ index ▁( ▁h ▁, ▁j ▁) ▁; ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁= ▁pic ▁; ▁if ▁( ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁) ▁{ ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁-> ▁long _ ref ▁= ▁1 ▁; ▁h ▁-> ▁long _ ref _ count ▁++ ▁; ▁} ▁break ▁; ▁case ▁MM CO _ LONG 2 UNUSED ▁: ▁j ▁= ▁pic _ num _ extract ▁( ▁h ▁, ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁, ▁& ▁structure ▁) ▁; ▁pic ▁= ▁h ▁-> ▁long _ ref ▁[ ▁j ▁] ▁; ▁if ▁( ▁pic ▁) ▁{ ▁remove _ long ▁( ▁h ▁, ▁j ▁, ▁structure ▁ ^ ▁P ICT _ FRAME ▁) ▁; ▁} ▁else ▁if ▁( ▁h ▁-> ▁avctx ▁-> ▁debug ▁& ▁FF _ DEBUG _ MM CO ▁) ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" mm co : unref long failure \ n " ▁) ▁; ▁break ▁; ▁case ▁MM CO _ LONG ▁: ▁if ▁( ▁h ▁-> ▁short _ ref ▁[ ▁0 ▁] ▁== ▁h ▁-> ▁cur _ pic _ ptr ▁) ▁remove _ short _ at _ index ▁( ▁h ▁, ▁0 ▁) ▁; ▁if ▁( ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁long _ ref ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁h ▁-> ▁long _ ref ▁) ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁h ▁-> ▁long _ ref ▁[ ▁j ▁] ▁== ▁h ▁-> ▁cur _ pic _ ptr ▁) ▁remove _ long ▁( ▁h ▁, ▁j ▁, ▁0 ▁) ▁; ▁} ▁} ▁if ▁( ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁!= ▁h ▁-> ▁cur _ pic _ ptr ▁) ▁{ ▁remove _ long ▁( ▁h ▁, ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁, ▁0 ▁) ▁; ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁; ▁h ▁-> ▁long _ ref ▁[ ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁] ▁-> ▁long _ ref ▁= ▁1 ▁; ▁h ▁-> ▁long _ ref _ count ▁++ ▁; ▁} ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁reference ▁|= ▁h ▁-> ▁picture _ structure ▁; ▁current _ ref _ assigned ▁= ▁1 ▁; ▁break ▁; ▁case ▁MM CO _ SET _ MAX _ LONG ▁: ▁assert ▁( ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁<= ▁16 ▁) ▁; ▁for ▁( ▁j ▁= ▁mm co ▁[ ▁i ▁] ▁. ▁long _ arg ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁{ ▁remove _ long ▁( ▁h ▁, ▁j ▁, ▁0 ▁) ▁; ▁} ▁break ▁; ▁case ▁MM CO _ RESET ▁: ▁while ▁( ▁h ▁-> ▁short _ ref _ count ▁) ▁{ ▁remove _ short ▁( ▁h ▁, ▁h ▁-> ▁short _ ref ▁[ ▁0 ▁] ▁-> ▁frame _ num ▁, ▁0 ▁) ▁; ▁} ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁{ ▁remove _ long ▁( ▁h ▁, ▁j ▁, ▁0 ▁) ▁; ▁} ▁h ▁-> ▁frame _ num ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁frame _ num ▁= ▁0 ▁; ▁h ▁-> ▁mm co _ reset ▁= ▁1 ▁; ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁mm co _ reset ▁= ▁1 ▁; ▁break ▁; ▁default ▁: ▁assert ▁( ▁0 ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁current _ ref _ assigned ▁) ▁{ ▁if ▁( ▁h ▁-> ▁short _ ref _ count ▁&& ▁h ▁-> ▁short _ ref ▁[ ▁0 ▁] ▁== ▁h ▁-> ▁cur _ pic _ ptr ▁) ▁{ ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁reference ▁= ▁P ICT _ FRAME ▁; ▁} ▁else ▁if ▁( ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁long _ ref ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" illegal short term reference " ▁" assignment for second field " ▁" in comp lement ary field pair " ▁"( first field is long term )\ n " ▁) ▁; ▁err ▁= ▁AVERROR _ INVALIDDATA ▁; ▁} ▁else ▁{ ▁pic ▁= ▁remove _ short ▁( ▁h ▁, ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁frame _ num ▁, ▁0 ▁) ▁; ▁if ▁( ▁pic ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" illegal short term buffer state detected \ n " ▁) ▁; ▁err ▁= ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁h ▁-> ▁short _ ref _ count ▁) ▁memmove ▁( ▁& ▁h ▁-> ▁short _ ref ▁[ ▁1 ▁] ▁, ▁& ▁h ▁-> ▁short _ ref ▁[ ▁0 ▁] ▁, ▁h ▁-> ▁short _ ref _ count ▁* ▁sizeof ▁( ▁H 264 Picture ▁* ▁) ▁) ▁; ▁h ▁-> ▁short _ ref ▁[ ▁0 ▁] ▁= ▁h ▁-> ▁cur _ pic _ ptr ▁; ▁h ▁-> ▁short _ ref _ count ▁++ ▁; ▁h ▁-> ▁cur _ pic _ ptr ▁-> ▁reference ▁|= ▁h ▁-> ▁picture _ structure ▁; ▁} ▁} ▁if ▁( ▁h ▁-> ▁long _ ref _ count ▁+ ▁h ▁-> ▁short _ ref _ count ▁- ▁( ▁h ▁-> ▁short _ ref ▁[ ▁0 ▁] ▁== ▁h ▁-> ▁cur _ pic _ ptr ▁) ▁> ▁h ▁-> ▁sps ▁. ▁ref _ frame _ count ▁) ▁{ ▁av _ log ▁( ▁h ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" number of reference frames (% d + % d ) e xce eds max (% d ; prob ably " ▁" cor rupt input ), disc arding one \ n " ▁, ▁h ▁-> ▁long _ ref _ count ▁, ▁h ▁-> ▁short _ ref _ count ▁, ▁h ▁-> ▁sps ▁. ▁ref _ frame _ count ▁) ▁; ▁err ▁= ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁h ▁-> ▁long _ ref _ count ▁&& ▁! ▁h ▁-> ▁short _ ref _ count ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁++ ▁i ▁) ▁if ▁( ▁h ▁-> ▁long _ ref ▁[ ▁i ▁] ▁) ▁break ▁; ▁assert ▁( ▁i ▁< ▁16 ▁) ▁; ▁remove _ long ▁( ▁h ▁, ▁i ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁pic ▁= ▁h ▁-> ▁short _ ref ▁[ ▁h ▁-> ▁short _ ref _ count ▁- ▁1 ▁] ▁; ▁remove _ short ▁( ▁h ▁, ▁pic ▁-> ▁frame _ num ▁, ▁0 ▁) ▁; ▁} ▁} ▁print _ short _ term ▁( ▁h ▁) ▁; ▁print _ long _ term ▁( ▁h ▁) ▁; ▁return ▁( ▁h ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁? ▁err ▁: ▁0 ▁; ▁}	1
▁int ▁DH _ check ▁( ▁const ▁DH ▁* ▁dh ▁, ▁int ▁* ▁ret ▁) ▁{ ▁int ▁ok ▁= ▁0 ▁, ▁r ▁; ▁BN _ CTX ▁* ▁ctx ▁= ▁NULL ▁; ▁BIGNUM ▁* ▁t 1 ▁= ▁NULL ▁, ▁* ▁t 2 ▁= ▁NULL ▁; ▁if ▁( ▁! ▁DH _ check _ params ▁( ▁dh ▁, ▁ret ▁) ▁) ▁return ▁0 ▁; ▁ctx ▁= ▁BN _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁t 1 ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁t 2 ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁t 2 ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁dh ▁-> ▁q ▁) ▁{ ▁if ▁( ▁BN _ cmp ▁( ▁dh ▁-> ▁g ▁, ▁BN _ value _ one ▁( ▁) ▁) ▁<= ▁0 ▁) ▁* ▁ret ▁|= ▁DH _ NOT _ SU IT ABLE _ GENERATOR ▁; ▁else ▁if ▁( ▁BN _ cmp ▁( ▁dh ▁-> ▁g ▁, ▁dh ▁-> ▁p ▁) ▁>= ▁0 ▁) ▁* ▁ret ▁|= ▁DH _ NOT _ SU IT ABLE _ GENERATOR ▁; ▁else ▁{ ▁if ▁( ▁! ▁BN _ mod _ exp ▁( ▁t 1 ▁, ▁dh ▁-> ▁g ▁, ▁dh ▁-> ▁q ▁, ▁dh ▁-> ▁p ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ is _ one ▁( ▁t 1 ▁) ▁) ▁* ▁ret ▁|= ▁DH _ NOT _ SU IT ABLE _ GENERATOR ▁; ▁} ▁r ▁= ▁BN _ is _ prime _ ex ▁( ▁dh ▁-> ▁q ▁, ▁DH _ NUMBER _ ITERATIONS _ FOR _ PRIME ▁, ▁ctx ▁, ▁NULL ▁) ▁; ▁if ▁( ▁r ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁r ▁) ▁* ▁ret ▁|= ▁DH _ CHECK _ Q _ NOT _ PRIME ▁; ▁if ▁( ▁! ▁BN _ div ▁( ▁t 1 ▁, ▁t 2 ▁, ▁dh ▁-> ▁p ▁, ▁dh ▁-> ▁q ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ is _ one ▁( ▁t 2 ▁) ▁) ▁* ▁ret ▁|= ▁DH _ CHECK _ INVALID _ Q _ VALUE ▁; ▁if ▁( ▁dh ▁-> ▁j ▁&& ▁BN _ cmp ▁( ▁dh ▁-> ▁j ▁, ▁t 1 ▁) ▁) ▁* ▁ret ▁|= ▁DH _ CHECK _ INVALID _ J _ VALUE ▁; ▁} ▁r ▁= ▁BN _ is _ prime _ ex ▁( ▁dh ▁-> ▁p ▁, ▁DH _ NUMBER _ ITERATIONS _ FOR _ PRIME ▁, ▁ctx ▁, ▁NULL ▁) ▁; ▁if ▁( ▁r ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁r ▁) ▁* ▁ret ▁|= ▁DH _ CHECK _ P _ NOT _ PRIME ▁; ▁else ▁if ▁( ▁! ▁dh ▁-> ▁q ▁) ▁{ ▁if ▁( ▁! ▁BN _ rshift 1 ▁( ▁t 1 ▁, ▁dh ▁-> ▁p ▁) ▁) ▁goto ▁err ▁; ▁r ▁= ▁BN _ is _ prime _ ex ▁( ▁t 1 ▁, ▁DH _ NUMBER _ ITERATIONS _ FOR _ PRIME ▁, ▁ctx ▁, ▁NULL ▁) ▁; ▁if ▁( ▁r ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁r ▁) ▁* ▁ret ▁|= ▁DH _ CHECK _ P _ NOT _ SAFE _ PRIME ▁; ▁} ▁ok ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁BN _ CTX _ free ▁( ▁ctx ▁) ▁; ▁return ▁ok ▁; ▁}	0
▁int ▁BIO _ printf ▁( ▁BIO ▁* ▁bio ▁, ▁... ▁) ▁{ ▁va _ list ▁args ▁; ▁char ▁* ▁format ▁; ▁int ▁ret ▁; ▁size _ t ▁retlen ▁; ▁# ifdef ▁USE _ ALLOC ATING _ PRINT ▁char ▁* ▁huge buf ▁; ▁# else ▁MS _ STATIC ▁char ▁huge buf ▁[ ▁1024 ▁* ▁2 ▁] ▁; ▁# endif ▁va _ start ▁( ▁args ▁, ▁bio ▁) ▁; ▁format ▁= ▁va _ arg ▁( ▁args ▁, ▁char ▁* ▁) ▁; ▁# ifndef ▁USE _ ALLOC ATING _ PRINT ▁huge buf ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁d opr ▁( ▁huge buf ▁, ▁sizeof ▁( ▁huge buf ▁) ▁, ▁& ▁retlen ▁, ▁format ▁, ▁args ▁) ▁; ▁# else ▁huge buf ▁= ▁NULL ▁; ▁CRYPTO _ push _ info ▁( ▁" do apr ()" ▁) ▁; ▁do apr ▁( ▁& ▁huge buf ▁, ▁& ▁retlen ▁, ▁format ▁, ▁args ▁) ▁; ▁if ▁( ▁huge buf ▁) ▁{ ▁# endif ▁ret = BIO _ write ( bio , huge buf , ( int ) ret len ); ▁# ifdef ▁USE _ ALLOC ATING _ PRINT ▁Free ▁( ▁huge buf ▁) ▁; ▁} ▁CRYPTO _ pop _ info ▁( ▁) ▁; ▁# endif ▁va _ end ▁( ▁args ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁int ▁decode _ he xt ile ▁( ▁Vm nc Context ▁* ▁c ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁Get Byte Context ▁* ▁gb ▁, ▁int ▁w ▁, ▁int ▁h ▁, ▁int ▁stride ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁; ▁int ▁bg ▁= ▁0 ▁, ▁fg ▁= ▁0 ▁, ▁rects ▁, ▁color ▁, ▁flags ▁, ▁xy ▁, ▁wh ▁; ▁const ▁int ▁bpp ▁= ▁c ▁-> ▁bpp 2 ▁; ▁uint 8_ t ▁* ▁dst 2 ▁; ▁int ▁bw ▁= ▁16 ▁, ▁bh ▁= ▁16 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁h ▁; ▁j ▁+= ▁16 ▁) ▁{ ▁dst 2 ▁= ▁dst ▁; ▁bw ▁= ▁16 ▁; ▁if ▁( ▁j ▁+ ▁16 ▁> ▁h ▁) ▁bh ▁= ▁h ▁- ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁w ▁; ▁i ▁+= ▁16 ▁, ▁dst 2 ▁+= ▁16 ▁* ▁bpp ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁gb ▁) ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Pre m ature end of data !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁i ▁+ ▁16 ▁> ▁w ▁) ▁bw ▁= ▁w ▁- ▁i ▁; ▁flags ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁if ▁( ▁flags ▁& ▁HT _ RAW ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁gb ▁) ▁< ▁bw ▁* ▁bh ▁* ▁bpp ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Pre m ature end of data !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁paint _ raw ▁( ▁dst 2 ▁, ▁bw ▁, ▁bh ▁, ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁, ▁stride ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁flags ▁& ▁HT _ BK G ▁) ▁bg ▁= ▁vm nc _ get _ pixel ▁( ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁) ▁; ▁if ▁( ▁flags ▁& ▁HT _ FG ▁) ▁fg ▁= ▁vm nc _ get _ pixel ▁( ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁) ▁; ▁rects ▁= ▁0 ▁; ▁if ▁( ▁flags ▁& ▁HT _ SUB ▁) ▁rects ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁color ▁= ▁! ▁! ▁( ▁flags ▁& ▁HT _ CLR ▁) ▁; ▁paint _ rect ▁( ▁dst 2 ▁, ▁0 ▁, ▁0 ▁, ▁bw ▁, ▁bh ▁, ▁bg ▁, ▁bpp ▁, ▁stride ▁) ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁gb ▁) ▁< ▁rects ▁* ▁( ▁color ▁* ▁bpp ▁+ ▁2 ▁) ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Pre m ature end of data !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁rects ▁; ▁k ▁++ ▁) ▁{ ▁int ▁rect _ x ▁, ▁rect _ y ▁, ▁rect _ w ▁, ▁rect _ h ▁; ▁if ▁( ▁color ▁) ▁fg ▁= ▁vm nc _ get _ pixel ▁( ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁) ▁; ▁xy ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁wh ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁rect _ x ▁= ▁xy ▁>> ▁4 ▁; ▁rect _ y ▁= ▁xy ▁& ▁0 xF ▁; ▁rect _ w ▁= ▁( ▁wh ▁>> ▁4 ▁) ▁+ ▁1 ▁; ▁rect _ h ▁= ▁( ▁wh ▁& ▁0 xF ▁) ▁+ ▁1 ▁; ▁if ▁( ▁rect _ x ▁+ ▁rect _ w ▁> ▁bw ▁|| ▁rect _ y ▁+ ▁rect _ h ▁> ▁bh ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid sub rect \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁paint _ rect ▁( ▁dst 2 ▁, ▁rect _ x ▁, ▁rect _ y ▁, ▁rect _ w ▁, ▁rect _ h ▁, ▁fg ▁, ▁bpp ▁, ▁stride ▁) ▁; ▁} ▁} ▁} ▁dst ▁+= ▁stride ▁* ▁16 ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁get _ password ▁( ▁struct ▁passwd _ ctx ▁* ▁ctx ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁passwd _ src ▁== ▁PW _ STD IN ▁) ▁{ ▁char ▁* ▁buf ▁= ▁ctx ▁-> ▁out ▁; ▁apr _ file _ t ▁* ▁file _ stdin ▁; ▁apr _ size _ t ▁nread ▁; ▁if ▁( ▁apr _ file _ open _ stdin ▁( ▁& ▁file _ stdin ▁, ▁ctx ▁-> ▁pool ▁) ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ctx ▁-> ▁errstr ▁= ▁" Unable t oread from stdin ." ▁; ▁return ▁ERR _ GENERAL ▁; ▁} ▁if ▁( ▁apr _ file _ read _ full ▁( ▁file _ stdin ▁, ▁buf ▁, ▁ctx ▁-> ▁out _ len ▁- ▁1 ▁, ▁& ▁nread ▁) ▁!= ▁APR _ EOF ▁|| ▁nread ▁== ▁ctx ▁-> ▁out _ len ▁- ▁1 ▁) ▁{ ▁goto ▁err _ too _ long ▁; ▁} ▁buf ▁[ ▁nread ▁] ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁nread ▁>= ▁1 ▁&& ▁buf ▁[ ▁nread ▁- ▁1 ▁] ▁== ▁' ▁\ n ▁' ▁) ▁{ ▁buf ▁[ ▁nread ▁- ▁1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁nread ▁>= ▁2 ▁&& ▁buf ▁[ ▁nread ▁- ▁2 ▁] ▁== ▁' ▁\ r ▁' ▁) ▁buf ▁[ ▁nread ▁- ▁2 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁apr _ file _ close ▁( ▁file _ stdin ▁) ▁; ▁} ▁else ▁{ ▁char ▁buf ▁[ ▁MAX _ STRING _ LEN ▁+ ▁1 ▁] ▁; ▁apr _ size _ t ▁bufsize ▁= ▁sizeof ▁( ▁buf ▁) ▁; ▁if ▁( ▁apr _ password _ get ▁( ▁" New password :" ▁, ▁ctx ▁-> ▁out ▁, ▁& ▁ctx ▁-> ▁out _ len ▁) ▁!= ▁0 ▁) ▁goto ▁err _ too _ long ▁; ▁apr _ password _ get ▁( ▁" Re - ty pen ew password :" ▁, ▁buf ▁, ▁& ▁bufsize ▁) ▁; ▁if ▁( ▁strcmp ▁( ▁ctx ▁-> ▁out ▁, ▁buf ▁) ▁!= ▁0 ▁) ▁{ ▁ctx ▁-> ▁errstr ▁= ▁" password verification error " ▁; ▁memset ▁( ▁ctx ▁-> ▁out ▁, ▁' ▁\0 ▁' ▁, ▁ctx ▁-> ▁out _ len ▁) ▁; ▁memset ▁( ▁buf ▁, ▁' ▁\0 ▁' ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁return ▁ERR _ PWM IS MATCH ▁; ▁} ▁memset ▁( ▁buf ▁, ▁' ▁\0 ▁' ▁, ▁sizeof ▁( ▁buf ▁) ▁) ▁; ▁} ▁return ▁0 ▁; ▁err _ too _ long ▁: ▁ctx ▁-> ▁errstr ▁= ▁apr _ ps printf ▁( ▁ctx ▁-> ▁pool ▁, ▁" password tool ong ( > %" ▁APR _ SIZE _ T _ FMT ▁")" ▁, ▁ctx ▁-> ▁out _ len ▁- ▁1 ▁) ▁; ▁return ▁ERR _ OVERFLOW ▁; ▁}	1
▁static ▁int ▁v 4 10_ encode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁void ▁* ▁data ▁) ▁{ ▁AVFrame ▁* ▁pic ▁= ▁data ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁buf ▁; ▁uint 16_ t ▁* ▁y ▁, ▁* ▁u ▁, ▁* ▁v ▁; ▁uint 32_ t ▁val ▁; ▁int ▁i ▁, ▁j ▁; ▁int ▁output _ size ▁= ▁0 ▁; ▁if ▁( ▁buf _ size ▁< ▁avctx ▁-> ▁width ▁* ▁avctx ▁-> ▁height ▁* ▁4 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Out buffer ist oo small .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁avctx ▁-> ▁coded _ frame ▁-> ▁reference ▁= ▁0 ▁; ▁avctx ▁-> ▁coded _ frame ▁-> ▁key _ frame ▁= ▁1 ▁; ▁avctx ▁-> ▁coded _ frame ▁-> ▁pict _ type ▁= ▁FF _ I _ TYPE ▁; ▁y ▁= ▁( ▁uint 16_ t ▁* ▁) ▁pic ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁u ▁= ▁( ▁uint 16_ t ▁* ▁) ▁pic ▁-> ▁data ▁[ ▁1 ▁] ▁; ▁v ▁= ▁( ▁uint 16_ t ▁* ▁) ▁pic ▁-> ▁data ▁[ ▁2 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁height ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁avctx ▁-> ▁width ▁; ▁j ▁++ ▁) ▁{ ▁val ▁= ▁u ▁[ ▁j ▁] ▁<< ▁2 ▁; ▁val ▁|= ▁y ▁[ ▁j ▁] ▁<< ▁12 ▁; ▁val ▁|= ▁v ▁[ ▁j ▁] ▁<< ▁22 ▁; ▁AV _ WL 32 ▁( ▁dst ▁, ▁val ▁) ▁; ▁dst ▁+= ▁4 ▁; ▁output _ size ▁+= ▁4 ▁; ▁} ▁y ▁+= ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁>> ▁1 ▁; ▁u ▁+= ▁pic ▁-> ▁linesize ▁[ ▁1 ▁] ▁>> ▁1 ▁; ▁v ▁+= ▁pic ▁-> ▁linesize ▁[ ▁2 ▁] ▁>> ▁1 ▁; ▁} ▁return ▁output _ size ▁; ▁}	0
▁int ▁ff _ inter leave _ add _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁, ▁int ▁( ▁* ▁compare ▁) ▁( ▁AVFormatContext ▁* ▁, ▁AVPacket ▁* ▁, ▁AVPacket ▁* ▁) ▁) ▁{ ▁int ▁ret ▁; ▁AVPacket List ▁* ▁* ▁next _ point ▁, ▁* ▁this _ pk tl ▁; ▁this _ pk tl ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVPacket List ▁) ▁) ▁; ▁if ▁( ▁! ▁this _ pk tl ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁this _ pk tl ▁-> ▁pkt ▁= ▁* ▁pkt ▁; ▁# if ▁FF _ API _ DES TRUCT _ PACKET ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁pkt ▁-> ▁destruct ▁= ▁NULL ▁; ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁# endif ▁pkt ▁-> ▁buf ▁= ▁NULL ▁; ▁if ▁( ▁( ▁ret ▁= ▁av _ dup _ packet ▁( ▁& ▁this _ pk tl ▁-> ▁pkt ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ free ▁( ▁this _ pk tl ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁) ▁{ ▁next _ point ▁= ▁& ▁( ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁-> ▁next ▁) ▁; ▁} ▁else ▁next _ point ▁= ▁& ▁s ▁-> ▁packet _ buffer ▁; ▁if ▁( ▁* ▁next _ point ▁) ▁{ ▁if ▁( ▁compare ▁( ▁s ▁, ▁& ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁{ ▁while ▁( ▁! ▁compare ▁( ▁s ▁, ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁pkt ▁, ▁pkt ▁) ▁) ▁next _ point ▁= ▁& ▁( ▁* ▁next _ point ▁) ▁-> ▁next ▁; ▁goto ▁next _ non _ null ▁; ▁} ▁else ▁{ ▁next _ point ▁= ▁& ▁( ▁s ▁-> ▁packet _ buffer _ end ▁-> ▁next ▁) ▁; ▁} ▁} ▁assert ▁( ▁! ▁* ▁next _ point ▁) ▁; ▁s ▁-> ▁packet _ buffer _ end ▁= ▁this _ pk tl ▁; ▁next _ non _ null ▁: ▁this _ pk tl ▁-> ▁next ▁= ▁* ▁next _ point ▁; ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁last _ in _ packet _ buffer ▁= ▁* ▁next _ point ▁= ▁this _ pk tl ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁EVP _ MD _ CTX _ cleanup ▁( ▁EVP _ MD _ CTX ▁* ▁ctx ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁digest ▁&& ▁ctx ▁-> ▁digest ▁-> ▁cleanup ▁&& ▁! ▁EVP _ MD _ CTX _ test _ flags ▁( ▁ctx ▁, ▁EVP _ MD _ CTX _ FLAG _ CLEAN ED ▁) ▁) ▁ctx ▁-> ▁digest ▁-> ▁cleanup ▁( ▁ctx ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁digest ▁&& ▁ctx ▁-> ▁digest ▁-> ▁ctx _ size ▁&& ▁ctx ▁-> ▁md _ data ▁&& ▁! ▁EVP _ MD _ CTX _ test _ flags ▁( ▁ctx ▁, ▁EVP _ MD _ CTX _ FLAG _ REUSE ▁) ▁) ▁{ ▁OPENSSL _ cleanse ▁( ▁ctx ▁-> ▁md _ data ▁, ▁ctx ▁-> ▁digest ▁-> ▁ctx _ size ▁) ▁; ▁OPENSSL _ free ▁( ▁ctx ▁-> ▁md _ data ▁) ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁pctx ▁) ▁EVP _ PKEY _ CTX _ free ▁( ▁ctx ▁-> ▁pctx ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁if ▁( ▁ctx ▁-> ▁engine ▁) ▁ENGINE _ finish ▁( ▁ctx ▁-> ▁engine ▁) ▁; ▁# endif ▁memset ▁( ▁ctx ▁, ▁' ▁\0 ▁' ▁, ▁sizeof ▁* ▁ctx ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁asn 1_ cb ▁( ▁const ▁char ▁* ▁elem ▁, ▁int ▁len ▁, ▁void ▁* ▁bit str ▁) ▁{ ▁tag _ exp _ arg ▁* ▁arg ▁= ▁bit str ▁; ▁int ▁i ▁; ▁int ▁ut ype ▁; ▁int ▁vlen ▁= ▁0 ▁; ▁const ▁char ▁* ▁p ▁, ▁* ▁v start ▁= ▁NULL ▁; ▁int ▁tmp _ tag ▁, ▁tmp _ class ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁p ▁= ▁elem ▁; ▁i ▁< ▁len ▁; ▁p ▁++ ▁, ▁i ▁++ ▁) ▁{ ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁) ▁{ ▁v start ▁= ▁p ▁+ ▁1 ▁; ▁vlen ▁= ▁len ▁- ▁( ▁v start ▁- ▁elem ▁) ▁; ▁len ▁= ▁p ▁- ▁elem ▁; ▁break ▁; ▁} ▁} ▁ut ype ▁= ▁asn 1_ str 2 tag ▁( ▁elem ▁, ▁len ▁) ▁; ▁if ▁( ▁ut ype ▁== ▁-1 ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ UNKNOWN _ TAG ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁2 ▁, ▁" tag =" ▁, ▁elem ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁! ▁( ▁ut ype ▁& ▁ASN 1_ GEN _ FLAG ▁) ▁) ▁{ ▁arg ▁-> ▁ut ype ▁= ▁ut ype ▁; ▁arg ▁-> ▁str ▁= ▁v start ▁; ▁if ▁( ▁! ▁v start ▁&& ▁elem ▁[ ▁len ▁] ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ MISSING _ VALUE ▁) ▁; ▁return ▁-1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁switch ▁( ▁ut ype ▁) ▁{ ▁case ▁ASN 1_ GEN _ FLAG _ IMP ▁: ▁if ▁( ▁arg ▁-> ▁imp _ tag ▁!= ▁-1 ▁) ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ ILLEGAL _ NEST ED _ TAG GING ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁! ▁parse _ tag ging ▁( ▁v start ▁, ▁vlen ▁, ▁& ▁arg ▁-> ▁imp _ tag ▁, ▁& ▁arg ▁-> ▁imp _ class ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ EXP ▁: ▁if ▁( ▁! ▁parse _ tag ging ▁( ▁v start ▁, ▁vlen ▁, ▁& ▁tmp _ tag ▁, ▁& ▁tmp _ class ▁) ▁) ▁return ▁-1 ▁; ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁tmp _ tag ▁, ▁tmp _ class ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ SEQ WRAP ▁: ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁V _ ASN 1_ SEQUENCE ▁, ▁V _ ASN 1_ UNIVERSAL ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ BIT WRAP ▁: ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁V _ ASN 1_ BIT _ STRING ▁, ▁V _ ASN 1_ UNIVERSAL ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ O CT WRAP ▁: ▁if ▁( ▁! ▁append _ exp ▁( ▁arg ▁, ▁V _ ASN 1_ OCTET _ STRING ▁, ▁V _ ASN 1_ UNIVERSAL ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁) ▁) ▁return ▁-1 ▁; ▁break ▁; ▁case ▁ASN 1_ GEN _ FLAG _ FORMAT ▁: ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" ASCII " ▁, ▁5 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ ASCII ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" UTF 8" ▁, ▁4 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ UTF 8 ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" HEX " ▁, ▁3 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ HEX ▁; ▁else ▁if ▁( ▁! ▁strncmp ▁( ▁v start ▁, ▁" BIT LIST " ▁, ▁3 ▁) ▁) ▁arg ▁-> ▁format ▁= ▁ASN 1_ GEN _ FORMAT _ BIT LIST ▁; ▁else ▁{ ▁ASN 1 err ▁( ▁ASN 1_ F _ ASN 1_ CB ▁, ▁ASN 1_ R _ UNK OWN _ FORMAT ▁) ▁; ▁return ▁-1 ▁; ▁} ▁break ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁h ls _ append _ segment ▁( ▁struct ▁AVFormatContext ▁* ▁s ▁, ▁H LS Context ▁* ▁h ls ▁, ▁double ▁duration ▁, ▁int 64_ t ▁pos ▁, ▁int 64_ t ▁size ▁) ▁{ ▁H LS Segment ▁* ▁en ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁* ▁en ▁) ▁) ▁; ▁const ▁char ▁* ▁filename ▁; ▁int ▁ret ▁; ▁if ▁( ▁! ▁en ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁( ▁h ls ▁-> ▁flags ▁& ▁( ▁H LS _ SECOND _ LEVEL _ SEGMENT _ SIZE ▁| ▁H LS _ SECOND _ LEVEL _ SEGMENT _ DURATION ▁) ▁) ▁&& ▁strlen ▁( ▁h ls ▁-> ▁current _ segment _ final _ filename _ fmt ▁) ▁) ▁{ ▁char ▁* ▁old _ filename ▁= ▁av _ strdup ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁) ▁; ▁av _ strlcpy ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁, ▁h ls ▁-> ▁current _ segment _ final _ filename _ fmt ▁, ▁sizeof ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁) ▁) ▁; ▁if ▁( ▁h ls ▁-> ▁flags ▁& ▁H LS _ SECOND _ LEVEL _ SEGMENT _ SIZE ▁) ▁{ ▁char ▁* ▁filename ▁= ▁av _ strdup ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁) ▁; ▁if ▁( ▁! ▁filename ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁replace _ int _ data _ in _ filename ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁, ▁sizeof ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁) ▁, ▁filename ▁, ▁' ▁' ▁, ▁pos ▁+ ▁size ▁) ▁< ▁1 ▁) ▁{ ▁av _ log ▁( ▁h ls ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid second level segment fil en am et e mplate ' % s ', " ▁" you can try t ore move second _ level _ segment _ size flag \ n " ▁, ▁filename ▁) ▁; ▁av _ free ▁( ▁filename ▁) ▁; ▁av _ free ▁( ▁old _ filename ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁av _ free ▁( ▁filename ▁) ▁; ▁} ▁if ▁( ▁h ls ▁-> ▁flags ▁& ▁H LS _ SECOND _ LEVEL _ SEGMENT _ DURATION ▁) ▁{ ▁char ▁* ▁filename ▁= ▁av _ strdup ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁) ▁; ▁if ▁( ▁! ▁filename ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁replace _ int _ data _ in _ filename ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁, ▁sizeof ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁) ▁, ▁filename ▁, ▁' ▁' ▁, ▁( ▁int 64_ t ▁) ▁round ▁( ▁1000000 ▁* ▁duration ▁) ▁) ▁< ▁1 ▁) ▁{ ▁av _ log ▁( ▁h ls ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid second level segment fil en am et e mplate ' % s ', " ▁" you can try t ore move second _ level _ segment _ time flag \ n " ▁, ▁filename ▁) ▁; ▁av _ free ▁( ▁filename ▁) ▁; ▁av _ free ▁( ▁old _ filename ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁av _ free ▁( ▁filename ▁) ▁; ▁} ▁ff _ rename ▁( ▁old _ filename ▁, ▁h ls ▁-> ▁av f ▁-> ▁filename ▁, ▁h ls ▁) ▁; ▁av _ free ▁( ▁old _ filename ▁) ▁; ▁} ▁filename ▁= ▁av _ bas ename ▁( ▁h ls ▁-> ▁av f ▁-> ▁filename ▁) ▁; ▁if ▁( ▁h ls ▁-> ▁use _ local time _ mkdir ▁) ▁{ ▁filename ▁= ▁h ls ▁-> ▁av f ▁-> ▁filename ▁; ▁} ▁if ▁( ▁find _ segment _ by _ filename ▁( ▁h ls ▁-> ▁segments ▁, ▁filename ▁) ▁|| ▁find _ segment _ by _ filename ▁( ▁h ls ▁-> ▁old _ segments ▁, ▁filename ▁) ▁) ▁{ ▁av _ log ▁( ▁h ls ▁, ▁AV _ LOG _ WARNING ▁, ▁" D uplicated segment filename detected :% s \ n " ▁, ▁filename ▁) ▁; ▁} ▁av _ strlcpy ▁( ▁en ▁-> ▁filename ▁, ▁filename ▁, ▁sizeof ▁( ▁en ▁-> ▁filename ▁) ▁) ▁; ▁if ▁( ▁h ls ▁-> ▁has _ sub title ▁) ▁av _ strlcpy ▁( ▁en ▁-> ▁sub _ filename ▁, ▁av _ bas ename ▁( ▁h ls ▁-> ▁v tt _ av f ▁-> ▁filename ▁) ▁, ▁sizeof ▁( ▁en ▁-> ▁sub _ filename ▁) ▁) ▁; ▁else ▁en ▁-> ▁sub _ filename ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁en ▁-> ▁duration ▁= ▁duration ▁; ▁en ▁-> ▁pos ▁= ▁pos ▁; ▁en ▁-> ▁size ▁= ▁size ▁; ▁en ▁-> ▁next ▁= ▁NULL ▁; ▁en ▁-> ▁dis cont ▁= ▁0 ▁; ▁if ▁( ▁h ls ▁-> ▁dis contin uity ▁) ▁{ ▁en ▁-> ▁dis cont ▁= ▁1 ▁; ▁h ls ▁-> ▁dis contin uity ▁= ▁0 ▁; ▁} ▁if ▁( ▁h ls ▁-> ▁key _ info _ file ▁) ▁{ ▁av _ strlcpy ▁( ▁en ▁-> ▁key _ uri ▁, ▁h ls ▁-> ▁key _ uri ▁, ▁sizeof ▁( ▁en ▁-> ▁key _ uri ▁) ▁) ▁; ▁av _ strlcpy ▁( ▁en ▁-> ▁iv _ string ▁, ▁h ls ▁-> ▁iv _ string ▁, ▁sizeof ▁( ▁en ▁-> ▁iv _ string ▁) ▁) ▁; ▁} ▁if ▁( ▁! ▁h ls ▁-> ▁segments ▁) ▁h ls ▁-> ▁segments ▁= ▁en ▁; ▁else ▁h ls ▁-> ▁last _ segment ▁-> ▁next ▁= ▁en ▁; ▁h ls ▁-> ▁last _ segment ▁= ▁en ▁; ▁if ▁( ▁h ls ▁-> ▁pl _ type ▁!= ▁PLAY LIST _ TYPE _ NONE ▁) ▁h ls ▁-> ▁max _ nb _ segments ▁= ▁0 ▁; ▁if ▁( ▁h ls ▁-> ▁max _ nb _ segments ▁&& ▁h ls ▁-> ▁nb _ entries ▁>= ▁h ls ▁-> ▁max _ nb _ segments ▁) ▁{ ▁en ▁= ▁h ls ▁-> ▁segments ▁; ▁h ls ▁-> ▁initial _ prog _ date _ time ▁+= ▁en ▁-> ▁duration ▁; ▁h ls ▁-> ▁segments ▁= ▁en ▁-> ▁next ▁; ▁if ▁( ▁en ▁&& ▁h ls ▁-> ▁flags ▁& ▁H LS _ DELETE _ SEGMENT S ▁&& ▁! ▁( ▁h ls ▁-> ▁flags ▁& ▁H LS _ SINGLE _ FILE ▁|| ▁h ls ▁-> ▁wrap ▁) ▁) ▁{ ▁en ▁-> ▁next ▁= ▁h ls ▁-> ▁old _ segments ▁; ▁h ls ▁-> ▁old _ segments ▁= ▁en ▁; ▁if ▁( ▁( ▁ret ▁= ▁h ls _ delete _ old _ segments ▁( ▁h ls ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁else ▁av _ free ▁( ▁en ▁) ▁; ▁} ▁else ▁h ls ▁-> ▁nb _ entries ▁++ ▁; ▁if ▁( ▁h ls ▁-> ▁max _ seg _ size ▁> ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁h ls ▁-> ▁sequence ▁++ ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁util _ verbose ▁( ▁ENGINE ▁* ▁e ▁, ▁int ▁verbose ▁, ▁BIO ▁* ▁bio _ out ▁, ▁const ▁char ▁* ▁indent ▁) ▁{ ▁static ▁const ▁int ▁line _ wrap ▁= ▁78 ▁; ▁int ▁num ▁; ▁char ▁* ▁name ▁= ▁NULL ▁; ▁char ▁* ▁desc ▁= ▁NULL ▁; ▁int ▁flags ▁; ▁int ▁xpos ▁= ▁0 ▁; ▁STACK ▁* ▁cmds ▁= ▁sk _ new _ null ▁( ▁) ▁; ▁if ▁( ▁! ▁cmds ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ HAS _ CTRL _ FUNCTION ▁, ▁0 ▁, ▁NULL ▁, ▁NULL ▁) ▁|| ▁( ▁( ▁num ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ FIRST _ CMD _ TYPE ▁, ▁0 ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁<= ▁0 ▁) ▁) ▁{ ▁# if ▁0 ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% s < noc ont rol commands >\ n " ▁, ▁indent ▁) ▁; ▁# endif ▁return ▁1 ▁; ▁} ▁do ▁{ ▁int ▁len ▁; ▁if ▁( ▁( ▁len ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ NAME _ LEN _ FROM _ CMD ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁name ▁= ▁OPENSSL _ malloc ▁( ▁len ▁+ ▁1 ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ NAME _ FROM _ CMD ▁, ▁num ▁, ▁name ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁len ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ DESC _ LEN _ FROM _ CMD ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁len ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁desc ▁= ▁OPENSSL _ malloc ▁( ▁len ▁+ ▁1 ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ DESC _ FROM _ CMD ▁, ▁num ▁, ▁desc ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁flags ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ CMD _ FLAGS ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁xpos ▁== ▁0 ▁) ▁xpos ▁= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁indent ▁) ▁; ▁else ▁xpos ▁+= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"," ▁) ▁; ▁if ▁( ▁verbose ▁== ▁1 ▁) ▁{ ▁if ▁( ▁( ▁xpos ▁> ▁( ▁int ▁) ▁strlen ▁( ▁indent ▁) ▁) ▁&& ▁( ▁xpos ▁+ ▁( ▁int ▁) ▁strlen ▁( ▁name ▁) ▁> ▁line _ wrap ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"\ n " ▁) ▁; ▁xpos ▁= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁indent ▁) ▁; ▁} ▁xpos ▁+= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% s " ▁, ▁name ▁) ▁; ▁} ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% s :% s \ n " ▁, ▁name ▁, ▁( ▁desc ▁== ▁NULL ▁) ▁? ▁"< node scription >" ▁: ▁desc ▁) ▁; ▁if ▁( ▁( ▁verbose ▁== ▁3 ▁) ▁&& ▁! ▁util _ flags ▁( ▁bio _ out ▁, ▁flags ▁, ▁indent ▁) ▁) ▁goto ▁err ▁; ▁xpos ▁= ▁0 ▁; ▁} ▁OPENSSL _ free ▁( ▁name ▁) ▁; ▁name ▁= ▁NULL ▁; ▁if ▁( ▁desc ▁) ▁{ ▁OPENSSL _ free ▁( ▁desc ▁) ▁; ▁desc ▁= ▁NULL ▁; ▁} ▁num ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ NEXT _ CMD _ TYPE ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁} ▁while ▁( ▁num ▁> ▁0 ▁) ▁; ▁if ▁( ▁xpos ▁> ▁0 ▁) ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"\ n " ▁) ▁; ▁return ▁1 ▁; ▁err ▁: ▁if ▁( ▁cmds ▁) ▁sk _ pop _ free ▁( ▁cmds ▁, ▁identity ▁) ▁; ▁if ▁( ▁name ▁) ▁OPENSSL _ free ▁( ▁name ▁) ▁; ▁if ▁( ▁desc ▁) ▁OPENSSL _ free ▁( ▁desc ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁ssl _ cipher _ list _ to _ bytes ▁( ▁SSL ▁* ▁s ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁sk ▁, ▁unsigned ▁char ▁* ▁p ▁, ▁int ▁( ▁* ▁put _ cb ▁) ▁( ▁const ▁SSL _ CIPHER ▁* ▁, ▁unsigned ▁char ▁* ▁) ▁) ▁{ ▁int ▁i ▁, ▁j ▁= ▁0 ▁; ▁SSL _ CIPHER ▁* ▁c ▁; ▁C ERT ▁* ▁ct ▁= ▁s ▁-> ▁cert ▁; ▁unsigned ▁char ▁* ▁q ▁; ▁int ▁no _ sc sv ▁= ▁s ▁-> ▁re neg ot iate ▁; ▁ssl _ set _ client _ disabled ▁( ▁s ▁) ▁; ▁if ▁( ▁sk ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁q ▁= ▁p ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁sk ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁sk ▁, ▁i ▁) ▁; ▁if ▁( ▁c ▁-> ▁algorithm _ ssl ▁& ▁ct ▁-> ▁mask _ ssl ▁|| ▁c ▁-> ▁algorithm _ m key ▁& ▁ct ▁-> ▁mask _ k ▁|| ▁c ▁-> ▁algorithm _ auth ▁& ▁ct ▁-> ▁mask _ a ▁) ▁continue ▁; ▁# ifdef ▁OPENSSL _ SSL _ DEBUG _ BROKEN _ PROTOCOL ▁if ▁( ▁c ▁-> ▁id ▁== ▁SSL 3_ CK _ SC SV ▁) ▁{ ▁if ▁( ▁no _ sc sv ▁) ▁continue ▁; ▁else ▁no _ sc sv ▁= ▁1 ▁; ▁} ▁# endif ▁j ▁= ▁put _ cb ▁? ▁put _ cb ▁( ▁c ▁, ▁p ▁) ▁: ▁ssl _ put _ cipher _ by _ char ▁( ▁s ▁, ▁c ▁, ▁p ▁) ▁; ▁p ▁+= ▁j ▁; ▁} ▁if ▁( ▁p ▁!= ▁q ▁&& ▁! ▁no _ sc sv ▁) ▁{ ▁static ▁SSL _ CIPHER ▁sc sv ▁= ▁{ ▁0 ▁, ▁NULL ▁, ▁SSL 3_ CK _ SC SV ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁} ▁; ▁j ▁= ▁put _ cb ▁? ▁put _ cb ▁( ▁& ▁sc sv ▁, ▁p ▁) ▁: ▁ssl _ put _ cipher _ by _ char ▁( ▁s ▁, ▁& ▁sc sv ▁, ▁p ▁) ▁; ▁p ▁+= ▁j ▁; ▁# ifdef ▁OPENSSL _ RI _ DEBUG ▁fprintf ▁( ▁stderr ▁, ▁" SC SV sent by client \ n " ▁) ▁; ▁# endif ▁} ▁return ▁( ▁p ▁- ▁q ▁) ▁; ▁}	1
▁int ▁tls _ construct _ st oc _ status _ request ▁( ▁SSL ▁* ▁s ▁, ▁W PACKET ▁* ▁pkt ▁, ▁X 509 ▁* ▁x ▁, ▁size _ t ▁chain ▁, ▁int ▁* ▁al ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁tl se xt _ status _ expected ▁) ▁return ▁1 ▁; ▁if ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁&& ▁chain ▁!= ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁! ▁W PACKET _ put _ bytes _ u 16 ▁( ▁pkt ▁, ▁TL SE XT _ TYPE _ status _ request ▁) ▁|| ▁! ▁W PACKET _ start _ sub _ packet _ u 16 ▁( ▁pkt ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ ST OC _ STATUS _ REQUEST ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁&& ▁! ▁tls _ construct _ cert _ status _ body ▁( ▁s ▁, ▁pkt ▁) ▁) ▁|| ▁! ▁W PACKET _ close ▁( ▁pkt ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ ST OC _ STATUS _ REQUEST ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁eval _ motion _ dist ▁( ▁Ro q Context ▁* ▁enc ▁, ▁int ▁x ▁, ▁int ▁y ▁, ▁motion _ vect ▁vect ▁, ▁int ▁size ▁) ▁{ ▁int ▁mx ▁= ▁vect ▁. ▁d ▁[ ▁0 ▁] ▁; ▁int ▁my ▁= ▁vect ▁. ▁d ▁[ ▁1 ▁] ▁; ▁if ▁( ▁mx ▁< ▁-7 ▁|| ▁mx ▁> ▁7 ▁) ▁return ▁INT _ MAX ▁; ▁if ▁( ▁my ▁< ▁-7 ▁|| ▁my ▁> ▁7 ▁) ▁return ▁INT _ MAX ▁; ▁mx ▁+= ▁x ▁; ▁my ▁+= ▁y ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁mx ▁> ▁enc ▁-> ▁width ▁- ▁size ▁|| ▁( ▁unsigned ▁) ▁my ▁> ▁enc ▁-> ▁height ▁- ▁size ▁) ▁return ▁INT _ MAX ▁; ▁return ▁block _ sse ▁( ▁enc ▁-> ▁frame _ to _ enc ▁-> ▁data ▁, ▁enc ▁-> ▁last _ frame ▁-> ▁data ▁, ▁x ▁, ▁y ▁, ▁mx ▁, ▁my ▁, ▁enc ▁-> ▁frame _ to _ enc ▁-> ▁linesize ▁, ▁enc ▁-> ▁last _ frame ▁-> ▁linesize ▁, ▁size ▁) ▁; ▁}	1
▁static ▁int ▁print _ device _ sink s ▁( ▁AV OutputFormat ▁* ▁fmt ▁, ▁AV Dictionary ▁* ▁opts ▁) ▁{ ▁int ▁ret ▁, ▁i ▁; ▁AV Device InfoList ▁* ▁device _ list ▁= ▁NULL ▁; ▁if ▁( ▁! ▁fmt ▁|| ▁! ▁fmt ▁-> ▁priv _ class ▁|| ▁! ▁AV _ IS _ OUTPUT _ DEVICE ▁( ▁fmt ▁-> ▁priv _ class ▁-> ▁category ▁) ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁printf ▁( ▁" A udo - detected sink s for % s :\ n " ▁, ▁fmt ▁-> ▁name ▁) ▁; ▁if ▁( ▁! ▁fmt ▁-> ▁get _ device _ list ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁printf ▁( ▁" Cannot list sink s . Not implemented .\ n " ▁) ▁; ▁goto ▁fail ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁av device _ list _ output _ sink s ▁( ▁fmt ▁, ▁NULL ▁, ▁opts ▁, ▁& ▁device _ list ▁) ▁) ▁< ▁0 ▁) ▁{ ▁printf ▁( ▁" Cannot list sink s .\ n " ▁) ▁; ▁goto ▁fail ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁device _ list ▁-> ▁nb _ devices ▁; ▁i ▁++ ▁) ▁{ ▁printf ▁( ▁"% s % s [% s ]\ n " ▁, ▁device _ list ▁-> ▁default _ device ▁== ▁i ▁? ▁"*" ▁: ▁"" ▁, ▁device _ list ▁-> ▁devices ▁[ ▁i ▁] ▁-> ▁device _ name ▁, ▁device _ list ▁-> ▁devices ▁[ ▁i ▁] ▁-> ▁device _ description ▁) ▁; ▁} ▁fail ▁: ▁av device _ free _ list _ devices ▁( ▁& ▁device _ list ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁body ▁( ▁uint 32_ t ▁AB CD ▁[ ▁4 ▁] ▁, ▁uint 32_ t ▁* ▁src ▁, ▁int ▁nblocks ▁) ▁{ ▁int ▁i ▁av _ unused ▁; ▁int ▁n ▁; ▁uint 32_ t ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁, ▁t ▁, ▁* ▁X ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁nblocks ▁; ▁n ▁++ ▁) ▁{ ▁a ▁= ▁AB CD ▁[ ▁3 ▁] ▁; ▁b ▁= ▁AB CD ▁[ ▁2 ▁] ▁; ▁c ▁= ▁AB CD ▁[ ▁1 ▁] ▁; ▁d ▁= ▁AB CD ▁[ ▁0 ▁] ▁; ▁X ▁= ▁src ▁+ ▁n ▁* ▁16 ▁; ▁# if ▁HAVE _ BIG ENDIAN ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁i ▁++ ▁) ▁X ▁[ ▁i ▁] ▁= ▁av _ bswap 32 ▁( ▁X ▁[ ▁i ▁] ▁) ▁; ▁# endif ▁# if ▁CONFIG _ SMALL ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁{ ▁CORE ▁( ▁i ▁, ▁a ▁, ▁b ▁, ▁c ▁, ▁d ▁) ▁; ▁t ▁= ▁d ▁; ▁d ▁= ▁c ▁; ▁c ▁= ▁b ▁; ▁b ▁= ▁a ▁; ▁a ▁= ▁t ▁; ▁} ▁# else ▁# define ▁CORE 2 ▁( ▁i ▁) ▁\ CORE ( i , a , b , c , d ); CORE (( i +1 ), d , a , b , c );\ CORE (( i +2 ), c , d , a , b ); CORE (( i + 3 ), b , c , d , a ) ▁# define ▁CORE 4 ▁( ▁i ▁) ▁CORE 2( i ); CORE 2 (( i + 4 )); CORE 2 (( i + 8 )); CORE 2 (( i + 12 )) ▁CORE 4 ▁( ▁0 ▁) ▁; ▁CORE 4 ▁( ▁16 ▁) ▁; ▁CORE 4 ▁( ▁32 ▁) ▁; ▁CORE 4 ▁( ▁48 ▁) ▁; ▁# endif ▁AB CD ▁[ ▁0 ▁] ▁+= ▁d ▁; ▁AB CD ▁[ ▁1 ▁] ▁+= ▁c ▁; ▁AB CD ▁[ ▁2 ▁] ▁+= ▁b ▁; ▁AB CD ▁[ ▁3 ▁] ▁+= ▁a ▁; ▁} ▁}	0
▁static ▁int ▁process _ input _ packet ▁( ▁InputStream ▁* ▁ist ▁, ▁const ▁AVPacket ▁* ▁pkt ▁, ▁int ▁no _ eof ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁, ▁i ▁; ▁int ▁got _ output ▁= ▁0 ▁; ▁AVPacket ▁avpkt ▁; ▁if ▁( ▁! ▁ist ▁-> ▁saw _ first _ ts ▁) ▁{ ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁st ▁-> ▁avg _ frame _ rate ▁. ▁num ▁? ▁- ▁ist ▁-> ▁dec _ ctx ▁-> ▁has _ b _ frames ▁* ▁AV _ TIME _ BASE ▁/ ▁av _ q 2 d ▁( ▁ist ▁-> ▁st ▁-> ▁avg _ frame _ rate ▁) ▁: ▁0 ▁; ▁ist ▁-> ▁pts ▁= ▁0 ▁; ▁if ▁( ▁pkt ▁&& ▁pkt ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁{ ▁ist ▁-> ▁dts ▁+= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁pts ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁} ▁ist ▁-> ▁saw _ first _ ts ▁= ▁1 ▁; ▁} ▁if ▁( ▁ist ▁-> ▁next _ dts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁ist ▁-> ▁next _ dts ▁= ▁ist ▁-> ▁dts ▁; ▁if ▁( ▁ist ▁-> ▁next _ pts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁pts ▁; ▁if ▁( ▁! ▁pkt ▁) ▁{ ▁av _ init _ packet ▁( ▁& ▁avpkt ▁) ▁; ▁avpkt ▁. ▁data ▁= ▁NULL ▁; ▁avpkt ▁. ▁size ▁= ▁0 ▁; ▁goto ▁handle _ eof ▁; ▁} ▁else ▁{ ▁avpkt ▁= ▁* ▁pkt ▁; ▁} ▁if ▁( ▁pkt ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁= ▁ist ▁-> ▁dts ▁= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁dts ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁if ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ VIDEO ▁|| ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁} ▁while ▁( ▁ist ▁-> ▁decoding _ needed ▁&& ▁( ▁avpkt ▁. ▁size ▁> ▁0 ▁|| ▁( ▁! ▁pkt ▁&& ▁got _ output ▁) ▁) ▁) ▁{ ▁int ▁duration ▁; ▁handle _ eof ▁: ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁next _ pts ▁; ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁switch ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁ret ▁= ▁decode _ audio ▁( ▁ist ▁, ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁ret ▁= ▁decode _ video ▁( ▁ist ▁, ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁if ▁( ▁avpkt ▁. ▁duration ▁) ▁{ ▁duration ▁= ▁av _ re scale _ q ▁( ▁avpkt ▁. ▁duration ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁} ▁else ▁if ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁!= ▁0 ▁&& ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁den ▁!= ▁0 ▁) ▁{ ▁int ▁ticks ▁= ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁? ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁-> ▁repeat _ p ict ▁+ ▁1 ▁: ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁duration ▁= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁den ▁* ▁ticks ▁) ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁} ▁else ▁duration ▁= ▁0 ▁; ▁if ▁( ▁ist ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁duration ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁+= ▁duration ▁; ▁} ▁else ▁ist ▁-> ▁next _ dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁if ▁( ▁got _ output ▁) ▁ist ▁-> ▁next _ pts ▁+= ▁duration ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ SUBTITLE ▁: ▁ret ▁= ▁trans code _ sub title s ▁( ▁ist ▁, ▁& ▁avpkt ▁, ▁& ▁got _ output ▁) ▁; ▁break ▁; ▁default ▁: ▁return ▁-1 ▁; ▁} ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error while de coding stream #% d :% d :% s \ n " ▁, ▁ist ▁-> ▁file _ index ▁, ▁ist ▁-> ▁st ▁-> ▁index ▁, ▁av _ err 2 str ▁( ▁ret ▁) ▁) ▁; ▁if ▁( ▁exit _ on _ error ▁) ▁exit _ program ▁( ▁1 ▁) ▁; ▁break ▁; ▁} ▁avpkt ▁. ▁dts ▁= ▁avpkt ▁. ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁if ▁( ▁pkt ▁) ▁{ ▁if ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁codec _ type ▁!= ▁AVMEDIA _ TYPE _ AUDIO ▁) ▁ret ▁= ▁avpkt ▁. ▁size ▁; ▁avpkt ▁. ▁data ▁+= ▁ret ▁; ▁avpkt ▁. ▁size ▁-= ▁ret ▁; ▁} ▁if ▁( ▁! ▁got _ output ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁got _ output ▁&& ▁! ▁pkt ▁) ▁break ▁; ▁} ▁if ▁( ▁! ▁pkt ▁&& ▁ist ▁-> ▁decoding _ needed ▁&& ▁! ▁got _ output ▁&& ▁! ▁no _ eof ▁) ▁{ ▁int ▁ret ▁= ▁send _ filter _ eof ▁( ▁ist ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ FATAL ▁, ▁" Err orm ark ing filters as finished \ n " ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁ist ▁-> ▁decoding _ needed ▁) ▁{ ▁ist ▁-> ▁dts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁switch ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁ist ▁-> ▁next _ dts ▁+= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁dec _ ctx ▁-> ▁frame _ size ▁) ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁sample _ rate ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁if ▁( ▁ist ▁-> ▁fram erate ▁. ▁num ▁) ▁{ ▁AVR ational ▁time _ base _ q ▁= ▁AV _ TIME _ BASE _ Q ▁; ▁int 64_ t ▁next _ dts ▁= ▁av _ re scale _ q ▁( ▁ist ▁-> ▁next _ dts ▁, ▁time _ base _ q ▁, ▁av _ inv _ q ▁( ▁ist ▁-> ▁fram erate ▁) ▁) ▁; ▁ist ▁-> ▁next _ dts ▁= ▁av _ re scale _ q ▁( ▁next _ dts ▁+ ▁1 ▁, ▁av _ inv _ q ▁( ▁ist ▁-> ▁fram erate ▁) ▁, ▁time _ base _ q ▁) ▁; ▁} ▁else ▁if ▁( ▁pkt ▁-> ▁duration ▁) ▁{ ▁ist ▁-> ▁next _ dts ▁+= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁duration ▁, ▁ist ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁} ▁else ▁if ▁( ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁!= ▁0 ▁) ▁{ ▁int ▁ticks ▁= ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁? ▁av _ stream _ get _ parser ▁( ▁ist ▁-> ▁st ▁) ▁-> ▁repeat _ p ict ▁+ ▁1 ▁: ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁ist ▁-> ▁next _ dts ▁+= ▁( ▁( ▁int 64_ t ▁) ▁AV _ TIME _ BASE ▁* ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁den ▁* ▁ticks ▁) ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁fram erate ▁. ▁num ▁/ ▁ist ▁-> ▁dec _ ctx ▁-> ▁ticks _ per _ frame ▁; ▁} ▁break ▁; ▁} ▁ist ▁-> ▁pts ▁= ▁ist ▁-> ▁dts ▁; ▁ist ▁-> ▁next _ pts ▁= ▁ist ▁-> ▁next _ dts ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁pkt ▁&& ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁check _ output _ constraints ▁( ▁ist ▁, ▁o st ▁) ▁|| ▁o st ▁-> ▁encoding _ needed ▁) ▁continue ▁; ▁do _ stream copy ▁( ▁ist ▁, ▁o st ▁, ▁pkt ▁) ▁; ▁} ▁return ▁got _ output ▁; ▁}	1
▁void ▁ff _ init _ block _ index ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁const ▁int ▁linesize ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁const ▁int ▁uv lines ize ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁-> ▁linesize ▁[ ▁1 ▁] ▁; ▁const ▁int ▁mb _ size ▁= ▁4 ▁; ▁s ▁-> ▁block _ index ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁) ▁- ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁) ▁- ▁1 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁2 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁+ ▁1 ▁) ▁- ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁3 ▁] ▁= ▁s ▁-> ▁b 8_ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁* ▁2 ▁+ ▁1 ▁) ▁- ▁1 ▁+ ▁s ▁-> ▁mb _ x ▁* ▁2 ▁; ▁s ▁-> ▁block _ index ▁[ ▁4 ▁] ▁= ▁s ▁-> ▁mb _ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁+ ▁1 ▁) ▁+ ▁s ▁-> ▁b 8_ stride ▁* ▁s ▁-> ▁mb _ height ▁* ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁- ▁1 ▁; ▁s ▁-> ▁block _ index ▁[ ▁5 ▁] ▁= ▁s ▁-> ▁mb _ stride ▁* ▁( ▁s ▁-> ▁mb _ y ▁+ ▁s ▁-> ▁mb _ height ▁+ ▁2 ▁) ▁+ ▁s ▁-> ▁b 8_ stride ▁* ▁s ▁-> ▁mb _ height ▁* ▁2 ▁+ ▁s ▁-> ▁mb _ x ▁- ▁1 ▁; ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁( ▁( ▁s ▁-> ▁mb _ x ▁- ▁1 ▁) ▁<< ▁mb _ size ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁( ▁( ▁s ▁-> ▁mb _ x ▁- ▁1 ▁) ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ x _ shift ▁) ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁2 ▁] ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁-> ▁data ▁[ ▁2 ▁] ▁+ ▁( ▁( ▁s ▁-> ▁mb _ x ▁- ▁1 ▁) ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ x _ shift ▁) ▁) ▁; ▁if ▁( ▁! ▁( ▁s ▁-> ▁pict _ type ▁== ▁AV _ PICTURE _ TYPE _ B ▁&& ▁s ▁-> ▁avctx ▁-> ▁draw _ h oriz _ band ▁&& ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁) ▁{ ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ FRAME ▁) ▁{ ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁+= ▁s ▁-> ▁mb _ y ▁* ▁linesize ▁<< ▁mb _ size ▁; ▁s ▁-> ▁dest ▁[ ▁1 ▁] ▁+= ▁s ▁-> ▁mb _ y ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁2 ▁] ▁+= ▁s ▁-> ▁mb _ y ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁} ▁else ▁{ ▁s ▁-> ▁dest ▁[ ▁0 ▁] ▁+= ▁( ▁s ▁-> ▁mb _ y ▁>> ▁1 ▁) ▁* ▁linesize ▁<< ▁mb _ size ▁; ▁s ▁-> ▁dest ▁[ ▁1 ▁] ▁+= ▁( ▁s ▁-> ▁mb _ y ▁>> ▁1 ▁) ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁s ▁-> ▁dest ▁[ ▁2 ▁] ▁+= ▁( ▁s ▁-> ▁mb _ y ▁>> ▁1 ▁) ▁* ▁uv lines ize ▁<< ▁( ▁mb _ size ▁- ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁assert ▁( ▁( ▁s ▁-> ▁mb _ y ▁& ▁1 ▁) ▁== ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ BOTTOM _ FIELD ▁) ▁) ▁; ▁} ▁} ▁}	0
▁int ▁dt ls 1_ do _ write ▁( ▁SSL ▁* ▁s ▁, ▁int ▁type ▁) ▁{ ▁int ▁ret ▁; ▁int ▁curr _ mtu ▁; ▁unsigned ▁int ▁len ▁, ▁frag _ off ▁, ▁mac _ size ▁, ▁blocksize ▁; ▁if ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁< ▁dt ls 1_ min _ mtu ▁( ▁) ▁&& ▁! ▁( ▁SSL _ get _ options ▁( ▁s ▁) ▁& ▁SSL _ OP _ NO _ QUERY _ MTU ▁) ▁) ▁{ ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁= ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ QUERY _ MTU ▁, ▁0 ▁, ▁NULL ▁) ▁; ▁if ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁< ▁dt ls 1_ min _ mtu ▁( ▁) ▁) ▁{ ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁= ▁0 ▁; ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁= ▁dt ls 1_ guess _ mtu ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁) ▁; ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ SET _ MTU ▁, ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁, ▁NULL ▁) ▁; ▁} ▁} ▁# if ▁0 ▁mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁; ▁fprintf ▁( ▁stderr ▁, ▁" using MTU =% d \ n " ▁, ▁mtu ▁) ▁; ▁mtu ▁-= ▁( ▁DTLS 1_ HM _ HEADER _ LENGTH ▁+ ▁DTLS 1_ RT _ HEADER _ LENGTH ▁) ▁; ▁curr _ mtu ▁= ▁mtu ▁- ▁BIO _ w pending ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁; ▁if ▁( ▁curr _ mtu ▁> ▁0 ▁) ▁mtu ▁= ▁curr _ mtu ▁; ▁else ▁if ▁( ▁( ▁ret ▁= ▁BIO _ flush ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁) ▁<= ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁BIO _ w pending ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁+ ▁s ▁-> ▁init _ num ▁>= ▁mtu ▁) ▁{ ▁ret ▁= ▁BIO _ flush ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁) ▁return ▁ret ▁; ▁mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁- ▁( ▁DTLS 1_ HM _ HEADER _ LENGTH ▁+ ▁DTLS 1_ RT _ HEADER _ LENGTH ▁) ▁; ▁} ▁# endif ▁OPENSSL _ assert ▁( ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁>= ▁dt ls 1_ min _ mtu ▁( ▁) ▁) ▁; ▁if ▁( ▁s ▁-> ▁init _ off ▁== ▁0 ▁&& ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁) ▁OPENSSL _ assert ▁( ▁s ▁-> ▁init _ num ▁== ▁( ▁int ▁) ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁. ▁msg _ len ▁+ ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁if ▁( ▁s ▁-> ▁write _ hash ▁) ▁mac _ size ▁= ▁EVP _ MD _ CTX _ size ▁( ▁s ▁-> ▁write _ hash ▁) ▁; ▁else ▁mac _ size ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁enc _ write _ ctx ▁&& ▁( ▁EVP _ CIPHER _ mode ▁( ▁s ▁-> ▁enc _ write _ ctx ▁-> ▁cipher ▁) ▁& ▁EVP _ C IPH _ CBC _ MODE ▁) ▁) ▁blocksize ▁= ▁2 ▁* ▁EVP _ CIPHER _ block _ size ▁( ▁s ▁-> ▁enc _ write _ ctx ▁-> ▁cipher ▁) ▁; ▁else ▁blocksize ▁= ▁0 ▁; ▁frag _ off ▁= ▁0 ▁; ▁while ▁( ▁s ▁-> ▁init _ num ▁) ▁{ ▁curr _ mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁- ▁BIO _ w pending ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁- ▁DTLS 1_ RT _ HEADER _ LENGTH ▁- ▁mac _ size ▁- ▁blocksize ▁; ▁if ▁( ▁curr _ mtu ▁<= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁{ ▁ret ▁= ▁BIO _ flush ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁) ▁return ▁ret ▁; ▁curr _ mtu ▁= ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁- ▁DTLS 1_ RT _ HEADER _ LENGTH ▁- ▁mac _ size ▁- ▁blocksize ▁; ▁} ▁if ▁( ▁s ▁-> ▁init _ num ▁> ▁curr _ mtu ▁) ▁len ▁= ▁curr _ mtu ▁; ▁else ▁len ▁= ▁s ▁-> ▁init _ num ▁; ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁) ▁{ ▁if ▁( ▁s ▁-> ▁init _ off ▁!= ▁0 ▁) ▁{ ▁OPENSSL _ assert ▁( ▁s ▁-> ▁init _ off ▁> ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁s ▁-> ▁init _ off ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁s ▁-> ▁init _ num ▁+= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁if ▁( ▁s ▁-> ▁init _ num ▁> ▁curr _ mtu ▁) ▁len ▁= ▁curr _ mtu ▁; ▁else ▁len ▁= ▁s ▁-> ▁init _ num ▁; ▁} ▁dt ls 1_ fix _ message _ header ▁( ▁s ▁, ▁frag _ off ▁, ▁len ▁- ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁dt ls 1_ write _ message _ header ▁( ▁s ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁) ▁; ▁OPENSSL _ assert ▁( ▁len ▁>= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁} ▁ret ▁= ▁dt ls 1_ write _ bytes ▁( ▁s ▁, ▁type ▁, ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁, ▁len ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ MTU _ EXCEEDED ▁, ▁0 ▁, ▁NULL ▁) ▁> ▁0 ▁) ▁s ▁-> ▁d 1 ▁-> ▁mtu ▁= ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ QUERY _ MTU ▁, ▁0 ▁, ▁NULL ▁) ▁; ▁else ▁return ▁( ▁-1 ▁) ▁; ▁} ▁else ▁{ ▁OPENSSL _ assert ▁( ▁len ▁== ▁( ▁unsigned ▁int ▁) ▁ret ▁) ▁; ▁if ▁( ▁type ▁== ▁SSL 3_ RT _ HAND SHAKE ▁&& ▁! ▁s ▁-> ▁d 1 ▁-> ▁retrans mit ting ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁& ▁s ▁-> ▁init _ buf ▁-> ▁data ▁[ ▁s ▁-> ▁init _ off ▁] ▁; ▁const ▁struct ▁hm _ header _ st ▁* ▁msg _ hdr ▁= ▁& ▁s ▁-> ▁d 1 ▁-> ▁w _ msg _ hdr ▁; ▁int ▁xlen ▁; ▁if ▁( ▁frag _ off ▁== ▁0 ▁&& ▁s ▁-> ▁version ▁!= ▁DTLS 1_ BAD _ VER ▁) ▁{ ▁* ▁p ▁++ ▁= ▁msg _ hdr ▁-> ▁type ▁; ▁l 2 n 3 ▁( ▁msg _ hdr ▁-> ▁msg _ len ▁, ▁p ▁) ▁; ▁s 2 n ▁( ▁msg _ hdr ▁-> ▁seq ▁, ▁p ▁) ▁; ▁l 2 n 3 ▁( ▁0 ▁, ▁p ▁) ▁; ▁l 2 n 3 ▁( ▁msg _ hdr ▁-> ▁msg _ len ▁, ▁p ▁) ▁; ▁p ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁xlen ▁= ▁ret ▁; ▁} ▁else ▁{ ▁p ▁+= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁xlen ▁= ▁ret ▁- ▁DTLS 1_ HM _ HEADER _ LENGTH ▁; ▁} ▁ssl 3_ finish _ mac ▁( ▁s ▁, ▁p ▁, ▁xlen ▁) ▁; ▁} ▁if ▁( ▁ret ▁== ▁s ▁-> ▁init _ num ▁) ▁{ ▁if ▁( ▁s ▁-> ▁msg _ callback ▁) ▁s ▁-> ▁msg _ callback ▁( ▁1 ▁, ▁s ▁-> ▁version ▁, ▁type ▁, ▁s ▁-> ▁init _ buf ▁-> ▁data ▁, ▁( ▁size _ t ▁) ▁( ▁s ▁-> ▁init _ off ▁+ ▁s ▁-> ▁init _ num ▁) ▁, ▁s ▁, ▁s ▁-> ▁msg _ callback _ arg ▁) ▁; ▁s ▁-> ▁init _ off ▁= ▁0 ▁; ▁s ▁-> ▁init _ num ▁= ▁0 ▁; ▁return ▁( ▁1 ▁) ▁; ▁} ▁s ▁-> ▁init _ off ▁+= ▁ret ▁; ▁s ▁-> ▁init _ num ▁-= ▁ret ▁; ▁frag _ off ▁+= ▁( ▁ret ▁-= ▁DTLS 1_ HM _ HEADER _ LENGTH ▁) ▁; ▁} ▁} ▁return ▁( ▁0 ▁) ▁; ▁}	1
▁static ▁char ▁* ▁* ▁lookup _ serial ▁( ▁CA _ DB ▁* ▁db ▁, ▁ASN 1_ INTEGER ▁* ▁ser ▁) ▁{ ▁int ▁i ▁; ▁BIGNUM ▁* ▁bn ▁= ▁NULL ▁; ▁char ▁* ▁it mp ▁, ▁* ▁row ▁[ ▁DB _ NUMBER ▁] ▁, ▁* ▁* ▁r row ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁DB _ NUMBER ▁; ▁i ▁++ ▁) ▁row ▁[ ▁i ▁] ▁= ▁NULL ▁; ▁bn ▁= ▁ASN 1_ INTEGER _ to _ BN ▁( ▁ser ▁, ▁NULL ▁) ▁; ▁OPENSSL _ assert ▁( ▁bn ▁) ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁bn ▁) ▁) ▁it mp ▁= ▁OPENSSL _ strdup ▁( ▁" 00" ▁) ▁; ▁else ▁it mp ▁= ▁BN _ bn 2 hex ▁( ▁bn ▁) ▁; ▁row ▁[ ▁DB _ serial ▁] ▁= ▁it mp ▁; ▁BN _ free ▁( ▁bn ▁) ▁; ▁r row ▁= ▁TXT _ DB _ get _ by _ index ▁( ▁db ▁-> ▁db ▁, ▁DB _ serial ▁, ▁row ▁) ▁; ▁OPENSSL _ free ▁( ▁it mp ▁) ▁; ▁return ▁r row ▁; ▁}	0
▁static ▁timer _ event _ t ▁* ▁event _ get _ timer _ event ▁( ▁apr _ time _ t ▁t ▁, ▁ap _ mp m _ callback _ fn _ t ▁* ▁cb fn ▁, ▁void ▁* ▁bat on ▁, ▁int ▁insert ▁, ▁apr _ pol lfd _ t ▁* ▁* ▁remove ▁) ▁{ ▁timer _ event _ t ▁* ▁te ▁; ▁apr _ thread _ mutex _ lock ▁( ▁g _ timer _ skip list _ mtx ▁) ▁; ▁if ▁( ▁! ▁APR _ RING _ EMPTY ▁( ▁& ▁timer _ free _ ring ▁, ▁timer _ event _ t ▁, ▁link ▁) ▁) ▁{ ▁te ▁= ▁APR _ RING _ FIRST ▁( ▁& ▁timer _ free _ ring ▁) ▁; ▁APR _ RING _ REMOVE ▁( ▁te ▁, ▁link ▁) ▁; ▁} ▁else ▁{ ▁te ▁= ▁apr _ skip list _ alloc ▁( ▁timer _ skip list ▁, ▁sizeof ▁( ▁timer _ event _ t ▁) ▁) ▁; ▁APR _ RING _ ELEM _ INIT ▁( ▁te ▁, ▁link ▁) ▁; ▁} ▁te ▁-> ▁cb func ▁= ▁cb fn ▁; ▁te ▁-> ▁bat on ▁= ▁bat on ▁; ▁te ▁-> ▁canceled ▁= ▁0 ▁; ▁te ▁-> ▁when ▁= ▁t ▁; ▁te ▁-> ▁remove ▁= ▁remove ▁; ▁if ▁( ▁insert ▁) ▁{ ▁apr _ skip list _ insert ▁( ▁timer _ skip list ▁, ▁( ▁void ▁* ▁) ▁te ▁) ▁; ▁} ▁apr _ thread _ mutex _ unlock ▁( ▁g _ timer _ skip list _ mtx ▁) ▁; ▁return ▁te ▁; ▁}	0
▁static ▁char ▁* ▁sh _ find _ my _ buddy ▁( ▁char ▁* ▁ptr ▁, ▁int ▁list ▁) ▁{ ▁int ▁bit ▁; ▁char ▁* ▁chunk ▁= ▁NULL ▁; ▁bit ▁= ▁( ▁1 ▁<< ▁list ▁) ▁+ ▁( ▁ptr ▁- ▁sh ▁. ▁arena ▁) ▁/ ▁( ▁sh ▁. ▁arena _ size ▁>> ▁list ▁) ▁; ▁bit ▁ ^ = ▁1 ▁; ▁if ▁( ▁TEST BIT ▁( ▁sh ▁. ▁bit table ▁, ▁bit ▁) ▁&& ▁! ▁TEST BIT ▁( ▁sh ▁. ▁bit malloc ▁, ▁bit ▁) ▁) ▁chunk ▁= ▁sh ▁. ▁arena ▁+ ▁( ▁( ▁bit ▁& ▁( ▁( ▁1 ▁<< ▁list ▁) ▁- ▁1 ▁) ▁) ▁* ▁( ▁sh ▁. ▁arena _ size ▁>> ▁list ▁) ▁) ▁; ▁return ▁chunk ▁; ▁}	1
▁static ▁int ▁tls 1_ check _ sig _ alg ▁( ▁SSL ▁* ▁s ▁, ▁X 509 ▁* ▁x ▁, ▁int ▁default _ nid ▁) ▁{ ▁int ▁sig _ nid ▁, ▁use _ pc _ sig algs ▁= ▁0 ▁; ▁size _ t ▁i ▁; ▁const ▁SIG ALG _ LOOKUP ▁* ▁sig alg ▁; ▁size _ t ▁sig algs len ▁; ▁if ▁( ▁default _ nid ▁== ▁-1 ▁) ▁return ▁1 ▁; ▁sig _ nid ▁= ▁X 509_ get _ signature _ nid ▁( ▁x ▁) ▁; ▁if ▁( ▁default _ nid ▁) ▁return ▁sig _ nid ▁== ▁default _ nid ▁? ▁1 ▁: ▁0 ▁; ▁if ▁( ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁&& ▁s ▁-> ▁s 3 ▁. ▁tmp ▁. ▁peer _ cert _ sig algs ▁!= ▁NULL ▁) ▁{ ▁sig algs len ▁= ▁s ▁-> ▁s 3 ▁. ▁tmp ▁. ▁peer _ cert _ sig algs len ▁; ▁use _ pc _ sig algs ▁= ▁1 ▁; ▁} ▁else ▁{ ▁sig algs len ▁= ▁s ▁-> ▁shared _ sig algs len ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sig algs len ▁; ▁i ▁++ ▁) ▁{ ▁sig alg ▁= ▁use _ pc _ sig algs ▁? ▁tls 1_ lookup _ sig alg ▁( ▁s ▁-> ▁s 3 ▁. ▁tmp ▁. ▁peer _ cert _ sig algs ▁[ ▁i ▁] ▁) ▁: ▁s ▁-> ▁shared _ sig algs ▁[ ▁i ▁] ▁; ▁if ▁( ▁sig _ nid ▁== ▁sig alg ▁-> ▁sig and hash ▁) ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁tls 13_ h kdf _ expand ▁( ▁SSL ▁* ▁s ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁const ▁unsigned ▁char ▁* ▁secret ▁, ▁const ▁unsigned ▁char ▁* ▁label ▁, ▁size _ t ▁label len ▁, ▁const ▁unsigned ▁char ▁* ▁data ▁, ▁size _ t ▁datalen ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁size _ t ▁outlen ▁) ▁{ ▁const ▁unsigned ▁char ▁label _ prefix ▁[ ▁] ▁= ▁" tls 13" ▁; ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new _ id ▁( ▁EVP _ PKEY _ HK DF ▁, ▁NULL ▁) ▁; ▁int ▁ret ▁; ▁size _ t ▁hk df label len ▁; ▁size _ t ▁hash len ▁; ▁unsigned ▁char ▁hk df label ▁[ ▁sizeof ▁( ▁uint 16_ t ▁) ▁+ ▁sizeof ▁( ▁uint 8_ t ▁) ▁+ ▁+ ▁sizeof ▁( ▁label _ prefix ▁) ▁+ ▁TLS 13_ MAX _ LABEL _ LEN ▁+ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁W PACKET ▁pkt ▁; ▁if ▁( ▁pctx ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁hash len ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁if ▁( ▁! ▁W PACKET _ init _ static _ len ▁( ▁& ▁pkt ▁, ▁hk df label ▁, ▁sizeof ▁( ▁hk df label ▁) ▁, ▁0 ▁) ▁|| ▁! ▁W PACKET _ put _ bytes _ u 16 ▁( ▁& ▁pkt ▁, ▁outlen ▁) ▁|| ▁! ▁W PACKET _ start _ sub _ packet _ u 8 ▁( ▁& ▁pkt ▁) ▁|| ▁! ▁W PACKET _ memcpy ▁( ▁& ▁pkt ▁, ▁label _ prefix ▁, ▁sizeof ▁( ▁label _ prefix ▁) ▁- ▁1 ▁) ▁|| ▁! ▁W PACKET _ memcpy ▁( ▁& ▁pkt ▁, ▁label ▁, ▁label len ▁) ▁|| ▁! ▁W PACKET _ close ▁( ▁& ▁pkt ▁) ▁|| ▁! ▁W PACKET _ sub _ memcpy _ u 8 ▁( ▁& ▁pkt ▁, ▁data ▁, ▁( ▁data ▁== ▁NULL ▁) ▁? ▁0 ▁: ▁datalen ▁) ▁|| ▁! ▁W PACKET _ get _ total _ written ▁( ▁& ▁pkt ▁, ▁& ▁hk df label len ▁) ▁|| ▁! ▁W PACKET _ finish ▁( ▁& ▁pkt ▁) ▁) ▁{ ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁W PACKET _ cleanup ▁( ▁& ▁pkt ▁) ▁; ▁return ▁0 ▁; ▁} ▁ret ▁= ▁EVP _ PKEY _ der ive _ init ▁( ▁pctx ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ h kdf _ mode ▁( ▁pctx ▁, ▁EVP _ PKEY _ HK DEF _ MODE _ EXPAND _ ONLY ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set _ h kdf _ md ▁( ▁pctx ▁, ▁md ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set 1_ h kdf _ key ▁( ▁pctx ▁, ▁secret ▁, ▁hash len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ add 1_ h kdf _ info ▁( ▁pctx ▁, ▁hk df label ▁, ▁hk df label len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ der ive ▁( ▁pctx ▁, ▁out ▁, ▁& ▁outlen ▁) ▁<= ▁0 ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁ret ▁== ▁0 ▁; ▁}	0
▁static ▁int ▁decode _ he xt ile ▁( ▁Vm nc Context ▁* ▁c ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁Get Byte Context ▁* ▁gb ▁, ▁int ▁w ▁, ▁int ▁h ▁, ▁int ▁stride ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁; ▁int ▁bg ▁= ▁0 ▁, ▁fg ▁= ▁0 ▁, ▁rects ▁, ▁color ▁, ▁flags ▁, ▁xy ▁, ▁wh ▁; ▁const ▁int ▁bpp ▁= ▁c ▁-> ▁bpp 2 ▁; ▁uint 8_ t ▁* ▁dst 2 ▁; ▁int ▁bw ▁= ▁16 ▁, ▁bh ▁= ▁16 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁h ▁; ▁j ▁+= ▁16 ▁) ▁{ ▁dst 2 ▁= ▁dst ▁; ▁bw ▁= ▁16 ▁; ▁if ▁( ▁j ▁+ ▁16 ▁> ▁h ▁) ▁bh ▁= ▁h ▁- ▁j ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁w ▁; ▁i ▁+= ▁16 ▁, ▁dst 2 ▁+= ▁16 ▁* ▁bpp ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁gb ▁) ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Pre m ature end of data !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁i ▁+ ▁16 ▁> ▁w ▁) ▁bw ▁= ▁w ▁- ▁i ▁; ▁flags ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁if ▁( ▁flags ▁& ▁HT _ RAW ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁gb ▁) ▁< ▁bw ▁* ▁bh ▁* ▁bpp ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Pre m ature end of data !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁paint _ raw ▁( ▁dst 2 ▁, ▁bw ▁, ▁bh ▁, ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁, ▁stride ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁flags ▁& ▁HT _ BK G ▁) ▁bg ▁= ▁vm nc _ get _ pixel ▁( ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁) ▁; ▁if ▁( ▁flags ▁& ▁HT _ FG ▁) ▁fg ▁= ▁vm nc _ get _ pixel ▁( ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁) ▁; ▁rects ▁= ▁0 ▁; ▁if ▁( ▁flags ▁& ▁HT _ SUB ▁) ▁rects ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁color ▁= ▁! ▁! ▁( ▁flags ▁& ▁HT _ CLR ▁) ▁; ▁paint _ rect ▁( ▁dst 2 ▁, ▁0 ▁, ▁0 ▁, ▁bw ▁, ▁bh ▁, ▁bg ▁, ▁bpp ▁, ▁stride ▁) ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁gb ▁) ▁< ▁rects ▁* ▁( ▁color ▁* ▁bpp ▁+ ▁2 ▁) ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Pre m ature end of data !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁rects ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁color ▁) ▁fg ▁= ▁vm nc _ get _ pixel ▁( ▁gb ▁, ▁bpp ▁, ▁c ▁-> ▁big endian ▁) ▁; ▁xy ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁wh ▁= ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁paint _ rect ▁( ▁dst 2 ▁, ▁xy ▁>> ▁4 ▁, ▁xy ▁& ▁0 xF ▁, ▁( ▁wh ▁>> ▁4 ▁) ▁+ ▁1 ▁, ▁( ▁wh ▁& ▁0 xF ▁) ▁+ ▁1 ▁, ▁fg ▁, ▁bpp ▁, ▁stride ▁) ▁; ▁} ▁} ▁} ▁dst ▁+= ▁stride ▁* ▁16 ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁mov _ read _ ud ta _ string ▁( ▁MOV Context ▁* ▁c ▁, ▁AVIO Context ▁* ▁pb ▁, ▁MOV Atom ▁atom ▁) ▁{ ▁char ▁tmp _ key ▁[ ▁5 ▁] ▁; ▁char ▁str ▁[ ▁1024 ▁] ▁, ▁key 2 ▁[ ▁32 ▁] ▁, ▁language ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁const ▁char ▁* ▁key ▁= ▁NULL ▁; ▁uint 16_ t ▁lang code ▁= ▁0 ▁; ▁uint 32_ t ▁data _ type ▁= ▁0 ▁, ▁str _ size ▁; ▁int ▁( ▁* ▁parse ▁) ▁( ▁MOV Context ▁* ▁, ▁AVIO Context ▁* ▁, ▁unsigned ▁, ▁const ▁char ▁* ▁) ▁= ▁NULL ▁; ▁switch ▁( ▁atom ▁. ▁type ▁) ▁{ ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" title " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" art ist " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" album _ art ist " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" comp oser " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" copyright " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" comment " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" album " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" date " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" gen re " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" gen re " ▁; ▁parse ▁= ▁mov _ metadata _ gn re ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" encoder " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" encoder " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁0 xa 9 ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" location " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" description " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" syn ops is " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" show " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" ep isode _ id " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" network " ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" track " ▁; ▁parse ▁= ▁mov _ metadata _ track _ or _ disc _ number ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" disc " ▁; ▁parse ▁= ▁mov _ metadata _ track _ or _ disc _ number ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" ep isode _ sort " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ bypass _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" se ason _ number " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ bypass _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" media _ type " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ no _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" hd _ video " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ no _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁key ▁= ▁" gap less _ playback " ▁; ▁parse ▁= ▁mov _ metadata _ int 8_ no _ padding ▁; ▁break ▁; ▁case ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁: ▁return ▁mov _ metadata _ loc i ▁( ▁c ▁, ▁pb ▁, ▁atom ▁. ▁size ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁it unes _ metadata ▁&& ▁atom ▁. ▁size ▁> ▁8 ▁) ▁{ ▁int ▁data _ size ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁int ▁tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁tag ▁== ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁data _ type ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁str _ size ▁= ▁data _ size ▁- ▁16 ▁; ▁atom ▁. ▁size ▁-= ▁16 ▁; ▁if ▁( ▁atom ▁. ▁type ▁== ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁int ▁ret ▁= ▁mov _ read _ co vr ▁( ▁c ▁, ▁pb ▁, ▁data _ type ▁, ▁str _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error parsing cover art .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁} ▁else ▁return ▁0 ▁; ▁} ▁else ▁if ▁( ▁atom ▁. ▁size ▁> ▁4 ▁&& ▁key ▁&& ▁! ▁c ▁-> ▁it unes _ metadata ▁) ▁{ ▁str _ size ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁lang code ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁ff _ mov _ lang _ to _ iso 639 ▁( ▁lang code ▁, ▁language ▁) ▁; ▁atom ▁. ▁size ▁-= ▁4 ▁; ▁} ▁else ▁str _ size ▁= ▁atom ▁. ▁size ▁; ▁if ▁( ▁c ▁-> ▁export _ all ▁&& ▁! ▁key ▁) ▁{ ▁snprintf ▁( ▁tmp _ key ▁, ▁5 ▁, ▁"% .4 s " ▁, ▁( ▁char ▁* ▁) ▁& ▁atom ▁. ▁type ▁) ▁; ▁key ▁= ▁tmp _ key ▁; ▁} ▁if ▁( ▁! ▁key ▁) ▁return ▁0 ▁; ▁if ▁( ▁atom ▁. ▁size ▁< ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁str _ size ▁= ▁FF MIN 3 ▁( ▁sizeof ▁( ▁str ▁) ▁- ▁1 ▁, ▁str _ size ▁, ▁atom ▁. ▁size ▁) ▁; ▁if ▁( ▁parse ▁) ▁parse ▁( ▁c ▁, ▁pb ▁, ▁str _ size ▁, ▁key ▁) ▁; ▁else ▁{ ▁if ▁( ▁data _ type ▁== ▁3 ▁|| ▁( ▁data _ type ▁== ▁0 ▁&& ▁( ▁lang code ▁< ▁0 x 400 ▁|| ▁lang code ▁== ▁0 x 7 fff ▁) ▁) ▁) ▁{ ▁mov _ read _ mac _ string ▁( ▁c ▁, ▁pb ▁, ▁str _ size ▁, ▁str ▁, ▁sizeof ▁( ▁str ▁) ▁) ▁; ▁} ▁else ▁{ ▁avio _ read ▁( ▁pb ▁, ▁str ▁, ▁str _ size ▁) ▁; ▁str ▁[ ▁str _ size ▁] ▁= ▁0 ▁; ▁} ▁c ▁-> ▁fc ▁-> ▁event _ flags ▁|= ▁AV FMT _ EVENT _ FLAG _ METADATA _ UPDATED ▁; ▁av _ dict _ set ▁( ▁& ▁c ▁-> ▁fc ▁-> ▁metadata ▁, ▁key ▁, ▁str ▁, ▁0 ▁) ▁; ▁if ▁( ▁* ▁language ▁&& ▁strcmp ▁( ▁language ▁, ▁" und " ▁) ▁) ▁{ ▁snprintf ▁( ▁key 2 ▁, ▁sizeof ▁( ▁key 2 ▁) ▁, ▁"% s -% s " ▁, ▁key ▁, ▁language ▁) ▁; ▁av _ dict _ set ▁( ▁& ▁c ▁-> ▁fc ▁-> ▁metadata ▁, ▁key 2 ▁, ▁str ▁, ▁0 ▁) ▁; ▁} ▁} ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" lang \" %3 s \"" ▁, ▁language ▁) ▁; ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" tag \"% s \" value \"% s \" atom \"% .4 s \"% d %" ▁PRId 64 ▁"\ n " ▁, ▁key ▁, ▁str ▁, ▁( ▁char ▁* ▁) ▁& ▁atom ▁. ▁type ▁, ▁str _ size ▁, ▁atom ▁. ▁size ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁void ▁ff _ lag _ rac _ init ▁( ▁lag _ rac ▁* ▁l ▁, ▁Get Bit Context ▁* ▁gb ▁, ▁int ▁length ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁left ▁; ▁align _ get _ bits ▁( ▁gb ▁) ▁; ▁left ▁= ▁get _ bits _ left ▁( ▁gb ▁) ▁>> ▁3 ▁; ▁l ▁-> ▁bytestream _ start ▁= ▁l ▁-> ▁bytestream ▁= ▁gb ▁-> ▁buffer ▁+ ▁get _ bits _ count ▁( ▁gb ▁) ▁/ ▁8 ▁; ▁l ▁-> ▁bytestream _ end ▁= ▁l ▁-> ▁bytestream _ start ▁+ ▁left ▁; ▁l ▁-> ▁range ▁= ▁0 x 80 ▁; ▁l ▁-> ▁low ▁= ▁* ▁l ▁-> ▁bytestream ▁>> ▁1 ▁; ▁l ▁-> ▁hash _ shift ▁= ▁FF MAX ▁( ▁l ▁-> ▁scale ▁- ▁8 ▁, ▁0 ▁) ▁; ▁for ▁( ▁i ▁= ▁j ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁r ▁= ▁i ▁<< ▁l ▁-> ▁hash _ shift ▁; ▁while ▁( ▁l ▁-> ▁prob ▁[ ▁j ▁+ ▁1 ▁] ▁<= ▁r ▁) ▁j ▁++ ▁; ▁l ▁-> ▁range _ hash ▁[ ▁i ▁] ▁= ▁j ▁; ▁} ▁l ▁-> ▁hash _ shift ▁+= ▁23 ▁; ▁}	1
▁static ▁int ▁a mov ie _ request _ frame ▁( ▁AVFilter Link ▁* ▁out link ▁) ▁{ ▁Movie Context ▁* ▁movie ▁= ▁out link ▁-> ▁src ▁-> ▁priv ▁; ▁int ▁ret ▁; ▁if ▁( ▁movie ▁-> ▁is _ done ▁) ▁return ▁AVERROR _ EOF ▁; ▁do ▁{ ▁if ▁( ▁( ▁ret ▁= ▁a mov ie _ get _ samples ▁( ▁out link ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁while ▁( ▁! ▁movie ▁-> ▁samples ref ▁) ▁; ▁avfilter _ filter _ samples ▁( ▁out link ▁, ▁avfilter _ ref _ buffer ▁( ▁movie ▁-> ▁samples ref ▁, ▁ ~ ▁0 ▁) ▁) ▁; ▁avfilter _ unref _ buffer ▁( ▁movie ▁-> ▁samples ref ▁) ▁; ▁movie ▁-> ▁samples ref ▁= ▁NULL ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁test _ kdf _ h kdf ▁( ▁void ▁) ▁{ ▁int ▁ret ▁; ▁EVP _ KDF _ CTX ▁* ▁k ctx ▁; ▁unsigned ▁char ▁out ▁[ ▁10 ▁] ▁; ▁const ▁unsigned ▁char ▁expected ▁[ ▁sizeof ▁( ▁out ▁) ▁] ▁= ▁{ ▁0 x 2 a ▁, ▁0 xc 4 ▁, ▁0 x 36 ▁, ▁0 x 9 f ▁, ▁0 x 52 ▁, ▁0 x 59 ▁, ▁0 x 96 ▁, ▁0 xf 8 ▁, ▁0 xde ▁, ▁0 x 13 ▁} ▁; ▁ret ▁= ▁TEST _ ptr ▁( ▁k ctx ▁= ▁EVP _ KDF _ CTX _ new _ id ▁( ▁EVP _ KDF _ HK DF ▁) ▁) ▁&& ▁TEST _ int _ gt ▁( ▁EVP _ KDF _ ctrl ▁( ▁k ctx ▁, ▁EVP _ KDF _ CTRL _ SET _ MD ▁, ▁EVP _ sha 256 ▁( ▁) ▁) ▁, ▁0 ▁) ▁&& ▁TEST _ int _ gt ▁( ▁EVP _ KDF _ ctrl ▁( ▁k ctx ▁, ▁EVP _ KDF _ CTRL _ SET _ S ALT ▁, ▁" salt " ▁, ▁( ▁size _ t ▁) ▁4 ▁) ▁, ▁0 ▁) ▁&& ▁TEST _ int _ gt ▁( ▁EVP _ KDF _ ctrl ▁( ▁k ctx ▁, ▁EVP _ KDF _ CTRL _ SET _ KEY ▁, ▁" secret " ▁, ▁( ▁size _ t ▁) ▁6 ▁) ▁, ▁0 ▁) ▁&& ▁TEST _ int _ gt ▁( ▁EVP _ KDF _ ctrl ▁( ▁k ctx ▁, ▁EVP _ KDF _ CTRL _ ADD _ HK DF _ INFO ▁, ▁" label " ▁, ▁( ▁size _ t ▁) ▁5 ▁) ▁, ▁0 ▁) ▁&& ▁TEST _ int _ gt ▁( ▁EVP _ KDF _ der ive ▁( ▁k ctx ▁, ▁out ▁, ▁sizeof ▁( ▁out ▁) ▁) ▁, ▁0 ▁) ▁&& ▁TEST _ mem _ eq ▁( ▁out ▁, ▁sizeof ▁( ▁out ▁) ▁, ▁expected ▁, ▁sizeof ▁( ▁expected ▁) ▁) ▁; ▁EVP _ KDF _ CTX _ free ▁( ▁k ctx ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁char ▁* ▁ngx _ http _ refer er _ merge _ conf ▁( ▁ngx _ conf _ t ▁* ▁cf ▁, ▁void ▁* ▁parent ▁, ▁void ▁* ▁child ▁) ▁{ ▁ngx _ http _ refer er _ conf _ t ▁* ▁prev ▁= ▁parent ▁; ▁ngx _ http _ refer er _ conf _ t ▁* ▁conf ▁= ▁child ▁; ▁ngx _ uint _ t ▁n ▁; ▁ngx _ hash _ init _ t ▁hash ▁; ▁ngx _ http _ server _ name _ t ▁* ▁sn ▁; ▁ngx _ http _ core _ srv _ conf _ t ▁* ▁csc f ▁; ▁if ▁( ▁conf ▁-> ▁keys ▁== ▁NULL ▁) ▁{ ▁conf ▁-> ▁hash ▁= ▁prev ▁-> ▁hash ▁; ▁# if ▁( ▁NGX _ PC RE ▁) ▁ngx _ conf _ merge _ ptr _ value ▁( ▁conf ▁-> ▁regex ▁, ▁prev ▁-> ▁regex ▁, ▁NULL ▁) ▁; ▁ngx _ conf _ merge _ ptr _ value ▁( ▁conf ▁-> ▁server _ name _ regex ▁, ▁prev ▁-> ▁server _ name _ regex ▁, ▁NULL ▁) ▁; ▁# endif ▁ngx _ conf _ merge _ value ▁( ▁conf ▁-> ▁no _ refer er ▁, ▁prev ▁-> ▁no _ refer er ▁, ▁0 ▁) ▁; ▁ngx _ conf _ merge _ value ▁( ▁conf ▁-> ▁blocked _ refer er ▁, ▁prev ▁-> ▁blocked _ refer er ▁, ▁0 ▁) ▁; ▁ngx _ conf _ merge _ uint _ value ▁( ▁conf ▁-> ▁refer er _ hash _ max _ size ▁, ▁prev ▁-> ▁refer er _ hash _ max _ size ▁, ▁2048 ▁) ▁; ▁ngx _ conf _ merge _ uint _ value ▁( ▁conf ▁-> ▁refer er _ hash _ bucket _ size ▁, ▁prev ▁-> ▁refer er _ hash _ bucket _ size ▁, ▁64 ▁) ▁; ▁return ▁NGX _ CONF _ OK ▁; ▁} ▁if ▁( ▁conf ▁-> ▁server _ names ▁== ▁1 ▁) ▁{ ▁csc f ▁= ▁ngx _ http _ conf _ get _ module _ srv _ conf ▁( ▁cf ▁, ▁ngx _ http _ core _ module ▁) ▁; ▁sn ▁= ▁csc f ▁-> ▁server _ names ▁. ▁elts ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁csc f ▁-> ▁server _ names ▁. ▁nel ts ▁; ▁n ▁++ ▁) ▁{ ▁# if ▁( ▁NGX _ PC RE ▁) ▁if ▁( ▁sn ▁[ ▁n ▁] ▁. ▁regex ▁) ▁{ ▁if ▁( ▁ngx _ http _ add _ regex _ server _ name ▁( ▁cf ▁, ▁conf ▁, ▁sn ▁[ ▁n ▁] ▁. ▁regex ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁continue ▁; ▁} ▁# endif ▁if ▁( ▁ngx _ http _ add _ refer er ▁( ▁cf ▁, ▁conf ▁-> ▁keys ▁, ▁& ▁sn ▁[ ▁n ▁] ▁. ▁name ▁, ▁NULL ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁} ▁} ▁if ▁( ▁( ▁conf ▁-> ▁no _ refer er ▁== ▁1 ▁|| ▁conf ▁-> ▁blocked _ refer er ▁== ▁1 ▁) ▁&& ▁conf ▁-> ▁keys ▁-> ▁keys ▁. ▁nel ts ▁== ▁0 ▁&& ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ head ▁. ▁nel ts ▁== ▁0 ▁&& ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ tail ▁. ▁nel ts ▁== ▁0 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ EMERG ▁, ▁cf ▁-> ▁log ▁, ▁0 ▁, ▁" the \" none \" or \" blocked \" refer ers are specified " ▁" int he \" valid _ refer ers \" direct ive " ▁" without any valid refer er " ▁) ▁; ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁ngx _ conf _ merge _ uint _ value ▁( ▁conf ▁-> ▁refer er _ hash _ max _ size ▁, ▁prev ▁-> ▁refer er _ hash _ max _ size ▁, ▁2048 ▁) ▁; ▁ngx _ conf _ merge _ uint _ value ▁( ▁conf ▁-> ▁refer er _ hash _ bucket _ size ▁, ▁prev ▁-> ▁refer er _ hash _ bucket _ size ▁, ▁64 ▁) ▁; ▁conf ▁-> ▁refer er _ hash _ bucket _ size ▁= ▁ngx _ align ▁( ▁conf ▁-> ▁refer er _ hash _ bucket _ size ▁, ▁ngx _ cache line _ size ▁) ▁; ▁hash ▁. ▁key ▁= ▁ngx _ hash _ key _ lc ▁; ▁hash ▁. ▁max _ size ▁= ▁conf ▁-> ▁refer er _ hash _ max _ size ▁; ▁hash ▁. ▁bucket _ size ▁= ▁conf ▁-> ▁refer er _ hash _ bucket _ size ▁; ▁hash ▁. ▁name ▁= ▁" refer er _ hash " ▁; ▁hash ▁. ▁pool ▁= ▁cf ▁-> ▁pool ▁; ▁if ▁( ▁conf ▁-> ▁keys ▁-> ▁keys ▁. ▁nel ts ▁) ▁{ ▁hash ▁. ▁hash ▁= ▁& ▁conf ▁-> ▁hash ▁. ▁hash ▁; ▁hash ▁. ▁temp _ pool ▁= ▁NULL ▁; ▁if ▁( ▁ngx _ hash _ init ▁( ▁& ▁hash ▁, ▁conf ▁-> ▁keys ▁-> ▁keys ▁. ▁elts ▁, ▁conf ▁-> ▁keys ▁-> ▁keys ▁. ▁nel ts ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁} ▁if ▁( ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ head ▁. ▁nel ts ▁) ▁{ ▁ngx _ q sort ▁( ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ head ▁. ▁elts ▁, ▁( ▁size _ t ▁) ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ head ▁. ▁nel ts ▁, ▁sizeof ▁( ▁ngx _ hash _ key _ t ▁) ▁, ▁ngx _ http _ cmp _ refer er _ w ildcard s ▁) ▁; ▁hash ▁. ▁hash ▁= ▁NULL ▁; ▁hash ▁. ▁temp _ pool ▁= ▁cf ▁-> ▁temp _ pool ▁; ▁if ▁( ▁ngx _ hash _ w ildcard _ init ▁( ▁& ▁hash ▁, ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ head ▁. ▁elts ▁, ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ head ▁. ▁nel ts ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁conf ▁-> ▁hash ▁. ▁wc _ head ▁= ▁( ▁ngx _ hash _ w ildcard _ t ▁* ▁) ▁hash ▁. ▁hash ▁; ▁} ▁if ▁( ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ tail ▁. ▁nel ts ▁) ▁{ ▁ngx _ q sort ▁( ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ tail ▁. ▁elts ▁, ▁( ▁size _ t ▁) ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ tail ▁. ▁nel ts ▁, ▁sizeof ▁( ▁ngx _ hash _ key _ t ▁) ▁, ▁ngx _ http _ cmp _ refer er _ w ildcard s ▁) ▁; ▁hash ▁. ▁hash ▁= ▁NULL ▁; ▁hash ▁. ▁temp _ pool ▁= ▁cf ▁-> ▁temp _ pool ▁; ▁if ▁( ▁ngx _ hash _ w ildcard _ init ▁( ▁& ▁hash ▁, ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ tail ▁. ▁elts ▁, ▁conf ▁-> ▁keys ▁-> ▁dns _ wc _ tail ▁. ▁nel ts ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁conf ▁-> ▁hash ▁. ▁wc _ tail ▁= ▁( ▁ngx _ hash _ w ildcard _ t ▁* ▁) ▁hash ▁. ▁hash ▁; ▁} ▁# if ▁( ▁NGX _ PC RE ▁) ▁ngx _ conf _ merge _ ptr _ value ▁( ▁conf ▁-> ▁regex ▁, ▁prev ▁-> ▁regex ▁, ▁NULL ▁) ▁; ▁ngx _ conf _ merge _ ptr _ value ▁( ▁conf ▁-> ▁server _ name _ regex ▁, ▁prev ▁-> ▁server _ name _ regex ▁, ▁NULL ▁) ▁; ▁# endif ▁if ▁( ▁conf ▁-> ▁no _ refer er ▁== ▁NGX _ CONF _ UNSET ▁) ▁{ ▁conf ▁-> ▁no _ refer er ▁= ▁0 ▁; ▁} ▁if ▁( ▁conf ▁-> ▁blocked _ refer er ▁== ▁NGX _ CONF _ UNSET ▁) ▁{ ▁conf ▁-> ▁blocked _ refer er ▁= ▁0 ▁; ▁} ▁conf ▁-> ▁keys ▁= ▁NULL ▁; ▁return ▁NGX _ CONF _ OK ▁; ▁}	0
▁static ▁int ▁TIFF Append To Strip ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁strip ▁, ▁uint 8 ▁* ▁data ▁, ▁tm size _ t ▁cc ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Append To Strip " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁uint 64 ▁m ▁; ▁int 64 ▁old _ byte _ count ▁= ▁-1 ▁; ▁if ▁( ▁td ▁-> ▁td _ strip offset _ p ▁[ ▁strip ▁] ▁== ▁0 ▁|| ▁tif ▁-> ▁tif _ cur off ▁== ▁0 ▁) ▁{ ▁assert ▁( ▁td ▁-> ▁td _ n stri ps ▁> ▁0 ▁) ▁; ▁if ▁( ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁!= ▁0 ▁&& ▁td ▁-> ▁td _ strip offset _ p ▁[ ▁strip ▁] ▁!= ▁0 ▁&& ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁>= ▁( ▁uint 64 ▁) ▁cc ▁) ▁{ ▁if ▁( ▁! ▁Seek OK ▁( ▁tif ▁, ▁td ▁-> ▁td _ strip offset _ p ▁[ ▁strip ▁] ▁) ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Seek error at scanline % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁tif ▁-> ▁tif _ row ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁else ▁{ ▁td ▁-> ▁td _ strip offset _ p ▁[ ▁strip ▁] ▁= ▁TIFF Seek File ▁( ▁tif ▁, ▁0 ▁, ▁SEEK _ END ▁) ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ DIRTY STRIP ▁; ▁} ▁tif ▁-> ▁tif _ cur off ▁= ▁td ▁-> ▁td _ strip offset _ p ▁[ ▁strip ▁] ▁; ▁old _ byte _ count ▁= ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁; ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁= ▁0 ▁; ▁} ▁m ▁= ▁tif ▁-> ▁tif _ cur off ▁+ ▁cc ▁; ▁if ▁( ▁! ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ BIG TIFF ▁) ▁) ▁m ▁= ▁( ▁uint 32 ▁) ▁m ▁; ▁if ▁( ▁( ▁m ▁< ▁tif ▁-> ▁tif _ cur off ▁) ▁|| ▁( ▁m ▁< ▁( ▁uint 64 ▁) ▁cc ▁) ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Maximum TIFF file size e xceeded " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁! ▁Write OK ▁( ▁tif ▁, ▁data ▁, ▁cc ▁) ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Write error at scanline % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁tif ▁-> ▁tif _ row ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁tif ▁-> ▁tif _ cur off ▁= ▁m ▁; ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁+= ▁cc ▁; ▁if ▁( ▁( ▁int 64 ▁) ▁td ▁-> ▁td _ strip byte count _ p ▁[ ▁strip ▁] ▁!= ▁old _ byte _ count ▁) ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ DIRTY STRIP ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁void ▁ff _ fill _ rectangle ▁( ▁FF Draw Context ▁* ▁draw ▁, ▁FF Draw Color ▁* ▁color ▁, ▁uint 8_ t ▁* ▁dst ▁[ ▁] ▁, ▁int ▁dst _ lines ize ▁[ ▁] ▁, ▁int ▁dst _ x ▁, ▁int ▁dst _ y ▁, ▁int ▁w ▁, ▁int ▁h ▁) ▁{ ▁int ▁plane ▁, ▁x ▁, ▁y ▁, ▁wp ▁, ▁hp ▁; ▁uint 8_ t ▁* ▁p 0 ▁, ▁* ▁p ▁; ▁for ▁( ▁plane ▁= ▁0 ▁; ▁plane ▁< ▁draw ▁-> ▁nb _ planes ▁; ▁plane ▁++ ▁) ▁{ ▁p 0 ▁= ▁pointer _ at ▁( ▁draw ▁, ▁dst ▁, ▁dst _ lines ize ▁, ▁plane ▁, ▁dst _ x ▁, ▁dst _ y ▁) ▁; ▁wp ▁= ▁( ▁w ▁>> ▁draw ▁-> ▁h sub ▁[ ▁plane ▁] ▁) ▁; ▁hp ▁= ▁( ▁h ▁>> ▁draw ▁-> ▁v sub ▁[ ▁plane ▁] ▁) ▁; ▁if ▁( ▁! ▁hp ▁) ▁return ▁; ▁p ▁= ▁p 0 ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁wp ▁; ▁x ▁++ ▁) ▁{ ▁memcpy ▁( ▁p ▁, ▁color ▁-> ▁comp ▁[ ▁plane ▁] ▁. ▁u 8 ▁, ▁draw ▁-> ▁pixel step ▁[ ▁plane ▁] ▁) ▁; ▁p ▁+= ▁draw ▁-> ▁pixel step ▁[ ▁plane ▁] ▁; ▁} ▁wp ▁*= ▁draw ▁-> ▁pixel step ▁[ ▁plane ▁] ▁; ▁p ▁= ▁p 0 ▁+ ▁dst _ lines ize ▁[ ▁plane ▁] ▁; ▁for ▁( ▁y ▁= ▁1 ▁; ▁y ▁< ▁hp ▁; ▁y ▁++ ▁) ▁{ ▁memcpy ▁( ▁p ▁, ▁p 0 ▁, ▁wp ▁) ▁; ▁p ▁+= ▁dst _ lines ize ▁[ ▁plane ▁] ▁; ▁} ▁} ▁}	1
▁static ▁int ▁web v tt _ event _ to _ ass ▁( ▁AV B Print ▁* ▁buf ▁, ▁const ▁char ▁* ▁p ▁) ▁{ ▁int ▁i ▁, ▁again ▁, ▁skip ▁= ▁0 ▁; ▁while ▁( ▁* ▁p ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁web v tt _ tag _ replace ▁) ▁; ▁i ▁++ ▁) ▁{ ▁const ▁char ▁* ▁from ▁= ▁web v tt _ tag _ replace ▁[ ▁i ▁] ▁. ▁from ▁; ▁const ▁size _ t ▁len ▁= ▁strlen ▁( ▁from ▁) ▁; ▁if ▁( ▁! ▁strncmp ▁( ▁p ▁, ▁from ▁, ▁len ▁) ▁) ▁{ ▁av _ b printf ▁( ▁buf ▁, ▁"% s " ▁, ▁web v tt _ tag _ replace ▁[ ▁i ▁] ▁. ▁to ▁) ▁; ▁p ▁+= ▁len ▁; ▁again ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁! ▁* ▁p ▁) ▁break ▁; ▁if ▁( ▁again ▁) ▁{ ▁again ▁= ▁0 ▁; ▁skip ▁= ▁0 ▁; ▁continue ▁; ▁} ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁) ▁skip ▁= ▁1 ▁; ▁else ▁if ▁( ▁* ▁p ▁== ▁' ▁' ▁) ▁skip ▁= ▁0 ▁; ▁else ▁if ▁( ▁p ▁[ ▁0 ▁] ▁== ▁' ▁\ n ▁' ▁&& ▁p ▁[ ▁1 ▁] ▁) ▁av _ b printf ▁( ▁buf ▁, ▁"\\ N " ▁) ▁; ▁else ▁if ▁( ▁! ▁skip ▁&& ▁* ▁p ▁!= ▁' ▁\ r ▁' ▁) ▁av _ b print _ chars ▁( ▁buf ▁, ▁* ▁p ▁, ▁1 ▁) ▁; ▁p ▁++ ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁av _ cold ▁int ▁q dm 2_ decode _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁Q DM 2 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁uint 8_ t ▁* ▁extradata ▁; ▁int ▁extradata _ size ▁; ▁int ▁tmp _ val ▁, ▁tmp ▁, ▁size ▁; ▁if ▁( ▁! ▁avctx ▁-> ▁extradata ▁|| ▁( ▁avctx ▁-> ▁extradata _ size ▁< ▁48 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" extr ad at am issing ort r unc ated \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁= ▁avctx ▁-> ▁extradata ▁; ▁extradata _ size ▁= ▁avctx ▁-> ▁extradata _ size ▁; ▁while ▁( ▁extradata _ size ▁> ▁7 ▁) ▁{ ▁if ▁( ▁! ▁memcmp ▁( ▁extradata ▁, ▁" fr ma Q DM " ▁, ▁7 ▁) ▁) ▁break ▁; ▁extradata ▁++ ▁; ▁extradata _ size ▁-- ▁; ▁} ▁if ▁( ▁extradata _ size ▁< ▁12 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" not en oug hex tr adata (% i )\ n " ▁, ▁extradata _ size ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁memcmp ▁( ▁extradata ▁, ▁" fr ma Q DM " ▁, ▁7 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid headers , Q DM ? not found \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁extradata ▁[ ▁7 ▁] ▁== ▁' ▁' ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" stream is Q D MC version 1, which is not supported \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁+= ▁8 ▁; ▁extradata _ size ▁-= ▁8 ▁; ▁size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁if ▁( ▁size ▁> ▁extradata _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" extr ad atas iz et oo small ,% i < % i \ n " ▁, ▁extradata _ size ▁, ▁size ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁+= ▁4 ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" size :% d \ n " ▁, ▁size ▁) ▁; ▁if ▁( ▁AV _ RB 32 ▁( ▁extradata ▁) ▁!= ▁M KB ET AG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" inval i dex tr adata , expect ing Q D CA \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁extradata ▁+= ▁8 ▁; ▁avctx ▁-> ▁channels ▁= ▁s ▁-> ▁nb _ channels ▁= ▁s ▁-> ▁channels ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁if ▁( ▁s ▁-> ▁channels ▁> ▁M PA _ MAX _ CHANNELS ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avctx ▁-> ▁sample _ rate ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁s ▁-> ▁group _ size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁s ▁-> ▁fft _ size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁extradata ▁+= ▁4 ▁; ▁s ▁-> ▁checksum _ size ▁= ▁AV _ RB 32 ▁( ▁extradata ▁) ▁; ▁if ▁( ▁s ▁-> ▁checksum _ size ▁>= ▁1 U ▁<< ▁28 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" dat ab locks iz et ool arge (% u )\ n " ▁, ▁s ▁-> ▁checksum _ size ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁fft _ order ▁= ▁av _ log 2 ▁( ▁s ▁-> ▁fft _ size ▁) ▁+ ▁1 ▁; ▁s ▁-> ▁fft _ frame _ size ▁= ▁2 ▁* ▁s ▁-> ▁fft _ size ▁; ▁s ▁-> ▁group _ order ▁= ▁av _ log 2 ▁( ▁s ▁-> ▁group _ size ▁) ▁+ ▁1 ▁; ▁s ▁-> ▁frame _ size ▁= ▁s ▁-> ▁group _ size ▁/ ▁16 ▁; ▁if ▁( ▁s ▁-> ▁frame _ size ▁> ▁Q DM 2_ MAX _ FRAME _ SIZE ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁s ▁-> ▁sub _ sampling ▁= ▁s ▁-> ▁fft _ order ▁- ▁7 ▁; ▁s ▁-> ▁frequency _ range ▁= ▁255 ▁/ ▁( ▁1 ▁<< ▁( ▁2 ▁- ▁s ▁-> ▁sub _ sampling ▁) ▁) ▁; ▁switch ▁( ▁( ▁s ▁-> ▁sub _ sampling ▁* ▁2 ▁+ ▁s ▁-> ▁channels ▁- ▁1 ▁) ▁) ▁{ ▁case ▁0 ▁: ▁tmp ▁= ▁40 ▁; ▁break ▁; ▁case ▁1 ▁: ▁tmp ▁= ▁48 ▁; ▁break ▁; ▁case ▁2 ▁: ▁tmp ▁= ▁56 ▁; ▁break ▁; ▁case ▁3 ▁: ▁tmp ▁= ▁72 ▁; ▁break ▁; ▁case ▁4 ▁: ▁tmp ▁= ▁80 ▁; ▁break ▁; ▁case ▁5 ▁: ▁tmp ▁= ▁100 ▁; ▁break ▁; ▁default ▁: ▁tmp ▁= ▁s ▁-> ▁sub _ sampling ▁; ▁break ▁; ▁} ▁tmp _ val ▁= ▁0 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁1000 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁1 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁14 40 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁2 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁1 760 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁3 ▁; ▁if ▁( ▁( ▁tmp ▁* ▁22 40 ▁) ▁< ▁avctx ▁-> ▁bit _ rate ▁) ▁tmp _ val ▁= ▁4 ▁; ▁s ▁-> ▁cm _ table _ select ▁= ▁tmp _ val ▁; ▁if ▁( ▁s ▁-> ▁sub _ sampling ▁== ▁0 ▁) ▁tmp ▁= ▁7 999 ▁; ▁else ▁tmp ▁= ▁( ▁( ▁- ▁( ▁s ▁-> ▁sub _ sampling ▁- ▁1 ▁) ▁) ▁& ▁8000 ▁) ▁+ ▁20000 ▁; ▁if ▁( ▁tmp ▁< ▁8000 ▁) ▁s ▁-> ▁coeff _ per _ sb _ select ▁= ▁0 ▁; ▁else ▁if ▁( ▁tmp ▁<= ▁16000 ▁) ▁s ▁-> ▁coeff _ per _ sb _ select ▁= ▁1 ▁; ▁else ▁s ▁-> ▁coeff _ per _ sb _ select ▁= ▁2 ▁; ▁if ▁( ▁( ▁s ▁-> ▁fft _ order ▁< ▁7 ▁) ▁|| ▁( ▁s ▁-> ▁fft _ order ▁> ▁9 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown FFT order (% d ), contact the developers !\ n " ▁, ▁s ▁-> ▁fft _ order ▁) ▁; ▁return ▁-1 ▁; ▁} ▁ff _ rd ft _ init ▁( ▁& ▁s ▁-> ▁rd ft _ ctx ▁, ▁s ▁-> ▁fft _ order ▁, ▁ID FT _ C 2 R ▁) ▁; ▁ff _ mp ad sp _ init ▁( ▁& ▁s ▁-> ▁mp ad sp ▁) ▁; ▁q dm 2_ init ▁( ▁s ▁) ▁; ▁avctx ▁-> ▁sample _ fmt ▁= ▁AV _ SAMPLE _ FMT _ S 16 ▁; ▁avcodec _ get _ frame _ defaults ▁( ▁& ▁s ▁-> ▁frame ▁) ▁; ▁avctx ▁-> ▁coded _ frame ▁= ▁& ▁s ▁-> ▁frame ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁inline ▁int ▁wv _ unpack _ mono ▁( ▁W av pack Frame Context ▁* ▁s ▁, ▁Get Bit Context ▁* ▁gb ▁, ▁void ▁* ▁dst ▁, ▁const ▁int ▁type ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁count ▁= ▁0 ▁; ▁int ▁last ▁, ▁t ▁; ▁int ▁A ▁, ▁S ▁, ▁T ▁; ▁int ▁pos ▁= ▁s ▁-> ▁pos ▁; ▁uint 32_ t ▁crc ▁= ▁s ▁-> ▁sc ▁. ▁crc ▁; ▁uint 32_ t ▁crc _ extra _ bits ▁= ▁s ▁-> ▁extra _ sc ▁. ▁crc ▁; ▁int 16_ t ▁* ▁dst 16 ▁= ▁dst ▁; ▁int 32_ t ▁* ▁dst 32 ▁= ▁dst ▁; ▁float ▁* ▁dst fl ▁= ▁dst ▁; ▁s ▁-> ▁one ▁= ▁s ▁-> ▁zero ▁= ▁s ▁-> ▁zero es ▁= ▁0 ▁; ▁do ▁{ ▁T ▁= ▁wv _ get _ value ▁( ▁s ▁, ▁gb ▁, ▁0 ▁, ▁& ▁last ▁) ▁; ▁S ▁= ▁0 ▁; ▁if ▁( ▁last ▁) ▁break ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁terms ▁; ▁i ▁++ ▁) ▁{ ▁t ▁= ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁value ▁; ▁if ▁( ▁t ▁> ▁8 ▁) ▁{ ▁if ▁( ▁t ▁& ▁1 ▁) ▁A ▁= ▁2 U ▁* ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁0 ▁] ▁- ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁1 ▁] ▁; ▁else ▁A ▁= ▁( ▁int ▁) ▁( ▁3 U ▁* ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁0 ▁] ▁- ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁1 ▁] ▁) ▁>> ▁1 ▁; ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁0 ▁] ▁; ▁j ▁= ▁0 ▁; ▁} ▁else ▁{ ▁A ▁= ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁pos ▁] ▁; ▁j ▁= ▁( ▁pos ▁+ ▁t ▁) ▁& ▁7 ▁; ▁} ▁if ▁( ▁type ▁!= ▁AV _ SAMPLE _ FMT _ S 16 P ▁) ▁S ▁= ▁T ▁+ ▁( ▁( ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁weight A ▁* ▁( ▁int 64_ t ▁) ▁A ▁+ ▁512 ▁) ▁>> ▁10 ▁) ▁; ▁else ▁S ▁= ▁T ▁+ ▁( ▁( ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁weight A ▁* ▁A ▁+ ▁512 ▁) ▁>> ▁10 ▁) ▁; ▁if ▁( ▁A ▁&& ▁T ▁) ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁weight A ▁-= ▁( ▁( ▁( ▁( ▁T ▁ ^ ▁A ▁) ▁>> ▁30 ▁) ▁& ▁2 ▁) ▁- ▁1 ▁) ▁* ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁delta ▁; ▁s ▁-> ▁decor r ▁[ ▁i ▁] ▁. ▁samples A ▁[ ▁j ▁] ▁= ▁T ▁= ▁S ▁; ▁} ▁pos ▁= ▁( ▁pos ▁+ ▁1 ▁) ▁& ▁7 ▁; ▁crc ▁= ▁crc ▁* ▁3 ▁+ ▁S ▁; ▁if ▁( ▁type ▁== ▁AV _ SAMPLE _ FMT _ FL TP ▁) ▁{ ▁* ▁dst fl ▁++ ▁= ▁wv _ get _ value _ float ▁( ▁s ▁, ▁& ▁crc _ extra _ bits ▁, ▁S ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁AV _ SAMPLE _ FMT _ S 32 P ▁) ▁{ ▁* ▁dst 32 ▁++ ▁= ▁wv _ get _ value _ integer ▁( ▁s ▁, ▁& ▁crc _ extra _ bits ▁, ▁S ▁) ▁; ▁} ▁else ▁{ ▁* ▁dst 16 ▁++ ▁= ▁wv _ get _ value _ integer ▁( ▁s ▁, ▁& ▁crc _ extra _ bits ▁, ▁S ▁) ▁; ▁} ▁count ▁++ ▁; ▁} ▁while ▁( ▁! ▁last ▁&& ▁count ▁< ▁s ▁-> ▁samples ▁) ▁; ▁wv _ reset _ saved _ context ▁( ▁s ▁) ▁; ▁if ▁( ▁last ▁&& ▁count ▁< ▁s ▁-> ▁samples ▁) ▁{ ▁int ▁size ▁= ▁av _ get _ bytes _ per _ sample ▁( ▁type ▁) ▁; ▁memset ▁( ▁( ▁uint 8_ t ▁* ▁) ▁dst ▁+ ▁count ▁* ▁size ▁, ▁0 ▁, ▁( ▁s ▁-> ▁samples ▁- ▁count ▁) ▁* ▁size ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ CRC CHECK ▁) ▁{ ▁int ▁ret ▁= ▁wv _ check _ crc ▁( ▁s ▁, ▁crc ▁, ▁crc _ extra _ bits ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁&& ▁s ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁return ▁ret ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁crl _ ak id _ check ▁( ▁X 509_ STORE _ CTX ▁* ▁ctx ▁, ▁X 509_ CRL ▁* ▁crl ▁, ▁X 509 ▁* ▁* ▁p iss uer ▁, ▁int ▁* ▁pc rl _ score ▁) ▁{ ▁X 509 ▁* ▁crl _ iss uer ▁= ▁NULL ▁; ▁X 509_ NAME ▁* ▁cn m ▁= ▁X 509_ CRL _ get _ iss uer ▁( ▁crl ▁) ▁; ▁int ▁c idx ▁= ▁ctx ▁-> ▁error _ depth ▁; ▁int ▁i ▁; ▁if ▁( ▁c idx ▁!= ▁sk _ X 509_ num ▁( ▁ctx ▁-> ▁chain ▁) ▁- ▁1 ▁) ▁c idx ▁++ ▁; ▁crl _ iss uer ▁= ▁sk _ X 509_ value ▁( ▁ctx ▁-> ▁chain ▁, ▁c idx ▁) ▁; ▁if ▁( ▁X 509_ check _ ak id ▁( ▁crl _ iss uer ▁, ▁crl ▁-> ▁ak id ▁) ▁== ▁X 509_ V _ OK ▁) ▁{ ▁if ▁( ▁* ▁pc rl _ score ▁& ▁CRL _ SCORE _ IS SU ER _ NAME ▁) ▁{ ▁* ▁pc rl _ score ▁|= ▁CRL _ SCORE _ AK ID ▁| ▁CRL _ SCORE _ IS SU ER _ CERT ▁; ▁* ▁p iss uer ▁= ▁crl _ iss uer ▁; ▁return ▁; ▁} ▁} ▁for ▁( ▁c idx ▁++ ▁; ▁c idx ▁< ▁sk _ X 509_ num ▁( ▁ctx ▁-> ▁chain ▁) ▁; ▁c idx ▁++ ▁) ▁{ ▁crl _ iss uer ▁= ▁sk _ X 509_ value ▁( ▁ctx ▁-> ▁chain ▁, ▁c idx ▁) ▁; ▁if ▁( ▁X 509_ NAME _ cmp ▁( ▁X 509_ get _ subject _ name ▁( ▁crl _ iss uer ▁) ▁, ▁cn m ▁) ▁) ▁continue ▁; ▁if ▁( ▁X 509_ check _ ak id ▁( ▁crl _ iss uer ▁, ▁crl ▁-> ▁ak id ▁) ▁== ▁X 509_ V _ OK ▁) ▁{ ▁* ▁pc rl _ score ▁|= ▁CRL _ SCORE _ AK ID ▁| ▁CRL _ SCORE _ SAME _ PATH ▁; ▁* ▁p iss uer ▁= ▁crl _ iss uer ▁; ▁return ▁; ▁} ▁} ▁if ▁( ▁! ▁( ▁ctx ▁-> ▁param ▁-> ▁flags ▁& ▁X 509_ V _ FLAG _ EXTENDED _ CRL _ SUPPORT ▁) ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ X 509_ num ▁( ▁ctx ▁-> ▁un trusted ▁) ▁; ▁i ▁++ ▁) ▁{ ▁crl _ iss uer ▁= ▁sk _ X 509_ value ▁( ▁ctx ▁-> ▁un trusted ▁, ▁i ▁) ▁; ▁if ▁( ▁X 509_ NAME _ cmp ▁( ▁X 509_ get _ subject _ name ▁( ▁crl _ iss uer ▁) ▁, ▁cn m ▁) ▁) ▁continue ▁; ▁if ▁( ▁X 509_ check _ ak id ▁( ▁crl _ iss uer ▁, ▁crl ▁-> ▁ak id ▁) ▁== ▁X 509_ V _ OK ▁) ▁{ ▁* ▁p iss uer ▁= ▁crl _ iss uer ▁; ▁* ▁pc rl _ score ▁|= ▁CRL _ SCORE _ AK ID ▁; ▁return ▁; ▁} ▁} ▁}	0
▁static ▁int ▁codec _ re init ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁quality ▁) ▁{ ▁N uv Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁width ▁= ▁( ▁width ▁+ ▁1 ▁) ▁& ▁ ~ ▁1 ▁; ▁height ▁= ▁( ▁height ▁+ ▁1 ▁) ▁& ▁ ~ ▁1 ▁; ▁if ▁( ▁quality ▁>= ▁0 ▁) ▁get _ quant _ quality ▁( ▁c ▁, ▁quality ▁) ▁; ▁if ▁( ▁width ▁!= ▁c ▁-> ▁width ▁|| ▁height ▁!= ▁c ▁-> ▁height ▁) ▁{ ▁if ▁( ▁av _ image _ check _ size ▁( ▁height ▁, ▁width ▁, ▁0 ▁, ▁avctx ▁) ▁< ▁0 ▁) ▁return ▁0 ▁; ▁avctx ▁-> ▁width ▁= ▁c ▁-> ▁width ▁= ▁width ▁; ▁avctx ▁-> ▁height ▁= ▁c ▁-> ▁height ▁= ▁height ▁; ▁c ▁-> ▁decomp _ size ▁= ▁c ▁-> ▁height ▁* ▁c ▁-> ▁width ▁* ▁3 ▁/ ▁2 ▁; ▁c ▁-> ▁decomp _ buf ▁= ▁av _ realloc ▁( ▁c ▁-> ▁decomp _ buf ▁, ▁c ▁-> ▁decomp _ size ▁+ ▁AV _ LZ O _ OUTPUT _ PADDING ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁decomp _ buf ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Can ' t allocate de compression buffer .\ n " ▁) ▁; ▁return ▁0 ▁; ▁} ▁rt jpeg _ decode _ init ▁( ▁& ▁c ▁-> ▁rt j ▁, ▁& ▁c ▁-> ▁dsp ▁, ▁c ▁-> ▁width ▁, ▁c ▁-> ▁height ▁, ▁c ▁-> ▁l q ▁, ▁c ▁-> ▁cq ▁) ▁; ▁} ▁else ▁if ▁( ▁quality ▁!= ▁c ▁-> ▁quality ▁) ▁rt jpeg _ decode _ init ▁( ▁& ▁c ▁-> ▁rt j ▁, ▁& ▁c ▁-> ▁dsp ▁, ▁c ▁-> ▁width ▁, ▁c ▁-> ▁height ▁, ▁c ▁-> ▁l q ▁, ▁c ▁-> ▁cq ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁void ▁ip video _ decode _ opcodes ▁( ▁Ip video Context ▁* ▁s ▁, ▁AVFrame ▁* ▁frame ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁unsigned ▁char ▁opcode ▁; ▁int ▁ret ▁; ▁Get Bit Context ▁gb ▁; ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁stream _ ptr ▁, ▁14 ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁is _16 bpp ▁) ▁{ ▁memcpy ▁( ▁frame ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁s ▁-> ▁pal ▁, ▁AV PALETTE _ SIZE ▁) ▁; ▁s ▁-> ▁stride ▁= ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁} ▁else ▁{ ▁s ▁-> ▁stride ▁= ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁>> ▁1 ▁; ▁s ▁-> ▁mv _ ptr ▁= ▁s ▁-> ▁stream _ ptr ▁; ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁mv _ ptr ▁, ▁bytestream 2_ get _ le 16 ▁( ▁& ▁s ▁-> ▁stream _ ptr ▁) ▁) ▁; ▁} ▁s ▁-> ▁line _ inc ▁= ▁s ▁-> ▁stride ▁- ▁8 ▁; ▁s ▁-> ▁upper _ motion _ limit _ offset ▁= ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁- ▁8 ▁) ▁* ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁+ ▁( ▁s ▁-> ▁avctx ▁-> ▁width ▁- ▁8 ▁) ▁* ▁( ▁1 ▁+ ▁s ▁-> ▁is _16 bpp ▁) ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁s ▁-> ▁decoding _ map ▁, ▁s ▁-> ▁decoding _ map _ size ▁* ▁8 ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁s ▁-> ▁avctx ▁-> ▁height ▁; ▁y ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁s ▁-> ▁avctx ▁-> ▁width ▁; ▁x ▁+= ▁8 ▁) ▁{ ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁gb ▁) ▁< ▁4 ▁) ▁return ▁; ▁opcode ▁= ▁get _ bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁ff _ t log ▁( ▁s ▁-> ▁avctx ▁, ▁" block @ (% 3 d ,% 3 d ): encoding 0 x % X , data pt roff set % d \ n " ▁, ▁x ▁, ▁y ▁, ▁opcode ▁, ▁bytestream 2_ tell ▁( ▁& ▁s ▁-> ▁stream _ ptr ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁is _16 bpp ▁) ▁{ ▁s ▁-> ▁pixel _ ptr ▁= ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁x ▁+ ▁y ▁* ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁ret ▁= ▁ip video _ decode _ block ▁[ ▁opcode ▁] ▁( ▁s ▁, ▁frame ▁) ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pixel _ ptr ▁= ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁x ▁* ▁2 ▁+ ▁y ▁* ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁ret ▁= ▁ip video _ decode _ block 16 ▁[ ▁opcode ▁] ▁( ▁s ▁, ▁frame ▁) ▁; ▁} ▁if ▁( ▁ret ▁!= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" decode pro ble mon frame % d , @ block (% d ,% d )\ n " ▁, ▁s ▁-> ▁avctx ▁-> ▁frame _ number ▁, ▁x ▁, ▁y ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁stream _ ptr ▁) ▁> ▁1 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" deco def in ished with % db ytes le fto ver \ n " ▁, ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁stream _ ptr ▁) ▁) ▁; ▁} ▁}	1
▁static ▁void ▁hor Diff 32 ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 8 ▁* ▁cp 0 ▁, ▁tm size _ t ▁cc ▁) ▁{ ▁TIFF Predictor State ▁* ▁sp ▁= ▁Predict or State ▁( ▁tif ▁) ▁; ▁tm size _ t ▁stride ▁= ▁sp ▁-> ▁stride ▁; ▁int 32 ▁* ▁wp ▁= ▁( ▁int 32 ▁* ▁) ▁cp 0 ▁; ▁tm size _ t ▁wc ▁= ▁cc ▁/ ▁4 ▁; ▁assert ▁( ▁( ▁cc ▁% ▁( ▁4 ▁* ▁stride ▁) ▁) ▁== ▁0 ▁) ▁; ▁if ▁( ▁wc ▁> ▁stride ▁) ▁{ ▁wc ▁-= ▁stride ▁; ▁wp ▁+= ▁wc ▁- ▁1 ▁; ▁do ▁{ ▁REPEAT 4 ▁( ▁stride ▁, ▁wp ▁[ ▁stride ▁] ▁-= ▁wp ▁[ ▁0 ▁] ▁; ▁wp ▁-- ▁) ▁wc ▁-= ▁stride ▁; ▁} ▁while ▁( ▁wc ▁> ▁0 ▁) ▁; ▁} ▁}	1
▁int ▁EC _ GROUP _ check ▁( ▁const ▁EC _ GROUP ▁* ▁group ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁const ▁BIGNUM ▁* ▁order ▁; ▁BN _ CTX ▁* ▁new _ ctx ▁= ▁NULL ▁; ▁EC _ POINT ▁* ▁point ▁= ▁NULL ▁; ▁if ▁( ▁( ▁group ▁-> ▁meth ▁-> ▁flags ▁& ▁EC _ FLAGS _ CUSTOM _ CURVE ▁) ▁!= ▁0 ▁) ▁return ▁1 ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁ctx ▁= ▁new _ ctx ▁= ▁BN _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GROUP _ CHECK ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁if ▁( ▁! ▁EC _ GROUP _ check _ disc rimin ant ▁( ▁group ▁, ▁ctx ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GROUP _ CHECK ▁, ▁EC _ R _ DIS CR IM IN ANT _ IS _ ZERO ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁group ▁-> ▁generator ▁== ▁NULL ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GROUP _ CHECK ▁, ▁EC _ R _ UNDEFINED _ GENERATOR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁EC _ POINT _ is _ on _ curve ▁( ▁group ▁, ▁group ▁-> ▁generator ▁, ▁ctx ▁) ▁<= ▁0 ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GROUP _ CHECK ▁, ▁EC _ R _ POINT _ IS _ NOT _ ON _ CURVE ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁point ▁= ▁EC _ POINT _ new ▁( ▁group ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁order ▁= ▁EC _ GROUP _ get 0_ order ▁( ▁group ▁) ▁; ▁if ▁( ▁order ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁order ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GROUP _ CHECK ▁, ▁EC _ R _ UNDEFINED _ ORDER ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁EC _ POINT _ mul ▁( ▁group ▁, ▁point ▁, ▁order ▁, ▁NULL ▁, ▁NULL ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EC _ POINT _ is _ at _ infinity ▁( ▁group ▁, ▁point ▁) ▁) ▁{ ▁EC err ▁( ▁EC _ F _ EC _ GROUP _ CHECK ▁, ▁EC _ R _ INVALID _ GROUP _ ORDER ▁) ▁; ▁goto ▁err ▁; ▁} ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ free ▁( ▁new _ ctx ▁) ▁; ▁EC _ POINT _ free ▁( ▁point ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁void ▁F UN CC ▁( ▁pred 4 x 4_ top _ dc ▁) ▁( ▁uint 8_ t ▁* ▁_ src ▁, ▁const ▁uint 8_ t ▁* ▁top right ▁, ▁int ▁_ stride ▁) ▁{ ▁pixel ▁* ▁src ▁= ▁( ▁pixel ▁* ▁) ▁_ src ▁; ▁int ▁stride ▁= ▁_ stride ▁/ ▁sizeof ▁( ▁pixel ▁) ▁; ▁const ▁int ▁dc ▁= ▁( ▁src ▁[ ▁- ▁stride ▁] ▁+ ▁src ▁[ ▁1 ▁- ▁stride ▁] ▁+ ▁src ▁[ ▁2 ▁- ▁stride ▁] ▁+ ▁src ▁[ ▁3 ▁- ▁stride ▁] ▁+ ▁2 ▁) ▁>> ▁2 ▁; ▁const ▁pixel 4 ▁a ▁= ▁PIXEL _ SPL AT _ X 4 ▁( ▁dc ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁0 ▁* ▁stride ▁, ▁a ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁1 ▁* ▁stride ▁, ▁a ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁2 ▁* ▁stride ▁, ▁a ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁3 ▁* ▁stride ▁, ▁a ▁) ▁; ▁}	0
▁static ▁av _ always _ inline ▁int ▁decode _ l uma _ residual ▁( ▁const ▁H 264 Context ▁* ▁h ▁, ▁H 264 Slice Context ▁* ▁sl ▁, ▁Get Bit Context ▁* ▁gb ▁, ▁const ▁uint 8_ t ▁* ▁scan ▁, ▁const ▁uint 8_ t ▁* ▁scan 8 x 8 ▁, ▁int ▁pixel _ shift ▁, ▁int ▁mb _ type ▁, ▁int ▁cb p ▁, ▁int ▁p ▁) ▁{ ▁int ▁i 4 x 4 ▁, ▁i 8 x 8 ▁; ▁int ▁q scale ▁= ▁p ▁== ▁0 ▁? ▁sl ▁-> ▁q scale ▁: ▁sl ▁-> ▁chroma _ qp ▁[ ▁p ▁- ▁1 ▁] ▁; ▁if ▁( ▁IS _ INTR A 16 x 16 ▁( ▁mb _ type ▁) ▁) ▁{ ▁AV _ ZERO 128 ▁( ▁sl ▁-> ▁mb _ l uma _ dc ▁[ ▁p ▁] ▁+ ▁0 ▁) ▁; ▁AV _ ZERO 128 ▁( ▁sl ▁-> ▁mb _ l uma _ dc ▁[ ▁p ▁] ▁+ ▁8 ▁) ▁; ▁AV _ ZERO 128 ▁( ▁sl ▁-> ▁mb _ l uma _ dc ▁[ ▁p ▁] ▁+ ▁16 ▁) ▁; ▁AV _ ZERO 128 ▁( ▁sl ▁-> ▁mb _ l uma _ dc ▁[ ▁p ▁] ▁+ ▁24 ▁) ▁; ▁if ▁( ▁decode _ residual ▁( ▁h ▁, ▁sl ▁, ▁gb ▁, ▁sl ▁-> ▁mb _ l uma _ dc ▁[ ▁p ▁] ▁, ▁LU MA _ DC _ BLOCK _ INDEX ▁+ ▁p ▁, ▁scan ▁, ▁NULL ▁, ▁16 ▁) ▁< ▁0 ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁assert ▁( ▁( ▁cb p ▁& ▁15 ▁) ▁== ▁0 ▁|| ▁( ▁cb p ▁& ▁15 ▁) ▁== ▁15 ▁) ▁; ▁if ▁( ▁cb p ▁& ▁15 ▁) ▁{ ▁for ▁( ▁i 8 x 8 ▁= ▁0 ▁; ▁i 8 x 8 ▁< ▁4 ▁; ▁i 8 x 8 ▁++ ▁) ▁{ ▁for ▁( ▁i 4 x 4 ▁= ▁0 ▁; ▁i 4 x 4 ▁< ▁4 ▁; ▁i 4 x 4 ▁++ ▁) ▁{ ▁const ▁int ▁index ▁= ▁i 4 x 4 ▁+ ▁4 ▁* ▁i 8 x 8 ▁+ ▁p ▁* ▁16 ▁; ▁if ▁( ▁decode _ residual ▁( ▁h ▁, ▁sl ▁, ▁gb ▁, ▁sl ▁-> ▁mb ▁+ ▁( ▁16 ▁* ▁index ▁<< ▁pixel _ shift ▁) ▁, ▁index ▁, ▁scan ▁+ ▁1 ▁, ▁h ▁-> ▁ps ▁. ▁pps ▁-> ▁de quant 4_ coeff ▁[ ▁p ▁] ▁[ ▁q scale ▁] ▁, ▁15 ▁) ▁< ▁0 ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁} ▁} ▁return ▁0 xf ▁; ▁} ▁else ▁{ ▁fill _ rectangle ▁( ▁& ▁sl ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁p ▁* ▁16 ▁] ▁] ▁, ▁4 ▁, ▁4 ▁, ▁8 ▁, ▁0 ▁, ▁1 ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁else ▁{ ▁int ▁cq m ▁= ▁( ▁IS _ INTR A ▁( ▁mb _ type ▁) ▁? ▁0 ▁: ▁3 ▁) ▁+ ▁p ▁; ▁int ▁new _ cb p ▁= ▁0 ▁; ▁for ▁( ▁i 8 x 8 ▁= ▁0 ▁; ▁i 8 x 8 ▁< ▁4 ▁; ▁i 8 x 8 ▁++ ▁) ▁{ ▁if ▁( ▁cb p ▁& ▁( ▁1 ▁<< ▁i 8 x 8 ▁) ▁) ▁{ ▁if ▁( ▁IS _8 x 8 D CT ▁( ▁mb _ type ▁) ▁) ▁{ ▁int 16_ t ▁* ▁buf ▁= ▁& ▁sl ▁-> ▁mb ▁[ ▁64 ▁* ▁i 8 x 8 ▁+ ▁256 ▁* ▁p ▁<< ▁pixel _ shift ▁] ▁; ▁uint 8_ t ▁* ▁nnz ▁; ▁for ▁( ▁i 4 x 4 ▁= ▁0 ▁; ▁i 4 x 4 ▁< ▁4 ▁; ▁i 4 x 4 ▁++ ▁) ▁{ ▁const ▁int ▁index ▁= ▁i 4 x 4 ▁+ ▁4 ▁* ▁i 8 x 8 ▁+ ▁p ▁* ▁16 ▁; ▁if ▁( ▁decode _ residual ▁( ▁h ▁, ▁sl ▁, ▁gb ▁, ▁buf ▁, ▁index ▁, ▁scan 8 x 8 ▁+ ▁16 ▁* ▁i 4 x 4 ▁, ▁h ▁-> ▁ps ▁. ▁pps ▁-> ▁de quant 8_ coeff ▁[ ▁cq m ▁] ▁[ ▁q scale ▁] ▁, ▁16 ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁nnz ▁= ▁& ▁sl ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁4 ▁* ▁i 8 x 8 ▁+ ▁p ▁* ▁16 ▁] ▁] ▁; ▁nnz ▁[ ▁0 ▁] ▁+= ▁nnz ▁[ ▁1 ▁] ▁+ ▁nnz ▁[ ▁8 ▁] ▁+ ▁nnz ▁[ ▁9 ▁] ▁; ▁new _ cb p ▁|= ▁! ▁! ▁nnz ▁[ ▁0 ▁] ▁<< ▁i 8 x 8 ▁; ▁} ▁else ▁{ ▁for ▁( ▁i 4 x 4 ▁= ▁0 ▁; ▁i 4 x 4 ▁< ▁4 ▁; ▁i 4 x 4 ▁++ ▁) ▁{ ▁const ▁int ▁index ▁= ▁i 4 x 4 ▁+ ▁4 ▁* ▁i 8 x 8 ▁+ ▁p ▁* ▁16 ▁; ▁if ▁( ▁decode _ residual ▁( ▁h ▁, ▁sl ▁, ▁gb ▁, ▁sl ▁-> ▁mb ▁+ ▁( ▁16 ▁* ▁index ▁<< ▁pixel _ shift ▁) ▁, ▁index ▁, ▁scan ▁, ▁h ▁-> ▁ps ▁. ▁pps ▁-> ▁de quant 4_ coeff ▁[ ▁cq m ▁] ▁[ ▁q scale ▁] ▁, ▁16 ▁) ▁< ▁0 ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁new _ cb p ▁|= ▁sl ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁index ▁] ▁] ▁<< ▁i 8 x 8 ▁; ▁} ▁} ▁} ▁else ▁{ ▁uint 8_ t ▁* ▁const ▁nnz ▁= ▁& ▁sl ▁-> ▁non _ zero _ count _ cache ▁[ ▁scan 8 ▁[ ▁4 ▁* ▁i 8 x 8 ▁+ ▁p ▁* ▁16 ▁] ▁] ▁; ▁nnz ▁[ ▁0 ▁] ▁= ▁nnz ▁[ ▁1 ▁] ▁= ▁nnz ▁[ ▁8 ▁] ▁= ▁nnz ▁[ ▁9 ▁] ▁= ▁0 ▁; ▁} ▁} ▁return ▁new _ cb p ▁; ▁} ▁}	0
▁static ▁void ▁mp 3_ update _ x ing ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁MP 3 Context ▁* ▁mp 3 ▁= ▁s ▁-> ▁priv _ data ▁; ▁AV Replay Gain ▁* ▁rg ▁; ▁uint 16_ t ▁tag _ crc ▁; ▁uint 8_ t ▁* ▁toc ▁; ▁int ▁i ▁, ▁rg _ size ▁; ▁if ▁( ▁! ▁mp 3 ▁-> ▁has _ variable _ bitrate ▁) ▁AV _ WL 32 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁, ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁; ▁AV _ WB 32 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁8 ▁, ▁mp 3 ▁-> ▁frames ▁) ▁; ▁AV _ WB 32 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁12 ▁, ▁mp 3 ▁-> ▁size ▁) ▁; ▁toc ▁= ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁16 ▁; ▁toc ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁X ING _ TOC _ SIZE ▁; ▁++ ▁i ▁) ▁{ ▁int ▁j ▁= ▁i ▁* ▁mp 3 ▁-> ▁pos ▁/ ▁X ING _ TOC _ SIZE ▁; ▁int ▁seek _ point ▁= ▁256 LL ▁* ▁mp 3 ▁-> ▁bag ▁[ ▁j ▁] ▁/ ▁mp 3 ▁-> ▁size ▁; ▁toc ▁[ ▁i ▁] ▁= ▁FF MIN ▁( ▁seek _ point ▁, ▁255 ▁) ▁; ▁} ▁rg ▁= ▁( ▁AV Replay Gain ▁* ▁) ▁av _ stream _ get _ side _ data ▁( ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁, ▁AV _ PKT _ DATA _ RE PLAY GAIN ▁, ▁& ▁rg _ size ▁) ▁; ▁if ▁( ▁rg ▁&& ▁rg _ size ▁>= ▁sizeof ▁( ▁* ▁rg ▁) ▁) ▁{ ▁uint 16_ t ▁val ▁; ▁AV _ WB 32 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁131 ▁, ▁av _ re scale ▁( ▁rg ▁-> ▁track _ peak ▁, ▁1 ▁<< ▁23 ▁, ▁100000 ▁) ▁) ▁; ▁if ▁( ▁rg ▁-> ▁track _ gain ▁!= ▁INT 32_ MIN ▁) ▁{ ▁val ▁= ▁FF ABS ▁( ▁rg ▁-> ▁track _ gain ▁/ ▁10000 ▁) ▁& ▁( ▁( ▁1 ▁<< ▁9 ▁) ▁- ▁1 ▁) ▁; ▁val ▁|= ▁( ▁rg ▁-> ▁track _ gain ▁< ▁0 ▁) ▁<< ▁9 ▁; ▁val ▁|= ▁1 ▁<< ▁13 ▁; ▁AV _ WB 16 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁135 ▁, ▁val ▁) ▁; ▁} ▁if ▁( ▁rg ▁-> ▁album _ gain ▁!= ▁INT 32_ MIN ▁) ▁{ ▁val ▁= ▁FF ABS ▁( ▁rg ▁-> ▁album _ gain ▁/ ▁10000 ▁) ▁& ▁( ▁( ▁1 ▁<< ▁9 ▁) ▁- ▁1 ▁) ▁; ▁val ▁|= ▁( ▁rg ▁-> ▁album _ gain ▁< ▁0 ▁) ▁<< ▁9 ▁; ▁val ▁|= ▁1 ▁<< ▁14 ▁; ▁AV _ WB 16 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁13 7 ▁, ▁val ▁) ▁; ▁} ▁} ▁AV _ WB 32 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁X ING _ SIZE ▁- ▁8 ▁, ▁mp 3 ▁-> ▁audio _ size ▁) ▁; ▁AV _ WB 16 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁X ING _ SIZE ▁- ▁4 ▁, ▁mp 3 ▁-> ▁audio _ crc ▁) ▁; ▁tag _ crc ▁= ▁av _ crc ▁( ▁av _ crc _ get _ table ▁( ▁AV _ CRC _16_ AN SI _ LE ▁) ▁, ▁0 ▁, ▁mp 3 ▁-> ▁x ing _ frame ▁, ▁190 ▁) ▁; ▁AV _ WB 16 ▁( ▁mp 3 ▁-> ▁x ing _ frame ▁+ ▁mp 3 ▁-> ▁x ing _ offset ▁+ ▁X ING _ SIZE ▁- ▁2 ▁, ▁tag _ crc ▁) ▁; ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁mp 3 ▁-> ▁x ing _ frame _ offset ▁, ▁SEEK _ SET ▁) ▁; ▁avio _ write ▁( ▁s ▁-> ▁pb ▁, ▁mp 3 ▁-> ▁x ing _ frame ▁, ▁mp 3 ▁-> ▁x ing _ frame _ size ▁) ▁; ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁0 ▁, ▁SEEK _ END ▁) ▁; ▁}	0
▁ngx _ int _ t ▁ngx _ hash _ add _ key ▁( ▁ngx _ hash _ keys _ arrays _ t ▁* ▁ha ▁, ▁ngx _ str _ t ▁* ▁key ▁, ▁void ▁* ▁value ▁, ▁ngx _ uint _ t ▁flags ▁) ▁{ ▁size _ t ▁len ▁; ▁u _ char ▁* ▁p ▁; ▁ngx _ str _ t ▁* ▁name ▁; ▁ngx _ uint _ t ▁i ▁, ▁k ▁, ▁n ▁, ▁skip ▁, ▁last ▁; ▁ngx _ array _ t ▁* ▁keys ▁, ▁* ▁hw c ▁; ▁ngx _ hash _ key _ t ▁* ▁hk ▁; ▁last ▁= ▁key ▁-> ▁len ▁; ▁if ▁( ▁flags ▁& ▁NGX _ HASH _ W ILDCARD _ KEY ▁) ▁{ ▁n ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁key ▁-> ▁len ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁key ▁-> ▁data ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁++ ▁n ▁> ▁1 ▁) ▁{ ▁return ▁NGX _ DECL INED ▁; ▁} ▁} ▁if ▁( ▁key ▁-> ▁data ▁[ ▁i ▁] ▁== ▁' ▁' ▁&& ▁key ▁-> ▁data ▁[ ▁i ▁+ ▁1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁return ▁NGX _ DECL INED ▁; ▁} ▁} ▁if ▁( ▁key ▁-> ▁len ▁> ▁1 ▁&& ▁key ▁-> ▁data ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁skip ▁= ▁1 ▁; ▁goto ▁wildcard ▁; ▁} ▁if ▁( ▁key ▁-> ▁len ▁> ▁2 ▁) ▁{ ▁if ▁( ▁key ▁-> ▁data ▁[ ▁0 ▁] ▁== ▁' ▁' ▁&& ▁key ▁-> ▁data ▁[ ▁1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁skip ▁= ▁2 ▁; ▁goto ▁wildcard ▁; ▁} ▁if ▁( ▁key ▁-> ▁data ▁[ ▁i ▁- ▁2 ▁] ▁== ▁' ▁' ▁&& ▁key ▁-> ▁data ▁[ ▁i ▁- ▁1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁skip ▁= ▁0 ▁; ▁last ▁-= ▁2 ▁; ▁goto ▁wildcard ▁; ▁} ▁} ▁if ▁( ▁n ▁) ▁{ ▁return ▁NGX _ DECL INED ▁; ▁} ▁} ▁k ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁last ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁( ▁flags ▁& ▁NGX _ HASH _ READONLY _ KEY ▁) ▁) ▁{ ▁key ▁-> ▁data ▁[ ▁i ▁] ▁= ▁ngx _ tolower ▁( ▁key ▁-> ▁data ▁[ ▁i ▁] ▁) ▁; ▁} ▁k ▁= ▁ngx _ hash ▁( ▁k ▁, ▁key ▁-> ▁data ▁[ ▁i ▁] ▁) ▁; ▁} ▁k ▁%= ▁ha ▁-> ▁hsize ▁; ▁name ▁= ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁. ▁elts ▁; ▁if ▁( ▁name ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁. ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁last ▁!= ▁name ▁[ ▁i ▁] ▁. ▁len ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁ngx _ strncmp ▁( ▁key ▁-> ▁data ▁, ▁name ▁[ ▁i ▁] ▁. ▁data ▁, ▁last ▁) ▁== ▁0 ▁) ▁{ ▁return ▁NGX _ BUSY ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁ngx _ array _ init ▁( ▁& ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁, ▁ha ▁-> ▁temp _ pool ▁, ▁4 ▁, ▁sizeof ▁( ▁ngx _ str _ t ▁) ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁} ▁name ▁= ▁ngx _ array _ push ▁( ▁& ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁) ▁; ▁if ▁( ▁name ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁* ▁name ▁= ▁* ▁key ▁; ▁hk ▁= ▁ngx _ array _ push ▁( ▁& ▁ha ▁-> ▁keys ▁) ▁; ▁if ▁( ▁hk ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁hk ▁-> ▁key ▁= ▁* ▁key ▁; ▁hk ▁-> ▁key _ hash ▁= ▁ngx _ hash _ key ▁( ▁key ▁-> ▁data ▁, ▁last ▁) ▁; ▁hk ▁-> ▁value ▁= ▁value ▁; ▁return ▁NGX _ OK ▁; ▁wildcard ▁: ▁k ▁= ▁ngx _ hash _ str low ▁( ▁& ▁key ▁-> ▁data ▁[ ▁skip ▁] ▁, ▁& ▁key ▁-> ▁data ▁[ ▁skip ▁] ▁, ▁last ▁- ▁skip ▁) ▁; ▁k ▁%= ▁ha ▁-> ▁hsize ▁; ▁if ▁( ▁skip ▁== ▁1 ▁) ▁{ ▁name ▁= ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁. ▁elts ▁; ▁if ▁( ▁name ▁) ▁{ ▁len ▁= ▁last ▁- ▁skip ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁. ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁len ▁!= ▁name ▁[ ▁i ▁] ▁. ▁len ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁ngx _ strncmp ▁( ▁& ▁key ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁name ▁[ ▁i ▁] ▁. ▁data ▁, ▁len ▁) ▁== ▁0 ▁) ▁{ ▁return ▁NGX _ BUSY ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁ngx _ array _ init ▁( ▁& ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁, ▁ha ▁-> ▁temp _ pool ▁, ▁4 ▁, ▁sizeof ▁( ▁ngx _ str _ t ▁) ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁} ▁name ▁= ▁ngx _ array _ push ▁( ▁& ▁ha ▁-> ▁keys _ hash ▁[ ▁k ▁] ▁) ▁; ▁if ▁( ▁name ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁name ▁-> ▁len ▁= ▁last ▁- ▁1 ▁; ▁name ▁-> ▁data ▁= ▁ngx _ pn alloc ▁( ▁ha ▁-> ▁temp _ pool ▁, ▁name ▁-> ▁len ▁) ▁; ▁if ▁( ▁name ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁ngx _ memcpy ▁( ▁name ▁-> ▁data ▁, ▁& ▁key ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁name ▁-> ▁len ▁) ▁; ▁} ▁if ▁( ▁skip ▁) ▁{ ▁p ▁= ▁ngx _ pn alloc ▁( ▁ha ▁-> ▁temp _ pool ▁, ▁last ▁) ▁; ▁if ▁( ▁p ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁len ▁= ▁0 ▁; ▁n ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁last ▁- ▁1 ▁; ▁i ▁; ▁i ▁-- ▁) ▁{ ▁if ▁( ▁key ▁-> ▁data ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁ngx _ memcpy ▁( ▁& ▁p ▁[ ▁n ▁] ▁, ▁& ▁key ▁-> ▁data ▁[ ▁i ▁+ ▁1 ▁] ▁, ▁len ▁) ▁; ▁n ▁+= ▁len ▁; ▁p ▁[ ▁n ▁++ ▁] ▁= ▁' ▁' ▁; ▁len ▁= ▁0 ▁; ▁continue ▁; ▁} ▁len ▁++ ▁; ▁} ▁if ▁( ▁len ▁) ▁{ ▁ngx _ memcpy ▁( ▁& ▁p ▁[ ▁n ▁] ▁, ▁& ▁key ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁len ▁) ▁; ▁n ▁+= ▁len ▁; ▁} ▁p ▁[ ▁n ▁] ▁= ▁' ▁\0 ▁' ▁; ▁hw c ▁= ▁& ▁ha ▁-> ▁dns _ wc _ head ▁; ▁keys ▁= ▁& ▁ha ▁-> ▁dns _ wc _ head _ hash ▁[ ▁k ▁] ▁; ▁} ▁else ▁{ ▁last ▁++ ▁; ▁p ▁= ▁ngx _ pn alloc ▁( ▁ha ▁-> ▁temp _ pool ▁, ▁last ▁) ▁; ▁if ▁( ▁p ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁ngx _ cpy strn ▁( ▁p ▁, ▁key ▁-> ▁data ▁, ▁last ▁) ▁; ▁hw c ▁= ▁& ▁ha ▁-> ▁dns _ wc _ tail ▁; ▁keys ▁= ▁& ▁ha ▁-> ▁dns _ wc _ tail _ hash ▁[ ▁k ▁] ▁; ▁} ▁name ▁= ▁keys ▁-> ▁elts ▁; ▁if ▁( ▁name ▁) ▁{ ▁len ▁= ▁last ▁- ▁skip ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁keys ▁-> ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁len ▁!= ▁name ▁[ ▁i ▁] ▁. ▁len ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁ngx _ strncmp ▁( ▁key ▁-> ▁data ▁+ ▁skip ▁, ▁name ▁[ ▁i ▁] ▁. ▁data ▁, ▁len ▁) ▁== ▁0 ▁) ▁{ ▁return ▁NGX _ BUSY ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁ngx _ array _ init ▁( ▁keys ▁, ▁ha ▁-> ▁temp _ pool ▁, ▁4 ▁, ▁sizeof ▁( ▁ngx _ str _ t ▁) ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁} ▁name ▁= ▁ngx _ array _ push ▁( ▁keys ▁) ▁; ▁if ▁( ▁name ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁name ▁-> ▁len ▁= ▁last ▁- ▁skip ▁; ▁name ▁-> ▁data ▁= ▁ngx _ pn alloc ▁( ▁ha ▁-> ▁temp _ pool ▁, ▁name ▁-> ▁len ▁) ▁; ▁if ▁( ▁name ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁ngx _ memcpy ▁( ▁name ▁-> ▁data ▁, ▁key ▁-> ▁data ▁+ ▁skip ▁, ▁name ▁-> ▁len ▁) ▁; ▁hk ▁= ▁ngx _ array _ push ▁( ▁hw c ▁) ▁; ▁if ▁( ▁hk ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁hk ▁-> ▁key ▁. ▁len ▁= ▁last ▁- ▁1 ▁; ▁hk ▁-> ▁key ▁. ▁data ▁= ▁p ▁; ▁hk ▁-> ▁key _ hash ▁= ▁0 ▁; ▁hk ▁-> ▁value ▁= ▁value ▁; ▁return ▁NGX _ OK ▁; ▁}	1
▁void ▁* ▁OPENSSL _ sk _ delete ▁( ▁OPENSSL _ STACK ▁* ▁st ▁, ▁int ▁loc ▁) ▁{ ▁const ▁void ▁* ▁ret ▁; ▁if ▁( ▁st ▁== ▁NULL ▁|| ▁loc ▁< ▁0 ▁|| ▁loc ▁>= ▁st ▁-> ▁num ▁) ▁return ▁NULL ▁; ▁ret ▁= ▁st ▁-> ▁data ▁[ ▁loc ▁] ▁; ▁if ▁( ▁loc ▁!= ▁st ▁-> ▁num ▁- ▁1 ▁) ▁memmove ▁( ▁& ▁st ▁-> ▁data ▁[ ▁loc ▁] ▁, ▁& ▁st ▁-> ▁data ▁[ ▁loc ▁+ ▁1 ▁] ▁, ▁sizeof ▁( ▁st ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁* ▁( ▁st ▁-> ▁num ▁- ▁loc ▁- ▁1 ▁) ▁) ▁; ▁st ▁-> ▁num ▁-- ▁; ▁return ▁( ▁void ▁* ▁) ▁ret ▁; ▁}	0
▁static ▁inline ▁void ▁q pel _ motion ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁field _ based ▁, ▁int ▁bottom _ field ▁, ▁int ▁field _ select ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁q pel _ mc _ func ▁( ▁* ▁q pix _ op ▁) ▁[ ▁16 ▁] ▁, ▁int ▁motion _ x ▁, ▁int ▁motion _ y ▁, ▁int ▁h ▁) ▁{ ▁uint 8_ t ▁* ▁ptr _ y ▁, ▁* ▁ptr _ cb ▁, ▁* ▁ptr _ cr ▁; ▁int ▁d xy ▁, ▁uv d xy ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁, ▁uv src _ x ▁, ▁uv src _ y ▁, ▁v _ edge _ pos ▁, ▁linesize ▁, ▁uv lines ize ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁3 ▁) ▁<< ▁2 ▁) ▁| ▁( ▁motion _ x ▁& ▁3 ▁) ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁2 ▁) ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁( ▁16 ▁>> ▁field _ based ▁) ▁+ ▁( ▁motion _ y ▁>> ▁2 ▁) ▁; ▁v _ edge _ pos ▁= ▁s ▁-> ▁v _ edge _ pos ▁>> ▁field _ based ▁; ▁linesize ▁= ▁s ▁-> ▁linesize ▁<< ▁field _ based ▁; ▁uv lines ize ▁= ▁s ▁-> ▁uv lines ize ▁<< ▁field _ based ▁; ▁if ▁( ▁field _ based ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁>> ▁1 ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ Q PE L _ CH RO MA 2 ▁) ▁{ ▁static ▁const ▁int ▁rt ab ▁[ ▁8 ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁+ ▁rt ab ▁[ ▁motion _ x ▁& ▁7 ▁] ▁; ▁my ▁= ▁( ▁motion _ y ▁>> ▁1 ▁) ▁+ ▁rt ab ▁[ ▁motion _ y ▁& ▁7 ▁] ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ Q PE L _ CH RO MA ▁) ▁{ ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁my ▁= ▁( ▁motion _ y ▁>> ▁1 ▁) ▁| ▁( ▁motion _ y ▁& ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁/ ▁2 ▁; ▁} ▁mx ▁= ▁( ▁mx ▁>> ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁my ▁= ▁( ▁my ▁>> ▁1 ▁) ▁| ▁( ▁my ▁& ▁1 ▁) ▁; ▁uv d xy ▁= ▁( ▁mx ▁& ▁1 ▁) ▁| ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁; ▁mx ▁>>= ▁1 ▁; ▁my ▁>>= ▁1 ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁uv src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁( ▁8 ▁>> ▁field _ based ▁) ▁+ ▁my ▁; ▁ptr _ y ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁src _ y ▁* ▁linesize ▁+ ▁src _ x ▁; ▁ptr _ cb ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁ptr _ cr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁src _ x ▁> ▁FF MAX ▁( ▁s ▁-> ▁h _ edge _ pos ▁- ▁( ▁motion _ x ▁& ▁3 ▁) ▁- ▁16 ▁, ▁0 ▁) ▁|| ▁( ▁unsigned ▁) ▁src _ y ▁> ▁FF MAX ▁( ▁v _ edge _ pos ▁- ▁( ▁motion _ y ▁& ▁3 ▁) ▁- ▁h ▁, ▁0 ▁) ▁) ▁{ ▁s ▁-> ▁dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr _ y ▁, ▁s ▁-> ▁linesize ▁, ▁17 ▁, ▁17 ▁+ ▁field _ based ▁, ▁src _ x ▁, ▁src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr _ y ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁uv buf ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁+ ▁18 ▁* ▁s ▁-> ▁linesize ▁; ▁s ▁-> ▁dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁, ▁ptr _ cb ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁+ ▁16 ▁, ▁ptr _ cr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr _ cb ▁= ▁uv buf ▁; ▁ptr _ cr ▁= ▁uv buf ▁+ ▁16 ▁; ▁} ▁} ▁if ▁( ▁! ▁field _ based ▁) ▁q pix _ op ▁[ ▁0 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁) ▁; ▁else ▁{ ▁if ▁( ▁bottom _ field ▁) ▁{ ▁dest _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁dest _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁dest _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁if ▁( ▁field _ select ▁) ▁{ ▁ptr _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁ptr _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁ptr _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁q pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁) ▁; ▁q pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁, ▁ptr _ y ▁+ ▁8 ▁, ▁linesize ▁) ▁; ▁} ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr _ cr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr _ cb ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁} ▁}	1
▁static ▁int ▁aes _ ecb ▁( ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁unsigned ▁int ▁inl ▁) ▁{ ▁RI JN DA EL _ KEY ▁* ▁k ▁= ▁ctx ▁-> ▁cipher _ data ▁; ▁while ▁( ▁inl ▁> ▁0 ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁encrypt ▁) ▁ri j nd ael Encrypt ▁( ▁k ▁-> ▁rd _ key ▁, ▁k ▁-> ▁rounds ▁, ▁in ▁, ▁out ▁) ▁; ▁else ▁ri j nd ael Decrypt ▁( ▁k ▁-> ▁rd _ key ▁, ▁k ▁-> ▁rounds ▁, ▁in ▁, ▁out ▁) ▁; ▁inl ▁-= ▁16 ▁; ▁in ▁+= ▁16 ▁; ▁out ▁+= ▁16 ▁; ▁} ▁assert ▁( ▁inl ▁== ▁0 ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁void ▁* ▁av _ malloc ▁( ▁unsigned ▁int ▁size ▁) ▁{ ▁void ▁* ▁ptr ▁= ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁long ▁diff ▁; ▁# endif ▁if ▁( ▁size ▁> ▁( ▁INT _ MAX ▁- ▁16 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁ptr ▁= ▁malloc ▁( ▁size ▁+ ▁16 ▁) ▁; ▁if ▁( ▁! ▁ptr ▁) ▁return ▁ptr ▁; ▁diff ▁= ▁( ▁( ▁- ▁( ▁long ▁) ▁ptr ▁- ▁1 ▁) ▁& ▁15 ▁) ▁+ ▁1 ▁; ▁ptr ▁= ▁( ▁char ▁* ▁) ▁ptr ▁+ ▁diff ▁; ▁( ▁( ▁char ▁* ▁) ▁ptr ▁) ▁[ ▁-1 ▁] ▁= ▁diff ▁; ▁# elif ▁HAVE _ POSIX _ MEM ALIGN ▁if ▁( ▁posix _ memalign ▁( ▁& ▁ptr ▁, ▁16 ▁, ▁size ▁) ▁) ▁ptr ▁= ▁NULL ▁; ▁# elif ▁HAVE _ MEM ALIGN ▁ptr ▁= ▁mem align ▁( ▁16 ▁, ▁size ▁) ▁; ▁# else ▁ptr ▁= ▁malloc ▁( ▁size ▁) ▁; ▁# endif ▁return ▁ptr ▁; ▁}	0
▁void ▁ssl _ set _ client _ disabled ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁C ERT ▁* ▁c ▁= ▁s ▁-> ▁cert ▁; ▁const ▁unsigned ▁char ▁* ▁sig algs ▁; ▁size _ t ▁i ▁, ▁sig algs len ▁; ▁int ▁have _ rsa ▁= ▁0 ▁, ▁have _ dsa ▁= ▁0 ▁, ▁have _ ecdsa ▁= ▁0 ▁; ▁c ▁-> ▁mask _ a ▁= ▁0 ▁; ▁c ▁-> ▁mask _ k ▁= ▁0 ▁; ▁if ▁( ▁! ▁SSL _ CLIENT _ USE _ TLS 1_ 2_ CIPHER S ▁( ▁s ▁) ▁) ▁c ▁-> ▁mask _ ssl ▁= ▁SSL _ TLS V 1_2 ▁; ▁else ▁c ▁-> ▁mask _ ssl ▁= ▁0 ▁; ▁sig algs len ▁= ▁tls 12_ get _ ps ig algs ▁( ▁s ▁, ▁& ▁sig algs ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sig algs len ▁; ▁i ▁+= ▁2 ▁, ▁sig algs ▁+= ▁2 ▁) ▁{ ▁switch ▁( ▁sig algs ▁[ ▁1 ▁] ▁) ▁{ ▁# ifndef ▁OPENSSL _ NO _ RSA ▁case ▁TL SE XT _ signature _ rsa ▁: ▁have _ rsa ▁= ▁1 ▁; ▁break ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DSA ▁case ▁TL SE XT _ signature _ dsa ▁: ▁have _ dsa ▁= ▁1 ▁; ▁break ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDSA ▁case ▁TL SE XT _ signature _ ecdsa ▁: ▁have _ ecdsa ▁= ▁1 ▁; ▁break ▁; ▁# endif ▁} ▁} ▁if ▁( ▁! ▁have _ rsa ▁) ▁{ ▁c ▁-> ▁mask _ a ▁|= ▁SSL _ a RSA ▁; ▁c ▁-> ▁mask _ k ▁|= ▁SSL _ k DH r ▁| ▁SSL _ k ECDH r ▁; ▁} ▁if ▁( ▁! ▁have _ dsa ▁) ▁{ ▁c ▁-> ▁mask _ a ▁|= ▁SSL _ a DSS ▁; ▁c ▁-> ▁mask _ k ▁|= ▁SSL _ k DH d ▁; ▁} ▁if ▁( ▁! ▁have _ ecdsa ▁) ▁{ ▁c ▁-> ▁mask _ a ▁|= ▁SSL _ a ECDSA ▁; ▁c ▁-> ▁mask _ k ▁|= ▁SSL _ k EC D He ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ KRB 5 ▁if ▁( ▁! ▁k ssl _ t gt _ is _ available ▁( ▁s ▁-> ▁k ssl _ ctx ▁) ▁) ▁{ ▁c ▁-> ▁mask _ a ▁|= ▁SSL _ a KRB 5 ▁; ▁c ▁-> ▁mask _ k ▁|= ▁SSL _ k KRB 5 ▁; ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ PS K ▁if ▁( ▁! ▁s ▁-> ▁p sk _ client _ callback ▁) ▁{ ▁c ▁-> ▁mask _ a ▁|= ▁SSL _ a PS K ▁; ▁c ▁-> ▁mask _ k ▁|= ▁SSL _ k PS K ▁; ▁} ▁# endif ▁c ▁-> ▁valid ▁= ▁1 ▁; ▁}	1
▁static ▁void ▁fill _ buffer ▁( ▁AVIO Context ▁* ▁s ▁) ▁{ ▁uint 8_ t ▁* ▁dst ▁= ▁! ▁s ▁-> ▁max _ packet _ size ▁&& ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buffer ▁< ▁s ▁-> ▁buffer _ size ▁? ▁s ▁-> ▁buf _ end ▁: ▁s ▁-> ▁buffer ▁; ▁int ▁len ▁= ▁s ▁-> ▁buffer _ size ▁- ▁( ▁dst ▁- ▁s ▁-> ▁buffer ▁) ▁; ▁int ▁max _ buffer _ size ▁= ▁s ▁-> ▁max _ packet _ size ▁? ▁s ▁-> ▁max _ packet _ size ▁: ▁IO _ BUFFER _ SIZE ▁; ▁if ▁( ▁s ▁-> ▁eof _ reached ▁) ▁return ▁; ▁if ▁( ▁s ▁-> ▁update _ checksum ▁&& ▁dst ▁== ▁s ▁-> ▁buffer ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ end ▁> ▁s ▁-> ▁checksum _ ptr ▁) ▁s ▁-> ▁checksum ▁= ▁s ▁-> ▁update _ checksum ▁( ▁s ▁-> ▁checksum ▁, ▁s ▁-> ▁checksum _ ptr ▁, ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁checksum _ ptr ▁) ▁; ▁s ▁-> ▁checksum _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁if ▁( ▁s ▁-> ▁buffer _ size ▁> ▁max _ buffer _ size ▁) ▁{ ▁ff io _ set _ buf _ size ▁( ▁s ▁, ▁max _ buffer _ size ▁) ▁; ▁s ▁-> ▁checksum _ ptr ▁= ▁dst ▁= ▁s ▁-> ▁buffer ▁; ▁len ▁= ▁s ▁-> ▁buffer _ size ▁; ▁} ▁if ▁( ▁s ▁-> ▁read _ packet ▁) ▁len ▁= ▁s ▁-> ▁read _ packet ▁( ▁s ▁-> ▁opaque ▁, ▁dst ▁, ▁len ▁) ▁; ▁else ▁len ▁= ▁0 ▁; ▁if ▁( ▁len ▁<= ▁0 ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁s ▁-> ▁error ▁= ▁len ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pos ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁dst ▁; ▁s ▁-> ▁buf _ end ▁= ▁dst ▁+ ▁len ▁; ▁} ▁}	1
▁static ▁void ▁vp 8_ decode _ mb _ row _ no _ filter ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁t data ▁, ▁int ▁job nr ▁, ▁int ▁thread nr ▁, ▁int ▁is _ vp 7 ▁) ▁{ ▁VP 8 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁VP 8 Thread Data ▁* ▁prev _ td ▁, ▁* ▁next _ td ▁, ▁* ▁td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁thread nr ▁] ▁; ▁int ▁mb _ y ▁= ▁td ▁-> ▁thread _ mb _ pos ▁>> ▁16 ▁; ▁int ▁mb _ x ▁, ▁mb _ xy ▁= ▁mb _ y ▁* ▁s ▁-> ▁mb _ width ▁; ▁int ▁num _ jobs ▁= ▁s ▁-> ▁num _ jobs ▁; ▁VP 8 Frame ▁* ▁cur frame ▁= ▁s ▁-> ▁cur frame ▁, ▁* ▁prev _ frame ▁= ▁s ▁-> ▁prev _ frame ▁; ▁VP 56 Range Coder ▁* ▁c ▁= ▁& ▁s ▁-> ▁coeff _ partition ▁[ ▁mb _ y ▁& ▁( ▁s ▁-> ▁num _ coeff _ partitions ▁- ▁1 ▁) ▁] ▁; ▁VP 8 Macro block ▁* ▁mb ▁; ▁uint 8_ t ▁* ▁dst ▁[ ▁3 ▁] ▁= ▁{ ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁16 ▁* ▁mb _ y ▁* ▁s ▁-> ▁linesize ▁, ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁, ▁cur frame ▁-> ▁tf ▁. ▁f ▁-> ▁data ▁[ ▁2 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁} ▁; ▁if ▁( ▁mb _ y ▁== ▁0 ▁) ▁prev _ td ▁= ▁td ▁; ▁else ▁prev _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁num _ jobs ▁- ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁if ▁( ▁mb _ y ▁== ▁s ▁-> ▁mb _ height ▁- ▁1 ▁) ▁next _ td ▁= ▁td ▁; ▁else ▁next _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁if ▁( ▁s ▁-> ▁mb _ layout ▁== ▁1 ▁) ▁mb ▁= ▁s ▁-> ▁macro blocks _ base ▁+ ▁( ▁( ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁* ▁( ▁mb _ y ▁+ ▁1 ▁) ▁+ ▁1 ▁) ▁; ▁else ▁{ ▁if ▁( ▁prev _ frame ▁&& ▁s ▁-> ▁segment ation ▁. ▁enabled ▁&& ▁! ▁s ▁-> ▁segment ation ▁. ▁update _ map ▁) ▁ff _ thread _ await _ progress ▁( ▁& ▁prev _ frame ▁-> ▁tf ▁, ▁mb _ y ▁, ▁0 ▁) ▁; ▁mb ▁= ▁s ▁-> ▁macro blocks ▁+ ▁( ▁s ▁-> ▁mb _ height ▁- ▁mb _ y ▁- ▁1 ▁) ▁* ▁2 ▁; ▁memset ▁( ▁mb ▁- ▁1 ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁mb ▁) ▁) ▁; ▁AV _ WN 32 A ▁( ▁s ▁-> ▁in tra 4 x 4_ pred _ mode _ left ▁, ▁DC _ PRED ▁* ▁0 x 01010101 ▁) ▁; ▁} ▁if ▁( ▁! ▁is _ vp 7 ▁|| ▁mb _ y ▁== ▁0 ▁) ▁memset ▁( ▁td ▁-> ▁left _ nn z ▁, ▁0 ▁, ▁sizeof ▁( ▁td ▁-> ▁left _ nn z ▁) ▁) ▁; ▁s ▁-> ▁mv _ min ▁. ▁x ▁= ▁- ▁M ARGIN ▁; ▁s ▁-> ▁mv _ max ▁. ▁x ▁= ▁( ▁( ▁s ▁-> ▁mb _ width ▁- ▁1 ▁) ▁<< ▁6 ▁) ▁+ ▁M ARGIN ▁; ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁mb _ x ▁++ ▁, ▁mb _ xy ▁++ ▁, ▁mb ▁++ ▁) ▁{ ▁if ▁( ▁prev _ td ▁!= ▁td ▁) ▁{ ▁if ▁( ▁thread nr ▁!= ▁0 ▁) ▁{ ▁check _ thread _ pos ▁( ▁td ▁, ▁prev _ td ▁, ▁mb _ x ▁+ ▁( ▁is _ vp 7 ▁? ▁2 ▁: ▁1 ▁) ▁, ▁mb _ y ▁- ▁( ▁is _ vp 7 ▁? ▁2 ▁: ▁1 ▁) ▁) ▁; ▁} ▁else ▁{ ▁check _ thread _ pos ▁( ▁td ▁, ▁prev _ td ▁, ▁mb _ x ▁+ ▁( ▁is _ vp 7 ▁? ▁2 ▁: ▁1 ▁) ▁+ ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁, ▁mb _ y ▁- ▁( ▁is _ vp 7 ▁? ▁2 ▁: ▁1 ▁) ▁) ▁; ▁} ▁} ▁s ▁-> ▁v dsp ▁. ▁prefetch ▁( ▁dst ▁[ ▁0 ▁] ▁+ ▁( ▁mb _ x ▁& ▁3 ▁) ▁* ▁4 ▁* ▁s ▁-> ▁linesize ▁+ ▁64 ▁, ▁s ▁-> ▁linesize ▁, ▁4 ▁) ▁; ▁s ▁-> ▁v dsp ▁. ▁prefetch ▁( ▁dst ▁[ ▁1 ▁] ▁+ ▁( ▁mb _ x ▁& ▁7 ▁) ▁* ▁s ▁-> ▁uv lines ize ▁+ ▁64 ▁, ▁dst ▁[ ▁2 ▁] ▁- ▁dst ▁[ ▁1 ▁] ▁, ▁2 ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁mb _ layout ▁) ▁decode _ mb _ mode ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁cur frame ▁-> ▁seg _ map ▁-> ▁data ▁+ ▁mb _ xy ▁, ▁prev _ frame ▁&& ▁prev _ frame ▁-> ▁seg _ map ▁? ▁prev _ frame ▁-> ▁seg _ map ▁-> ▁data ▁+ ▁mb _ xy ▁: ▁NULL ▁, ▁0 ▁, ▁is _ vp 7 ▁) ▁; ▁prefetch _ motion ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁mb _ xy ▁, ▁VP 5 6_ FRAME _ PREVIOUS ▁) ▁; ▁if ▁( ▁! ▁mb ▁-> ▁skip ▁) ▁decode _ mb _ coeffs ▁( ▁s ▁, ▁td ▁, ▁c ▁, ▁mb ▁, ▁s ▁-> ▁top _ nn z ▁[ ▁mb _ x ▁] ▁, ▁td ▁-> ▁left _ nn z ▁, ▁is _ vp 7 ▁) ▁; ▁if ▁( ▁mb ▁-> ▁mode ▁<= ▁MODE _ I 4 x 4 ▁) ▁in tra _ predict ▁( ▁s ▁, ▁td ▁, ▁dst ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁is _ vp 7 ▁) ▁; ▁else ▁inter _ predict ▁( ▁s ▁, ▁td ▁, ▁dst ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁prefetch _ motion ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁mb _ xy ▁, ▁VP 5 6_ FRAME _ G OL DEN ▁) ▁; ▁if ▁( ▁! ▁mb ▁-> ▁skip ▁) ▁{ ▁idct _ mb ▁( ▁s ▁, ▁td ▁, ▁dst ▁, ▁mb ▁) ▁; ▁} ▁else ▁{ ▁AV _ ZERO 64 ▁( ▁td ▁-> ▁left _ nn z ▁) ▁; ▁AV _ WN 64 ▁( ▁s ▁-> ▁top _ nn z ▁[ ▁mb _ x ▁] ▁, ▁0 ▁) ▁; ▁if ▁( ▁mb ▁-> ▁mode ▁!= ▁MODE _ I 4 x 4 ▁&& ▁mb ▁-> ▁mode ▁!= ▁VP 8_ MV MODE _ SPLIT ▁) ▁{ ▁td ▁-> ▁left _ nn z ▁[ ▁8 ▁] ▁= ▁0 ▁; ▁s ▁-> ▁top _ nn z ▁[ ▁mb _ x ▁] ▁[ ▁8 ▁] ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁de block _ filter ▁) ▁filter _ level _ for _ mb ▁( ▁s ▁, ▁mb ▁, ▁& ▁td ▁-> ▁filter _ strength ▁[ ▁mb _ x ▁] ▁, ▁is _ vp 7 ▁) ▁; ▁if ▁( ▁s ▁-> ▁de block _ filter ▁&& ▁num _ jobs ▁!= ▁1 ▁&& ▁thread nr ▁== ▁num _ jobs ▁- ▁1 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁filter ▁. ▁simple ▁) ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁NULL ▁, ▁NULL ▁, ▁s ▁-> ▁linesize ▁, ▁0 ▁, ▁1 ▁) ▁; ▁else ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁dst ▁[ ▁1 ▁] ▁, ▁dst ▁[ ▁2 ▁] ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁uv lines ize ▁, ▁0 ▁) ▁; ▁} ▁prefetch _ motion ▁( ▁s ▁, ▁mb ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁mb _ xy ▁, ▁VP 5 6_ FRAME _ G OL DEN 2 ▁) ▁; ▁dst ▁[ ▁0 ▁] ▁+= ▁16 ▁; ▁dst ▁[ ▁1 ▁] ▁+= ▁8 ▁; ▁dst ▁[ ▁2 ▁] ▁+= ▁8 ▁; ▁s ▁-> ▁mv _ min ▁. ▁x ▁-= ▁64 ▁; ▁s ▁-> ▁mv _ max ▁. ▁x ▁-= ▁64 ▁; ▁if ▁( ▁mb _ x ▁== ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁{ ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁) ▁; ▁} ▁else ▁{ ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁mb _ x ▁) ▁; ▁} ▁} ▁}	0
▁int ▁EVP _ Digest Init _ ex ▁( ▁EVP _ MD _ CTX ▁* ▁ctx ▁, ▁const ▁EVP _ MD ▁* ▁type ▁, ▁ENGINE ▁* ▁impl ▁) ▁{ ▁EVP _ MD _ CTX _ clear _ flags ▁( ▁ctx ▁, ▁EVP _ MD _ CTX _ FLAG _ CLEAN ED ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁if ▁( ▁ctx ▁-> ▁engine ▁&& ▁ctx ▁-> ▁digest ▁&& ▁( ▁! ▁type ▁|| ▁( ▁type ▁&& ▁( ▁type ▁-> ▁type ▁== ▁ctx ▁-> ▁digest ▁-> ▁type ▁) ▁) ▁) ▁) ▁goto ▁skip _ to _ init ▁; ▁if ▁( ▁type ▁) ▁{ ▁ENGINE _ finish ▁( ▁ctx ▁-> ▁engine ▁) ▁; ▁if ▁( ▁impl ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁ENGINE _ init ▁( ▁impl ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DIGEST INIT _ EX ▁, ▁EVP _ R _ INITIALIZ ATION _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁else ▁{ ▁impl ▁= ▁ENGINE _ get _ digest _ engine ▁( ▁type ▁-> ▁type ▁) ▁; ▁} ▁if ▁( ▁impl ▁!= ▁NULL ▁) ▁{ ▁const ▁EVP _ MD ▁* ▁d ▁= ▁ENGINE _ get _ digest ▁( ▁impl ▁, ▁type ▁-> ▁type ▁) ▁; ▁if ▁( ▁d ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DIGEST INIT _ EX ▁, ▁EVP _ R _ INITIALIZ ATION _ ERROR ▁) ▁; ▁ENGINE _ finish ▁( ▁impl ▁) ▁; ▁return ▁0 ▁; ▁} ▁type ▁= ▁d ▁; ▁ctx ▁-> ▁engine ▁= ▁impl ▁; ▁} ▁else ▁ctx ▁-> ▁engine ▁= ▁NULL ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁ctx ▁-> ▁digest ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DIGEST INIT _ EX ▁, ▁EVP _ R _ NO _ DIGEST _ SET ▁) ▁; ▁return ▁0 ▁; ▁} ▁type ▁= ▁ctx ▁-> ▁digest ▁; ▁} ▁# endif ▁if ▁( ▁ctx ▁-> ▁digest ▁!= ▁type ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁digest ▁&& ▁ctx ▁-> ▁digest ▁-> ▁ctx _ size ▁) ▁OPENSSL _ free ▁( ▁ctx ▁-> ▁md _ data ▁) ▁; ▁ctx ▁-> ▁digest ▁= ▁type ▁; ▁if ▁( ▁! ▁( ▁ctx ▁-> ▁flags ▁& ▁EVP _ MD _ CTX _ FLAG _ NO _ INIT ▁) ▁&& ▁type ▁-> ▁ctx _ size ▁) ▁{ ▁ctx ▁-> ▁update ▁= ▁type ▁-> ▁update ▁; ▁ctx ▁-> ▁md _ data ▁= ▁OPENSSL _ zalloc ▁( ▁type ▁-> ▁ctx _ size ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁md _ data ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DIGEST INIT _ EX ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁} ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁skip _ to _ init ▁: ▁# endif ▁if ▁( ▁ctx ▁-> ▁pctx ▁) ▁{ ▁int ▁r ▁; ▁r ▁= ▁EVP _ PKEY _ CTX _ ctrl ▁( ▁ctx ▁-> ▁pctx ▁, ▁-1 ▁, ▁EVP _ PKEY _ OP _ TYPE _ SIG ▁, ▁EVP _ PKEY _ CTRL _ DIGEST INIT ▁, ▁0 ▁, ▁ctx ▁) ▁; ▁if ▁( ▁r ▁<= ▁0 ▁&& ▁( ▁r ▁!= ▁-2 ▁) ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁flags ▁& ▁EVP _ MD _ CTX _ FLAG _ NO _ INIT ▁) ▁return ▁1 ▁; ▁return ▁ctx ▁-> ▁digest ▁-> ▁init ▁( ▁ctx ▁) ▁; ▁}	0
▁int ▁X 509_ VERIFY _ PARAM _ set 1_ host ▁( ▁X 509_ VERIFY _ PARAM ▁* ▁param ▁, ▁const ▁unsigned ▁char ▁* ▁name ▁, ▁size _ t ▁namelen ▁) ▁{ ▁return ▁int _ x 509_ param _ set 1 ▁( ▁& ▁param ▁-> ▁id ▁-> ▁host ▁, ▁& ▁param ▁-> ▁id ▁-> ▁host len ▁, ▁name ▁, ▁namelen ▁) ▁; ▁}	0
▁static ▁int ▁decode _ frame ▁( ▁FLAC Context ▁* ▁s ▁) ▁{ ▁int ▁bs _ code ▁, ▁sr _ code ▁, ▁bps _ code ▁, ▁i ▁; ▁int ▁ch _ mode ▁, ▁bps ▁, ▁blocksize ▁, ▁sampler ate ▁; ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁gb ▁; ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁16 ▁) ▁; ▁bs _ code ▁= ▁get _ bits ▁( ▁gb ▁, ▁4 ▁) ▁; ▁sr _ code ▁= ▁get _ bits ▁( ▁gb ▁, ▁4 ▁) ▁; ▁ch _ mode ▁= ▁get _ bits ▁( ▁gb ▁, ▁4 ▁) ▁; ▁if ▁( ▁ch _ mode ▁< ▁FLAC _ MAX _ CHANNELS ▁&& ▁s ▁-> ▁channels ▁== ▁ch _ mode ▁+ ▁1 ▁) ▁{ ▁ch _ mode ▁= ▁FLAC _ CH MODE _ IN DEPEND ENT ▁; ▁} ▁else ▁if ▁( ▁ch _ mode ▁> ▁FLAC _ CH MODE _ MID _ SIDE ▁|| ▁s ▁-> ▁channels ▁!= ▁2 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" unsupported ch anne lass ignment % d ( channels =% d )\ n " ▁, ▁ch _ mode ▁, ▁s ▁-> ▁channels ▁) ▁; ▁return ▁-1 ▁; ▁} ▁bps _ code ▁= ▁get _ bits ▁( ▁gb ▁, ▁3 ▁) ▁; ▁if ▁( ▁bps _ code ▁== ▁0 ▁) ▁bps ▁= ▁s ▁-> ▁bps ▁; ▁else ▁if ▁( ▁( ▁bps _ code ▁!= ▁3 ▁) ▁&& ▁( ▁bps _ code ▁!= ▁7 ▁) ▁) ▁bps ▁= ▁sample _ size _ table ▁[ ▁bps _ code ▁] ▁; ▁else ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid sample size code (% d )\ n " ▁, ▁bps _ code ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁bps ▁> ▁16 ▁) ▁{ ▁s ▁-> ▁avctx ▁-> ▁sample _ fmt ▁= ▁SAMPLE _ FMT _ S 32 ▁; ▁s ▁-> ▁sample _ shift ▁= ▁32 ▁- ▁bps ▁; ▁s ▁-> ▁is 32 ▁= ▁1 ▁; ▁} ▁else ▁{ ▁s ▁-> ▁avctx ▁-> ▁sample _ fmt ▁= ▁SAMPLE _ FMT _ S 16 ▁; ▁s ▁-> ▁sample _ shift ▁= ▁16 ▁- ▁bps ▁; ▁s ▁-> ▁is 32 ▁= ▁0 ▁; ▁} ▁s ▁-> ▁bps ▁= ▁s ▁-> ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁= ▁bps ▁; ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" broken stream , invalid padding \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁get _ utf 8 ▁( ▁gb ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" utf 8 fs ck ed \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁bs _ code ▁== ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" reserved blocksize code : 0\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁bs _ code ▁== ▁6 ▁) ▁blocksize ▁= ▁get _ bits ▁( ▁gb ▁, ▁8 ▁) ▁+ ▁1 ▁; ▁else ▁if ▁( ▁bs _ code ▁== ▁7 ▁) ▁blocksize ▁= ▁get _ bits ▁( ▁gb ▁, ▁16 ▁) ▁+ ▁1 ▁; ▁else ▁blocksize ▁= ▁ff _ fl ac _ blocksize _ table ▁[ ▁bs _ code ▁] ▁; ▁if ▁( ▁blocksize ▁> ▁s ▁-> ▁max _ blocksize ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" blocksize % d >% d \ n " ▁, ▁blocksize ▁, ▁s ▁-> ▁max _ blocksize ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁sr _ code ▁== ▁0 ▁) ▁sampler ate ▁= ▁s ▁-> ▁sampler ate ▁; ▁else ▁if ▁( ▁sr _ code ▁< ▁12 ▁) ▁sampler ate ▁= ▁ff _ fl ac _ sample _ rate _ table ▁[ ▁sr _ code ▁] ▁; ▁else ▁if ▁( ▁sr _ code ▁== ▁12 ▁) ▁sampler ate ▁= ▁get _ bits ▁( ▁gb ▁, ▁8 ▁) ▁* ▁1000 ▁; ▁else ▁if ▁( ▁sr _ code ▁== ▁13 ▁) ▁sampler ate ▁= ▁get _ bits ▁( ▁gb ▁, ▁16 ▁) ▁; ▁else ▁if ▁( ▁sr _ code ▁== ▁14 ▁) ▁sampler ate ▁= ▁get _ bits ▁( ▁gb ▁, ▁16 ▁) ▁* ▁10 ▁; ▁else ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" illegal sampler ate code % d \ n " ▁, ▁sr _ code ▁) ▁; ▁return ▁-1 ▁; ▁} ▁skip _ bits ▁( ▁gb ▁, ▁8 ▁) ▁; ▁if ▁( ▁av _ crc ▁( ▁av _ crc _ get _ table ▁( ▁AV _ CRC _8_ AT M ▁) ▁, ▁0 ▁, ▁gb ▁-> ▁buffer ▁, ▁get _ bits _ count ▁( ▁gb ▁) ▁/ ▁8 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" header crc mismatch \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁blocksize ▁= ▁blocksize ▁; ▁s ▁-> ▁sampler ate ▁= ▁sampler ate ▁; ▁s ▁-> ▁bps ▁= ▁bps ▁; ▁s ▁-> ▁ch _ mode ▁= ▁ch _ mode ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁decode _ sub frame ▁( ▁s ▁, ▁i ▁) ▁< ▁0 ▁) ▁return ▁-1 ▁; ▁} ▁align _ get _ bits ▁( ▁gb ▁) ▁; ▁skip _ bits ▁( ▁gb ▁, ▁16 ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁const ▁unsigned ▁char ▁* ▁valid _ star ▁( ▁const ▁unsigned ▁char ▁* ▁p ▁, ▁size _ t ▁len ▁, ▁unsigned ▁int ▁flags ▁) ▁{ ▁const ▁unsigned ▁char ▁* ▁star ▁= ▁0 ▁; ▁size _ t ▁i ▁; ▁int ▁state ▁= ▁LABEL _ START ▁; ▁int ▁dot s ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁p ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁int ▁at start ▁= ▁( ▁state ▁& ▁LABEL _ START ▁) ▁; ▁int ▁at end ▁= ▁( ▁i ▁== ▁len ▁- ▁1 ▁|| ▁p ▁[ ▁i ▁+ ▁i ▁] ▁== ▁' ▁' ▁) ▁; ▁if ▁( ▁star ▁!= ▁NULL ▁|| ▁( ▁state ▁& ▁LABEL _ ID NA ▁) ▁!= ▁0 ▁|| ▁dot s ▁) ▁return ▁NULL ▁; ▁if ▁( ▁( ▁flags ▁& ▁X 509_ CHECK _ FLAG _ NO _ PARTIAL _ W IL DC AR DS ▁) ▁&& ▁( ▁! ▁at start ▁|| ▁! ▁at end ▁) ▁) ▁return ▁NULL ▁; ▁if ▁( ▁! ▁at start ▁&& ▁! ▁at end ▁) ▁return ▁NULL ▁; ▁star ▁= ▁& ▁p ▁[ ▁i ▁] ▁; ▁state ▁&= ▁ ~ ▁LABEL _ START ▁; ▁} ▁else ▁if ▁( ▁( ▁state ▁& ▁LABEL _ START ▁) ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁( ▁state ▁& ▁LABEL _ ID NA ▁) ▁== ▁0 ▁&& ▁len ▁- ▁i ▁>= ▁4 ▁&& ▁strncasecmp ▁( ▁( ▁char ▁* ▁) ▁& ▁p ▁[ ▁i ▁] ▁, ▁" x n -- " ▁, ▁4 ▁) ▁== ▁0 ▁) ▁{ ▁i ▁+= ▁3 ▁; ▁state ▁|= ▁LABEL _ ID NA ▁; ▁continue ▁; ▁} ▁state ▁&= ▁ ~ ▁LABEL _ START ▁; ▁if ▁( ▁( ▁' ▁' ▁<= ▁p ▁[ ▁i ▁] ▁&& ▁p ▁[ ▁i ▁] ▁<= ▁' ▁' ▁) ▁|| ▁( ▁' ▁' ▁<= ▁p ▁[ ▁i ▁] ▁&& ▁p ▁[ ▁i ▁] ▁<= ▁' ▁' ▁) ▁|| ▁( ▁' ▁' ▁<= ▁p ▁[ ▁i ▁] ▁&& ▁p ▁[ ▁i ▁] ▁<= ▁' ▁' ▁) ▁) ▁continue ▁; ▁return ▁NULL ▁; ▁} ▁else ▁if ▁( ▁( ▁' ▁' ▁<= ▁p ▁[ ▁i ▁] ▁&& ▁p ▁[ ▁i ▁] ▁<= ▁' ▁' ▁) ▁|| ▁( ▁' ▁' ▁<= ▁p ▁[ ▁i ▁] ▁&& ▁p ▁[ ▁i ▁] ▁<= ▁' ▁' ▁) ▁|| ▁( ▁' ▁' ▁<= ▁p ▁[ ▁i ▁] ▁&& ▁p ▁[ ▁i ▁] ▁<= ▁' ▁' ▁) ▁) ▁{ ▁state ▁&= ▁LABEL _ ID NA ▁; ▁continue ▁; ▁} ▁else ▁if ▁( ▁p ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁state ▁& ▁( ▁LABEL _ HY PH EN ▁| ▁LABEL _ START ▁) ▁) ▁return ▁NULL ▁; ▁state ▁= ▁LABEL _ START ▁; ▁++ ▁dot s ▁; ▁} ▁else ▁if ▁( ▁p ▁[ ▁i ▁] ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁state ▁& ▁LABEL _ HY PH EN ▁) ▁return ▁NULL ▁; ▁state ▁|= ▁LABEL _ HY PH EN ▁; ▁} ▁else ▁return ▁NULL ▁; ▁} ▁if ▁( ▁( ▁state ▁& ▁( ▁LABEL _ START ▁| ▁LABEL _ HY PH EN ▁) ▁) ▁!= ▁0 ▁|| ▁dot s ▁< ▁2 ▁) ▁return ▁NULL ▁; ▁return ▁star ▁; ▁}	0
▁static ▁inline ▁int ▁svq 3_ decode _ block ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁DCT ELEM ▁* ▁block ▁, ▁int ▁index ▁, ▁const ▁int ▁type ▁) ▁{ ▁static ▁const ▁uint 8_ t ▁* ▁const ▁scan _ patterns ▁[ ▁4 ▁] ▁= ▁{ ▁lum a _ dc _ zig z ag _ scan ▁, ▁z ig z ag _ scan ▁, ▁svq 3_ scan ▁, ▁chroma _ dc _ scan ▁} ▁; ▁int ▁run ▁, ▁level ▁, ▁sign ▁, ▁vlc ▁, ▁limit ▁; ▁const ▁int ▁in tra ▁= ▁( ▁3 ▁* ▁type ▁) ▁>> ▁2 ▁; ▁const ▁uint 8_ t ▁* ▁const ▁scan ▁= ▁scan _ patterns ▁[ ▁type ▁] ▁; ▁for ▁( ▁limit ▁= ▁( ▁16 ▁>> ▁in tra ▁) ▁; ▁index ▁< ▁16 ▁; ▁index ▁= ▁limit ▁, ▁limit ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁; ▁( ▁vlc ▁= ▁svq 3_ get _ ue _ go lo mb ▁( ▁gb ▁) ▁) ▁!= ▁0 ▁; ▁index ▁++ ▁) ▁{ ▁if ▁( ▁vlc ▁== ▁INVALID _ V LC ▁) ▁return ▁-1 ▁; ▁sign ▁= ▁( ▁vlc ▁& ▁0 x 1 ▁) ▁- ▁1 ▁; ▁vlc ▁= ▁( ▁vlc ▁+ ▁1 ▁) ▁>> ▁1 ▁; ▁if ▁( ▁type ▁== ▁3 ▁) ▁{ ▁if ▁( ▁vlc ▁< ▁3 ▁) ▁{ ▁run ▁= ▁0 ▁; ▁level ▁= ▁vlc ▁; ▁} ▁else ▁if ▁( ▁vlc ▁< ▁4 ▁) ▁{ ▁run ▁= ▁1 ▁; ▁level ▁= ▁1 ▁; ▁} ▁else ▁{ ▁run ▁= ▁( ▁vlc ▁& ▁0 x 3 ▁) ▁; ▁level ▁= ▁( ▁( ▁vlc ▁+ ▁9 ▁) ▁>> ▁2 ▁) ▁- ▁run ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁vlc ▁< ▁16 ▁) ▁{ ▁run ▁= ▁svq 3_ dct _ tables ▁[ ▁in tra ▁] ▁[ ▁vlc ▁] ▁. ▁run ▁; ▁level ▁= ▁svq 3_ dct _ tables ▁[ ▁in tra ▁] ▁[ ▁vlc ▁] ▁. ▁level ▁; ▁} ▁else ▁if ▁( ▁in tra ▁) ▁{ ▁run ▁= ▁( ▁vlc ▁& ▁0 x 7 ▁) ▁; ▁level ▁= ▁( ▁vlc ▁>> ▁3 ▁) ▁+ ▁( ▁( ▁run ▁== ▁0 ▁) ▁? ▁8 ▁: ▁( ▁( ▁run ▁< ▁2 ▁) ▁? ▁2 ▁: ▁( ▁( ▁run ▁< ▁5 ▁) ▁? ▁0 ▁: ▁-1 ▁) ▁) ▁) ▁; ▁} ▁else ▁{ ▁run ▁= ▁( ▁vlc ▁& ▁0 xF ▁) ▁; ▁level ▁= ▁( ▁vlc ▁>> ▁4 ▁) ▁+ ▁( ▁( ▁run ▁== ▁0 ▁) ▁? ▁4 ▁: ▁( ▁( ▁run ▁< ▁3 ▁) ▁? ▁2 ▁: ▁( ▁( ▁run ▁< ▁10 ▁) ▁? ▁1 ▁: ▁0 ▁) ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁( ▁index ▁+= ▁run ▁) ▁>= ▁limit ▁) ▁return ▁-1 ▁; ▁block ▁[ ▁scan ▁[ ▁index ▁] ▁] ▁= ▁( ▁level ▁ ^ ▁sign ▁) ▁- ▁sign ▁; ▁} ▁if ▁( ▁type ▁!= ▁2 ▁) ▁{ ▁break ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁ff _ fill _ line _ with _ color ▁( ▁uint 8_ t ▁* ▁line ▁[ ▁4 ▁] ▁, ▁int ▁pixel _ step ▁[ ▁4 ▁] ▁, ▁int ▁w ▁, ▁uint 8_ t ▁dst _ color ▁[ ▁4 ▁] ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁uint 8_ t ▁rgba _ color ▁[ ▁4 ▁] ▁, ▁int ▁* ▁is _ packed _ rgba ▁, ▁uint 8_ t ▁rgba _ map _ ptr ▁[ ▁4 ▁] ▁) ▁{ ▁uint 8_ t ▁rgba _ map ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁i ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁pix _ desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁pix _ fmt ▁) ▁; ▁int ▁h sub ▁= ▁pix _ desc ▁-> ▁log 2_ chroma _ w ▁; ▁* ▁is _ packed _ rgba ▁= ▁ff _ fill _ rgba _ map ▁( ▁rgba _ map ▁, ▁pix _ fmt ▁) ▁>= ▁0 ▁; ▁if ▁( ▁* ▁is _ packed _ rgba ▁) ▁{ ▁pixel _ step ▁[ ▁0 ▁] ▁= ▁( ▁av _ get _ bits _ per _ pixel ▁( ▁pix _ desc ▁) ▁) ▁>> ▁3 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁dst _ color ▁[ ▁rgba _ map ▁[ ▁i ▁] ▁] ▁= ▁rgba _ color ▁[ ▁i ▁] ▁; ▁line ▁[ ▁0 ▁] ▁= ▁av _ malloc _ array ▁( ▁w ▁, ▁pixel _ step ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁! ▁line ▁[ ▁0 ▁] ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁w ▁; ▁i ▁++ ▁) ▁memcpy ▁( ▁line ▁[ ▁0 ▁] ▁+ ▁i ▁* ▁pixel _ step ▁[ ▁0 ▁] ▁, ▁dst _ color ▁, ▁pixel _ step ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁rgba _ map _ ptr ▁) ▁memcpy ▁( ▁rgba _ map _ ptr ▁, ▁rgba _ map ▁, ▁sizeof ▁( ▁rgba _ map ▁[ ▁0 ▁] ▁) ▁* ▁4 ▁) ▁; ▁} ▁else ▁{ ▁int ▁plane ▁; ▁dst _ color ▁[ ▁0 ▁] ▁= ▁RGB _ TO _ Y _ CC IR ▁( ▁rgba _ color ▁[ ▁0 ▁] ▁, ▁rgba _ color ▁[ ▁1 ▁] ▁, ▁rgba _ color ▁[ ▁2 ▁] ▁) ▁; ▁dst _ color ▁[ ▁1 ▁] ▁= ▁RGB _ TO _ U _ CC IR ▁( ▁rgba _ color ▁[ ▁0 ▁] ▁, ▁rgba _ color ▁[ ▁1 ▁] ▁, ▁rgba _ color ▁[ ▁2 ▁] ▁, ▁0 ▁) ▁; ▁dst _ color ▁[ ▁2 ▁] ▁= ▁RGB _ TO _ V _ CC IR ▁( ▁rgba _ color ▁[ ▁0 ▁] ▁, ▁rgba _ color ▁[ ▁1 ▁] ▁, ▁rgba _ color ▁[ ▁2 ▁] ▁, ▁0 ▁) ▁; ▁dst _ color ▁[ ▁3 ▁] ▁= ▁rgba _ color ▁[ ▁3 ▁] ▁; ▁for ▁( ▁plane ▁= ▁0 ▁; ▁plane ▁< ▁4 ▁; ▁plane ▁++ ▁) ▁{ ▁int ▁line _ size ▁; ▁int ▁h sub 1 ▁= ▁( ▁plane ▁== ▁1 ▁|| ▁plane ▁== ▁2 ▁) ▁? ▁h sub ▁: ▁0 ▁; ▁pixel _ step ▁[ ▁plane ▁] ▁= ▁1 ▁; ▁line _ size ▁= ▁FF _ CE IL _ RSHIFT ▁( ▁w ▁, ▁h sub 1 ▁) ▁* ▁pixel _ step ▁[ ▁plane ▁] ▁; ▁line ▁[ ▁plane ▁] ▁= ▁av _ malloc ▁( ▁line _ size ▁) ▁; ▁if ▁( ▁! ▁line ▁[ ▁plane ▁] ▁) ▁{ ▁while ▁( ▁plane ▁&& ▁line ▁[ ▁plane ▁- ▁1 ▁] ▁) ▁av _ freep ▁( ▁& ▁line ▁[ ▁-- ▁plane ▁] ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁memset ▁( ▁line ▁[ ▁plane ▁] ▁, ▁dst _ color ▁[ ▁plane ▁] ▁, ▁line _ size ▁) ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁C ERT ▁* ▁ssl _ cert _ dup ▁( ▁C ERT ▁* ▁cert ▁) ▁{ ▁C ERT ▁* ▁ret ▁; ▁int ▁i ▁; ▁ret ▁= ▁( ▁C ERT ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁C ERT ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CERT _ DUP ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁memset ▁( ▁ret ▁, ▁0 ▁, ▁sizeof ▁( ▁C ERT ▁) ▁) ▁; ▁ret ▁-> ▁key ▁= ▁& ▁ret ▁-> ▁p keys ▁[ ▁cert ▁-> ▁key ▁- ▁& ▁cert ▁-> ▁p keys ▁[ ▁0 ▁] ▁] ▁; ▁ret ▁-> ▁valid ▁= ▁cert ▁-> ▁valid ▁; ▁ret ▁-> ▁mask ▁= ▁cert ▁-> ▁mask ▁; ▁ret ▁-> ▁export _ mask ▁= ▁cert ▁-> ▁export _ mask ▁; ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁cert ▁-> ▁rsa _ tmp ▁!= ▁NULL ▁) ▁{ ▁RSA _ up _ ref ▁( ▁cert ▁-> ▁rsa _ tmp ▁) ▁; ▁ret ▁-> ▁rsa _ tmp ▁= ▁cert ▁-> ▁rsa _ tmp ▁; ▁} ▁ret ▁-> ▁rsa _ tmp _ cb ▁= ▁cert ▁-> ▁rsa _ tmp _ cb ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DH ▁if ▁( ▁cert ▁-> ▁dh _ tmp ▁!= ▁NULL ▁) ▁{ ▁ret ▁-> ▁dh _ tmp ▁= ▁DH params _ dup ▁( ▁cert ▁-> ▁dh _ tmp ▁) ▁; ▁if ▁( ▁ret ▁-> ▁dh _ tmp ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CERT _ DUP ▁, ▁ERR _ R _ DH _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁cert ▁-> ▁dh _ tmp ▁-> ▁priv _ key ▁) ▁{ ▁BIGNUM ▁* ▁b ▁= ▁BN _ dup ▁( ▁cert ▁-> ▁dh _ tmp ▁-> ▁priv _ key ▁) ▁; ▁if ▁( ▁! ▁b ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CERT _ DUP ▁, ▁ERR _ R _ BN _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁ret ▁-> ▁dh _ tmp ▁-> ▁priv _ key ▁= ▁b ▁; ▁} ▁if ▁( ▁cert ▁-> ▁dh _ tmp ▁-> ▁pub _ key ▁) ▁{ ▁BIGNUM ▁* ▁b ▁= ▁BN _ dup ▁( ▁cert ▁-> ▁dh _ tmp ▁-> ▁pub _ key ▁) ▁; ▁if ▁( ▁! ▁b ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CERT _ DUP ▁, ▁ERR _ R _ BN _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁ret ▁-> ▁dh _ tmp ▁-> ▁pub _ key ▁= ▁b ▁; ▁} ▁} ▁ret ▁-> ▁dh _ tmp _ cb ▁= ▁cert ▁-> ▁dh _ tmp _ cb ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDH ▁if ▁( ▁cert ▁-> ▁ecdh _ tmp ▁) ▁{ ▁ret ▁-> ▁ecdh _ tmp ▁= ▁EC _ KEY _ dup ▁( ▁cert ▁-> ▁ecdh _ tmp ▁) ▁; ▁if ▁( ▁ret ▁-> ▁ecdh _ tmp ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CERT _ DUP ▁, ▁ERR _ R _ EC _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁ret ▁-> ▁ecdh _ tmp _ cb ▁= ▁cert ▁-> ▁ecdh _ tmp _ cb ▁; ▁# endif ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁SSL _ PKEY _ NUM ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁cert ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁!= ▁NULL ▁) ▁{ ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁= ▁cert ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁; ▁CRYPTO _ add ▁( ▁& ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ X 509 ▁) ▁; ▁} ▁if ▁( ▁cert ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁private key ▁!= ▁NULL ▁) ▁{ ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁private key ▁= ▁cert ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁private key ▁; ▁CRYPTO _ add ▁( ▁& ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁private key ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ EVP _ PKEY ▁) ▁; ▁switch ▁( ▁i ▁) ▁{ ▁case ▁SSL _ PKEY _ RSA _ ENC ▁: ▁case ▁SSL _ PKEY _ RSA _ SIGN ▁: ▁break ▁; ▁case ▁SSL _ PKEY _ DSA _ SIGN ▁: ▁break ▁; ▁case ▁SSL _ PKEY _ DH _ RSA ▁: ▁case ▁SSL _ PKEY _ DH _ DSA ▁: ▁break ▁; ▁case ▁SSL _ PKEY _ ECC ▁: ▁break ▁; ▁default ▁: ▁SSL err ▁( ▁SSL _ F _ SSL _ CERT _ DUP ▁, ▁SSL _ R _ LIBRARY _ BUG ▁) ▁; ▁} ▁} ▁} ▁ret ▁-> ▁references ▁= ▁1 ▁; ▁return ▁( ▁ret ▁) ▁; ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ DH ▁) ▁|| ▁! ▁defined ▁( ▁OPENSSL _ NO _ ECDH ▁) ▁err ▁: ▁# endif ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁ret ▁-> ▁rsa _ tmp ▁!= ▁NULL ▁) ▁RSA _ free ▁( ▁ret ▁-> ▁rsa _ tmp ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DH ▁if ▁( ▁ret ▁-> ▁dh _ tmp ▁!= ▁NULL ▁) ▁DH _ free ▁( ▁ret ▁-> ▁dh _ tmp ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDH ▁if ▁( ▁ret ▁-> ▁ecdh _ tmp ▁!= ▁NULL ▁) ▁EC _ KEY _ free ▁( ▁ret ▁-> ▁ecdh _ tmp ▁) ▁; ▁# endif ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁SSL _ PKEY _ NUM ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁!= ▁NULL ▁) ▁X 509_ free ▁( ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁) ▁; ▁if ▁( ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁private key ▁!= ▁NULL ▁) ▁EVP _ PKEY _ free ▁( ▁ret ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁private key ▁) ▁; ▁} ▁return ▁NULL ▁; ▁}	1
▁static ▁int ▁rtp _ parse _ mp 4_ au ▁( ▁RTP Demux Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁) ▁{ ▁int ▁au _ headers _ length ▁, ▁au _ header _ size ▁, ▁i ▁; ▁Get Bit Context ▁get bit context ▁; ▁RTP Payload Data ▁* ▁infos ▁; ▁infos ▁= ▁s ▁-> ▁rtp _ payload _ data ▁; ▁if ▁( ▁infos ▁== ▁NULL ▁) ▁return ▁-1 ▁; ▁au _ headers _ length ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁; ▁if ▁( ▁au _ headers _ length ▁> ▁RTP _ MAX _ PACKET _ LENGTH ▁) ▁return ▁-1 ▁; ▁infos ▁-> ▁au _ headers _ length _ bytes ▁= ▁( ▁au _ headers _ length ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁buf ▁+= ▁2 ▁; ▁init _ get _ bits ▁( ▁& ▁get bit context ▁, ▁buf ▁, ▁infos ▁-> ▁au _ headers _ length _ bytes ▁* ▁8 ▁) ▁; ▁au _ header _ size ▁= ▁infos ▁-> ▁siz elength ▁+ ▁infos ▁-> ▁index length ▁; ▁if ▁( ▁au _ header _ size ▁<= ▁0 ▁|| ▁( ▁au _ headers _ length ▁% ▁au _ header _ size ▁!= ▁0 ▁) ▁) ▁return ▁-1 ▁; ▁infos ▁-> ▁nb _ au _ headers ▁= ▁au _ headers _ length ▁/ ▁au _ header _ size ▁; ▁infos ▁-> ▁au _ headers ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁struct ▁AU Headers ▁) ▁* ▁infos ▁-> ▁nb _ au _ headers ▁) ▁; ▁infos ▁-> ▁au _ headers ▁[ ▁0 ▁] ▁. ▁size ▁= ▁0 ▁; ▁infos ▁-> ▁au _ headers ▁[ ▁0 ▁] ▁. ▁index ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁infos ▁-> ▁nb _ au _ headers ▁; ▁++ ▁i ▁) ▁{ ▁infos ▁-> ▁au _ headers ▁[ ▁0 ▁] ▁. ▁size ▁+= ▁get _ bits _ long ▁( ▁& ▁get bit context ▁, ▁infos ▁-> ▁siz elength ▁) ▁; ▁infos ▁-> ▁au _ headers ▁[ ▁0 ▁] ▁. ▁index ▁= ▁get _ bits _ long ▁( ▁& ▁get bit context ▁, ▁infos ▁-> ▁index length ▁) ▁; ▁} ▁infos ▁-> ▁nb _ au _ headers ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁decode _2 ▁( ▁SAN M Video Context ▁* ▁ctx ▁) ▁{ ▁int ▁cx ▁, ▁cy ▁, ▁ret ▁; ▁for ▁( ▁cy ▁= ▁0 ▁; ▁cy ▁!= ▁ctx ▁-> ▁aligned _ height ▁; ▁cy ▁+= ▁8 ▁) ▁{ ▁for ▁( ▁cx ▁= ▁0 ▁; ▁cx ▁!= ▁ctx ▁-> ▁aligned _ width ▁; ▁cx ▁+= ▁8 ▁) ▁{ ▁if ▁( ▁ret ▁= ▁codec 2 sub block ▁( ▁ctx ▁, ▁cx ▁, ▁cy ▁, ▁8 ▁) ▁) ▁return ▁ret ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁BN _ mod _ exp _ mont ▁( ▁BIGNUM ▁* ▁rr ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁p ▁, ▁const ▁BIGNUM ▁* ▁m ▁, ▁BN _ CTX ▁* ▁ctx ▁, ▁BN _ M ONT _ CTX ▁* ▁in _ mont ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁bits ▁, ▁ret ▁= ▁0 ▁, ▁w start ▁, ▁w end ▁, ▁window ▁, ▁wvalue ▁; ▁int ▁start ▁= ▁1 ▁; ▁BIGNUM ▁* ▁d ▁, ▁* ▁r ▁; ▁const ▁BIGNUM ▁* ▁aa ▁; ▁BIGNUM ▁* ▁val ▁[ ▁TABLE _ SIZE ▁] ▁; ▁BN _ M ONT _ CTX ▁* ▁m ont ▁= ▁NULL ▁; ▁if ▁( ▁BN _ get _ flags ▁( ▁p ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁|| ▁BN _ get _ flags ▁( ▁a ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁|| ▁BN _ get _ flags ▁( ▁m ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁) ▁{ ▁return ▁BN _ mod _ exp _ mont _ const time ▁( ▁rr ▁, ▁a ▁, ▁p ▁, ▁m ▁, ▁ctx ▁, ▁in _ mont ▁) ▁; ▁} ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁p ▁) ▁; ▁bn _ check _ top ▁( ▁m ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ odd ▁( ▁m ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ MOD _ EXP _ M ONT ▁, ▁BN _ R _ CALLED _ WITH _ EVEN _ MODUL US ▁) ▁; ▁return ▁0 ▁; ▁} ▁bits ▁= ▁BN _ num _ bits ▁( ▁p ▁) ▁; ▁if ▁( ▁bits ▁== ▁0 ▁) ▁{ ▁if ▁( ▁BN _ is _ one ▁( ▁m ▁) ▁) ▁{ ▁ret ▁= ▁1 ▁; ▁BN _ zero ▁( ▁rr ▁) ▁; ▁} ▁else ▁{ ▁ret ▁= ▁BN _ one ▁( ▁rr ▁) ▁; ▁} ▁return ▁ret ▁; ▁} ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁d ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁r ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁val ▁[ ▁0 ▁] ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁val ▁[ ▁0 ▁] ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁in _ mont ▁!= ▁NULL ▁) ▁m ont ▁= ▁in _ mont ▁; ▁else ▁{ ▁if ▁( ▁( ▁m ont ▁= ▁BN _ M ONT _ CTX _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ M ONT _ CTX _ set ▁( ▁m ont ▁, ▁m ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁a ▁-> ▁neg ▁|| ▁BN _ ucmp ▁( ▁a ▁, ▁m ▁) ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁! ▁BN _ nn mod ▁( ▁val ▁[ ▁0 ▁] ▁, ▁a ▁, ▁m ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁aa ▁= ▁val ▁[ ▁0 ▁] ▁; ▁} ▁else ▁aa ▁= ▁a ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁aa ▁) ▁) ▁{ ▁BN _ zero ▁( ▁rr ▁) ▁; ▁ret ▁= ▁1 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ to _ mon tg om ery ▁( ▁val ▁[ ▁0 ▁] ▁, ▁aa ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁window ▁= ▁BN _ window _ bits _ for _ exponent _ size ▁( ▁bits ▁) ▁; ▁if ▁( ▁window ▁> ▁1 ▁) ▁{ ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁d ▁, ▁val ▁[ ▁0 ▁] ▁, ▁val ▁[ ▁0 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁j ▁= ▁1 ▁<< ▁( ▁window ▁- ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁( ▁val ▁[ ▁i ▁] ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁|| ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁val ▁[ ▁i ▁] ▁, ▁val ▁[ ▁i ▁- ▁1 ▁] ▁, ▁d ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁} ▁start ▁= ▁1 ▁; ▁wvalue ▁= ▁0 ▁; ▁w start ▁= ▁bits ▁- ▁1 ▁; ▁w end ▁= ▁0 ▁; ▁# if ▁1 ▁j ▁= ▁m ▁-> ▁top ▁; ▁if ▁( ▁m ▁-> ▁d ▁[ ▁j ▁- ▁1 ▁] ▁& ▁( ▁( ▁( ▁BN _ ULONG ▁) ▁1 ▁) ▁<< ▁( ▁BN _ BITS 2 ▁- ▁1 ▁) ▁) ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁r ▁, ▁j ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁r ▁-> ▁d ▁[ ▁0 ▁] ▁= ▁( ▁0 ▁- ▁m ▁-> ▁d ▁[ ▁0 ▁] ▁) ▁& ▁BN _ MASK 2 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁r ▁-> ▁d ▁[ ▁i ▁] ▁= ▁( ▁ ~ ▁m ▁-> ▁d ▁[ ▁i ▁] ▁) ▁& ▁BN _ MASK 2 ▁; ▁r ▁-> ▁top ▁= ▁j ▁; ▁bn _ correct _ top ▁( ▁r ▁) ▁; ▁} ▁else ▁# endif ▁if ▁( ▁! ▁BN _ to _ mon tg om ery ▁( ▁r ▁, ▁BN _ value _ one ▁( ▁) ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁BN _ is _ bit _ set ▁( ▁p ▁, ▁w start ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁! ▁start ▁) ▁{ ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁r ▁, ▁r ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁w start ▁== ▁0 ▁) ▁break ▁; ▁w start ▁-- ▁; ▁continue ▁; ▁} ▁j ▁= ▁w start ▁; ▁wvalue ▁= ▁1 ▁; ▁w end ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁window ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁w start ▁- ▁i ▁< ▁0 ▁) ▁break ▁; ▁if ▁( ▁BN _ is _ bit _ set ▁( ▁p ▁, ▁w start ▁- ▁i ▁) ▁) ▁{ ▁wvalue ▁<<= ▁( ▁i ▁- ▁w end ▁) ▁; ▁wvalue ▁|= ▁1 ▁; ▁w end ▁= ▁i ▁; ▁} ▁} ▁j ▁= ▁w end ▁+ ▁1 ▁; ▁if ▁( ▁! ▁start ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁r ▁, ▁r ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁r ▁, ▁r ▁, ▁val ▁[ ▁wvalue ▁>> ▁1 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁w start ▁-= ▁w end ▁+ ▁1 ▁; ▁wvalue ▁= ▁0 ▁; ▁start ▁= ▁0 ▁; ▁if ▁( ▁w start ▁< ▁0 ▁) ▁break ▁; ▁} ▁# if ▁defined ▁( ▁SPARC _ T 4_ M ONT ▁) ▁if ▁( ▁OPENSSL _ spar cv 9 cap _ P ▁[ ▁0 ▁] ▁& ▁( ▁SPAR CV 9_ VIS 3 ▁| ▁SPAR CV 9_ PREFER _ FPU ▁) ▁) ▁{ ▁j ▁= ▁m ont ▁-> ▁N ▁. ▁top ▁; ▁val ▁[ ▁0 ▁] ▁-> ▁d ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁val ▁[ ▁0 ▁] ▁-> ▁d ▁[ ▁i ▁] ▁= ▁0 ▁; ▁val ▁[ ▁0 ▁] ▁-> ▁top ▁= ▁j ▁; ▁if ▁( ▁! ▁BN _ mod _ mul _ mon tg om ery ▁( ▁rr ▁, ▁r ▁, ▁val ▁[ ▁0 ▁] ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁# endif ▁if ▁( ▁! ▁BN _ from _ mon tg om ery ▁( ▁rr ▁, ▁r ▁, ▁m ont ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁in _ mont ▁== ▁NULL ▁) ▁BN _ M ONT _ CTX _ free ▁( ▁m ont ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁bn _ check _ top ▁( ▁rr ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁frame _ thread _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁int ▁thread _ count ▁= ▁avctx ▁-> ▁thread _ count ▁; ▁AVCodec ▁* ▁codec ▁= ▁avctx ▁-> ▁codec ▁; ▁AVCodecContext ▁* ▁src ▁= ▁avctx ▁; ▁Frame ThreadContext ▁* ▁fctx ▁; ▁int ▁i ▁, ▁err ▁= ▁0 ▁; ▁if ▁( ▁! ▁thread _ count ▁) ▁{ ▁int ▁nb _ cpus ▁= ▁ff _ get _ logical _ cpus ▁( ▁avctx ▁) ▁; ▁if ▁( ▁( ▁avctx ▁-> ▁debug ▁& ▁( ▁FF _ DEBUG _ VIS _ QP ▁| ▁FF _ DEBUG _ VIS _ MB _ TYPE ▁) ▁) ▁|| ▁avctx ▁-> ▁debug _ mv ▁) ▁nb _ cpus ▁= ▁1 ▁; ▁if ▁( ▁nb _ cpus ▁> ▁1 ▁) ▁thread _ count ▁= ▁avctx ▁-> ▁thread _ count ▁= ▁FF MIN ▁( ▁nb _ cpus ▁+ ▁1 ▁, ▁MAX _ AUTO _ THREADS ▁) ▁; ▁else ▁thread _ count ▁= ▁avctx ▁-> ▁thread _ count ▁= ▁1 ▁; ▁} ▁if ▁( ▁thread _ count ▁<= ▁1 ▁) ▁{ ▁avctx ▁-> ▁active _ thread _ type ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁avctx ▁-> ▁thread _ opaque ▁= ▁fctx ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁Frame ThreadContext ▁) ▁) ▁; ▁fctx ▁-> ▁threads ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁Per ThreadContext ▁) ▁* ▁thread _ count ▁) ▁; ▁pthread _ mutex _ init ▁( ▁& ▁fctx ▁-> ▁buffer _ mutex ▁, ▁NULL ▁) ▁; ▁fctx ▁-> ▁delay ing ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁AVCodecContext ▁* ▁copy ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVCodecContext ▁) ▁) ▁; ▁Per ThreadContext ▁* ▁p ▁= ▁& ▁fctx ▁-> ▁threads ▁[ ▁i ▁] ▁; ▁pthread _ mutex _ init ▁( ▁& ▁p ▁-> ▁mutex ▁, ▁NULL ▁) ▁; ▁pthread _ mutex _ init ▁( ▁& ▁p ▁-> ▁progress _ mutex ▁, ▁NULL ▁) ▁; ▁pthread _ cond _ init ▁( ▁& ▁p ▁-> ▁input _ cond ▁, ▁NULL ▁) ▁; ▁pthread _ cond _ init ▁( ▁& ▁p ▁-> ▁progress _ cond ▁, ▁NULL ▁) ▁; ▁pthread _ cond _ init ▁( ▁& ▁p ▁-> ▁output _ cond ▁, ▁NULL ▁) ▁; ▁p ▁-> ▁parent ▁= ▁fctx ▁; ▁p ▁-> ▁avctx ▁= ▁copy ▁; ▁if ▁( ▁! ▁copy ▁) ▁{ ▁err ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁error ▁; ▁} ▁* ▁copy ▁= ▁* ▁src ▁; ▁copy ▁-> ▁thread _ opaque ▁= ▁p ▁; ▁copy ▁-> ▁pkt ▁= ▁& ▁p ▁-> ▁avpkt ▁; ▁if ▁( ▁! ▁i ▁) ▁{ ▁src ▁= ▁copy ▁; ▁if ▁( ▁codec ▁-> ▁init ▁) ▁err ▁= ▁codec ▁-> ▁init ▁( ▁copy ▁) ▁; ▁update _ context _ from _ thread ▁( ▁avctx ▁, ▁copy ▁, ▁1 ▁) ▁; ▁} ▁else ▁{ ▁copy ▁-> ▁priv _ data ▁= ▁av _ malloc ▁( ▁codec ▁-> ▁priv _ data _ size ▁) ▁; ▁if ▁( ▁! ▁copy ▁-> ▁priv _ data ▁) ▁{ ▁err ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁error ▁; ▁} ▁memcpy ▁( ▁copy ▁-> ▁priv _ data ▁, ▁src ▁-> ▁priv _ data ▁, ▁codec ▁-> ▁priv _ data _ size ▁) ▁; ▁copy ▁-> ▁internal ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVCodec Internal ▁) ▁) ▁; ▁if ▁( ▁! ▁copy ▁-> ▁internal ▁) ▁{ ▁err ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁error ▁; ▁} ▁* ▁copy ▁-> ▁internal ▁= ▁* ▁src ▁-> ▁internal ▁; ▁copy ▁-> ▁internal ▁-> ▁is _ copy ▁= ▁1 ▁; ▁if ▁( ▁codec ▁-> ▁init _ thread _ copy ▁) ▁err ▁= ▁codec ▁-> ▁init _ thread _ copy ▁( ▁copy ▁) ▁; ▁} ▁if ▁( ▁err ▁) ▁goto ▁error ▁; ▁err ▁= ▁AVERROR ▁( ▁pthread _ create ▁( ▁& ▁p ▁-> ▁thread ▁, ▁NULL ▁, ▁frame _ worker _ thread ▁, ▁p ▁) ▁) ▁; ▁p ▁-> ▁thread _ init ▁= ▁! ▁err ▁; ▁if ▁( ▁! ▁p ▁-> ▁thread _ init ▁) ▁goto ▁error ▁; ▁} ▁return ▁0 ▁; ▁error ▁: ▁frame _ thread _ free ▁( ▁avctx ▁, ▁i ▁+ ▁1 ▁) ▁; ▁return ▁err ▁; ▁}	1
▁static ▁void ▁test _ memory _ null _ empty ▁( ▁const ▁unsigned ▁char ▁* ▁m ▁, ▁char ▁c ▁) ▁{ ▁if ▁( ▁m ▁== ▁NULL ▁) ▁test _ printf _ stderr ▁( ▁"% 4 s % c % s \ n " ▁, ▁"" ▁, ▁c ▁, ▁" NULL " ▁) ▁; ▁else ▁test _ printf _ stderr ▁( ▁"%04 x % c % s \ n " ▁, ▁0 u ▁, ▁c ▁, ▁" empty " ▁) ▁; ▁}	0
▁static ▁int ▁add _ file ▁( ▁AVFormatContext ▁* ▁av f ▁, ▁char ▁* ▁filename ▁, ▁Concat File ▁* ▁* ▁r file ▁, ▁unsigned ▁* ▁nb _ files _ alloc ▁) ▁{ ▁Concat Context ▁* ▁cat ▁= ▁av f ▁-> ▁priv _ data ▁; ▁Concat File ▁* ▁file ▁; ▁char ▁* ▁url ▁= ▁NULL ▁; ▁const ▁char ▁* ▁proto ▁; ▁size _ t ▁url _ len ▁, ▁proto _ len ▁; ▁int ▁ret ▁; ▁if ▁( ▁cat ▁-> ▁safe ▁> ▁0 ▁&& ▁! ▁safe _ filename ▁( ▁filename ▁) ▁) ▁{ ▁av _ log ▁( ▁av f ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsafe filename ' % s '\ n " ▁, ▁filename ▁) ▁; ▁FAIL ▁( ▁AVERROR ▁( ▁EPERM ▁) ▁) ▁; ▁} ▁proto ▁= ▁avio _ find _ protocol _ name ▁( ▁filename ▁) ▁; ▁proto _ len ▁= ▁proto ▁? ▁strlen ▁( ▁proto ▁) ▁: ▁0 ▁; ▁if ▁( ▁proto ▁&& ▁! ▁memcmp ▁( ▁filename ▁, ▁proto ▁, ▁proto _ len ▁) ▁&& ▁( ▁filename ▁[ ▁proto _ len ▁] ▁== ▁' ▁' ▁|| ▁filename ▁[ ▁proto _ len ▁] ▁== ▁' ▁' ▁) ▁) ▁{ ▁url ▁= ▁filename ▁; ▁filename ▁= ▁NULL ▁; ▁} ▁else ▁{ ▁url _ len ▁= ▁strlen ▁( ▁av f ▁-> ▁filename ▁) ▁+ ▁strlen ▁( ▁filename ▁) ▁+ ▁16 ▁; ▁if ▁( ▁! ▁( ▁url ▁= ▁av _ malloc ▁( ▁url _ len ▁) ▁) ▁) ▁FAIL ▁( ▁AVERROR ▁( ▁ENOMEM ▁) ▁) ▁; ▁ff _ make _ absolute _ url ▁( ▁url ▁, ▁url _ len ▁, ▁av f ▁-> ▁filename ▁, ▁filename ▁) ▁; ▁av _ freep ▁( ▁& ▁filename ▁) ▁; ▁} ▁if ▁( ▁cat ▁-> ▁nb _ files ▁>= ▁* ▁nb _ files _ alloc ▁) ▁{ ▁size _ t ▁n ▁= ▁FF MAX ▁( ▁* ▁nb _ files _ alloc ▁* ▁2 ▁, ▁16 ▁) ▁; ▁Concat File ▁* ▁new _ files ▁; ▁if ▁( ▁n ▁<= ▁cat ▁-> ▁nb _ files ▁|| ▁n ▁> ▁SIZE _ MAX ▁/ ▁sizeof ▁( ▁* ▁cat ▁-> ▁files ▁) ▁|| ▁! ▁( ▁new _ files ▁= ▁av _ realloc ▁( ▁cat ▁-> ▁files ▁, ▁n ▁* ▁sizeof ▁( ▁* ▁cat ▁-> ▁files ▁) ▁) ▁) ▁) ▁FAIL ▁( ▁AVERROR ▁( ▁ENOMEM ▁) ▁) ▁; ▁cat ▁-> ▁files ▁= ▁new _ files ▁; ▁* ▁nb _ files _ alloc ▁= ▁n ▁; ▁} ▁file ▁= ▁& ▁cat ▁-> ▁files ▁[ ▁cat ▁-> ▁nb _ files ▁++ ▁] ▁; ▁memset ▁( ▁file ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁file ▁) ▁) ▁; ▁* ▁r file ▁= ▁file ▁; ▁file ▁-> ▁url ▁= ▁url ▁; ▁file ▁-> ▁start _ time ▁= ▁AV _ NOP TS _ VALUE ▁; ▁file ▁-> ▁duration ▁= ▁AV _ NOP TS _ VALUE ▁; ▁file ▁-> ▁next _ dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁file ▁-> ▁in point ▁= ▁AV _ NOP TS _ VALUE ▁; ▁file ▁-> ▁out point ▁= ▁AV _ NOP TS _ VALUE ▁; ▁return ▁0 ▁; ▁fail ▁: ▁av _ free ▁( ▁url ▁) ▁; ▁av _ free ▁( ▁filename ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁x 509 v 3_ cache _ extensions ▁( ▁X 509 ▁* ▁x ▁) ▁{ ▁BASIC _ CONSTRAINTS ▁* ▁bs ▁; ▁ASN 1_ BIT _ STRING ▁* ▁usage ▁; ▁ASN 1_ BIT _ STRING ▁* ▁ns ▁; ▁STACK _ OF ▁( ▁ASN 1_ OBJECT ▁) ▁* ▁ext usage ▁; ▁int ▁i ▁; ▁if ▁( ▁x ▁-> ▁ex _ flags ▁& ▁EX FLAG _ SET ▁) ▁return ▁; ▁# ifndef ▁NO _ SHA ▁X 509_ digest ▁( ▁x ▁, ▁EVP _ sha 1 ▁( ▁) ▁, ▁x ▁-> ▁sha 1_ hash ▁, ▁NULL ▁) ▁; ▁# endif ▁if ▁( ▁! ▁X 509_ NAME _ cmp ▁( ▁X 509_ get _ subject _ name ▁( ▁x ▁) ▁, ▁X 509_ get _ iss uer _ name ▁( ▁x ▁) ▁) ▁) ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ SS ▁; ▁if ▁( ▁! ▁X 509_ get _ version ▁( ▁x ▁) ▁) ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ V 1 ▁; ▁if ▁( ▁( ▁bs ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ basic _ constraints ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁if ▁( ▁bs ▁-> ▁ca ▁) ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ CA ▁; ▁if ▁( ▁bs ▁-> ▁path len ▁) ▁{ ▁if ▁( ▁( ▁bs ▁-> ▁path len ▁-> ▁type ▁== ▁V _ ASN 1_ NEG _ INTEGER ▁) ▁|| ▁! ▁bs ▁-> ▁ca ▁) ▁{ ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ INVALID ▁; ▁x ▁-> ▁ex _ path len ▁= ▁0 ▁; ▁} ▁else ▁x ▁-> ▁ex _ path len ▁= ▁ASN 1_ INTEGER _ get ▁( ▁bs ▁-> ▁path len ▁) ▁; ▁} ▁else ▁x ▁-> ▁ex _ path len ▁= ▁-1 ▁; ▁BASIC _ CONSTRAINTS _ free ▁( ▁bs ▁) ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ B CONS ▁; ▁} ▁if ▁( ▁( ▁usage ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ key _ usage ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁if ▁( ▁usage ▁-> ▁length ▁> ▁0 ▁) ▁{ ▁x ▁-> ▁ex _ k usage ▁= ▁usage ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁if ▁( ▁usage ▁-> ▁length ▁> ▁1 ▁) ▁x ▁-> ▁ex _ k usage ▁|= ▁usage ▁-> ▁data ▁[ ▁1 ▁] ▁<< ▁8 ▁; ▁} ▁else ▁x ▁-> ▁ex _ k usage ▁= ▁0 ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ K USAGE ▁; ▁ASN 1_ BIT _ STRING _ free ▁( ▁usage ▁) ▁; ▁} ▁x ▁-> ▁ex _ x k usage ▁= ▁0 ▁; ▁if ▁( ▁( ▁ext usage ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ ext _ key _ usage ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ X K USAGE ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ ASN 1_ OBJECT _ num ▁( ▁ext usage ▁) ▁; ▁i ▁++ ▁) ▁{ ▁switch ▁( ▁OBJ _ obj 2 nid ▁( ▁sk _ ASN 1_ OBJECT _ value ▁( ▁ext usage ▁, ▁i ▁) ▁) ▁) ▁{ ▁case ▁NID _ server _ auth ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ SSL _ SERVER ▁; ▁break ▁; ▁case ▁NID _ client _ auth ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ SSL _ CLIENT ▁; ▁break ▁; ▁case ▁NID _ email _ protect ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ S MIME ▁; ▁break ▁; ▁case ▁NID _ code _ sign ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ CODE _ SIGN ▁; ▁break ▁; ▁case ▁NID _ ms _ sg c ▁: ▁case ▁NID _ ns _ sg c ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ S GC ▁; ▁} ▁} ▁sk _ ASN 1_ OBJECT _ pop _ free ▁( ▁ext usage ▁, ▁ASN 1_ OBJECT _ free ▁) ▁; ▁} ▁if ▁( ▁( ▁ns ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ net scape _ cert _ type ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁if ▁( ▁ns ▁-> ▁length ▁> ▁0 ▁) ▁x ▁-> ▁ex _ n sc ert ▁= ▁ns ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁else ▁x ▁-> ▁ex _ n sc ert ▁= ▁0 ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ N SC ERT ▁; ▁ASN 1_ BIT _ STRING _ free ▁( ▁ns ▁) ▁; ▁} ▁x ▁-> ▁sk id ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ subject _ key _ identifier ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁x ▁-> ▁ak id ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ author ity _ key _ identifier ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ SET ▁; ▁}	0
▁static ▁int ▁y op _ read _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁Y op Dec Context ▁* ▁y op ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁AVCodecContext ▁* ▁audio _ dec ▁, ▁* ▁video _ dec ▁; ▁AVStream ▁* ▁audio _ stream ▁, ▁* ▁video _ stream ▁; ▁int ▁frame _ rate ▁, ▁ret ▁; ▁audio _ stream ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁video _ stream ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁video _ stream ▁-> ▁codec ▁-> ▁extradata _ size ▁= ▁8 ▁; ▁video _ stream ▁-> ▁codec ▁-> ▁extradata ▁= ▁av _ malloc z ▁( ▁video _ stream ▁-> ▁codec ▁-> ▁extradata _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁video _ stream ▁-> ▁codec ▁-> ▁extradata ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁audio _ dec ▁= ▁audio _ stream ▁-> ▁codec ▁; ▁audio _ dec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁audio _ dec ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ AD PCM _ I MA _ AP C ▁; ▁audio _ dec ▁-> ▁channels ▁= ▁1 ▁; ▁audio _ dec ▁-> ▁sample _ rate ▁= ▁220 50 ▁; ▁video _ dec ▁= ▁video _ stream ▁-> ▁codec ▁; ▁video _ dec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ VIDEO ▁; ▁video _ dec ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ Y OP ▁; ▁avio _ skip ▁( ▁pb ▁, ▁6 ▁) ▁; ▁frame _ rate ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁; ▁y op ▁-> ▁frame _ size ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁* ▁2048 ▁; ▁video _ dec ▁-> ▁width ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁video _ dec ▁-> ▁height ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁video _ stream ▁-> ▁sample _ aspect _ ratio ▁= ▁( ▁AVR ational ▁) ▁{ ▁1 ▁, ▁2 ▁} ▁; ▁ret ▁= ▁avio _ read ▁( ▁pb ▁, ▁video _ dec ▁-> ▁extradata ▁, ▁8 ▁) ▁; ▁if ▁( ▁ret ▁< ▁8 ▁) ▁return ▁ret ▁< ▁0 ▁? ▁ret ▁: ▁AVERROR _ EOF ▁; ▁y op ▁-> ▁palette _ size ▁= ▁video _ dec ▁-> ▁extradata ▁[ ▁0 ▁] ▁* ▁3 ▁+ ▁4 ▁; ▁y op ▁-> ▁audio _ block _ length ▁= ▁AV _ RL 16 ▁( ▁video _ dec ▁-> ▁extradata ▁+ ▁6 ▁) ▁; ▁if ▁( ▁y op ▁-> ▁audio _ block _ length ▁< ▁9 20 ▁|| ▁y op ▁-> ▁audio _ block _ length ▁+ ▁y op ▁-> ▁palette _ size ▁>= ▁y op ▁-> ▁frame _ size ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Y OP has invalid header \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁avio _ seek ▁( ▁pb ▁, ▁2048 ▁, ▁SEEK _ SET ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁video _ stream ▁, ▁32 ▁, ▁1 ▁, ▁frame _ rate ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁restore _ med ian ▁( ▁uint 8_ t ▁* ▁src ▁, ▁int ▁step ▁, ▁int ▁stride ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁slices ▁, ▁int ▁r mode ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁slice ▁; ▁int ▁A ▁, ▁B ▁, ▁C ▁; ▁uint 8_ t ▁* ▁b src ▁; ▁int ▁slice _ start ▁, ▁slice _ height ▁; ▁const ▁int ▁c mask ▁= ▁ ~ ▁r mode ▁; ▁for ▁( ▁slice ▁= ▁0 ▁; ▁slice ▁< ▁slices ▁; ▁slice ▁++ ▁) ▁{ ▁slice _ start ▁= ▁( ▁( ▁slice ▁* ▁height ▁) ▁/ ▁slices ▁) ▁& ▁c mask ▁; ▁slice _ height ▁= ▁( ▁( ▁( ▁( ▁slice ▁+ ▁1 ▁) ▁* ▁height ▁) ▁/ ▁slices ▁) ▁& ▁c mask ▁) ▁- ▁slice _ start ▁; ▁b src ▁= ▁src ▁+ ▁slice _ start ▁* ▁stride ▁; ▁b src ▁[ ▁0 ▁] ▁+= ▁0 x 80 ▁; ▁A ▁= ▁b src ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁step ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁b src ▁[ ▁i ▁] ▁+= ▁A ▁; ▁A ▁= ▁b src ▁[ ▁i ▁] ▁; ▁} ▁b src ▁+= ▁stride ▁; ▁if ▁( ▁slice _ height ▁== ▁1 ▁) ▁continue ▁; ▁C ▁= ▁b src ▁[ ▁- ▁stride ▁] ▁; ▁b src ▁[ ▁0 ▁] ▁+= ▁C ▁; ▁A ▁= ▁b src ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁step ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁B ▁= ▁b src ▁[ ▁i ▁- ▁stride ▁] ▁; ▁b src ▁[ ▁i ▁] ▁+= ▁mid _ pred ▁( ▁A ▁, ▁B ▁, ▁( ▁uint 8_ t ▁) ▁( ▁A ▁+ ▁B ▁- ▁C ▁) ▁) ▁; ▁C ▁= ▁B ▁; ▁A ▁= ▁b src ▁[ ▁i ▁] ▁; ▁} ▁b src ▁+= ▁stride ▁; ▁for ▁( ▁j ▁= ▁2 ▁; ▁j ▁< ▁slice _ height ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁* ▁step ▁; ▁i ▁+= ▁step ▁) ▁{ ▁B ▁= ▁b src ▁[ ▁i ▁- ▁stride ▁] ▁; ▁b src ▁[ ▁i ▁] ▁+= ▁mid _ pred ▁( ▁A ▁, ▁B ▁, ▁( ▁uint 8_ t ▁) ▁( ▁A ▁+ ▁B ▁- ▁C ▁) ▁) ▁; ▁C ▁= ▁B ▁; ▁A ▁= ▁b src ▁[ ▁i ▁] ▁; ▁} ▁b src ▁+= ▁stride ▁; ▁} ▁} ▁}	1
▁int ▁X 509_ cmp _ time ▁( ▁ASN 1_ TIME ▁* ▁ct m ▁, ▁time _ t ▁* ▁cmp _ time ▁) ▁{ ▁char ▁* ▁str ▁; ▁ASN 1_ TIME ▁atm ▁; ▁time _ t ▁offset ▁; ▁char ▁buff 1 ▁[ ▁24 ▁] ▁, ▁buff 2 ▁[ ▁24 ▁] ▁, ▁* ▁p ▁; ▁int ▁i ▁, ▁j ▁; ▁p ▁= ▁buff 1 ▁; ▁i ▁= ▁ct m ▁-> ▁length ▁; ▁str ▁= ▁( ▁char ▁* ▁) ▁ct m ▁-> ▁data ▁; ▁if ▁( ▁ct m ▁-> ▁type ▁== ▁V _ ASN 1_ UTC TIME ▁) ▁{ ▁if ▁( ▁( ▁i ▁< ▁11 ▁) ▁|| ▁( ▁i ▁> ▁17 ▁) ▁) ▁return ▁( ▁0 ▁) ▁; ▁memcpy ▁( ▁p ▁, ▁str ▁, ▁10 ▁) ▁; ▁p ▁+= ▁10 ▁; ▁str ▁+= ▁10 ▁; ▁} ▁else ▁{ ▁if ▁( ▁i ▁< ▁13 ▁) ▁return ▁0 ▁; ▁memcpy ▁( ▁p ▁, ▁str ▁, ▁12 ▁) ▁; ▁p ▁+= ▁12 ▁; ▁str ▁+= ▁12 ▁; ▁} ▁if ▁( ▁( ▁* ▁str ▁== ▁' ▁' ▁) ▁|| ▁( ▁* ▁str ▁== ▁' ▁' ▁) ▁|| ▁( ▁* ▁str ▁== ▁' ▁' ▁) ▁) ▁{ ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁} ▁else ▁{ ▁* ▁( ▁p ▁++ ▁) ▁= ▁* ▁( ▁str ▁++ ▁) ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁* ▁( ▁str ▁++ ▁) ▁; ▁if ▁( ▁* ▁str ▁== ▁' ▁' ▁) ▁{ ▁str ▁++ ▁; ▁while ▁( ▁( ▁* ▁str ▁>= ▁' ▁' ▁) ▁&& ▁( ▁* ▁str ▁<= ▁' ▁' ▁) ▁) ▁str ▁++ ▁; ▁} ▁} ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁* ▁str ▁== ▁' ▁' ▁) ▁offset ▁= ▁0 ▁; ▁else ▁{ ▁if ▁( ▁( ▁* ▁str ▁!= ▁' ▁' ▁) ▁&& ▁( ▁str ▁[ ▁5 ▁] ▁!= ▁' ▁' ▁) ▁) ▁return ▁( ▁0 ▁) ▁; ▁offset ▁= ▁( ▁( ▁str ▁[ ▁1 ▁] ▁- ▁' ▁' ▁) ▁* ▁10 ▁+ ▁( ▁str ▁[ ▁2 ▁] ▁- ▁' ▁' ▁) ▁) ▁* ▁60 ▁; ▁offset ▁+= ▁( ▁str ▁[ ▁3 ▁] ▁- ▁' ▁' ▁) ▁* ▁10 ▁+ ▁( ▁str ▁[ ▁4 ▁] ▁- ▁' ▁' ▁) ▁; ▁if ▁( ▁* ▁str ▁== ▁' ▁' ▁) ▁offset ▁= ▁- ▁offset ▁; ▁} ▁atm ▁. ▁type ▁= ▁ct m ▁-> ▁type ▁; ▁atm ▁. ▁length ▁= ▁sizeof ▁( ▁buff 2 ▁) ▁; ▁atm ▁. ▁data ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁buff 2 ▁; ▁X 509_ time _ adj ▁( ▁& ▁atm ▁, ▁- ▁offset ▁* ▁60 ▁, ▁cmp _ time ▁) ▁; ▁if ▁( ▁ct m ▁-> ▁type ▁== ▁V _ ASN 1_ UTC TIME ▁) ▁{ ▁i ▁= ▁( ▁buff 1 ▁[ ▁0 ▁] ▁- ▁' ▁' ▁) ▁* ▁10 ▁+ ▁( ▁buff 1 ▁[ ▁1 ▁] ▁- ▁' ▁' ▁) ▁; ▁if ▁( ▁i ▁< ▁50 ▁) ▁i ▁+= ▁100 ▁; ▁j ▁= ▁( ▁buff 2 ▁[ ▁0 ▁] ▁- ▁' ▁' ▁) ▁* ▁10 ▁+ ▁( ▁buff 2 ▁[ ▁1 ▁] ▁- ▁' ▁' ▁) ▁; ▁if ▁( ▁j ▁< ▁50 ▁) ▁j ▁+= ▁100 ▁; ▁if ▁( ▁i ▁< ▁j ▁) ▁return ▁( ▁-1 ▁) ▁; ▁if ▁( ▁i ▁> ▁j ▁) ▁return ▁( ▁1 ▁) ▁; ▁} ▁i ▁= ▁strcmp ▁( ▁buff 1 ▁, ▁buff 2 ▁) ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁return ▁( ▁-1 ▁) ▁; ▁else ▁return ▁( ▁i ▁) ▁; ▁}	0
▁int ▁ff _ m jpeg _ find _ marker ▁( ▁MJ peg Decode Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁* ▁buf _ ptr ▁, ▁const ▁uint 8_ t ▁* ▁buf _ end ▁, ▁const ▁uint 8_ t ▁* ▁* ▁un escaped _ buf _ ptr ▁, ▁int ▁* ▁un escaped _ buf _ size ▁) ▁{ ▁int ▁start _ code ▁; ▁start _ code ▁= ▁find _ marker ▁( ▁buf _ ptr ▁, ▁buf _ end ▁) ▁; ▁if ▁( ▁( ▁buf _ end ▁- ▁* ▁buf _ ptr ▁) ▁> ▁s ▁-> ▁buffer _ size ▁) ▁{ ▁av _ free ▁( ▁s ▁-> ▁buffer ▁) ▁; ▁s ▁-> ▁buffer _ size ▁= ▁buf _ end ▁- ▁* ▁buf _ ptr ▁; ▁s ▁-> ▁buffer ▁= ▁av _ malloc ▁( ▁s ▁-> ▁buffer _ size ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" buff ert oo small , expand ing to % db ytes \ n " ▁, ▁s ▁-> ▁buffer _ size ▁) ▁; ▁} ▁if ▁( ▁start _ code ▁== ▁S OS ▁&& ▁! ▁s ▁-> ▁ls ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁src ▁= ▁* ▁buf _ ptr ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁s ▁-> ▁buffer ▁; ▁while ▁( ▁src ▁< ▁buf _ end ▁) ▁{ ▁uint 8_ t ▁x ▁= ▁* ▁( ▁src ▁++ ▁) ▁; ▁* ▁( ▁dst ▁++ ▁) ▁= ▁x ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁codec _ id ▁!= ▁CODEC _ ID _ TH P ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 xff ▁) ▁{ ▁while ▁( ▁src ▁< ▁buf _ end ▁&& ▁x ▁== ▁0 xff ▁) ▁x ▁= ▁* ▁( ▁src ▁++ ▁) ▁; ▁if ▁( ▁x ▁>= ▁0 xd 0 ▁&& ▁x ▁<= ▁0 xd 7 ▁) ▁* ▁( ▁dst ▁++ ▁) ▁= ▁x ▁; ▁else ▁if ▁( ▁x ▁) ▁break ▁; ▁} ▁} ▁} ▁* ▁un escaped _ buf _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁* ▁un escaped _ buf _ size ▁= ▁dst ▁- ▁s ▁-> ▁buffer ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" esc ap ing removed % t db ytes \ n " ▁, ▁( ▁buf _ end ▁- ▁* ▁buf _ ptr ▁) ▁- ▁( ▁dst ▁- ▁s ▁-> ▁buffer ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁start _ code ▁== ▁S OS ▁&& ▁s ▁-> ▁ls ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁src ▁= ▁* ▁buf _ ptr ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁s ▁-> ▁buffer ▁; ▁int ▁bit _ count ▁= ▁0 ▁; ▁int ▁t ▁= ▁0 ▁, ▁b ▁= ▁0 ▁; ▁Put Bit Context ▁pb ▁; ▁s ▁-> ▁cur _ scan ▁++ ▁; ▁while ▁( ▁src ▁+ ▁t ▁< ▁buf _ end ▁) ▁{ ▁uint 8_ t ▁x ▁= ▁src ▁[ ▁t ▁++ ▁] ▁; ▁if ▁( ▁x ▁== ▁0 xff ▁) ▁{ ▁while ▁( ▁( ▁src ▁+ ▁t ▁< ▁buf _ end ▁) ▁&& ▁x ▁== ▁0 xff ▁) ▁x ▁= ▁src ▁[ ▁t ▁++ ▁] ▁; ▁if ▁( ▁x ▁& ▁0 x 80 ▁) ▁{ ▁t ▁-= ▁2 ▁; ▁break ▁; ▁} ▁} ▁} ▁bit _ count ▁= ▁t ▁* ▁8 ▁; ▁init _ put _ bits ▁( ▁& ▁pb ▁, ▁dst ▁, ▁t ▁) ▁; ▁while ▁( ▁b ▁< ▁t ▁) ▁{ ▁uint 8_ t ▁x ▁= ▁src ▁[ ▁b ▁++ ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁8 ▁, ▁x ▁) ▁; ▁if ▁( ▁x ▁== ▁0 xFF ▁) ▁{ ▁x ▁= ▁src ▁[ ▁b ▁++ ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁7 ▁, ▁x ▁) ▁; ▁bit _ count ▁-- ▁; ▁} ▁} ▁flush _ put _ bits ▁( ▁& ▁pb ▁) ▁; ▁* ▁un escaped _ buf _ ptr ▁= ▁dst ▁; ▁* ▁un escaped _ buf _ size ▁= ▁( ▁bit _ count ▁+ ▁7 ▁) ▁>> ▁3 ▁; ▁} ▁else ▁{ ▁* ▁un escaped _ buf _ ptr ▁= ▁* ▁buf _ ptr ▁; ▁* ▁un escaped _ buf _ size ▁= ▁buf _ end ▁- ▁* ▁buf _ ptr ▁; ▁} ▁return ▁start _ code ▁; ▁}	1
▁static ▁int ▁decode _ cb lk ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁, ▁J peg 2000 Coding Style ▁* ▁co dst y ▁, ▁J peg 2000 T 1 Context ▁* ▁t 1 ▁, ▁J peg 2000 C blk ▁* ▁cb lk ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁band pos ▁) ▁{ ▁int ▁pass no ▁= ▁cb lk ▁-> ▁np asses ▁, ▁pass _ t ▁= ▁2 ▁, ▁bp no ▁= ▁cb lk ▁-> ▁non zer ob its ▁- ▁1 ▁, ▁y ▁; ▁int ▁pass _ cnt ▁= ▁0 ▁; ▁int ▁vert _ ca us al _ ctx _ cst y _ symbol ▁= ▁co dst y ▁-> ▁cb lk _ style ▁& ▁JPEG 2000_ C BLK _ V SC ▁; ▁int ▁term _ cnt ▁= ▁0 ▁; ▁int ▁coder _ type ▁; ▁av _ assert 0 ▁( ▁width ▁<= ▁1024 U ▁&& ▁height ▁<= ▁1024 U ▁) ▁; ▁av _ assert 0 ▁( ▁width ▁* ▁height ▁<= ▁4096 ▁) ▁; ▁memset ▁( ▁t 1 ▁-> ▁data ▁, ▁0 ▁, ▁t 1 ▁-> ▁stride ▁* ▁height ▁* ▁sizeof ▁( ▁* ▁t 1 ▁-> ▁data ▁) ▁) ▁; ▁if ▁( ▁! ▁cb lk ▁-> ▁length ▁) ▁return ▁0 ▁; ▁memset ▁( ▁t 1 ▁-> ▁flags ▁, ▁0 ▁, ▁t 1 ▁-> ▁stride ▁* ▁( ▁height ▁+ ▁2 ▁) ▁* ▁sizeof ▁( ▁* ▁t 1 ▁-> ▁flags ▁) ▁) ▁; ▁cb lk ▁-> ▁data ▁[ ▁cb lk ▁-> ▁length ▁] ▁= ▁0 xff ▁; ▁cb lk ▁-> ▁data ▁[ ▁cb lk ▁-> ▁length ▁+ ▁1 ▁] ▁= ▁0 xff ▁; ▁ff _ mq c _ init dec ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁cb lk ▁-> ▁data ▁, ▁0 ▁, ▁1 ▁) ▁; ▁while ▁( ▁pass no ▁-- ▁) ▁{ ▁switch ▁( ▁pass _ t ▁) ▁{ ▁case ▁0 ▁: ▁decode _ sig pass ▁( ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁bp no ▁+ ▁1 ▁, ▁band pos ▁, ▁vert _ ca us al _ ctx _ cst y _ symbol ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁decode _ ref pass ▁( ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁bp no ▁+ ▁1 ▁, ▁vert _ ca us al _ ctx _ cst y _ symbol ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁av _ assert 2 ▁( ▁! ▁t 1 ▁-> ▁mqc ▁. ▁raw ▁) ▁; ▁decode _ cl n pass ▁( ▁s ▁, ▁t 1 ▁, ▁width ▁, ▁height ▁, ▁bp no ▁+ ▁1 ▁, ▁band pos ▁, ▁co dst y ▁-> ▁cb lk _ style ▁& ▁JPEG 2000_ C BLK _ SEG SYM ▁, ▁vert _ ca us al _ ctx _ cst y _ symbol ▁) ▁; ▁break ▁; ▁} ▁if ▁( ▁co dst y ▁-> ▁cb lk _ style ▁& ▁JPEG 2000_ C BLK _ RESET ▁) ▁ff _ mq c _ init _ contexts ▁( ▁& ▁t 1 ▁-> ▁mqc ▁) ▁; ▁if ▁( ▁pass no ▁&& ▁( ▁coder _ type ▁= ▁needs _ termin ation ▁( ▁co dst y ▁-> ▁cb lk _ style ▁, ▁pass _ cnt ▁) ▁) ▁) ▁{ ▁if ▁( ▁term _ cnt ▁>= ▁cb lk ▁-> ▁nb _ termin ations ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Missing needed termin ation \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ff _ mq c _ init dec ▁( ▁& ▁t 1 ▁-> ▁mqc ▁, ▁cb lk ▁-> ▁data ▁+ ▁cb lk ▁-> ▁data _ start ▁[ ▁++ ▁term _ cnt ▁] ▁, ▁coder _ type ▁== ▁2 ▁, ▁0 ▁) ▁; ▁} ▁pass _ t ▁++ ▁; ▁if ▁( ▁pass _ t ▁== ▁3 ▁) ▁{ ▁bp no ▁-- ▁; ▁pass _ t ▁= ▁0 ▁; ▁} ▁pass _ cnt ▁++ ▁; ▁} ▁if ▁( ▁cb lk ▁-> ▁data ▁+ ▁cb lk ▁-> ▁length ▁- ▁2 ▁* ▁( ▁term _ cnt ▁< ▁cb lk ▁-> ▁nb _ termin ations ▁) ▁!= ▁t 1 ▁-> ▁mqc ▁. ▁bp ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" End mismatch %" ▁PTR DIFF _ SPEC IFIER ▁"\ n " ▁, ▁cb lk ▁-> ▁data ▁+ ▁cb lk ▁-> ▁length ▁- ▁2 ▁* ▁( ▁term _ cnt ▁< ▁cb lk ▁-> ▁nb _ termin ations ▁) ▁- ▁t 1 ▁-> ▁mqc ▁. ▁bp ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁ir 2_ decode _ plane ▁( ▁I r 2 Context ▁* ▁ctx ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁pitch ▁, ▁const ▁uint 8_ t ▁* ▁table ▁) ▁{ ▁int ▁i ▁; ▁int ▁j ▁; ▁int ▁out ▁= ▁0 ▁; ▁if ▁( ▁width ▁& ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁while ▁( ▁out ▁< ▁width ▁) ▁{ ▁int ▁c ▁= ▁ir 2_ get _ code ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁if ▁( ▁c ▁>= ▁0 x 80 ▁) ▁{ ▁c ▁-= ▁0 x 7 F ▁; ▁if ▁( ▁out ▁+ ▁c ▁* ▁2 ▁> ▁width ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁* ▁2 ▁; ▁i ▁++ ▁) ▁dst ▁[ ▁out ▁++ ▁] ▁= ▁0 x 80 ▁; ▁} ▁else ▁{ ▁if ▁( ▁c ▁<= ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁dst ▁[ ▁out ▁++ ▁] ▁= ▁table ▁[ ▁c ▁* ▁2 ▁] ▁; ▁dst ▁[ ▁out ▁++ ▁] ▁= ▁table ▁[ ▁( ▁c ▁* ▁2 ▁) ▁+ ▁1 ▁] ▁; ▁} ▁} ▁dst ▁+= ▁pitch ▁; ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁height ▁; ▁j ▁++ ▁) ▁{ ▁out ▁= ▁0 ▁; ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁<= ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁while ▁( ▁out ▁< ▁width ▁) ▁{ ▁int ▁c ▁= ▁ir 2_ get _ code ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁if ▁( ▁c ▁>= ▁0 x 80 ▁) ▁{ ▁c ▁-= ▁0 x 7 F ▁; ▁if ▁( ▁out ▁+ ▁c ▁* ▁2 ▁> ▁width ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁* ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁dst ▁[ ▁out ▁] ▁= ▁dst ▁[ ▁out ▁- ▁pitch ▁] ▁; ▁out ▁++ ▁; ▁} ▁} ▁else ▁{ ▁int ▁t ▁; ▁if ▁( ▁c ▁<= ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁t ▁= ▁dst ▁[ ▁out ▁- ▁pitch ▁] ▁+ ▁( ▁table ▁[ ▁c ▁* ▁2 ▁] ▁- ▁128 ▁) ▁; ▁t ▁= ▁av _ clip _ uint 8 ▁( ▁t ▁) ▁; ▁dst ▁[ ▁out ▁] ▁= ▁t ▁; ▁out ▁++ ▁; ▁t ▁= ▁dst ▁[ ▁out ▁- ▁pitch ▁] ▁+ ▁( ▁table ▁[ ▁( ▁c ▁* ▁2 ▁) ▁+ ▁1 ▁] ▁- ▁128 ▁) ▁; ▁t ▁= ▁av _ clip _ uint 8 ▁( ▁t ▁) ▁; ▁dst ▁[ ▁out ▁] ▁= ▁t ▁; ▁out ▁++ ▁; ▁} ▁} ▁dst ▁+= ▁pitch ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁check _ recording _ time ▁( ▁OutputStream ▁* ▁o st ▁) ▁{ ▁OutputFile ▁* ▁of ▁= ▁output _ files ▁[ ▁o st ▁-> ▁file _ index ▁] ▁; ▁if ▁( ▁of ▁-> ▁recording _ time ▁!= ▁INT 64_ MAX ▁&& ▁av _ compare _ ts ▁( ▁o st ▁-> ▁sync _ opts ▁- ▁o st ▁-> ▁first _ pts ▁, ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁time _ base ▁, ▁of ▁-> ▁recording _ time ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁>= ▁0 ▁) ▁{ ▁o st ▁-> ▁is _ p ast _ recording _ time ▁= ▁1 ▁; ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁cp Image ▁( ▁TIFF ▁* ▁in ▁, ▁TIFF ▁* ▁out ▁, ▁read Func ▁fin ▁, ▁write Func ▁fout ▁, ▁uint 32 ▁image length ▁, ▁uint 32 ▁image width ▁, ▁ts ample _ t ▁s pp ▁) ▁{ ▁int ▁status ▁= ▁0 ▁; ▁t data _ t ▁buf ▁= ▁NULL ▁; ▁tsize _ t ▁scan lines ize ▁= ▁TIFF Raster Scan line Size ▁( ▁in ▁) ▁; ▁tsize _ t ▁bytes ▁= ▁scan lines ize ▁* ▁( ▁tsize _ t ▁) ▁image length ▁; ▁if ▁( ▁scan lines ize ▁&& ▁image length ▁&& ▁bytes ▁/ ▁( ▁tsize _ t ▁) ▁image length ▁== ▁scan lines ize ▁) ▁{ ▁buf ▁= ▁_ TIFF malloc ▁( ▁bytes ▁) ▁; ▁if ▁( ▁buf ▁) ▁{ ▁if ▁( ▁( ▁* ▁fin ▁) ▁( ▁in ▁, ▁( ▁uint 8 ▁* ▁) ▁buf ▁, ▁image length ▁, ▁image width ▁, ▁s pp ▁) ▁) ▁{ ▁status ▁= ▁( ▁* ▁fout ▁) ▁( ▁out ▁, ▁( ▁uint 8 ▁* ▁) ▁buf ▁, ▁image length ▁, ▁image width ▁, ▁s pp ▁) ▁; ▁} ▁_ TIFF free ▁( ▁buf ▁) ▁; ▁} ▁else ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , can ' t alloc ates pace for image buffer " ▁) ▁; ▁} ▁} ▁else ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , nos pace for image buffer " ▁) ▁; ▁} ▁return ▁status ▁; ▁}	1
▁SSL ▁* ▁SSL _ dup ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁STACK _ OF ▁( ▁X 509_ NAME ▁) ▁* ▁sk ▁; ▁X 509_ NAME ▁* ▁xn ▁; ▁SSL ▁* ▁ret ▁; ▁int ▁i ▁; ▁if ▁( ▁! ▁SSL _ in _ init ▁( ▁s ▁) ▁|| ▁! ▁SSL _ in _ before ▁( ▁s ▁) ▁) ▁{ ▁CRYPTO _ UP _ REF ▁( ▁& ▁s ▁-> ▁references ▁, ▁& ▁i ▁, ▁s ▁-> ▁lock ▁) ▁; ▁return ▁s ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁SSL _ new ▁( ▁SSL _ get _ SSL _ CTX ▁( ▁s ▁) ▁) ▁) ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁s ▁-> ▁session ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁SSL _ copy _ session _ id ▁( ▁ret ▁, ▁s ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁SSL _ set _ ssl _ method ▁( ▁ret ▁, ▁s ▁-> ▁method ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁s ▁-> ▁cert ▁!= ▁NULL ▁) ▁{ ▁ssl _ cert _ free ▁( ▁ret ▁-> ▁cert ▁) ▁; ▁ret ▁-> ▁cert ▁= ▁ssl _ cert _ dup ▁( ▁s ▁-> ▁cert ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cert ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁SSL _ set _ session _ id _ context ▁( ▁ret ▁, ▁s ▁-> ▁sid _ ctx ▁, ▁( ▁int ▁) ▁s ▁-> ▁sid _ ctx _ length ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁ssl _ d ane _ dup ▁( ▁ret ▁, ▁s ▁) ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁version ▁= ▁s ▁-> ▁version ▁; ▁ret ▁-> ▁options ▁= ▁s ▁-> ▁options ▁; ▁ret ▁-> ▁mode ▁= ▁s ▁-> ▁mode ▁; ▁SSL _ set _ max _ cert _ list ▁( ▁ret ▁, ▁SSL _ get _ max _ cert _ list ▁( ▁s ▁) ▁) ▁; ▁SSL _ set _ read _ ahead ▁( ▁ret ▁, ▁SSL _ get _ read _ ahead ▁( ▁s ▁) ▁) ▁; ▁ret ▁-> ▁msg _ callback ▁= ▁s ▁-> ▁msg _ callback ▁; ▁ret ▁-> ▁msg _ callback _ arg ▁= ▁s ▁-> ▁msg _ callback _ arg ▁; ▁SSL _ set _ verify ▁( ▁ret ▁, ▁SSL _ get _ verify _ mode ▁( ▁s ▁) ▁, ▁SSL _ get _ verify _ callback ▁( ▁s ▁) ▁) ▁; ▁SSL _ set _ verify _ depth ▁( ▁ret ▁, ▁SSL _ get _ verify _ depth ▁( ▁s ▁) ▁) ▁; ▁ret ▁-> ▁generate _ session _ id ▁= ▁s ▁-> ▁generate _ session _ id ▁; ▁SSL _ set _ info _ callback ▁( ▁ret ▁, ▁SSL _ get _ info _ callback ▁( ▁s ▁) ▁) ▁; ▁if ▁( ▁! ▁CRYPTO _ dup _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL ▁, ▁& ▁ret ▁-> ▁ex _ data ▁, ▁& ▁s ▁-> ▁ex _ data ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁s ▁-> ▁rb io ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁BIO _ dup _ state ▁( ▁s ▁-> ▁rb io ▁, ▁( ▁char ▁* ▁) ▁& ▁ret ▁-> ▁rb io ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁w bio ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁s ▁-> ▁w bio ▁!= ▁s ▁-> ▁rb io ▁) ▁{ ▁if ▁( ▁! ▁BIO _ dup _ state ▁( ▁s ▁-> ▁w bio ▁, ▁( ▁char ▁* ▁) ▁& ▁ret ▁-> ▁w bio ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁{ ▁BIO _ up _ ref ▁( ▁ret ▁-> ▁rb io ▁) ▁; ▁ret ▁-> ▁w bio ▁= ▁ret ▁-> ▁rb io ▁; ▁} ▁} ▁ret ▁-> ▁server ▁= ▁s ▁-> ▁server ▁; ▁if ▁( ▁s ▁-> ▁handshake _ func ▁) ▁{ ▁if ▁( ▁s ▁-> ▁server ▁) ▁SSL _ set _ accept _ state ▁( ▁ret ▁) ▁; ▁else ▁SSL _ set _ connect _ state ▁( ▁ret ▁) ▁; ▁} ▁ret ▁-> ▁shutdown ▁= ▁s ▁-> ▁shutdown ▁; ▁ret ▁-> ▁hit ▁= ▁s ▁-> ▁hit ▁; ▁ret ▁-> ▁default _ passwd _ callback ▁= ▁s ▁-> ▁default _ passwd _ callback ▁; ▁ret ▁-> ▁default _ passwd _ callback _ userdata ▁= ▁s ▁-> ▁default _ passwd _ callback _ userdata ▁; ▁X 509_ VERIFY _ PARAM _ inherit ▁( ▁ret ▁-> ▁param ▁, ▁s ▁-> ▁param ▁) ▁; ▁if ▁( ▁s ▁-> ▁cipher _ list ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ret ▁-> ▁cipher _ list ▁= ▁sk _ SSL _ CIPHER _ dup ▁( ▁s ▁-> ▁cipher _ list ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁s ▁-> ▁cipher _ list _ by _ id ▁!= ▁NULL ▁) ▁if ▁( ▁( ▁ret ▁-> ▁cipher _ list _ by _ id ▁= ▁sk _ SSL _ CIPHER _ dup ▁( ▁s ▁-> ▁cipher _ list _ by _ id ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁s ▁-> ▁ca _ names ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁sk ▁= ▁sk _ X 509_ NAME _ dup ▁( ▁s ▁-> ▁ca _ names ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁ca _ names ▁= ▁sk ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ X 509_ NAME _ num ▁( ▁sk ▁) ▁; ▁i ▁++ ▁) ▁{ ▁xn ▁= ▁sk _ X 509_ NAME _ value ▁( ▁sk ▁, ▁i ▁) ▁; ▁if ▁( ▁sk _ X 509_ NAME _ set ▁( ▁sk ▁, ▁i ▁, ▁X 509_ NAME _ dup ▁( ▁xn ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁X 509_ NAME _ free ▁( ▁xn ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁} ▁return ▁ret ▁; ▁err ▁: ▁SSL _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁int ▁state _ machine ▁( ▁SSL ▁* ▁s ▁, ▁int ▁server ▁) ▁{ ▁BUF _ MEM ▁* ▁buf ▁= ▁NULL ▁; ▁void ▁( ▁* ▁cb ▁) ▁( ▁const ▁SSL ▁* ▁ssl ▁, ▁int ▁type ▁, ▁int ▁val ▁) ▁= ▁NULL ▁; ▁OSSL _ STATE M ▁* ▁st ▁= ▁& ▁s ▁-> ▁state m ▁; ▁int ▁ret ▁= ▁-1 ▁; ▁int ▁ss ret ▁; ▁if ▁( ▁st ▁-> ▁state ▁== ▁MSG _ FLOW _ ERROR ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁clear _ sys _ error ▁( ▁) ▁; ▁cb ▁= ▁get _ callback ▁( ▁s ▁) ▁; ▁st ▁-> ▁in _ handshake ▁++ ▁; ▁if ▁( ▁! ▁SSL _ in _ init ▁( ▁s ▁) ▁|| ▁SSL _ in _ before ▁( ▁s ▁) ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁s 3 ▁. ▁flags ▁& ▁TLS 1_ FLAGS _ STAT EL ESS ▁) ▁== ▁0 ▁&& ▁! ▁SSL _ clear ▁( ▁s ▁) ▁) ▁return ▁-1 ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ SCT P ▁if ▁( ▁SSL _ IS _ DT LS ▁( ▁s ▁) ▁&& ▁BIO _ d gram _ is _ sctp ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁) ▁{ ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ SCT P _ SET _ IN _ HAND SHAKE ▁, ▁st ▁-> ▁in _ handshake ▁, ▁NULL ▁) ▁; ▁} ▁# endif ▁if ▁( ▁st ▁-> ▁state ▁== ▁MSG _ FLOW _ UN INIT ED ▁|| ▁st ▁-> ▁state ▁== ▁MSG _ FLOW _ FINISHED ▁) ▁{ ▁if ▁( ▁st ▁-> ▁state ▁== ▁MSG _ FLOW _ UN INIT ED ▁) ▁{ ▁st ▁-> ▁hand _ state ▁= ▁TLS _ ST _ BEFORE ▁; ▁st ▁-> ▁request _ state ▁= ▁TLS _ ST _ BEFORE ▁; ▁} ▁s ▁-> ▁server ▁= ▁server ▁; ▁if ▁( ▁cb ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁SSL _ IS _ FIRST _ HAND SHAKE ▁( ▁s ▁) ▁|| ▁! ▁SSL _ IS _ TLS 13 ▁( ▁s ▁) ▁) ▁cb ▁( ▁s ▁, ▁SSL _ CB _ HAND SHAKE _ START ▁, ▁1 ▁) ▁; ▁} ▁if ▁( ▁SSL _ IS _ DT LS ▁( ▁s ▁) ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁version ▁& ▁0 xff 00 ▁) ▁!= ▁( ▁DTLS 1_ VERSION ▁& ▁0 xff 00 ▁) ▁&& ▁( ▁server ▁|| ▁( ▁s ▁-> ▁version ▁& ▁0 xff 00 ▁) ▁!= ▁( ▁DTLS 1_ BAD _ VER ▁& ▁0 xff 00 ▁) ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ NO _ ALERT ▁, ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁( ▁s ▁-> ▁version ▁>> ▁8 ▁) ▁!= ▁SSL 3_ VERSION _ MAJOR ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ NO _ ALERT ▁, ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁if ▁( ▁! ▁ssl _ security ▁( ▁s ▁, ▁SSL _ SEC OP _ VERSION ▁, ▁0 ▁, ▁s ▁-> ▁version ▁, ▁NULL ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ NO _ ALERT ▁, ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁s ▁-> ▁init _ buf ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁buf ▁= ▁BUF _ MEM _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ NO _ ALERT ▁, ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁! ▁BUF _ MEM _ grow ▁( ▁buf ▁, ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ NO _ ALERT ▁, ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁s ▁-> ▁init _ buf ▁= ▁buf ▁; ▁buf ▁= ▁NULL ▁; ▁} ▁if ▁( ▁! ▁ssl 3_ setup _ buffers ▁( ▁s ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ NO _ ALERT ▁, ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁s ▁-> ▁init _ num ▁= ▁0 ▁; ▁s ▁-> ▁s 3 ▁. ▁change _ cipher _ spec ▁= ▁0 ▁; ▁# ifndef ▁OPENSSL _ NO _ SCT P ▁if ▁( ▁! ▁SSL _ IS _ DT LS ▁( ▁s ▁) ▁|| ▁! ▁BIO _ d gram _ is _ sctp ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁) ▁# endif ▁if ▁( ▁! ▁ssl _ init _ wb io _ buffer ▁( ▁s ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ NO _ ALERT ▁, ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁end ▁; ▁} ▁if ▁( ▁( ▁SSL _ in _ before ▁( ▁s ▁) ▁) ▁|| ▁s ▁-> ▁re neg ot iate ▁) ▁{ ▁if ▁( ▁! ▁tls _ setup _ handshake ▁( ▁s ▁) ▁) ▁{ ▁goto ▁end ▁; ▁} ▁if ▁( ▁SSL _ IS _ FIRST _ HAND SHAKE ▁( ▁s ▁) ▁) ▁st ▁-> ▁read _ state _ first _ init ▁= ▁1 ▁; ▁} ▁st ▁-> ▁state ▁= ▁MSG _ FLOW _ WRIT ING ▁; ▁init _ write _ state _ machine ▁( ▁s ▁) ▁; ▁} ▁while ▁( ▁st ▁-> ▁state ▁!= ▁MSG _ FLOW _ FINISHED ▁) ▁{ ▁if ▁( ▁st ▁-> ▁state ▁== ▁MSG _ FLOW _ READ ING ▁) ▁{ ▁ss ret ▁= ▁read _ state _ machine ▁( ▁s ▁) ▁; ▁if ▁( ▁ss ret ▁== ▁SUB _ STATE _ FINISHED ▁) ▁{ ▁st ▁-> ▁state ▁= ▁MSG _ FLOW _ WRIT ING ▁; ▁init _ write _ state _ machine ▁( ▁s ▁) ▁; ▁} ▁else ▁{ ▁goto ▁end ▁; ▁} ▁} ▁else ▁if ▁( ▁st ▁-> ▁state ▁== ▁MSG _ FLOW _ WRIT ING ▁) ▁{ ▁ss ret ▁= ▁write _ state _ machine ▁( ▁s ▁) ▁; ▁if ▁( ▁ss ret ▁== ▁SUB _ STATE _ FINISHED ▁) ▁{ ▁st ▁-> ▁state ▁= ▁MSG _ FLOW _ READ ING ▁; ▁init _ read _ state _ machine ▁( ▁s ▁) ▁; ▁} ▁else ▁if ▁( ▁ss ret ▁== ▁SUB _ STATE _ END _ HAND SHAKE ▁) ▁{ ▁st ▁-> ▁state ▁= ▁MSG _ FLOW _ FINISHED ▁; ▁} ▁else ▁{ ▁goto ▁end ▁; ▁} ▁} ▁else ▁{ ▁check _ fatal ▁( ▁s ▁, ▁SSL _ F _ STATE _ MACHINE ▁) ▁; ▁SSL err ▁( ▁SSL _ F _ STATE _ MACHINE ▁, ▁ERR _ R _ SHOULD _ NOT _ HAVE _ BE EN _ CALLED ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁ret ▁= ▁1 ▁; ▁end ▁: ▁st ▁-> ▁in _ handshake ▁-- ▁; ▁# ifndef ▁OPENSSL _ NO _ SCT P ▁if ▁( ▁SSL _ IS _ DT LS ▁( ▁s ▁) ▁&& ▁BIO _ d gram _ is _ sctp ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁) ▁) ▁{ ▁BIO _ ctrl ▁( ▁SSL _ get _ wb io ▁( ▁s ▁) ▁, ▁BIO _ CTRL _ DGRAM _ SCT P _ SET _ IN _ HAND SHAKE ▁, ▁st ▁-> ▁in _ handshake ▁, ▁NULL ▁) ▁; ▁} ▁# endif ▁BUF _ MEM _ free ▁( ▁buf ▁) ▁; ▁if ▁( ▁cb ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁server ▁) ▁cb ▁( ▁s ▁, ▁SSL _ CB _ ACCEPT _ EXIT ▁, ▁ret ▁) ▁; ▁else ▁cb ▁( ▁s ▁, ▁SSL _ CB _ CONNECT _ EXIT ▁, ▁ret ▁) ▁; ▁} ▁return ▁ret ▁; ▁}	0
▁void ▁DES _ string _ to _ key ▁( ▁const ▁char ▁* ▁str ▁, ▁DES _ cblock ▁* ▁key ▁) ▁{ ▁DES _ key _ schedule ▁ks ▁; ▁int ▁i ▁, ▁length ▁; ▁register ▁unsigned ▁char ▁j ▁; ▁memset ▁( ▁key ▁, ▁0 ▁, ▁8 ▁) ▁; ▁length ▁= ▁strlen ▁( ▁str ▁) ▁; ▁# ifdef ▁OLD _ STR _ TO _ KEY ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁( ▁* ▁key ▁) ▁[ ▁i ▁% ▁8 ▁] ▁ ^ = ▁( ▁str ▁[ ▁i ▁] ▁<< ▁1 ▁) ▁; ▁# else ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁j ▁= ▁str ▁[ ▁i ▁] ▁; ▁if ▁( ▁( ▁i ▁% ▁16 ▁) ▁< ▁8 ▁) ▁( ▁* ▁key ▁) ▁[ ▁i ▁% ▁8 ▁] ▁ ^ = ▁( ▁j ▁<< ▁1 ▁) ▁; ▁else ▁{ ▁j ▁= ▁( ▁( ▁j ▁<< ▁4 ▁) ▁& ▁0 xf 0 ▁) ▁| ▁( ▁( ▁j ▁>> ▁4 ▁) ▁& ▁0 x 0 f ▁) ▁; ▁j ▁= ▁( ▁( ▁j ▁<< ▁2 ▁) ▁& ▁0 xcc ▁) ▁| ▁( ▁( ▁j ▁>> ▁2 ▁) ▁& ▁0 x 33 ▁) ▁; ▁j ▁= ▁( ▁( ▁j ▁<< ▁1 ▁) ▁& ▁0 xaa ▁) ▁| ▁( ▁( ▁j ▁>> ▁1 ▁) ▁& ▁0 x 55 ▁) ▁; ▁( ▁* ▁key ▁) ▁[ ▁7 ▁- ▁( ▁i ▁% ▁8 ▁) ▁] ▁ ^ = ▁j ▁; ▁} ▁} ▁# endif ▁DES _ set _ odd _ parity ▁( ▁key ▁) ▁; ▁# ifdef ▁EXPER IMENTAL _ STR _ TO _ STR ONG _ KEY ▁if ▁( ▁DES _ is _ weak _ key ▁( ▁key ▁) ▁) ▁( ▁* ▁key ▁) ▁[ ▁7 ▁] ▁ ^ = ▁0 xF 0 ▁; ▁DES _ set _ key ▁( ▁key ▁, ▁& ▁ks ▁) ▁; ▁# else ▁DES _ set _ key _ unchecked ▁( ▁key ▁, ▁& ▁ks ▁) ▁; ▁# endif ▁DES _ cbc _ cksum ▁( ▁( ▁const ▁unsigned ▁char ▁* ▁) ▁str ▁, ▁key ▁, ▁length ▁, ▁& ▁ks ▁, ▁key ▁) ▁; ▁OPENSSL _ cleanse ▁( ▁& ▁ks ▁, ▁sizeof ▁( ▁ks ▁) ▁) ▁; ▁DES _ set _ odd _ parity ▁( ▁key ▁) ▁; ▁}	1
▁int ▁ff _ m jpeg _ find _ marker ▁( ▁MJ peg Decode Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁* ▁buf _ ptr ▁, ▁const ▁uint 8_ t ▁* ▁buf _ end ▁, ▁const ▁uint 8_ t ▁* ▁* ▁un escaped _ buf _ ptr ▁, ▁int ▁* ▁un escaped _ buf _ size ▁) ▁{ ▁int ▁start _ code ▁; ▁start _ code ▁= ▁find _ marker ▁( ▁buf _ ptr ▁, ▁buf _ end ▁) ▁; ▁av _ fast _ pad ded _ malloc ▁( ▁& ▁s ▁-> ▁buffer ▁, ▁& ▁s ▁-> ▁buffer _ size ▁, ▁buf _ end ▁- ▁* ▁buf _ ptr ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁buffer ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁if ▁( ▁start _ code ▁== ▁S OS ▁&& ▁! ▁s ▁-> ▁ls ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁src ▁= ▁* ▁buf _ ptr ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁s ▁-> ▁buffer ▁; ▁while ▁( ▁src ▁< ▁buf _ end ▁) ▁{ ▁uint 8_ t ▁x ▁= ▁* ▁( ▁src ▁++ ▁) ▁; ▁* ▁( ▁dst ▁++ ▁) ▁= ▁x ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁codec _ id ▁!= ▁CODEC _ ID _ TH P ▁) ▁{ ▁if ▁( ▁x ▁== ▁0 xff ▁) ▁{ ▁while ▁( ▁src ▁< ▁buf _ end ▁&& ▁x ▁== ▁0 xff ▁) ▁x ▁= ▁* ▁( ▁src ▁++ ▁) ▁; ▁if ▁( ▁x ▁>= ▁0 xd 0 ▁&& ▁x ▁<= ▁0 xd 7 ▁) ▁* ▁( ▁dst ▁++ ▁) ▁= ▁x ▁; ▁else ▁if ▁( ▁x ▁) ▁break ▁; ▁} ▁} ▁} ▁* ▁un escaped _ buf _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁* ▁un escaped _ buf _ size ▁= ▁dst ▁- ▁s ▁-> ▁buffer ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" esc ap ing removed % t db ytes \ n " ▁, ▁( ▁buf _ end ▁- ▁* ▁buf _ ptr ▁) ▁- ▁( ▁dst ▁- ▁s ▁-> ▁buffer ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁start _ code ▁== ▁S OS ▁&& ▁s ▁-> ▁ls ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁src ▁= ▁* ▁buf _ ptr ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁s ▁-> ▁buffer ▁; ▁int ▁bit _ count ▁= ▁0 ▁; ▁int ▁t ▁= ▁0 ▁, ▁b ▁= ▁0 ▁; ▁Put Bit Context ▁pb ▁; ▁s ▁-> ▁cur _ scan ▁++ ▁; ▁while ▁( ▁src ▁+ ▁t ▁< ▁buf _ end ▁) ▁{ ▁uint 8_ t ▁x ▁= ▁src ▁[ ▁t ▁++ ▁] ▁; ▁if ▁( ▁x ▁== ▁0 xff ▁) ▁{ ▁while ▁( ▁( ▁src ▁+ ▁t ▁< ▁buf _ end ▁) ▁&& ▁x ▁== ▁0 xff ▁) ▁x ▁= ▁src ▁[ ▁t ▁++ ▁] ▁; ▁if ▁( ▁x ▁& ▁0 x 80 ▁) ▁{ ▁t ▁-= ▁2 ▁; ▁break ▁; ▁} ▁} ▁} ▁bit _ count ▁= ▁t ▁* ▁8 ▁; ▁init _ put _ bits ▁( ▁& ▁pb ▁, ▁dst ▁, ▁t ▁) ▁; ▁while ▁( ▁b ▁< ▁t ▁) ▁{ ▁uint 8_ t ▁x ▁= ▁src ▁[ ▁b ▁++ ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁8 ▁, ▁x ▁) ▁; ▁if ▁( ▁x ▁== ▁0 xFF ▁) ▁{ ▁x ▁= ▁src ▁[ ▁b ▁++ ▁] ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁7 ▁, ▁x ▁) ▁; ▁bit _ count ▁-- ▁; ▁} ▁} ▁flush _ put _ bits ▁( ▁& ▁pb ▁) ▁; ▁* ▁un escaped _ buf _ ptr ▁= ▁dst ▁; ▁* ▁un escaped _ buf _ size ▁= ▁( ▁bit _ count ▁+ ▁7 ▁) ▁>> ▁3 ▁; ▁} ▁else ▁{ ▁* ▁un escaped _ buf _ ptr ▁= ▁* ▁buf _ ptr ▁; ▁* ▁un escaped _ buf _ size ▁= ▁buf _ end ▁- ▁* ▁buf _ ptr ▁; ▁} ▁return ▁start _ code ▁; ▁}	0
▁void ▁ASYNC _ cleanup _ thread ▁( ▁void ▁) ▁{ ▁async _ free _ pool _ internal ▁( ▁async _ get _ pool ▁( ▁) ▁) ▁; ▁}	0
▁static ▁int ▁ir 2_ decode _ plane _ inter ▁( ▁I r 2 Context ▁* ▁ctx ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁pitch ▁, ▁const ▁uint 8_ t ▁* ▁table ▁) ▁{ ▁int ▁j ▁; ▁int ▁out ▁= ▁0 ▁; ▁int ▁c ▁; ▁int ▁t ▁; ▁if ▁( ▁width ▁& ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁height ▁; ▁j ▁++ ▁) ▁{ ▁out ▁= ▁0 ▁; ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁<= ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁while ▁( ▁out ▁< ▁width ▁) ▁{ ▁c ▁= ▁ir 2_ get _ code ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁if ▁( ▁c ▁>= ▁0 x 80 ▁) ▁{ ▁c ▁-= ▁0 x 7 F ▁; ▁out ▁+= ▁c ▁* ▁2 ▁; ▁} ▁else ▁{ ▁t ▁= ▁dst ▁[ ▁out ▁] ▁+ ▁( ▁( ▁( ▁table ▁[ ▁c ▁* ▁2 ▁] ▁- ▁128 ▁) ▁* ▁3 ▁) ▁>> ▁2 ▁) ▁; ▁t ▁= ▁av _ clip _ uint 8 ▁( ▁t ▁) ▁; ▁dst ▁[ ▁out ▁] ▁= ▁t ▁; ▁out ▁++ ▁; ▁t ▁= ▁dst ▁[ ▁out ▁] ▁+ ▁( ▁( ▁( ▁table ▁[ ▁( ▁c ▁* ▁2 ▁) ▁+ ▁1 ▁] ▁- ▁128 ▁) ▁* ▁3 ▁) ▁>> ▁2 ▁) ▁; ▁t ▁= ▁av _ clip _ uint 8 ▁( ▁t ▁) ▁; ▁dst ▁[ ▁out ▁] ▁= ▁t ▁; ▁out ▁++ ▁; ▁} ▁} ▁dst ▁+= ▁pitch ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁MOD _ EXP _ C TIME _ COPY _ FROM _ PRE BUF ▁( ▁BIGNUM ▁* ▁b ▁, ▁int ▁top ▁, ▁unsigned ▁char ▁* ▁buf ▁, ▁int ▁idx ▁, ▁int ▁window ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁width ▁= ▁1 ▁<< ▁window ▁; ▁volatile ▁BN _ ULONG ▁* ▁table ▁= ▁( ▁volatile ▁BN _ ULONG ▁* ▁) ▁buf ▁; ▁if ▁( ▁bn _ w expand ▁( ▁b ▁, ▁top ▁) ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁window ▁<= ▁3 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁, ▁table ▁+= ▁width ▁) ▁{ ▁BN _ ULONG ▁acc ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁width ▁; ▁j ▁++ ▁) ▁{ ▁acc ▁|= ▁table ▁[ ▁j ▁] ▁& ▁( ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁constant _ time _ eq _ int ▁( ▁j ▁, ▁idx ▁) ▁& ▁1 ▁) ▁) ▁; ▁} ▁b ▁-> ▁d ▁[ ▁i ▁] ▁= ▁acc ▁; ▁} ▁} ▁else ▁{ ▁int ▁x stride ▁= ▁1 ▁<< ▁( ▁window ▁- ▁2 ▁) ▁; ▁BN _ ULONG ▁y 0 ▁, ▁y 1 ▁, ▁y 2 ▁, ▁y 3 ▁; ▁i ▁= ▁idx ▁>> ▁( ▁window ▁- ▁2 ▁) ▁; ▁idx ▁&= ▁x stride ▁- ▁1 ▁; ▁y 0 ▁= ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁constant _ time _ eq _ int ▁( ▁i ▁, ▁0 ▁) ▁& ▁1 ▁) ▁; ▁y 1 ▁= ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁constant _ time _ eq _ int ▁( ▁i ▁, ▁1 ▁) ▁& ▁1 ▁) ▁; ▁y 2 ▁= ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁constant _ time _ eq _ int ▁( ▁i ▁, ▁2 ▁) ▁& ▁1 ▁) ▁; ▁y 3 ▁= ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁constant _ time _ eq _ int ▁( ▁i ▁, ▁3 ▁) ▁& ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁, ▁table ▁+= ▁width ▁) ▁{ ▁BN _ ULONG ▁acc ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁x stride ▁; ▁j ▁++ ▁) ▁{ ▁acc ▁|= ▁( ▁( ▁table ▁[ ▁j ▁+ ▁0 ▁* ▁x stride ▁] ▁& ▁y 0 ▁) ▁| ▁( ▁table ▁[ ▁j ▁+ ▁1 ▁* ▁x stride ▁] ▁& ▁y 1 ▁) ▁| ▁( ▁table ▁[ ▁j ▁+ ▁2 ▁* ▁x stride ▁] ▁& ▁y 2 ▁) ▁| ▁( ▁table ▁[ ▁j ▁+ ▁3 ▁* ▁x stride ▁] ▁& ▁y 3 ▁) ▁) ▁& ▁( ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁constant _ time _ eq _ int ▁( ▁j ▁, ▁idx ▁) ▁& ▁1 ▁) ▁) ▁; ▁} ▁b ▁-> ▁d ▁[ ▁i ▁] ▁= ▁acc ▁; ▁} ▁} ▁b ▁-> ▁top ▁= ▁top ▁; ▁b ▁-> ▁flags ▁|= ▁BN _ FLG _ FIXED _ TOP ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁R ENAME ▁( ▁res ample _ common ▁) ▁( ▁Res ample Context ▁* ▁c ▁, ▁void ▁* ▁dest ▁, ▁const ▁void ▁* ▁source ▁, ▁int ▁n ▁, ▁int ▁update _ ctx ▁) ▁{ ▁DE LEM ▁* ▁dst ▁= ▁dest ▁; ▁const ▁DE LEM ▁* ▁src ▁= ▁source ▁; ▁int ▁dst _ index ▁; ▁int ▁index ▁= ▁c ▁-> ▁index ▁; ▁int ▁frac ▁= ▁c ▁-> ▁frac ▁; ▁int ▁sample _ index ▁= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁n ▁; ▁dst _ index ▁++ ▁) ▁{ ▁F ELEM ▁* ▁filter ▁= ▁( ▁( ▁F ELEM ▁* ▁) ▁c ▁-> ▁filter _ bank ▁) ▁+ ▁c ▁-> ▁filter _ alloc ▁* ▁index ▁; ▁F ELEM 2 ▁val ▁= ▁0 ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁filter _ length ▁; ▁i ▁++ ▁) ▁{ ▁val ▁+= ▁src ▁[ ▁sample _ index ▁+ ▁i ▁] ▁* ▁( ▁F ELEM 2 ▁) ▁filter ▁[ ▁i ▁] ▁; ▁} ▁OUT ▁( ▁dst ▁[ ▁dst _ index ▁] ▁, ▁val ▁) ▁; ▁frac ▁+= ▁c ▁-> ▁dst _ incr _ mod ▁; ▁index ▁+= ▁c ▁-> ▁dst _ incr _ div ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁sample _ index ▁+= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁} ▁if ▁( ▁update _ ctx ▁) ▁{ ▁c ▁-> ▁frac ▁= ▁frac ▁; ▁c ▁-> ▁index ▁= ▁index ▁; ▁} ▁return ▁sample _ index ▁; ▁}	0
▁static ▁int ▁read _ restart _ header ▁( ▁M LP Decode Context ▁* ▁m ▁, ▁Get Bit Context ▁* ▁gb p ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁unsigned ▁int ▁substr ▁) ▁{ ▁Sub Stream ▁* ▁s ▁= ▁& ▁m ▁-> ▁substream ▁[ ▁substr ▁] ▁; ▁unsigned ▁int ▁ch ▁; ▁int ▁sync _ word ▁, ▁tmp ▁; ▁uint 8_ t ▁checksum ▁; ▁uint 8_ t ▁loss less _ check ▁; ▁int ▁start _ count ▁= ▁get _ bits _ count ▁( ▁gb p ▁) ▁; ▁const ▁int ▁max _ matrix _ channel ▁= ▁m ▁-> ▁avctx ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ ML P ▁? ▁MAX _ MATRIX _ CHANNEL _ ML P ▁: ▁MAX _ MATRIX _ CHANNEL _ TRUE HD ▁; ▁sync _ word ▁= ▁get _ bits ▁( ▁gb p ▁, ▁13 ▁) ▁; ▁if ▁( ▁sync _ word ▁!= ▁0 x 31 ea ▁>> ▁1 ▁) ▁{ ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" restart headers ync inc orrect ( got 0 x %04 x )\ n " ▁, ▁sync _ word ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁noise _ type ▁= ▁get _ bits 1 ▁( ▁gb p ▁) ▁; ▁if ▁( ▁m ▁-> ▁avctx ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ ML P ▁&& ▁s ▁-> ▁noise _ type ▁) ▁{ ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" ML P must have 0 x 31 eas ync word .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁skip _ bits ▁( ▁gb p ▁, ▁16 ▁) ▁; ▁s ▁-> ▁min _ channel ▁= ▁get _ bits ▁( ▁gb p ▁, ▁4 ▁) ▁; ▁s ▁-> ▁max _ channel ▁= ▁get _ bits ▁( ▁gb p ▁, ▁4 ▁) ▁; ▁s ▁-> ▁max _ matrix _ channel ▁= ▁get _ bits ▁( ▁gb p ▁, ▁4 ▁) ▁; ▁if ▁( ▁s ▁-> ▁max _ matrix _ channel ▁> ▁max _ matrix _ channel ▁) ▁{ ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Max matrix channel cannot be greater than % d .\ n " ▁, ▁max _ matrix _ channel ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁s ▁-> ▁max _ channel ▁!= ▁s ▁-> ▁max _ matrix _ channel ▁) ▁{ ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Max channel must bee qual max matrix channel .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁s ▁-> ▁max _ channel ▁> ▁MAX _ MATRIX _ CHANNEL _ ML P ▁&& ▁! ▁s ▁-> ▁noise _ type ▁) ▁{ ▁av _ log _ ask _ for _ sample ▁( ▁m ▁-> ▁avctx ▁, ▁" Number of channels % dis l arger th ant hema x imum supported " ▁" by the decoder .\ n " ▁, ▁s ▁-> ▁max _ channel ▁+ ▁2 ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁if ▁( ▁s ▁-> ▁min _ channel ▁> ▁s ▁-> ▁max _ channel ▁) ▁{ ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Sub stream min channel cannot be greater than max channel .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁m ▁-> ▁avctx ▁-> ▁request _ channels ▁> ▁0 ▁&& ▁s ▁-> ▁max _ channel ▁+ ▁1 ▁>= ▁m ▁-> ▁avctx ▁-> ▁request _ channels ▁&& ▁substr ▁< ▁m ▁-> ▁max _ decoded _ substream ▁) ▁{ ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Extract ing % d channel down mix from substream % d ." ▁" F ur thers ub stream sw ill b es k ipped .\ n " ▁, ▁s ▁-> ▁max _ channel ▁+ ▁1 ▁, ▁substr ▁) ▁; ▁m ▁-> ▁max _ decoded _ substream ▁= ▁substr ▁; ▁} ▁s ▁-> ▁noise _ shift ▁= ▁get _ bits ▁( ▁gb p ▁, ▁4 ▁) ▁; ▁s ▁-> ▁noise gen _ seed ▁= ▁get _ bits ▁( ▁gb p ▁, ▁23 ▁) ▁; ▁skip _ bits ▁( ▁gb p ▁, ▁19 ▁) ▁; ▁s ▁-> ▁data _ check _ present ▁= ▁get _ bits 1 ▁( ▁gb p ▁) ▁; ▁loss less _ check ▁= ▁get _ bits ▁( ▁gb p ▁, ▁8 ▁) ▁; ▁if ▁( ▁substr ▁== ▁m ▁-> ▁max _ decoded _ substream ▁&& ▁s ▁-> ▁loss less _ check _ data ▁!= ▁0 xffffffff ▁) ▁{ ▁tmp ▁= ▁xor _32_ to _8 ▁( ▁s ▁-> ▁loss less _ check _ data ▁) ▁; ▁if ▁( ▁tmp ▁!= ▁loss less _ check ▁) ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Loss less check failed - expected %02 x , calc ulated %02 x .\ n " ▁, ▁loss less _ check ▁, ▁tmp ▁) ▁; ▁} ▁skip _ bits ▁( ▁gb p ▁, ▁16 ▁) ▁; ▁memset ▁( ▁s ▁-> ▁ch _ assign ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁ch _ assign ▁) ▁) ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁<= ▁s ▁-> ▁max _ matrix _ channel ▁; ▁ch ▁++ ▁) ▁{ ▁int ▁ch _ assign ▁= ▁get _ bits ▁( ▁gb p ▁, ▁6 ▁) ▁; ▁if ▁( ▁ch _ assign ▁> ▁s ▁-> ▁max _ matrix _ channel ▁) ▁{ ▁av _ log _ ask _ for _ sample ▁( ▁m ▁-> ▁avctx ▁, ▁" Assignment of matrix channel % d to invalid output channel % d .\ n " ▁, ▁ch ▁, ▁ch _ assign ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁s ▁-> ▁ch _ assign ▁[ ▁ch _ assign ▁] ▁= ▁ch ▁; ▁} ▁if ▁( ▁m ▁-> ▁avctx ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ ML P ▁&& ▁m ▁-> ▁needs _ re ordering ▁) ▁{ ▁if ▁( ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁( ▁AV _ CH _ LAYOUT _ QUAD ▁| ▁AV _ CH _ LOW _ FREQUENCY ▁) ▁|| ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁AV _ CH _ LAYOUT _5 POINT 0_ BACK ▁) ▁{ ▁int ▁i ▁= ▁s ▁-> ▁ch _ assign ▁[ ▁4 ▁] ▁; ▁s ▁-> ▁ch _ assign ▁[ ▁4 ▁] ▁= ▁s ▁-> ▁ch _ assign ▁[ ▁3 ▁] ▁; ▁s ▁-> ▁ch _ assign ▁[ ▁3 ▁] ▁= ▁s ▁-> ▁ch _ assign ▁[ ▁2 ▁] ▁; ▁s ▁-> ▁ch _ assign ▁[ ▁2 ▁] ▁= ▁i ▁; ▁} ▁else ▁if ▁( ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁AV _ CH _ LAYOUT _5 POINT 1_ BACK ▁) ▁{ ▁F FS W AP ▁( ▁int ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁2 ▁] ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁4 ▁] ▁) ▁; ▁F FS W AP ▁( ▁int ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁3 ▁] ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁5 ▁] ▁) ▁; ▁} ▁} ▁if ▁( ▁m ▁-> ▁avctx ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ TRUE HD ▁&& ▁( ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁AV _ CH _ LAYOUT _7 POINT 1 ▁|| ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁AV _ CH _ LAYOUT _7 POINT 1_ WIDE ▁) ▁) ▁{ ▁F FS W AP ▁( ▁int ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁4 ▁] ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁6 ▁] ▁) ▁; ▁F FS W AP ▁( ▁int ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁5 ▁] ▁, ▁s ▁-> ▁ch _ assign ▁[ ▁7 ▁] ▁) ▁; ▁} ▁else ▁if ▁( ▁m ▁-> ▁avctx ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ TRUE HD ▁&& ▁( ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁AV _ CH _ LAYOUT _6 POINT 1 ▁|| ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁( ▁AV _ CH _ LAYOUT _6 POINT 1 ▁| ▁AV _ CH _ TOP _ CENTER ▁) ▁|| ▁m ▁-> ▁avctx ▁-> ▁channel _ layout ▁== ▁( ▁AV _ CH _ LAYOUT _6 POINT 1 ▁| ▁AV _ CH _ TOP _ FRONT _ CENTER ▁) ▁) ▁) ▁{ ▁int ▁i ▁= ▁s ▁-> ▁ch _ assign ▁[ ▁6 ▁] ▁; ▁s ▁-> ▁ch _ assign ▁[ ▁6 ▁] ▁= ▁s ▁-> ▁ch _ assign ▁[ ▁5 ▁] ▁; ▁s ▁-> ▁ch _ assign ▁[ ▁5 ▁] ▁= ▁s ▁-> ▁ch _ assign ▁[ ▁4 ▁] ▁; ▁s ▁-> ▁ch _ assign ▁[ ▁4 ▁] ▁= ▁i ▁; ▁} ▁checksum ▁= ▁ff _ ml p _ restart _ checksum ▁( ▁buf ▁, ▁get _ bits _ count ▁( ▁gb p ▁) ▁- ▁start _ count ▁) ▁; ▁if ▁( ▁checksum ▁!= ▁get _ bits ▁( ▁gb p ▁, ▁8 ▁) ▁) ▁av _ log ▁( ▁m ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" restart header checksum error \ n " ▁) ▁; ▁s ▁-> ▁param _ p resence _ flags ▁= ▁0 xff ▁; ▁s ▁-> ▁num _ primitive _ mat rices ▁= ▁0 ▁; ▁s ▁-> ▁blocksize ▁= ▁8 ▁; ▁s ▁-> ▁loss less _ check _ data ▁= ▁0 ▁; ▁memset ▁( ▁s ▁-> ▁output _ shift ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁output _ shift ▁) ▁) ▁; ▁memset ▁( ▁s ▁-> ▁quant _ step _ size ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁quant _ step _ size ▁) ▁) ▁; ▁for ▁( ▁ch ▁= ▁s ▁-> ▁min _ channel ▁; ▁ch ▁<= ▁s ▁-> ▁max _ channel ▁; ▁ch ▁++ ▁) ▁{ ▁Channel Params ▁* ▁cp ▁= ▁& ▁s ▁-> ▁channel _ params ▁[ ▁ch ▁] ▁; ▁cp ▁-> ▁filter _ params ▁[ ▁FIR ▁] ▁. ▁order ▁= ▁0 ▁; ▁cp ▁-> ▁filter _ params ▁[ ▁I IR ▁] ▁. ▁order ▁= ▁0 ▁; ▁cp ▁-> ▁filter _ params ▁[ ▁FIR ▁] ▁. ▁shift ▁= ▁0 ▁; ▁cp ▁-> ▁filter _ params ▁[ ▁I IR ▁] ▁. ▁shift ▁= ▁0 ▁; ▁cp ▁-> ▁h uff _ offset ▁= ▁0 ▁; ▁cp ▁-> ▁sign _ h uff _ offset ▁= ▁( ▁-1 ▁) ▁<< ▁23 ▁; ▁cp ▁-> ▁code book ▁= ▁0 ▁; ▁cp ▁-> ▁h uff _ ls bs ▁= ▁24 ▁; ▁} ▁if ▁( ▁substr ▁== ▁m ▁-> ▁max _ decoded _ substream ▁) ▁m ▁-> ▁avctx ▁-> ▁channels ▁= ▁s ▁-> ▁max _ matrix _ channel ▁+ ▁1 ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁quant ize _ and _ encode _ band ▁( ▁struct ▁AAC Enc Context ▁* ▁s ▁, ▁Put Bit Context ▁* ▁pb ▁, ▁const ▁float ▁* ▁in ▁, ▁int ▁size ▁, ▁int ▁scale _ idx ▁, ▁int ▁cb ▁, ▁const ▁float ▁lambda ▁) ▁{ ▁const ▁float ▁I Q ▁= ▁ff _ aac _ pow 2 sf _ tab ▁[ ▁200 ▁+ ▁scale _ idx ▁- ▁SCALE _ ONE _ POS ▁+ ▁SCALE _ DIV _512 ▁] ▁; ▁const ▁float ▁Q ▁= ▁ff _ aac _ pow 2 sf _ tab ▁[ ▁200 ▁- ▁scale _ idx ▁+ ▁SCALE _ ONE _ POS ▁- ▁SCALE _ DIV _512 ▁] ▁; ▁const ▁float ▁CLIP PED _ ESCAPE ▁= ▁165 140 .0 f ▁* ▁I Q ▁; ▁const ▁int ▁dim ▁= ▁( ▁cb ▁< ▁FIRST _ PAIR _ BT ▁) ▁? ▁4 ▁: ▁2 ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁; ▁# ifndef ▁USE _ RE ALLY _ FULL _ SEARCH ▁const ▁float ▁Q 34 ▁= ▁sqrtf ▁( ▁Q ▁* ▁sqrtf ▁( ▁Q ▁) ▁) ▁; ▁const ▁int ▁range ▁= ▁aac _ cb _ range ▁[ ▁cb ▁] ▁; ▁const ▁int ▁maxval ▁= ▁aac _ cb _ max val ▁[ ▁cb ▁] ▁; ▁int ▁offs ▁[ ▁4 ▁] ▁; ▁float ▁* ▁scaled ▁= ▁s ▁-> ▁sco efs ▁; ▁# endif ▁if ▁( ▁! ▁cb ▁) ▁return ▁; ▁# ifndef ▁USE _ RE ALLY _ FULL _ SEARCH ▁offs ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁dim ▁; ▁i ▁++ ▁) ▁offs ▁[ ▁i ▁] ▁= ▁offs ▁[ ▁i ▁- ▁1 ▁] ▁* ▁range ▁; ▁abs _ pow 34_ v ▁( ▁scaled ▁, ▁in ▁, ▁size ▁) ▁; ▁quant ize _ band s ▁( ▁s ▁-> ▁q co efs ▁, ▁in ▁, ▁scaled ▁, ▁size ▁, ▁Q 34 ▁, ▁! ▁IS _ CODE BOOK _ UNSIGNED ▁( ▁cb ▁) ▁, ▁maxval ▁) ▁; ▁# endif ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁+= ▁dim ▁) ▁{ ▁float ▁min cost ▁; ▁int ▁min idx ▁= ▁0 ▁; ▁int ▁min bits ▁= ▁0 ▁; ▁const ▁float ▁* ▁vec ▁; ▁# ifndef ▁USE _ RE ALLY _ FULL _ SEARCH ▁int ▁( ▁* ▁qu ants ▁) ▁[ ▁2 ▁] ▁= ▁& ▁s ▁-> ▁q co efs ▁[ ▁i ▁] ▁; ▁min cost ▁= ▁0.0 f ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁min cost ▁+= ▁in ▁[ ▁i ▁+ ▁j ▁] ▁* ▁in ▁[ ▁i ▁+ ▁j ▁] ▁; ▁min idx ▁= ▁IS _ CODE BOOK _ UNSIGNED ▁( ▁cb ▁) ▁? ▁0 ▁: ▁40 ▁; ▁min bits ▁= ▁ff _ aac _ s pectral _ bits ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁min idx ▁] ▁; ▁min cost ▁= ▁min cost ▁* ▁lambda ▁+ ▁min bits ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁( ▁1 ▁<< ▁dim ▁) ▁; ▁j ▁++ ▁) ▁{ ▁float ▁rd ▁= ▁0.0 f ▁; ▁int ▁cur bits ▁; ▁int ▁cur idx ▁= ▁IS _ CODE BOOK _ UNSIGNED ▁( ▁cb ▁) ▁? ▁0 ▁: ▁40 ▁; ▁int ▁same ▁= ▁0 ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁dim ▁; ▁k ▁++ ▁) ▁{ ▁if ▁( ▁( ▁j ▁& ▁( ▁1 ▁<< ▁k ▁) ▁) ▁&& ▁qu ants ▁[ ▁k ▁] ▁[ ▁0 ▁] ▁== ▁qu ants ▁[ ▁k ▁] ▁[ ▁1 ▁] ▁) ▁{ ▁same ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁same ▁) ▁continue ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁dim ▁; ▁k ▁++ ▁) ▁cur idx ▁+= ▁qu ants ▁[ ▁k ▁] ▁[ ▁! ▁! ▁( ▁j ▁& ▁( ▁1 ▁<< ▁k ▁) ▁) ▁] ▁* ▁offs ▁[ ▁dim ▁- ▁1 ▁- ▁k ▁] ▁; ▁cur bits ▁= ▁ff _ aac _ s pectral _ bits ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁cur idx ▁] ▁; ▁vec ▁= ▁& ▁ff _ aac _ code book _ vectors ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁cur idx ▁* ▁dim ▁] ▁; ▁# else ▁vec = ff _ aac _ code book _ vectors [ cb -1 ]; ▁min cost ▁= ▁INFINITY ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁ff _ aac _ s pectral _ sizes ▁[ ▁cb ▁- ▁1 ▁] ▁; ▁j ▁++ ▁, ▁vec ▁+= ▁dim ▁) ▁{ ▁float ▁rd ▁= ▁0.0 f ▁; ▁int ▁cur bits ▁= ▁ff _ aac _ s pectral _ bits ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁j ▁] ▁; ▁int ▁cur idx ▁= ▁j ▁; ▁# endif ▁if ( IS _ CODE BOOK _ UNSIGNED ( cb )) { ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁dim ▁; ▁k ▁++ ▁) ▁{ ▁float ▁t ▁= ▁fabsf ▁( ▁in ▁[ ▁i ▁+ ▁k ▁] ▁) ▁; ▁float ▁di ▁; ▁if ▁( ▁vec ▁[ ▁k ▁] ▁== ▁64 .0 f ▁) ▁{ ▁if ▁( ▁t ▁< ▁39 .0 f ▁* ▁I Q ▁) ▁{ ▁rd ▁= ▁INFINITY ▁; ▁break ▁; ▁} ▁if ▁( ▁t ▁>= ▁CLIP PED _ ESCAPE ▁) ▁{ ▁di ▁= ▁t ▁- ▁CLIP PED _ ESCAPE ▁; ▁cur bits ▁+= ▁21 ▁; ▁} ▁else ▁{ ▁int ▁c ▁= ▁av _ clip ▁( ▁quant ▁( ▁t ▁, ▁Q ▁) ▁, ▁0 ▁, ▁819 1 ▁) ▁; ▁di ▁= ▁t ▁- ▁c ▁* ▁cb rt f ▁( ▁c ▁) ▁* ▁I Q ▁; ▁cur bits ▁+= ▁av _ log 2 ▁( ▁c ▁) ▁* ▁2 ▁- ▁4 ▁+ ▁1 ▁; ▁} ▁} ▁else ▁{ ▁di ▁= ▁t ▁- ▁vec ▁[ ▁k ▁] ▁* ▁I Q ▁; ▁} ▁if ▁( ▁vec ▁[ ▁k ▁] ▁!= ▁0.0 f ▁) ▁cur bits ▁++ ▁; ▁rd ▁+= ▁di ▁* ▁di ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁dim ▁; ▁k ▁++ ▁) ▁{ ▁float ▁di ▁= ▁in ▁[ ▁i ▁+ ▁k ▁] ▁- ▁vec ▁[ ▁k ▁] ▁* ▁I Q ▁; ▁rd ▁+= ▁di ▁* ▁di ▁; ▁} ▁} ▁rd ▁= ▁rd ▁* ▁lambda ▁+ ▁cur bits ▁; ▁if ▁( ▁rd ▁< ▁min cost ▁) ▁{ ▁min cost ▁= ▁rd ▁; ▁min idx ▁= ▁cur idx ▁; ▁min bits ▁= ▁cur bits ▁; ▁} ▁} ▁put _ bits ▁( ▁pb ▁, ▁ff _ aac _ s pectral _ bits ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁min idx ▁] ▁, ▁ff _ aac _ s pectral _ codes ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁min idx ▁] ▁) ▁; ▁if ▁( ▁IS _ CODE BOOK _ UNSIGNED ▁( ▁cb ▁) ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁dim ▁; ▁j ▁++ ▁) ▁if ▁( ▁ff _ aac _ code book _ vectors ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁min idx ▁* ▁dim ▁+ ▁j ▁] ▁!= ▁0.0 f ▁) ▁put _ bits ▁( ▁pb ▁, ▁1 ▁, ▁in ▁[ ▁i ▁+ ▁j ▁] ▁< ▁0.0 f ▁) ▁; ▁if ▁( ▁cb ▁== ▁ESC _ BT ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁ff _ aac _ code book _ vectors ▁[ ▁cb ▁- ▁1 ▁] ▁[ ▁min idx ▁* ▁2 ▁+ ▁j ▁] ▁== ▁64 .0 f ▁) ▁{ ▁int ▁coef ▁= ▁av _ clip ▁( ▁quant ▁( ▁fabsf ▁( ▁in ▁[ ▁i ▁+ ▁j ▁] ▁) ▁, ▁Q ▁) ▁, ▁0 ▁, ▁819 1 ▁) ▁; ▁int ▁len ▁= ▁av _ log 2 ▁( ▁coef ▁) ▁; ▁put _ bits ▁( ▁pb ▁, ▁len ▁- ▁4 ▁+ ▁1 ▁, ▁( ▁1 ▁<< ▁( ▁len ▁- ▁4 ▁+ ▁1 ▁) ▁) ▁- ▁2 ▁) ▁; ▁put _ bits ▁( ▁pb ▁, ▁len ▁, ▁coef ▁& ▁( ▁( ▁1 ▁<< ▁len ▁) ▁- ▁1 ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁}	1
▁void ▁ff _ set _ fixed _ vector ▁( ▁float ▁* ▁out ▁, ▁const ▁A MR Fixed ▁* ▁in ▁, ▁float ▁scale ▁, ▁int ▁size ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁in ▁-> ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁x ▁= ▁in ▁-> ▁x ▁[ ▁i ▁] ▁, ▁repeats ▁= ▁! ▁( ▁( ▁in ▁-> ▁no _ repeat _ mask ▁>> ▁i ▁) ▁& ▁1 ▁) ▁; ▁float ▁y ▁= ▁in ▁-> ▁y ▁[ ▁i ▁] ▁* ▁scale ▁; ▁if ▁( ▁in ▁-> ▁pitch _ lag ▁> ▁0 ▁) ▁do ▁{ ▁out ▁[ ▁x ▁] ▁+= ▁y ▁; ▁y ▁*= ▁in ▁-> ▁pitch _ fac ▁; ▁x ▁+= ▁in ▁-> ▁pitch _ lag ▁; ▁} ▁while ▁( ▁x ▁< ▁size ▁&& ▁repeats ▁) ▁; ▁} ▁}	0
▁static ▁int ▁mk v _ write _ tags ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁Mat ro sk a Mux Context ▁* ▁mk v ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁ret ▁; ▁ff _ metadata _ conv _ ctx ▁( ▁s ▁, ▁ff _ mk v _ metadata _ conv ▁, ▁NULL ▁) ▁; ▁if ▁( ▁mk v _ check _ tag ▁( ▁s ▁-> ▁metadata ▁, ▁0 ▁) ▁) ▁{ ▁ret ▁= ▁mk v _ write _ tag ▁( ▁s ▁, ▁s ▁-> ▁metadata ▁, ▁0 ▁, ▁0 ▁, ▁& ▁mk v ▁-> ▁tags ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ ATTACHMENT ▁) ▁continue ▁; ▁if ▁( ▁! ▁mk v _ check _ tag ▁( ▁st ▁-> ▁metadata ▁, ▁MAT RO SK A _ ID _ TAG TARGET S _ TRACK UID ▁) ▁) ▁continue ▁; ▁ret ▁= ▁mk v _ write _ tag ▁( ▁s ▁, ▁st ▁-> ▁metadata ▁, ▁MAT RO SK A _ ID _ TAG TARGET S _ TRACK UID ▁, ▁i ▁+ ▁1 ▁, ▁& ▁mk v ▁-> ▁tags ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁s ▁-> ▁pb ▁-> ▁seek able ▁&& ▁! ▁mk v ▁-> ▁is _ live ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVIO Context ▁* ▁pb ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁eb ml _ master ▁tag _ target ▁; ▁eb ml _ master ▁tag ▁; ▁if ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ ATTACHMENT ▁) ▁continue ▁; ▁mk v _ write _ tag _ targets ▁( ▁s ▁, ▁MAT RO SK A _ ID _ TAG TARGET S _ TRACK UID ▁, ▁i ▁+ ▁1 ▁, ▁& ▁mk v ▁-> ▁tags ▁, ▁& ▁tag _ target ▁) ▁; ▁pb ▁= ▁mk v ▁-> ▁tags _ bc ▁; ▁tag ▁= ▁start _ eb ml _ master ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ SIMPLE TAG ▁, ▁0 ▁) ▁; ▁put _ eb ml _ string ▁( ▁pb ▁, ▁MAT RO SK A _ ID _ TAG NAME ▁, ▁" DURATION " ▁) ▁; ▁mk v ▁-> ▁stream _ duration _ offsets ▁[ ▁i ▁] ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁put _ eb ml _ void ▁( ▁pb ▁, ▁23 ▁) ▁; ▁end _ eb ml _ master ▁( ▁pb ▁, ▁tag ▁) ▁; ▁end _ eb ml _ master ▁( ▁pb ▁, ▁tag _ target ▁) ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ ch apt ers ▁; ▁i ▁++ ▁) ▁{ ▁AV Ch apter ▁* ▁ch ▁= ▁s ▁-> ▁ch apt ers ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁mk v _ check _ tag ▁( ▁ch ▁-> ▁metadata ▁, ▁MAT RO SK A _ ID _ TAG TARGET S _ CH APTER UID ▁) ▁) ▁continue ▁; ▁ret ▁= ▁mk v _ write _ tag ▁( ▁s ▁, ▁ch ▁-> ▁metadata ▁, ▁MAT RO SK A _ ID _ TAG TARGET S _ CH APTER UID ▁, ▁ch ▁-> ▁id ▁+ ▁mk v ▁-> ▁chapter _ id _ offset ▁, ▁& ▁mk v ▁-> ▁tags ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁mk v ▁-> ▁have _ attach ments ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁mk v ▁-> ▁attachments ▁-> ▁num _ entries ▁; ▁i ▁++ ▁) ▁{ ▁mk v _ attachment ▁* ▁attachment ▁= ▁& ▁mk v ▁-> ▁attachments ▁-> ▁entries ▁[ ▁i ▁] ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁attachment ▁-> ▁stream _ idx ▁] ▁; ▁if ▁( ▁! ▁mk v _ check _ tag ▁( ▁st ▁-> ▁metadata ▁, ▁MAT RO SK A _ ID _ TAG TARGET S _ ATTACH UID ▁) ▁) ▁continue ▁; ▁ret ▁= ▁mk v _ write _ tag ▁( ▁s ▁, ▁st ▁-> ▁metadata ▁, ▁MAT RO SK A _ ID _ TAG TARGET S _ ATTACH UID ▁, ▁attachment ▁-> ▁file uid ▁, ▁& ▁mk v ▁-> ▁tags ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁} ▁if ▁( ▁mk v ▁-> ▁tags ▁. ▁pos ▁) ▁{ ▁if ▁( ▁s ▁-> ▁pb ▁-> ▁seek able ▁&& ▁! ▁mk v ▁-> ▁is _ live ▁) ▁put _ eb ml _ void ▁( ▁s ▁-> ▁pb ▁, ▁avio _ tell ▁( ▁mk v ▁-> ▁tags _ bc ▁) ▁) ▁; ▁else ▁end _ eb ml _ master _ crc 32 ▁( ▁s ▁-> ▁pb ▁, ▁& ▁mk v ▁-> ▁tags _ bc ▁, ▁mk v ▁, ▁mk v ▁-> ▁tags ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁inline ▁void ▁q tr le _ decode _2 n 4 bpp ▁( ▁Q tr le Context ▁* ▁s ▁, ▁int ▁stream _ ptr ▁, ▁int ▁row _ ptr ▁, ▁int ▁lines _ to _ change ▁, ▁int ▁bpp ▁) ▁{ ▁int ▁r le _ code ▁, ▁i ▁; ▁int ▁pixel _ ptr ▁; ▁int ▁row _ inc ▁= ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁; ▁unsigned ▁char ▁pi ▁[ ▁16 ▁] ▁; ▁unsigned ▁char ▁* ▁rgb ▁= ▁s ▁-> ▁frame ▁. ▁data ▁[ ▁0 ▁] ▁; ▁int ▁pixel _ limit ▁= ▁s ▁-> ▁frame ▁. ▁linesize ▁[ ▁0 ▁] ▁* ▁s ▁-> ▁avctx ▁-> ▁height ▁; ▁int ▁num _ pixels ▁= ▁( ▁bpp ▁== ▁4 ▁) ▁? ▁8 ▁: ▁16 ▁; ▁while ▁( ▁lines _ to _ change ▁-- ▁) ▁{ ▁CHECK _ STREAM _ PTR ▁( ▁2 ▁) ▁; ▁pixel _ ptr ▁= ▁row _ ptr ▁+ ▁( ▁num _ pixels ▁* ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁- ▁1 ▁) ▁) ▁; ▁while ▁( ▁( ▁r le _ code ▁= ▁( ▁signed ▁char ▁) ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁) ▁!= ▁-1 ▁) ▁{ ▁if ▁( ▁r le _ code ▁== ▁0 ▁) ▁{ ▁CHECK _ STREAM _ PTR ▁( ▁1 ▁) ▁; ▁pixel _ ptr ▁+= ▁( ▁num _ pixels ▁* ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁- ▁1 ▁) ▁) ▁; ▁CHECK _ PIXEL _ PTR ▁( ▁0 ▁) ▁; ▁} ▁else ▁if ▁( ▁r le _ code ▁< ▁0 ▁) ▁{ ▁r le _ code ▁= ▁- ▁r le _ code ▁; ▁CHECK _ STREAM _ PTR ▁( ▁4 ▁) ▁; ▁for ▁( ▁i ▁= ▁num _ pixels ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁pi ▁[ ▁num _ pixels ▁- ▁1 ▁- ▁i ▁] ▁= ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁] ▁>> ▁( ▁( ▁i ▁* ▁bpp ▁) ▁& ▁0 x 07 ▁) ▁) ▁& ▁( ▁( ▁1 ▁<< ▁bpp ▁) ▁- ▁1 ▁) ▁; ▁stream _ ptr ▁+= ▁( ▁( ▁i ▁& ▁( ▁( ▁num _ pixels ▁>> ▁2 ▁) ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁; ▁} ▁CHECK _ PIXEL _ PTR ▁( ▁r le _ code ▁* ▁num _ pixels ▁) ▁; ▁while ▁( ▁r le _ code ▁-- ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ pixels ▁; ▁i ▁++ ▁) ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁pi ▁[ ▁i ▁] ▁; ▁} ▁} ▁else ▁{ ▁r le _ code ▁*= ▁4 ▁; ▁CHECK _ STREAM _ PTR ▁( ▁r le _ code ▁) ▁; ▁CHECK _ PIXEL _ PTR ▁( ▁r le _ code ▁* ▁( ▁num _ pixels ▁>> ▁2 ▁) ▁) ▁; ▁while ▁( ▁r le _ code ▁-- ▁) ▁{ ▁if ▁( ▁bpp ▁== ▁4 ▁) ▁{ ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁( ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁] ▁) ▁>> ▁4 ▁) ▁& ▁0 x 0 f ▁; ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁) ▁& ▁0 x 0 f ▁; ▁} ▁else ▁{ ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁( ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁] ▁) ▁>> ▁6 ▁) ▁& ▁0 x 03 ▁; ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁( ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁] ▁) ▁>> ▁4 ▁) ▁& ▁0 x 03 ▁; ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁( ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁] ▁) ▁>> ▁2 ▁) ▁& ▁0 x 03 ▁; ▁rgb ▁[ ▁pixel _ ptr ▁++ ▁] ▁= ▁( ▁s ▁-> ▁buf ▁[ ▁stream _ ptr ▁++ ▁] ▁) ▁& ▁0 x 03 ▁; ▁} ▁} ▁} ▁} ▁row _ ptr ▁+= ▁row _ inc ▁; ▁} ▁}	1
▁static ▁void ▁arith 2_ normal ise ▁( ▁Ar ith Coder ▁* ▁c ▁) ▁{ ▁while ▁( ▁( ▁c ▁-> ▁high ▁>> ▁15 ▁) ▁- ▁( ▁c ▁-> ▁low ▁>> ▁15 ▁) ▁< ▁2 ▁) ▁{ ▁if ▁( ▁( ▁c ▁-> ▁low ▁ ^ ▁c ▁-> ▁high ▁) ▁& ▁0 x 10000 ▁) ▁{ ▁c ▁-> ▁high ▁ ^ = ▁0 x 8000 ▁; ▁c ▁-> ▁value ▁ ^ = ▁0 x 8000 ▁; ▁c ▁-> ▁low ▁ ^ = ▁0 x 8000 ▁; ▁} ▁c ▁-> ▁high ▁= ▁( ▁uint 16_ t ▁) ▁c ▁-> ▁high ▁<< ▁8 ▁| ▁0 xFF ▁; ▁c ▁-> ▁value ▁= ▁( ▁uint 16_ t ▁) ▁c ▁-> ▁value ▁<< ▁8 ▁| ▁bytestream 2_ get _ byte ▁( ▁c ▁-> ▁gbc ▁. ▁g B ▁) ▁; ▁c ▁-> ▁low ▁= ▁( ▁uint 16_ t ▁) ▁c ▁-> ▁low ▁<< ▁8 ▁; ▁} ▁}	0
▁int ▁tls _ construct _ finished ▁( ▁SSL ▁* ▁s ▁, ▁const ▁char ▁* ▁sender ▁, ▁int ▁slen ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁; ▁int ▁i ▁; ▁unsigned ▁long ▁l ▁; ▁p ▁= ▁ssl _ handshake _ start ▁( ▁s ▁) ▁; ▁i ▁= ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁final _ finish _ mac ▁( ▁s ▁, ▁sender ▁, ▁slen ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁finish _ md ▁) ▁; ▁if ▁( ▁i ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁finish _ md _ len ▁= ▁i ▁; ▁memcpy ▁( ▁p ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁finish _ md ▁, ▁i ▁) ▁; ▁l ▁= ▁i ▁; ▁if ▁( ▁s ▁-> ▁type ▁== ▁SSL _ ST _ CONNECT ▁) ▁{ ▁OPENSSL _ assert ▁( ▁i ▁<= ▁EVP _ MAX _ MD _ SIZE ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁s 3 ▁-> ▁previous _ client _ finished ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁finish _ md ▁, ▁i ▁) ▁; ▁s ▁-> ▁s 3 ▁-> ▁previous _ client _ finished _ len ▁= ▁i ▁; ▁} ▁else ▁{ ▁OPENSSL _ assert ▁( ▁i ▁<= ▁EVP _ MAX _ MD _ SIZE ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁s 3 ▁-> ▁previous _ server _ finished ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁finish _ md ▁, ▁i ▁) ▁; ▁s ▁-> ▁s 3 ▁-> ▁previous _ server _ finished _ len ▁= ▁i ▁; ▁} ▁if ▁( ▁! ▁ssl _ set _ handshake _ header ▁( ▁s ▁, ▁SSL 3_ MT _ FINISHED ▁, ▁l ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS _ CON STRUCT _ FINISHED ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	0
▁static ▁void ▁fmt int ▁( ▁void ▁( ▁* ▁out ch _ fn ▁) ▁( ▁char ▁* ▁* ▁, ▁size _ t ▁* ▁, ▁size _ t ▁* ▁, ▁int ▁) ▁, ▁char ▁* ▁* ▁buffer ▁, ▁size _ t ▁* ▁curr len ▁, ▁size _ t ▁* ▁maxlen ▁, ▁LLONG ▁value ▁, ▁int ▁base ▁, ▁int ▁min ▁, ▁int ▁max ▁, ▁int ▁flags ▁) ▁{ ▁int ▁sign value ▁= ▁0 ▁; ▁unsigned ▁LLONG ▁u value ▁; ▁char ▁convert ▁[ ▁20 ▁] ▁; ▁int ▁place ▁= ▁0 ▁; ▁int ▁sp ad len ▁= ▁0 ▁; ▁int ▁z pad len ▁= ▁0 ▁; ▁int ▁caps ▁= ▁0 ▁; ▁if ▁( ▁max ▁< ▁0 ▁) ▁max ▁= ▁0 ▁; ▁u value ▁= ▁value ▁; ▁if ▁( ▁! ▁( ▁flags ▁& ▁DP _ F _ UNSIGNED ▁) ▁) ▁{ ▁if ▁( ▁value ▁< ▁0 ▁) ▁{ ▁sign value ▁= ▁' ▁' ▁; ▁u value ▁= ▁- ▁value ▁; ▁} ▁else ▁if ▁( ▁flags ▁& ▁DP _ F _ PLUS ▁) ▁sign value ▁= ▁' ▁' ▁; ▁else ▁if ▁( ▁flags ▁& ▁DP _ F _ SPACE ▁) ▁sign value ▁= ▁' ▁' ▁; ▁} ▁if ▁( ▁flags ▁& ▁DP _ F _ UP ▁) ▁caps ▁= ▁1 ▁; ▁do ▁{ ▁convert ▁[ ▁place ▁++ ▁] ▁= ▁( ▁caps ▁? ▁"0123456789 ABCDEF " ▁: ▁"0123456789 abcdef " ▁) ▁[ ▁u value ▁% ▁( ▁unsigned ▁) ▁base ▁] ▁; ▁u value ▁= ▁( ▁u value ▁/ ▁( ▁unsigned ▁) ▁base ▁) ▁; ▁} ▁while ▁( ▁u value ▁&& ▁( ▁place ▁< ▁20 ▁) ▁) ▁; ▁if ▁( ▁place ▁== ▁20 ▁) ▁place ▁-- ▁; ▁convert ▁[ ▁place ▁] ▁= ▁0 ▁; ▁z pad len ▁= ▁max ▁- ▁place ▁; ▁sp ad len ▁= ▁min ▁- ▁MAX ▁( ▁max ▁, ▁place ▁) ▁- ▁( ▁sign value ▁? ▁1 ▁: ▁0 ▁) ▁; ▁if ▁( ▁z pad len ▁< ▁0 ▁) ▁z pad len ▁= ▁0 ▁; ▁if ▁( ▁sp ad len ▁< ▁0 ▁) ▁sp ad len ▁= ▁0 ▁; ▁if ▁( ▁flags ▁& ▁DP _ F _ ZERO ▁) ▁{ ▁z pad len ▁= ▁MAX ▁( ▁z pad len ▁, ▁sp ad len ▁) ▁; ▁sp ad len ▁= ▁0 ▁; ▁} ▁if ▁( ▁flags ▁& ▁DP _ F _ MINUS ▁) ▁sp ad len ▁= ▁- ▁sp ad len ▁; ▁while ▁( ▁sp ad len ▁> ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁sp ad len ▁; ▁} ▁if ▁( ▁sign value ▁) ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁sign value ▁) ▁; ▁if ▁( ▁z pad len ▁> ▁0 ▁) ▁{ ▁while ▁( ▁z pad len ▁> ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁z pad len ▁; ▁} ▁} ▁while ▁( ▁place ▁> ▁0 ▁) ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁convert ▁[ ▁-- ▁place ▁] ▁) ▁; ▁while ▁( ▁sp ad len ▁< ▁0 ▁) ▁{ ▁( ▁* ▁out ch _ fn ▁) ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁++ ▁sp ad len ▁; ▁} ▁return ▁; ▁}	0
▁static ▁int ▁g 2 m _ init _ buffers ▁( ▁G 2 M Context ▁* ▁c ▁) ▁{ ▁int ▁aligned _ height ▁; ▁if ▁( ▁! ▁c ▁-> ▁frame buf ▁|| ▁c ▁-> ▁old _ width ▁< ▁c ▁-> ▁width ▁|| ▁c ▁-> ▁old _ height ▁< ▁c ▁-> ▁height ▁) ▁{ ▁c ▁-> ▁frame buf _ stride ▁= ▁FF ALIGN ▁( ▁c ▁-> ▁width ▁* ▁3 ▁, ▁16 ▁) ▁; ▁aligned _ height ▁= ▁FF ALIGN ▁( ▁c ▁-> ▁height ▁, ▁16 ▁) ▁; ▁av _ free ▁( ▁c ▁-> ▁frame buf ▁) ▁; ▁c ▁-> ▁frame buf ▁= ▁av _ malloc z ▁( ▁c ▁-> ▁frame buf _ stride ▁* ▁aligned _ height ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁frame buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁if ▁( ▁! ▁c ▁-> ▁synth _ tile ▁|| ▁! ▁c ▁-> ▁jpeg _ tile ▁|| ▁c ▁-> ▁old _ tile _ w ▁< ▁c ▁-> ▁tile _ width ▁|| ▁c ▁-> ▁old _ tile _ h ▁< ▁c ▁-> ▁tile _ height ▁) ▁{ ▁c ▁-> ▁tile _ stride ▁= ▁FF ALIGN ▁( ▁c ▁-> ▁tile _ width ▁* ▁3 ▁, ▁16 ▁) ▁; ▁aligned _ height ▁= ▁FF ALIGN ▁( ▁c ▁-> ▁tile _ height ▁, ▁16 ▁) ▁; ▁av _ free ▁( ▁c ▁-> ▁synth _ tile ▁) ▁; ▁av _ free ▁( ▁c ▁-> ▁jpeg _ tile ▁) ▁; ▁av _ free ▁( ▁c ▁-> ▁k emp f _ buf ▁) ▁; ▁av _ free ▁( ▁c ▁-> ▁k emp f _ flags ▁) ▁; ▁c ▁-> ▁synth _ tile ▁= ▁av _ malloc z ▁( ▁c ▁-> ▁tile _ stride ▁* ▁aligned _ height ▁) ▁; ▁c ▁-> ▁jpeg _ tile ▁= ▁av _ malloc z ▁( ▁c ▁-> ▁tile _ stride ▁* ▁aligned _ height ▁) ▁; ▁c ▁-> ▁k emp f _ buf ▁= ▁av _ malloc z ▁( ▁( ▁c ▁-> ▁tile _ width ▁+ ▁1 ▁) ▁* ▁aligned _ height ▁+ ▁FF _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁c ▁-> ▁k emp f _ flags ▁= ▁av _ malloc z ▁( ▁c ▁-> ▁tile _ width ▁* ▁aligned _ height ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁synth _ tile ▁|| ▁! ▁c ▁-> ▁jpeg _ tile ▁|| ▁! ▁c ▁-> ▁k emp f _ buf ▁|| ▁! ▁c ▁-> ▁k emp f _ flags ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁decode _ inter frame _ v 4 a ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁uint 8_ t ▁* ▁src ▁, ▁uint 32_ t ▁size ▁) ▁{ ▁H nm 4 Video Context ▁* ▁h nm ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁Get Byte Context ▁gb ▁; ▁uint 32_ t ▁write offset ▁= ▁0 ▁, ▁offset ▁; ▁uint 8_ t ▁tag ▁, ▁count ▁, ▁previous ▁, ▁delta ▁; ▁bytestream 2_ init ▁( ▁& ▁gb ▁, ▁src ▁, ▁size ▁) ▁; ▁while ▁( ▁bytestream 2_ tell ▁( ▁& ▁gb ▁) ▁< ▁size ▁) ▁{ ▁count ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 3 F ▁; ▁if ▁( ▁count ▁== ▁0 ▁) ▁{ ▁tag ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 xC 0 ▁; ▁tag ▁= ▁tag ▁>> ▁6 ▁; ▁if ▁( ▁tag ▁== ▁0 ▁) ▁{ ▁write offset ▁+= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁; ▁} ▁else ▁if ▁( ▁tag ▁== ▁1 ▁) ▁{ ▁if ▁( ▁write offset ▁+ ▁h nm ▁-> ▁width ▁>= ▁h nm ▁-> ▁width ▁* ▁h nm ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" write offset out of bounds \ n " ▁) ▁; ▁break ▁; ▁} ▁h nm ▁-> ▁current ▁[ ▁write offset ▁] ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁+ ▁h nm ▁-> ▁width ▁] ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁gb ▁) ▁; ▁write offset ▁++ ▁; ▁} ▁else ▁if ▁( ▁tag ▁== ▁2 ▁) ▁{ ▁write offset ▁+= ▁h nm ▁-> ▁width ▁; ▁} ▁else ▁if ▁( ▁tag ▁== ▁3 ▁) ▁{ ▁break ▁; ▁} ▁if ▁( ▁write offset ▁> ▁h nm ▁-> ▁width ▁* ▁h nm ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" write offset out of bounds \ n " ▁) ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁delta ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 80 ▁; ▁previous ▁= ▁bytestream 2_ peek _ byte ▁( ▁& ▁gb ▁) ▁& ▁0 x 40 ▁; ▁bytestream 2_ skip ▁( ▁& ▁gb ▁, ▁1 ▁) ▁; ▁offset ▁= ▁write offset ▁; ▁offset ▁+= ▁bytestream 2_ get _ le 16 ▁( ▁& ▁gb ▁) ▁; ▁if ▁( ▁delta ▁) ▁offset ▁-= ▁0 x 10000 ▁; ▁if ▁( ▁offset ▁+ ▁h nm ▁-> ▁width ▁+ ▁count ▁>= ▁h nm ▁-> ▁width ▁* ▁h nm ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Attemp ting t oread out of bounds \ n " ▁) ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁write offset ▁+ ▁h nm ▁-> ▁width ▁+ ▁count ▁>= ▁h nm ▁-> ▁width ▁* ▁h nm ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Attemp ting tow rite out of bounds \ n " ▁) ▁; ▁break ▁; ▁} ▁if ▁( ▁previous ▁) ▁{ ▁while ▁( ▁count ▁> ▁0 ▁) ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁] ▁= ▁h nm ▁-> ▁previous ▁[ ▁offset ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁+ ▁h nm ▁-> ▁width ▁] ▁= ▁h nm ▁-> ▁previous ▁[ ▁offset ▁+ ▁h nm ▁-> ▁width ▁] ▁; ▁write offset ▁++ ▁; ▁offset ▁++ ▁; ▁count ▁-- ▁; ▁} ▁} ▁else ▁{ ▁while ▁( ▁count ▁> ▁0 ▁) ▁{ ▁h nm ▁-> ▁current ▁[ ▁write offset ▁] ▁= ▁h nm ▁-> ▁current ▁[ ▁offset ▁] ▁; ▁h nm ▁-> ▁current ▁[ ▁write offset ▁+ ▁h nm ▁-> ▁width ▁] ▁= ▁h nm ▁-> ▁current ▁[ ▁offset ▁+ ▁h nm ▁-> ▁width ▁] ▁; ▁write offset ▁++ ▁; ▁offset ▁++ ▁; ▁count ▁-- ▁; ▁} ▁} ▁} ▁} ▁}	1
▁static ▁int ▁def _ init _ WIN 32 ▁( ▁CONF ▁* ▁conf ▁) ▁{ ▁if ▁( ▁conf ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁conf ▁-> ▁meth ▁= ▁& ▁WIN 32_ method ▁; ▁conf ▁-> ▁meth _ data ▁= ▁( ▁void ▁* ▁) ▁CONF _ type _ win 32 ▁; ▁conf ▁-> ▁data ▁= ▁NULL ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁module _ run ▁( ▁const ▁CONF ▁* ▁cnf ▁, ▁const ▁char ▁* ▁name ▁, ▁const ▁char ▁* ▁value ▁, ▁unsigned ▁long ▁flags ▁) ▁{ ▁CONF _ MODULE ▁* ▁md ▁; ▁int ▁ret ▁; ▁md ▁= ▁module _ find ▁( ▁name ▁) ▁; ▁if ▁( ▁! ▁md ▁&& ▁! ▁( ▁flags ▁& ▁CONF _ M FLAGS _ NO _ D SO ▁) ▁) ▁md ▁= ▁module _ load _ dso ▁( ▁cnf ▁, ▁name ▁, ▁value ▁) ▁; ▁if ▁( ▁! ▁md ▁) ▁{ ▁if ▁( ▁! ▁( ▁flags ▁& ▁CONF _ M FLAGS _ SIL ENT ▁) ▁) ▁{ ▁CONF err ▁( ▁CONF _ F _ MODULE _ RUN ▁, ▁CONF _ R _ UNKNOWN _ MODULE _ NAME ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁2 ▁, ▁" module =" ▁, ▁name ▁) ▁; ▁} ▁return ▁-1 ▁; ▁} ▁ret ▁= ▁module _ init ▁( ▁md ▁, ▁name ▁, ▁value ▁, ▁cnf ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁) ▁{ ▁if ▁( ▁! ▁( ▁flags ▁& ▁CONF _ M FLAGS _ SIL ENT ▁) ▁) ▁{ ▁char ▁r code ▁[ ▁DECIMAL _ SIZE ▁( ▁ret ▁) ▁+ ▁1 ▁] ▁; ▁CONF err ▁( ▁CONF _ F _ MODULE _ RUN ▁, ▁CONF _ R _ MODULE _ INITIALIZ ATION _ ERROR ▁) ▁; ▁sprintf ▁( ▁r code ▁, ▁"% -8 d " ▁, ▁ret ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁6 ▁, ▁" module =" ▁, ▁name ▁, ▁", value =" ▁, ▁value ▁, ▁", ret code =" ▁, ▁r code ▁) ▁; ▁} ▁} ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁gather _ data _ for _ cel ▁( ▁C el Evaluation ▁* ▁cel ▁, ▁Ro q Context ▁* ▁enc ▁, ▁Ro q Temp data ▁* ▁temp Data ▁) ▁{ ▁uint 8_ t ▁mb 8 ▁[ ▁8 ▁* ▁8 ▁* ▁3 ▁] ▁; ▁int ▁index ▁= ▁cel ▁-> ▁source Y ▁* ▁enc ▁-> ▁width ▁/ ▁64 ▁+ ▁cel ▁-> ▁source X ▁/ ▁8 ▁; ▁int ▁i ▁, ▁j ▁, ▁best _ dist ▁, ▁divide _ bit _ use ▁; ▁int ▁bits Used ▁[ ▁4 ▁] ▁= ▁{ ▁2 ▁, ▁10 ▁, ▁10 ▁, ▁0 ▁} ▁; ▁if ▁( ▁enc ▁-> ▁frames Since Keyframe ▁>= ▁1 ▁) ▁{ ▁cel ▁-> ▁motion ▁= ▁enc ▁-> ▁this _ motion 8 ▁[ ▁index ▁] ▁; ▁cel ▁-> ▁eval _ dist ▁[ ▁Ro Q _ ID _ F CC ▁] ▁= ▁eval _ motion _ dist ▁( ▁enc ▁, ▁cel ▁-> ▁source X ▁, ▁cel ▁-> ▁source Y ▁, ▁enc ▁-> ▁this _ motion 8 ▁[ ▁index ▁] ▁, ▁8 ▁) ▁; ▁} ▁else ▁cel ▁-> ▁eval _ dist ▁[ ▁Ro Q _ ID _ F CC ▁] ▁= ▁INT _ MAX ▁; ▁if ▁( ▁enc ▁-> ▁frames Since Keyframe ▁>= ▁2 ▁) ▁cel ▁-> ▁eval _ dist ▁[ ▁Ro Q _ ID _ MO T ▁] ▁= ▁block _ sse ▁( ▁enc ▁-> ▁frame _ to _ enc ▁-> ▁data ▁, ▁enc ▁-> ▁current _ frame ▁-> ▁data ▁, ▁cel ▁-> ▁source X ▁, ▁cel ▁-> ▁source Y ▁, ▁cel ▁-> ▁source X ▁, ▁cel ▁-> ▁source Y ▁, ▁enc ▁-> ▁frame _ to _ enc ▁-> ▁linesize ▁, ▁enc ▁-> ▁current _ frame ▁-> ▁linesize ▁, ▁8 ▁) ▁; ▁else ▁cel ▁-> ▁eval _ dist ▁[ ▁Ro Q _ ID _ MO T ▁] ▁= ▁INT _ MAX ▁; ▁get _ frame _ mb ▁( ▁enc ▁-> ▁frame _ to _ enc ▁, ▁cel ▁-> ▁source X ▁, ▁cel ▁-> ▁source Y ▁, ▁mb 8 ▁, ▁8 ▁) ▁; ▁cel ▁-> ▁eval _ dist ▁[ ▁Ro Q _ ID _ SL D ▁] ▁= ▁index _ mb ▁( ▁mb 8 ▁, ▁temp Data ▁-> ▁code books ▁. ▁un packed _ cb 4_ en l arg ed ▁, ▁temp Data ▁-> ▁code books ▁. ▁num CB 4 ▁, ▁& ▁cel ▁-> ▁cb Entry ▁, ▁8 ▁) ▁; ▁gather _ data _ for _ sub cel ▁( ▁cel ▁-> ▁sub C els ▁+ ▁0 ▁, ▁cel ▁-> ▁source X ▁+ ▁0 ▁, ▁cel ▁-> ▁source Y ▁+ ▁0 ▁, ▁enc ▁, ▁temp Data ▁) ▁; ▁gather _ data _ for _ sub cel ▁( ▁cel ▁-> ▁sub C els ▁+ ▁1 ▁, ▁cel ▁-> ▁source X ▁+ ▁4 ▁, ▁cel ▁-> ▁source Y ▁+ ▁0 ▁, ▁enc ▁, ▁temp Data ▁) ▁; ▁gather _ data _ for _ sub cel ▁( ▁cel ▁-> ▁sub C els ▁+ ▁2 ▁, ▁cel ▁-> ▁source X ▁+ ▁0 ▁, ▁cel ▁-> ▁source Y ▁+ ▁4 ▁, ▁enc ▁, ▁temp Data ▁) ▁; ▁gather _ data _ for _ sub cel ▁( ▁cel ▁-> ▁sub C els ▁+ ▁3 ▁, ▁cel ▁-> ▁source X ▁+ ▁4 ▁, ▁cel ▁-> ▁source Y ▁+ ▁4 ▁, ▁enc ▁, ▁temp Data ▁) ▁; ▁cel ▁-> ▁eval _ dist ▁[ ▁Ro Q _ ID _ CCC ▁] ▁= ▁0 ▁; ▁divide _ bit _ use ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁cel ▁-> ▁eval _ dist ▁[ ▁Ro Q _ ID _ CCC ▁] ▁+= ▁cel ▁-> ▁sub C els ▁[ ▁i ▁] ▁. ▁eval _ dist ▁[ ▁cel ▁-> ▁sub C els ▁[ ▁i ▁] ▁. ▁best _ coding ▁] ▁; ▁divide _ bit _ use ▁+= ▁cel ▁-> ▁sub C els ▁[ ▁i ▁] ▁. ▁best _ bit _ use ▁; ▁} ▁best _ dist ▁= ▁INT _ MAX ▁; ▁bits Used ▁[ ▁3 ▁] ▁= ▁2 ▁+ ▁divide _ bit _ use ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁if ▁( ▁RO Q _ L AMBDA _ SCALE ▁* ▁cel ▁-> ▁eval _ dist ▁[ ▁i ▁] ▁+ ▁enc ▁-> ▁lambda ▁* ▁bits Used ▁[ ▁i ▁] ▁< ▁best _ dist ▁) ▁{ ▁cel ▁-> ▁best _ coding ▁= ▁i ▁; ▁best _ dist ▁= ▁RO Q _ L AMBDA _ SCALE ▁* ▁cel ▁-> ▁eval _ dist ▁[ ▁i ▁] ▁+ ▁enc ▁-> ▁lambda ▁* ▁bits Used ▁[ ▁i ▁] ▁; ▁} ▁temp Data ▁-> ▁used _ option ▁[ ▁cel ▁-> ▁best _ coding ▁] ▁++ ▁; ▁temp Data ▁-> ▁main Chunk Size ▁+= ▁bits Used ▁[ ▁cel ▁-> ▁best _ coding ▁] ▁; ▁if ▁( ▁cel ▁-> ▁best _ coding ▁== ▁Ro Q _ ID _ SL D ▁) ▁temp Data ▁-> ▁code books ▁. ▁used CB 4 ▁[ ▁cel ▁-> ▁cb Entry ▁] ▁++ ▁; ▁if ▁( ▁cel ▁-> ▁best _ coding ▁== ▁Ro Q _ ID _ CCC ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁cel ▁-> ▁sub C els ▁[ ▁i ▁] ▁. ▁best _ coding ▁== ▁Ro Q _ ID _ SL D ▁) ▁temp Data ▁-> ▁code books ▁. ▁used CB 4 ▁[ ▁cel ▁-> ▁sub C els ▁[ ▁i ▁] ▁. ▁cb Entry ▁] ▁++ ▁; ▁else ▁if ▁( ▁cel ▁-> ▁sub C els ▁[ ▁i ▁] ▁. ▁best _ coding ▁== ▁Ro Q _ ID _ CCC ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁temp Data ▁-> ▁code books ▁. ▁used CB 2 ▁[ ▁cel ▁-> ▁sub C els ▁[ ▁i ▁] ▁. ▁sub C els ▁[ ▁j ▁] ▁] ▁++ ▁; ▁} ▁}	1
▁int ▁ff _ h 264_ alloc _ tables ▁( ▁H 264 Context ▁* ▁h ▁) ▁{ ▁Mpeg Enc Context ▁* ▁const ▁s ▁= ▁& ▁h ▁-> ▁s ▁; ▁const ▁int ▁big _ mb _ num ▁= ▁s ▁-> ▁mb _ stride ▁* ▁( ▁s ▁-> ▁mb _ height ▁+ ▁1 ▁) ▁; ▁const ▁int ▁row _ mb _ num ▁= ▁2 ▁* ▁s ▁-> ▁mb _ stride ▁* ▁FF MAX ▁( ▁s ▁-> ▁avctx ▁-> ▁thread _ count ▁, ▁1 ▁) ▁; ▁int ▁x ▁, ▁y ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁in tra 4 x 4_ pred _ mode ▁, ▁row _ mb _ num ▁* ▁8 ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁non _ zero _ count ▁, ▁big _ mb _ num ▁* ▁48 ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁slice _ table _ base ▁, ▁( ▁big _ mb _ num ▁+ ▁s ▁-> ▁mb _ stride ▁) ▁* ▁sizeof ▁( ▁* ▁h ▁-> ▁slice _ table _ base ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁cb p _ table ▁, ▁big _ mb _ num ▁* ▁sizeof ▁( ▁uint 16_ t ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁chroma _ pred _ mode _ table ▁, ▁big _ mb _ num ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁, ▁fail ▁) ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁mv d _ table ▁[ ▁0 ▁] ▁, ▁16 ▁* ▁row _ mb _ num ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁, ▁fail ▁) ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁mv d _ table ▁[ ▁1 ▁] ▁, ▁16 ▁* ▁row _ mb _ num ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁, ▁fail ▁) ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁direct _ table ▁, ▁4 ▁* ▁big _ mb _ num ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁, ▁fail ▁) ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁list _ counts ▁, ▁big _ mb _ num ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁, ▁fail ▁) ▁memset ▁( ▁h ▁-> ▁slice _ table _ base ▁, ▁-1 ▁, ▁( ▁big _ mb _ num ▁+ ▁s ▁-> ▁mb _ stride ▁) ▁* ▁sizeof ▁( ▁* ▁h ▁-> ▁slice _ table _ base ▁) ▁) ▁; ▁h ▁-> ▁slice _ table ▁= ▁h ▁-> ▁slice _ table _ base ▁+ ▁s ▁-> ▁mb _ stride ▁* ▁2 ▁+ ▁1 ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁mb 2 b _ xy ▁, ▁big _ mb _ num ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁, ▁fail ▁) ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁h ▁-> ▁mb 2 br _ xy ▁, ▁big _ mb _ num ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁, ▁fail ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁s ▁-> ▁mb _ height ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁s ▁-> ▁mb _ width ▁; ▁x ▁++ ▁) ▁{ ▁const ▁int ▁mb _ xy ▁= ▁x ▁+ ▁y ▁* ▁s ▁-> ▁mb _ stride ▁; ▁const ▁int ▁b _ xy ▁= ▁4 ▁* ▁x ▁+ ▁4 ▁* ▁y ▁* ▁h ▁-> ▁b _ stride ▁; ▁h ▁-> ▁mb 2 b _ xy ▁[ ▁mb _ xy ▁] ▁= ▁b _ xy ▁; ▁h ▁-> ▁mb 2 br _ xy ▁[ ▁mb _ xy ▁] ▁= ▁8 ▁* ▁( ▁F MO ▁? ▁mb _ xy ▁: ▁( ▁mb _ xy ▁% ▁( ▁2 ▁* ▁s ▁-> ▁mb _ stride ▁) ▁) ▁) ▁; ▁} ▁} ▁s ▁-> ▁ob mc _ scratch pad ▁= ▁NULL ▁; ▁if ▁( ▁! ▁h ▁-> ▁de quant 4_ coeff ▁[ ▁0 ▁] ▁) ▁init _ de quant _ tables ▁( ▁h ▁) ▁; ▁return ▁0 ▁; ▁fail ▁: ▁free _ tables ▁( ▁h ▁, ▁1 ▁) ▁; ▁return ▁-1 ▁; ▁}	0
▁DECLARE read Func ▁( ▁read Cont ig Tiles Into Buffer ▁) ▁{ ▁int ▁status ▁= ▁1 ▁; ▁tsize _ t ▁tile size ▁= ▁TIFF Tile Size ▁( ▁in ▁) ▁; ▁t data _ t ▁tile buf ▁; ▁uint 32 ▁image w ▁= ▁TIFF Scan line Size ▁( ▁in ▁) ▁; ▁uint 32 ▁tile w ▁= ▁TIFF Tile Row Size ▁( ▁in ▁) ▁; ▁int 64 ▁is k ew ▁= ▁( ▁int 64 ▁) ▁image w ▁- ▁( ▁int 64 ▁) ▁tile w ▁; ▁uint 8 ▁* ▁bufp ▁= ▁( ▁uint 8 ▁* ▁) ▁buf ▁; ▁uint 32 ▁tw ▁, ▁tl ▁; ▁uint 32 ▁row ▁; ▁( ▁void ▁) ▁s pp ▁; ▁tile buf ▁= ▁_ TIFF malloc ▁( ▁tile size ▁) ▁; ▁if ▁( ▁tile buf ▁== ▁0 ▁) ▁return ▁0 ▁; ▁_ TIFF memset ▁( ▁tile buf ▁, ▁0 ▁, ▁tile size ▁) ▁; ▁( ▁void ▁) ▁TIFF Get Field ▁( ▁in ▁, ▁TIFF TAG _ TILE WIDTH ▁, ▁& ▁tw ▁) ▁; ▁( ▁void ▁) ▁TIFF Get Field ▁( ▁in ▁, ▁TIFF TAG _ TILE LENGTH ▁, ▁& ▁tl ▁) ▁; ▁for ▁( ▁row ▁= ▁0 ▁; ▁row ▁< ▁image length ▁; ▁row ▁+= ▁tl ▁) ▁{ ▁uint 32 ▁nrow ▁= ▁( ▁row ▁+ ▁tl ▁> ▁image length ▁) ▁? ▁image length ▁- ▁row ▁: ▁tl ▁; ▁uint 32 ▁col b ▁= ▁0 ▁; ▁uint 32 ▁col ▁; ▁for ▁( ▁col ▁= ▁0 ▁; ▁col ▁< ▁image width ▁&& ▁col b ▁< ▁image w ▁; ▁col ▁+= ▁tw ▁) ▁{ ▁if ▁( ▁TIFF Read Tile ▁( ▁in ▁, ▁tile buf ▁, ▁col ▁, ▁row ▁, ▁0 ▁, ▁0 ▁) ▁< ▁0 ▁&& ▁! ▁ignore ▁) ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , can ' t read tile at % lu % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁col ▁, ▁( ▁unsigned ▁long ▁) ▁row ▁) ▁; ▁status ▁= ▁0 ▁; ▁goto ▁done ▁; ▁} ▁if ▁( ▁col b ▁> ▁is k ew ▁) ▁{ ▁uint 32 ▁width ▁= ▁image w ▁- ▁col b ▁; ▁uint 32 ▁o skew ▁= ▁tile w ▁- ▁width ▁; ▁cp Strip To Tile ▁( ▁bufp ▁+ ▁col b ▁, ▁tile buf ▁, ▁nrow ▁, ▁width ▁, ▁o skew ▁+ ▁is k ew ▁, ▁o skew ▁) ▁; ▁} ▁else ▁cp Strip To Tile ▁( ▁bufp ▁+ ▁col b ▁, ▁tile buf ▁, ▁nrow ▁, ▁tile w ▁, ▁is k ew ▁, ▁0 ▁) ▁; ▁col b ▁+= ▁tile w ▁; ▁} ▁bufp ▁+= ▁image w ▁* ▁nrow ▁; ▁} ▁done ▁: ▁_ TIFF free ▁( ▁tile buf ▁) ▁; ▁return ▁status ▁; ▁}	1
▁static ▁void ▁FUNC ▁( ▁trans quant _ bypass 16 x 16 ▁) ▁( ▁uint 8_ t ▁* ▁_ dst ▁, ▁int 16_ t ▁* ▁coeffs ▁, ▁ptrdiff _ t ▁stride ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁pixel ▁* ▁dst ▁= ▁( ▁pixel ▁* ▁) ▁_ dst ▁; ▁stride ▁/= ▁sizeof ▁( ▁pixel ▁) ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁16 ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁16 ▁; ▁x ▁++ ▁) ▁{ ▁dst ▁[ ▁x ▁] ▁= ▁av _ clip _ pixel ▁( ▁dst ▁[ ▁x ▁] ▁+ ▁* ▁coeffs ▁) ▁; ▁coeffs ▁++ ▁; ▁} ▁dst ▁+= ▁stride ▁; ▁} ▁}	0
▁void ▁bn _ sqr _ recursive ▁( ▁BN _ ULONG ▁* ▁r ▁, ▁const ▁BN _ ULONG ▁* ▁a ▁, ▁int ▁n 2 ▁, ▁BN _ ULONG ▁* ▁t ▁) ▁{ ▁int ▁n ▁= ▁n 2 ▁/ ▁2 ▁; ▁int ▁zero ▁, ▁c 1 ▁; ▁BN _ ULONG ▁ln ▁, ▁lo ▁, ▁* ▁p ▁; ▁if ▁( ▁n 2 ▁== ▁4 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁bn _ sqr _ normal ▁( ▁r ▁, ▁a ▁, ▁4 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 4 ▁( ▁r ▁, ▁a ▁) ▁; ▁# endif ▁return ▁; ▁} ▁else ▁if ▁( ▁n 2 ▁== ▁8 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁bn _ sqr _ normal ▁( ▁r ▁, ▁a ▁, ▁8 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 8 ▁( ▁r ▁, ▁a ▁) ▁; ▁# endif ▁return ▁; ▁} ▁if ▁( ▁n 2 ▁< ▁BN _ SQR _ RECURSIVE _ SIZE _ NORMAL ▁) ▁{ ▁bn _ sqr _ normal ▁( ▁r ▁, ▁a ▁, ▁n 2 ▁, ▁t ▁) ▁; ▁return ▁; ▁} ▁c 1 ▁= ▁bn _ cmp _ words ▁( ▁a ▁, ▁& ▁( ▁a ▁[ ▁n ▁] ▁) ▁, ▁n ▁) ▁; ▁zero ▁= ▁0 ▁; ▁if ▁( ▁c 1 ▁> ▁0 ▁) ▁bn _ sub _ words ▁( ▁t ▁, ▁a ▁, ▁& ▁( ▁a ▁[ ▁n ▁] ▁) ▁, ▁n ▁) ▁; ▁else ▁if ▁( ▁c 1 ▁< ▁0 ▁) ▁bn _ sub _ words ▁( ▁t ▁, ▁& ▁( ▁a ▁[ ▁n ▁] ▁) ▁, ▁a ▁, ▁n ▁) ▁; ▁else ▁zero ▁= ▁1 ▁; ▁p ▁= ▁& ▁( ▁t ▁[ ▁n 2 ▁* ▁2 ▁] ▁) ▁; ▁if ▁( ▁! ▁zero ▁) ▁bn _ sqr _ recursive ▁( ▁& ▁( ▁t ▁[ ▁n 2 ▁] ▁) ▁, ▁t ▁, ▁n ▁, ▁p ▁) ▁; ▁else ▁memset ▁( ▁& ▁t ▁[ ▁n 2 ▁] ▁, ▁0 ▁, ▁sizeof ▁( ▁* ▁t ▁) ▁* ▁n 2 ▁) ▁; ▁bn _ sqr _ recursive ▁( ▁r ▁, ▁a ▁, ▁n ▁, ▁p ▁) ▁; ▁bn _ sqr _ recursive ▁( ▁& ▁( ▁r ▁[ ▁n 2 ▁] ▁) ▁, ▁& ▁( ▁a ▁[ ▁n ▁] ▁) ▁, ▁n ▁, ▁p ▁) ▁; ▁c 1 ▁= ▁( ▁int ▁) ▁( ▁bn _ add _ words ▁( ▁t ▁, ▁r ▁, ▁& ▁( ▁r ▁[ ▁n 2 ▁] ▁) ▁, ▁n 2 ▁) ▁) ▁; ▁c 1 ▁-= ▁( ▁int ▁) ▁( ▁bn _ sub _ words ▁( ▁& ▁( ▁t ▁[ ▁n 2 ▁] ▁) ▁, ▁t ▁, ▁& ▁( ▁t ▁[ ▁n 2 ▁] ▁) ▁, ▁n 2 ▁) ▁) ▁; ▁c 1 ▁+= ▁( ▁int ▁) ▁( ▁bn _ add _ words ▁( ▁& ▁( ▁r ▁[ ▁n ▁] ▁) ▁, ▁& ▁( ▁r ▁[ ▁n ▁] ▁) ▁, ▁& ▁( ▁t ▁[ ▁n 2 ▁] ▁) ▁, ▁n 2 ▁) ▁) ▁; ▁if ▁( ▁c 1 ▁) ▁{ ▁p ▁= ▁& ▁( ▁r ▁[ ▁n ▁+ ▁n 2 ▁] ▁) ▁; ▁lo ▁= ▁* ▁p ▁; ▁ln ▁= ▁( ▁lo ▁+ ▁c 1 ▁) ▁& ▁BN _ MASK 2 ▁; ▁* ▁p ▁= ▁ln ▁; ▁if ▁( ▁ln ▁< ▁( ▁BN _ ULONG ▁) ▁c 1 ▁) ▁{ ▁do ▁{ ▁p ▁++ ▁; ▁lo ▁= ▁* ▁p ▁; ▁ln ▁= ▁( ▁lo ▁+ ▁1 ▁) ▁& ▁BN _ MASK 2 ▁; ▁* ▁p ▁= ▁ln ▁; ▁} ▁while ▁( ▁ln ▁== ▁0 ▁) ▁; ▁} ▁} ▁}	1
▁static ▁inline ▁void ▁q pel _ motion ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁field _ based ▁, ▁int ▁bottom _ field ▁, ▁int ▁field _ select ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁q pel _ mc _ func ▁( ▁* ▁q pix _ op ▁) ▁[ ▁16 ▁] ▁, ▁int ▁motion _ x ▁, ▁int ▁motion _ y ▁, ▁int ▁h ▁) ▁{ ▁uint 8_ t ▁* ▁ptr _ y ▁, ▁* ▁ptr _ cb ▁, ▁* ▁ptr _ cr ▁; ▁int ▁d xy ▁, ▁uv d xy ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁, ▁uv src _ x ▁, ▁uv src _ y ▁, ▁v _ edge _ pos ▁, ▁linesize ▁, ▁uv lines ize ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁3 ▁) ▁<< ▁2 ▁) ▁| ▁( ▁motion _ x ▁& ▁3 ▁) ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁2 ▁) ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁( ▁16 ▁>> ▁field _ based ▁) ▁+ ▁( ▁motion _ y ▁>> ▁2 ▁) ▁; ▁v _ edge _ pos ▁= ▁s ▁-> ▁v _ edge _ pos ▁>> ▁field _ based ▁; ▁linesize ▁= ▁s ▁-> ▁linesize ▁<< ▁field _ based ▁; ▁uv lines ize ▁= ▁s ▁-> ▁uv lines ize ▁<< ▁field _ based ▁; ▁if ▁( ▁field _ based ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁>> ▁1 ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ Q PE L _ CH RO MA 2 ▁) ▁{ ▁static ▁const ▁int ▁rt ab ▁[ ▁8 ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁+ ▁rt ab ▁[ ▁motion _ x ▁& ▁7 ▁] ▁; ▁my ▁= ▁( ▁motion _ y ▁>> ▁1 ▁) ▁+ ▁rt ab ▁[ ▁motion _ y ▁& ▁7 ▁] ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ Q PE L _ CH RO MA ▁) ▁{ ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁my ▁= ▁( ▁motion _ y ▁>> ▁1 ▁) ▁| ▁( ▁motion _ y ▁& ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁/ ▁2 ▁; ▁} ▁mx ▁= ▁( ▁mx ▁>> ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁my ▁= ▁( ▁my ▁>> ▁1 ▁) ▁| ▁( ▁my ▁& ▁1 ▁) ▁; ▁uv d xy ▁= ▁( ▁mx ▁& ▁1 ▁) ▁| ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁; ▁mx ▁>>= ▁1 ▁; ▁my ▁>>= ▁1 ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁uv src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁( ▁8 ▁>> ▁field _ based ▁) ▁+ ▁my ▁; ▁ptr _ y ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁src _ y ▁* ▁linesize ▁+ ▁src _ x ▁; ▁ptr _ cb ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁ptr _ cr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁src _ x ▁> ▁FF MAX ▁( ▁s ▁-> ▁h _ edge _ pos ▁- ▁( ▁motion _ x ▁& ▁3 ▁) ▁- ▁16 ▁, ▁0 ▁) ▁|| ▁( ▁unsigned ▁) ▁src _ y ▁> ▁FF MAX ▁( ▁v _ edge _ pos ▁- ▁( ▁motion _ y ▁& ▁3 ▁) ▁- ▁h ▁, ▁0 ▁) ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr _ y ▁, ▁s ▁-> ▁linesize ▁, ▁17 ▁, ▁17 ▁+ ▁field _ based ▁, ▁src _ x ▁, ▁src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr _ y ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁uv buf ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁+ ▁18 ▁* ▁s ▁-> ▁linesize ▁; ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁, ▁ptr _ cb ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁+ ▁16 ▁, ▁ptr _ cr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr _ cb ▁= ▁uv buf ▁; ▁ptr _ cr ▁= ▁uv buf ▁+ ▁16 ▁; ▁} ▁} ▁if ▁( ▁! ▁field _ based ▁) ▁q pix _ op ▁[ ▁0 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁) ▁; ▁else ▁{ ▁if ▁( ▁bottom _ field ▁) ▁{ ▁dest _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁dest _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁dest _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁if ▁( ▁field _ select ▁) ▁{ ▁ptr _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁ptr _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁ptr _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁q pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁) ▁; ▁q pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁, ▁ptr _ y ▁+ ▁8 ▁, ▁linesize ▁) ▁; ▁} ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr _ cr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr _ cb ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁} ▁}	1
▁static ▁av _ always _ inline ▁void ▁yuv 2 rgb _ full _2_ c _ template ▁( ▁S ws Context ▁* ▁c ▁, ▁const ▁int 16_ t ▁* ▁buf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁ubuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁vbuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁a buf ▁[ ▁2 ▁] ▁, ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁dst W ▁, ▁int ▁y alpha ▁, ▁int ▁u val pha ▁, ▁int ▁y ▁, ▁enum ▁AV PixelFormat ▁target ▁, ▁int ▁has Alpha ▁) ▁{ ▁const ▁int 16_ t ▁* ▁buf 0 ▁= ▁buf ▁[ ▁0 ▁] ▁, ▁* ▁buf 1 ▁= ▁buf ▁[ ▁1 ▁] ▁, ▁* ▁ubuf 0 ▁= ▁ubuf ▁[ ▁0 ▁] ▁, ▁* ▁ubuf 1 ▁= ▁ubuf ▁[ ▁1 ▁] ▁, ▁* ▁vbuf 0 ▁= ▁vbuf ▁[ ▁0 ▁] ▁, ▁* ▁vbuf 1 ▁= ▁vbuf ▁[ ▁1 ▁] ▁, ▁* ▁a buf 0 ▁= ▁has Alpha ▁? ▁a buf ▁[ ▁0 ▁] ▁: ▁NULL ▁, ▁* ▁a buf 1 ▁= ▁has Alpha ▁? ▁a buf ▁[ ▁1 ▁] ▁: ▁NULL ▁; ▁int ▁y alpha 1 ▁= ▁4096 ▁- ▁y alpha ▁; ▁int ▁u val pha 1 ▁= ▁4096 ▁- ▁u val pha ▁; ▁int ▁i ▁; ▁int ▁step ▁= ▁( ▁target ▁== ▁AV _ PIX _ FMT _ RGB 24 ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ BGR 24 ▁) ▁? ▁3 ▁: ▁4 ▁; ▁int ▁err ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁A ▁= ▁0 ▁; ▁if ▁( ▁target ▁== ▁AV _ PIX _ FMT _ BGR 4_ BYTE ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ RGB 4_ BYTE ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ BGR 8 ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ RGB 8 ▁) ▁step ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁] ▁* ▁y alpha ▁) ▁>> ▁10 ▁; ▁int ▁U ▁= ▁( ▁ubuf 0 ▁[ ▁i ▁] ▁* ▁u val pha 1 ▁+ ▁ubuf 1 ▁[ ▁i ▁] ▁* ▁u val pha ▁- ▁( ▁128 ▁<< ▁19 ▁) ▁) ▁>> ▁10 ▁; ▁int ▁V ▁= ▁( ▁vbuf 0 ▁[ ▁i ▁] ▁* ▁u val pha 1 ▁+ ▁vbuf 1 ▁[ ▁i ▁] ▁* ▁u val pha ▁- ▁( ▁128 ▁<< ▁19 ▁) ▁) ▁>> ▁10 ▁; ▁if ▁( ▁has Alpha ▁) ▁{ ▁A ▁= ▁( ▁a buf 0 ▁[ ▁i ▁] ▁* ▁y alpha 1 ▁+ ▁a buf 1 ▁[ ▁i ▁] ▁* ▁y alpha ▁+ ▁( ▁1 ▁<< ▁18 ▁) ▁) ▁>> ▁19 ▁; ▁if ▁( ▁A ▁& ▁0 x 100 ▁) ▁A ▁= ▁av _ clip _ uint 8 ▁( ▁A ▁) ▁; ▁} ▁yuv 2 rgb _ write _ full ▁( ▁c ▁, ▁dest ▁, ▁i ▁, ▁Y ▁, ▁A ▁, ▁U ▁, ▁V ▁, ▁y ▁, ▁target ▁, ▁has Alpha ▁, ▁err ▁) ▁; ▁dest ▁+= ▁step ▁; ▁} ▁c ▁-> ▁d ither _ error ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁0 ▁] ▁; ▁c ▁-> ▁d ither _ error ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁1 ▁] ▁; ▁c ▁-> ▁d ither _ error ▁[ ▁2 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁2 ▁] ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁mpeg _ motion _ internal ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁field _ based ▁, ▁int ▁bottom _ field ▁, ▁int ▁field _ select ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁int ▁motion _ x ▁, ▁int ▁motion _ y ▁, ▁int ▁h ▁, ▁int ▁is _ mpeg 12 ▁, ▁int ▁mb _ y ▁) ▁{ ▁uint 8_ t ▁* ▁ptr _ y ▁, ▁* ▁ptr _ cb ▁, ▁* ▁ptr _ cr ▁; ▁int ▁d xy ▁, ▁uv d xy ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁, ▁uv src _ x ▁, ▁uv src _ y ▁, ▁v _ edge _ pos ▁, ▁uv lines ize ▁, ▁linesize ▁; ▁# if ▁0 ▁if ▁( ▁s ▁-> ▁qu arter _ sample ▁) ▁{ ▁motion _ x ▁>>= ▁1 ▁; ▁motion _ y ▁>>= ▁1 ▁; ▁} ▁# endif ▁v _ edge _ pos ▁= ▁s ▁-> ▁v _ edge _ pos ▁>> ▁field _ based ▁; ▁linesize ▁= ▁s ▁-> ▁current _ picture ▁. ▁linesize ▁[ ▁0 ▁] ▁<< ▁field _ based ▁; ▁uv lines ize ▁= ▁s ▁-> ▁current _ picture ▁. ▁linesize ▁[ ▁1 ▁] ▁<< ▁field _ based ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁1 ▁) ▁; ▁src _ y ▁= ▁( ▁mb _ y ▁<< ▁( ▁4 ▁- ▁field _ based ▁) ▁) ▁+ ▁( ▁motion _ y ▁>> ▁1 ▁) ▁; ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 263 ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ H PE L _ CH RO MA ▁) ▁&& ▁field _ based ▁) ▁{ ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁my ▁= ▁motion _ y ▁>> ▁1 ▁; ▁uv d xy ▁= ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁( ▁mx ▁>> ▁1 ▁) ▁; ▁uv src _ y ▁= ▁( ▁mb _ y ▁<< ▁( ▁3 ▁- ▁field _ based ▁) ▁) ▁+ ▁( ▁my ▁>> ▁1 ▁) ▁; ▁} ▁else ▁{ ▁uv d xy ▁= ▁d xy ▁| ▁( ▁motion _ y ▁& ▁2 ▁) ▁| ▁( ▁( ▁motion _ x ▁& ▁2 ▁) ▁>> ▁1 ▁) ▁; ▁uv src _ x ▁= ▁src _ x ▁>> ▁1 ▁; ▁uv src _ y ▁= ▁src _ y ▁>> ▁1 ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 26 1 ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁4 ▁; ▁my ▁= ▁motion _ y ▁/ ▁4 ▁; ▁uv d xy ▁= ▁0 ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁uv src _ y ▁= ▁mb _ y ▁* ▁8 ▁+ ▁my ▁; ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁chroma _ y _ shift ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁/ ▁2 ▁; ▁uv d xy ▁= ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁( ▁mx ▁>> ▁1 ▁) ▁; ▁uv src _ y ▁= ▁( ▁mb _ y ▁<< ▁( ▁3 ▁- ▁field _ based ▁) ▁) ▁+ ▁( ▁my ▁>> ▁1 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁chroma _ x _ shift ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁uv d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁( ▁mx ▁>> ▁1 ▁) ▁; ▁uv src _ y ▁= ▁src _ y ▁; ▁} ▁else ▁{ ▁uv d xy ▁= ▁d xy ▁; ▁uv src _ x ▁= ▁src _ x ▁; ▁uv src _ y ▁= ▁src _ y ▁; ▁} ▁} ▁} ▁ptr _ y ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁src _ y ▁* ▁linesize ▁+ ▁src _ x ▁; ▁ptr _ cb ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁ptr _ cr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁src _ x ▁> ▁s ▁-> ▁h _ edge _ pos ▁- ▁( ▁motion _ x ▁& ▁1 ▁) ▁- ▁16 ▁|| ▁( ▁unsigned ▁) ▁src _ y ▁> ▁v _ edge _ pos ▁- ▁( ▁motion _ y ▁& ▁1 ▁) ▁- ▁h ▁) ▁{ ▁if ▁( ▁is _ mpeg 12 ▁|| ▁s ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ MPEG 2 VIDEO ▁|| ▁s ▁-> ▁codec _ id ▁== ▁CODEC _ ID _ MPEG 1 VIDEO ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" MPEG motion vector out of boundary (% d % d )\ n " ▁, ▁src _ x ▁, ▁src _ y ▁) ▁; ▁return ▁; ▁} ▁s ▁-> ▁dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr _ y ▁, ▁s ▁-> ▁linesize ▁, ▁17 ▁, ▁17 ▁+ ▁field _ based ▁, ▁src _ x ▁, ▁src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr _ y ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁uv buf ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁+ ▁18 ▁* ▁s ▁-> ▁linesize ▁; ▁s ▁-> ▁dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁, ▁ptr _ cb ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁+ ▁16 ▁, ▁ptr _ cr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr _ cb ▁= ▁uv buf ▁; ▁ptr _ cr ▁= ▁uv buf ▁+ ▁16 ▁; ▁} ▁} ▁if ▁( ▁bottom _ field ▁) ▁{ ▁dest _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁dest _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁dest _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁if ▁( ▁field _ select ▁) ▁{ ▁ptr _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁ptr _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁ptr _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁pix _ op ▁[ ▁0 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁, ▁h ▁) ▁; ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁pix _ op ▁[ ▁s ▁-> ▁chroma _ x _ shift ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr _ cb ▁, ▁uv lines ize ▁, ▁h ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁pix _ op ▁[ ▁s ▁-> ▁chroma _ x _ shift ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr _ cr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁} ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁( ▁CONFIG _ H 26 1_ ENCODER ▁|| ▁CONFIG _ H 26 1_ DECODER ▁) ▁&& ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 26 1 ▁) ▁{ ▁ff _ h 26 1_ loop _ filter ▁( ▁s ▁) ▁; ▁} ▁}	1
▁char ▁* ▁sk _ delete ▁( ▁STACK ▁* ▁st ▁, ▁int ▁loc ▁) ▁{ ▁char ▁* ▁ret ▁; ▁int ▁i ▁, ▁j ▁; ▁if ▁( ▁! ▁st ▁|| ▁( ▁loc ▁< ▁0 ▁) ▁|| ▁( ▁loc ▁>= ▁st ▁-> ▁num ▁) ▁) ▁return ▁NULL ▁; ▁ret ▁= ▁st ▁-> ▁data ▁[ ▁loc ▁] ▁; ▁if ▁( ▁loc ▁!= ▁st ▁-> ▁num ▁- ▁1 ▁) ▁{ ▁j ▁= ▁st ▁-> ▁num ▁- ▁1 ▁; ▁for ▁( ▁i ▁= ▁loc ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁st ▁-> ▁data ▁[ ▁i ▁] ▁= ▁st ▁-> ▁data ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁} ▁st ▁-> ▁num ▁-- ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁void ▁asn 1_ template _ free ▁( ▁ASN 1_ VALUE ▁* ▁* ▁pval ▁, ▁const ▁ASN 1_ TEMPLATE ▁* ▁tt ▁) ▁{ ▁if ▁( ▁tt ▁-> ▁flags ▁& ▁ASN 1_ T FLG _ SK _ MASK ▁) ▁{ ▁STACK _ OF ▁( ▁ASN 1_ VALUE ▁) ▁* ▁sk ▁= ▁( ▁STACK _ OF ▁( ▁ASN 1_ VALUE ▁) ▁* ▁) ▁* ▁pval ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ ASN 1_ VALUE _ num ▁( ▁sk ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ASN 1_ VALUE ▁* ▁v tmp ▁= ▁sk _ ASN 1_ VALUE _ value ▁( ▁sk ▁, ▁i ▁) ▁; ▁ASN 1_ item _ ex _ free ▁( ▁& ▁v tmp ▁, ▁ASN 1_ ITEM _ ptr ▁( ▁tt ▁-> ▁item ▁) ▁) ▁; ▁} ▁sk _ ASN 1_ VALUE _ free ▁( ▁sk ▁) ▁; ▁* ▁pval ▁= ▁NULL ▁; ▁} ▁else ▁{ ▁ASN 1_ item _ ex _ free ▁( ▁pval ▁, ▁ASN 1_ ITEM _ ptr ▁( ▁tt ▁-> ▁item ▁) ▁) ▁; ▁} ▁}	1
▁static ▁int ▁replace _ int _ data _ in _ filename ▁( ▁char ▁* ▁* ▁s ▁, ▁const ▁char ▁* ▁filename ▁, ▁char ▁placeholder ▁, ▁int 64_ t ▁number ▁) ▁{ ▁const ▁char ▁* ▁p ▁; ▁char ▁* ▁new _ filename ▁; ▁char ▁c ▁; ▁int ▁nd ▁, ▁add char _ count ▁; ▁int ▁found _ count ▁= ▁0 ▁; ▁AV B Print ▁buf ▁; ▁av _ b print _ init ▁( ▁& ▁buf ▁, ▁0 ▁, ▁AV _ B PRINT _ SIZE _ UN LIMITED ▁) ▁; ▁p ▁= ▁filename ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁c ▁= ▁* ▁p ▁; ▁if ▁( ▁c ▁== ▁' ▁\0 ▁' ▁) ▁break ▁; ▁if ▁( ▁c ▁== ▁' ▁' ▁&& ▁* ▁( ▁p ▁+ ▁1 ▁) ▁== ▁' ▁' ▁) ▁add char _ count ▁= ▁2 ▁; ▁else ▁if ▁( ▁c ▁== ▁' ▁' ▁&& ▁( ▁av _ is digit ▁( ▁* ▁( ▁p ▁+ ▁1 ▁) ▁) ▁|| ▁* ▁( ▁p ▁+ ▁1 ▁) ▁== ▁placeholder ▁) ▁) ▁{ ▁nd ▁= ▁0 ▁; ▁add char _ count ▁= ▁1 ▁; ▁while ▁( ▁av _ is digit ▁( ▁* ▁( ▁p ▁+ ▁add char _ count ▁) ▁) ▁) ▁{ ▁nd ▁= ▁nd ▁* ▁10 ▁+ ▁* ▁( ▁p ▁+ ▁add char _ count ▁) ▁- ▁' ▁' ▁; ▁add char _ count ▁++ ▁; ▁} ▁if ▁( ▁* ▁( ▁p ▁+ ▁add char _ count ▁) ▁== ▁placeholder ▁) ▁{ ▁av _ b printf ▁( ▁& ▁buf ▁, ▁"% 0 *" ▁PRId 64 ▁, ▁( ▁number ▁< ▁0 ▁) ▁? ▁nd ▁: ▁nd ▁++ ▁, ▁number ▁) ▁; ▁p ▁+= ▁( ▁add char _ count ▁+ ▁1 ▁) ▁; ▁add char _ count ▁= ▁0 ▁; ▁found _ count ▁++ ▁; ▁} ▁} ▁else ▁add char _ count ▁= ▁1 ▁; ▁av _ b print _ append _ data ▁( ▁& ▁buf ▁, ▁p ▁, ▁add char _ count ▁) ▁; ▁p ▁+= ▁add char _ count ▁; ▁} ▁if ▁( ▁! ▁av _ b print _ is _ complete ▁( ▁& ▁buf ▁) ▁) ▁{ ▁av _ b print _ finalize ▁( ▁& ▁buf ▁, ▁NULL ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁av _ b print _ finalize ▁( ▁& ▁buf ▁, ▁& ▁new _ filename ▁) ▁< ▁0 ▁|| ▁! ▁new _ filename ▁) ▁return ▁-1 ▁; ▁* ▁s ▁= ▁new _ filename ▁; ▁return ▁found _ count ▁; ▁}	0
▁static ▁int ▁cg id _ handler ▁( ▁request _ rec ▁* ▁r ▁) ▁{ ▁conn _ rec ▁* ▁c ▁= ▁r ▁-> ▁connection ▁; ▁int ▁retval ▁, ▁n ph ▁, ▁db pos ▁; ▁char ▁* ▁argv 0 ▁, ▁* ▁d buf ▁; ▁apr _ bucket _ b rig ade ▁* ▁bb ▁; ▁apr _ bucket ▁* ▁b ▁; ▁cg id _ server _ conf ▁* ▁conf ▁; ▁int ▁is _ included ▁; ▁int ▁seen _ e os ▁, ▁child _ stopped _ reading ▁; ▁int ▁sd ▁; ▁char ▁* ▁* ▁env ▁; ▁apr _ file _ t ▁* ▁temp sock ▁, ▁* ▁script _ err ▁, ▁* ▁err pipe _ out ▁; ▁struct ▁cleanup _ script _ info ▁* ▁info ▁; ▁apr _ status _ t ▁rv ▁; ▁cg id _ dir conf ▁* ▁dc ▁; ▁apr _ interval _ time _ t ▁timeout ▁; ▁if ▁( ▁strcmp ▁( ▁r ▁-> ▁handler ▁, ▁CG I _ MAGIC _ TYPE ▁) ▁&& ▁strcmp ▁( ▁r ▁-> ▁handler ▁, ▁" cgi - script " ▁) ▁) ▁{ ▁return ▁DECL INED ▁; ▁} ▁conf ▁= ▁ap _ get _ module _ config ▁( ▁r ▁-> ▁server ▁-> ▁module _ config ▁, ▁& ▁cg id _ module ▁) ▁; ▁dc ▁= ▁ap _ get _ module _ config ▁( ▁r ▁-> ▁per _ dir _ config ▁, ▁& ▁cg id _ module ▁) ▁; ▁timeout ▁= ▁dc ▁-> ▁timeout ▁> ▁0 ▁? ▁dc ▁-> ▁timeout ▁: ▁r ▁-> ▁server ▁-> ▁timeout ▁; ▁is _ included ▁= ▁! ▁strcmp ▁( ▁r ▁-> ▁protocol ▁, ▁" INCLUDED " ▁) ▁; ▁if ▁( ▁( ▁argv 0 ▁= ▁strrchr ▁( ▁r ▁-> ▁filename ▁, ▁' ▁' ▁) ▁) ▁!= ▁NULL ▁) ▁{ ▁argv 0 ▁++ ▁; ▁} ▁else ▁{ ▁argv 0 ▁= ▁r ▁-> ▁filename ▁; ▁} ▁n ph ▁= ▁! ▁( ▁strncmp ▁( ▁argv 0 ▁, ▁" n ph -" ▁, ▁4 ▁) ▁) ▁; ▁argv 0 ▁= ▁r ▁-> ▁filename ▁; ▁if ▁( ▁! ▁( ▁ap _ allow _ options ▁( ▁r ▁) ▁& ▁OPT _ EXEC CG I ▁) ▁&& ▁! ▁is _ script ali ased ▁( ▁r ▁) ▁) ▁{ ▁return ▁log _ script error ▁( ▁r ▁, ▁conf ▁, ▁HTTP _ FOR BIDDEN ▁, ▁0 ▁, ▁AP LOG NO ▁( ▁0 12 62 ▁) ▁" Options Exec CG I is off int his directory " ▁) ▁; ▁} ▁if ▁( ▁n ph ▁&& ▁is _ included ▁) ▁{ ▁return ▁log _ script error ▁( ▁r ▁, ▁conf ▁, ▁HTTP _ FOR BIDDEN ▁, ▁0 ▁, ▁AP LOG NO ▁( ▁0 12 63 ▁) ▁" at tempt to include N PH CG I script " ▁) ▁; ▁} ▁# if ▁defined ▁( ▁OS 2 ▁) ▁|| ▁defined ▁( ▁WIN 32 ▁) ▁# error ▁mod _ c gid does not work on th isp latform . If y oute ach itto , look ▁# error ▁at mod _ cgi . c for required code int h isp ath . ▁# else ▁if ▁( ▁r ▁-> ▁f info ▁. ▁filetype ▁== ▁APR _ NO FILE ▁) ▁{ ▁return ▁log _ script error ▁( ▁r ▁, ▁conf ▁, ▁HTTP _ NOT _ FOUND ▁, ▁0 ▁, ▁AP LOG NO ▁( ▁0 12 64 ▁) ▁" script not found or unable to stat " ▁) ▁; ▁} ▁# endif ▁if ▁( ▁r ▁-> ▁f info ▁. ▁filetype ▁== ▁APR _ DIR ▁) ▁{ ▁return ▁log _ script error ▁( ▁r ▁, ▁conf ▁, ▁HTTP _ FOR BIDDEN ▁, ▁0 ▁, ▁AP LOG NO ▁( ▁0 12 65 ▁) ▁" at tempt to in voked irectory ass cript " ▁) ▁; ▁} ▁if ▁( ▁( ▁r ▁-> ▁used _ path _ info ▁== ▁AP _ REQ _ REJECT _ PATH _ INFO ▁) ▁&& ▁r ▁-> ▁path _ info ▁&& ▁* ▁r ▁-> ▁path _ info ▁) ▁{ ▁return ▁log _ script error ▁( ▁r ▁, ▁conf ▁, ▁HTTP _ NOT _ FOUND ▁, ▁0 ▁, ▁AP LOG NO ▁( ▁0 12 66 ▁) ▁" Accept Path In foo ff dis al lows user ' sp ath " ▁) ▁; ▁} ▁# ifdef ▁HAVE _ CG ID _ F DP ASS ING ▁rv ▁= ▁apr _ file _ pipe _ create ▁( ▁& ▁script _ err ▁, ▁& ▁err pipe _ out ▁, ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁rv ▁) ▁{ ▁return ▁log _ script error ▁( ▁r ▁, ▁conf ▁, ▁HTTP _ SERVICE _ UNAVAILABLE ▁, ▁rv ▁, ▁AP LOG NO ▁( ▁101 76 ▁) ▁" could not create pipe for stderr " ▁) ▁; ▁} ▁# else ▁script _ err ▁= ▁NULL ▁; ▁err pipe _ out ▁= ▁NULL ▁; ▁# endif ▁ap _ add _ common _ vars ▁( ▁r ▁) ▁; ▁ap _ add _ cgi _ vars ▁( ▁r ▁) ▁; ▁env ▁= ▁ap _ create _ environment ▁( ▁r ▁-> ▁pool ▁, ▁r ▁-> ▁sub process _ env ▁) ▁; ▁if ▁( ▁( ▁retval ▁= ▁connect _ to _ daemon ▁( ▁& ▁sd ▁, ▁r ▁, ▁conf ▁) ▁) ▁!= ▁OK ▁) ▁{ ▁return ▁retval ▁; ▁} ▁rv ▁= ▁send _ req ▁( ▁sd ▁, ▁err pipe _ out ▁, ▁r ▁, ▁argv 0 ▁, ▁env ▁, ▁CG I _ REQ ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 12 68 ▁) ▁" writ et oc gid aemon process " ▁) ▁; ▁} ▁if ▁( ▁err pipe _ out ▁) ▁apr _ file _ close ▁( ▁err pipe _ out ▁) ▁; ▁info ▁= ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁sizeof ▁( ▁struct ▁cleanup _ script _ info ▁) ▁) ▁; ▁info ▁-> ▁conf ▁= ▁conf ▁; ▁info ▁-> ▁r ▁= ▁r ▁; ▁rv ▁= ▁get _ cgi _ pid ▁( ▁r ▁, ▁conf ▁, ▁& ▁( ▁info ▁-> ▁pid ▁) ▁) ▁; ▁if ▁( ▁APR _ SUCCESS ▁== ▁rv ▁) ▁{ ▁apr _ pool _ cleanup _ register ▁( ▁r ▁-> ▁pool ▁, ▁info ▁, ▁cleanup _ script ▁, ▁apr _ pool _ cleanup _ null ▁) ▁; ▁} ▁else ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁rv ▁, ▁r ▁, ▁" error determin ing cgi PID " ▁) ▁; ▁} ▁apr _ os _ pipe _ put _ ex ▁( ▁& ▁temp sock ▁, ▁& ▁sd ▁, ▁1 ▁, ▁r ▁-> ▁pool ▁) ▁; ▁apr _ file _ pipe _ timeout _ set ▁( ▁temp sock ▁, ▁timeout ▁) ▁; ▁apr _ pool _ cleanup _ kill ▁( ▁r ▁-> ▁pool ▁, ▁( ▁void ▁* ▁) ▁( ▁( ▁long ▁) ▁sd ▁) ▁, ▁close _ unix _ socket ▁) ▁; ▁bb ▁= ▁apr _ b rig ade _ create ▁( ▁r ▁-> ▁pool ▁, ▁r ▁-> ▁connection ▁-> ▁bucket _ alloc ▁) ▁; ▁seen _ e os ▁= ▁0 ▁; ▁child _ stopped _ reading ▁= ▁0 ▁; ▁d buf ▁= ▁NULL ▁; ▁db pos ▁= ▁0 ▁; ▁if ▁( ▁conf ▁-> ▁log name ▁) ▁{ ▁d buf ▁= ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁conf ▁-> ▁buf bytes ▁+ ▁1 ▁) ▁; ▁} ▁do ▁{ ▁apr _ bucket ▁* ▁bucket ▁; ▁rv ▁= ▁ap _ get _ b rig ade ▁( ▁r ▁-> ▁input _ filters ▁, ▁bb ▁, ▁AP _ MODE _ READ BYTES ▁, ▁APR _ BLOCK _ READ ▁, ▁HUGE _ STRING _ LEN ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 12 70 ▁) ▁" Error reading request entity data " ▁) ▁; ▁return ▁ap _ map _ http _ request _ error ▁( ▁rv ▁, ▁HTTP _ BAD _ REQUEST ▁) ▁; ▁} ▁for ▁( ▁bucket ▁= ▁APR _ BR IG ADE _ FIRST ▁( ▁bb ▁) ▁; ▁bucket ▁!= ▁APR _ BR IG ADE _ SENT IN EL ▁( ▁bb ▁) ▁; ▁bucket ▁= ▁APR _ BUCKET _ NEXT ▁( ▁bucket ▁) ▁) ▁{ ▁const ▁char ▁* ▁data ▁; ▁apr _ size _ t ▁len ▁; ▁if ▁( ▁APR _ BUCKET _ IS _ E OS ▁( ▁bucket ▁) ▁) ▁{ ▁seen _ e os ▁= ▁1 ▁; ▁break ▁; ▁} ▁if ▁( ▁APR _ BUCKET _ IS _ FLUSH ▁( ▁bucket ▁) ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁child _ stopped _ reading ▁) ▁{ ▁continue ▁; ▁} ▁apr _ bucket _ read ▁( ▁bucket ▁, ▁& ▁data ▁, ▁& ▁len ▁, ▁APR _ BLOCK _ READ ▁) ▁; ▁if ▁( ▁conf ▁-> ▁log name ▁&& ▁db pos ▁< ▁conf ▁-> ▁buf bytes ▁) ▁{ ▁int ▁cur size ▁; ▁if ▁( ▁( ▁db pos ▁+ ▁len ▁) ▁> ▁conf ▁-> ▁buf bytes ▁) ▁{ ▁cur size ▁= ▁conf ▁-> ▁buf bytes ▁- ▁db pos ▁; ▁} ▁else ▁{ ▁cur size ▁= ▁len ▁; ▁} ▁memcpy ▁( ▁d buf ▁+ ▁db pos ▁, ▁data ▁, ▁cur size ▁) ▁; ▁db pos ▁+= ▁cur size ▁; ▁} ▁rv ▁= ▁apr _ file _ write _ full ▁( ▁temp sock ▁, ▁data ▁, ▁len ▁, ▁NULL ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁child _ stopped _ reading ▁= ▁1 ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ ERR ▁, ▁rv ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 265 1 ▁) ▁" Error writing request body tos cript % s " ▁, ▁r ▁-> ▁filename ▁) ▁; ▁} ▁} ▁apr _ b rig ade _ cleanup ▁( ▁bb ▁) ▁; ▁} ▁while ▁( ▁! ▁seen _ e os ▁) ▁; ▁if ▁( ▁conf ▁-> ▁log name ▁) ▁{ ▁d buf ▁[ ▁db pos ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁shutdown ▁( ▁sd ▁, ▁1 ▁) ▁; ▁bb ▁= ▁apr _ b rig ade _ create ▁( ▁r ▁-> ▁pool ▁, ▁c ▁-> ▁bucket _ alloc ▁) ▁; ▁# ifdef ▁HAVE _ CG ID _ F DP ASS ING ▁b ▁= ▁cg i _ bucket _ create ▁( ▁r ▁, ▁dc ▁-> ▁timeout ▁, ▁temp sock ▁, ▁script _ err ▁, ▁c ▁-> ▁bucket _ alloc ▁) ▁; ▁if ▁( ▁b ▁== ▁NULL ▁) ▁return ▁HTTP _ INTERNAL _ SERVER _ ERROR ▁; ▁# else ▁b ▁= ▁apr _ bucket _ pipe _ create ▁( ▁temp sock ▁, ▁c ▁-> ▁bucket _ alloc ▁) ▁; ▁# endif ▁APR _ BR IG ADE _ INSERT _ TAIL ▁( ▁bb ▁, ▁b ▁) ▁; ▁b ▁= ▁apr _ bucket _ e os _ create ▁( ▁c ▁-> ▁bucket _ alloc ▁) ▁; ▁APR _ BR IG ADE _ INSERT _ TAIL ▁( ▁bb ▁, ▁b ▁) ▁; ▁return ▁cg i _ handle _ response ▁( ▁r ▁, ▁n ph ▁, ▁bb ▁, ▁timeout ▁, ▁conf ▁, ▁d buf ▁, ▁script _ err ▁) ▁; ▁}	0
▁static ▁int ▁check _ c rl _ path ▁( ▁X 509_ STORE _ CTX ▁* ▁ctx ▁, ▁X 509 ▁* ▁x ▁) ▁{ ▁X 509_ STORE _ CTX ▁crl _ ctx ▁; ▁int ▁ret ▁; ▁if ▁( ▁ctx ▁-> ▁parent ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁X 509_ STORE _ CTX _ init ▁( ▁& ▁crl _ ctx ▁, ▁ctx ▁-> ▁ctx ▁, ▁x ▁, ▁ctx ▁-> ▁un trusted ▁) ▁) ▁return ▁-1 ▁; ▁crl _ ctx ▁. ▁crl s ▁= ▁ctx ▁-> ▁crl s ▁; ▁X 509_ STORE _ CTX _ set 0_ param ▁( ▁& ▁crl _ ctx ▁, ▁ctx ▁-> ▁param ▁) ▁; ▁crl _ ctx ▁. ▁parent ▁= ▁ctx ▁; ▁crl _ ctx ▁. ▁verify _ cb ▁= ▁ctx ▁-> ▁verify _ cb ▁; ▁ret ▁= ▁X 509_ verify _ cert ▁( ▁& ▁crl _ ctx ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁goto ▁err ▁; ▁ret ▁= ▁check _ c rl _ chain ▁( ▁ctx ▁, ▁ctx ▁-> ▁chain ▁, ▁crl _ ctx ▁. ▁chain ▁) ▁; ▁err ▁: ▁X 509_ STORE _ CTX _ cleanup ▁( ▁& ▁crl _ ctx ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁by _ file _ ctrl ▁( ▁X 509_ LOOKUP ▁* ▁ctx ▁, ▁int ▁cmd ▁, ▁const ▁char ▁* ▁argp ▁, ▁long ▁arg l ▁, ▁char ▁* ▁* ▁ret ▁) ▁{ ▁int ▁ok ▁= ▁0 ▁; ▁char ▁* ▁file ▁; ▁switch ▁( ▁cmd ▁) ▁{ ▁case ▁X 509_ L _ FILE _ LOAD ▁: ▁if ▁( ▁arg l ▁== ▁X 509_ FILE TYPE _ DEFAULT ▁) ▁{ ▁ok ▁= ▁X 509_ load _ cert _ c rl _ file ▁( ▁ctx ▁, ▁X 509_ get _ default _ cert _ file ▁( ▁) ▁, ▁X 509_ FILE TYPE _ PEM ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁{ ▁X 509 err ▁( ▁X 509_ F _ BY _ FILE _ CTRL ▁, ▁X 509_ R _ LOAD ING _ DEFAULT S ▁) ▁; ▁} ▁else ▁{ ▁file ▁= ▁( ▁char ▁* ▁) ▁Get env ▁( ▁X 509_ get _ default _ cert _ file _ env ▁( ▁) ▁) ▁; ▁ok ▁= ▁X 509_ load _ cert _ c rl _ file ▁( ▁ctx ▁, ▁file ▁, ▁X 509_ FILE TYPE _ PEM ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁arg l ▁== ▁X 509_ FILE TYPE _ PEM ▁) ▁ok ▁= ▁X 509_ load _ cert _ c rl _ file ▁( ▁ctx ▁, ▁argp ▁, ▁X 509_ FILE TYPE _ PEM ▁) ▁; ▁else ▁ok ▁= ▁X 509_ load _ cert _ file ▁( ▁ctx ▁, ▁argp ▁, ▁( ▁int ▁) ▁arg l ▁) ▁; ▁} ▁break ▁; ▁} ▁return ▁( ▁ok ▁) ▁; ▁}	0
▁static ▁int ▁s 302 m _ encode 2_ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁avpkt ▁, ▁const ▁AVFrame ▁* ▁frame ▁, ▁int ▁* ▁got _ packet _ ptr ▁) ▁{ ▁S 302 M Enc Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁int ▁buf _ size ▁= ▁AES 3_ HEADER _ LEN ▁+ ▁( ▁frame ▁-> ▁nb _ samples ▁* ▁avctx ▁-> ▁channels ▁* ▁( ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁+ ▁4 ▁) ▁) ▁/ ▁8 ▁; ▁int ▁ret ▁, ▁c ▁, ▁channels ▁; ▁uint 8_ t ▁* ▁o ▁; ▁Put Bit Context ▁pb ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ alloc _ packet 2 ▁( ▁avctx ▁, ▁avpkt ▁, ▁buf _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁o ▁= ▁avpkt ▁-> ▁data ▁; ▁init _ put _ bits ▁( ▁& ▁pb ▁, ▁o ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁16 ▁, ▁buf _ size ▁- ▁AES 3_ HEADER _ LEN ▁) ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁2 ▁, ▁( ▁avctx ▁-> ▁channels ▁- ▁2 ▁) ▁>> ▁1 ▁) ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁8 ▁, ▁0 ▁) ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁2 ▁, ▁( ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁- ▁16 ▁) ▁/ ▁4 ▁) ▁; ▁put _ bits ▁( ▁& ▁pb ▁, ▁4 ▁, ▁0 ▁) ▁; ▁flush _ put _ bits ▁( ▁& ▁pb ▁) ▁; ▁o ▁+= ▁AES 3_ HEADER _ LEN ▁; ▁if ▁( ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁== ▁24 ▁) ▁{ ▁const ▁uint 32_ t ▁* ▁samples ▁= ▁( ▁uint 32_ t ▁* ▁) ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁c ▁= ▁0 ▁; ▁c ▁< ▁frame ▁-> ▁nb _ samples ▁; ▁c ▁++ ▁) ▁{ ▁uint 8_ t ▁v uc f ▁= ▁s ▁-> ▁fram ing _ index ▁== ▁0 ▁? ▁0 x 10 ▁: ▁0 ▁; ▁for ▁( ▁channels ▁= ▁0 ▁; ▁channels ▁< ▁avctx ▁-> ▁channels ▁; ▁channels ▁+= ▁2 ▁) ▁{ ▁o ▁[ ▁0 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁0 ▁] ▁& ▁0 x 0000 FF 00 ▁) ▁>> ▁8 ▁] ▁; ▁o ▁[ ▁1 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁0 ▁] ▁& ▁0 x 00 FF 0000 ▁) ▁>> ▁16 ▁] ▁; ▁o ▁[ ▁2 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁0 ▁] ▁& ▁0 xFF 000000 ▁) ▁>> ▁24 ▁] ▁; ▁o ▁[ ▁3 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 x 00000 F 00 ▁) ▁>> ▁4 ▁] ▁| ▁v uc f ▁; ▁o ▁[ ▁4 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 x 000 FF 000 ▁) ▁>> ▁12 ▁] ▁; ▁o ▁[ ▁5 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 x 0 FF 00000 ▁) ▁>> ▁20 ▁] ▁; ▁o ▁[ ▁6 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 xF 0000000 ▁) ▁>> ▁28 ▁] ▁; ▁o ▁+= ▁7 ▁; ▁samples ▁+= ▁2 ▁; ▁} ▁s ▁-> ▁fram ing _ index ▁++ ▁; ▁if ▁( ▁s ▁-> ▁fram ing _ index ▁>= ▁192 ▁) ▁s ▁-> ▁fram ing _ index ▁= ▁0 ▁; ▁} ▁} ▁else ▁if ▁( ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁== ▁20 ▁) ▁{ ▁const ▁uint 32_ t ▁* ▁samples ▁= ▁( ▁uint 32_ t ▁* ▁) ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁c ▁= ▁0 ▁; ▁c ▁< ▁frame ▁-> ▁nb _ samples ▁; ▁c ▁++ ▁) ▁{ ▁uint 8_ t ▁v uc f ▁= ▁s ▁-> ▁fram ing _ index ▁== ▁0 ▁? ▁0 x 80 ▁: ▁0 ▁; ▁for ▁( ▁channels ▁= ▁0 ▁; ▁channels ▁< ▁avctx ▁-> ▁channels ▁; ▁channels ▁+= ▁2 ▁) ▁{ ▁o ▁[ ▁0 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁0 ▁] ▁& ▁0 x 000 FF 000 ▁) ▁>> ▁12 ▁] ▁; ▁o ▁[ ▁1 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁0 ▁] ▁& ▁0 x 0 FF 00000 ▁) ▁>> ▁20 ▁] ▁; ▁o ▁[ ▁2 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁( ▁samples ▁[ ▁0 ▁] ▁& ▁0 xF 0000000 ▁) ▁>> ▁28 ▁) ▁| ▁v uc f ▁] ▁; ▁o ▁[ ▁3 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 x 000 FF 000 ▁) ▁>> ▁12 ▁] ▁; ▁o ▁[ ▁4 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 x 0 FF 00000 ▁) ▁>> ▁20 ▁] ▁; ▁o ▁[ ▁5 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 xF 0000000 ▁) ▁>> ▁28 ▁] ▁; ▁o ▁+= ▁6 ▁; ▁samples ▁+= ▁2 ▁; ▁} ▁s ▁-> ▁fram ing _ index ▁++ ▁; ▁if ▁( ▁s ▁-> ▁fram ing _ index ▁>= ▁192 ▁) ▁s ▁-> ▁fram ing _ index ▁= ▁0 ▁; ▁} ▁} ▁else ▁if ▁( ▁avctx ▁-> ▁bits _ per _ raw _ sample ▁== ▁16 ▁) ▁{ ▁const ▁uint 16_ t ▁* ▁samples ▁= ▁( ▁uint 16_ t ▁* ▁) ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁for ▁( ▁c ▁= ▁0 ▁; ▁c ▁< ▁frame ▁-> ▁nb _ samples ▁; ▁c ▁++ ▁) ▁{ ▁uint 8_ t ▁v uc f ▁= ▁s ▁-> ▁fram ing _ index ▁== ▁0 ▁? ▁0 x 10 ▁: ▁0 ▁; ▁for ▁( ▁channels ▁= ▁0 ▁; ▁channels ▁< ▁avctx ▁-> ▁channels ▁; ▁channels ▁+= ▁2 ▁) ▁{ ▁o ▁[ ▁0 ▁] ▁= ▁ff _ reverse ▁[ ▁samples ▁[ ▁0 ▁] ▁& ▁0 xFF ▁] ▁; ▁o ▁[ ▁1 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁0 ▁] ▁& ▁0 xFF 00 ▁) ▁>> ▁8 ▁] ▁; ▁o ▁[ ▁2 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 x 0 F ▁) ▁<< ▁4 ▁] ▁| ▁v uc f ▁; ▁o ▁[ ▁3 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 x 0 FF 0 ▁) ▁>> ▁4 ▁] ▁; ▁o ▁[ ▁4 ▁] ▁= ▁ff _ reverse ▁[ ▁( ▁samples ▁[ ▁1 ▁] ▁& ▁0 xF 000 ▁) ▁>> ▁12 ▁] ▁; ▁o ▁+= ▁5 ▁; ▁samples ▁+= ▁2 ▁; ▁} ▁s ▁-> ▁fram ing _ index ▁++ ▁; ▁if ▁( ▁s ▁-> ▁fram ing _ index ▁>= ▁192 ▁) ▁s ▁-> ▁fram ing _ index ▁= ▁0 ▁; ▁} ▁} ▁* ▁got _ packet _ ptr ▁= ▁1 ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁flush _ encoder s ▁( ▁void ▁) ▁{ ▁int ▁i ▁, ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ output _ streams ▁; ▁i ▁++ ▁) ▁{ ▁OutputStream ▁* ▁o st ▁= ▁output _ streams ▁[ ▁i ▁] ▁; ▁AVCodecContext ▁* ▁enc ▁= ▁o st ▁-> ▁st ▁-> ▁codec ▁; ▁AVFormatContext ▁* ▁os ▁= ▁output _ files ▁[ ▁o st ▁-> ▁file _ index ▁] ▁-> ▁ctx ▁; ▁int ▁stop _ encoding ▁= ▁0 ▁; ▁if ▁( ▁! ▁o st ▁-> ▁encoding _ needed ▁) ▁continue ▁; ▁if ▁( ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁enc ▁-> ▁frame _ size ▁<= ▁1 ▁) ▁continue ▁; ▁if ▁( ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁&& ▁( ▁os ▁-> ▁of orm at ▁-> ▁flags ▁& ▁AV FMT _ RAW PICTURE ▁) ▁&& ▁enc ▁-> ▁codec ▁-> ▁id ▁== ▁CODEC _ ID _ RAW VIDEO ▁) ▁continue ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁int ▁( ▁* ▁encode ▁) ▁( ▁AVCodecContext ▁* ▁, ▁AVPacket ▁* ▁, ▁const ▁AVFrame ▁* ▁, ▁int ▁* ▁) ▁= ▁NULL ▁; ▁const ▁char ▁* ▁desc ▁; ▁int 64_ t ▁* ▁size ▁; ▁switch ▁( ▁o st ▁-> ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁encode ▁= ▁avcodec _ encode _ audio 2 ▁; ▁desc ▁= ▁" Audio " ▁; ▁size ▁= ▁& ▁audio _ size ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁encode ▁= ▁avcodec _ encode _ video 2 ▁; ▁desc ▁= ▁" Video " ▁; ▁size ▁= ▁& ▁video _ size ▁; ▁break ▁; ▁default ▁: ▁stop _ encoding ▁= ▁1 ▁; ▁} ▁if ▁( ▁encode ▁) ▁{ ▁AVPacket ▁pkt ▁; ▁int ▁got _ packet ▁; ▁av _ init _ packet ▁( ▁& ▁pkt ▁) ▁; ▁pkt ▁. ▁data ▁= ▁NULL ▁; ▁pkt ▁. ▁size ▁= ▁0 ▁; ▁ret ▁= ▁encode ▁( ▁enc ▁, ▁& ▁pkt ▁, ▁NULL ▁, ▁& ▁got _ packet ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ FATAL ▁, ▁"% s encoding failed \ n " ▁, ▁desc ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁* ▁size ▁+= ▁ret ▁; ▁if ▁( ▁o st ▁-> ▁logfile ▁&& ▁enc ▁-> ▁stats _ out ▁) ▁{ ▁fprintf ▁( ▁o st ▁-> ▁logfile ▁, ▁"% s " ▁, ▁enc ▁-> ▁stats _ out ▁) ▁; ▁} ▁if ▁( ▁! ▁got _ packet ▁) ▁{ ▁stop _ encoding ▁= ▁1 ▁; ▁break ▁; ▁} ▁if ▁( ▁pkt ▁. ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁pkt ▁. ▁pts ▁= ▁av _ re scale _ q ▁( ▁pkt ▁. ▁pts ▁, ▁enc ▁-> ▁time _ base ▁, ▁o st ▁-> ▁st ▁-> ▁time _ base ▁) ▁; ▁if ▁( ▁pkt ▁. ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁pkt ▁. ▁dts ▁= ▁av _ re scale _ q ▁( ▁pkt ▁. ▁dts ▁, ▁enc ▁-> ▁time _ base ▁, ▁o st ▁-> ▁st ▁-> ▁time _ base ▁) ▁; ▁write _ frame ▁( ▁os ▁, ▁& ▁pkt ▁, ▁o st ▁) ▁; ▁} ▁if ▁( ▁stop _ encoding ▁) ▁break ▁; ▁} ▁} ▁}	0
▁static ▁int ▁decode _ n al _ units ▁( ▁H EV C Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁length ▁) ▁{ ▁int ▁i ▁, ▁ret ▁= ▁0 ▁; ▁s ▁-> ▁ref ▁= ▁NULL ▁; ▁s ▁-> ▁last _ e os ▁= ▁s ▁-> ▁eos ▁; ▁s ▁-> ▁eos ▁= ▁0 ▁; ▁ret ▁= ▁ff _ he vc _ split _ packet ▁( ▁& ▁s ▁-> ▁pkt ▁, ▁buf ▁, ▁length ▁, ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁is _ n al ff ▁, ▁s ▁-> ▁nal _ length _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Errors plit ting the input into NAL units .\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁pkt ▁. ▁nb _ n als ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁pkt ▁. ▁n als ▁[ ▁i ▁] ▁. ▁type ▁== ▁N AL _ EO B _ N UT ▁|| ▁s ▁-> ▁pkt ▁. ▁n als ▁[ ▁i ▁] ▁. ▁type ▁== ▁N AL _ E OS _ N UT ▁) ▁s ▁-> ▁eos ▁= ▁1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁pkt ▁. ▁nb _ n als ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁= ▁decode _ n al _ unit ▁( ▁s ▁, ▁& ▁s ▁-> ▁pkt ▁. ▁n als ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Error parsing NAL unit #% d .\ n " ▁, ▁i ▁) ▁; ▁goto ▁fail ▁; ▁} ▁} ▁fail ▁: ▁if ▁( ▁s ▁-> ▁ref ▁&& ▁s ▁-> ▁threads _ type ▁== ▁FF _ THREAD _ FRAME ▁) ▁ff _ thread _ report _ progress ▁( ▁& ▁s ▁-> ▁ref ▁-> ▁tf ▁, ▁INT _ MAX ▁, ▁0 ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁X 509_ signature _ dump ▁( ▁BIO ▁* ▁bp ▁, ▁const ▁ASN 1_ STRING ▁* ▁sig ▁, ▁int ▁indent ▁) ▁{ ▁const ▁unsigned ▁char ▁* ▁s ▁; ▁int ▁i ▁, ▁n ▁; ▁n ▁= ▁sig ▁-> ▁length ▁; ▁s ▁= ▁sig ▁-> ▁data ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁i ▁% ▁18 ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁BIO _ write ▁( ▁bp ▁, ▁"\ n " ▁, ▁1 ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁BIO _ indent ▁( ▁bp ▁, ▁indent ▁, ▁indent ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁BIO _ printf ▁( ▁bp ▁, ▁"%02 x % s " ▁, ▁s ▁[ ▁i ▁] ▁, ▁( ▁( ▁i ▁+ ▁1 ▁) ▁== ▁n ▁) ▁? ▁"" ▁: ▁":" ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁BIO _ write ▁( ▁bp ▁, ▁"\ n " ▁, ▁1 ▁) ▁!= ▁1 ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁decode _ unit ▁( ▁SC PR Context ▁* ▁s ▁, ▁Pixel Model ▁* ▁pixel ▁, ▁unsigned ▁step ▁, ▁unsigned ▁* ▁rval ▁) ▁{ ▁Get Byte Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁gb ▁; ▁Range Coder ▁* ▁rc ▁= ▁& ▁s ▁-> ▁rc ▁; ▁unsigned ▁tot fr ▁= ▁pixel ▁-> ▁total _ freq ▁; ▁unsigned ▁value ▁, ▁x ▁= ▁0 ▁, ▁cum fr ▁= ▁0 ▁, ▁cnt _ x ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁, ▁ret ▁, ▁c ▁, ▁cnt _ c ▁; ▁if ▁( ▁( ▁ret ▁= ▁s ▁-> ▁get _ freq ▁( ▁rc ▁, ▁tot fr ▁, ▁& ▁value ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁while ▁( ▁x ▁< ▁16 ▁) ▁{ ▁cnt _ x ▁= ▁pixel ▁-> ▁lookup ▁[ ▁x ▁] ▁; ▁if ▁( ▁value ▁>= ▁cum fr ▁+ ▁cnt _ x ▁) ▁cum fr ▁+= ▁cnt _ x ▁; ▁else ▁break ▁; ▁x ▁++ ▁; ▁} ▁c ▁= ▁x ▁* ▁16 ▁; ▁cnt _ c ▁= ▁0 ▁; ▁while ▁( ▁c ▁< ▁256 ▁) ▁{ ▁cnt _ c ▁= ▁pixel ▁-> ▁freq ▁[ ▁c ▁] ▁; ▁if ▁( ▁value ▁>= ▁cum fr ▁+ ▁cnt _ c ▁) ▁cum fr ▁+= ▁cnt _ c ▁; ▁else ▁break ▁; ▁c ▁++ ▁; ▁} ▁if ▁( ▁( ▁ret ▁= ▁s ▁-> ▁decode ▁( ▁gb ▁, ▁rc ▁, ▁cum fr ▁, ▁cnt _ c ▁, ▁tot fr ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁pixel ▁-> ▁freq ▁[ ▁c ▁] ▁= ▁cnt _ c ▁+ ▁step ▁; ▁pixel ▁-> ▁lookup ▁[ ▁x ▁] ▁= ▁cnt _ x ▁+ ▁step ▁; ▁tot fr ▁+= ▁step ▁; ▁if ▁( ▁tot fr ▁> ▁BOT ▁) ▁{ ▁tot fr ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁nc ▁= ▁( ▁pixel ▁-> ▁freq ▁[ ▁i ▁] ▁>> ▁1 ▁) ▁+ ▁1 ▁; ▁pixel ▁-> ▁freq ▁[ ▁i ▁] ▁= ▁nc ▁; ▁tot fr ▁+= ▁nc ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁sum ▁= ▁0 ▁; ▁unsigned ▁i 16_ 17 ▁= ▁i ▁<< ▁4 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁16 ▁; ▁j ▁++ ▁) ▁sum ▁+= ▁pixel ▁-> ▁freq ▁[ ▁i 16_ 17 ▁+ ▁j ▁] ▁; ▁pixel ▁-> ▁lookup ▁[ ▁i ▁] ▁= ▁sum ▁; ▁} ▁} ▁pixel ▁-> ▁total _ freq ▁= ▁tot fr ▁; ▁* ▁rval ▁= ▁c ▁& ▁s ▁-> ▁c bits ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁vp 6_ parse _ coeff _ h uffman ▁( ▁VP 56 Context ▁* ▁s ▁) ▁{ ▁VP 56 Model ▁* ▁model ▁= ▁s ▁-> ▁model p ▁; ▁uint 8_ t ▁* ▁perm ute ▁= ▁s ▁-> ▁sc ant able ▁. ▁perm ut ated ▁; ▁VLC ▁* ▁vlc _ coeff ▁; ▁int ▁coeff ▁, ▁sign ▁, ▁coeff _ idx ▁; ▁int ▁b ▁, ▁cg ▁, ▁idx ▁; ▁int ▁pt ▁= ▁0 ▁; ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁< ▁6 ▁; ▁b ▁++ ▁) ▁{ ▁int ▁ct ▁= ▁0 ▁; ▁if ▁( ▁b ▁> ▁3 ▁) ▁pt ▁= ▁1 ▁; ▁vlc _ coeff ▁= ▁& ▁s ▁-> ▁dcc v _ vlc ▁[ ▁pt ▁] ▁; ▁for ▁( ▁coeff _ idx ▁= ▁0 ▁; ▁coeff _ idx ▁< ▁64 ▁; ▁) ▁{ ▁int ▁run ▁= ▁1 ▁; ▁if ▁( ▁coeff _ idx ▁< ▁2 ▁&& ▁s ▁-> ▁nb _ null ▁[ ▁coeff _ idx ▁] ▁[ ▁pt ▁] ▁) ▁{ ▁s ▁-> ▁nb _ null ▁[ ▁coeff _ idx ▁] ▁[ ▁pt ▁] ▁-- ▁; ▁if ▁( ▁coeff _ idx ▁) ▁break ▁; ▁} ▁else ▁{ ▁if ▁( ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁>= ▁s ▁-> ▁gb ▁. ▁size _ in _ bits ▁) ▁return ▁; ▁coeff ▁= ▁get _ vlc 2 ▁( ▁& ▁s ▁-> ▁gb ▁, ▁vlc _ coeff ▁-> ▁table ▁, ▁9 ▁, ▁3 ▁) ▁; ▁if ▁( ▁coeff ▁== ▁0 ▁) ▁{ ▁if ▁( ▁coeff _ idx ▁) ▁{ ▁int ▁pt ▁= ▁( ▁coeff _ idx ▁>= ▁6 ▁) ▁; ▁run ▁+= ▁get _ vlc 2 ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁run v _ vlc ▁[ ▁pt ▁] ▁. ▁table ▁, ▁9 ▁, ▁3 ▁) ▁; ▁if ▁( ▁run ▁>= ▁9 ▁) ▁run ▁+= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁6 ▁) ▁; ▁} ▁else ▁s ▁-> ▁nb _ null ▁[ ▁0 ▁] ▁[ ▁pt ▁] ▁= ▁vp 6_ get _ nb _ null ▁( ▁s ▁) ▁; ▁ct ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁coeff ▁== ▁11 ▁) ▁{ ▁if ▁( ▁coeff _ idx ▁== ▁1 ▁) ▁s ▁-> ▁nb _ null ▁[ ▁1 ▁] ▁[ ▁pt ▁] ▁= ▁vp 6_ get _ nb _ null ▁( ▁s ▁) ▁; ▁break ▁; ▁} ▁else ▁{ ▁int ▁coeff 2 ▁= ▁vp 5 6_ coeff _ bias ▁[ ▁coeff ▁] ▁; ▁if ▁( ▁coeff ▁> ▁4 ▁) ▁coeff 2 ▁+= ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁coeff ▁<= ▁9 ▁? ▁coeff ▁- ▁4 ▁: ▁11 ▁) ▁; ▁ct ▁= ▁1 ▁+ ▁( ▁coeff 2 ▁> ▁1 ▁) ▁; ▁sign ▁= ▁get _ bits 1 ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁coeff 2 ▁= ▁( ▁coeff 2 ▁ ^ ▁- ▁sign ▁) ▁+ ▁sign ▁; ▁if ▁( ▁coeff _ idx ▁) ▁coeff 2 ▁*= ▁s ▁-> ▁de quant _ ac ▁; ▁idx ▁= ▁model ▁-> ▁coeff _ index _ to _ pos ▁[ ▁coeff _ idx ▁] ▁; ▁s ▁-> ▁block _ coeff ▁[ ▁b ▁] ▁[ ▁perm ute ▁[ ▁idx ▁] ▁] ▁= ▁coeff 2 ▁; ▁} ▁} ▁coeff _ idx ▁+= ▁run ▁; ▁cg ▁= ▁FF MIN ▁( ▁vp 6_ coeff _ groups ▁[ ▁coeff _ idx ▁] ▁, ▁3 ▁) ▁; ▁vlc _ coeff ▁= ▁& ▁s ▁-> ▁r act _ vlc ▁[ ▁pt ▁] ▁[ ▁ct ▁] ▁[ ▁cg ▁] ▁; ▁} ▁} ▁}	1
▁static ▁RAND _ DR BG ▁* ▁dr bg _ setup ▁( ▁RAND _ DR BG ▁* ▁parent ▁) ▁{ ▁RAND _ DR BG ▁* ▁dr bg ▁; ▁dr bg ▁= ▁OPENSSL _ secure _ zalloc ▁( ▁sizeof ▁( ▁RAND _ DR BG ▁) ▁) ▁; ▁if ▁( ▁dr bg ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁dr bg ▁-> ▁lock ▁= ▁CRYPTO _ THREAD _ lock _ new ▁( ▁) ▁; ▁if ▁( ▁dr bg ▁-> ▁lock ▁== ▁NULL ▁) ▁{ ▁RAND err ▁( ▁RAND _ F _ DR BG _ SETUP ▁, ▁RAND _ R _ FAILED _ TO _ CREATE _ LOCK ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁RAND _ DR BG _ set ▁( ▁dr bg ▁, ▁RAND _ DR BG _ NID ▁, ▁RAND _ DR BG _ FLAG _ CTR _ USE _ DF ▁) ▁!= ▁1 ▁) ▁goto ▁err ▁; ▁if ▁( ▁RAND _ DR BG _ set _ callbacks ▁( ▁dr bg ▁, ▁rand _ drbg _ get _ entropy ▁, ▁rand _ drbg _ cleanup _ entropy ▁, ▁NULL ▁, ▁NULL ▁) ▁!= ▁1 ▁) ▁goto ▁err ▁; ▁if ▁( ▁parent ▁== ▁NULL ▁) ▁{ ▁dr bg ▁-> ▁re seed _ interval ▁= ▁MASTER _ RES E ED _ INTERVAL ▁; ▁dr bg ▁-> ▁re seed _ time _ interval ▁= ▁MASTER _ RES E ED _ TIME _ INTERVAL ▁; ▁} ▁else ▁{ ▁dr bg ▁-> ▁parent ▁= ▁parent ▁; ▁dr bg ▁-> ▁re seed _ interval ▁= ▁SL AVE _ RES E ED _ INTERVAL ▁; ▁dr bg ▁-> ▁re seed _ time _ interval ▁= ▁SL AVE _ RES E ED _ TIME _ INTERVAL ▁; ▁} ▁dr bg ▁-> ▁re seed _ counter ▁= ▁1 ▁; ▁RAND _ DR BG _ instantiate ▁( ▁dr bg ▁, ▁( ▁const ▁unsigned ▁char ▁* ▁) ▁ossl _ pers _ string ▁, ▁sizeof ▁( ▁ossl _ pers _ string ▁) ▁- ▁1 ▁) ▁; ▁return ▁dr bg ▁; ▁err ▁: ▁dr bg _ cleanup ▁( ▁dr bg ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁ass _ get _ duration ▁( ▁const ▁uint 8_ t ▁* ▁p ▁) ▁{ ▁int ▁sh ▁, ▁sm ▁, ▁ss ▁, ▁sc ▁, ▁eh ▁, ▁em ▁, ▁es ▁, ▁ec ▁; ▁uint 64_ t ▁start ▁, ▁end ▁; ▁if ▁( ▁sscanf ▁( ▁p ▁, ▁"%* [ ^ , ], % d :% d :% d % * c % d ,% d :% d :% d % * c % d " ▁, ▁& ▁sh ▁, ▁& ▁sm ▁, ▁& ▁ss ▁, ▁& ▁sc ▁, ▁& ▁eh ▁, ▁& ▁em ▁, ▁& ▁es ▁, ▁& ▁ec ▁) ▁!= ▁8 ▁) ▁return ▁0 ▁; ▁start ▁= ▁36 00000 ▁* ▁sh ▁+ ▁60000 ▁* ▁sm ▁+ ▁1000 ▁* ▁ss ▁+ ▁10 ▁* ▁sc ▁; ▁end ▁= ▁36 00000 ▁* ▁eh ▁+ ▁60000 ▁* ▁em ▁+ ▁1000 ▁* ▁es ▁+ ▁10 ▁* ▁ec ▁; ▁return ▁end ▁- ▁start ▁; ▁}	1
▁static ▁int ▁tls _ decrypt _ ticket ▁( ▁SSL ▁* ▁s ▁, ▁const ▁unsigned ▁char ▁* ▁et ick ▁, ▁size _ t ▁et ick len ▁, ▁const ▁unsigned ▁char ▁* ▁sess _ id ▁, ▁size _ t ▁sess len ▁, ▁SSL _ SESSION ▁* ▁* ▁p sess ▁) ▁{ ▁SSL _ SESSION ▁* ▁sess ▁; ▁unsigned ▁char ▁* ▁s dec ▁; ▁const ▁unsigned ▁char ▁* ▁p ▁; ▁int ▁slen ▁, ▁renew _ ticket ▁= ▁0 ▁, ▁ret ▁= ▁-1 ▁, ▁decl en ▁; ▁size _ t ▁mlen ▁; ▁unsigned ▁char ▁tick _ hmac ▁[ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁HMAC _ CTX ▁* ▁hctx ▁= ▁NULL ▁; ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁; ▁SSL _ CTX ▁* ▁tctx ▁= ▁s ▁-> ▁initial _ ctx ▁; ▁hctx ▁= ▁HMAC _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁hctx ▁== ▁NULL ▁) ▁return ▁-2 ▁; ▁ctx ▁= ▁EVP _ CIPHER _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁ret ▁= ▁-2 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁tctx ▁-> ▁tl se xt _ ticket _ key _ cb ▁) ▁{ ▁unsigned ▁char ▁* ▁n ct ick ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁et ick ▁; ▁int ▁rv ▁= ▁tctx ▁-> ▁tl se xt _ ticket _ key _ cb ▁( ▁s ▁, ▁n ct ick ▁, ▁n ct ick ▁+ ▁16 ▁, ▁ctx ▁, ▁hctx ▁, ▁0 ▁) ▁; ▁if ▁( ▁rv ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁rv ▁== ▁0 ▁) ▁{ ▁ret ▁= ▁2 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁rv ▁== ▁2 ▁) ▁renew _ ticket ▁= ▁1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁memcmp ▁( ▁et ick ▁, ▁tctx ▁-> ▁tl se xt _ tick _ key _ name ▁, ▁sizeof ▁( ▁tctx ▁-> ▁tl se xt _ tick _ key _ name ▁) ▁) ▁!= ▁0 ▁) ▁{ ▁ret ▁= ▁2 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁HMAC _ Init _ ex ▁( ▁hctx ▁, ▁tctx ▁-> ▁tl se xt _ tick _ hmac _ key ▁, ▁sizeof ▁( ▁tctx ▁-> ▁tl se xt _ tick _ hmac _ key ▁) ▁, ▁EVP _ sha 256 ▁( ▁) ▁, ▁NULL ▁) ▁<= ▁0 ▁|| ▁EVP _ Decrypt Init _ ex ▁( ▁ctx ▁, ▁EVP _ aes _256_ cbc ▁( ▁) ▁, ▁NULL ▁, ▁tctx ▁-> ▁tl se xt _ tick _ aes _ key ▁, ▁et ick ▁+ ▁sizeof ▁( ▁tctx ▁-> ▁tl se xt _ tick _ key _ name ▁) ▁) ▁<= ▁0 ▁) ▁{ ▁goto ▁err ▁; ▁} ▁} ▁mlen ▁= ▁HMAC _ size ▁( ▁hctx ▁) ▁; ▁if ▁( ▁mlen ▁== ▁0 ▁) ▁{ ▁goto ▁err ▁; ▁} ▁if ▁( ▁et ick len ▁<= ▁TL SE XT _ KEY NAME _ LENGTH ▁+ ▁EVP _ CIPHER _ CTX _ iv _ length ▁( ▁ctx ▁) ▁+ ▁mlen ▁) ▁{ ▁ret ▁= ▁2 ▁; ▁goto ▁err ▁; ▁} ▁et ick len ▁-= ▁mlen ▁; ▁if ▁( ▁HMAC _ Update ▁( ▁hctx ▁, ▁et ick ▁, ▁et ick len ▁) ▁<= ▁0 ▁|| ▁HMAC _ Final ▁( ▁hctx ▁, ▁tick _ hmac ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁{ ▁goto ▁err ▁; ▁} ▁HMAC _ CTX _ free ▁( ▁hctx ▁) ▁; ▁if ▁( ▁CRYPTO _ memcmp ▁( ▁tick _ hmac ▁, ▁et ick ▁+ ▁et ick len ▁, ▁mlen ▁) ▁) ▁{ ▁EVP _ CIPHER _ CTX _ free ▁( ▁ctx ▁) ▁; ▁return ▁2 ▁; ▁} ▁p ▁= ▁et ick ▁+ ▁16 ▁+ ▁EVP _ CIPHER _ CTX _ iv _ length ▁( ▁ctx ▁) ▁; ▁et ick len ▁-= ▁16 ▁+ ▁EVP _ CIPHER _ CTX _ iv _ length ▁( ▁ctx ▁) ▁; ▁s dec ▁= ▁OPENSSL _ malloc ▁( ▁et ick len ▁) ▁; ▁if ▁( ▁s dec ▁== ▁NULL ▁|| ▁EVP _ Decrypt Update ▁( ▁ctx ▁, ▁s dec ▁, ▁& ▁slen ▁, ▁p ▁, ▁( ▁int ▁) ▁et ick len ▁) ▁<= ▁0 ▁) ▁{ ▁EVP _ CIPHER _ CTX _ free ▁( ▁ctx ▁) ▁; ▁OPENSSL _ free ▁( ▁s dec ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁EVP _ Decrypt Final ▁( ▁ctx ▁, ▁s dec ▁+ ▁slen ▁, ▁& ▁decl en ▁) ▁<= ▁0 ▁) ▁{ ▁EVP _ CIPHER _ CTX _ free ▁( ▁ctx ▁) ▁; ▁OPENSSL _ free ▁( ▁s dec ▁) ▁; ▁return ▁2 ▁; ▁} ▁slen ▁+= ▁decl en ▁; ▁EVP _ CIPHER _ CTX _ free ▁( ▁ctx ▁) ▁; ▁ctx ▁= ▁NULL ▁; ▁p ▁= ▁s dec ▁; ▁sess ▁= ▁d 2 i _ SSL _ SESSION ▁( ▁NULL ▁, ▁& ▁p ▁, ▁slen ▁) ▁; ▁OPENSSL _ free ▁( ▁s dec ▁) ▁; ▁if ▁( ▁sess ▁) ▁{ ▁if ▁( ▁sess len ▁) ▁memcpy ▁( ▁sess ▁-> ▁session _ id ▁, ▁sess _ id ▁, ▁sess len ▁) ▁; ▁sess ▁-> ▁session _ id _ length ▁= ▁sess len ▁; ▁* ▁p sess ▁= ▁sess ▁; ▁if ▁( ▁renew _ ticket ▁) ▁return ▁4 ▁; ▁else ▁return ▁3 ▁; ▁} ▁ERR _ clear _ error ▁( ▁) ▁; ▁return ▁2 ▁; ▁err ▁: ▁EVP _ CIPHER _ CTX _ free ▁( ▁ctx ▁) ▁; ▁HMAC _ CTX _ free ▁( ▁hctx ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁int ▁tls _ process _ cert _ status _ body ▁( ▁SSL ▁* ▁s ▁, ▁PACKET ▁* ▁pkt ▁, ▁int ▁* ▁al ▁) ▁{ ▁size _ t ▁resp len ▁; ▁unsigned ▁int ▁type ▁; ▁if ▁( ▁! ▁PACKET _ get _1 ▁( ▁pkt ▁, ▁& ▁type ▁) ▁|| ▁type ▁!= ▁TL SE XT _ STAT UST YPE _ oc sp ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PROCESS _ CERT _ STATUS _ BODY ▁, ▁SSL _ R _ UNSUPPORTED _ STATUS _ TYPE ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁! ▁PACKET _ get _ net _3_ len ▁( ▁pkt ▁, ▁& ▁resp len ▁) ▁|| ▁PACKET _ remaining ▁( ▁pkt ▁) ▁!= ▁resp len ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PROCESS _ CERT _ STATUS _ BODY ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁return ▁0 ▁; ▁} ▁s ▁-> ▁tl se xt _ oc sp _ resp ▁= ▁OPENSSL _ malloc ▁( ▁resp len ▁) ▁; ▁if ▁( ▁s ▁-> ▁tl se xt _ oc sp _ resp ▁== ▁NULL ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PROCESS _ CERT _ STATUS _ BODY ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁! ▁PACKET _ copy _ bytes ▁( ▁pkt ▁, ▁s ▁-> ▁tl se xt _ oc sp _ resp ▁, ▁resp len ▁) ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ TLS _ PROCESS _ CERT _ STATUS _ BODY ▁, ▁SSL _ R _ LENGTH _ MISMATCH ▁) ▁; ▁return ▁0 ▁; ▁} ▁s ▁-> ▁tl se xt _ oc sp _ resp len ▁= ▁resp len ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁ftp _ restart ▁( ▁FTP Context ▁* ▁s ▁, ▁int 64_ t ▁pos ▁) ▁{ ▁char ▁command ▁[ ▁CONTROL _ BUFFER _ SIZE ▁] ▁; ▁const ▁int ▁rest _ codes ▁[ ▁] ▁= ▁{ ▁350 ▁, ▁501 ▁, ▁0 ▁} ▁; ▁snprintf ▁( ▁command ▁, ▁sizeof ▁( ▁command ▁) ▁, ▁" REST %" ▁PRId 64 ▁"\ r \ n " ▁, ▁pos ▁) ▁; ▁if ▁( ▁ftp _ send _ command ▁( ▁s ▁, ▁command ▁, ▁rest _ codes ▁, ▁NULL ▁) ▁!= ▁350 ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁void ▁av _ dyn array _ add ▁( ▁void ▁* ▁tab _ ptr ▁, ▁int ▁* ▁nb _ ptr ▁, ▁void ▁* ▁elem ▁) ▁{ ▁int ▁nb ▁, ▁nb _ alloc ▁; ▁intptr _ t ▁* ▁tab ▁; ▁nb ▁= ▁* ▁nb _ ptr ▁; ▁tab ▁= ▁* ▁( ▁intptr _ t ▁* ▁* ▁) ▁tab _ ptr ▁; ▁if ▁( ▁( ▁nb ▁& ▁( ▁nb ▁- ▁1 ▁) ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁nb ▁== ▁0 ▁) ▁{ ▁nb _ alloc ▁= ▁1 ▁; ▁} ▁else ▁{ ▁if ▁( ▁nb ▁> ▁INT _ MAX ▁/ ▁( ▁2 ▁* ▁sizeof ▁( ▁intptr _ t ▁) ▁) ▁) ▁goto ▁fail ▁; ▁nb _ alloc ▁= ▁nb ▁* ▁2 ▁; ▁} ▁tab ▁= ▁av _ realloc ▁( ▁tab ▁, ▁nb _ alloc ▁* ▁sizeof ▁( ▁intptr _ t ▁) ▁) ▁; ▁if ▁( ▁! ▁tab ▁) ▁goto ▁fail ▁; ▁* ▁( ▁intptr _ t ▁* ▁* ▁) ▁tab _ ptr ▁= ▁tab ▁; ▁} ▁tab ▁[ ▁nb ▁++ ▁] ▁= ▁( ▁intptr _ t ▁) ▁elem ▁; ▁* ▁nb _ ptr ▁= ▁nb ▁; ▁return ▁; ▁fail ▁: ▁av _ freep ▁( ▁tab _ ptr ▁) ▁; ▁* ▁nb _ ptr ▁= ▁0 ▁; ▁}	0
▁SSL _ CTX ▁* ▁SSL _ CTX _ new ▁( ▁const ▁SSL _ METHOD ▁* ▁meth ▁) ▁{ ▁SSL _ CTX ▁* ▁ret ▁= ▁NULL ▁; ▁if ▁( ▁meth ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ NULL _ SSL _ METHOD _ PASSED ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁! ▁OPENSSL _ init _ ssl ▁( ▁OPENSSL _ INIT _ LOAD _ SSL _ STRINGS ▁, ▁NULL ▁) ▁) ▁return ▁NULL ▁; ▁if ▁( ▁SSL _ get _ ex _ data _ X 509_ STORE _ CTX _ idx ▁( ▁) ▁< ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ X 509_ VER IFICATION _ SETUP _ PRO BLE MS ▁) ▁; ▁goto ▁err ▁; ▁} ▁ret ▁= ▁OPENSSL _ zalloc ▁( ▁sizeof ▁( ▁* ▁ret ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁method ▁= ▁meth ▁; ▁ret ▁-> ▁min _ proto _ version ▁= ▁0 ▁; ▁ret ▁-> ▁max _ proto _ version ▁= ▁0 ▁; ▁ret ▁-> ▁mode ▁= ▁SSL _ MODE _ AUTO _ RETRY ▁; ▁ret ▁-> ▁session _ cache _ mode ▁= ▁SSL _ S ESS _ CACHE _ SERVER ▁; ▁ret ▁-> ▁session _ cache _ size ▁= ▁SSL _ SESSION _ CACHE _ MAX _ SIZE _ DEFAULT ▁; ▁ret ▁-> ▁session _ timeout ▁= ▁meth ▁-> ▁get _ timeout ▁( ▁) ▁; ▁ret ▁-> ▁references ▁= ▁1 ▁; ▁ret ▁-> ▁lock ▁= ▁CRYPTO _ THREAD _ lock _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁lock ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁OPENSSL _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁} ▁ret ▁-> ▁max _ cert _ list ▁= ▁SSL _ MAX _ CERT _ LIST _ DEFAULT ▁; ▁ret ▁-> ▁verify _ mode ▁= ▁SSL _ VERIFY _ NONE ▁; ▁if ▁( ▁( ▁ret ▁-> ▁cert ▁= ▁ssl _ cert _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁sessions ▁= ▁lh _ SSL _ SESSION _ new ▁( ▁ssl _ session _ hash ▁, ▁ssl _ session _ cmp ▁) ▁; ▁if ▁( ▁ret ▁-> ▁sessions ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁cert _ store ▁= ▁X 509_ STORE _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cert _ store ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁# ifndef ▁OPENSSL _ NO _ CT ▁ret ▁-> ▁ct log _ store ▁= ▁CT LOG _ STORE _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁ct log _ store ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁# endif ▁if ▁( ▁! ▁SSL _ CTX _ set _ c iphers u ites ▁( ▁ret ▁, ▁TLS _ DEFAULT _ CIPHER SU ITES ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁ssl _ create _ cipher _ list ▁( ▁ret ▁-> ▁method ▁, ▁ret ▁-> ▁tls 13_ c iphers u ites ▁, ▁& ▁ret ▁-> ▁cipher _ list ▁, ▁& ▁ret ▁-> ▁cipher _ list _ by _ id ▁, ▁SSL _ DEFAULT _ CIPHER _ LIST ▁, ▁ret ▁-> ▁cert ▁) ▁|| ▁sk _ SSL _ CIPHER _ num ▁( ▁ret ▁-> ▁cipher _ list ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ LIBRARY _ HAS _ NO _ CIPHER S ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁ret ▁-> ▁param ▁= ▁X 509_ VERIFY _ PARAM _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁param ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁ret ▁-> ▁md 5 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- md 5" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ MD 5_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁sha 1 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- sha 1" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ SHA 1_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁ca _ names ▁= ▁sk _ X 509_ NAME _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁ret ▁-> ▁client _ ca _ names ▁= ▁sk _ X 509_ NAME _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁CRYPTO _ new _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL _ CTX ▁, ▁ret ▁, ▁& ▁ret ▁-> ▁ex _ data ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁ret ▁-> ▁ext ▁. ▁secure ▁= ▁OPENSSL _ secure _ zalloc ▁( ▁sizeof ▁( ▁* ▁ret ▁-> ▁ext ▁. ▁secure ▁) ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁( ▁meth ▁-> ▁ssl 3_ enc ▁-> ▁enc _ flags ▁& ▁SSL _ ENC _ FLAG _ DT LS ▁) ▁) ▁ret ▁-> ▁comp _ methods ▁= ▁SSL _ COMP _ get _ compression _ methods ▁( ▁) ▁; ▁ret ▁-> ▁max _ send _ fragment ▁= ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁; ▁ret ▁-> ▁split _ send _ fragment ▁= ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁; ▁if ▁( ▁( ▁RAND _ bytes ▁( ▁ret ▁-> ▁ext ▁. ▁tick _ key _ name ▁, ▁sizeof ▁( ▁ret ▁-> ▁ext ▁. ▁tick _ key _ name ▁) ▁) ▁<= ▁0 ▁) ▁|| ▁( ▁RAND _ priv _ bytes ▁( ▁ret ▁-> ▁ext ▁. ▁secure ▁-> ▁tick _ hmac _ key ▁, ▁sizeof ▁( ▁ret ▁-> ▁ext ▁. ▁secure ▁-> ▁tick _ hmac _ key ▁) ▁) ▁<= ▁0 ▁) ▁|| ▁( ▁RAND _ priv _ bytes ▁( ▁ret ▁-> ▁ext ▁. ▁secure ▁-> ▁tick _ aes _ key ▁, ▁sizeof ▁( ▁ret ▁-> ▁ext ▁. ▁secure ▁-> ▁tick _ aes _ key ▁) ▁) ▁<= ▁0 ▁) ▁) ▁ret ▁-> ▁options ▁|= ▁SSL _ OP _ NO _ TICK ET ▁; ▁if ▁( ▁RAND _ priv _ bytes ▁( ▁ret ▁-> ▁ext ▁. ▁cookie _ hmac _ key ▁, ▁sizeof ▁( ▁ret ▁-> ▁ext ▁. ▁cookie _ hmac _ key ▁) ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁# ifndef ▁OPENSSL _ NO _ SR P ▁if ▁( ▁! ▁SSL _ CTX _ SR P _ CTX _ init ▁( ▁ret ▁) ▁) ▁goto ▁err ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁# ifdef ▁OPENSSL _ SSL _ CLIENT _ ENGINE _ AUTO ▁# define ▁eng _ str x ▁( ▁x ▁) ▁# x ▁# define ▁eng _ str ▁( ▁x ▁) ▁eng _ str x ( x ) ▁{ ▁ENGINE ▁* ▁eng ▁; ▁eng ▁= ▁ENGINE _ by _ id ▁( ▁eng _ str ▁( ▁OPENSSL _ SSL _ CLIENT _ ENGINE _ AUTO ▁) ▁) ▁; ▁if ▁( ▁! ▁eng ▁) ▁{ ▁ERR _ clear _ error ▁( ▁) ▁; ▁ENGINE _ load _ builtin _ engines ▁( ▁) ▁; ▁eng ▁= ▁ENGINE _ by _ id ▁( ▁eng _ str ▁( ▁OPENSSL _ SSL _ CLIENT _ ENGINE _ AUTO ▁) ▁) ▁; ▁} ▁if ▁( ▁! ▁eng ▁|| ▁! ▁SSL _ CTX _ set _ client _ cert _ engine ▁( ▁ret ▁, ▁eng ▁) ▁) ▁ERR _ clear _ error ▁( ▁) ▁; ▁} ▁# endif ▁# endif ▁ret ▁-> ▁options ▁|= ▁SSL _ OP _ LEGACY _ SERVER _ CONNECT ▁; ▁ret ▁-> ▁options ▁|= ▁SSL _ OP _ NO _ COMPRESSION ▁| ▁SSL _ OP _ ENABLE _ MIDDLE BOX _ COMPAT ▁; ▁ret ▁-> ▁ext ▁. ▁status _ type ▁= ▁TL SE XT _ STAT UST YPE _ nothing ▁; ▁ret ▁-> ▁max _ early _ data ▁= ▁0 ▁; ▁ret ▁-> ▁recv _ max _ early _ data ▁= ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁; ▁ret ▁-> ▁num _ tick ets ▁= ▁2 ▁; ▁ssl _ ctx _ system _ config ▁( ▁ret ▁) ▁; ▁return ▁ret ▁; ▁err ▁: ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁err 2 ▁: ▁SSL _ CTX _ free ▁( ▁ret ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁mpeg _ motion _ internal ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁field _ based ▁, ▁int ▁bottom _ field ▁, ▁int ▁field _ select ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁int ▁motion _ x ▁, ▁int ▁motion _ y ▁, ▁int ▁h ▁, ▁int ▁is _ mpeg 12 ▁, ▁int ▁mb _ y ▁) ▁{ ▁uint 8_ t ▁* ▁ptr _ y ▁, ▁* ▁ptr _ cb ▁, ▁* ▁ptr _ cr ▁; ▁int ▁d xy ▁, ▁uv d xy ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁, ▁uv src _ x ▁, ▁uv src _ y ▁, ▁v _ edge _ pos ▁; ▁ptrdiff _ t ▁uv lines ize ▁, ▁linesize ▁; ▁# if ▁0 ▁if ▁( ▁s ▁-> ▁qu arter _ sample ▁) ▁{ ▁motion _ x ▁>>= ▁1 ▁; ▁motion _ y ▁>>= ▁1 ▁; ▁} ▁# endif ▁v _ edge _ pos ▁= ▁s ▁-> ▁v _ edge _ pos ▁>> ▁field _ based ▁; ▁linesize ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁-> ▁linesize ▁[ ▁0 ▁] ▁<< ▁field _ based ▁; ▁uv lines ize ▁= ▁s ▁-> ▁current _ picture ▁. ▁f ▁-> ▁linesize ▁[ ▁1 ▁] ▁<< ▁field _ based ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁1 ▁) ▁; ▁src _ y ▁= ▁( ▁mb _ y ▁<< ▁( ▁4 ▁- ▁field _ based ▁) ▁) ▁+ ▁( ▁motion _ y ▁>> ▁1 ▁) ▁; ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 263 ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ H PE L _ CH RO MA ▁) ▁&& ▁field _ based ▁) ▁{ ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁my ▁= ▁motion _ y ▁>> ▁1 ▁; ▁uv d xy ▁= ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁( ▁mx ▁>> ▁1 ▁) ▁; ▁uv src _ y ▁= ▁( ▁mb _ y ▁<< ▁( ▁3 ▁- ▁field _ based ▁) ▁) ▁+ ▁( ▁my ▁>> ▁1 ▁) ▁; ▁} ▁else ▁{ ▁uv d xy ▁= ▁d xy ▁| ▁( ▁motion _ y ▁& ▁2 ▁) ▁| ▁( ▁( ▁motion _ x ▁& ▁2 ▁) ▁>> ▁1 ▁) ▁; ▁uv src _ x ▁= ▁src _ x ▁>> ▁1 ▁; ▁uv src _ y ▁= ▁src _ y ▁>> ▁1 ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 26 1 ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁4 ▁; ▁my ▁= ▁motion _ y ▁/ ▁4 ▁; ▁uv d xy ▁= ▁0 ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁uv src _ y ▁= ▁mb _ y ▁* ▁8 ▁+ ▁my ▁; ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁chroma _ y _ shift ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁/ ▁2 ▁; ▁uv d xy ▁= ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁( ▁mx ▁>> ▁1 ▁) ▁; ▁uv src _ y ▁= ▁( ▁mb _ y ▁<< ▁( ▁3 ▁- ▁field _ based ▁) ▁) ▁+ ▁( ▁my ▁>> ▁1 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁s ▁-> ▁chroma _ x _ shift ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁uv d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁( ▁mx ▁>> ▁1 ▁) ▁; ▁uv src _ y ▁= ▁src _ y ▁; ▁} ▁else ▁{ ▁uv d xy ▁= ▁d xy ▁; ▁uv src _ x ▁= ▁src _ x ▁; ▁uv src _ y ▁= ▁src _ y ▁; ▁} ▁} ▁} ▁ptr _ y ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁src _ y ▁* ▁linesize ▁+ ▁src _ x ▁; ▁ptr _ cb ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁ptr _ cr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁src _ x ▁> ▁FF MAX ▁( ▁s ▁-> ▁h _ edge _ pos ▁- ▁( ▁motion _ x ▁& ▁1 ▁) ▁- ▁16 ▁, ▁0 ▁) ▁|| ▁( ▁unsigned ▁) ▁src _ y ▁> ▁FF MAX ▁( ▁v _ edge _ pos ▁- ▁( ▁motion _ y ▁& ▁1 ▁) ▁- ▁h ▁, ▁0 ▁) ▁) ▁{ ▁if ▁( ▁is _ mpeg 12 ▁|| ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁|| ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 1 VIDEO ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" MPEG motion vector out of boundary (% d % d )\ n " ▁, ▁src _ x ▁, ▁src _ y ▁) ▁; ▁return ▁; ▁} ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr _ y ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁linesize ▁, ▁17 ▁, ▁17 ▁+ ▁field _ based ▁, ▁src _ x ▁, ▁src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr _ y ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁uv buf ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁+ ▁18 ▁* ▁s ▁-> ▁linesize ▁; ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁, ▁ptr _ cb ▁, ▁s ▁-> ▁uv lines ize ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁+ ▁16 ▁, ▁ptr _ cr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr _ cb ▁= ▁uv buf ▁; ▁ptr _ cr ▁= ▁uv buf ▁+ ▁16 ▁; ▁} ▁} ▁if ▁( ▁bottom _ field ▁) ▁{ ▁dest _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁dest _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁dest _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁if ▁( ▁field _ select ▁) ▁{ ▁ptr _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁ptr _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁ptr _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁pix _ op ▁[ ▁0 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁, ▁h ▁) ▁; ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁pix _ op ▁[ ▁s ▁-> ▁chroma _ x _ shift ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr _ cb ▁, ▁uv lines ize ▁, ▁h ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁pix _ op ▁[ ▁s ▁-> ▁chroma _ x _ shift ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr _ cr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁} ▁if ▁( ▁! ▁is _ mpeg 12 ▁&& ▁( ▁CONFIG _ H 26 1_ ENCODER ▁|| ▁CONFIG _ H 26 1_ DECODER ▁) ▁&& ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 26 1 ▁) ▁{ ▁ff _ h 26 1_ loop _ filter ▁( ▁s ▁) ▁; ▁} ▁}	0
▁static ▁av _ always _ inline ▁void ▁yuv 2 rgb _ full _2_ c _ template ▁( ▁S ws Context ▁* ▁c ▁, ▁const ▁int 16_ t ▁* ▁buf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁ubuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁vbuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁a buf ▁[ ▁2 ▁] ▁, ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁dst W ▁, ▁int ▁y alpha ▁, ▁int ▁u val pha ▁, ▁int ▁y ▁, ▁enum ▁AV PixelFormat ▁target ▁, ▁int ▁has Alpha ▁) ▁{ ▁const ▁int 16_ t ▁* ▁buf 0 ▁= ▁buf ▁[ ▁0 ▁] ▁, ▁* ▁buf 1 ▁= ▁buf ▁[ ▁1 ▁] ▁, ▁* ▁ubuf 0 ▁= ▁ubuf ▁[ ▁0 ▁] ▁, ▁* ▁ubuf 1 ▁= ▁ubuf ▁[ ▁1 ▁] ▁, ▁* ▁vbuf 0 ▁= ▁vbuf ▁[ ▁0 ▁] ▁, ▁* ▁vbuf 1 ▁= ▁vbuf ▁[ ▁1 ▁] ▁, ▁* ▁a buf 0 ▁= ▁has Alpha ▁? ▁a buf ▁[ ▁0 ▁] ▁: ▁NULL ▁, ▁* ▁a buf 1 ▁= ▁has Alpha ▁? ▁a buf ▁[ ▁1 ▁] ▁: ▁NULL ▁; ▁int ▁y alpha 1 ▁= ▁4096 ▁- ▁y alpha ▁; ▁int ▁u val pha 1 ▁= ▁4096 ▁- ▁u val pha ▁; ▁int ▁i ▁; ▁int ▁step ▁= ▁( ▁target ▁== ▁AV _ PIX _ FMT _ RGB 24 ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ BGR 24 ▁) ▁? ▁3 ▁: ▁4 ▁; ▁int ▁err ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁if ▁( ▁target ▁== ▁AV _ PIX _ FMT _ BGR 4_ BYTE ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ RGB 4_ BYTE ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ BGR 8 ▁|| ▁target ▁== ▁AV _ PIX _ FMT _ RGB 8 ▁) ▁step ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁; ▁i ▁++ ▁) ▁{ ▁int ▁Y ▁= ▁( ▁buf 0 ▁[ ▁i ▁] ▁* ▁y alpha 1 ▁+ ▁buf 1 ▁[ ▁i ▁] ▁* ▁y alpha ▁) ▁>> ▁10 ▁; ▁int ▁U ▁= ▁( ▁ubuf 0 ▁[ ▁i ▁] ▁* ▁u val pha 1 ▁+ ▁ubuf 1 ▁[ ▁i ▁] ▁* ▁u val pha ▁- ▁( ▁128 ▁<< ▁19 ▁) ▁) ▁>> ▁10 ▁; ▁int ▁V ▁= ▁( ▁vbuf 0 ▁[ ▁i ▁] ▁* ▁u val pha 1 ▁+ ▁vbuf 1 ▁[ ▁i ▁] ▁* ▁u val pha ▁- ▁( ▁128 ▁<< ▁19 ▁) ▁) ▁>> ▁10 ▁; ▁int ▁A ▁; ▁if ▁( ▁has Alpha ▁) ▁{ ▁A ▁= ▁( ▁a buf 0 ▁[ ▁i ▁] ▁* ▁y alpha 1 ▁+ ▁a buf 1 ▁[ ▁i ▁] ▁* ▁y alpha ▁+ ▁( ▁1 ▁<< ▁18 ▁) ▁) ▁>> ▁19 ▁; ▁if ▁( ▁A ▁& ▁0 x 100 ▁) ▁A ▁= ▁av _ clip _ uint 8 ▁( ▁A ▁) ▁; ▁} ▁yuv 2 rgb _ write _ full ▁( ▁c ▁, ▁dest ▁, ▁i ▁, ▁Y ▁, ▁A ▁, ▁U ▁, ▁V ▁, ▁y ▁, ▁target ▁, ▁has Alpha ▁, ▁err ▁) ▁; ▁dest ▁+= ▁step ▁; ▁} ▁c ▁-> ▁d ither _ error ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁0 ▁] ▁; ▁c ▁-> ▁d ither _ error ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁1 ▁] ▁; ▁c ▁-> ▁d ither _ error ▁[ ▁2 ▁] ▁[ ▁i ▁] ▁= ▁err ▁[ ▁2 ▁] ▁; ▁}	1
▁static ▁int ▁decode _ plane ▁( ▁In de o 3 Decode Context ▁* ▁ctx ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁Plane ▁* ▁plane ▁, ▁const ▁uint 8_ t ▁* ▁data ▁, ▁int 32_ t ▁data _ size ▁, ▁int 32_ t ▁strip _ width ▁) ▁{ ▁Cell ▁curr _ cell ▁; ▁int ▁num _ vectors ▁; ▁num _ vectors ▁= ▁bytestream _ get _ le 32 ▁( ▁& ▁data ▁) ▁; ▁ctx ▁-> ▁mc _ vectors ▁= ▁num _ vectors ▁? ▁data ▁: ▁0 ▁; ▁init _ get _ bits ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁& ▁data ▁[ ▁num _ vectors ▁* ▁2 ▁] ▁, ▁data _ size ▁<< ▁3 ▁) ▁; ▁ctx ▁-> ▁skip _ bits ▁= ▁0 ▁; ▁ctx ▁-> ▁need _ res ync ▁= ▁0 ▁; ▁ctx ▁-> ▁last _ byte ▁= ▁data ▁+ ▁data _ size ▁- ▁1 ▁; ▁curr _ cell ▁. ▁xpos ▁= ▁curr _ cell ▁. ▁ypos ▁= ▁0 ▁; ▁curr _ cell ▁. ▁width ▁= ▁plane ▁-> ▁width ▁>> ▁2 ▁; ▁curr _ cell ▁. ▁height ▁= ▁plane ▁-> ▁height ▁>> ▁2 ▁; ▁curr _ cell ▁. ▁tree ▁= ▁0 ▁; ▁curr _ cell ▁. ▁mv _ ptr ▁= ▁0 ▁; ▁return ▁parse _ b intree ▁( ▁ctx ▁, ▁avctx ▁, ▁plane ▁, ▁IN TRA _ NULL ▁, ▁& ▁curr _ cell ▁, ▁CELL _ STACK _ MAX ▁, ▁strip _ width ▁) ▁; ▁}	1
▁static ▁int ▁init _ file ▁( ▁AVFormatContext ▁* ▁s ▁, ▁OutputStream ▁* ▁os ▁, ▁int 64_ t ▁start _ ts ▁) ▁{ ▁int ▁ret ▁, ▁i ▁; ▁ret ▁= ▁s ▁-> ▁io _ open ▁( ▁s ▁, ▁& ▁os ▁-> ▁out ▁, ▁os ▁-> ▁temp _ filename ▁, ▁AVIO _ FLAG _ WRITE ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁avio _ wb 32 ▁( ▁os ▁-> ▁out ▁, ▁0 ▁) ▁; ▁avio _ wl 32 ▁( ▁os ▁-> ▁out ▁, ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁os ▁-> ▁nb _ extra _ packets ▁; ▁i ▁++ ▁) ▁{ ▁AV _ WB 24 ▁( ▁os ▁-> ▁extra _ packets ▁[ ▁i ▁] ▁+ ▁4 ▁, ▁start _ ts ▁) ▁; ▁os ▁-> ▁extra _ packets ▁[ ▁i ▁] ▁[ ▁7 ▁] ▁= ▁( ▁start _ ts ▁>> ▁24 ▁) ▁& ▁0 x 7 f ▁; ▁avio _ write ▁( ▁os ▁-> ▁out ▁, ▁os ▁-> ▁extra _ packets ▁[ ▁i ▁] ▁, ▁os ▁-> ▁extra _ packet _ sizes ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁BN _ div _ re cp ▁( ▁BIGNUM ▁* ▁dv ▁, ▁BIGNUM ▁* ▁rem ▁, ▁const ▁BIGNUM ▁* ▁m ▁, ▁BN _ RE CP _ CTX ▁* ▁recp ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁ret ▁= ▁0 ▁; ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁, ▁* ▁d ▁, ▁* ▁r ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁a ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁b ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁dv ▁!= ▁NULL ▁) ▁d ▁= ▁dv ▁; ▁else ▁d ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁rem ▁!= ▁NULL ▁) ▁r ▁= ▁rem ▁; ▁else ▁r ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁a ▁== ▁NULL ▁|| ▁b ▁== ▁NULL ▁|| ▁d ▁== ▁NULL ▁|| ▁r ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ ucmp ▁( ▁m ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁) ▁< ▁0 ▁) ▁{ ▁BN _ zero ▁( ▁d ▁) ▁; ▁if ▁( ▁! ▁BN _ copy ▁( ▁r ▁, ▁m ▁) ▁) ▁{ ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁0 ▁; ▁} ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁} ▁i ▁= ▁BN _ num _ bits ▁( ▁m ▁) ▁; ▁j ▁= ▁recp ▁-> ▁num _ bits ▁<< ▁1 ▁; ▁if ▁( ▁j ▁> ▁i ▁) ▁i ▁= ▁j ▁; ▁if ▁( ▁i ▁!= ▁recp ▁-> ▁shift ▁) ▁recp ▁-> ▁shift ▁= ▁BN _ rec ip rocal ▁( ▁& ▁( ▁recp ▁-> ▁N r ▁) ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁, ▁i ▁, ▁ctx ▁) ▁; ▁if ▁( ▁recp ▁-> ▁shift ▁== ▁-1 ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ rshift ▁( ▁a ▁, ▁m ▁, ▁recp ▁-> ▁num _ bits ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ mul ▁( ▁b ▁, ▁a ▁, ▁& ▁( ▁recp ▁-> ▁N r ▁) ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ rshift ▁( ▁d ▁, ▁b ▁, ▁i ▁- ▁recp ▁-> ▁num _ bits ▁) ▁) ▁goto ▁err ▁; ▁d ▁-> ▁neg ▁= ▁0 ▁; ▁if ▁( ▁! ▁BN _ mul ▁( ▁b ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁, ▁d ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ us ub ▁( ▁r ▁, ▁m ▁, ▁b ▁) ▁) ▁goto ▁err ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁j ▁= ▁0 ▁; ▁while ▁( ▁BN _ ucmp ▁( ▁r ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁) ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁j ▁++ ▁> ▁2 ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ DIV _ RE CP ▁, ▁BN _ R _ BAD _ REC IP RO CAL ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ us ub ▁( ▁r ▁, ▁r ▁, ▁& ▁( ▁recp ▁-> ▁N ▁) ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ add _ word ▁( ▁d ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁} ▁r ▁-> ▁neg ▁= ▁BN _ is _ zero ▁( ▁r ▁) ▁? ▁0 ▁: ▁m ▁-> ▁neg ▁; ▁d ▁-> ▁neg ▁= ▁m ▁-> ▁neg ▁ ^ ▁recp ▁-> ▁N ▁. ▁neg ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁bn _ check _ top ▁( ▁dv ▁) ▁; ▁bn _ check _ top ▁( ▁rem ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁static ▁int ▁activate ▁( ▁AVFilter Context ▁* ▁ctx ▁) ▁{ ▁AVFilter Link ▁* ▁out link ▁= ▁ctx ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁Mix Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFrame ▁* ▁buf ▁= ▁NULL ▁; ▁int ▁i ▁, ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ inputs ▁; ▁i ▁++ ▁) ▁{ ▁AVFilter Link ▁* ▁inlink ▁= ▁ctx ▁-> ▁inputs ▁[ ▁i ▁] ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ in link _ consume _ frame ▁( ▁ctx ▁-> ▁inputs ▁[ ▁i ▁] ▁, ▁& ▁buf ▁) ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁int 64_ t ▁pts ▁= ▁av _ re scale _ q ▁( ▁buf ▁-> ▁pts ▁, ▁inlink ▁-> ▁time _ base ▁, ▁out link ▁-> ▁time _ base ▁) ▁; ▁ret ▁= ▁frame _ list _ add _ frame ▁( ▁s ▁-> ▁frame _ list ▁, ▁buf ▁-> ▁nb _ samples ▁, ▁pts ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ frame _ free ▁( ▁& ▁buf ▁) ▁; ▁return ▁ret ▁; ▁} ▁} ▁ret ▁= ▁av _ audio _ fifo _ write ▁( ▁s ▁-> ▁f ifos ▁[ ▁i ▁] ▁, ▁( ▁void ▁* ▁* ▁) ▁buf ▁-> ▁extended _ data ▁, ▁buf ▁-> ▁nb _ samples ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ frame _ free ▁( ▁& ▁buf ▁) ▁; ▁return ▁ret ▁; ▁} ▁av _ frame _ free ▁( ▁& ▁buf ▁) ▁; ▁ret ▁= ▁output _ frame ▁( ▁out link ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ inputs ▁; ▁i ▁++ ▁) ▁{ ▁int 64_ t ▁pts ▁; ▁int ▁status ▁; ▁if ▁( ▁ff _ in link _ ack nowledge _ status ▁( ▁ctx ▁-> ▁inputs ▁[ ▁i ▁] ▁, ▁& ▁status ▁, ▁& ▁pts ▁) ▁) ▁{ ▁if ▁( ▁status ▁== ▁AVERROR _ EOF ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁s ▁-> ▁input _ state ▁[ ▁i ▁] ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁nb _ inputs ▁== ▁1 ▁) ▁{ ▁ff _ out link _ set _ status ▁( ▁out link ▁, ▁status ▁, ▁pts ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁else ▁{ ▁s ▁-> ▁input _ state ▁[ ▁i ▁] ▁|= ▁INPUT _ EOF ▁; ▁if ▁( ▁av _ audio _ fifo _ size ▁( ▁s ▁-> ▁f ifos ▁[ ▁i ▁] ▁) ▁== ▁0 ▁) ▁{ ▁s ▁-> ▁input _ state ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁} ▁} ▁} ▁} ▁if ▁( ▁calc _ active _ inputs ▁( ▁s ▁) ▁) ▁{ ▁ff _ out link _ set _ status ▁( ▁out link ▁, ▁AVERROR _ EOF ▁, ▁s ▁-> ▁next _ pts ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁ff _ out link _ frame _ w anted ▁( ▁out link ▁) ▁) ▁{ ▁int ▁wanted _ samples ▁; ▁if ▁( ▁! ▁( ▁s ▁-> ▁input _ state ▁[ ▁0 ▁] ▁& ▁INPUT _ ON ▁) ▁) ▁return ▁request _ samples ▁( ▁ctx ▁, ▁1 ▁) ▁; ▁if ▁( ▁s ▁-> ▁frame _ list ▁-> ▁nb _ frames ▁== ▁0 ▁) ▁{ ▁ff _ in link _ request _ frame ▁( ▁ctx ▁-> ▁inputs ▁[ ▁0 ▁] ▁) ▁; ▁return ▁0 ▁; ▁} ▁av _ assert 0 ▁( ▁s ▁-> ▁frame _ list ▁-> ▁nb _ frames ▁> ▁0 ▁) ▁; ▁wanted _ samples ▁= ▁frame _ list _ next _ frame _ size ▁( ▁s ▁-> ▁frame _ list ▁) ▁; ▁return ▁request _ samples ▁( ▁ctx ▁, ▁wanted _ samples ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁inline ▁double ▁bits 2 qp ▁( ▁Rate Control Entry ▁* ▁r ce ▁, ▁double ▁bits ▁) ▁{ ▁if ▁( ▁bits ▁< ▁0.9 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" bits < 0. 9\ n " ▁) ▁; ▁} ▁return ▁r ce ▁-> ▁q scale ▁* ▁( ▁double ▁) ▁( ▁r ce ▁-> ▁i _ tex _ bits ▁+ ▁r ce ▁-> ▁p _ tex _ bits ▁+ ▁1 ▁) ▁/ ▁bits ▁; ▁}	1
▁static ▁int ▁t ta _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁T TA Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁i ▁; ▁init _ get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁buf ▁, ▁buf _ size ▁* ▁8 ▁) ▁; ▁{ ▁int ▁cur _ chan ▁= ▁0 ▁, ▁frame len ▁= ▁s ▁-> ▁frame _ length ▁; ▁int 32_ t ▁* ▁p ▁; ▁s ▁-> ▁total _ frames ▁-- ▁; ▁if ▁( ▁! ▁s ▁-> ▁total _ frames ▁&& ▁s ▁-> ▁last _ frame _ length ▁) ▁frame len ▁= ▁s ▁-> ▁last _ frame _ length ▁; ▁if ▁( ▁* ▁data _ size ▁< ▁( ▁frame len ▁* ▁s ▁-> ▁channels ▁* ▁2 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Output buffers ize ist oo small .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁channels ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁ch _ ctx ▁[ ▁i ▁] ▁. ▁predictor ▁= ▁0 ▁; ▁tt af ilter _ init ▁( ▁& ▁s ▁-> ▁ch _ ctx ▁[ ▁i ▁] ▁. ▁filter ▁, ▁tt af ilter _ configs ▁[ ▁s ▁-> ▁bps ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁tt af ilter _ configs ▁[ ▁s ▁-> ▁bps ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁r ice _ init ▁( ▁& ▁s ▁-> ▁ch _ ctx ▁[ ▁i ▁] ▁. ▁r ice ▁, ▁10 ▁, ▁10 ▁) ▁; ▁} ▁for ▁( ▁p ▁= ▁s ▁-> ▁decode _ buffer ▁; ▁p ▁< ▁s ▁-> ▁decode _ buffer ▁+ ▁( ▁frame len ▁* ▁s ▁-> ▁channels ▁) ▁; ▁p ▁++ ▁) ▁{ ▁int 32_ t ▁* ▁predictor ▁= ▁& ▁s ▁-> ▁ch _ ctx ▁[ ▁cur _ chan ▁] ▁. ▁predictor ▁; ▁T TA Filter ▁* ▁filter ▁= ▁& ▁s ▁-> ▁ch _ ctx ▁[ ▁cur _ chan ▁] ▁. ▁filter ▁; ▁TT AR ice ▁* ▁r ice ▁= ▁& ▁s ▁-> ▁ch _ ctx ▁[ ▁cur _ chan ▁] ▁. ▁r ice ▁; ▁uint 32_ t ▁unary ▁, ▁depth ▁, ▁k ▁; ▁int 32_ t ▁value ▁; ▁unary ▁= ▁t ta _ get _ unary ▁( ▁& ▁s ▁-> ▁gb ▁) ▁; ▁if ▁( ▁unary ▁== ▁0 ▁) ▁{ ▁depth ▁= ▁0 ▁; ▁k ▁= ▁r ice ▁-> ▁k 0 ▁; ▁} ▁else ▁{ ▁depth ▁= ▁1 ▁; ▁k ▁= ▁r ice ▁-> ▁k 1 ▁; ▁unary ▁-- ▁; ▁} ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁k ▁) ▁return ▁-1 ▁; ▁if ▁( ▁k ▁) ▁{ ▁if ▁( ▁k ▁> ▁MIN _ CACHE _ BITS ▁) ▁return ▁-1 ▁; ▁value ▁= ▁( ▁unary ▁<< ▁k ▁) ▁+ ▁get _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁k ▁) ▁; ▁} ▁else ▁value ▁= ▁unary ▁; ▁switch ▁( ▁depth ▁) ▁{ ▁case ▁1 ▁: ▁r ice ▁-> ▁sum 1 ▁+= ▁value ▁- ▁( ▁r ice ▁-> ▁sum 1 ▁>> ▁4 ▁) ▁; ▁if ▁( ▁r ice ▁-> ▁k 1 ▁> ▁0 ▁&& ▁r ice ▁-> ▁sum 1 ▁< ▁shift _16 ▁[ ▁r ice ▁-> ▁k 1 ▁] ▁) ▁r ice ▁-> ▁k 1 ▁-- ▁; ▁else ▁if ▁( ▁r ice ▁-> ▁sum 1 ▁> ▁shift _16 ▁[ ▁r ice ▁-> ▁k 1 ▁+ ▁1 ▁] ▁) ▁r ice ▁-> ▁k 1 ▁++ ▁; ▁value ▁+= ▁shift _1 ▁[ ▁r ice ▁-> ▁k 0 ▁] ▁; ▁default ▁: ▁r ice ▁-> ▁sum 0 ▁+= ▁value ▁- ▁( ▁r ice ▁-> ▁sum 0 ▁>> ▁4 ▁) ▁; ▁if ▁( ▁r ice ▁-> ▁k 0 ▁> ▁0 ▁&& ▁r ice ▁-> ▁sum 0 ▁< ▁shift _16 ▁[ ▁r ice ▁-> ▁k 0 ▁] ▁) ▁r ice ▁-> ▁k 0 ▁-- ▁; ▁else ▁if ▁( ▁r ice ▁-> ▁sum 0 ▁> ▁shift _16 ▁[ ▁r ice ▁-> ▁k 0 ▁+ ▁1 ▁] ▁) ▁r ice ▁-> ▁k 0 ▁++ ▁; ▁} ▁# define ▁UN F OLD ▁( ▁x ▁) ▁((( x )& 1) ? ( ++ ( x ) >> 1 ): (- ( x ) >> 1 )) ▁* ▁p ▁= ▁UN F OLD ▁( ▁value ▁) ▁; ▁tt af ilter _ process ▁( ▁filter ▁, ▁p ▁, ▁0 ▁) ▁; ▁# define ▁PRED ▁( ▁x ▁, ▁k ▁) ▁( int 32_ t )(( (( uint 64_ t ) x << k )- x ) >> k ) ▁switch ▁( ▁s ▁-> ▁bps ▁) ▁{ ▁case ▁1 ▁: ▁* ▁p ▁+= ▁PRED ▁( ▁* ▁predictor ▁, ▁4 ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁case ▁3 ▁: ▁* ▁p ▁+= ▁PRED ▁( ▁* ▁predictor ▁, ▁5 ▁) ▁; ▁break ▁; ▁case ▁4 ▁: ▁* ▁p ▁+= ▁* ▁predictor ▁; ▁break ▁; ▁} ▁* ▁predictor ▁= ▁* ▁p ▁; ▁if ▁( ▁cur _ chan ▁< ▁( ▁s ▁-> ▁channels ▁- ▁1 ▁) ▁) ▁cur _ chan ▁++ ▁; ▁else ▁{ ▁if ▁( ▁s ▁-> ▁channels ▁> ▁1 ▁) ▁{ ▁int 32_ t ▁* ▁r ▁= ▁p ▁- ▁1 ▁; ▁for ▁( ▁* ▁p ▁+= ▁* ▁r ▁/ ▁2 ▁; ▁r ▁> ▁p ▁- ▁s ▁-> ▁channels ▁; ▁r ▁-- ▁) ▁* ▁r ▁= ▁* ▁( ▁r ▁+ ▁1 ▁) ▁- ▁* ▁r ▁; ▁} ▁cur _ chan ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁get _ bits _ left ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁32 ▁) ▁return ▁-1 ▁; ▁skip _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁32 ▁) ▁; ▁switch ▁( ▁s ▁-> ▁bps ▁) ▁{ ▁case ▁2 ▁: ▁{ ▁uint 16_ t ▁* ▁samples ▁= ▁data ▁; ▁for ▁( ▁p ▁= ▁s ▁-> ▁decode _ buffer ▁; ▁p ▁< ▁s ▁-> ▁decode _ buffer ▁+ ▁( ▁frame len ▁* ▁s ▁-> ▁channels ▁) ▁; ▁p ▁++ ▁) ▁{ ▁* ▁samples ▁++ ▁= ▁* ▁p ▁; ▁} ▁* ▁data _ size ▁= ▁( ▁uint 8_ t ▁* ▁) ▁samples ▁- ▁( ▁uint 8_ t ▁* ▁) ▁data ▁; ▁break ▁; ▁} ▁default ▁: ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error , only 16 bits ample ss upported !\ n " ▁) ▁; ▁} ▁} ▁return ▁buf _ size ▁; ▁}	0
▁static ▁uint 64_ t ▁sse _ line _8 bit ▁( ▁const ▁uint 8_ t ▁* ▁main _ line ▁, ▁const ▁uint 8_ t ▁* ▁ref _ line ▁, ▁int ▁outw ▁) ▁{ ▁int ▁j ▁; ▁unsigned ▁m 2 ▁= ▁0 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁outw ▁; ▁j ▁++ ▁) ▁m 2 ▁+= ▁pow 2 ▁( ▁main _ line ▁[ ▁j ▁] ▁- ▁ref _ line ▁[ ▁j ▁] ▁) ▁; ▁return ▁m 2 ▁; ▁}	0
▁static ▁int ▁v 210_ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁int ▁ret ▁; ▁ret ▁= ▁av _ get _ packet ▁( ▁s ▁-> ▁pb ▁, ▁pkt ▁, ▁s ▁-> ▁packet _ size ▁) ▁; ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁dts ▁= ▁pkt ▁-> ▁pos ▁/ ▁s ▁-> ▁packet _ size ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁0 ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁jpeg 2000_ read _ main _ headers ▁( ▁J peg 2000 Decoder Context ▁* ▁s ▁) ▁{ ▁J peg 2000 Coding Style ▁* ▁co dst y ▁= ▁s ▁-> ▁co dst y ▁; ▁J peg 2000 Quant Style ▁* ▁q nt st y ▁= ▁s ▁-> ▁q nt st y ▁; ▁uint 8_ t ▁* ▁properties ▁= ▁s ▁-> ▁properties ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁int ▁len ▁, ▁ret ▁= ▁0 ▁; ▁uint 16_ t ▁marker ▁; ▁int ▁old pos ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁g ▁) ▁< ▁2 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Missing EO C \ n " ▁) ▁; ▁break ▁; ▁} ▁marker ▁= ▁bytestream 2_ get _ be 16 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁old pos ▁= ▁bytestream 2_ tell ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁if ▁( ▁marker ▁== ▁JPEG 2000_ EO C ▁) ▁break ▁; ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁s ▁-> ▁g ▁) ▁< ▁2 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁len ▁= ▁bytestream 2_ get _ be 16 u ▁( ▁& ▁s ▁-> ▁g ▁) ▁; ▁switch ▁( ▁marker ▁) ▁{ ▁case ▁JPEG 2000_ SIZ ▁: ▁ret ▁= ▁get _ s iz ▁( ▁s ▁) ▁; ▁break ▁; ▁case ▁JPEG 2000_ CO C ▁: ▁ret ▁= ▁get _ co c ▁( ▁s ▁, ▁co dst y ▁, ▁properties ▁) ▁; ▁break ▁; ▁case ▁JPEG 2000_ COD ▁: ▁ret ▁= ▁get _ cod ▁( ▁s ▁, ▁co dst y ▁, ▁properties ▁) ▁; ▁break ▁; ▁case ▁JPEG 2000_ Q CC ▁: ▁ret ▁= ▁get _ q cc ▁( ▁s ▁, ▁len ▁, ▁q nt st y ▁, ▁properties ▁) ▁; ▁break ▁; ▁case ▁JPEG 2000_ Q CD ▁: ▁ret ▁= ▁get _ q cd ▁( ▁s ▁, ▁len ▁, ▁q nt st y ▁, ▁properties ▁) ▁; ▁break ▁; ▁case ▁JPEG 2000_ SO T ▁: ▁ret ▁= ▁get _ s ot ▁( ▁s ▁, ▁len ▁) ▁; ▁break ▁; ▁case ▁JPEG 2000_ COM ▁: ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁g ▁, ▁len ▁- ▁2 ▁) ▁; ▁break ▁; ▁case ▁JPEG 2000_ TL M ▁: ▁ret ▁= ▁get _ tlm ▁( ▁s ▁, ▁len ▁) ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" unsupported marker 0 x % .4 X at pos 0 x % t X \ n " ▁, ▁marker ▁, ▁bytestream 2_ tell ▁( ▁& ▁s ▁-> ▁g ▁) ▁- ▁4 ▁) ▁; ▁bytestream 2_ skip ▁( ▁& ▁s ▁-> ▁g ▁, ▁len ▁- ▁2 ▁) ▁; ▁break ▁; ▁} ▁if ▁( ▁( ▁( ▁bytestream 2_ tell ▁( ▁& ▁s ▁-> ▁g ▁) ▁- ▁old pos ▁!= ▁len ▁) ▁&& ▁( ▁marker ▁!= ▁JPEG 2000_ SO T ▁) ▁) ▁|| ▁ret ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" err ord uring processing marker segment % .4 x \ n " ▁, ▁marker ▁) ▁; ▁return ▁ret ▁? ▁ret ▁: ▁-1 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁void ▁ngx _ str low ▁( ▁u _ char ▁* ▁dst ▁, ▁u _ char ▁* ▁src ▁, ▁size _ t ▁n ▁) ▁{ ▁while ▁( ▁n ▁-- ▁) ▁{ ▁* ▁dst ▁= ▁ngx _ tolower ▁( ▁* ▁src ▁) ▁; ▁dst ▁++ ▁; ▁src ▁++ ▁; ▁} ▁}	1
▁SSL ▁* ▁SSL _ new ▁( ▁SSL _ CTX ▁* ▁ctx ▁) ▁{ ▁SSL ▁* ▁s ▁; ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ NEW ▁, ▁SSL _ R _ NULL _ SSL _ CTX ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁method ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ NEW ▁, ▁SSL _ R _ SSL _ CTX _ HAS _ NO _ DEFAULT _ SSL _ VERSION ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁s ▁= ▁( ▁SSL ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁SSL ▁) ▁) ▁; ▁if ▁( ▁s ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁memset ▁( ▁s ▁, ▁0 ▁, ▁sizeof ▁( ▁SSL ▁) ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ KRB 5 ▁s ▁-> ▁k ssl _ ctx ▁= ▁k ssl _ ctx _ new ▁( ▁) ▁; ▁# endif ▁if ▁( ▁ctx ▁-> ▁cert ▁!= ▁NULL ▁) ▁{ ▁s ▁-> ▁cert ▁= ▁ssl _ cert _ dup ▁( ▁ctx ▁-> ▁cert ▁) ▁; ▁if ▁( ▁s ▁-> ▁cert ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁else ▁s ▁-> ▁cert ▁= ▁NULL ▁; ▁s ▁-> ▁sid _ ctx _ length ▁= ▁ctx ▁-> ▁sid _ ctx _ length ▁; ▁memcpy ▁( ▁& ▁s ▁-> ▁sid _ ctx ▁, ▁& ▁ctx ▁-> ▁sid _ ctx ▁, ▁sizeof ▁( ▁s ▁-> ▁sid _ ctx ▁) ▁) ▁; ▁s ▁-> ▁verify _ mode ▁= ▁ctx ▁-> ▁verify _ mode ▁; ▁s ▁-> ▁verify _ depth ▁= ▁ctx ▁-> ▁verify _ depth ▁; ▁s ▁-> ▁verify _ callback ▁= ▁ctx ▁-> ▁default _ verify _ callback ▁; ▁s ▁-> ▁generate _ session _ id ▁= ▁ctx ▁-> ▁generate _ session _ id ▁; ▁s ▁-> ▁purpose ▁= ▁ctx ▁-> ▁purpose ▁; ▁s ▁-> ▁trust ▁= ▁ctx ▁-> ▁trust ▁; ▁CRYPTO _ add ▁( ▁& ▁ctx ▁-> ▁references ▁, ▁1 ▁, ▁CRYPTO _ LOCK _ SSL _ CTX ▁) ▁; ▁s ▁-> ▁ctx ▁= ▁ctx ▁; ▁s ▁-> ▁verify _ result ▁= ▁X 509_ V _ OK ▁; ▁s ▁-> ▁method ▁= ▁ctx ▁-> ▁method ▁; ▁if ▁( ▁! ▁s ▁-> ▁method ▁-> ▁ssl _ new ▁( ▁s ▁) ▁) ▁goto ▁err ▁; ▁s ▁-> ▁quiet _ shutdown ▁= ▁ctx ▁-> ▁quiet _ shutdown ▁; ▁s ▁-> ▁references ▁= ▁1 ▁; ▁s ▁-> ▁server ▁= ▁( ▁ctx ▁-> ▁method ▁-> ▁ssl _ accept ▁== ▁ssl _ undefined _ function ▁) ▁? ▁0 ▁: ▁1 ▁; ▁s ▁-> ▁options ▁= ▁ctx ▁-> ▁options ▁; ▁s ▁-> ▁mode ▁= ▁ctx ▁-> ▁mode ▁; ▁s ▁-> ▁max _ cert _ list ▁= ▁ctx ▁-> ▁max _ cert _ list ▁; ▁s ▁-> ▁read _ ahead ▁= ▁ctx ▁-> ▁read _ ahead ▁; ▁SSL _ clear ▁( ▁s ▁) ▁; ▁CRYPTO _ new _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL ▁, ▁s ▁, ▁& ▁s ▁-> ▁ex _ data ▁) ▁; ▁return ▁( ▁s ▁) ▁; ▁err ▁: ▁if ▁( ▁s ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁s ▁-> ▁cert ▁!= ▁NULL ▁) ▁ssl _ cert _ free ▁( ▁s ▁-> ▁cert ▁) ▁; ▁if ▁( ▁s ▁-> ▁ctx ▁!= ▁NULL ▁) ▁SSL _ CTX _ free ▁( ▁s ▁-> ▁ctx ▁) ▁; ▁OPENSSL _ free ▁( ▁s ▁) ▁; ▁} ▁SSL err ▁( ▁SSL _ F _ SSL _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	0
▁static ▁av _ always _ inline ▁void ▁filter _ mb _ row ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁t data ▁, ▁int ▁job nr ▁, ▁int ▁thread nr ▁, ▁int ▁is _ vp 7 ▁) ▁{ ▁VP 8 Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁VP 8 Thread Data ▁* ▁td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁thread nr ▁] ▁; ▁int ▁mb _ x ▁, ▁mb _ y ▁= ▁td ▁-> ▁thread _ mb _ pos ▁>> ▁16 ▁, ▁num _ jobs ▁= ▁s ▁-> ▁num _ jobs ▁; ▁AVFrame ▁* ▁cur frame ▁= ▁s ▁-> ▁cur frame ▁-> ▁tf ▁. ▁f ▁; ▁VP 8 Macro block ▁* ▁mb ▁; ▁VP 8 Thread Data ▁* ▁prev _ td ▁, ▁* ▁next _ td ▁; ▁uint 8_ t ▁* ▁dst ▁[ ▁3 ▁] ▁= ▁{ ▁cur frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁16 ▁* ▁mb _ y ▁* ▁s ▁-> ▁linesize ▁, ▁cur frame ▁-> ▁data ▁[ ▁1 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁, ▁cur frame ▁-> ▁data ▁[ ▁2 ▁] ▁+ ▁8 ▁* ▁mb _ y ▁* ▁s ▁-> ▁uv lines ize ▁} ▁; ▁if ▁( ▁s ▁-> ▁mb _ layout ▁== ▁1 ▁) ▁mb ▁= ▁s ▁-> ▁macro blocks _ base ▁+ ▁( ▁( ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁* ▁( ▁mb _ y ▁+ ▁1 ▁) ▁+ ▁1 ▁) ▁; ▁else ▁mb ▁= ▁s ▁-> ▁macro blocks ▁+ ▁( ▁s ▁-> ▁mb _ height ▁- ▁mb _ y ▁- ▁1 ▁) ▁* ▁2 ▁; ▁if ▁( ▁mb _ y ▁== ▁0 ▁) ▁prev _ td ▁= ▁td ▁; ▁else ▁prev _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁num _ jobs ▁- ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁if ▁( ▁mb _ y ▁== ▁s ▁-> ▁mb _ height ▁- ▁1 ▁) ▁next _ td ▁= ▁td ▁; ▁else ▁next _ td ▁= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁( ▁job nr ▁+ ▁1 ▁) ▁% ▁num _ jobs ▁] ▁; ▁for ▁( ▁mb _ x ▁= ▁0 ▁; ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁mb _ x ▁++ ▁, ▁mb ▁++ ▁) ▁{ ▁VP 8 Filter Strength ▁* ▁f ▁= ▁& ▁td ▁-> ▁filter _ strength ▁[ ▁mb _ x ▁] ▁; ▁if ▁( ▁prev _ td ▁!= ▁td ▁) ▁check _ thread _ pos ▁( ▁td ▁, ▁prev _ td ▁, ▁( ▁mb _ x ▁+ ▁1 ▁) ▁+ ▁( ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁) ▁, ▁mb _ y ▁- ▁1 ▁) ▁; ▁if ▁( ▁next _ td ▁!= ▁td ▁) ▁if ▁( ▁next _ td ▁!= ▁& ▁s ▁-> ▁thread _ data ▁[ ▁0 ▁] ▁) ▁check _ thread _ pos ▁( ▁td ▁, ▁next _ td ▁, ▁mb _ x ▁+ ▁1 ▁, ▁mb _ y ▁+ ▁1 ▁) ▁; ▁if ▁( ▁num _ jobs ▁== ▁1 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁filter ▁. ▁simple ▁) ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁NULL ▁, ▁NULL ▁, ▁s ▁-> ▁linesize ▁, ▁0 ▁, ▁1 ▁) ▁; ▁else ▁backup _ mb _ border ▁( ▁s ▁-> ▁top _ border ▁[ ▁mb _ x ▁+ ▁1 ▁] ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁dst ▁[ ▁1 ▁] ▁, ▁dst ▁[ ▁2 ▁] ▁, ▁s ▁-> ▁linesize ▁, ▁s ▁-> ▁uv lines ize ▁, ▁0 ▁) ▁; ▁} ▁if ▁( ▁s ▁-> ▁filter ▁. ▁simple ▁) ▁filter _ mb _ simple ▁( ▁s ▁, ▁dst ▁[ ▁0 ▁] ▁, ▁f ▁, ▁mb _ x ▁, ▁mb _ y ▁) ▁; ▁else ▁filter _ mb ▁( ▁s ▁, ▁dst ▁, ▁f ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁is _ vp 7 ▁) ▁; ▁dst ▁[ ▁0 ▁] ▁+= ▁16 ▁; ▁dst ▁[ ▁1 ▁] ▁+= ▁8 ▁; ▁dst ▁[ ▁2 ▁] ▁+= ▁8 ▁; ▁update _ pos ▁( ▁td ▁, ▁mb _ y ▁, ▁( ▁s ▁-> ▁mb _ width ▁+ ▁3 ▁) ▁+ ▁mb _ x ▁) ▁; ▁} ▁}	1
▁double ▁s ws _ dc Vec ▁( ▁S ws Vector ▁* ▁a ▁) ▁{ ▁int ▁i ▁; ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁-> ▁length ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁-> ▁coeff ▁[ ▁i ▁] ▁; ▁return ▁sum ▁; ▁}	1
▁static ▁int ▁decode _ tag ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁N elly M oser Decode Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁blocks ▁, ▁i ▁, ▁block _ size ▁; ▁int 16_ t ▁* ▁samples ▁; ▁samples ▁= ▁( ▁int 16_ t ▁* ▁) ▁data ▁; ▁if ▁( ▁buf _ size ▁< ▁avctx ▁-> ▁block _ align ▁) ▁{ ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁buf _ size ▁; ▁} ▁if ▁( ▁buf _ size ▁% ▁64 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Tag size % d .\ n " ▁, ▁buf _ size ▁) ▁; ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁buf _ size ▁; ▁} ▁block _ size ▁= ▁N EL LY _ SAMPLES ▁* ▁av _ get _ bytes _ per _ sample ▁( ▁avctx ▁-> ▁sample _ fmt ▁) ▁; ▁blocks ▁= ▁FF MIN ▁( ▁buf _ size ▁/ ▁64 ▁, ▁* ▁data _ size ▁/ ▁block _ size ▁) ▁; ▁if ▁( ▁blocks ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Output buffer ist oo small \ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁blocks ▁; ▁i ▁++ ▁) ▁{ ▁n elly _ decode _ block ▁( ▁s ▁, ▁& ▁buf ▁[ ▁i ▁* ▁N EL LY _ BLOCK _ LEN ▁] ▁, ▁s ▁-> ▁float _ buf ▁) ▁; ▁s ▁-> ▁fmt _ conv ▁. ▁float _ to _ int 16 ▁( ▁& ▁samples ▁[ ▁i ▁* ▁N EL LY _ SAMPLES ▁] ▁, ▁s ▁-> ▁float _ buf ▁, ▁N EL LY _ SAMPLES ▁) ▁; ▁} ▁* ▁data _ size ▁= ▁blocks ▁* ▁block _ size ▁; ▁return ▁buf _ size ▁; ▁}	0
▁static ▁BIGNUM ▁* ▁sr p _ Calc _ k ▁( ▁const ▁BIGNUM ▁* ▁N ▁, ▁const ▁BIGNUM ▁* ▁g ▁) ▁{ ▁unsigned ▁char ▁digest ▁[ ▁SHA _ DIGEST _ LENGTH ▁] ▁; ▁unsigned ▁char ▁* ▁tmp ▁= ▁NULL ▁; ▁EVP _ MD _ CTX ▁* ▁ctxt ▁= ▁NULL ▁; ▁int ▁long g ▁; ▁int ▁long N ▁= ▁BN _ num _ bytes ▁( ▁N ▁) ▁; ▁BIGNUM ▁* ▁res ▁= ▁NULL ▁; ▁if ▁( ▁BN _ ucmp ▁( ▁g ▁, ▁N ▁) ▁>= ▁0 ▁) ▁return ▁NULL ▁; ▁ctxt ▁= ▁EVP _ MD _ CTX _ new ▁( ▁) ▁; ▁if ▁( ▁ctxt ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁( ▁tmp ▁= ▁OPENSSL _ malloc ▁( ▁long N ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁BN _ bn 2 bin ▁( ▁N ▁, ▁tmp ▁) ▁; ▁if ▁( ▁! ▁EVP _ Digest Init _ ex ▁( ▁ctxt ▁, ▁EVP _ sha 1 ▁( ▁) ▁, ▁NULL ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁ctxt ▁, ▁tmp ▁, ▁long N ▁) ▁) ▁goto ▁err ▁; ▁memset ▁( ▁tmp ▁, ▁0 ▁, ▁long N ▁) ▁; ▁long g ▁= ▁BN _ bn 2 bin ▁( ▁g ▁, ▁tmp ▁) ▁; ▁if ▁( ▁! ▁EVP _ DigestUpdate ▁( ▁ctxt ▁, ▁tmp ▁+ ▁long g ▁, ▁long N ▁- ▁long g ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁ctxt ▁, ▁tmp ▁, ▁long g ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁EVP _ Digest Final _ ex ▁( ▁ctxt ▁, ▁digest ▁, ▁NULL ▁) ▁) ▁goto ▁err ▁; ▁res ▁= ▁BN _ bin 2 bn ▁( ▁digest ▁, ▁sizeof ▁( ▁digest ▁) ▁, ▁NULL ▁) ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁tmp ▁) ▁; ▁EVP _ MD _ CTX _ free ▁( ▁ctxt ▁) ▁; ▁return ▁res ▁; ▁}	1
▁int ▁av _ samples _ set _ sil ence ▁( ▁uint 8_ t ▁* ▁* ▁audio _ data ▁, ▁int ▁offset ▁, ▁int ▁nb _ samples ▁, ▁int ▁nb _ channels ▁, ▁enum ▁AV Sample Format ▁sample _ fmt ▁) ▁{ ▁int ▁plan ar ▁= ▁av _ sample _ fmt _ is _ planar ▁( ▁sample _ fmt ▁) ▁; ▁int ▁planes ▁= ▁plan ar ▁? ▁nb _ channels ▁: ▁1 ▁; ▁int ▁block _ align ▁= ▁av _ get _ bytes _ per _ sample ▁( ▁sample _ fmt ▁) ▁* ▁( ▁plan ar ▁? ▁1 ▁: ▁nb _ channels ▁) ▁; ▁int ▁data _ size ▁= ▁nb _ samples ▁* ▁block _ align ▁; ▁int ▁fill _ char ▁= ▁( ▁sample _ fmt ▁== ▁AV _ SAMPLE _ FMT _ U 8 ▁|| ▁sample _ fmt ▁== ▁AV _ SAMPLE _ FMT _ U 8 P ▁) ▁? ▁0 x 80 ▁: ▁0 x 00 ▁; ▁int ▁i ▁; ▁offset ▁*= ▁block _ align ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁planes ▁; ▁i ▁++ ▁) ▁memset ▁( ▁audio _ data ▁[ ▁i ▁] ▁+ ▁offset ▁, ▁fill _ char ▁, ▁data _ size ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁dvb sub _ parse _ region _ segment ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁DVB Sub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁uint 8_ t ▁* ▁buf _ end ▁= ▁buf ▁+ ▁buf _ size ▁; ▁int ▁region _ id ▁, ▁object _ id ▁; ▁int ▁av _ unused ▁version ▁; ▁DVB Sub Region ▁* ▁region ▁; ▁DVB Sub Object ▁* ▁object ▁; ▁DVB Sub Object Display ▁* ▁display ▁; ▁int ▁fill ▁; ▁if ▁( ▁buf _ size ▁< ▁10 ▁) ▁return ▁; ▁region _ id ▁= ▁* ▁buf ▁++ ▁; ▁region ▁= ▁get _ region ▁( ▁ctx ▁, ▁region _ id ▁) ▁; ▁if ▁( ▁! ▁region ▁) ▁{ ▁region ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁DVB Sub Region ▁) ▁) ▁; ▁if ▁( ▁! ▁region ▁) ▁return ▁; ▁region ▁-> ▁id ▁= ▁region _ id ▁; ▁region ▁-> ▁version ▁= ▁-1 ▁; ▁region ▁-> ▁next ▁= ▁ctx ▁-> ▁region _ list ▁; ▁ctx ▁-> ▁region _ list ▁= ▁region ▁; ▁} ▁version ▁= ▁( ▁( ▁* ▁buf ▁) ▁>> ▁4 ▁) ▁& ▁15 ▁; ▁fill ▁= ▁( ▁( ▁* ▁buf ▁++ ▁) ▁>> ▁3 ▁) ▁& ▁1 ▁; ▁region ▁-> ▁width ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁; ▁buf ▁+= ▁2 ▁; ▁region ▁-> ▁height ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁; ▁buf ▁+= ▁2 ▁; ▁if ▁( ▁region ▁-> ▁width ▁* ▁region ▁-> ▁height ▁!= ▁region ▁-> ▁buf _ size ▁) ▁{ ▁av _ free ▁( ▁region ▁-> ▁pbuf ▁) ▁; ▁region ▁-> ▁buf _ size ▁= ▁region ▁-> ▁width ▁* ▁region ▁-> ▁height ▁; ▁region ▁-> ▁pbuf ▁= ▁av _ malloc ▁( ▁region ▁-> ▁buf _ size ▁) ▁; ▁fill ▁= ▁1 ▁; ▁region ▁-> ▁dirty ▁= ▁0 ▁; ▁} ▁region ▁-> ▁depth ▁= ▁1 ▁<< ▁( ▁( ▁( ▁* ▁buf ▁++ ▁) ▁>> ▁2 ▁) ▁& ▁7 ▁) ▁; ▁if ▁( ▁region ▁-> ▁depth ▁< ▁2 ▁|| ▁region ▁-> ▁depth ▁> ▁8 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" region depth % dis invalid \ n " ▁, ▁region ▁-> ▁depth ▁) ▁; ▁region ▁-> ▁depth ▁= ▁4 ▁; ▁} ▁region ▁-> ▁cl ut ▁= ▁* ▁buf ▁++ ▁; ▁if ▁( ▁region ▁-> ▁depth ▁== ▁8 ▁) ▁{ ▁region ▁-> ▁bg color ▁= ▁* ▁buf ▁++ ▁; ▁buf ▁+= ▁1 ▁; ▁} ▁else ▁{ ▁buf ▁+= ▁1 ▁; ▁if ▁( ▁region ▁-> ▁depth ▁== ▁4 ▁) ▁region ▁-> ▁bg color ▁= ▁( ▁( ▁( ▁* ▁buf ▁++ ▁) ▁>> ▁4 ▁) ▁& ▁15 ▁) ▁; ▁else ▁region ▁-> ▁bg color ▁= ▁( ▁( ▁( ▁* ▁buf ▁++ ▁) ▁>> ▁2 ▁) ▁& ▁3 ▁) ▁; ▁} ▁av _ d log ▁( ▁avctx ▁, ▁" Region % d , (% dx % d )\ n " ▁, ▁region _ id ▁, ▁region ▁-> ▁width ▁, ▁region ▁-> ▁height ▁) ▁; ▁if ▁( ▁fill ▁) ▁{ ▁memset ▁( ▁region ▁-> ▁pbuf ▁, ▁region ▁-> ▁bg color ▁, ▁region ▁-> ▁buf _ size ▁) ▁; ▁av _ d log ▁( ▁avctx ▁, ▁" Fill region (% d )\ n " ▁, ▁region ▁-> ▁bg color ▁) ▁; ▁} ▁delete _ region _ display _ list ▁( ▁ctx ▁, ▁region ▁) ▁; ▁while ▁( ▁buf ▁+ ▁5 ▁< ▁buf _ end ▁) ▁{ ▁object _ id ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁; ▁buf ▁+= ▁2 ▁; ▁object ▁= ▁get _ object ▁( ▁ctx ▁, ▁object _ id ▁) ▁; ▁if ▁( ▁! ▁object ▁) ▁{ ▁object ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁DVB Sub Object ▁) ▁) ▁; ▁object ▁-> ▁id ▁= ▁object _ id ▁; ▁object ▁-> ▁next ▁= ▁ctx ▁-> ▁object _ list ▁; ▁ctx ▁-> ▁object _ list ▁= ▁object ▁; ▁} ▁object ▁-> ▁type ▁= ▁( ▁* ▁buf ▁) ▁>> ▁6 ▁; ▁display ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁DVB Sub Object Display ▁) ▁) ▁; ▁display ▁-> ▁object _ id ▁= ▁object _ id ▁; ▁display ▁-> ▁region _ id ▁= ▁region _ id ▁; ▁display ▁-> ▁x _ pos ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁& ▁0 xfff ▁; ▁buf ▁+= ▁2 ▁; ▁display ▁-> ▁y _ pos ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁& ▁0 xfff ▁; ▁buf ▁+= ▁2 ▁; ▁if ▁( ▁( ▁object ▁-> ▁type ▁== ▁1 ▁|| ▁object ▁-> ▁type ▁== ▁2 ▁) ▁&& ▁buf ▁+ ▁1 ▁< ▁buf _ end ▁) ▁{ ▁display ▁-> ▁fg color ▁= ▁* ▁buf ▁++ ▁; ▁display ▁-> ▁bg color ▁= ▁* ▁buf ▁++ ▁; ▁} ▁display ▁-> ▁region _ list _ next ▁= ▁region ▁-> ▁display _ list ▁; ▁region ▁-> ▁display _ list ▁= ▁display ▁; ▁display ▁-> ▁object _ list _ next ▁= ▁object ▁-> ▁display _ list ▁; ▁object ▁-> ▁display _ list ▁= ▁display ▁; ▁} ▁}	0
▁static ▁int ▁load _ record ▁( ▁SSL 3_ RECORD ▁* ▁rec ▁, ▁RECORD _ DATA ▁* ▁re cd ▁, ▁unsigned ▁char ▁* ▁* ▁key ▁, ▁unsigned ▁char ▁* ▁iv ▁, ▁size _ t ▁iv len ▁, ▁unsigned ▁char ▁* ▁seq ▁) ▁{ ▁unsigned ▁char ▁* ▁pt ▁= ▁NULL ▁, ▁* ▁sq ▁= ▁NULL ▁, ▁* ▁iv tmp ▁= ▁NULL ▁; ▁size _ t ▁pt len ▁; ▁* ▁key ▁= ▁OPENSSL _ hex str 2 buf ▁( ▁re cd ▁-> ▁key ▁, ▁NULL ▁) ▁; ▁iv tmp ▁= ▁OPENSSL _ hex str 2 buf ▁( ▁re cd ▁-> ▁iv ▁, ▁NULL ▁) ▁; ▁sq ▁= ▁OPENSSL _ hex str 2 buf ▁( ▁re cd ▁-> ▁seq ▁, ▁NULL ▁) ▁; ▁pt ▁= ▁multi hex str 2 buf ▁( ▁re cd ▁-> ▁plaintext ▁, ▁& ▁pt len ▁) ▁; ▁if ▁( ▁* ▁key ▁== ▁NULL ▁|| ▁iv tmp ▁== ▁NULL ▁|| ▁sq ▁== ▁NULL ▁|| ▁pt ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁rec ▁-> ▁data ▁= ▁rec ▁-> ▁input ▁= ▁OPENSSL _ malloc ▁( ▁pt len ▁+ ▁EVP _ GCM _ TLS _ TAG _ LEN ▁) ▁; ▁if ▁( ▁rec ▁-> ▁data ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁rec ▁-> ▁length ▁= ▁pt len ▁; ▁memcpy ▁( ▁rec ▁-> ▁data ▁, ▁pt ▁, ▁pt len ▁) ▁; ▁OPENSSL _ free ▁( ▁pt ▁) ▁; ▁memcpy ▁( ▁seq ▁, ▁sq ▁, ▁SEQ _ NUM _ SIZE ▁) ▁; ▁OPENSSL _ free ▁( ▁sq ▁) ▁; ▁memcpy ▁( ▁iv ▁, ▁iv tmp ▁, ▁iv len ▁) ▁; ▁OPENSSL _ free ▁( ▁iv tmp ▁) ▁; ▁return ▁1 ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁* ▁key ▁) ▁; ▁* ▁key ▁= ▁NULL ▁; ▁OPENSSL _ free ▁( ▁iv tmp ▁) ▁; ▁OPENSSL _ free ▁( ▁sq ▁) ▁; ▁OPENSSL _ free ▁( ▁pt ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁void ▁av _ image _ copy ▁( ▁uint 8_ t ▁* ▁dst _ data ▁[ ▁4 ▁] ▁, ▁int ▁dst _ lines izes ▁[ ▁4 ▁] ▁, ▁const ▁uint 8_ t ▁* ▁src _ data ▁[ ▁4 ▁] ▁, ▁const ▁int ▁src _ lines izes ▁[ ▁4 ▁] ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁pix _ fmt ▁) ▁; ▁if ▁( ▁! ▁desc ▁|| ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ HW ACCEL ▁) ▁return ▁; ▁if ▁( ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PAL ▁|| ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PSE UD OP AL ▁) ▁{ ▁av _ image _ copy _ plane ▁( ▁dst _ data ▁[ ▁0 ▁] ▁, ▁dst _ lines izes ▁[ ▁0 ▁] ▁, ▁src _ data ▁[ ▁0 ▁] ▁, ▁src _ lines izes ▁[ ▁0 ▁] ▁, ▁width ▁, ▁height ▁) ▁; ▁memcpy ▁( ▁dst _ data ▁[ ▁1 ▁] ▁, ▁src _ data ▁[ ▁1 ▁] ▁, ▁4 ▁* ▁256 ▁) ▁; ▁} ▁else ▁{ ▁int ▁i ▁, ▁planes _ nb ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁desc ▁-> ▁nb _ components ▁; ▁i ▁++ ▁) ▁planes _ nb ▁= ▁FF MAX ▁( ▁planes _ nb ▁, ▁desc ▁-> ▁comp ▁[ ▁i ▁] ▁. ▁plane ▁+ ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁planes _ nb ▁; ▁i ▁++ ▁) ▁{ ▁int ▁h ▁= ▁height ▁; ▁int ▁b width ▁= ▁av _ image _ get _ lines ize ▁( ▁pix _ fmt ▁, ▁width ▁, ▁i ▁) ▁; ▁if ▁( ▁b width ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" av _ image _ get _ lines ize failed \ n " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁) ▁{ ▁h ▁= ▁AV _ CE IL _ RSHIFT ▁( ▁height ▁, ▁desc ▁-> ▁log 2_ chroma _ h ▁) ▁; ▁} ▁av _ image _ copy _ plane ▁( ▁dst _ data ▁[ ▁i ▁] ▁, ▁dst _ lines izes ▁[ ▁i ▁] ▁, ▁src _ data ▁[ ▁i ▁] ▁, ▁src _ lines izes ▁[ ▁i ▁] ▁, ▁b width ▁, ▁h ▁) ▁; ▁} ▁} ▁}	1
▁void ▁ssl _ set _ cert _ masks ▁( ▁C ERT ▁* ▁c ▁, ▁const ▁SSL _ CIPHER ▁* ▁cipher ▁) ▁{ ▁C ERT _ PKEY ▁* ▁cp k ▁; ▁int ▁rsa _ enc ▁, ▁rsa _ tmp ▁, ▁rsa _ sign ▁, ▁dh _ tmp ▁, ▁dh _ rsa ▁, ▁dh _ dsa ▁, ▁dsa _ sign ▁; ▁int ▁rsa _ enc _ export ▁, ▁dh _ rsa _ export ▁, ▁dh _ dsa _ export ▁; ▁int ▁rsa _ tmp _ export ▁, ▁dh _ tmp _ export ▁, ▁kl ▁; ▁unsigned ▁long ▁mask _ k ▁, ▁mask _ a ▁, ▁e mask _ k ▁, ▁e mask _ a ▁; ▁# ifndef ▁OPENSSL _ NO _ ECDSA ▁int ▁have _ ecc _ cert ▁, ▁ecdsa _ ok ▁, ▁ecc _ pkey _ size ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDH ▁int ▁have _ ec dh _ tmp ▁, ▁ecdh _ ok ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ EC ▁X 509 ▁* ▁x ▁= ▁NULL ▁; ▁EVP _ PKEY ▁* ▁ecc _ pkey ▁= ▁NULL ▁; ▁int ▁signature _ nid ▁= ▁0 ▁, ▁pk _ nid ▁= ▁0 ▁, ▁md _ nid ▁= ▁0 ▁; ▁# endif ▁if ▁( ▁c ▁== ▁NULL ▁) ▁return ▁; ▁kl ▁= ▁SSL _ C _ EXPORT _ PKEY LENGTH ▁( ▁cipher ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ RSA ▁rsa _ tmp ▁= ▁( ▁c ▁-> ▁rsa _ tmp ▁!= ▁NULL ▁|| ▁c ▁-> ▁rsa _ tmp _ cb ▁!= ▁NULL ▁) ▁; ▁rsa _ tmp _ export ▁= ▁( ▁c ▁-> ▁rsa _ tmp _ cb ▁!= ▁NULL ▁|| ▁( ▁rsa _ tmp ▁&& ▁RSA _ size ▁( ▁c ▁-> ▁rsa _ tmp ▁) ▁* ▁8 ▁<= ▁kl ▁) ▁) ▁; ▁# else ▁rsa _ tmp ▁= ▁rsa _ tmp _ export ▁= ▁0 ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DH ▁dh _ tmp ▁= ▁( ▁c ▁-> ▁dh _ tmp ▁!= ▁NULL ▁|| ▁c ▁-> ▁dh _ tmp _ cb ▁!= ▁NULL ▁|| ▁c ▁-> ▁dh _ tmp _ auto ▁) ▁; ▁dh _ tmp _ export ▁= ▁! ▁c ▁-> ▁dh _ tmp _ auto ▁&& ▁( ▁c ▁-> ▁dh _ tmp _ cb ▁!= ▁NULL ▁|| ▁( ▁dh _ tmp ▁&& ▁DH _ size ▁( ▁c ▁-> ▁dh _ tmp ▁) ▁* ▁8 ▁<= ▁kl ▁) ▁) ▁; ▁# else ▁dh _ tmp ▁= ▁dh _ tmp _ export ▁= ▁0 ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDH ▁have _ ec dh _ tmp ▁= ▁( ▁c ▁-> ▁ecdh _ tmp ▁|| ▁c ▁-> ▁ecdh _ tmp _ cb ▁|| ▁c ▁-> ▁ecdh _ tmp _ auto ▁) ▁; ▁# endif ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ RSA _ ENC ▁] ▁) ▁; ▁rsa _ enc ▁= ▁cp k ▁-> ▁valid _ flags ▁& ▁C ERT _ PKEY _ VALID ▁; ▁rsa _ enc _ export ▁= ▁( ▁rsa _ enc ▁&& ▁EVP _ PKEY _ size ▁( ▁cp k ▁-> ▁private key ▁) ▁* ▁8 ▁<= ▁kl ▁) ▁; ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ RSA _ SIGN ▁] ▁) ▁; ▁rsa _ sign ▁= ▁cp k ▁-> ▁valid _ flags ▁& ▁C ERT _ PKEY _ SIGN ▁; ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ DSA _ SIGN ▁] ▁) ▁; ▁dsa _ sign ▁= ▁cp k ▁-> ▁valid _ flags ▁& ▁C ERT _ PKEY _ SIGN ▁; ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ DH _ RSA ▁] ▁) ▁; ▁dh _ rsa ▁= ▁cp k ▁-> ▁valid _ flags ▁& ▁C ERT _ PKEY _ VALID ▁; ▁dh _ rsa _ export ▁= ▁( ▁dh _ rsa ▁&& ▁EVP _ PKEY _ size ▁( ▁cp k ▁-> ▁private key ▁) ▁* ▁8 ▁<= ▁kl ▁) ▁; ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ DH _ DSA ▁] ▁) ▁; ▁dh _ dsa ▁= ▁cp k ▁-> ▁valid _ flags ▁& ▁C ERT _ PKEY _ VALID ▁; ▁dh _ dsa _ export ▁= ▁( ▁dh _ dsa ▁&& ▁EVP _ PKEY _ size ▁( ▁cp k ▁-> ▁private key ▁) ▁* ▁8 ▁<= ▁kl ▁) ▁; ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ EC ▁have _ ecc _ cert ▁= ▁cp k ▁-> ▁valid _ flags ▁& ▁C ERT _ PKEY _ VALID ▁; ▁# endif ▁mask _ k ▁= ▁0 ▁; ▁mask _ a ▁= ▁0 ▁; ▁e mask _ k ▁= ▁0 ▁; ▁e mask _ a ▁= ▁0 ▁; ▁# ifdef ▁C IPHER _ DEBUG ▁printf ▁( ▁" rt =% dr te =% dd ht =% de cd ht =% d re =% d ree =% drs =% dds =% dd hr =% dd hd =% d \ n " ▁, ▁rsa _ tmp ▁, ▁rsa _ tmp _ export ▁, ▁dh _ tmp ▁, ▁have _ ec dh _ tmp ▁, ▁rsa _ enc ▁, ▁rsa _ enc _ export ▁, ▁rsa _ sign ▁, ▁dsa _ sign ▁, ▁dh _ rsa ▁, ▁dh _ dsa ▁) ▁; ▁# endif ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ GO ST 01 ▁] ▁) ▁; ▁if ▁( ▁cp k ▁-> ▁x 509 ▁!= ▁NULL ▁&& ▁cp k ▁-> ▁private key ▁!= ▁NULL ▁) ▁{ ▁mask _ k ▁|= ▁SSL _ k GO ST ▁; ▁mask _ a ▁|= ▁SSL _ a GO ST 01 ▁; ▁} ▁cp k ▁= ▁& ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ GO ST 94 ▁] ▁) ▁; ▁if ▁( ▁cp k ▁-> ▁x 509 ▁!= ▁NULL ▁&& ▁cp k ▁-> ▁private key ▁!= ▁NULL ▁) ▁{ ▁mask _ k ▁|= ▁SSL _ k GO ST ▁; ▁mask _ a ▁|= ▁SSL _ a GO ST 94 ▁; ▁} ▁if ▁( ▁rsa _ enc ▁|| ▁( ▁rsa _ tmp ▁&& ▁rsa _ sign ▁) ▁) ▁mask _ k ▁|= ▁SSL _ k RSA ▁; ▁if ▁( ▁rsa _ enc _ export ▁|| ▁( ▁rsa _ tmp _ export ▁&& ▁( ▁rsa _ sign ▁|| ▁rsa _ enc ▁) ▁) ▁) ▁e mask _ k ▁|= ▁SSL _ k RSA ▁; ▁# if ▁0 ▁if ▁( ▁( ▁dh _ tmp ▁|| ▁dh _ rsa ▁|| ▁dh _ dsa ▁) ▁&& ▁( ▁rsa _ enc ▁|| ▁rsa _ sign ▁|| ▁dsa _ sign ▁) ▁) ▁mask _ k ▁|= ▁SSL _ k D HE ▁; ▁if ▁( ▁( ▁dh _ tmp _ export ▁|| ▁dh _ rsa _ export ▁|| ▁dh _ dsa _ export ▁) ▁&& ▁( ▁rsa _ enc ▁|| ▁rsa _ sign ▁|| ▁dsa _ sign ▁) ▁) ▁e mask _ k ▁|= ▁SSL _ k D HE ▁; ▁# endif ▁if ▁( ▁dh _ tmp _ export ▁) ▁e mask _ k ▁|= ▁SSL _ k D HE ▁; ▁if ▁( ▁dh _ tmp ▁) ▁mask _ k ▁|= ▁SSL _ k D HE ▁; ▁if ▁( ▁dh _ rsa ▁) ▁mask _ k ▁|= ▁SSL _ k DH r ▁; ▁if ▁( ▁dh _ rsa _ export ▁) ▁e mask _ k ▁|= ▁SSL _ k DH r ▁; ▁if ▁( ▁dh _ dsa ▁) ▁mask _ k ▁|= ▁SSL _ k DH d ▁; ▁if ▁( ▁dh _ dsa _ export ▁) ▁e mask _ k ▁|= ▁SSL _ k DH d ▁; ▁if ▁( ▁e mask _ k ▁& ▁( ▁SSL _ k DH r ▁| ▁SSL _ k DH d ▁) ▁) ▁mask _ a ▁|= ▁SSL _ a DH ▁; ▁if ▁( ▁rsa _ enc ▁|| ▁rsa _ sign ▁) ▁{ ▁mask _ a ▁|= ▁SSL _ a RSA ▁; ▁e mask _ a ▁|= ▁SSL _ a RSA ▁; ▁} ▁if ▁( ▁dsa _ sign ▁) ▁{ ▁mask _ a ▁|= ▁SSL _ a DSS ▁; ▁e mask _ a ▁|= ▁SSL _ a DSS ▁; ▁} ▁mask _ a ▁|= ▁SSL _ a NULL ▁; ▁e mask _ a ▁|= ▁SSL _ a NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ KRB 5 ▁mask _ k ▁|= ▁SSL _ k KRB 5 ▁; ▁mask _ a ▁|= ▁SSL _ a KRB 5 ▁; ▁e mask _ k ▁|= ▁SSL _ k KRB 5 ▁; ▁e mask _ a ▁|= ▁SSL _ a KRB 5 ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁have _ ecc _ cert ▁) ▁{ ▁cp k ▁= ▁& ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁; ▁x ▁= ▁cp k ▁-> ▁x 509 ▁; ▁X 509_ check _ p urpose ▁( ▁x ▁, ▁-1 ▁, ▁0 ▁) ▁; ▁ecdh _ ok ▁= ▁( ▁x ▁-> ▁ex _ flags ▁& ▁EX FLAG _ K USAGE ▁) ▁? ▁( ▁x ▁-> ▁ex _ k usage ▁& ▁X 509 v 3_ K U _ KEY _ AG RE EMENT ▁) ▁: ▁1 ▁; ▁ecdsa _ ok ▁= ▁( ▁x ▁-> ▁ex _ flags ▁& ▁EX FLAG _ K USAGE ▁) ▁? ▁( ▁x ▁-> ▁ex _ k usage ▁& ▁X 509 v 3_ K U _ DIGITAL _ SIGNATURE ▁) ▁: ▁1 ▁; ▁if ▁( ▁! ▁( ▁cp k ▁-> ▁valid _ flags ▁& ▁C ERT _ PKEY _ SIGN ▁) ▁) ▁ecdsa _ ok ▁= ▁0 ▁; ▁ecc _ pkey ▁= ▁X 509_ get _ pubkey ▁( ▁x ▁) ▁; ▁ecc _ pkey _ size ▁= ▁( ▁ecc _ pkey ▁!= ▁NULL ▁) ▁? ▁EVP _ PKEY _ bits ▁( ▁ecc _ pkey ▁) ▁: ▁0 ▁; ▁EVP _ PKEY _ free ▁( ▁ecc _ pkey ▁) ▁; ▁if ▁( ▁( ▁x ▁-> ▁sig _ alg ▁) ▁&& ▁( ▁x ▁-> ▁sig _ alg ▁-> ▁algorithm ▁) ▁) ▁{ ▁signature _ nid ▁= ▁OBJ _ obj 2 nid ▁( ▁x ▁-> ▁sig _ alg ▁-> ▁algorithm ▁) ▁; ▁OBJ _ find _ sig id _ algs ▁( ▁signature _ nid ▁, ▁& ▁md _ nid ▁, ▁& ▁pk _ nid ▁) ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ ECDH ▁if ▁( ▁ecdh _ ok ▁) ▁{ ▁if ▁( ▁pk _ nid ▁== ▁NID _ rsa Encryption ▁|| ▁pk _ nid ▁== ▁NID _ rsa ▁) ▁{ ▁mask _ k ▁|= ▁SSL _ k ECDH r ▁; ▁mask _ a ▁|= ▁SSL _ a ECDH ▁; ▁if ▁( ▁ecc _ pkey _ size ▁<= ▁16 3 ▁) ▁{ ▁e mask _ k ▁|= ▁SSL _ k ECDH r ▁; ▁e mask _ a ▁|= ▁SSL _ a ECDH ▁; ▁} ▁} ▁if ▁( ▁pk _ nid ▁== ▁NID _ X 9_ 62_ id _ ec PublicKey ▁) ▁{ ▁mask _ k ▁|= ▁SSL _ k EC D He ▁; ▁mask _ a ▁|= ▁SSL _ a ECDH ▁; ▁if ▁( ▁ecc _ pkey _ size ▁<= ▁16 3 ▁) ▁{ ▁e mask _ k ▁|= ▁SSL _ k EC D He ▁; ▁e mask _ a ▁|= ▁SSL _ a ECDH ▁; ▁} ▁} ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDSA ▁if ▁( ▁ecdsa _ ok ▁) ▁{ ▁mask _ a ▁|= ▁SSL _ a ECDSA ▁; ▁e mask _ a ▁|= ▁SSL _ a ECDSA ▁; ▁} ▁# endif ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ECDH ▁if ▁( ▁have _ ec dh _ tmp ▁) ▁{ ▁mask _ k ▁|= ▁SSL _ k EC D HE ▁; ▁e mask _ k ▁|= ▁SSL _ k EC D HE ▁; ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ PS K ▁mask _ k ▁|= ▁SSL _ k PS K ▁; ▁mask _ a ▁|= ▁SSL _ a PS K ▁; ▁e mask _ k ▁|= ▁SSL _ k PS K ▁; ▁e mask _ a ▁|= ▁SSL _ a PS K ▁; ▁# endif ▁c ▁-> ▁mask _ k ▁= ▁mask _ k ▁; ▁c ▁-> ▁mask _ a ▁= ▁mask _ a ▁; ▁c ▁-> ▁export _ mask _ k ▁= ▁e mask _ k ▁; ▁c ▁-> ▁export _ mask _ a ▁= ▁e mask _ a ▁; ▁c ▁-> ▁valid ▁= ▁1 ▁; ▁}	0
▁static ▁void ▁print _ statistics ▁( ▁apr _ file _ t ▁* ▁output ▁) ▁{ ▁apr _ file _ printf ▁( ▁output ▁, ▁" log resolve Statistics :" ▁NL ▁) ▁; ▁apr _ file _ printf ▁( ▁output ▁, ▁" Entries :% d " ▁NL ▁, ▁entries ▁) ▁; ▁apr _ file _ printf ▁( ▁output ▁, ▁" With name :% d " ▁NL ▁, ▁with name ▁) ▁; ▁apr _ file _ printf ▁( ▁output ▁, ▁" Res olves :% d " ▁NL ▁, ▁res olves ▁) ▁; ▁if ▁( ▁n ore verse ▁) ▁{ ▁apr _ file _ printf ▁( ▁output ▁, ▁"- N ore verse :% d " ▁NL ▁, ▁n ore verse ▁) ▁; ▁} ▁if ▁( ▁double failed ▁) ▁{ ▁apr _ file _ printf ▁( ▁output ▁, ▁"- Double lookup failed :% d " ▁NL ▁, ▁double failed ▁) ▁; ▁} ▁apr _ file _ printf ▁( ▁output ▁, ▁" Cache hits :% d " ▁NL ▁, ▁cache hits ▁) ▁; ▁apr _ file _ printf ▁( ▁output ▁, ▁" Caches ize :% d " ▁NL ▁, ▁caches ize ▁) ▁; ▁}	0
▁static ▁Res ample Context ▁* ▁res ample _ init ▁( ▁Res ample Context ▁* ▁c ▁, ▁int ▁out _ rate ▁, ▁int ▁in _ rate ▁, ▁int ▁filter _ size ▁, ▁int ▁phase _ shift ▁, ▁int ▁linear ▁, ▁double ▁cutoff 0 ▁, ▁enum ▁AV Sample Format ▁format ▁, ▁enum ▁S wr FilterType ▁filter _ type ▁, ▁int ▁ka iser _ beta ▁, ▁double ▁precision ▁, ▁int ▁che by ▁) ▁{ ▁double ▁cutoff ▁= ▁cutoff 0 ▁? ▁cutoff 0 ▁: ▁0. 97 ▁; ▁double ▁factor ▁= ▁FF MIN ▁( ▁out _ rate ▁* ▁cutoff ▁/ ▁in _ rate ▁, ▁1.0 ▁) ▁; ▁int ▁phase _ count ▁= ▁1 ▁<< ▁phase _ shift ▁; ▁if ▁( ▁! ▁c ▁|| ▁c ▁-> ▁phase _ shift ▁!= ▁phase _ shift ▁|| ▁c ▁-> ▁linear ▁!= ▁linear ▁|| ▁c ▁-> ▁factor ▁!= ▁factor ▁|| ▁c ▁-> ▁filter _ length ▁!= ▁FF MAX ▁( ▁( ▁int ▁) ▁ceil ▁( ▁filter _ size ▁/ ▁factor ▁) ▁, ▁1 ▁) ▁|| ▁c ▁-> ▁format ▁!= ▁format ▁|| ▁c ▁-> ▁filter _ type ▁!= ▁filter _ type ▁|| ▁c ▁-> ▁ka iser _ beta ▁!= ▁ka iser _ beta ▁) ▁{ ▁c ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁c ▁) ▁) ▁; ▁if ▁( ▁! ▁c ▁) ▁return ▁NULL ▁; ▁c ▁-> ▁format ▁= ▁format ▁; ▁c ▁-> ▁fe lem _ size ▁= ▁av _ get _ bytes _ per _ sample ▁( ▁c ▁-> ▁format ▁) ▁; ▁switch ▁( ▁c ▁-> ▁format ▁) ▁{ ▁case ▁AV _ SAMPLE _ FMT _ S 16 P ▁: ▁c ▁-> ▁filter _ shift ▁= ▁15 ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ S 32 P ▁: ▁c ▁-> ▁filter _ shift ▁= ▁30 ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ FL TP ▁: ▁case ▁AV _ SAMPLE _ FMT _ DB LP ▁: ▁c ▁-> ▁filter _ shift ▁= ▁0 ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported sample format \ n " ▁) ▁; ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁filter _ size ▁/ ▁factor ▁> ▁INT 32_ MAX ▁/ ▁256 ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ ERROR ▁, ▁" Filter len gt htool arge \ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁c ▁-> ▁phase _ shift ▁= ▁phase _ shift ▁; ▁c ▁-> ▁phase _ mask ▁= ▁phase _ count ▁- ▁1 ▁; ▁c ▁-> ▁linear ▁= ▁linear ▁; ▁c ▁-> ▁factor ▁= ▁factor ▁; ▁c ▁-> ▁filter _ length ▁= ▁FF MAX ▁( ▁( ▁int ▁) ▁ceil ▁( ▁filter _ size ▁/ ▁factor ▁) ▁, ▁1 ▁) ▁; ▁c ▁-> ▁filter _ alloc ▁= ▁FF ALIGN ▁( ▁c ▁-> ▁filter _ length ▁, ▁8 ▁) ▁; ▁c ▁-> ▁filter _ bank ▁= ▁av _ calloc ▁( ▁c ▁-> ▁filter _ alloc ▁, ▁( ▁phase _ count ▁+ ▁1 ▁) ▁* ▁c ▁-> ▁fe lem _ size ▁) ▁; ▁c ▁-> ▁filter _ type ▁= ▁filter _ type ▁; ▁c ▁-> ▁ka iser _ beta ▁= ▁ka iser _ beta ▁; ▁if ▁( ▁! ▁c ▁-> ▁filter _ bank ▁) ▁goto ▁error ▁; ▁if ▁( ▁build _ filter ▁( ▁c ▁, ▁( ▁void ▁* ▁) ▁c ▁-> ▁filter _ bank ▁, ▁factor ▁, ▁c ▁-> ▁filter _ length ▁, ▁c ▁-> ▁filter _ alloc ▁, ▁phase _ count ▁, ▁1 ▁<< ▁c ▁-> ▁filter _ shift ▁, ▁filter _ type ▁, ▁ka iser _ beta ▁) ▁) ▁goto ▁error ▁; ▁memcpy ▁( ▁c ▁-> ▁filter _ bank ▁+ ▁( ▁c ▁-> ▁filter _ alloc ▁* ▁phase _ count ▁+ ▁1 ▁) ▁* ▁c ▁-> ▁fe lem _ size ▁, ▁c ▁-> ▁filter _ bank ▁, ▁( ▁c ▁-> ▁filter _ alloc ▁- ▁1 ▁) ▁* ▁c ▁-> ▁fe lem _ size ▁) ▁; ▁memcpy ▁( ▁c ▁-> ▁filter _ bank ▁+ ▁( ▁c ▁-> ▁filter _ alloc ▁* ▁phase _ count ▁) ▁* ▁c ▁-> ▁fe lem _ size ▁, ▁c ▁-> ▁filter _ bank ▁+ ▁( ▁c ▁-> ▁filter _ alloc ▁- ▁1 ▁) ▁* ▁c ▁-> ▁fe lem _ size ▁, ▁c ▁-> ▁fe lem _ size ▁) ▁; ▁} ▁c ▁-> ▁comp ensation _ distance ▁= ▁0 ▁; ▁if ▁( ▁! ▁av _ reduce ▁( ▁& ▁c ▁-> ▁src _ incr ▁, ▁& ▁c ▁-> ▁dst _ incr ▁, ▁out _ rate ▁, ▁in _ rate ▁* ▁( ▁int 64_ t ▁) ▁phase _ count ▁, ▁INT 32_ MAX ▁/ ▁2 ▁) ▁) ▁goto ▁error ▁; ▁c ▁-> ▁ideal _ dst _ incr ▁= ▁c ▁-> ▁dst _ incr ▁; ▁c ▁-> ▁dst _ incr _ div ▁= ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁c ▁-> ▁dst _ incr _ mod ▁= ▁c ▁-> ▁dst _ incr ▁% ▁c ▁-> ▁src _ incr ▁; ▁c ▁-> ▁index ▁= ▁- ▁phase _ count ▁* ▁( ▁( ▁c ▁-> ▁filter _ length ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁c ▁-> ▁frac ▁= ▁0 ▁; ▁sw ri _ res ample _ dsp _ init ▁( ▁c ▁) ▁; ▁return ▁c ▁; ▁error ▁: ▁av _ freep ▁( ▁& ▁c ▁-> ▁filter _ bank ▁) ▁; ▁av _ free ▁( ▁c ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁uint 32_ t ▁parse _ peak ▁( ▁const ▁uint 8_ t ▁* ▁peak ▁) ▁{ ▁int 64_ t ▁val ▁= ▁0 ▁; ▁int 64_ t ▁scale ▁= ▁1 ▁; ▁if ▁( ▁! ▁peak ▁) ▁return ▁0 ▁; ▁peak ▁+= ▁str spn ▁( ▁peak ▁, ▁"\ t " ▁) ▁; ▁if ▁( ▁peak ▁[ ▁0 ▁] ▁== ▁' ▁' ▁&& ▁peak ▁[ ▁1 ▁] ▁== ▁' ▁' ▁) ▁return ▁UINT 32_ MAX ▁; ▁else ▁if ▁( ▁! ▁( ▁peak ▁[ ▁0 ▁] ▁== ▁' ▁' ▁&& ▁peak ▁[ ▁1 ▁] ▁== ▁' ▁' ▁) ▁) ▁return ▁0 ▁; ▁peak ▁+= ▁2 ▁; ▁while ▁( ▁av _ is digit ▁( ▁* ▁peak ▁) ▁) ▁{ ▁int ▁digit ▁= ▁* ▁peak ▁- ▁' ▁' ▁; ▁if ▁( ▁scale ▁> ▁INT 64_ MAX ▁/ ▁10 ▁) ▁break ▁; ▁val ▁= ▁10 ▁* ▁val ▁+ ▁digit ▁; ▁scale ▁*= ▁10 ▁; ▁peak ▁++ ▁; ▁} ▁return ▁av _ re scale ▁( ▁val ▁, ▁UINT 32_ MAX ▁, ▁scale ▁) ▁; ▁}	1
▁static ▁inline ▁int ▁Get Code ▁( ▁Gif State ▁* ▁s ▁) ▁{ ▁int ▁c ▁, ▁siz buf ▁; ▁uint 8_ t ▁* ▁ptr ▁; ▁while ▁( ▁s ▁-> ▁b bits ▁< ▁s ▁-> ▁cur size ▁) ▁{ ▁ptr ▁= ▁s ▁-> ▁pbuf ▁; ▁if ▁( ▁ptr ▁>= ▁s ▁-> ▁ebuf ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁e ob _ reached ▁) ▁{ ▁siz buf ▁= ▁get _ byte ▁( ▁s ▁-> ▁f ▁) ▁; ▁s ▁-> ▁ebuf ▁= ▁s ▁-> ▁buf ▁+ ▁siz buf ▁; ▁s ▁-> ▁pbuf ▁= ▁s ▁-> ▁buf ▁; ▁if ▁( ▁siz buf ▁> ▁0 ▁) ▁{ ▁get _ buffer ▁( ▁s ▁-> ▁f ▁, ▁s ▁-> ▁buf ▁, ▁siz buf ▁) ▁; ▁} ▁else ▁{ ▁s ▁-> ▁e ob _ reached ▁= ▁1 ▁; ▁} ▁} ▁ptr ▁= ▁s ▁-> ▁pbuf ▁; ▁} ▁s ▁-> ▁b buf ▁|= ▁ptr ▁[ ▁0 ▁] ▁<< ▁s ▁-> ▁b bits ▁; ▁ptr ▁++ ▁; ▁s ▁-> ▁pbuf ▁= ▁ptr ▁; ▁s ▁-> ▁b bits ▁+= ▁8 ▁; ▁} ▁c ▁= ▁s ▁-> ▁b buf ▁& ▁s ▁-> ▁cur mask ▁; ▁s ▁-> ▁b buf ▁>>= ▁s ▁-> ▁cur size ▁; ▁s ▁-> ▁b bits ▁-= ▁s ▁-> ▁cur size ▁; ▁return ▁c ▁; ▁}	1
▁tm size _ t ▁TIFF Write Encoded Strip ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁strip ▁, ▁void ▁* ▁data ▁, ▁tm size _ t ▁cc ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" TIFF Write Encoded Strip " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁uint 16 ▁sample ▁; ▁if ▁( ▁! ▁WRITE CHECK STR IPS ▁( ▁tif ▁, ▁module ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁if ▁( ▁strip ▁>= ▁td ▁-> ▁td _ n stri ps ▁) ▁{ ▁if ▁( ▁td ▁-> ▁td _ planar config ▁== ▁PLAN AR CONFIG _ SEPAR ATE ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Cannot grow image b yst ri ps when using separate planes " ▁) ▁; ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁! ▁TIFF Grow Stri ps ▁( ▁tif ▁, ▁1 ▁, ▁module ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁td ▁-> ▁td _ stri ps per image ▁= ▁TIFF how many _32 ▁( ▁td ▁-> ▁td _ image length ▁, ▁td ▁-> ▁td _ rows per strip ▁) ▁; ▁} ▁if ▁( ▁! ▁BUFFER CHECK ▁( ▁tif ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ BUF 4 WRITE ▁; ▁tif ▁-> ▁tif _ cur strip ▁= ▁strip ▁; ▁if ▁( ▁! ▁_ TIFF Reserve Large En ough Write Buffer ▁( ▁tif ▁, ▁strip ▁) ▁) ▁{ ▁return ▁( ▁( ▁tm size _ t ▁) ▁( ▁-1 ▁) ▁) ▁; ▁} ▁tif ▁-> ▁tif _ raw cc ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ raw cp ▁= ▁tif ▁-> ▁tif _ raw data ▁; ▁if ▁( ▁td ▁-> ▁td _ stri ps per image ▁== ▁0 ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Z er ost ri ps per image " ▁) ▁; ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁} ▁tif ▁-> ▁tif _ row ▁= ▁( ▁strip ▁% ▁td ▁-> ▁td _ stri ps per image ▁) ▁* ▁td ▁-> ▁td _ rows per strip ▁; ▁if ▁( ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ CODER SETUP ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁! ▁( ▁* ▁tif ▁-> ▁tif _ setup encode ▁) ▁( ▁tif ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁tif ▁-> ▁tif _ flags ▁|= ▁TIFF _ CODER SETUP ▁; ▁} ▁tif ▁-> ▁tif _ flags ▁&= ▁ ~ ▁TIFF _ POST ENCODE ▁; ▁if ▁( ▁td ▁-> ▁td _ compression ▁== ▁COMPRESS ION _ NONE ▁) ▁{ ▁tif ▁-> ▁tif _ post decode ▁( ▁tif ▁, ▁( ▁uint 8 ▁* ▁) ▁data ▁, ▁cc ▁) ▁; ▁if ▁( ▁! ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁&& ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁== ▁0 ▁) ▁TIFF Reverse Bits ▁( ▁( ▁uint 8 ▁* ▁) ▁data ▁, ▁cc ▁) ▁; ▁if ▁( ▁cc ▁> ▁0 ▁&& ▁! ▁TIFF Append To Strip ▁( ▁tif ▁, ▁strip ▁, ▁( ▁uint 8 ▁* ▁) ▁data ▁, ▁cc ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁return ▁( ▁cc ▁) ▁; ▁} ▁sample ▁= ▁( ▁uint 16 ▁) ▁( ▁strip ▁/ ▁td ▁-> ▁td _ stri ps per image ▁) ▁; ▁if ▁( ▁! ▁( ▁* ▁tif ▁-> ▁tif _ pre encode ▁) ▁( ▁tif ▁, ▁sample ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁tif ▁-> ▁tif _ post decode ▁( ▁tif ▁, ▁( ▁uint 8 ▁* ▁) ▁data ▁, ▁cc ▁) ▁; ▁if ▁( ▁! ▁( ▁* ▁tif ▁-> ▁tif _ encode strip ▁) ▁( ▁tif ▁, ▁( ▁uint 8 ▁* ▁) ▁data ▁, ▁cc ▁, ▁sample ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁if ▁( ▁! ▁( ▁* ▁tif ▁-> ▁tif _ post encode ▁) ▁( ▁tif ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁if ▁( ▁! ▁is Fill Order ▁( ▁tif ▁, ▁td ▁-> ▁td _ fill order ▁) ▁&& ▁( ▁tif ▁-> ▁tif _ flags ▁& ▁TIFF _ NO BIT REV ▁) ▁== ▁0 ▁) ▁TIFF Reverse Bits ▁( ▁tif ▁-> ▁tif _ raw data ▁, ▁tif ▁-> ▁tif _ raw cc ▁) ▁; ▁if ▁( ▁tif ▁-> ▁tif _ raw cc ▁> ▁0 ▁&& ▁! ▁TIFF Append To Strip ▁( ▁tif ▁, ▁strip ▁, ▁tif ▁-> ▁tif _ raw data ▁, ▁tif ▁-> ▁tif _ raw cc ▁) ▁) ▁return ▁( ▁( ▁tm size _ t ▁) ▁- ▁1 ▁) ▁; ▁tif ▁-> ▁tif _ raw cc ▁= ▁0 ▁; ▁tif ▁-> ▁tif _ raw cp ▁= ▁tif ▁-> ▁tif _ raw data ▁; ▁return ▁( ▁cc ▁) ▁; ▁}	1
▁static ▁void ▁gif _ fill _ rect ▁( ▁AVFrame ▁* ▁picture ▁, ▁uint 32_ t ▁color ▁, ▁int ▁l ▁, ▁int ▁t ▁, ▁int ▁w ▁, ▁int ▁h ▁) ▁{ ▁const ▁int ▁linesize ▁= ▁picture ▁-> ▁linesize ▁[ ▁0 ▁] ▁/ ▁sizeof ▁( ▁uint 32_ t ▁) ▁; ▁const ▁uint 32_ t ▁* ▁py ▁= ▁( ▁uint 32_ t ▁* ▁) ▁picture ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁t ▁* ▁linesize ▁; ▁const ▁uint 32_ t ▁* ▁pr ▁, ▁* ▁pb ▁= ▁py ▁+ ▁( ▁t ▁+ ▁h ▁) ▁* ▁linesize ▁; ▁uint 32_ t ▁* ▁px ▁; ▁for ▁( ▁; ▁py ▁< ▁pb ▁; ▁py ▁+= ▁linesize ▁) ▁{ ▁px ▁= ▁( ▁uint 32_ t ▁* ▁) ▁py ▁+ ▁l ▁; ▁pr ▁= ▁px ▁+ ▁w ▁; ▁for ▁( ▁; ▁px ▁< ▁pr ▁; ▁px ▁++ ▁) ▁* ▁px ▁= ▁color ▁; ▁} ▁}	1
▁int ▁tls 13_ der ive _ finished key ▁( ▁SSL ▁* ▁s ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁const ▁unsigned ▁char ▁* ▁secret ▁, ▁unsigned ▁char ▁* ▁fin ▁, ▁size _ t ▁fin len ▁) ▁{ ▁static ▁const ▁unsigned ▁char ▁finished label ▁[ ▁] ▁= ▁" finished " ▁; ▁return ▁tls 13_ h kdf _ expand ▁( ▁s ▁, ▁md ▁, ▁secret ▁, ▁finished label ▁, ▁sizeof ▁( ▁finished label ▁) ▁- ▁1 ▁, ▁NULL ▁, ▁0 ▁, ▁fin ▁, ▁fin len ▁, ▁1 ▁) ▁; ▁}	0
▁static ▁av _ always _ inline ▁int ▁update _ dimensions ▁( ▁VP 8 Context ▁* ▁s ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁is _ vp 7 ▁) ▁{ ▁AVCodecContext ▁* ▁avctx ▁= ▁s ▁-> ▁avctx ▁; ▁int ▁i ▁, ▁ret ▁; ▁if ▁( ▁width ▁!= ▁s ▁-> ▁avctx ▁-> ▁width ▁|| ▁height ▁!= ▁s ▁-> ▁avctx ▁-> ▁height ▁) ▁{ ▁vp 8_ decode _ flush _ impl ▁( ▁s ▁-> ▁avctx ▁, ▁1 ▁) ▁; ▁ret ▁= ▁ff _ set _ dimensions ▁( ▁s ▁-> ▁avctx ▁, ▁width ▁, ▁height ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁s ▁-> ▁mb _ width ▁= ▁( ▁s ▁-> ▁avctx ▁-> ▁coded _ width ▁+ ▁15 ▁) ▁/ ▁16 ▁; ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁avctx ▁-> ▁coded _ height ▁+ ▁15 ▁) ▁/ ▁16 ▁; ▁s ▁-> ▁mb _ layout ▁= ▁is _ vp 7 ▁|| ▁avctx ▁-> ▁active _ thread _ type ▁== ▁FF _ THREAD _ SL ICE ▁&& ▁FF MIN ▁( ▁s ▁-> ▁num _ coeff _ partitions ▁, ▁avctx ▁-> ▁thread _ count ▁) ▁> ▁1 ▁; ▁if ▁( ▁! ▁s ▁-> ▁mb _ layout ▁) ▁{ ▁s ▁-> ▁macro blocks _ base ▁= ▁av _ malloc z ▁( ▁( ▁s ▁-> ▁mb _ width ▁+ ▁s ▁-> ▁mb _ height ▁* ▁2 ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁macro blocks ▁) ▁) ▁; ▁s ▁-> ▁in tra 4 x 4_ pred _ mode _ top ▁= ▁av _ malloc z ▁( ▁s ▁-> ▁mb _ width ▁* ▁4 ▁) ▁; ▁} ▁else ▁s ▁-> ▁macro blocks _ base ▁= ▁av _ malloc z ▁( ▁( ▁s ▁-> ▁mb _ width ▁+ ▁2 ▁) ▁* ▁( ▁s ▁-> ▁mb _ height ▁+ ▁2 ▁) ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁macro blocks ▁) ▁) ▁; ▁s ▁-> ▁top _ nn z ▁= ▁av _ malloc z ▁( ▁s ▁-> ▁mb _ width ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁top _ nn z ▁) ▁) ▁; ▁s ▁-> ▁top _ border ▁= ▁av _ malloc z ▁( ▁( ▁s ▁-> ▁mb _ width ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁top _ border ▁) ▁) ▁; ▁s ▁-> ▁thread _ data ▁= ▁av _ malloc z ▁( ▁MAX _ THREADS ▁* ▁sizeof ▁( ▁VP 8 Thread Data ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁macro blocks _ base ▁|| ▁! ▁s ▁-> ▁top _ nn z ▁|| ▁! ▁s ▁-> ▁top _ border ▁|| ▁! ▁s ▁-> ▁thread _ data ▁|| ▁( ▁! ▁s ▁-> ▁in tra 4 x 4_ pred _ mode _ top ▁&& ▁! ▁s ▁-> ▁mb _ layout ▁) ▁) ▁{ ▁free _ buffers ▁( ▁s ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ THREADS ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁thread _ data ▁[ ▁i ▁] ▁. ▁filter _ strength ▁= ▁av _ malloc z ▁( ▁s ▁-> ▁mb _ width ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁thread _ data ▁[ ▁0 ▁] ▁. ▁filter _ strength ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁thread _ data ▁[ ▁i ▁] ▁. ▁filter _ strength ▁) ▁{ ▁free _ buffers ▁( ▁s ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁# if ▁HAVE _ THREADS ▁pthread _ mutex _ init ▁( ▁& ▁s ▁-> ▁thread _ data ▁[ ▁i ▁] ▁. ▁lock ▁, ▁NULL ▁) ▁; ▁pthread _ cond _ init ▁( ▁& ▁s ▁-> ▁thread _ data ▁[ ▁i ▁] ▁. ▁cond ▁, ▁NULL ▁) ▁; ▁# endif ▁} ▁s ▁-> ▁macro blocks ▁= ▁s ▁-> ▁macro blocks _ base ▁+ ▁1 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁run _ post proc ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVFrame ▁* ▁frame ▁) ▁{ ▁DDS Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁x _ off ▁; ▁switch ▁( ▁ctx ▁-> ▁post proc ▁) ▁{ ▁case ▁DDS _ ALPHA _ EXP ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing alpha exponent .\ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁* ▁frame ▁-> ▁height ▁; ▁i ▁+= ▁4 ▁) ▁{ ▁uint 8_ t ▁* ▁src ▁= ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁i ▁; ▁int ▁r ▁= ▁src ▁[ ▁0 ▁] ▁; ▁int ▁g ▁= ▁src ▁[ ▁1 ▁] ▁; ▁int ▁b ▁= ▁src ▁[ ▁2 ▁] ▁; ▁int ▁a ▁= ▁src ▁[ ▁3 ▁] ▁; ▁src ▁[ ▁0 ▁] ▁= ▁r ▁* ▁a ▁/ ▁255 ▁; ▁src ▁[ ▁1 ▁] ▁= ▁g ▁* ▁a ▁/ ▁255 ▁; ▁src ▁[ ▁2 ▁] ▁= ▁b ▁* ▁a ▁/ ▁255 ▁; ▁src ▁[ ▁3 ▁] ▁= ▁255 ▁; ▁} ▁break ▁; ▁case ▁DDS _ NORMAL _ MAP ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing normal map .\ n " ▁) ▁; ▁x _ off ▁= ▁ctx ▁-> ▁tex _ ratio ▁== ▁8 ▁? ▁0 ▁: ▁3 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁* ▁frame ▁-> ▁height ▁; ▁i ▁+= ▁4 ▁) ▁{ ▁uint 8_ t ▁* ▁src ▁= ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁i ▁; ▁int ▁x ▁= ▁src ▁[ ▁x _ off ▁] ▁; ▁int ▁y ▁= ▁src ▁[ ▁1 ▁] ▁; ▁int ▁z ▁= ▁127 ▁; ▁int ▁d ▁= ▁( ▁255 ▁* ▁255 ▁- ▁x ▁* ▁x ▁- ▁y ▁* ▁y ▁) ▁/ ▁2 ▁; ▁if ▁( ▁d ▁> ▁0 ▁) ▁z ▁= ▁rint ▁( ▁sqrtf ▁( ▁d ▁) ▁) ▁; ▁src ▁[ ▁0 ▁] ▁= ▁x ▁; ▁src ▁[ ▁1 ▁] ▁= ▁y ▁; ▁src ▁[ ▁2 ▁] ▁= ▁z ▁; ▁src ▁[ ▁3 ▁] ▁= ▁255 ▁; ▁} ▁break ▁; ▁case ▁DDS _ RAW _ Y CO CG ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing raw Y Co C g .\ n " ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁* ▁frame ▁-> ▁height ▁; ▁i ▁+= ▁4 ▁) ▁{ ▁uint 8_ t ▁* ▁src ▁= ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁i ▁; ▁int ▁a ▁= ▁src ▁[ ▁0 ▁] ▁; ▁int ▁cg ▁= ▁src ▁[ ▁1 ▁] ▁- ▁128 ▁; ▁int ▁co ▁= ▁src ▁[ ▁2 ▁] ▁- ▁128 ▁; ▁int ▁y ▁= ▁src ▁[ ▁3 ▁] ▁; ▁src ▁[ ▁0 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁y ▁+ ▁co ▁- ▁cg ▁) ▁; ▁src ▁[ ▁1 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁y ▁+ ▁cg ▁) ▁; ▁src ▁[ ▁2 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁y ▁- ▁co ▁- ▁cg ▁) ▁; ▁src ▁[ ▁3 ▁] ▁= ▁a ▁; ▁} ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ A 2 XY ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing A 2 XY swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁0 ▁, ▁1 ▁) ▁; ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ RB X G ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing RB X G swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁1 ▁, ▁3 ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁2 ▁, ▁3 ▁) ▁; ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ RG XB ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing RG XB swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁2 ▁, ▁3 ▁) ▁; ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ RX BG ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing RX BG swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁1 ▁, ▁3 ▁) ▁; ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ RX GB ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing RX GB swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁0 ▁, ▁3 ▁) ▁; ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ X GB R ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing X GB R swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁2 ▁, ▁3 ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁0 ▁, ▁3 ▁) ▁; ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ X G XR ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing X G XR swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁1 ▁, ▁3 ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁0 ▁, ▁3 ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁0 ▁, ▁1 ▁) ▁; ▁break ▁; ▁case ▁DDS _ SW IZ Z LE _ X RB G ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Post - processing X RB G swizzle .\ n " ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁1 ▁, ▁3 ▁) ▁; ▁do _ swizzle ▁( ▁frame ▁, ▁0 ▁, ▁3 ▁) ▁; ▁break ▁; ▁} ▁}	0
▁int ▁av _ audio _ fifo _ space ▁( ▁AV Audio Fifo ▁* ▁af ▁) ▁{ ▁return ▁af ▁-> ▁allocated _ samples ▁- ▁af ▁-> ▁nb _ samples ▁; ▁}	1
▁static ▁int ▁revert _ channel _ cor relation ▁( ▁AL S Dec Context ▁* ▁ctx ▁, ▁AL S Block Data ▁* ▁bd ▁, ▁AL S Channel Data ▁* ▁* ▁cd ▁, ▁int ▁* ▁revert ed ▁, ▁unsigned ▁int ▁offset ▁, ▁int ▁c ▁) ▁{ ▁AL S Channel Data ▁* ▁ch ▁= ▁cd ▁[ ▁c ▁] ▁; ▁unsigned ▁int ▁dep ▁= ▁0 ▁; ▁unsigned ▁int ▁channels ▁= ▁ctx ▁-> ▁avctx ▁-> ▁channels ▁; ▁if ▁( ▁revert ed ▁[ ▁c ▁] ▁) ▁return ▁0 ▁; ▁revert ed ▁[ ▁c ▁] ▁= ▁1 ▁; ▁while ▁( ▁dep ▁< ▁channels ▁&& ▁! ▁ch ▁[ ▁dep ▁] ▁. ▁stop _ flag ▁) ▁{ ▁revert _ channel _ cor relation ▁( ▁ctx ▁, ▁bd ▁, ▁cd ▁, ▁revert ed ▁, ▁offset ▁, ▁ch ▁[ ▁dep ▁] ▁. ▁master _ channel ▁) ▁; ▁dep ▁++ ▁; ▁} ▁if ▁( ▁dep ▁== ▁channels ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Invalid channel cor relation !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁bd ▁-> ▁const _ block ▁= ▁ctx ▁-> ▁const _ block ▁+ ▁c ▁; ▁bd ▁-> ▁shift _ ls bs ▁= ▁ctx ▁-> ▁shift _ ls bs ▁+ ▁c ▁; ▁bd ▁-> ▁opt _ order ▁= ▁ctx ▁-> ▁opt _ order ▁+ ▁c ▁; ▁bd ▁-> ▁store _ prev _ samples ▁= ▁ctx ▁-> ▁store _ prev _ samples ▁+ ▁c ▁; ▁bd ▁-> ▁use _ l tp ▁= ▁ctx ▁-> ▁use _ l tp ▁+ ▁c ▁; ▁bd ▁-> ▁l tp _ lag ▁= ▁ctx ▁-> ▁l tp _ lag ▁+ ▁c ▁; ▁bd ▁-> ▁l tp _ gain ▁= ▁ctx ▁-> ▁l tp _ gain ▁[ ▁c ▁] ▁; ▁bd ▁-> ▁lpc _ co f ▁= ▁ctx ▁-> ▁lpc _ co f ▁[ ▁c ▁] ▁; ▁bd ▁-> ▁quant _ co f ▁= ▁ctx ▁-> ▁quant _ co f ▁[ ▁c ▁] ▁; ▁bd ▁-> ▁raw _ samples ▁= ▁ctx ▁-> ▁raw _ samples ▁[ ▁c ▁] ▁+ ▁offset ▁; ▁dep ▁= ▁0 ▁; ▁while ▁( ▁! ▁ch ▁[ ▁dep ▁] ▁. ▁stop _ flag ▁) ▁{ ▁unsigned ▁int ▁smp ▁; ▁unsigned ▁int ▁begin ▁= ▁1 ▁; ▁unsigned ▁int ▁end ▁= ▁bd ▁-> ▁block _ length ▁- ▁1 ▁; ▁int 64_ t ▁y ▁; ▁int 32_ t ▁* ▁master ▁= ▁ctx ▁-> ▁raw _ samples ▁[ ▁ch ▁[ ▁dep ▁] ▁. ▁master _ channel ▁] ▁+ ▁offset ▁; ▁if ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁time _ diff _ flag ▁) ▁{ ▁int ▁t ▁= ▁ch ▁[ ▁dep ▁] ▁. ▁time _ diff _ index ▁; ▁if ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁time _ diff _ sign ▁) ▁{ ▁t ▁= ▁- ▁t ▁; ▁begin ▁-= ▁t ▁; ▁} ▁else ▁{ ▁end ▁-= ▁t ▁; ▁} ▁for ▁( ▁smp ▁= ▁begin ▁; ▁smp ▁< ▁end ▁; ▁smp ▁++ ▁) ▁{ ▁y ▁= ▁( ▁1 ▁<< ▁6 ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁0 ▁] ▁, ▁master ▁[ ▁smp ▁- ▁1 ▁] ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁1 ▁] ▁, ▁master ▁[ ▁smp ▁] ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁2 ▁] ▁, ▁master ▁[ ▁smp ▁+ ▁1 ▁] ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁3 ▁] ▁, ▁master ▁[ ▁smp ▁- ▁1 ▁+ ▁t ▁] ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁4 ▁] ▁, ▁master ▁[ ▁smp ▁+ ▁t ▁] ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁5 ▁] ▁, ▁master ▁[ ▁smp ▁+ ▁1 ▁+ ▁t ▁] ▁) ▁; ▁bd ▁-> ▁raw _ samples ▁[ ▁smp ▁] ▁+= ▁y ▁>> ▁7 ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁smp ▁= ▁begin ▁; ▁smp ▁< ▁end ▁; ▁smp ▁++ ▁) ▁{ ▁y ▁= ▁( ▁1 ▁<< ▁6 ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁0 ▁] ▁, ▁master ▁[ ▁smp ▁- ▁1 ▁] ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁1 ▁] ▁, ▁master ▁[ ▁smp ▁] ▁) ▁+ ▁MUL 64 ▁( ▁ch ▁[ ▁dep ▁] ▁. ▁weight ing ▁[ ▁2 ▁] ▁, ▁master ▁[ ▁smp ▁+ ▁1 ▁] ▁) ▁; ▁bd ▁-> ▁raw _ samples ▁[ ▁smp ▁] ▁+= ▁y ▁>> ▁7 ▁; ▁} ▁} ▁dep ▁++ ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁inline ▁int ▁show _ tags ▁( ▁Writer Context ▁* ▁w ▁, ▁AV Dictionary ▁* ▁tags ▁, ▁int ▁section _ id ▁) ▁{ ▁AV Dictionary Entry ▁* ▁tag ▁= ▁NULL ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁! ▁tags ▁) ▁return ▁0 ▁; ▁writer _ print _ section _ header ▁( ▁w ▁, ▁section _ id ▁) ▁; ▁while ▁( ▁( ▁tag ▁= ▁av _ dict _ get ▁( ▁tags ▁, ▁"" ▁, ▁tag ▁, ▁AV _ DICT _ IGNORE _ SUFFIX ▁) ▁) ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁print _ str _ validate ▁( ▁tag ▁-> ▁key ▁, ▁tag ▁-> ▁value ▁) ▁) ▁< ▁0 ▁) ▁break ▁; ▁} ▁writer _ print _ section _ footer ▁( ▁w ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁wc 3_ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁W c 3 Demux Context ▁* ▁wc 3 ▁= ▁s ▁-> ▁priv _ data ▁; ▁Byte IO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁unsigned ▁int ▁fourcc _ tag ▁; ▁unsigned ▁int ▁size ▁; ▁int ▁packet _ read ▁= ▁0 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁unsigned ▁char ▁text ▁[ ▁1024 ▁] ▁; ▁unsigned ▁int ▁palette _ number ▁; ▁int ▁i ▁; ▁unsigned ▁char ▁r ▁, ▁g ▁, ▁b ▁; ▁int ▁base _ palette _ index ▁; ▁while ▁( ▁! ▁packet _ read ▁) ▁{ ▁fourcc _ tag ▁= ▁get _ le 32 ▁( ▁pb ▁) ▁; ▁size ▁= ▁( ▁get _ be 32 ▁( ▁pb ▁) ▁+ ▁1 ▁) ▁& ▁( ▁ ~ ▁1 ▁) ▁; ▁if ▁( ▁url _ fe of ▁( ▁pb ▁) ▁) ▁return ▁AVERROR ▁( ▁EIO ▁) ▁; ▁switch ▁( ▁fourcc _ tag ▁) ▁{ ▁case ▁BR CH _ TAG ▁: ▁break ▁; ▁case ▁SHO T _ TAG ▁: ▁palette _ number ▁= ▁get _ le 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁palette _ number ▁>= ▁wc 3 ▁-> ▁palette _ count ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁base _ palette _ index ▁= ▁palette _ number ▁* ▁PAL ETTE _ COUNT ▁* ▁3 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁PAL ETTE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁r ▁= ▁wc 3 ▁-> ▁pa let tes ▁[ ▁base _ palette _ index ▁+ ▁i ▁* ▁3 ▁+ ▁0 ▁] ▁; ▁g ▁= ▁wc 3 ▁-> ▁pa let tes ▁[ ▁base _ palette _ index ▁+ ▁i ▁* ▁3 ▁+ ▁1 ▁] ▁; ▁b ▁= ▁wc 3 ▁-> ▁pa let tes ▁[ ▁base _ palette _ index ▁+ ▁i ▁* ▁3 ▁+ ▁2 ▁] ▁; ▁wc 3 ▁-> ▁palette _ control ▁. ▁palette ▁[ ▁i ▁] ▁= ▁( ▁r ▁<< ▁16 ▁) ▁| ▁( ▁g ▁<< ▁8 ▁) ▁| ▁( ▁b ▁) ▁; ▁} ▁wc 3 ▁-> ▁palette _ control ▁. ▁palette _ changed ▁= ▁1 ▁; ▁break ▁; ▁case ▁VGA __ TAG ▁: ▁ret ▁= ▁av _ get _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁size ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁wc 3 ▁-> ▁video _ stream _ index ▁; ▁pkt ▁-> ▁pts ▁= ▁wc 3 ▁-> ▁pts ▁; ▁packet _ read ▁= ▁1 ▁; ▁break ▁; ▁case ▁TEXT _ TAG ▁: ▁# if ▁0 ▁url _ f seek ▁( ▁pb ▁, ▁size ▁, ▁SEEK _ CUR ▁) ▁; ▁# else ▁if ▁( ▁( ▁unsigned ▁) ▁size ▁> ▁sizeof ▁( ▁text ▁) ▁|| ▁( ▁ret ▁= ▁get _ buffer ▁( ▁pb ▁, ▁text ▁, ▁size ▁) ▁) ▁!= ▁size ▁) ▁ret ▁= ▁AVERROR ▁( ▁EIO ▁) ▁; ▁else ▁{ ▁int ▁i ▁= ▁0 ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Sub t it let ime !\ n " ▁) ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" ing lish :% s \ n " ▁, ▁& ▁text ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁i ▁+= ▁text ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" do y ts ch :% s \ n " ▁, ▁& ▁text ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁i ▁+= ▁text ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" f ron say :% s \ n " ▁, ▁& ▁text ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁# endif ▁break ▁; ▁case ▁A UD I _ TAG ▁: ▁ret ▁= ▁av _ get _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁size ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁wc 3 ▁-> ▁audio _ stream _ index ▁; ▁pkt ▁-> ▁pts ▁= ▁wc 3 ▁-> ▁pts ▁; ▁wc 3 ▁-> ▁pts ▁++ ▁; ▁packet _ read ▁= ▁1 ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" un recognized WC 3 chunk :% c % c % c % c (0 x %02 X %02 X %02 X %02 X )\ n " ▁, ▁( ▁uint 8_ t ▁) ▁fourcc _ tag ▁, ▁( ▁uint 8_ t ▁) ▁( ▁fourcc _ tag ▁>> ▁8 ▁) ▁, ▁( ▁uint 8_ t ▁) ▁( ▁fourcc _ tag ▁>> ▁16 ▁) ▁, ▁( ▁uint 8_ t ▁) ▁( ▁fourcc _ tag ▁>> ▁24 ▁) ▁, ▁( ▁uint 8_ t ▁) ▁fourcc _ tag ▁, ▁( ▁uint 8_ t ▁) ▁( ▁fourcc _ tag ▁>> ▁8 ▁) ▁, ▁( ▁uint 8_ t ▁) ▁( ▁fourcc _ tag ▁>> ▁16 ▁) ▁, ▁( ▁uint 8_ t ▁) ▁( ▁fourcc _ tag ▁>> ▁24 ▁) ▁) ▁; ▁ret ▁= ▁AVERROR _ INVALIDDATA ▁; ▁packet _ read ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁adx _ parse ▁( ▁AVCodec Parser Context ▁* ▁s 1 ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁* ▁poutbuf ▁, ▁int ▁* ▁poutbuf _ size ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁AD X Parse Context ▁* ▁s ▁= ▁s 1 ▁-> ▁priv _ data ▁; ▁ParseContext ▁* ▁pc ▁= ▁& ▁s ▁-> ▁pc ▁; ▁int ▁next ▁= ▁END _ NOT _ FOUND ▁; ▁int ▁i ▁; ▁uint 64_ t ▁state ▁= ▁pc ▁-> ▁state 64 ▁; ▁if ▁( ▁! ▁s ▁-> ▁header _ size ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁buf _ size ▁; ▁i ▁++ ▁) ▁{ ▁state ▁= ▁( ▁state ▁<< ▁8 ▁) ▁| ▁buf ▁[ ▁i ▁] ▁; ▁if ▁( ▁( ▁state ▁& ▁0 xFFFF 0000 FFFFFF 00 ▁) ▁== ▁0 x 8 00000000 312 0400 ULL ▁) ▁{ ▁int ▁channels ▁= ▁state ▁& ▁0 xFF ▁; ▁int ▁header _ size ▁= ▁( ▁( ▁state ▁>> ▁32 ▁) ▁& ▁0 xFFFF ▁) ▁+ ▁4 ▁; ▁if ▁( ▁channels ▁> ▁0 ▁&& ▁header _ size ▁>= ▁8 ▁) ▁{ ▁s ▁-> ▁header _ size ▁= ▁header _ size ▁; ▁s ▁-> ▁block _ size ▁= ▁BLOCK _ SIZE ▁* ▁channels ▁; ▁s ▁-> ▁remaining ▁= ▁i ▁- ▁7 ▁+ ▁s ▁-> ▁header _ size ▁+ ▁s ▁-> ▁block _ size ▁; ▁break ▁; ▁} ▁} ▁} ▁pc ▁-> ▁state 64 ▁= ▁state ▁; ▁} ▁if ▁( ▁s ▁-> ▁header _ size ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁remaining ▁) ▁s ▁-> ▁remaining ▁= ▁s ▁-> ▁block _ size ▁; ▁if ▁( ▁s ▁-> ▁remaining ▁<= ▁buf _ size ▁) ▁{ ▁next ▁= ▁s ▁-> ▁remaining ▁; ▁s ▁-> ▁remaining ▁= ▁0 ▁; ▁} ▁else ▁s ▁-> ▁remaining ▁-= ▁buf _ size ▁; ▁} ▁if ▁( ▁ff _ combine _ frame ▁( ▁pc ▁, ▁next ▁, ▁& ▁buf ▁, ▁& ▁buf _ size ▁) ▁< ▁0 ▁|| ▁! ▁buf _ size ▁) ▁{ ▁* ▁poutbuf ▁= ▁NULL ▁; ▁* ▁poutbuf _ size ▁= ▁0 ▁; ▁return ▁buf _ size ▁; ▁} ▁* ▁poutbuf ▁= ▁buf ▁; ▁* ▁poutbuf _ size ▁= ▁buf _ size ▁; ▁return ▁next ▁; ▁}	0
▁static ▁SR P _ g N _ cache ▁* ▁SR P _ g N _ new _ init ▁( ▁const ▁char ▁* ▁ch ▁) ▁{ ▁unsigned ▁char ▁tmp ▁[ ▁MAX _ LEN ▁] ▁; ▁int ▁len ▁; ▁SR P _ g N _ cache ▁* ▁new g N ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁new g N ▁) ▁) ▁; ▁if ▁( ▁new g N ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁len ▁= ▁t _ from b 64 ▁( ▁tmp ▁, ▁sizeof ▁( ▁tmp ▁) ▁, ▁ch ▁) ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁new g N ▁-> ▁b 64_ bn ▁= ▁OPENSSL _ strdup ▁( ▁ch ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁new g N ▁-> ▁bn ▁= ▁BN _ bin 2 bn ▁( ▁tmp ▁, ▁len ▁, ▁NULL ▁) ▁) ▁) ▁return ▁new g N ▁; ▁OPENSSL _ free ▁( ▁new g N ▁-> ▁b 64_ bn ▁) ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁new g N ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁ssl 3_ get _ server _ hello ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁sk ▁; ▁SSL _ CIPHER ▁* ▁c ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁* ▁d ▁; ▁int ▁i ▁, ▁al ▁, ▁ok ▁; ▁unsigned ▁int ▁j ▁; ▁long ▁n ▁; ▁SSL _ COMP ▁* ▁comp ▁; ▁n ▁= ▁ssl 3_ get _ message ▁( ▁s ▁, ▁SSL 3_ ST _ CR _ SR VR _ HELLO _ A ▁, ▁SSL 3_ ST _ CR _ SR VR _ HELLO _ B ▁, ▁SSL 3_ MT _ SERVER _ HELLO ▁, ▁300 ▁, ▁& ▁ok ▁) ▁; ▁if ▁( ▁! ▁ok ▁) ▁return ▁( ▁( ▁int ▁) ▁n ▁) ▁; ▁d ▁= ▁p ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁s ▁-> ▁init _ msg ▁; ▁if ▁( ▁( ▁p ▁[ ▁0 ▁] ▁!= ▁( ▁s ▁-> ▁version ▁>> ▁8 ▁) ▁) ▁|| ▁( ▁p ▁[ ▁1 ▁] ▁!= ▁( ▁s ▁-> ▁version ▁& ▁0 xff ▁) ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ WRONG _ SSL _ VERSION ▁) ▁; ▁s ▁-> ▁version ▁= ▁( ▁s ▁-> ▁version ▁& ▁0 xff 00 ▁) ▁| ▁p ▁[ ▁1 ▁] ▁; ▁al ▁= ▁SSL _ AD _ PROTOCOL _ VERSION ▁; ▁goto ▁f _ err ▁; ▁} ▁p ▁+= ▁2 ▁; ▁memcpy ▁( ▁s ▁-> ▁s 3 ▁-> ▁server _ random ▁, ▁p ▁, ▁SSL 3_ RANDOM _ SIZE ▁) ▁; ▁p ▁+= ▁SSL 3_ RANDOM _ SIZE ▁; ▁j ▁= ▁* ▁( ▁p ▁++ ▁) ▁; ▁if ▁( ▁j ▁> ▁sizeof ▁s ▁-> ▁session ▁-> ▁session _ id ▁) ▁{ ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ SSL 3_ SESSION _ ID _ TOO _ LONG ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁( ▁j ▁!= ▁0 ▁) ▁&& ▁( ▁j ▁!= ▁SSL 3_ SESSION _ ID _ SIZE ▁) ▁) ▁{ ▁if ▁( ▁j ▁< ▁SSL 2_ SSL _ SESSION _ ID _ LENGTH ▁) ▁{ ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ SSL 3_ SESSION _ ID _ TOO _ SHORT ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁} ▁if ▁( ▁j ▁!= ▁0 ▁&& ▁j ▁== ▁s ▁-> ▁session ▁-> ▁session _ id _ length ▁&& ▁memcmp ▁( ▁p ▁, ▁s ▁-> ▁session ▁-> ▁session _ id ▁, ▁j ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁s ▁-> ▁sid _ ctx _ length ▁!= ▁s ▁-> ▁session ▁-> ▁sid _ ctx _ length ▁|| ▁memcmp ▁( ▁s ▁-> ▁session ▁-> ▁sid _ ctx ▁, ▁s ▁-> ▁sid _ ctx ▁, ▁s ▁-> ▁sid _ ctx _ length ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ ATTEMP T _ TO _ REUSE _ SESSION _ IN _ DI FFER ENT _ CONTEXT ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁s ▁-> ▁hit ▁= ▁1 ▁; ▁} ▁else ▁{ ▁s ▁-> ▁hit ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁session ▁-> ▁session _ id _ length ▁> ▁0 ▁) ▁{ ▁if ▁( ▁! ▁ssl _ get _ new _ session ▁( ▁s ▁, ▁0 ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁goto ▁f _ err ▁; ▁} ▁} ▁s ▁-> ▁session ▁-> ▁session _ id _ length ▁= ▁j ▁; ▁memcpy ▁( ▁s ▁-> ▁session ▁-> ▁session _ id ▁, ▁p ▁, ▁j ▁) ▁; ▁} ▁p ▁+= ▁j ▁; ▁c ▁= ▁ssl _ get _ cipher _ by _ char ▁( ▁s ▁, ▁p ▁) ▁; ▁if ▁( ▁c ▁== ▁NULL ▁) ▁{ ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ UNKNOWN _ CIPHER _ RETURN ED ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁p ▁+= ▁ssl _ put _ cipher _ by _ char ▁( ▁s ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁sk ▁= ▁ssl _ get _ c iphers _ by _ id ▁( ▁s ▁) ▁; ▁i ▁= ▁sk _ SSL _ CIPHER _ find ▁( ▁sk ▁, ▁c ▁) ▁; ▁if ▁( ▁i ▁< ▁0 ▁) ▁{ ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ WRONG _ CIPHER _ RETURN ED ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁if ▁( ▁s ▁-> ▁hit ▁&& ▁( ▁s ▁-> ▁session ▁-> ▁cipher ▁!= ▁c ▁) ▁) ▁{ ▁if ▁( ▁! ▁( ▁s ▁-> ▁options ▁& ▁SSL _ OP _ NET SCAPE _ REUSE _ CIPHER _ CHANGE _ BUG ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ OLD _ SESSION _ CIPHER _ NOT _ RETURN ED ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁} ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁= ▁c ▁; ▁j ▁= ▁* ▁( ▁p ▁++ ▁) ▁; ▁if ▁( ▁j ▁== ▁0 ▁) ▁comp ▁= ▁NULL ▁; ▁else ▁comp ▁= ▁ssl 3_ comp _ find ▁( ▁s ▁-> ▁ctx ▁-> ▁comp _ methods ▁, ▁j ▁) ▁; ▁if ▁( ▁( ▁j ▁!= ▁0 ▁) ▁&& ▁( ▁comp ▁== ▁NULL ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ UNSUPPORTED _ COMPRESSION _ ALGORITHM ▁) ▁; ▁goto ▁f _ err ▁; ▁} ▁else ▁{ ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ compression ▁= ▁comp ▁; ▁} ▁if ▁( ▁p ▁!= ▁( ▁d ▁+ ▁n ▁) ▁) ▁{ ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ SSL 3_ GET _ SERVER _ HELLO ▁, ▁SSL _ R _ BAD _ PACKET _ LENGTH ▁) ▁; ▁goto ▁err ▁; ▁} ▁return ▁( ▁1 ▁) ▁; ▁f _ err ▁: ▁ssl 3_ send _ alert ▁( ▁s ▁, ▁SSL 3_ AL _ FATAL ▁, ▁al ▁) ▁; ▁err ▁: ▁return ▁( ▁-1 ▁) ▁; ▁}	0
▁static ▁int ▁as ink _ query _ formats ▁( ▁AVFilter Context ▁* ▁ctx ▁) ▁{ ▁Buffer Sink Context ▁* ▁buf ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFilter Formats ▁* ▁formats ▁= ▁NULL ▁; ▁AVFilter Channel Layout s ▁* ▁layouts ▁= ▁NULL ▁; ▁unsigned ▁i ▁; ▁int ▁ret ▁; ▁if ▁( ▁buf ▁-> ▁sample _ fmts _ size ▁% ▁sizeof ▁( ▁* ▁buf ▁-> ▁sample _ fmts ▁) ▁|| ▁buf ▁-> ▁sample _ rates _ size ▁% ▁sizeof ▁( ▁* ▁buf ▁-> ▁sample _ rates ▁) ▁|| ▁buf ▁-> ▁channel _ layout s _ size ▁% ▁sizeof ▁( ▁* ▁buf ▁-> ▁channel _ layout s ▁) ▁|| ▁buf ▁-> ▁channel _ counts _ size ▁% ▁sizeof ▁( ▁* ▁buf ▁-> ▁channel _ counts ▁) ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid size for format lists \ n " ▁) ▁; ▁# define ▁LOG _ ERROR ▁( ▁field ▁) ▁\ if ( buf -> field ##_ size % sizeof (* buf -> field )) \ av _ log ( ctx , AV _ LOG _ ERROR ," " # field " is % d , should be " \" multiple of % d \ n ", \ buf -> field ##_ size , ( int ) sizeof (* buf -> field )); ▁LOG _ ERROR ▁( ▁sample _ fmts ▁) ▁; ▁LOG _ ERROR ▁( ▁sample _ rates ▁) ▁; ▁LOG _ ERROR ▁( ▁channel _ layout s ▁) ▁; ▁LOG _ ERROR ▁( ▁channel _ counts ▁) ▁; ▁# undef ▁LOG _ ERROR ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁buf ▁-> ▁sample _ fmts _ size ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁sample _ fmts ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ format ▁( ▁& ▁formats ▁, ▁buf ▁-> ▁sample _ fmts ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ff _ set _ common _ formats ▁( ▁ctx ▁, ▁formats ▁) ▁; ▁} ▁if ▁( ▁buf ▁-> ▁channel _ layout s _ size ▁|| ▁buf ▁-> ▁channel _ counts _ size ▁|| ▁buf ▁-> ▁all _ channel _ counts ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁channel _ layout s ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ channel _ layout ▁( ▁& ▁layouts ▁, ▁buf ▁-> ▁channel _ layout s ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁channel _ counts ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ channel _ layout ▁( ▁& ▁layouts ▁, ▁FF _ COUNT 2 LAYOUT ▁( ▁buf ▁-> ▁channel _ counts ▁[ ▁i ▁] ▁) ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁buf ▁-> ▁all _ channel _ counts ▁) ▁{ ▁if ▁( ▁layouts ▁) ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Conflicting all _ channel _ counts and list in options \ n " ▁) ▁; ▁else ▁if ▁( ▁! ▁( ▁layouts ▁= ▁ff _ all _ channel _ counts ▁( ▁) ▁) ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁ff _ set _ common _ channel _ layout s ▁( ▁ctx ▁, ▁layouts ▁) ▁; ▁} ▁if ▁( ▁buf ▁-> ▁sample _ rates _ size ▁) ▁{ ▁formats ▁= ▁NULL ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁sample _ rates ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ format ▁( ▁& ▁formats ▁, ▁buf ▁-> ▁sample _ rates ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ff _ set _ common _ sampler ates ▁( ▁ctx ▁, ▁formats ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁av _ cold ▁int ▁atr ac 3_ decode _ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁static ▁int ▁static _ init _ done ▁; ▁int ▁i ▁, ▁js _ pair ▁, ▁ret ▁; ▁int ▁version ▁, ▁delay ▁, ▁samples _ per _ frame ▁, ▁frame _ factor ▁; ▁const ▁uint 8_ t ▁* ▁ed ata _ ptr ▁= ▁avctx ▁-> ▁extradata ▁; ▁A TR AC 3 Context ▁* ▁q ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁< ▁MIN _ CHANNELS ▁|| ▁avctx ▁-> ▁channels ▁> ▁MAX _ CHANNELS ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Channel configuration error !\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁! ▁static _ init _ done ▁) ▁atr ac 3_ init _ static _ data ▁( ▁) ▁; ▁static _ init _ done ▁= ▁1 ▁; ▁if ▁( ▁avctx ▁-> ▁extradata _ size ▁== ▁14 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁"[ 0 -1 ] % d \ n " ▁, ▁bytestream _ get _ le 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁) ▁; ▁ed ata _ ptr ▁+= ▁4 ▁; ▁q ▁-> ▁coding _ mode ▁= ▁bytestream _ get _ le 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁"[ 8 -9 ] % d \ n " ▁, ▁bytestream _ get _ le 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁) ▁; ▁frame _ factor ▁= ▁bytestream _ get _ le 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁"[ 12 -13 ] % d \ n " ▁, ▁bytestream _ get _ le 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁) ▁; ▁samples _ per _ frame ▁= ▁SAM PLES _ PER _ FRAME ▁* ▁avctx ▁-> ▁channels ▁; ▁version ▁= ▁4 ▁; ▁delay ▁= ▁0 x 88 E ▁; ▁q ▁-> ▁coding _ mode ▁= ▁q ▁-> ▁coding _ mode ▁? ▁JO INT _ STEREO ▁: ▁SINGLE ▁; ▁q ▁-> ▁sc ram b led _ stream ▁= ▁0 ▁; ▁if ▁( ▁avctx ▁-> ▁block _ align ▁!= ▁96 ▁* ▁avctx ▁-> ▁channels ▁* ▁frame _ factor ▁&& ▁avctx ▁-> ▁block _ align ▁!= ▁152 ▁* ▁avctx ▁-> ▁channels ▁* ▁frame _ factor ▁&& ▁avctx ▁-> ▁block _ align ▁!= ▁192 ▁* ▁avctx ▁-> ▁channels ▁* ▁frame _ factor ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown frame / channel / frame _ factor " ▁" configuration % d /% d /% d \ n " ▁, ▁avctx ▁-> ▁block _ align ▁, ▁avctx ▁-> ▁channels ▁, ▁frame _ factor ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁else ▁if ▁( ▁avctx ▁-> ▁extradata _ size ▁== ▁12 ▁|| ▁avctx ▁-> ▁extradata _ size ▁== ▁10 ▁) ▁{ ▁version ▁= ▁bytestream _ get _ be 32 ▁( ▁& ▁ed ata _ ptr ▁) ▁; ▁samples _ per _ frame ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁; ▁delay ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁; ▁q ▁-> ▁coding _ mode ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁ed ata _ ptr ▁) ▁; ▁q ▁-> ▁sc ram b led _ stream ▁= ▁1 ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown extr ad atas ize % d .\ n " ▁, ▁avctx ▁-> ▁extradata _ size ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁if ▁( ▁version ▁!= ▁4 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Version % d ! =4 .\ n " ▁, ▁version ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁samples _ per _ frame ▁!= ▁SAM PLES _ PER _ FRAME ▁* ▁avctx ▁-> ▁channels ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown amount of samples per frame % d .\ n " ▁, ▁samples _ per _ frame ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁delay ▁!= ▁0 x 88 E ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown amount of delay % x ! =0 x 88 E .\ n " ▁, ▁delay ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁q ▁-> ▁coding _ mode ▁== ▁SINGLE ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Single channels detected .\ n " ▁) ▁; ▁else ▁if ▁( ▁q ▁-> ▁coding _ mode ▁== ▁JO INT _ STEREO ▁) ▁{ ▁if ▁( ▁avctx ▁-> ▁channels ▁% ▁2 ▁== ▁1 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid joint stereo channel configuration .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Joint st ere ode tected .\ n " ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unknown channel coding mode % x !\ n " ▁, ▁q ▁-> ▁coding _ mode ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁block _ align ▁>= ▁UINT _ MAX ▁/ ▁2 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁q ▁-> ▁decoded _ bytes _ buffer ▁= ▁av _ malloc z ▁( ▁FF ALIGN ▁( ▁avctx ▁-> ▁block _ align ▁, ▁4 ▁) ▁+ ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁q ▁-> ▁decoded _ bytes _ buffer ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁avctx ▁-> ▁sample _ fmt ▁= ▁AV _ SAMPLE _ FMT _ FL TP ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ md ct _ init ▁( ▁& ▁q ▁-> ▁md ct _ ctx ▁, ▁9 ▁, ▁1 ▁, ▁1.0 ▁/ ▁32768 ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error init ializing MD CT \ n " ▁) ▁; ▁av _ freep ▁( ▁& ▁q ▁-> ▁decoded _ bytes _ buffer ▁) ▁; ▁return ▁ret ▁; ▁} ▁for ▁( ▁js _ pair ▁= ▁0 ▁; ▁js _ pair ▁< ▁MAX _ JS _ PAIR S ▁; ▁js _ pair ▁++ ▁) ▁{ ▁q ▁-> ▁weight ing _ delay ▁[ ▁js _ pair ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁q ▁-> ▁weight ing _ delay ▁[ ▁js _ pair ▁] ▁[ ▁1 ▁] ▁= ▁7 ▁; ▁q ▁-> ▁weight ing _ delay ▁[ ▁js _ pair ▁] ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁q ▁-> ▁weight ing _ delay ▁[ ▁js _ pair ▁] ▁[ ▁3 ▁] ▁= ▁7 ▁; ▁q ▁-> ▁weight ing _ delay ▁[ ▁js _ pair ▁] ▁[ ▁4 ▁] ▁= ▁0 ▁; ▁q ▁-> ▁weight ing _ delay ▁[ ▁js _ pair ▁] ▁[ ▁5 ▁] ▁= ▁7 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁q ▁-> ▁matrix _ coeff _ index _ prev ▁[ ▁js _ pair ▁] ▁[ ▁i ▁] ▁= ▁3 ▁; ▁q ▁-> ▁matrix _ coeff _ index _ now ▁[ ▁js _ pair ▁] ▁[ ▁i ▁] ▁= ▁3 ▁; ▁q ▁-> ▁matrix _ coeff _ index _ next ▁[ ▁js _ pair ▁] ▁[ ▁i ▁] ▁= ▁3 ▁; ▁} ▁} ▁ff _ at rac _ init _ gain _ comp ensation ▁( ▁& ▁q ▁-> ▁gain c _ ctx ▁, ▁4 ▁, ▁3 ▁) ▁; ▁q ▁-> ▁f dsp ▁= ▁avpriv _ float _ dsp _ alloc ▁( ▁avctx ▁-> ▁flags ▁& ▁AV _ CODEC _ FLAG _ BIT EXACT ▁) ▁; ▁q ▁-> ▁units ▁= ▁av _ malloc z _ array ▁( ▁avctx ▁-> ▁channels ▁, ▁sizeof ▁( ▁* ▁q ▁-> ▁units ▁) ▁) ▁; ▁if ▁( ▁! ▁q ▁-> ▁units ▁|| ▁! ▁q ▁-> ▁f dsp ▁) ▁{ ▁atr ac 3_ decode _ close ▁( ▁avctx ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁BN _ mul _ word ▁( ▁BIGNUM ▁* ▁a ▁, ▁BN _ ULONG ▁w ▁) ▁{ ▁BN _ ULONG ▁ll ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁w ▁&= ▁BN _ MASK 2 ▁; ▁if ▁( ▁a ▁-> ▁top ▁) ▁{ ▁if ▁( ▁w ▁== ▁0 ▁) ▁BN _ zero ▁( ▁a ▁) ▁; ▁else ▁{ ▁ll ▁= ▁bn _ mul _ words ▁( ▁a ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁a ▁-> ▁top ▁, ▁w ▁) ▁; ▁if ▁( ▁ll ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁a ▁, ▁a ▁-> ▁top ▁+ ▁1 ▁) ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁a ▁-> ▁d ▁[ ▁a ▁-> ▁top ▁++ ▁] ▁= ▁ll ▁; ▁} ▁} ▁} ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁void ▁fmt fp ▁( ▁char ▁* ▁buffer ▁, ▁size _ t ▁* ▁curr len ▁, ▁size _ t ▁maxlen ▁, ▁L DOUBLE ▁f value ▁, ▁int ▁min ▁, ▁int ▁max ▁, ▁int ▁flags ▁) ▁{ ▁int ▁sign value ▁= ▁0 ▁; ▁L DOUBLE ▁uf value ▁; ▁char ▁icon vert ▁[ ▁20 ▁] ▁; ▁char ▁f convert ▁[ ▁20 ▁] ▁; ▁int ▁ip lace ▁= ▁0 ▁; ▁int ▁fp lace ▁= ▁0 ▁; ▁int ▁padlen ▁= ▁0 ▁; ▁int ▁z pad len ▁= ▁0 ▁; ▁int ▁caps ▁= ▁0 ▁; ▁long ▁int part ▁; ▁long ▁frac part ▁; ▁if ▁( ▁max ▁< ▁0 ▁) ▁max ▁= ▁6 ▁; ▁uf value ▁= ▁abs _ val ▁( ▁f value ▁) ▁; ▁if ▁( ▁f value ▁< ▁0 ▁) ▁sign value ▁= ▁' ▁' ▁; ▁else ▁if ▁( ▁flags ▁& ▁DP _ F _ PLUS ▁) ▁sign value ▁= ▁' ▁' ▁; ▁else ▁if ▁( ▁flags ▁& ▁DP _ F _ SPACE ▁) ▁sign value ▁= ▁' ▁' ▁; ▁int part ▁= ▁( ▁long ▁) ▁uf value ▁; ▁if ▁( ▁max ▁> ▁9 ▁) ▁max ▁= ▁9 ▁; ▁frac part ▁= ▁round ▁( ▁( ▁pow 10 ▁( ▁max ▁) ▁) ▁* ▁( ▁uf value ▁- ▁int part ▁) ▁) ▁; ▁if ▁( ▁frac part ▁>= ▁pow 10 ▁( ▁max ▁) ▁) ▁{ ▁int part ▁++ ▁; ▁frac part ▁-= ▁( ▁long ▁) ▁pow 10 ▁( ▁max ▁) ▁; ▁} ▁do ▁{ ▁icon vert ▁[ ▁ip lace ▁++ ▁] ▁= ▁( ▁caps ▁? ▁"0123456789 ABCDEF " ▁: ▁"0123456789 abcdef " ▁) ▁[ ▁int part ▁% ▁10 ▁] ▁; ▁int part ▁= ▁( ▁int part ▁/ ▁10 ▁) ▁; ▁} ▁while ▁( ▁int part ▁&& ▁( ▁ip lace ▁< ▁20 ▁) ▁) ▁; ▁if ▁( ▁ip lace ▁== ▁20 ▁) ▁ip lace ▁-- ▁; ▁icon vert ▁[ ▁ip lace ▁] ▁= ▁0 ▁; ▁do ▁{ ▁f convert ▁[ ▁fp lace ▁++ ▁] ▁= ▁( ▁caps ▁? ▁"0123456789 ABCDEF " ▁: ▁"0123456789 abcdef " ▁) ▁[ ▁frac part ▁% ▁10 ▁] ▁; ▁frac part ▁= ▁( ▁frac part ▁/ ▁10 ▁) ▁; ▁} ▁while ▁( ▁frac part ▁&& ▁( ▁fp lace ▁< ▁20 ▁) ▁) ▁; ▁if ▁( ▁fp lace ▁== ▁20 ▁) ▁fp lace ▁-- ▁; ▁f convert ▁[ ▁fp lace ▁] ▁= ▁0 ▁; ▁padlen ▁= ▁min ▁- ▁ip lace ▁- ▁max ▁- ▁1 ▁- ▁( ▁( ▁sign value ▁) ▁? ▁1 ▁: ▁0 ▁) ▁; ▁z pad len ▁= ▁max ▁- ▁fp lace ▁; ▁if ▁( ▁z pad len ▁< ▁0 ▁) ▁z pad len ▁= ▁0 ▁; ▁if ▁( ▁padlen ▁< ▁0 ▁) ▁padlen ▁= ▁0 ▁; ▁if ▁( ▁flags ▁& ▁DP _ F _ MINUS ▁) ▁padlen ▁= ▁- ▁padlen ▁; ▁if ▁( ▁( ▁flags ▁& ▁DP _ F _ ZERO ▁) ▁&& ▁( ▁padlen ▁> ▁0 ▁) ▁) ▁{ ▁if ▁( ▁sign value ▁) ▁{ ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁sign value ▁) ▁; ▁-- ▁padlen ▁; ▁sign value ▁= ▁0 ▁; ▁} ▁while ▁( ▁padlen ▁> ▁0 ▁) ▁{ ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁padlen ▁; ▁} ▁} ▁while ▁( ▁padlen ▁> ▁0 ▁) ▁{ ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁padlen ▁; ▁} ▁if ▁( ▁sign value ▁) ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁sign value ▁) ▁; ▁while ▁( ▁ip lace ▁> ▁0 ▁) ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁icon vert ▁[ ▁-- ▁ip lace ▁] ▁) ▁; ▁if ▁( ▁max ▁> ▁0 ▁) ▁{ ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁while ▁( ▁fp lace ▁> ▁0 ▁) ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁f convert ▁[ ▁-- ▁fp lace ▁] ▁) ▁; ▁} ▁while ▁( ▁z pad len ▁> ▁0 ▁) ▁{ ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁-- ▁z pad len ▁; ▁} ▁while ▁( ▁padlen ▁< ▁0 ▁) ▁{ ▁d opr _ out ch ▁( ▁buffer ▁, ▁curr len ▁, ▁maxlen ▁, ▁' ▁' ▁) ▁; ▁++ ▁padlen ▁; ▁} ▁}	1
▁void ▁DSA _ free ▁( ▁DSA ▁* ▁r ▁) ▁{ ▁DSA _ METHOD ▁* ▁meth ▁; ▁int ▁i ▁; ▁if ▁( ▁r ▁== ▁NULL ▁) ▁return ▁; ▁i ▁= ▁CRYPTO _ add ▁( ▁& ▁r ▁-> ▁references ▁, ▁-1 ▁, ▁CRYPTO _ LOCK _ DSA ▁) ▁; ▁# ifdef ▁REF _ PRINT ▁REF _ PRINT ▁( ▁" DSA " ▁, ▁r ▁) ▁; ▁# endif ▁if ▁( ▁i ▁> ▁0 ▁) ▁return ▁; ▁# ifdef ▁REF _ CHECK ▁if ▁( ▁i ▁< ▁0 ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" DSA _ free , bad reference count \ n " ▁) ▁; ▁abort ▁( ▁) ▁; ▁} ▁# endif ▁CRYPTO _ free _ ex _ data ▁( ▁dsa _ meth ▁, ▁r ▁, ▁& ▁r ▁-> ▁ex _ data ▁) ▁; ▁meth ▁= ▁ENGINE _ get _ DSA ▁( ▁r ▁-> ▁engine ▁) ▁; ▁if ▁( ▁meth ▁-> ▁finish ▁) ▁meth ▁-> ▁finish ▁( ▁r ▁) ▁; ▁ENGINE _ finish ▁( ▁r ▁-> ▁engine ▁) ▁; ▁if ▁( ▁r ▁-> ▁p ▁!= ▁NULL ▁) ▁BN _ clear _ free ▁( ▁r ▁-> ▁p ▁) ▁; ▁if ▁( ▁r ▁-> ▁q ▁!= ▁NULL ▁) ▁BN _ clear _ free ▁( ▁r ▁-> ▁q ▁) ▁; ▁if ▁( ▁r ▁-> ▁g ▁!= ▁NULL ▁) ▁BN _ clear _ free ▁( ▁r ▁-> ▁g ▁) ▁; ▁if ▁( ▁r ▁-> ▁pub _ key ▁!= ▁NULL ▁) ▁BN _ clear _ free ▁( ▁r ▁-> ▁pub _ key ▁) ▁; ▁if ▁( ▁r ▁-> ▁priv _ key ▁!= ▁NULL ▁) ▁BN _ clear _ free ▁( ▁r ▁-> ▁priv _ key ▁) ▁; ▁if ▁( ▁r ▁-> ▁k inv ▁!= ▁NULL ▁) ▁BN _ clear _ free ▁( ▁r ▁-> ▁k inv ▁) ▁; ▁if ▁( ▁r ▁-> ▁r ▁!= ▁NULL ▁) ▁BN _ clear _ free ▁( ▁r ▁-> ▁r ▁) ▁; ▁OPENSSL _ free ▁( ▁r ▁) ▁; ▁}	0
▁static ▁int ▁append _ to _ cached _ buf ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁D VD Sub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁if ▁( ▁ctx ▁-> ▁buf _ size ▁>= ▁sizeof ▁( ▁ctx ▁-> ▁buf ▁) ▁- ▁buf _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Attemp tt ore construct " ▁" tool arge SP Up ackets abort ed .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁memcpy ▁( ▁ctx ▁-> ▁buf ▁+ ▁ctx ▁-> ▁buf _ size ▁, ▁buf ▁, ▁buf _ size ▁) ▁; ▁ctx ▁-> ▁buf _ size ▁+= ▁buf _ size ▁; ▁return ▁0 ▁; ▁}	0
▁char ▁* ▁UI _ construct _ prompt ▁( ▁UI ▁* ▁ui ▁, ▁const ▁char ▁* ▁object _ desc ▁, ▁const ▁char ▁* ▁object _ name ▁) ▁{ ▁char ▁* ▁prompt ▁= ▁NULL ▁; ▁if ▁( ▁ui ▁-> ▁meth ▁-> ▁ui _ construct _ prompt ▁) ▁prompt ▁= ▁ui ▁-> ▁meth ▁-> ▁ui _ construct _ prompt ▁( ▁ui ▁, ▁object _ desc ▁, ▁object _ name ▁) ▁; ▁else ▁{ ▁char ▁prompt 1 ▁[ ▁] ▁= ▁" Enter " ▁; ▁char ▁prompt 2 ▁[ ▁] ▁= ▁" for " ▁; ▁char ▁prompt 3 ▁[ ▁] ▁= ▁":" ▁; ▁int ▁len ▁= ▁0 ▁; ▁if ▁( ▁object _ desc ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁len ▁= ▁sizeof ▁( ▁prompt 1 ▁) ▁- ▁1 ▁+ ▁strlen ▁( ▁object _ desc ▁) ▁; ▁if ▁( ▁object _ name ▁) ▁len ▁+= ▁sizeof ▁( ▁prompt 2 ▁) ▁- ▁1 ▁+ ▁strlen ▁( ▁object _ name ▁) ▁; ▁len ▁+= ▁sizeof ▁( ▁prompt 3 ▁) ▁- ▁1 ▁; ▁prompt ▁= ▁( ▁char ▁* ▁) ▁OPENSSL _ malloc ▁( ▁len ▁+ ▁1 ▁) ▁; ▁strcpy ▁( ▁prompt ▁, ▁prompt 1 ▁) ▁; ▁strcat ▁( ▁prompt ▁, ▁object _ desc ▁) ▁; ▁if ▁( ▁object _ name ▁) ▁{ ▁strcat ▁( ▁prompt ▁, ▁prompt 2 ▁) ▁; ▁strcat ▁( ▁prompt ▁, ▁object _ name ▁) ▁; ▁} ▁strcat ▁( ▁prompt ▁, ▁prompt 3 ▁) ▁; ▁} ▁return ▁prompt ▁; ▁}	1
▁int ▁BN _ mul ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁int ▁top ▁, ▁al ▁, ▁bl ▁; ▁BIGNUM ▁* ▁rr ▁; ▁# if ▁defined ▁( ▁BN _ MUL _ COMB A ▁) ▁|| ▁defined ▁( ▁BN _ RECUR SION ▁) ▁int ▁i ▁; ▁# endif ▁# ifdef ▁BN _ RECUR SION ▁BIGNUM ▁* ▁t ▁= ▁NULL ▁; ▁int ▁j ▁= ▁0 ▁, ▁k ▁; ▁# endif ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁al ▁= ▁a ▁-> ▁top ▁; ▁bl ▁= ▁b ▁-> ▁top ▁; ▁if ▁( ▁( ▁al ▁== ▁0 ▁) ▁|| ▁( ▁bl ▁== ▁0 ▁) ▁) ▁{ ▁BN _ zero ▁( ▁r ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁} ▁top ▁= ▁al ▁+ ▁bl ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁if ▁( ▁( ▁r ▁== ▁a ▁) ▁|| ▁( ▁r ▁== ▁b ▁) ▁) ▁{ ▁if ▁( ▁( ▁rr ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁else ▁rr ▁= ▁r ▁; ▁rr ▁-> ▁neg ▁= ▁a ▁-> ▁neg ▁ ^ ▁b ▁-> ▁neg ▁; ▁# if ▁defined ▁( ▁BN _ MUL _ COMB A ▁) ▁|| ▁defined ▁( ▁BN _ RECUR SION ▁) ▁i ▁= ▁al ▁- ▁bl ▁; ▁# endif ▁# ifdef ▁BN _ MUL _ COMB A ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁# if ▁0 ▁if ▁( ▁al ▁== ▁4 ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁8 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁rr ▁-> ▁top ▁= ▁8 ▁; ▁bn _ mul _ com ba 4 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁) ▁; ▁goto ▁end ▁; ▁} ▁# endif ▁if ▁( ▁al ▁== ▁8 ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁16 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁rr ▁-> ▁top ▁= ▁16 ▁; ▁bn _ mul _ com ba 8 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁) ▁; ▁goto ▁end ▁; ▁} ▁} ▁# endif ▁# ifdef ▁BN _ RECUR SION ▁if ▁( ▁( ▁al ▁>= ▁BN _ M ULL _ SIZE _ NORMAL ▁) ▁&& ▁( ▁bl ▁>= ▁BN _ M ULL _ SIZE _ NORMAL ▁) ▁) ▁{ ▁if ▁( ▁i ▁>= ▁-1 ▁&& ▁i ▁<= ▁1 ▁) ▁{ ▁if ▁( ▁i ▁>= ▁0 ▁) ▁{ ▁j ▁= ▁BN _ num _ bits _ word ▁( ▁( ▁BN _ ULONG ▁) ▁al ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁-1 ▁) ▁{ ▁j ▁= ▁BN _ num _ bits _ word ▁( ▁( ▁BN _ ULONG ▁) ▁bl ▁) ▁; ▁} ▁j ▁= ▁1 ▁<< ▁( ▁j ▁- ▁1 ▁) ▁; ▁assert ▁( ▁j ▁<= ▁al ▁|| ▁j ▁<= ▁bl ▁) ▁; ▁k ▁= ▁j ▁+ ▁j ▁; ▁t ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁t ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁al ▁> ▁j ▁|| ▁bl ▁> ▁j ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁t ▁, ▁k ▁* ▁4 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁k ▁* ▁4 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ mul _ part _ recursive ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁, ▁j ▁, ▁al ▁- ▁j ▁, ▁bl ▁- ▁j ▁, ▁t ▁-> ▁d ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁t ▁, ▁k ▁* ▁2 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁k ▁* ▁2 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ mul _ recursive ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁, ▁j ▁, ▁al ▁- ▁j ▁, ▁bl ▁- ▁j ▁, ▁t ▁-> ▁d ▁) ▁; ▁} ▁rr ▁-> ▁top ▁= ▁top ▁; ▁goto ▁end ▁; ▁} ▁# if ▁0 ▁if ▁( ▁i ▁== ▁1 ▁&& ▁! ▁BN _ get _ flags ▁( ▁b ▁, ▁BN _ FLG _ STATIC _ DATA ▁) ▁) ▁{ ▁BIGNUM ▁* ▁tmp _ bn ▁= ▁( ▁BIGNUM ▁* ▁) ▁b ▁; ▁if ▁( ▁bn _ w expand ▁( ▁tmp _ bn ▁, ▁al ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁tmp _ bn ▁-> ▁d ▁[ ▁bl ▁] ▁= ▁0 ▁; ▁bl ▁++ ▁; ▁i ▁-- ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁-1 ▁&& ▁! ▁BN _ get _ flags ▁( ▁a ▁, ▁BN _ FLG _ STATIC _ DATA ▁) ▁) ▁{ ▁BIGNUM ▁* ▁tmp _ bn ▁= ▁( ▁BIGNUM ▁* ▁) ▁a ▁; ▁if ▁( ▁bn _ w expand ▁( ▁tmp _ bn ▁, ▁bl ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁tmp _ bn ▁-> ▁d ▁[ ▁al ▁] ▁= ▁0 ▁; ▁al ▁++ ▁; ▁i ▁++ ▁; ▁} ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁j ▁= ▁BN _ num _ bits _ word ▁( ▁( ▁BN _ ULONG ▁) ▁al ▁) ▁; ▁j ▁= ▁1 ▁<< ▁( ▁j ▁- ▁1 ▁) ▁; ▁k ▁= ▁j ▁+ ▁j ▁; ▁t ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁al ▁== ▁j ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁t ▁, ▁k ▁* ▁2 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁k ▁* ▁2 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ mul _ recursive ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁, ▁al ▁, ▁t ▁-> ▁d ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁t ▁, ▁k ▁* ▁4 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁k ▁* ▁4 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ mul _ part _ recursive ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁, ▁al ▁- ▁j ▁, ▁j ▁, ▁t ▁-> ▁d ▁) ▁; ▁} ▁rr ▁-> ▁top ▁= ▁top ▁; ▁goto ▁end ▁; ▁} ▁# endif ▁} ▁# endif ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁top ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁rr ▁-> ▁top ▁= ▁top ▁; ▁bn _ mul _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁b ▁-> ▁d ▁, ▁bl ▁) ▁; ▁# if ▁defined ▁( ▁BN _ MUL _ COMB A ▁) ▁|| ▁defined ▁( ▁BN _ RECUR SION ▁) ▁end ▁: ▁# endif ▁bn _ correct _ top ▁( ▁rr ▁) ▁; ▁if ▁( ▁r ▁!= ▁rr ▁) ▁BN _ copy ▁( ▁r ▁, ▁rr ▁) ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁static ▁int ▁b nr and ▁( ▁int ▁p seud or and ▁, ▁BIGNUM ▁* ▁rnd ▁, ▁int ▁bits ▁, ▁int ▁top ▁, ▁int ▁bottom ▁) ▁{ ▁unsigned ▁char ▁* ▁buf ▁= ▁NULL ▁; ▁int ▁ret ▁= ▁0 ▁, ▁bit ▁, ▁bytes ▁, ▁mask ▁; ▁time _ t ▁tim ▁; ▁if ▁( ▁bits ▁< ▁0 ▁|| ▁( ▁bits ▁== ▁1 ▁&& ▁top ▁> ▁0 ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN RAND ▁, ▁BN _ R _ BITS _ TOO _ SMALL ▁) ▁; ▁return ▁0 ▁; ▁} ▁if ▁( ▁bits ▁== ▁0 ▁) ▁{ ▁BN _ zero ▁( ▁rnd ▁) ▁; ▁return ▁1 ▁; ▁} ▁bytes ▁= ▁( ▁bits ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁bit ▁= ▁( ▁bits ▁- ▁1 ▁) ▁% ▁8 ▁; ▁mask ▁= ▁0 xff ▁<< ▁( ▁bit ▁+ ▁1 ▁) ▁; ▁buf ▁= ▁OPENSSL _ malloc ▁( ▁bytes ▁) ▁; ▁if ▁( ▁buf ▁== ▁NULL ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN RAND ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁time ▁( ▁& ▁tim ▁) ▁; ▁RAND _ add ▁( ▁& ▁tim ▁, ▁sizeof ▁( ▁tim ▁) ▁, ▁0.0 ▁) ▁; ▁if ▁( ▁RAND _ bytes ▁( ▁buf ▁, ▁bytes ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁p seud or and ▁== ▁2 ▁) ▁{ ▁int ▁i ▁; ▁unsigned ▁char ▁c ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁bytes ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁RAND _ bytes ▁( ▁& ▁c ▁, ▁1 ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁c ▁>= ▁128 ▁&& ▁i ▁> ▁0 ▁) ▁buf ▁[ ▁i ▁] ▁= ▁buf ▁[ ▁i ▁- ▁1 ▁] ▁; ▁else ▁if ▁( ▁c ▁< ▁42 ▁) ▁buf ▁[ ▁i ▁] ▁= ▁0 ▁; ▁else ▁if ▁( ▁c ▁< ▁84 ▁) ▁buf ▁[ ▁i ▁] ▁= ▁255 ▁; ▁} ▁} ▁if ▁( ▁top ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁top ▁) ▁{ ▁if ▁( ▁bit ▁== ▁0 ▁) ▁{ ▁buf ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁buf ▁[ ▁1 ▁] ▁|= ▁0 x 80 ▁; ▁} ▁else ▁{ ▁buf ▁[ ▁0 ▁] ▁|= ▁( ▁3 ▁<< ▁( ▁bit ▁- ▁1 ▁) ▁) ▁; ▁} ▁} ▁else ▁{ ▁buf ▁[ ▁0 ▁] ▁|= ▁( ▁1 ▁<< ▁bit ▁) ▁; ▁} ▁} ▁buf ▁[ ▁0 ▁] ▁&= ▁ ~ ▁mask ▁; ▁if ▁( ▁bottom ▁) ▁buf ▁[ ▁bytes ▁- ▁1 ▁] ▁|= ▁1 ▁; ▁if ▁( ▁! ▁BN _ bin 2 bn ▁( ▁buf ▁, ▁bytes ▁, ▁rnd ▁) ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁OPENSSL _ clear _ free ▁( ▁buf ▁, ▁bytes ▁) ▁; ▁bn _ check _ top ▁( ▁rnd ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁static ▁void ▁assert _ file _ over write ▁( ▁const ▁char ▁* ▁filename ▁) ▁{ ▁if ▁( ▁file _ over write ▁&& ▁no _ file _ over write ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Error , both - y and - ns upp lied . Exit ing .\ n " ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁if ▁( ▁! ▁file _ over write ▁) ▁{ ▁const ▁char ▁* ▁proto _ name ▁= ▁avio _ find _ protocol _ name ▁( ▁filename ▁) ▁; ▁if ▁( ▁proto _ name ▁&& ▁! ▁strcmp ▁( ▁proto _ name ▁, ▁" file " ▁) ▁&& ▁avio _ check ▁( ▁filename ▁, ▁0 ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁stdin _ inter action ▁&& ▁! ▁no _ file _ over write ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" File ' % s ' already exists . Overwrite ? [ y / N ]" ▁, ▁filename ▁) ▁; ▁fflush ▁( ▁stderr ▁) ▁; ▁term _ exit ▁( ▁) ▁; ▁signal ▁( ▁SIGINT ▁, ▁SIG _ DFL ▁) ▁; ▁if ▁( ▁! ▁read _ yes no ▁( ▁) ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ FATAL ▁, ▁" Not over writing - exit ing \ n " ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁term _ init ▁( ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ FATAL ▁, ▁" File ' % s ' already exists . Exit ing .\ n " ▁, ▁filename ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁} ▁} ▁}	0
▁int ▁ff _ d ca _ core _ parse ▁( ▁DC AC ore Decoder ▁* ▁s ▁, ▁uint 8_ t ▁* ▁data ▁, ▁int ▁size ▁) ▁{ ▁int ▁ret ▁; ▁s ▁-> ▁ext _ audio _ mask ▁= ▁0 ▁; ▁s ▁-> ▁x ch _ pos ▁= ▁s ▁-> ▁xx ch _ pos ▁= ▁s ▁-> ▁x 96_ pos ▁= ▁0 ▁; ▁if ▁( ▁( ▁ret ▁= ▁init _ get _ bits 8 ▁( ▁& ▁s ▁-> ▁gb ▁, ▁data ▁, ▁size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁s ▁-> ▁gb _ in ▁= ▁s ▁-> ▁gb ▁; ▁if ▁( ▁( ▁ret ▁= ▁parse _ frame _ header ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁alloc _ sample _ buffer ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁parse _ frame _ data ▁( ▁s ▁, ▁HEADER _ CORE ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁ret ▁= ▁parse _ optional _ info ▁( ▁s ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁s ▁-> ▁frame _ size ▁> ▁size ▁&& ▁s ▁-> ▁frame _ size ▁< ▁size ▁+ ▁4 ▁) ▁s ▁-> ▁frame _ size ▁= ▁size ▁; ▁if ▁( ▁ff _ d ca _ seek _ bits ▁( ▁& ▁s ▁-> ▁gb ▁, ▁s ▁-> ▁frame _ size ▁* ▁8 ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Read p ast end of co ref rame \ n " ▁) ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁err _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁AP _ DECLARE ▁( ▁void ▁) ▁ap _ get _ mime _ headers _ core ▁( ▁request _ rec ▁* ▁r ▁, ▁apr _ bucket _ b rig ade ▁* ▁bb ▁) ▁{ ▁char ▁* ▁last _ field ▁= ▁NULL ▁; ▁apr _ size _ t ▁last _ len ▁= ▁0 ▁; ▁apr _ size _ t ▁alloc _ len ▁= ▁0 ▁; ▁char ▁* ▁field ▁; ▁char ▁* ▁value ▁; ▁apr _ size _ t ▁len ▁; ▁int ▁fields _ read ▁= ▁0 ▁; ▁char ▁* ▁tmp _ field ▁; ▁core _ server _ config ▁* ▁conf ▁= ▁ap _ get _ core _ module _ config ▁( ▁r ▁-> ▁server ▁-> ▁module _ config ▁) ▁; ▁int ▁strict ▁= ▁( ▁conf ▁-> ▁http _ con formance ▁!= ▁AP _ HTTP _ CON FORM ANCE _ UN SAFE ▁) ▁; ▁while ▁( ▁1 ▁) ▁{ ▁apr _ status _ t ▁rv ▁; ▁field ▁= ▁NULL ▁; ▁rv ▁= ▁ap _ r get line ▁( ▁& ▁field ▁, ▁r ▁-> ▁server ▁-> ▁limit _ req _ field size ▁+ ▁2 ▁, ▁& ▁len ▁, ▁r ▁, ▁strict ▁? ▁AP _ GET LINE _ CR LF ▁: ▁0 ▁, ▁bb ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁if ▁( ▁APR _ STATUS _ IS _ TIME UP ▁( ▁rv ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ REQUEST _ TIME _ OUT ▁; ▁} ▁else ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁} ▁if ▁( ▁rv ▁== ▁APR _ ENO SPC ▁) ▁{ ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Size of are quest header field " ▁" e xce ed ss erver limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 1 ▁) ▁" Request header e xce eds Limit Request Field Size % s " ▁"%.* s " ▁, ▁( ▁field ▁&& ▁* ▁field ▁) ▁? ▁":" ▁: ▁"" ▁, ▁( ▁field ▁) ▁? ▁field _ name _ len ▁( ▁field ▁) ▁: ▁0 ▁, ▁( ▁field ▁) ▁? ▁field ▁: ▁"" ▁) ▁; ▁} ▁return ▁; ▁} ▁while ▁( ▁len ▁> ▁1 ▁&& ▁( ▁field ▁[ ▁len ▁- ▁1 ▁] ▁== ▁' ▁\ t ▁' ▁|| ▁field ▁[ ▁len ▁- ▁1 ▁] ▁== ▁' ▁' ▁) ▁) ▁{ ▁field ▁[ ▁-- ▁len ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁* ▁field ▁== ▁' ▁\ t ▁' ▁|| ▁* ▁field ▁== ▁' ▁' ▁) ▁{ ▁apr _ size _ t ▁fold _ len ▁; ▁if ▁( ▁last _ field ▁== ▁NULL ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 42 ▁) ▁" Line f olding en countered be fo ref irst " ▁" header line " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁field ▁[ ▁1 ▁] ▁== ▁' ▁\0 ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 43 ▁) ▁" Empty fol ded line en countered " ▁) ▁; ▁return ▁; ▁} ▁while ▁( ▁field ▁[ ▁1 ▁] ▁== ▁' ▁\ t ▁' ▁|| ▁field ▁[ ▁1 ▁] ▁== ▁' ▁' ▁) ▁{ ▁++ ▁field ▁; ▁-- ▁len ▁; ▁} ▁fold _ len ▁= ▁last _ len ▁+ ▁len ▁+ ▁1 ▁; ▁if ▁( ▁fold _ len ▁>= ▁( ▁apr _ size _ t ▁) ▁( ▁r ▁-> ▁server ▁-> ▁limit _ req _ field size ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Size of are quest header field " ▁" e xce ed ss erver limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 2 ▁) ▁" Request header e xce eds Limit Request Field Size " ▁" after f olding :% .* s " ▁, ▁field _ name _ len ▁( ▁last _ field ▁) ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁fold _ len ▁> ▁alloc _ len ▁) ▁{ ▁char ▁* ▁fold _ buf ▁; ▁alloc _ len ▁+= ▁alloc _ len ▁; ▁if ▁( ▁fold _ len ▁> ▁alloc _ len ▁) ▁{ ▁alloc _ len ▁= ▁fold _ len ▁; ▁} ▁fold _ buf ▁= ▁( ▁char ▁* ▁) ▁apr _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁alloc _ len ▁) ▁; ▁memcpy ▁( ▁fold _ buf ▁, ▁last _ field ▁, ▁last _ len ▁) ▁; ▁last _ field ▁= ▁fold _ buf ▁; ▁} ▁memcpy ▁( ▁last _ field ▁+ ▁last _ len ▁, ▁field ▁, ▁len ▁+ ▁1 ▁) ▁; ▁last _ field ▁[ ▁last _ len ▁] ▁= ▁' ▁' ▁; ▁last _ len ▁+= ▁len ▁; ▁continue ▁; ▁} ▁else ▁if ▁( ▁last _ field ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁r ▁-> ▁server ▁-> ▁limit _ req _ fields ▁&& ▁( ▁++ ▁fields _ read ▁> ▁r ▁-> ▁server ▁-> ▁limit _ req _ fields ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁apr _ table _ set n ▁( ▁r ▁-> ▁notes ▁, ▁" error - notes " ▁, ▁" Th enum ber of request header fields " ▁" e xce ed sth iss erver ' s limit ." ▁) ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ INFO ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁00 56 3 ▁) ▁" Number of request header se xce eds " ▁" Limit Request Fields " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁strict ▁) ▁{ ▁if ▁( ▁! ▁( ▁value ▁= ▁strchr ▁( ▁last _ field ▁, ▁' ▁' ▁) ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 05 64 ▁) ▁" Request header field ism issing ': '" ▁" separator :% .* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁tmp _ field ▁= ▁value ▁- ▁( ▁value ▁> ▁last _ field ▁? ▁1 ▁: ▁0 ▁) ▁; ▁* ▁value ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁strp brk ▁( ▁last _ field ▁, ▁"\ t \ n \ v \ f \ r " ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 52 ▁) ▁" Request header field name present ed " ▁" invalid whitespace " ▁) ▁; ▁return ▁; ▁} ▁while ▁( ▁* ▁value ▁== ▁' ▁' ▁|| ▁* ▁value ▁== ▁' ▁\ t ▁' ▁) ▁{ ▁++ ▁value ▁; ▁} ▁if ▁( ▁strp brk ▁( ▁value ▁, ▁"\ n \ v \ f \ r " ▁) ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 51 ▁) ▁" Request header field value present ed " ▁" bad whitespace " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁tmp _ field ▁== ▁last _ field ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 34 53 ▁) ▁" Request header field name w ase mpty " ▁) ▁; ▁return ▁; ▁} ▁} ▁else ▁{ ▁value ▁= ▁( ▁char ▁* ▁) ▁ap _ scan _ http _ token ▁( ▁last _ field ▁) ▁; ▁if ▁( ▁( ▁value ▁== ▁last _ field ▁) ▁|| ▁* ▁value ▁!= ▁' ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 24 26 ▁) ▁" Request header field name ism alformed :" ▁"%.* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁last _ field ▁) ▁; ▁return ▁; ▁} ▁* ▁value ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁while ▁( ▁* ▁value ▁== ▁' ▁' ▁|| ▁* ▁value ▁== ▁' ▁\ t ▁' ▁) ▁{ ▁++ ▁value ▁; ▁} ▁tmp _ field ▁= ▁( ▁char ▁* ▁) ▁ap _ scan _ http _ field _ content ▁( ▁value ▁) ▁; ▁if ▁( ▁* ▁tmp _ field ▁!= ▁' ▁\0 ▁' ▁) ▁{ ▁r ▁-> ▁status ▁= ▁HTTP _ BAD _ REQUEST ▁; ▁ap _ log _ r error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ DEBUG ▁, ▁0 ▁, ▁r ▁, ▁AP LOG NO ▁( ▁0 24 27 ▁) ▁" Request header value ism alformed :" ▁"%.* s " ▁, ▁( ▁int ▁) ▁LOG _ NAME _ MAX _ LEN ▁, ▁value ▁) ▁; ▁return ▁; ▁} ▁} ▁apr _ table _ add n ▁( ▁r ▁-> ▁headers _ in ▁, ▁last _ field ▁, ▁value ▁) ▁; ▁} ▁if ▁( ▁len ▁== ▁0 ▁) ▁{ ▁break ▁; ▁} ▁alloc _ len ▁= ▁0 ▁; ▁last _ field ▁= ▁field ▁; ▁last _ len ▁= ▁len ▁; ▁} ▁apr _ table _ compress ▁( ▁r ▁-> ▁headers _ in ▁, ▁APR _ OVER LAP _ TABLES _ MERGE ▁) ▁; ▁apr _ table _ do ▁( ▁table _ do _ fn _ check _ length s ▁, ▁r ▁, ▁r ▁-> ▁headers _ in ▁, ▁NULL ▁) ▁; ▁}	0
▁int ▁X 509_ NAME _ cmp ▁( ▁const ▁X 509_ NAME ▁* ▁a ▁, ▁const ▁X 509_ NAME ▁* ▁b ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁X 509_ NAME _ ENTRY ▁* ▁na ▁, ▁* ▁nb ▁; ▁if ▁( ▁sk _ X 509_ NAME _ ENTRY _ num ▁( ▁a ▁-> ▁entries ▁) ▁!= ▁sk _ X 509_ NAME _ ENTRY _ num ▁( ▁b ▁-> ▁entries ▁) ▁) ▁return ▁sk _ X 509_ NAME _ ENTRY _ num ▁( ▁a ▁-> ▁entries ▁) ▁- ▁sk _ X 509_ NAME _ ENTRY _ num ▁( ▁b ▁-> ▁entries ▁) ▁; ▁for ▁( ▁i ▁= ▁sk _ X 509_ NAME _ ENTRY _ num ▁( ▁a ▁-> ▁entries ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁na ▁= ▁sk _ X 509_ NAME _ ENTRY _ value ▁( ▁a ▁-> ▁entries ▁, ▁i ▁) ▁; ▁nb ▁= ▁sk _ X 509_ NAME _ ENTRY _ value ▁( ▁b ▁-> ▁entries ▁, ▁i ▁) ▁; ▁j ▁= ▁na ▁-> ▁value ▁-> ▁length ▁- ▁nb ▁-> ▁value ▁-> ▁length ▁; ▁if ▁( ▁j ▁) ▁return ▁( ▁j ▁) ▁; ▁j ▁= ▁memcmp ▁( ▁na ▁-> ▁value ▁-> ▁data ▁, ▁nb ▁-> ▁value ▁-> ▁data ▁, ▁na ▁-> ▁value ▁-> ▁length ▁) ▁; ▁if ▁( ▁j ▁) ▁return ▁( ▁j ▁) ▁; ▁j ▁= ▁na ▁-> ▁set ▁- ▁nb ▁-> ▁set ▁; ▁if ▁( ▁j ▁) ▁return ▁( ▁j ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁sk _ X 509_ NAME _ ENTRY _ num ▁( ▁a ▁-> ▁entries ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁na ▁= ▁sk _ X 509_ NAME _ ENTRY _ value ▁( ▁a ▁-> ▁entries ▁, ▁i ▁) ▁; ▁nb ▁= ▁sk _ X 509_ NAME _ ENTRY _ value ▁( ▁b ▁-> ▁entries ▁, ▁i ▁) ▁; ▁j ▁= ▁OBJ _ cmp ▁( ▁na ▁-> ▁object ▁, ▁nb ▁-> ▁object ▁) ▁; ▁if ▁( ▁j ▁) ▁return ▁( ▁j ▁) ▁; ▁} ▁return ▁( ▁0 ▁) ▁; ▁}	1
▁int ▁ff _ he vc _ split _ packet ▁( ▁H EV CP acket ▁* ▁pkt ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁length ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁int ▁is _ n al ff ▁, ▁int ▁nal _ length _ size ▁) ▁{ ▁int ▁consumed ▁, ▁ret ▁= ▁0 ▁; ▁pkt ▁-> ▁nb _ n als ▁= ▁0 ▁; ▁while ▁( ▁length ▁>= ▁4 ▁) ▁{ ▁H EV CN AL ▁* ▁nal ▁; ▁int ▁extract _ length ▁= ▁0 ▁; ▁if ▁( ▁is _ n al ff ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nal _ length _ size ▁; ▁i ▁++ ▁) ▁extract _ length ▁= ▁( ▁extract _ length ▁<< ▁8 ▁) ▁| ▁buf ▁[ ▁i ▁] ▁; ▁buf ▁+= ▁nal _ length _ size ▁; ▁length ▁-= ▁nal _ length _ size ▁; ▁if ▁( ▁extract _ length ▁> ▁length ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid NAL unit size .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁else ▁{ ▁while ▁( ▁buf ▁[ ▁0 ▁] ▁!= ▁0 ▁|| ▁buf ▁[ ▁1 ▁] ▁!= ▁0 ▁|| ▁buf ▁[ ▁2 ▁] ▁!= ▁1 ▁) ▁{ ▁++ ▁buf ▁; ▁-- ▁length ▁; ▁if ▁( ▁length ▁< ▁4 ▁) ▁{ ▁if ▁( ▁pkt ▁-> ▁nb _ n als ▁> ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" N ostart code is found .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁} ▁buf ▁+= ▁3 ▁; ▁length ▁-= ▁3 ▁; ▁extract _ length ▁= ▁length ▁; ▁} ▁if ▁( ▁pkt ▁-> ▁n als _ allocated ▁< ▁pkt ▁-> ▁nb _ n als ▁+ ▁1 ▁) ▁{ ▁int ▁new _ size ▁= ▁pkt ▁-> ▁n als _ allocated ▁+ ▁1 ▁; ▁void ▁* ▁tmp ▁= ▁av _ realloc _ array ▁( ▁pkt ▁-> ▁n als ▁, ▁new _ size ▁, ▁sizeof ▁( ▁* ▁pkt ▁-> ▁n als ▁) ▁) ▁; ▁if ▁( ▁! ▁tmp ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁pkt ▁-> ▁n als ▁= ▁tmp ▁; ▁memset ▁( ▁pkt ▁-> ▁n als ▁+ ▁pkt ▁-> ▁n als _ allocated ▁, ▁0 ▁, ▁( ▁new _ size ▁- ▁pkt ▁-> ▁n als _ allocated ▁) ▁* ▁sizeof ▁( ▁* ▁pkt ▁-> ▁n als ▁) ▁) ▁; ▁nal ▁= ▁& ▁pkt ▁-> ▁n als ▁[ ▁pkt ▁-> ▁nb _ n als ▁] ▁; ▁nal ▁-> ▁skipped _ bytes _ pos _ size ▁= ▁1024 ▁; ▁nal ▁-> ▁skipped _ bytes _ pos ▁= ▁av _ malloc _ array ▁( ▁nal ▁-> ▁skipped _ bytes _ pos _ size ▁, ▁sizeof ▁( ▁* ▁nal ▁-> ▁skipped _ bytes _ pos ▁) ▁) ▁; ▁if ▁( ▁! ▁nal ▁-> ▁skipped _ bytes _ pos ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁pkt ▁-> ▁n als _ allocated ▁= ▁new _ size ▁; ▁} ▁nal ▁= ▁& ▁pkt ▁-> ▁n als ▁[ ▁pkt ▁-> ▁nb _ n als ▁] ▁; ▁consumed ▁= ▁ff _ he vc _ extract _ rb sp ▁( ▁buf ▁, ▁extract _ length ▁, ▁nal ▁) ▁; ▁if ▁( ▁consumed ▁< ▁0 ▁) ▁return ▁consumed ▁; ▁pkt ▁-> ▁nb _ n als ▁++ ▁; ▁ret ▁= ▁init _ get _ bits 8 ▁( ▁& ▁nal ▁-> ▁gb ▁, ▁nal ▁-> ▁data ▁, ▁nal ▁-> ▁size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁ret ▁= ▁h ls _ n al _ unit ▁( ▁nal ▁, ▁avctx ▁) ▁; ▁if ▁( ▁ret ▁<= ▁0 ▁) ▁{ ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid NAL unit % d , sk ipping .\ n " ▁, ▁nal ▁-> ▁type ▁) ▁; ▁} ▁pkt ▁-> ▁nb _ n als ▁-- ▁; ▁} ▁buf ▁+= ▁consumed ▁; ▁length ▁-= ▁consumed ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁avi _ write _ trail er ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁AV I Context ▁* ▁avi ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int ▁res ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁, ▁n ▁, ▁nb _ frames ▁; ▁int 64_ t ▁file _ size ▁; ▁if ▁( ▁pb ▁-> ▁seek able ▁& ▁AVIO _ SEEK ABLE _ NORMAL ▁) ▁{ ▁if ▁( ▁avi ▁-> ▁ri ff _ id ▁== ▁1 ▁) ▁{ ▁ff _ end _ tag ▁( ▁pb ▁, ▁avi ▁-> ▁mov i _ list ▁) ▁; ▁res ▁= ▁avi _ write _ idx 1 ▁( ▁s ▁) ▁; ▁ff _ end _ tag ▁( ▁pb ▁, ▁avi ▁-> ▁ri ff _ start ▁) ▁; ▁} ▁else ▁{ ▁avi _ write _ ix ▁( ▁s ▁) ▁; ▁ff _ end _ tag ▁( ▁pb ▁, ▁avi ▁-> ▁mov i _ list ▁) ▁; ▁ff _ end _ tag ▁( ▁pb ▁, ▁avi ▁-> ▁ri ff _ start ▁) ▁; ▁file _ size ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁avi ▁-> ▁od ml _ list ▁- ▁8 ▁, ▁SEEK _ SET ▁) ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁" LIST " ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁16 ▁) ▁; ▁for ▁( ▁n ▁= ▁nb _ frames ▁= ▁0 ▁; ▁n ▁< ▁s ▁-> ▁nb _ streams ▁; ▁n ▁++ ▁) ▁{ ▁AVCodec Parameters ▁* ▁par ▁= ▁s ▁-> ▁streams ▁[ ▁n ▁] ▁-> ▁codecpar ▁; ▁AV I Stream ▁* ▁av ist ▁= ▁s ▁-> ▁streams ▁[ ▁n ▁] ▁-> ▁priv _ data ▁; ▁if ▁( ▁par ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁if ▁( ▁nb _ frames ▁< ▁av ist ▁-> ▁packet _ count ▁) ▁nb _ frames ▁= ▁av ist ▁-> ▁packet _ count ▁; ▁} ▁else ▁{ ▁if ▁( ▁par ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MP 2 ▁|| ▁par ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MP 3 ▁) ▁nb _ frames ▁+= ▁av ist ▁-> ▁packet _ count ▁; ▁} ▁} ▁avio _ wl 32 ▁( ▁pb ▁, ▁nb _ frames ▁) ▁; ▁avio _ seek ▁( ▁pb ▁, ▁file _ size ▁, ▁SEEK _ SET ▁) ▁; ▁avi _ write _ counters ▁( ▁s ▁, ▁avi ▁-> ▁ri ff _ id ▁) ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AV I Stream ▁* ▁av ist ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁priv _ data ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁av ist ▁-> ▁indexes ▁. ▁ent s _ allocated ▁/ ▁AV I _ INDEX _ CLUSTER _ SIZE ▁; ▁j ▁++ ▁) ▁av _ free ▁( ▁av ist ▁-> ▁indexes ▁. ▁cluster ▁[ ▁j ▁] ▁) ▁; ▁av _ freep ▁( ▁& ▁av ist ▁-> ▁indexes ▁. ▁cluster ▁) ▁; ▁av ist ▁-> ▁indexes ▁. ▁ent s _ allocated ▁= ▁av ist ▁-> ▁indexes ▁. ▁entry ▁= ▁0 ▁; ▁} ▁return ▁res ▁; ▁}	0
▁static ▁void ▁vc 1_ decode _ b _ blocks ▁( ▁VC 1 Context ▁* ▁v ▁) ▁{ ▁Mpeg Enc Context ▁* ▁s ▁= ▁& ▁v ▁-> ▁s ▁; ▁switch ▁( ▁v ▁-> ▁c _ ac _ table _ index ▁) ▁{ ▁case ▁0 ▁: ▁v ▁-> ▁coding set ▁= ▁( ▁v ▁-> ▁pq index ▁<= ▁8 ▁) ▁? ▁CS _ HIGH _ RATE _ INTR A ▁: ▁CS _ LOW _ MO T _ INTR A ▁; ▁break ▁; ▁case ▁1 ▁: ▁v ▁-> ▁coding set ▁= ▁CS _ HIGH _ MO T _ INTR A ▁; ▁break ▁; ▁case ▁2 ▁: ▁v ▁-> ▁coding set ▁= ▁CS _ MID _ RATE _ INTR A ▁; ▁break ▁; ▁} ▁switch ▁( ▁v ▁-> ▁c _ ac _ table _ index ▁) ▁{ ▁case ▁0 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁( ▁v ▁-> ▁pq index ▁<= ▁8 ▁) ▁? ▁CS _ HIGH _ RATE _ INTER ▁: ▁CS _ LOW _ MO T _ INTER ▁; ▁break ▁; ▁case ▁1 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁CS _ HIGH _ MO T _ INTER ▁; ▁break ▁; ▁case ▁2 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁CS _ MID _ RATE _ INTER ▁; ▁break ▁; ▁} ▁s ▁-> ▁first _ slice _ line ▁= ▁1 ▁; ▁for ▁( ▁s ▁-> ▁mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁mb _ y ▁< ▁s ▁-> ▁mb _ height ▁; ▁s ▁-> ▁mb _ y ▁++ ▁) ▁{ ▁for ▁( ▁s ▁-> ▁mb _ x ▁= ▁0 ▁; ▁s ▁-> ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁s ▁-> ▁mb _ x ▁++ ▁) ▁{ ▁ff _ init _ block _ index ▁( ▁s ▁) ▁; ▁ff _ update _ block _ index ▁( ▁s ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁clear _ blocks ▁( ▁s ▁-> ▁block ▁[ ▁0 ▁] ▁) ▁; ▁vc 1_ decode _ b _ mb ▁( ▁v ▁) ▁; ▁if ▁( ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁> ▁v ▁-> ▁bits ▁|| ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁< ▁0 ▁) ▁{ ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁0 ▁, ▁0 ▁, ▁s ▁-> ▁mb _ x ▁, ▁s ▁-> ▁mb _ y ▁, ▁( ▁AC _ END ▁| ▁DC _ END ▁| ▁MV _ END ▁) ▁) ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bits over cons umption :% i >% i at % ix % i \ n " ▁, ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁, ▁v ▁-> ▁bits ▁, ▁s ▁-> ▁mb _ x ▁, ▁s ▁-> ▁mb _ y ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁v ▁-> ▁s ▁. ▁loop _ filter ▁) ▁vc 1_ loop _ filter _ ib lk ▁( ▁s ▁, ▁v ▁-> ▁pq ▁) ▁; ▁} ▁ff _ draw _ h oriz _ band ▁( ▁s ▁, ▁s ▁-> ▁mb _ y ▁* ▁16 ▁, ▁16 ▁) ▁; ▁s ▁-> ▁first _ slice _ line ▁= ▁0 ▁; ▁} ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁0 ▁, ▁0 ▁, ▁s ▁-> ▁mb _ width ▁- ▁1 ▁, ▁s ▁-> ▁mb _ height ▁- ▁1 ▁, ▁( ▁AC _ END ▁| ▁DC _ END ▁| ▁MV _ END ▁) ▁) ▁; ▁}	0
▁static ▁int ▁wav _ write _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁WA VM ux Context ▁* ▁wav ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int 64_ t ▁fmt ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁" RI FF " ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁" WAVE " ▁) ▁; ▁fmt ▁= ▁ff _ start _ tag ▁( ▁pb ▁, ▁" fmt " ▁) ▁; ▁if ▁( ▁ff _ put _ wav _ header ▁( ▁s ▁, ▁pb ▁, ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codecpar ▁) ▁< ▁0 ▁) ▁{ ▁const ▁AVCodec Descriptor ▁* ▁desc ▁= ▁avcodec _ descriptor _ get ▁( ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codecpar ▁-> ▁codec _ id ▁) ▁; ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁"% s codec not supported in WAVE format \ n " ▁, ▁desc ▁? ▁desc ▁-> ▁name ▁: ▁" unknown " ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOSYS ▁) ▁; ▁} ▁ff _ end _ tag ▁( ▁pb ▁, ▁fmt ▁) ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codecpar ▁-> ▁codec _ tag ▁!= ▁0 x 01 ▁&& ▁( ▁s ▁-> ▁pb ▁-> ▁seek able ▁& ▁AVIO _ SEEK ABLE _ NORMAL ▁) ▁) ▁{ ▁wav ▁-> ▁fact _ pos ▁= ▁ff _ start _ tag ▁( ▁pb ▁, ▁" fact " ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁ff _ end _ tag ▁( ▁pb ▁, ▁wav ▁-> ▁fact _ pos ▁) ▁; ▁} ▁if ▁( ▁wav ▁-> ▁write _ b ext ▁) ▁bw f _ write _ b ext _ chunk ▁( ▁s ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁, ▁64 ▁, ▁1 ▁, ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codecpar ▁-> ▁sample _ rate ▁) ▁; ▁wav ▁-> ▁max pts ▁= ▁wav ▁-> ▁last _ duration ▁= ▁0 ▁; ▁wav ▁-> ▁min pts ▁= ▁INT 64_ MAX ▁; ▁ff _ ri ff _ write _ info ▁( ▁s ▁) ▁; ▁wav ▁-> ▁data ▁= ▁ff _ start _ tag ▁( ▁pb ▁, ▁" data " ▁) ▁; ▁avio _ flush ▁( ▁pb ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁mov _ write _ single _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁MO VM ux Context ▁* ▁mov ▁= ▁s ▁-> ▁priv _ data ▁; ▁MOV Track ▁* ▁tr k ▁= ▁& ▁mov ▁-> ▁tracks ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁; ▁AVCodec Parameters ▁* ▁par ▁= ▁tr k ▁-> ▁par ▁; ▁int 64_ t ▁frag _ duration ▁= ▁0 ▁; ▁int ▁size ▁= ▁pkt ▁-> ▁size ▁; ▁int ▁ret ▁= ▁check _ pkt ▁( ▁s ▁, ▁pkt ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁mov ▁-> ▁flags ▁& ▁FF _ MOV _ FLAG _ FRAG _ DIS CONT ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁mov ▁-> ▁tracks ▁[ ▁i ▁] ▁. ▁frag _ dis cont ▁= ▁1 ▁; ▁mov ▁-> ▁flags ▁&= ▁ ~ ▁FF _ MOV _ FLAG _ FRAG _ DIS CONT ▁; ▁} ▁if ▁( ▁! ▁pkt ▁-> ▁size ▁) ▁{ ▁if ▁( ▁tr k ▁-> ▁start _ dts ▁== ▁AV _ NOP TS _ VALUE ▁&& ▁tr k ▁-> ▁frag _ dis cont ▁) ▁{ ▁tr k ▁-> ▁start _ dts ▁= ▁pkt ▁-> ▁dts ▁; ▁if ▁( ▁pkt ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁tr k ▁-> ▁start _ cts ▁= ▁pkt ▁-> ▁pts ▁- ▁pkt ▁-> ▁dts ▁; ▁else ▁tr k ▁-> ▁start _ cts ▁= ▁0 ▁; ▁} ▁if ▁( ▁tr k ▁-> ▁par ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MP 4 AL S ▁) ▁{ ▁int ▁side _ size ▁= ▁0 ▁; ▁uint 8_ t ▁* ▁side ▁= ▁av _ packet _ get _ side _ data ▁( ▁pkt ▁, ▁AV _ PKT _ DATA _ NEW _ EX TR ADATA ▁, ▁& ▁side _ size ▁) ▁; ▁if ▁( ▁side ▁&& ▁side _ size ▁> ▁0 ▁&& ▁( ▁side _ size ▁!= ▁par ▁-> ▁extradata _ size ▁|| ▁memcmp ▁( ▁side ▁, ▁par ▁-> ▁extradata ▁, ▁side _ size ▁) ▁) ▁) ▁{ ▁void ▁* ▁new extra ▁= ▁av _ malloc z ▁( ▁side _ size ▁+ ▁AV _ INPUT _ BUFFER _ PADDING _ SIZE ▁) ▁; ▁if ▁( ▁! ▁new extra ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁av _ free ▁( ▁par ▁-> ▁extradata ▁) ▁; ▁par ▁-> ▁extradata ▁= ▁new extra ▁; ▁memcpy ▁( ▁par ▁-> ▁extradata ▁, ▁side ▁, ▁side _ size ▁) ▁; ▁par ▁-> ▁extradata _ size ▁= ▁side _ size ▁; ▁mov ▁-> ▁need _ rewrite _ extr adata ▁= ▁1 ▁; ▁} ▁} ▁return ▁0 ▁; ▁} ▁if ▁( ▁tr k ▁-> ▁entry ▁&& ▁pkt ▁-> ▁stream _ index ▁< ▁s ▁-> ▁nb _ streams ▁) ▁frag _ duration ▁= ▁av _ re scale _ q ▁( ▁pkt ▁-> ▁dts ▁- ▁tr k ▁-> ▁cluster ▁[ ▁0 ▁] ▁. ▁dts ▁, ▁s ▁-> ▁streams ▁[ ▁pkt ▁-> ▁stream _ index ▁] ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁; ▁if ▁( ▁( ▁mov ▁-> ▁max _ fragment _ duration ▁&& ▁frag _ duration ▁>= ▁mov ▁-> ▁max _ fragment _ duration ▁) ▁|| ▁( ▁mov ▁-> ▁max _ fragment _ size ▁&& ▁mov ▁-> ▁md at _ size ▁+ ▁size ▁>= ▁mov ▁-> ▁max _ fragment _ size ▁) ▁|| ▁( ▁mov ▁-> ▁flags ▁& ▁FF _ MOV _ FLAG _ FRAG _ KEY FRAME ▁&& ▁par ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁&& ▁tr k ▁-> ▁entry ▁&& ▁pkt ▁-> ▁flags ▁& ▁AV _ PKT _ FLAG _ KEY ▁) ▁) ▁{ ▁if ▁( ▁frag _ duration ▁>= ▁mov ▁-> ▁min _ fragment _ duration ▁) ▁{ ▁tr k ▁-> ▁track _ duration ▁= ▁pkt ▁-> ▁dts ▁- ▁tr k ▁-> ▁start _ dts ▁; ▁if ▁( ▁pkt ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁tr k ▁-> ▁end _ pts ▁= ▁pkt ▁-> ▁pts ▁; ▁else ▁tr k ▁-> ▁end _ pts ▁= ▁pkt ▁-> ▁dts ▁; ▁tr k ▁-> ▁end _ re liable ▁= ▁1 ▁; ▁mov _ auto _ flush _ fragment ▁( ▁s ▁, ▁0 ▁) ▁; ▁} ▁} ▁return ▁ff _ mov _ write _ packet ▁( ▁s ▁, ▁pkt ▁) ▁; ▁}	0
▁static ▁int ▁util _ verbose ▁( ▁ENGINE ▁* ▁e ▁, ▁int ▁verbose ▁, ▁BIO ▁* ▁bio _ out ▁, ▁const ▁char ▁* ▁indent ▁) ▁{ ▁static ▁const ▁int ▁line _ wrap ▁= ▁78 ▁; ▁int ▁num ▁; ▁char ▁* ▁name ▁= ▁NULL ▁; ▁char ▁* ▁desc ▁= ▁NULL ▁; ▁int ▁flags ▁; ▁int ▁xpos ▁= ▁0 ▁; ▁STACK ▁* ▁cmds ▁= ▁sk _ new _ null ▁( ▁) ▁; ▁if ▁( ▁! ▁cmds ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ HAS _ CTRL _ FUNCTION ▁, ▁0 ▁, ▁NULL ▁, ▁NULL ▁) ▁|| ▁( ▁( ▁num ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ FIRST _ CMD _ TYPE ▁, ▁0 ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁<= ▁0 ▁) ▁) ▁{ ▁# if ▁0 ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% s < noc ont rol commands >\ n " ▁, ▁indent ▁) ▁; ▁# endif ▁return ▁1 ▁; ▁} ▁do ▁{ ▁int ▁len ▁; ▁if ▁( ▁( ▁len ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ NAME _ LEN _ FROM _ CMD ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁name ▁= ▁OPENSSL _ malloc ▁( ▁len ▁+ ▁1 ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ NAME _ FROM _ CMD ▁, ▁num ▁, ▁name ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁len ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ DESC _ LEN _ FROM _ CMD ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁len ▁> ▁0 ▁) ▁{ ▁if ▁( ▁( ▁desc ▁= ▁OPENSSL _ malloc ▁( ▁len ▁+ ▁1 ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ DESC _ FROM _ CMD ▁, ▁num ▁, ▁desc ▁, ▁NULL ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁flags ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ CMD _ FLAGS ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁< ▁0 ▁) ▁goto ▁err ▁; ▁if ▁( ▁xpos ▁== ▁0 ▁) ▁xpos ▁= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁indent ▁) ▁; ▁else ▁xpos ▁+= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"," ▁) ▁; ▁if ▁( ▁verbose ▁== ▁1 ▁) ▁{ ▁if ▁( ▁( ▁xpos ▁> ▁strlen ▁( ▁indent ▁) ▁) ▁&& ▁( ▁xpos ▁+ ▁strlen ▁( ▁name ▁) ▁> ▁line _ wrap ▁) ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"\ n " ▁) ▁; ▁xpos ▁= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁indent ▁) ▁; ▁} ▁xpos ▁+= ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% s " ▁, ▁name ▁) ▁; ▁} ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"% s :% s \ n " ▁, ▁name ▁, ▁( ▁desc ▁== ▁NULL ▁) ▁? ▁"< node scription >" ▁: ▁desc ▁) ▁; ▁if ▁( ▁( ▁verbose ▁== ▁3 ▁) ▁&& ▁! ▁util _ flags ▁( ▁bio _ out ▁, ▁flags ▁, ▁indent ▁) ▁) ▁goto ▁err ▁; ▁xpos ▁= ▁0 ▁; ▁} ▁OPENSSL _ free ▁( ▁name ▁) ▁; ▁name ▁= ▁NULL ▁; ▁if ▁( ▁desc ▁) ▁{ ▁OPENSSL _ free ▁( ▁desc ▁) ▁; ▁desc ▁= ▁NULL ▁; ▁} ▁num ▁= ▁ENGINE _ ctrl ▁( ▁e ▁, ▁ENGINE _ CTRL _ GET _ NEXT _ CMD _ TYPE ▁, ▁num ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁} ▁while ▁( ▁num ▁> ▁0 ▁) ▁; ▁if ▁( ▁xpos ▁> ▁0 ▁) ▁BIO _ printf ▁( ▁bio _ out ▁, ▁"\ n " ▁) ▁; ▁return ▁1 ▁; ▁err ▁: ▁if ▁( ▁cmds ▁) ▁sk _ pop _ free ▁( ▁cmds ▁, ▁identity ▁) ▁; ▁if ▁( ▁name ▁) ▁OPENSSL _ free ▁( ▁name ▁) ▁; ▁if ▁( ▁desc ▁) ▁OPENSSL _ free ▁( ▁desc ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁BN _ u add ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁) ▁{ ▁int ▁max ▁, ▁min ▁, ▁dif ▁; ▁const ▁BN _ ULONG ▁* ▁ap ▁, ▁* ▁bp ▁; ▁BN _ ULONG ▁* ▁rp ▁, ▁carry ▁, ▁t 1 ▁, ▁t 2 ▁; ▁const ▁BIGNUM ▁* ▁tmp ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁a ▁-> ▁top ▁< ▁b ▁-> ▁top ▁) ▁{ ▁tmp ▁= ▁a ▁; ▁a ▁= ▁b ▁; ▁b ▁= ▁tmp ▁; ▁} ▁max ▁= ▁a ▁-> ▁top ▁; ▁min ▁= ▁b ▁-> ▁top ▁; ▁dif ▁= ▁max ▁- ▁min ▁; ▁if ▁( ▁bn _ w expand ▁( ▁r ▁, ▁max ▁+ ▁1 ▁) ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁r ▁-> ▁top ▁= ▁max ▁; ▁ap ▁= ▁a ▁-> ▁d ▁; ▁bp ▁= ▁b ▁-> ▁d ▁; ▁rp ▁= ▁r ▁-> ▁d ▁; ▁carry ▁= ▁bn _ add _ words ▁( ▁rp ▁, ▁ap ▁, ▁bp ▁, ▁min ▁) ▁; ▁rp ▁+= ▁min ▁; ▁ap ▁+= ▁min ▁; ▁bp ▁+= ▁min ▁; ▁if ▁( ▁carry ▁) ▁{ ▁while ▁( ▁dif ▁) ▁{ ▁dif ▁-- ▁; ▁t 1 ▁= ▁* ▁( ▁ap ▁++ ▁) ▁; ▁t 2 ▁= ▁( ▁t 1 ▁+ ▁1 ▁) ▁& ▁BN _ MASK 2 ▁; ▁* ▁( ▁rp ▁++ ▁) ▁= ▁t 2 ▁; ▁if ▁( ▁t 2 ▁) ▁{ ▁carry ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁carry ▁) ▁{ ▁* ▁rp ▁= ▁1 ▁; ▁r ▁-> ▁top ▁++ ▁; ▁} ▁} ▁if ▁( ▁dif ▁&& ▁rp ▁!= ▁ap ▁) ▁while ▁( ▁dif ▁-- ▁) ▁* ▁( ▁rp ▁++ ▁) ▁= ▁* ▁( ▁ap ▁++ ▁) ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁decode _ frame _ mp 3 on 4 ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame _ ptr ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁MP 3 On 4 Decode Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁M PA Decode Context ▁* ▁m ▁; ▁int ▁fsize ▁, ▁len ▁= ▁buf _ size ▁, ▁out _ size ▁= ▁0 ▁; ▁uint 32_ t ▁header ▁; ▁OUT _ INT ▁* ▁out _ samples ▁; ▁OUT _ INT ▁* ▁outptr ▁, ▁* ▁bp ▁; ▁int ▁fr ▁, ▁j ▁, ▁n ▁, ▁ch ▁, ▁ret ▁; ▁s ▁-> ▁frame ▁-> ▁nb _ samples ▁= ▁M PA _ FRAME _ SIZE ▁; ▁if ▁( ▁( ▁ret ▁= ▁avctx ▁-> ▁get _ buffer ▁( ▁avctx ▁, ▁s ▁-> ▁frame ▁) ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" get _ buffer () failed \ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁out _ samples ▁= ▁( ▁OUT _ INT ▁* ▁) ▁s ▁-> ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁if ▁( ▁buf _ size ▁< ▁HEADER _ SIZE ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁outptr ▁= ▁s ▁-> ▁frames ▁== ▁1 ▁? ▁out _ samples ▁: ▁s ▁-> ▁decoded _ buf ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁0 ▁; ▁ch ▁= ▁0 ▁; ▁for ▁( ▁fr ▁= ▁0 ▁; ▁fr ▁< ▁s ▁-> ▁frames ▁; ▁fr ▁++ ▁) ▁{ ▁fsize ▁= ▁AV _ RB 16 ▁( ▁buf ▁) ▁>> ▁4 ▁; ▁fsize ▁= ▁FF MIN 3 ▁( ▁fsize ▁, ▁len ▁, ▁M PA _ MAX _ CODED _ FRAME _ SIZE ▁) ▁; ▁m ▁= ▁s ▁-> ▁mp 3 dec ctx ▁[ ▁fr ▁] ▁; ▁assert ▁( ▁m ▁!= ▁NULL ▁) ▁; ▁header ▁= ▁( ▁AV _ RB 32 ▁( ▁buf ▁) ▁& ▁0 x 000 fffff ▁) ▁| ▁s ▁-> ▁sync word ▁; ▁if ▁( ▁ff _ mp a _ check _ header ▁( ▁header ▁) ▁< ▁0 ▁) ▁break ▁; ▁avpriv _ mpe ga udio _ decode _ header ▁( ▁( ▁M PA Decode Header ▁* ▁) ▁m ▁, ▁header ▁) ▁; ▁if ▁( ▁ch ▁+ ▁m ▁-> ▁nb _ channels ▁> ▁avctx ▁-> ▁channels ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" frame channel co un te xce eds codec " ▁" channel count \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁ch ▁+= ▁m ▁-> ▁nb _ channels ▁; ▁out _ size ▁+= ▁mp _ decode _ frame ▁( ▁m ▁, ▁outptr ▁, ▁buf ▁, ▁fsize ▁) ▁; ▁buf ▁+= ▁fsize ▁; ▁len ▁-= ▁fsize ▁; ▁if ▁( ▁s ▁-> ▁frames ▁> ▁1 ▁) ▁{ ▁n ▁= ▁m ▁-> ▁avctx ▁-> ▁frame _ size ▁* ▁m ▁-> ▁nb _ channels ▁; ▁bp ▁= ▁out _ samples ▁+ ▁s ▁-> ▁coff ▁[ ▁fr ▁] ▁; ▁if ▁( ▁m ▁-> ▁nb _ channels ▁== ▁1 ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁* ▁bp ▁= ▁s ▁-> ▁decoded _ buf ▁[ ▁j ▁] ▁; ▁bp ▁+= ▁avctx ▁-> ▁channels ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁n ▁; ▁j ▁++ ▁) ▁{ ▁bp ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁decoded _ buf ▁[ ▁j ▁++ ▁] ▁; ▁bp ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁decoded _ buf ▁[ ▁j ▁] ▁; ▁bp ▁+= ▁avctx ▁-> ▁channels ▁; ▁} ▁} ▁} ▁avctx ▁-> ▁bit _ rate ▁+= ▁m ▁-> ▁bit _ rate ▁; ▁} ▁avctx ▁-> ▁sample _ rate ▁= ▁s ▁-> ▁mp 3 dec ctx ▁[ ▁0 ▁] ▁-> ▁sample _ rate ▁; ▁s ▁-> ▁frame ▁-> ▁nb _ samples ▁= ▁out _ size ▁/ ▁( ▁avctx ▁-> ▁channels ▁* ▁sizeof ▁( ▁OUT _ INT ▁) ▁) ▁; ▁* ▁got _ frame _ ptr ▁= ▁1 ▁; ▁* ▁( ▁AVFrame ▁* ▁) ▁data ▁= ▁* ▁s ▁-> ▁frame ▁; ▁return ▁buf _ size ▁; ▁}	1
▁static ▁BIGNUM ▁* ▁BN _ POOL _ get ▁( ▁BN _ POOL ▁* ▁p ▁, ▁int ▁flag ▁) ▁{ ▁BIGNUM ▁* ▁bn ▁; ▁unsigned ▁int ▁loop ▁; ▁if ▁( ▁p ▁-> ▁used ▁== ▁p ▁-> ▁size ▁) ▁{ ▁BN _ POOL _ ITEM ▁* ▁item ▁; ▁if ▁( ▁( ▁item ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁item ▁) ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ POOL _ GET ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁for ▁( ▁loop ▁= ▁0 ▁, ▁bn ▁= ▁item ▁-> ▁vals ▁; ▁loop ▁++ ▁< ▁BN _ CTX _ POOL _ SIZE ▁; ▁bn ▁++ ▁) ▁{ ▁bn _ init ▁( ▁bn ▁) ▁; ▁if ▁( ▁( ▁flag ▁& ▁BN _ FLG _ SECURE ▁) ▁!= ▁0 ▁) ▁BN _ set _ flags ▁( ▁bn ▁, ▁BN _ FLG _ SECURE ▁) ▁; ▁} ▁item ▁-> ▁prev ▁= ▁p ▁-> ▁tail ▁; ▁item ▁-> ▁next ▁= ▁NULL ▁; ▁if ▁( ▁p ▁-> ▁head ▁== ▁NULL ▁) ▁p ▁-> ▁head ▁= ▁p ▁-> ▁current ▁= ▁p ▁-> ▁tail ▁= ▁item ▁; ▁else ▁{ ▁p ▁-> ▁tail ▁-> ▁next ▁= ▁item ▁; ▁p ▁-> ▁tail ▁= ▁item ▁; ▁p ▁-> ▁current ▁= ▁item ▁; ▁} ▁p ▁-> ▁size ▁+= ▁BN _ CTX _ POOL _ SIZE ▁; ▁p ▁-> ▁used ▁++ ▁; ▁return ▁item ▁-> ▁vals ▁; ▁} ▁if ▁( ▁! ▁p ▁-> ▁used ▁) ▁p ▁-> ▁current ▁= ▁p ▁-> ▁head ▁; ▁else ▁if ▁( ▁( ▁p ▁-> ▁used ▁% ▁BN _ CTX _ POOL _ SIZE ▁) ▁== ▁0 ▁) ▁p ▁-> ▁current ▁= ▁p ▁-> ▁current ▁-> ▁next ▁; ▁return ▁p ▁-> ▁current ▁-> ▁vals ▁+ ▁( ▁( ▁p ▁-> ▁used ▁++ ▁) ▁% ▁BN _ CTX _ POOL _ SIZE ▁) ▁; ▁}	1
▁static ▁int ▁calculate _ bitrate ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁AV I Context ▁* ▁avi ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁i ▁, ▁j ▁; ▁int 64_ t ▁len sum ▁= ▁0 ▁; ▁int 64_ t ▁max pos ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁int 64_ t ▁len ▁= ▁0 ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁if ▁( ▁! ▁st ▁-> ▁nb _ index _ entries ▁) ▁continue ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁st ▁-> ▁nb _ index _ entries ▁; ▁j ▁++ ▁) ▁len ▁+= ▁st ▁-> ▁index _ entries ▁[ ▁j ▁] ▁. ▁size ▁; ▁max pos ▁= ▁FF MAX ▁( ▁max pos ▁, ▁st ▁-> ▁index _ entries ▁[ ▁j ▁- ▁1 ▁] ▁. ▁pos ▁) ▁; ▁len sum ▁+= ▁len ▁; ▁} ▁if ▁( ▁max pos ▁< ▁avi ▁-> ▁io _ f size ▁* ▁9 ▁/ ▁10 ▁) ▁return ▁0 ▁; ▁if ▁( ▁len sum ▁* ▁9 ▁/ ▁10 ▁> ▁max pos ▁|| ▁len sum ▁< ▁max pos ▁* ▁9 ▁/ ▁10 ▁) ▁return ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁int 64_ t ▁len ▁= ▁0 ▁; ▁AVStream ▁* ▁st ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁; ▁int 64_ t ▁duration ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁st ▁-> ▁nb _ index _ entries ▁; ▁j ▁++ ▁) ▁len ▁+= ▁st ▁-> ▁index _ entries ▁[ ▁j ▁] ▁. ▁size ▁; ▁if ▁( ▁st ▁-> ▁nb _ index _ entries ▁< ▁2 ▁|| ▁st ▁-> ▁codec ▁-> ▁bit _ rate ▁> ▁0 ▁) ▁continue ▁; ▁duration ▁= ▁st ▁-> ▁index _ entries ▁[ ▁j ▁- ▁1 ▁] ▁. ▁timestamp ▁- ▁st ▁-> ▁index _ entries ▁[ ▁0 ▁] ▁. ▁timestamp ▁; ▁st ▁-> ▁codec ▁-> ▁bit _ rate ▁= ▁av _ re scale ▁( ▁8 ▁* ▁len ▁, ▁st ▁-> ▁time _ base ▁. ▁den ▁, ▁duration ▁* ▁st ▁-> ▁time _ base ▁. ▁num ▁) ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁void ▁vc 1_ decode _ i _ blocks _ adv ▁( ▁VC 1 Context ▁* ▁v ▁) ▁{ ▁int ▁k ▁; ▁Mpeg Enc Context ▁* ▁s ▁= ▁& ▁v ▁-> ▁s ▁; ▁int ▁cb p ▁, ▁val ▁; ▁uint 8_ t ▁* ▁coded _ val ▁; ▁int ▁mb _ pos ▁; ▁int ▁m quant ▁= ▁v ▁-> ▁pq ▁; ▁int ▁mq diff ▁; ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁gb ▁; ▁switch ▁( ▁v ▁-> ▁y _ ac _ table _ index ▁) ▁{ ▁case ▁0 ▁: ▁v ▁-> ▁coding set ▁= ▁( ▁v ▁-> ▁pq index ▁<= ▁8 ▁) ▁? ▁CS _ HIGH _ RATE _ INTR A ▁: ▁CS _ LOW _ MO T _ INTR A ▁; ▁break ▁; ▁case ▁1 ▁: ▁v ▁-> ▁coding set ▁= ▁CS _ HIGH _ MO T _ INTR A ▁; ▁break ▁; ▁case ▁2 ▁: ▁v ▁-> ▁coding set ▁= ▁CS _ MID _ RATE _ INTR A ▁; ▁break ▁; ▁} ▁switch ▁( ▁v ▁-> ▁c _ ac _ table _ index ▁) ▁{ ▁case ▁0 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁( ▁v ▁-> ▁pq index ▁<= ▁8 ▁) ▁? ▁CS _ HIGH _ RATE _ INTER ▁: ▁CS _ LOW _ MO T _ INTER ▁; ▁break ▁; ▁case ▁1 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁CS _ HIGH _ MO T _ INTER ▁; ▁break ▁; ▁case ▁2 ▁: ▁v ▁-> ▁coding set 2 ▁= ▁CS _ MID _ RATE _ INTER ▁; ▁break ▁; ▁} ▁s ▁-> ▁mb _ x ▁= ▁s ▁-> ▁mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁mb _ intra ▁= ▁1 ▁; ▁s ▁-> ▁first _ slice _ line ▁= ▁1 ▁; ▁s ▁-> ▁mb _ y ▁= ▁s ▁-> ▁start _ mb _ y ▁; ▁if ▁( ▁s ▁-> ▁start _ mb _ y ▁) ▁{ ▁s ▁-> ▁mb _ x ▁= ▁0 ▁; ▁init _ block _ index ▁( ▁v ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁coded _ block ▁[ ▁s ▁-> ▁block _ index ▁[ ▁0 ▁] ▁- ▁s ▁-> ▁b 8_ stride ▁] ▁, ▁0 ▁, ▁( ▁1 ▁+ ▁s ▁-> ▁b 8_ stride ▁) ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁coded _ block ▁) ▁) ▁; ▁} ▁for ▁( ▁; ▁s ▁-> ▁mb _ y ▁< ▁s ▁-> ▁end _ mb _ y ▁; ▁s ▁-> ▁mb _ y ▁++ ▁) ▁{ ▁s ▁-> ▁mb _ x ▁= ▁0 ▁; ▁init _ block _ index ▁( ▁v ▁) ▁; ▁for ▁( ▁; ▁s ▁-> ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁s ▁-> ▁mb _ x ▁++ ▁) ▁{ ▁int 16_ t ▁( ▁* ▁block ▁) ▁[ ▁64 ▁] ▁= ▁v ▁-> ▁block ▁[ ▁v ▁-> ▁cur _ blk _ idx ▁] ▁; ▁ff _ update _ block _ index ▁( ▁s ▁) ▁; ▁s ▁-> ▁dsp ▁. ▁clear _ blocks ▁( ▁block ▁[ ▁0 ▁] ▁) ▁; ▁mb _ pos ▁= ▁s ▁-> ▁mb _ x ▁+ ▁s ▁-> ▁mb _ y ▁* ▁s ▁-> ▁mb _ stride ▁; ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁mb _ type ▁[ ▁mb _ pos ▁+ ▁v ▁-> ▁mb _ off ▁] ▁= ▁MB _ TYPE _ INTR A ▁; ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁motion _ val ▁[ ▁1 ▁] ▁[ ▁s ▁-> ▁block _ index ▁[ ▁0 ▁] ▁+ ▁v ▁-> ▁blocks _ off ▁] ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁motion _ val ▁[ ▁1 ▁] ▁[ ▁s ▁-> ▁block _ index ▁[ ▁0 ▁] ▁+ ▁v ▁-> ▁blocks _ off ▁] ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁if ▁( ▁v ▁-> ▁field tx _ is _ raw ▁) ▁v ▁-> ▁field tx _ plane ▁[ ▁mb _ pos ▁] ▁= ▁get _ bits 1 ▁( ▁& ▁v ▁-> ▁s ▁. ▁gb ▁) ▁; ▁cb p ▁= ▁get _ vlc 2 ▁( ▁& ▁v ▁-> ▁s ▁. ▁gb ▁, ▁ff _ ms mp 4_ mb _ i _ vlc ▁. ▁table ▁, ▁MB _ INTR A _ V LC _ BITS ▁, ▁2 ▁) ▁; ▁if ▁( ▁v ▁-> ▁ac pred _ is _ raw ▁) ▁v ▁-> ▁s ▁. ▁ac _ pred ▁= ▁get _ bits 1 ▁( ▁& ▁v ▁-> ▁s ▁. ▁gb ▁) ▁; ▁else ▁v ▁-> ▁s ▁. ▁ac _ pred ▁= ▁v ▁-> ▁ac pred _ plane ▁[ ▁mb _ pos ▁] ▁; ▁if ▁( ▁v ▁-> ▁cond over ▁== ▁CON DO VER _ SELECT ▁&& ▁v ▁-> ▁over flg _ is _ raw ▁) ▁v ▁-> ▁over _ flags _ plane ▁[ ▁mb _ pos ▁] ▁= ▁get _ bits 1 ▁( ▁& ▁v ▁-> ▁s ▁. ▁gb ▁) ▁; ▁GET _ M QUANT ▁( ▁) ▁; ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁q scale _ table ▁[ ▁mb _ pos ▁] ▁= ▁m quant ▁; ▁s ▁-> ▁y _ dc _ scale ▁= ▁s ▁-> ▁y _ dc _ scale _ table ▁[ ▁m quant ▁] ▁; ▁s ▁-> ▁c _ dc _ scale ▁= ▁s ▁-> ▁c _ dc _ scale _ table ▁[ ▁m quant ▁] ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁6 ▁; ▁k ▁++ ▁) ▁{ ▁val ▁= ▁( ▁( ▁cb p ▁>> ▁( ▁5 ▁- ▁k ▁) ▁) ▁& ▁1 ▁) ▁; ▁if ▁( ▁k ▁< ▁4 ▁) ▁{ ▁int ▁pred ▁= ▁vc 1_ coded _ block _ pred ▁( ▁& ▁v ▁-> ▁s ▁, ▁k ▁, ▁& ▁coded _ val ▁) ▁; ▁val ▁= ▁val ▁ ^ ▁pred ▁; ▁* ▁coded _ val ▁= ▁val ▁; ▁} ▁cb p ▁|= ▁val ▁<< ▁( ▁5 ▁- ▁k ▁) ▁; ▁v ▁-> ▁a _ avail ▁= ▁! ▁s ▁-> ▁first _ slice _ line ▁|| ▁( ▁k ▁== ▁2 ▁|| ▁k ▁== ▁3 ▁) ▁; ▁v ▁-> ▁c _ avail ▁= ▁! ▁! ▁s ▁-> ▁mb _ x ▁|| ▁( ▁k ▁== ▁1 ▁|| ▁k ▁== ▁3 ▁) ▁; ▁vc 1_ decode _ i _ block _ adv ▁( ▁v ▁, ▁block ▁[ ▁k ▁] ▁, ▁k ▁, ▁val ▁, ▁( ▁k ▁< ▁4 ▁) ▁? ▁v ▁-> ▁coding set ▁: ▁v ▁-> ▁coding set 2 ▁, ▁m quant ▁) ▁; ▁if ▁( ▁k ▁> ▁3 ▁&& ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁continue ▁; ▁v ▁-> ▁vc 1 dsp ▁. ▁vc 1_ inv _ trans _8 x 8 ▁( ▁block ▁[ ▁k ▁] ▁) ▁; ▁} ▁vc 1_ smooth _ over lap _ filter _ ib lk ▁( ▁v ▁) ▁; ▁vc 1_ put _ signed _ blocks _ clamp ed ▁( ▁v ▁) ▁; ▁if ▁( ▁v ▁-> ▁s ▁. ▁loop _ filter ▁) ▁vc 1_ loop _ filter _ ib lk _ delayed ▁( ▁v ▁, ▁v ▁-> ▁pq ▁) ▁; ▁if ▁( ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁> ▁v ▁-> ▁bits ▁) ▁{ ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁0 ▁, ▁s ▁-> ▁start _ mb _ y ▁, ▁s ▁-> ▁mb _ x ▁, ▁s ▁-> ▁mb _ y ▁, ▁ER _ MB _ ERROR ▁) ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bits over cons umption :% i >% i \ n " ▁, ▁get _ bits _ count ▁( ▁& ▁s ▁-> ▁gb ▁) ▁, ▁v ▁-> ▁bits ▁) ▁; ▁return ▁; ▁} ▁} ▁if ▁( ▁! ▁v ▁-> ▁s ▁. ▁loop _ filter ▁) ▁ff _ draw _ h oriz _ band ▁( ▁s ▁, ▁s ▁-> ▁mb _ y ▁* ▁16 ▁, ▁16 ▁) ▁; ▁else ▁if ▁( ▁s ▁-> ▁mb _ y ▁) ▁ff _ draw _ h oriz _ band ▁( ▁s ▁, ▁( ▁s ▁-> ▁mb _ y ▁- ▁1 ▁) ▁* ▁16 ▁, ▁16 ▁) ▁; ▁s ▁-> ▁first _ slice _ line ▁= ▁0 ▁; ▁} ▁s ▁-> ▁mb _ x ▁= ▁0 ▁; ▁init _ block _ index ▁( ▁v ▁) ▁; ▁for ▁( ▁; ▁s ▁-> ▁mb _ x ▁< ▁s ▁-> ▁mb _ width ▁; ▁s ▁-> ▁mb _ x ▁++ ▁) ▁{ ▁ff _ update _ block _ index ▁( ▁s ▁) ▁; ▁vc 1_ put _ signed _ blocks _ clamp ed ▁( ▁v ▁) ▁; ▁if ▁( ▁v ▁-> ▁s ▁. ▁loop _ filter ▁) ▁vc 1_ loop _ filter _ ib lk _ delayed ▁( ▁v ▁, ▁v ▁-> ▁pq ▁) ▁; ▁} ▁if ▁( ▁v ▁-> ▁s ▁. ▁loop _ filter ▁) ▁ff _ draw _ h oriz _ band ▁( ▁s ▁, ▁( ▁s ▁-> ▁end _ mb _ y ▁- ▁1 ▁) ▁* ▁16 ▁, ▁16 ▁) ▁; ▁ff _ er _ add _ slice ▁( ▁s ▁, ▁0 ▁, ▁s ▁-> ▁start _ mb _ y ▁<< ▁v ▁-> ▁field _ mode ▁, ▁s ▁-> ▁mb _ width ▁- ▁1 ▁, ▁( ▁s ▁-> ▁end _ mb _ y ▁<< ▁v ▁-> ▁field _ mode ▁) ▁- ▁1 ▁, ▁ER _ MB _ END ▁) ▁; ▁}	0
▁static ▁EVP _ PKEY ▁* ▁hw cr hk _ load _ priv key ▁( ▁ENGINE ▁* ▁eng ▁, ▁const ▁char ▁* ▁key _ id ▁, ▁UI _ METHOD ▁* ▁ui _ method ▁, ▁void ▁* ▁callback _ data ▁) ▁{ ▁# ifndef ▁OPENSSL _ NO _ RSA ▁RSA ▁* ▁rt mp ▁= ▁NULL ▁; ▁# endif ▁EVP _ PKEY ▁* ▁res ▁= ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ RSA ▁HW Crypto Hook _ MPI ▁e ▁, ▁n ▁; ▁HW Crypto Hook _ RSA Key Handle ▁* ▁h ptr ▁; ▁# endif ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ RSA ▁) ▁char ▁temp buf ▁[ ▁1024 ▁] ▁; ▁HW Crypto Hook _ ErrMsg Buf ▁r msg ▁; ▁# endif ▁HW Crypto Hook _ Pass phrase Context ▁pp ctx ▁; ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ RSA ▁) ▁r msg ▁. ▁buf ▁= ▁temp buf ▁; ▁r msg ▁. ▁size ▁= ▁sizeof ▁( ▁temp buf ▁) ▁; ▁# endif ▁if ▁( ▁! ▁hw cr hk _ context ▁) ▁{ ▁HW CR HK err ▁( ▁HW CR HK _ F _ HW CR HK _ LOAD _ PRIV KEY ▁, ▁HW CR HK _ R _ NOT _ INITIAL I SED ▁) ▁; ▁goto ▁err ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ RSA ▁h ptr ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁HW Crypto Hook _ RSA Key Handle ▁) ▁) ▁; ▁if ▁( ▁! ▁h ptr ▁) ▁{ ▁HW CR HK err ▁( ▁HW CR HK _ F _ HW CR HK _ LOAD _ PRIV KEY ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁pp ctx ▁. ▁ui _ method ▁= ▁ui _ method ▁; ▁pp ctx ▁. ▁callback _ data ▁= ▁callback _ data ▁; ▁if ▁( ▁p _ hw cr hk _ RS AL oad Key ▁( ▁hw cr hk _ context ▁, ▁key _ id ▁, ▁h ptr ▁, ▁& ▁r msg ▁, ▁& ▁pp ctx ▁) ▁) ▁{ ▁HW CR HK err ▁( ▁HW CR HK _ F _ HW CR HK _ LOAD _ PRIV KEY ▁, ▁HW CR HK _ R _ CH IL _ ERROR ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁1 ▁, ▁r msg ▁. ▁buf ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁* ▁h ptr ▁) ▁{ ▁HW CR HK err ▁( ▁HW CR HK _ F _ HW CR HK _ LOAD _ PRIV KEY ▁, ▁HW CR HK _ R _ NO _ KEY ▁) ▁; ▁goto ▁err ▁; ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ RSA ▁rt mp ▁= ▁RSA _ new _ method ▁( ▁eng ▁) ▁; ▁RSA _ set _ ex _ data ▁( ▁rt mp ▁, ▁hnd idx _ rsa ▁, ▁( ▁char ▁* ▁) ▁h ptr ▁) ▁; ▁rt mp ▁-> ▁e ▁= ▁BN _ new ▁( ▁) ▁; ▁rt mp ▁-> ▁n ▁= ▁BN _ new ▁( ▁) ▁; ▁rt mp ▁-> ▁flags ▁|= ▁RSA _ FLAG _ EXT _ PKEY ▁; ▁MPI 2 BN ▁( ▁rt mp ▁-> ▁e ▁, ▁e ▁) ▁; ▁MPI 2 BN ▁( ▁rt mp ▁-> ▁n ▁, ▁n ▁) ▁; ▁if ▁( ▁p _ hw cr hk _ RSA Get PublicKey ▁( ▁* ▁h ptr ▁, ▁& ▁n ▁, ▁& ▁e ▁, ▁& ▁r msg ▁) ▁!= ▁HW CRYPTO HOOK _ ERROR _ MP IS IZE ▁) ▁{ ▁HW CR HK err ▁( ▁HW CR HK _ F _ HW CR HK _ LOAD _ PUB KEY ▁, ▁HW CR HK _ R _ CH IL _ ERROR ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁1 ▁, ▁r msg ▁. ▁buf ▁) ▁; ▁goto ▁err ▁; ▁} ▁bn _ expand 2 ▁( ▁rt mp ▁-> ▁e ▁, ▁e ▁. ▁size ▁/ ▁sizeof ▁( ▁BN _ ULONG ▁) ▁) ▁; ▁bn _ expand 2 ▁( ▁rt mp ▁-> ▁n ▁, ▁n ▁. ▁size ▁/ ▁sizeof ▁( ▁BN _ ULONG ▁) ▁) ▁; ▁MPI 2 BN ▁( ▁rt mp ▁-> ▁e ▁, ▁e ▁) ▁; ▁MPI 2 BN ▁( ▁rt mp ▁-> ▁n ▁, ▁n ▁) ▁; ▁if ▁( ▁p _ hw cr hk _ RSA Get PublicKey ▁( ▁* ▁h ptr ▁, ▁& ▁n ▁, ▁& ▁e ▁, ▁& ▁r msg ▁) ▁) ▁{ ▁HW CR HK err ▁( ▁HW CR HK _ F _ HW CR HK _ LOAD _ PUB KEY ▁, ▁HW CR HK _ R _ CH IL _ ERROR ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁1 ▁, ▁r msg ▁. ▁buf ▁) ▁; ▁goto ▁err ▁; ▁} ▁rt mp ▁-> ▁e ▁-> ▁top ▁= ▁e ▁. ▁size ▁/ ▁sizeof ▁( ▁BN _ ULONG ▁) ▁; ▁bn _ fix _ top ▁( ▁rt mp ▁-> ▁e ▁) ▁; ▁rt mp ▁-> ▁n ▁-> ▁top ▁= ▁n ▁. ▁size ▁/ ▁sizeof ▁( ▁BN _ ULONG ▁) ▁; ▁bn _ fix _ top ▁( ▁rt mp ▁-> ▁n ▁) ▁; ▁res ▁= ▁EVP _ PKEY _ new ▁( ▁) ▁; ▁EVP _ PKEY _ assign _ RSA ▁( ▁res ▁, ▁rt mp ▁) ▁; ▁# endif ▁if ▁( ▁! ▁res ▁) ▁HW CR HK err ▁( ▁HW CR HK _ F _ HW CR HK _ LOAD _ PUB KEY ▁, ▁HW CR HK _ R _ PRIVATE _ KEY _ ALGOR ITH MS _ DISABLED ▁) ▁; ▁return ▁res ▁; ▁err ▁: ▁if ▁( ▁res ▁) ▁EVP _ PKEY _ free ▁( ▁res ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁rt mp ▁) ▁RSA _ free ▁( ▁rt mp ▁) ▁; ▁# endif ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁read _ dct _ coeffs ▁( ▁Bit stream Context ▁* ▁bc ▁, ▁int 32_ t ▁block ▁[ ▁64 ▁] ▁, ▁const ▁uint 8_ t ▁* ▁scan ▁, ▁int ▁* ▁coef _ count _ ▁, ▁int ▁coef _ idx ▁[ ▁64 ▁] ▁, ▁int ▁q ▁) ▁{ ▁int ▁coef _ list ▁[ ▁128 ▁] ▁; ▁int ▁mode _ list ▁[ ▁128 ▁] ▁; ▁int ▁i ▁, ▁t ▁, ▁bits ▁, ▁c coef ▁, ▁mode ▁; ▁int ▁list _ start ▁= ▁64 ▁, ▁list _ end ▁= ▁64 ▁, ▁list _ pos ▁; ▁int ▁coef _ count ▁= ▁0 ▁; ▁int ▁quant _ idx ▁; ▁coef _ list ▁[ ▁list _ end ▁] ▁= ▁4 ▁; ▁mode _ list ▁[ ▁list _ end ▁++ ▁] ▁= ▁0 ▁; ▁coef _ list ▁[ ▁list _ end ▁] ▁= ▁24 ▁; ▁mode _ list ▁[ ▁list _ end ▁++ ▁] ▁= ▁0 ▁; ▁coef _ list ▁[ ▁list _ end ▁] ▁= ▁44 ▁; ▁mode _ list ▁[ ▁list _ end ▁++ ▁] ▁= ▁0 ▁; ▁coef _ list ▁[ ▁list _ end ▁] ▁= ▁1 ▁; ▁mode _ list ▁[ ▁list _ end ▁++ ▁] ▁= ▁3 ▁; ▁coef _ list ▁[ ▁list _ end ▁] ▁= ▁2 ▁; ▁mode _ list ▁[ ▁list _ end ▁++ ▁] ▁= ▁3 ▁; ▁coef _ list ▁[ ▁list _ end ▁] ▁= ▁3 ▁; ▁mode _ list ▁[ ▁list _ end ▁++ ▁] ▁= ▁3 ▁; ▁for ▁( ▁bits ▁= ▁bitstream _ read ▁( ▁bc ▁, ▁4 ▁) ▁- ▁1 ▁; ▁bits ▁>= ▁0 ▁; ▁bits ▁-- ▁) ▁{ ▁list _ pos ▁= ▁list _ start ▁; ▁while ▁( ▁list _ pos ▁< ▁list _ end ▁) ▁{ ▁if ▁( ▁! ▁( ▁mode _ list ▁[ ▁list _ pos ▁] ▁| ▁coef _ list ▁[ ▁list _ pos ▁] ▁) ▁|| ▁! ▁bitstream _ read _ bit ▁( ▁bc ▁) ▁) ▁{ ▁list _ pos ▁++ ▁; ▁continue ▁; ▁} ▁c coef ▁= ▁coef _ list ▁[ ▁list _ pos ▁] ▁; ▁mode ▁= ▁mode _ list ▁[ ▁list _ pos ▁] ▁; ▁switch ▁( ▁mode ▁) ▁{ ▁case ▁0 ▁: ▁coef _ list ▁[ ▁list _ pos ▁] ▁= ▁c coef ▁+ ▁4 ▁; ▁mode _ list ▁[ ▁list _ pos ▁] ▁= ▁1 ▁; ▁case ▁2 ▁: ▁if ▁( ▁mode ▁== ▁2 ▁) ▁{ ▁coef _ list ▁[ ▁list _ pos ▁] ▁= ▁0 ▁; ▁mode _ list ▁[ ▁list _ pos ▁++ ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁, ▁c coef ▁++ ▁) ▁{ ▁if ▁( ▁bitstream _ read _ bit ▁( ▁bc ▁) ▁) ▁{ ▁coef _ list ▁[ ▁-- ▁list _ start ▁] ▁= ▁c coef ▁; ▁mode _ list ▁[ ▁list _ start ▁] ▁= ▁3 ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁bits ▁) ▁{ ▁t ▁= ▁1 ▁- ▁( ▁bitstream _ read _ bit ▁( ▁bc ▁) ▁<< ▁1 ▁) ▁; ▁} ▁else ▁{ ▁t ▁= ▁bitstream _ read ▁( ▁bc ▁, ▁bits ▁) ▁| ▁1 ▁<< ▁bits ▁; ▁t ▁= ▁bitstream _ apply _ sign ▁( ▁bc ▁, ▁t ▁) ▁; ▁} ▁block ▁[ ▁scan ▁[ ▁c coef ▁] ▁] ▁= ▁t ▁; ▁coef _ idx ▁[ ▁coef _ count ▁++ ▁] ▁= ▁c coef ▁; ▁} ▁} ▁break ▁; ▁case ▁1 ▁: ▁mode _ list ▁[ ▁list _ pos ▁] ▁= ▁2 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁c coef ▁+= ▁4 ▁; ▁coef _ list ▁[ ▁list _ end ▁] ▁= ▁c coef ▁; ▁mode _ list ▁[ ▁list _ end ▁++ ▁] ▁= ▁2 ▁; ▁} ▁break ▁; ▁case ▁3 ▁: ▁if ▁( ▁! ▁bits ▁) ▁{ ▁t ▁= ▁1 ▁- ▁( ▁bitstream _ read _ bit ▁( ▁bc ▁) ▁<< ▁1 ▁) ▁; ▁} ▁else ▁{ ▁t ▁= ▁bitstream _ read ▁( ▁bc ▁, ▁bits ▁) ▁| ▁1 ▁<< ▁bits ▁; ▁t ▁= ▁bitstream _ apply _ sign ▁( ▁bc ▁, ▁t ▁) ▁; ▁} ▁block ▁[ ▁scan ▁[ ▁c coef ▁] ▁] ▁= ▁t ▁; ▁coef _ idx ▁[ ▁coef _ count ▁++ ▁] ▁= ▁c coef ▁; ▁coef _ list ▁[ ▁list _ pos ▁] ▁= ▁0 ▁; ▁mode _ list ▁[ ▁list _ pos ▁++ ▁] ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁q ▁== ▁-1 ▁) ▁{ ▁quant _ idx ▁= ▁bitstream _ read ▁( ▁bc ▁, ▁4 ▁) ▁; ▁} ▁else ▁{ ▁quant _ idx ▁= ▁q ▁; ▁} ▁if ▁( ▁quant _ idx ▁>= ▁16 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁* ▁coef _ count _ ▁= ▁coef _ count ▁; ▁return ▁quant _ idx ▁; ▁}	0
▁int ▁BN _ num _ bits ▁( ▁const ▁BIGNUM ▁* ▁a ▁) ▁{ ▁int ▁i ▁= ▁a ▁-> ▁top ▁- ▁1 ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁a ▁) ▁) ▁return ▁0 ▁; ▁return ▁( ▁( ▁i ▁* ▁BN _ BITS 2 ▁) ▁+ ▁BN _ num _ bits _ word ▁( ▁a ▁-> ▁d ▁[ ▁i ▁] ▁) ▁) ▁; ▁}	1
▁static ▁int ▁gif _ image _ write _ header ▁( ▁AVFormatContext ▁* ▁s ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁loop _ count ▁, ▁uint 32_ t ▁* ▁palette ▁) ▁{ ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁AVR ational ▁sar ▁= ▁s ▁-> ▁streams ▁[ ▁0 ▁] ▁-> ▁codec ▁-> ▁sample _ aspect _ ratio ▁; ▁int ▁i ▁, ▁aspect ▁= ▁0 ▁; ▁if ▁( ▁sar ▁. ▁num ▁> ▁0 ▁&& ▁sar ▁. ▁den ▁> ▁0 ▁) ▁{ ▁aspect ▁= ▁sar ▁. ▁num ▁* ▁64 ▁/ ▁sar ▁. ▁den ▁- ▁15 ▁; ▁if ▁( ▁aspect ▁< ▁0 ▁|| ▁aspect ▁> ▁255 ▁) ▁aspect ▁= ▁0 ▁; ▁} ▁avio _ write ▁( ▁pb ▁, ▁" GIF " ▁, ▁3 ▁) ▁; ▁avio _ write ▁( ▁pb ▁, ▁" 89 a " ▁, ▁3 ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁width ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁height ▁) ▁; ▁if ▁( ▁palette ▁) ▁{ ▁avio _ w 8 ▁( ▁pb ▁, ▁0 xf 7 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 1 f ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁aspect ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁const ▁uint 32_ t ▁v ▁= ▁palette ▁[ ▁i ▁] ▁& ▁0 xffffff ▁; ▁avio _ wb 24 ▁( ▁pb ▁, ▁v ▁) ▁; ▁} ▁} ▁else ▁{ ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁aspect ▁) ▁; ▁} ▁if ▁( ▁loop _ count ▁>= ▁0 ▁) ▁{ ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 21 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 xff ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 0 b ▁) ▁; ▁avio _ write ▁( ▁pb ▁, ▁" NET SCAPE 2.0" ▁, ▁sizeof ▁( ▁" NET SCAPE 2.0" ▁) ▁- ▁1 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 03 ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 01 ▁) ▁; ▁avio _ wl 16 ▁( ▁pb ▁, ▁( ▁uint 16_ t ▁) ▁loop _ count ▁) ▁; ▁avio _ w 8 ▁( ▁pb ▁, ▁0 x 00 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁test _ fail _ string _ common ▁( ▁const ▁char ▁* ▁prefix ▁, ▁const ▁char ▁* ▁file ▁, ▁int ▁line ▁, ▁const ▁char ▁* ▁type ▁, ▁const ▁char ▁* ▁left ▁, ▁const ▁char ▁* ▁right ▁, ▁const ▁char ▁* ▁op ▁, ▁const ▁char ▁* ▁m 1 ▁, ▁size _ t ▁l 1 ▁, ▁const ▁char ▁* ▁m 2 ▁, ▁size _ t ▁l 2 ▁) ▁{ ▁const ▁size _ t ▁width ▁= ▁( ▁MAX _ STRING _ WIDTH ▁- ▁subtest _ level ▁( ▁) ▁- ▁12 ▁) ▁/ ▁16 ▁* ▁16 ▁; ▁char ▁b 1 ▁[ ▁MAX _ STRING _ WIDTH ▁+ ▁1 ▁] ▁, ▁b 2 ▁[ ▁MAX _ STRING _ WIDTH ▁+ ▁1 ▁] ▁; ▁char ▁b diff ▁[ ▁MAX _ STRING _ WIDTH ▁+ ▁1 ▁] ▁; ▁size _ t ▁n 1 ▁, ▁n 2 ▁, ▁i ▁; ▁unsigned ▁int ▁cnt ▁= ▁0 ▁, ▁diff ▁; ▁test _ fail _ message _ prefix ▁( ▁prefix ▁, ▁file ▁, ▁line ▁, ▁type ▁, ▁left ▁, ▁right ▁, ▁op ▁) ▁; ▁if ▁( ▁m 1 ▁== ▁NULL ▁) ▁l 1 ▁= ▁0 ▁; ▁if ▁( ▁m 2 ▁== ▁NULL ▁) ▁l 2 ▁= ▁0 ▁; ▁if ▁( ▁l 1 ▁== ▁0 ▁&& ▁l 2 ▁== ▁0 ▁) ▁{ ▁if ▁( ▁( ▁m 1 ▁== ▁NULL ▁) ▁== ▁( ▁m 2 ▁== ▁NULL ▁) ▁) ▁{ ▁test _ string _ null _ empty ▁( ▁m 1 ▁, ▁' ▁' ▁) ▁; ▁} ▁else ▁{ ▁test _ diff _ header ▁( ▁left ▁, ▁right ▁) ▁; ▁test _ string _ null _ empty ▁( ▁m 1 ▁, ▁' ▁' ▁) ▁; ▁test _ string _ null _ empty ▁( ▁m 2 ▁, ▁' ▁' ▁) ▁; ▁} ▁goto ▁fin ▁; ▁} ▁if ▁( ▁l 1 ▁!= ▁l 2 ▁|| ▁strcmp ▁( ▁m 1 ▁, ▁m 2 ▁) ▁!= ▁0 ▁) ▁test _ diff _ header ▁( ▁left ▁, ▁right ▁) ▁; ▁while ▁( ▁l 1 ▁> ▁0 ▁|| ▁l 2 ▁> ▁0 ▁) ▁{ ▁n 1 ▁= ▁n 2 ▁= ▁0 ▁; ▁if ▁( ▁l 1 ▁> ▁0 ▁) ▁{ ▁b 1 ▁[ ▁n 1 ▁= ▁l 1 ▁> ▁width ▁? ▁width ▁: ▁l 1 ▁] ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 1 ▁; ▁i ▁++ ▁) ▁b 1 ▁[ ▁i ▁] ▁= ▁isprint ▁( ▁( ▁unsigned ▁char ▁) ▁m 1 ▁[ ▁i ▁] ▁) ▁? ▁m 1 ▁[ ▁i ▁] ▁: ▁' ▁' ▁; ▁} ▁if ▁( ▁l 2 ▁> ▁0 ▁) ▁{ ▁b 2 ▁[ ▁n 2 ▁= ▁l 2 ▁> ▁width ▁? ▁width ▁: ▁l 2 ▁] ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n 2 ▁; ▁i ▁++ ▁) ▁b 2 ▁[ ▁i ▁] ▁= ▁isprint ▁( ▁( ▁unsigned ▁char ▁) ▁m 2 ▁[ ▁i ▁] ▁) ▁? ▁m 2 ▁[ ▁i ▁] ▁: ▁' ▁' ▁; ▁} ▁diff ▁= ▁0 ▁; ▁i ▁= ▁0 ▁; ▁if ▁( ▁n 1 ▁> ▁0 ▁&& ▁n 2 ▁> ▁0 ▁) ▁{ ▁const ▁size _ t ▁j ▁= ▁n 1 ▁< ▁n 2 ▁? ▁n 1 ▁: ▁n 2 ▁; ▁for ▁( ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁if ▁( ▁m 1 ▁[ ▁i ▁] ▁== ▁m 2 ▁[ ▁i ▁] ▁) ▁{ ▁b diff ▁[ ▁i ▁] ▁= ▁' ▁' ▁; ▁} ▁else ▁{ ▁b diff ▁[ ▁i ▁] ▁= ▁' ▁' ▁; ▁diff ▁= ▁1 ▁; ▁} ▁b diff ▁[ ▁i ▁] ▁= ▁' ▁\0 ▁' ▁; ▁} ▁if ▁( ▁n 1 ▁== ▁n 2 ▁&& ▁! ▁diff ▁) ▁{ ▁test _ printf _ stderr ▁( ▁"% 4 u :' % s '\ n " ▁, ▁cnt ▁, ▁n 2 ▁> ▁n 1 ▁? ▁b 2 ▁: ▁b 1 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁cnt ▁== ▁0 ▁&& ▁( ▁m 1 ▁== ▁NULL ▁|| ▁* ▁m 1 ▁== ▁' ▁\0 ▁' ▁) ▁) ▁test _ string _ null _ empty ▁( ▁m 1 ▁, ▁' ▁' ▁) ▁; ▁else ▁if ▁( ▁n 1 ▁> ▁0 ▁) ▁test _ printf _ stderr ▁( ▁"% 4 u :- ' % s '\ n " ▁, ▁cnt ▁, ▁b 1 ▁) ▁; ▁if ▁( ▁cnt ▁== ▁0 ▁&& ▁( ▁m 2 ▁== ▁NULL ▁|| ▁* ▁m 2 ▁== ▁' ▁\0 ▁' ▁) ▁) ▁test _ string _ null _ empty ▁( ▁m 2 ▁, ▁' ▁' ▁) ▁; ▁else ▁if ▁( ▁n 2 ▁> ▁0 ▁) ▁test _ printf _ stderr ▁( ▁"% 4 u :+ ' % s '\ n " ▁, ▁cnt ▁, ▁b 2 ▁) ▁; ▁if ▁( ▁diff ▁&& ▁i ▁> ▁0 ▁) ▁test _ printf _ stderr ▁( ▁"% 4 s % s \ n " ▁, ▁"" ▁, ▁b diff ▁) ▁; ▁} ▁m 1 ▁+= ▁n 1 ▁; ▁m 2 ▁+= ▁n 2 ▁; ▁l 1 ▁-= ▁n 1 ▁; ▁l 2 ▁-= ▁n 2 ▁; ▁cnt ▁+= ▁width ▁; ▁} ▁fin ▁: ▁test _ flush _ stderr ▁( ▁) ▁; ▁}	1
▁static ▁inline ▁int ▁ff _ j 2 k _ ce ild iv ▁( ▁int ▁a ▁, ▁int ▁b ▁) ▁{ ▁return ▁( ▁a ▁+ ▁b ▁- ▁1 ▁) ▁/ ▁b ▁; ▁}	1
▁static ▁int ▁do _ sig ver _ init ▁( ▁EVP _ MD _ CTX ▁* ▁ctx ▁, ▁EVP _ PKEY _ CTX ▁* ▁* ▁pctx ▁, ▁const ▁EVP _ MD ▁* ▁type ▁, ▁ENGINE ▁* ▁e ▁, ▁EVP _ PKEY ▁* ▁pkey ▁, ▁int ▁ver ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁pctx ▁== ▁NULL ▁) ▁ctx ▁-> ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new ▁( ▁pkey ▁, ▁e ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁pctx ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁( ▁ctx ▁-> ▁pctx ▁-> ▁pm eth ▁-> ▁flags ▁& ▁EVP _ PKEY _ FLAG _ SIG CTX _ CUSTOM ▁) ▁) ▁{ ▁if ▁( ▁type ▁== ▁NULL ▁) ▁{ ▁int ▁def _ nid ▁; ▁if ▁( ▁EVP _ PKEY _ get _ default _ digest _ nid ▁( ▁pkey ▁, ▁& ▁def _ nid ▁) ▁> ▁0 ▁) ▁type ▁= ▁EVP _ get _ digest b yn id ▁( ▁def _ nid ▁) ▁; ▁} ▁if ▁( ▁type ▁== ▁NULL ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ DO _ SIG VER _ INIT ▁, ▁EVP _ R _ NO _ DEFAULT _ DIGEST ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁if ▁( ▁ver ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁pctx ▁-> ▁pm eth ▁-> ▁verify ctx _ init ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁pctx ▁-> ▁pm eth ▁-> ▁verify ctx _ init ▁( ▁ctx ▁-> ▁pctx ▁, ▁ctx ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁ctx ▁-> ▁pctx ▁-> ▁operation ▁= ▁EVP _ PKEY _ OP _ VERIFY CTX ▁; ▁} ▁else ▁if ▁( ▁EVP _ PKEY _ verify _ init ▁( ▁ctx ▁-> ▁pctx ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁} ▁else ▁{ ▁if ▁( ▁ctx ▁-> ▁pctx ▁-> ▁pm eth ▁-> ▁sign ctx _ init ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁pctx ▁-> ▁pm eth ▁-> ▁sign ctx _ init ▁( ▁ctx ▁-> ▁pctx ▁, ▁ctx ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁ctx ▁-> ▁pctx ▁-> ▁operation ▁= ▁EVP _ PKEY _ OP _ SIGN CTX ▁; ▁} ▁else ▁if ▁( ▁EVP _ PKEY _ sign _ init ▁( ▁ctx ▁-> ▁pctx ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁EVP _ PKEY _ CTX _ set _ signature _ md ▁( ▁ctx ▁-> ▁pctx ▁, ▁type ▁) ▁<= ▁0 ▁) ▁return ▁0 ▁; ▁if ▁( ▁pctx ▁) ▁* ▁pctx ▁= ▁ctx ▁-> ▁pctx ▁; ▁if ▁( ▁ctx ▁-> ▁pctx ▁-> ▁pm eth ▁-> ▁flags ▁& ▁EVP _ PKEY _ FLAG _ SIG CTX _ CUSTOM ▁) ▁return ▁1 ▁; ▁if ▁( ▁! ▁EVP _ Digest Init _ ex ▁( ▁ctx ▁, ▁type ▁, ▁e ▁) ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁void ▁F UN CC ▁( ▁pred 4 x 4_ dc ▁) ▁( ▁uint 8_ t ▁* ▁_ src ▁, ▁const ▁uint 8_ t ▁* ▁top right ▁, ▁int ▁_ stride ▁) ▁{ ▁pixel ▁* ▁src ▁= ▁( ▁pixel ▁* ▁) ▁_ src ▁; ▁int ▁stride ▁= ▁_ stride ▁/ ▁sizeof ▁( ▁pixel ▁) ▁; ▁const ▁int ▁dc ▁= ▁( ▁src ▁[ ▁- ▁stride ▁] ▁+ ▁src ▁[ ▁1 ▁- ▁stride ▁] ▁+ ▁src ▁[ ▁2 ▁- ▁stride ▁] ▁+ ▁src ▁[ ▁3 ▁- ▁stride ▁] ▁+ ▁src ▁[ ▁-1 ▁+ ▁0 ▁* ▁stride ▁] ▁+ ▁src ▁[ ▁-1 ▁+ ▁1 ▁* ▁stride ▁] ▁+ ▁src ▁[ ▁-1 ▁+ ▁2 ▁* ▁stride ▁] ▁+ ▁src ▁[ ▁-1 ▁+ ▁3 ▁* ▁stride ▁] ▁+ ▁4 ▁) ▁>> ▁3 ▁; ▁const ▁pixel 4 ▁a ▁= ▁PIXEL _ SPL AT _ X 4 ▁( ▁dc ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁0 ▁* ▁stride ▁, ▁a ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁1 ▁* ▁stride ▁, ▁a ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁2 ▁* ▁stride ▁, ▁a ▁) ▁; ▁AV _ WN 4 PA ▁( ▁src ▁+ ▁3 ▁* ▁stride ▁, ▁a ▁) ▁; ▁}	0
▁SSL _ CTX ▁* ▁SSL _ CTX _ new ▁( ▁const ▁SSL _ METHOD ▁* ▁meth ▁) ▁{ ▁SSL _ CTX ▁* ▁ret ▁= ▁NULL ▁; ▁if ▁( ▁meth ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ NULL _ SSL _ METHOD _ PASSED ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁if ▁( ▁FIPS _ mode ▁( ▁) ▁&& ▁( ▁meth ▁-> ▁version ▁< ▁TLS 1_ VERSION ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ ONLY _ TLS _ ALLOWED _ IN _ FIPS _ MODE ▁) ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁SSL _ get _ ex _ data _ X 509_ STORE _ CTX _ idx ▁( ▁) ▁< ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ X 509_ VER IFICATION _ SETUP _ PRO BLE MS ▁) ▁; ▁goto ▁err ▁; ▁} ▁ret ▁= ▁( ▁SSL _ CTX ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁SSL _ CTX ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁memset ▁( ▁ret ▁, ▁0 ▁, ▁sizeof ▁( ▁SSL _ CTX ▁) ▁) ▁; ▁ret ▁-> ▁method ▁= ▁meth ▁; ▁ret ▁-> ▁cert _ store ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ cache _ mode ▁= ▁SSL _ S ESS _ CACHE _ SERVER ▁; ▁ret ▁-> ▁session _ cache _ size ▁= ▁SSL _ SESSION _ CACHE _ MAX _ SIZE _ DEFAULT ▁; ▁ret ▁-> ▁session _ cache _ head ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ cache _ tail ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ timeout ▁= ▁meth ▁-> ▁get _ timeout ▁( ▁) ▁; ▁ret ▁-> ▁new _ session _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁remove _ session _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁get _ session _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁generate _ session _ id ▁= ▁0 ▁; ▁memset ▁( ▁( ▁char ▁* ▁) ▁& ▁ret ▁-> ▁stats ▁, ▁0 ▁, ▁sizeof ▁( ▁ret ▁-> ▁stats ▁) ▁) ▁; ▁ret ▁-> ▁references ▁= ▁1 ▁; ▁ret ▁-> ▁quiet _ shutdown ▁= ▁0 ▁; ▁ret ▁-> ▁info _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁app _ verify _ callback ▁= ▁0 ▁; ▁ret ▁-> ▁app _ verify _ arg ▁= ▁NULL ▁; ▁ret ▁-> ▁max _ cert _ list ▁= ▁SSL _ MAX _ CERT _ LIST _ DEFAULT ▁; ▁ret ▁-> ▁read _ ahead ▁= ▁0 ▁; ▁ret ▁-> ▁msg _ callback ▁= ▁0 ▁; ▁ret ▁-> ▁msg _ callback _ arg ▁= ▁NULL ▁; ▁ret ▁-> ▁verify _ mode ▁= ▁SSL _ VERIFY _ NONE ▁; ▁# if ▁0 ▁ret ▁-> ▁verify _ depth ▁= ▁-1 ▁; ▁# endif ▁ret ▁-> ▁sid _ ctx _ length ▁= ▁0 ▁; ▁ret ▁-> ▁default _ verify _ callback ▁= ▁NULL ▁; ▁if ▁( ▁( ▁ret ▁-> ▁cert ▁= ▁ssl _ cert _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁default _ passwd _ callback ▁= ▁0 ▁; ▁ret ▁-> ▁default _ passwd _ callback _ userdata ▁= ▁NULL ▁; ▁ret ▁-> ▁client _ cert _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁app _ gen _ cookie _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁app _ verify _ cookie _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁sessions ▁= ▁lh _ SSL _ SESSION _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁sessions ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁cert _ store ▁= ▁X 509_ STORE _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cert _ store ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ssl _ create _ cipher _ list ▁( ▁ret ▁-> ▁method ▁, ▁& ▁ret ▁-> ▁cipher _ list ▁, ▁& ▁ret ▁-> ▁cipher _ list _ by _ id ▁, ▁SSL _ DEFAULT _ CIPHER _ LIST ▁, ▁ret ▁-> ▁cert ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cipher _ list ▁== ▁NULL ▁|| ▁sk _ SSL _ CIPHER _ num ▁( ▁ret ▁-> ▁cipher _ list ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ LIBRARY _ HAS _ NO _ CIPHER S ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁ret ▁-> ▁param ▁= ▁X 509_ VERIFY _ PARAM _ new ▁( ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁param ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁ret ▁-> ▁md 5 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- md 5" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ MD 5_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁sha 1 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- sha 1" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ SHA 1_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁client _ CA ▁= ▁sk _ X 509_ NAME _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁CRYPTO _ new _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL _ CTX ▁, ▁ret ▁, ▁& ▁ret ▁-> ▁ex _ data ▁) ▁; ▁ret ▁-> ▁extra _ certs ▁= ▁NULL ▁; ▁if ▁( ▁! ▁( ▁meth ▁-> ▁ssl 3_ enc ▁-> ▁enc _ flags ▁& ▁SSL _ ENC _ FLAG _ DT LS ▁) ▁) ▁ret ▁-> ▁comp _ methods ▁= ▁SSL _ COMP _ get _ compression _ methods ▁( ▁) ▁; ▁ret ▁-> ▁max _ send _ fragment ▁= ▁SSL 3_ RT _ MAX _ PLAIN _ LENGTH ▁; ▁# ifndef ▁OPENSSL _ NO _ TL SE XT ▁ret ▁-> ▁tl se xt _ server name _ callback ▁= ▁0 ▁; ▁ret ▁-> ▁tl se xt _ server name _ arg ▁= ▁NULL ▁; ▁if ▁( ▁( ▁RAND _ pseudo _ bytes ▁( ▁ret ▁-> ▁tl se xt _ tick _ key _ name ▁, ▁16 ▁) ▁<= ▁0 ▁) ▁|| ▁( ▁RAND _ bytes ▁( ▁ret ▁-> ▁tl se xt _ tick _ hmac _ key ▁, ▁16 ▁) ▁<= ▁0 ▁) ▁|| ▁( ▁RAND _ bytes ▁( ▁ret ▁-> ▁tl se xt _ tick _ aes _ key ▁, ▁16 ▁) ▁<= ▁0 ▁) ▁) ▁ret ▁-> ▁options ▁|= ▁SSL _ OP _ NO _ TICK ET ▁; ▁ret ▁-> ▁tl se xt _ status _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁tl se xt _ status _ arg ▁= ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ NEXT PROT ONE G ▁ret ▁-> ▁next _ protos _ ad vert ised _ cb ▁= ▁0 ▁; ▁ret ▁-> ▁next _ proto _ select _ cb ▁= ▁0 ▁; ▁# endif ▁# endif ▁# ifndef ▁OPENSSL _ NO _ PS K ▁ret ▁-> ▁p sk _ identity _ hint ▁= ▁NULL ▁; ▁ret ▁-> ▁p sk _ client _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁p sk _ server _ callback ▁= ▁NULL ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ SR P ▁SSL _ CTX _ SR P _ CTX _ init ▁( ▁ret ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁ret ▁-> ▁client _ cert _ engine ▁= ▁NULL ▁; ▁# ifdef ▁OPENSSL _ SSL _ CLIENT _ ENGINE _ AUTO ▁# define ▁eng _ str x ▁( ▁x ▁) ▁# x ▁# define ▁eng _ str ▁( ▁x ▁) ▁eng _ str x ( x ) ▁{ ▁ENGINE ▁* ▁eng ▁; ▁eng ▁= ▁ENGINE _ by _ id ▁( ▁eng _ str ▁( ▁OPENSSL _ SSL _ CLIENT _ ENGINE _ AUTO ▁) ▁) ▁; ▁if ▁( ▁! ▁eng ▁) ▁{ ▁ERR _ clear _ error ▁( ▁) ▁; ▁ENGINE _ load _ builtin _ engines ▁( ▁) ▁; ▁eng ▁= ▁ENGINE _ by _ id ▁( ▁eng _ str ▁( ▁OPENSSL _ SSL _ CLIENT _ ENGINE _ AUTO ▁) ▁) ▁; ▁} ▁if ▁( ▁! ▁eng ▁|| ▁! ▁SSL _ CTX _ set _ client _ cert _ engine ▁( ▁ret ▁, ▁eng ▁) ▁) ▁ERR _ clear _ error ▁( ▁) ▁; ▁} ▁# endif ▁# endif ▁ret ▁-> ▁options ▁|= ▁SSL _ OP _ LEGACY _ SERVER _ CONNECT ▁; ▁return ▁( ▁ret ▁) ▁; ▁err ▁: ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁err 2 ▁: ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁SSL _ CTX _ free ▁( ▁ret ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	1
▁static ▁int ▁c ine p ak _ decode _ vectors ▁( ▁C ine p ak Context ▁* ▁s ▁, ▁cv id _ strip ▁* ▁strip ▁, ▁int ▁chunk _ id ▁, ▁int ▁size ▁, ▁const ▁uint 8_ t ▁* ▁data ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁e od ▁= ▁( ▁data ▁+ ▁size ▁) ▁; ▁uint 32_ t ▁flag ▁, ▁mask ▁; ▁uint 8_ t ▁* ▁cb 0 ▁, ▁* ▁cb 1 ▁, ▁* ▁cb 2 ▁, ▁* ▁cb 3 ▁; ▁int ▁x ▁, ▁y ▁; ▁char ▁* ▁ip 0 ▁, ▁* ▁ip 1 ▁, ▁* ▁ip 2 ▁, ▁* ▁ip 3 ▁; ▁flag ▁= ▁0 ▁; ▁mask ▁= ▁0 ▁; ▁for ▁( ▁y ▁= ▁strip ▁-> ▁y 1 ▁; ▁y ▁< ▁strip ▁-> ▁y 2 ▁; ▁y ▁+= ▁4 ▁) ▁{ ▁ip 0 ▁= ▁ip 1 ▁= ▁ip 2 ▁= ▁ip 3 ▁= ▁s ▁-> ▁frame ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁( ▁s ▁-> ▁palette _ video ▁? ▁strip ▁-> ▁x 1 ▁: ▁strip ▁-> ▁x 1 ▁* ▁3 ▁) ▁+ ▁( ▁y ▁* ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁- ▁y ▁> ▁1 ▁) ▁{ ▁ip 1 ▁= ▁ip 0 ▁+ ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁- ▁y ▁> ▁2 ▁) ▁{ ▁ip 2 ▁= ▁ip 1 ▁+ ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁height ▁- ▁y ▁> ▁3 ▁) ▁{ ▁ip 3 ▁= ▁ip 2 ▁+ ▁s ▁-> ▁frame ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁} ▁} ▁} ▁for ▁( ▁x ▁= ▁strip ▁-> ▁x 1 ▁; ▁x ▁< ▁strip ▁-> ▁x 2 ▁; ▁x ▁+= ▁4 ▁) ▁{ ▁if ▁( ▁( ▁chunk _ id ▁& ▁0 x 01 ▁) ▁&& ▁! ▁( ▁mask ▁>>= ▁1 ▁) ▁) ▁{ ▁if ▁( ▁( ▁data ▁+ ▁4 ▁) ▁> ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁flag ▁= ▁AV _ RB 32 ▁( ▁data ▁) ▁; ▁data ▁+= ▁4 ▁; ▁mask ▁= ▁0 x 80000000 ▁; ▁} ▁if ▁( ▁! ▁( ▁chunk _ id ▁& ▁0 x 01 ▁) ▁|| ▁( ▁flag ▁& ▁mask ▁) ▁) ▁{ ▁if ▁( ▁! ▁( ▁chunk _ id ▁& ▁0 x 02 ▁) ▁&& ▁! ▁( ▁mask ▁>>= ▁1 ▁) ▁) ▁{ ▁if ▁( ▁( ▁data ▁+ ▁4 ▁) ▁> ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁flag ▁= ▁AV _ RB 32 ▁( ▁data ▁) ▁; ▁data ▁+= ▁4 ▁; ▁mask ▁= ▁0 x 80000000 ▁; ▁} ▁if ▁( ▁( ▁chunk _ id ▁& ▁0 x 02 ▁) ▁|| ▁( ▁ ~ ▁flag ▁& ▁mask ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁p ▁; ▁if ▁( ▁data ▁>= ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁p ▁= ▁strip ▁-> ▁v 1_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁if ▁( ▁s ▁-> ▁palette _ video ▁) ▁{ ▁ip 3 ▁[ ▁0 ▁] ▁= ▁ip 3 ▁[ ▁1 ▁] ▁= ▁ip 2 ▁[ ▁0 ▁] ▁= ▁ip 2 ▁[ ▁1 ▁] ▁= ▁p ▁[ ▁6 ▁] ▁; ▁ip 3 ▁[ ▁2 ▁] ▁= ▁ip 3 ▁[ ▁3 ▁] ▁= ▁ip 2 ▁[ ▁2 ▁] ▁= ▁ip 2 ▁[ ▁3 ▁] ▁= ▁p ▁[ ▁9 ▁] ▁; ▁ip 1 ▁[ ▁0 ▁] ▁= ▁ip 1 ▁[ ▁1 ▁] ▁= ▁ip 0 ▁[ ▁0 ▁] ▁= ▁ip 0 ▁[ ▁1 ▁] ▁= ▁p ▁[ ▁0 ▁] ▁; ▁ip 1 ▁[ ▁2 ▁] ▁= ▁ip 1 ▁[ ▁3 ▁] ▁= ▁ip 0 ▁[ ▁2 ▁] ▁= ▁ip 0 ▁[ ▁3 ▁] ▁= ▁p ▁[ ▁3 ▁] ▁; ▁} ▁else ▁{ ▁p ▁+= ▁6 ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁p ▁+= ▁3 ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁p ▁-= ▁9 ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁0 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁3 ▁, ▁p ▁, ▁3 ▁) ▁; ▁p ▁+= ▁3 ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁6 ▁, ▁p ▁, ▁3 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁9 ▁, ▁p ▁, ▁3 ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁flag ▁& ▁mask ▁) ▁{ ▁if ▁( ▁( ▁data ▁+ ▁4 ▁) ▁> ▁e od ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁cb 0 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁cb 1 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁cb 2 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁cb 3 ▁= ▁strip ▁-> ▁v 4_ code book ▁[ ▁* ▁data ▁++ ▁] ▁; ▁if ▁( ▁s ▁-> ▁palette _ video ▁) ▁{ ▁uint 8_ t ▁* ▁p ▁; ▁p ▁= ▁ip 3 ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁9 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 3 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁= ▁cb 3 ▁[ ▁9 ▁] ▁; ▁p ▁= ▁ip 2 ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 2 ▁[ ▁3 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 3 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁= ▁cb 3 ▁[ ▁3 ▁] ▁; ▁p ▁= ▁ip 1 ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁9 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 1 ▁[ ▁6 ▁] ▁; ▁* ▁p ▁= ▁cb 1 ▁[ ▁9 ▁] ▁; ▁p ▁= ▁ip 0 ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 0 ▁[ ▁3 ▁] ▁; ▁* ▁p ▁++ ▁= ▁cb 1 ▁[ ▁0 ▁] ▁; ▁* ▁p ▁= ▁cb 1 ▁[ ▁3 ▁] ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁ip 3 ▁+ ▁0 ▁, ▁cb 2 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 3 ▁+ ▁6 ▁, ▁cb 3 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁0 ▁, ▁cb 2 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 2 ▁+ ▁6 ▁, ▁cb 3 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁0 ▁, ▁cb 0 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 1 ▁+ ▁6 ▁, ▁cb 1 ▁+ ▁6 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁0 ▁, ▁cb 0 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁memcpy ▁( ▁ip 0 ▁+ ▁6 ▁, ▁cb 1 ▁+ ▁0 ▁, ▁6 ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁s ▁-> ▁palette _ video ▁) ▁{ ▁ip 0 ▁+= ▁4 ▁; ▁ip 1 ▁+= ▁4 ▁; ▁ip 2 ▁+= ▁4 ▁; ▁ip 3 ▁+= ▁4 ▁; ▁} ▁else ▁{ ▁ip 0 ▁+= ▁12 ▁; ▁ip 1 ▁+= ▁12 ▁; ▁ip 2 ▁+= ▁12 ▁; ▁ip 3 ▁+= ▁12 ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁long ▁conn _ ctrl ▁( ▁BIO ▁* ▁b ▁, ▁int ▁cmd ▁, ▁long ▁num ▁, ▁void ▁* ▁ptr ▁) ▁{ ▁BIO ▁* ▁db io ▁; ▁int ▁* ▁ip ▁; ▁const ▁char ▁* ▁* ▁pptr ▁= ▁NULL ▁; ▁long ▁ret ▁= ▁1 ▁; ▁BIO _ CONNECT ▁* ▁data ▁; ▁data ▁= ▁( ▁BIO _ CONNECT ▁* ▁) ▁b ▁-> ▁ptr ▁; ▁switch ▁( ▁cmd ▁) ▁{ ▁case ▁BIO _ CTRL _ RESET ▁: ▁ret ▁= ▁0 ▁; ▁data ▁-> ▁state ▁= ▁BIO _ CONN _ S _ BEFORE ▁; ▁conn _ close _ socket ▁( ▁b ▁) ▁; ▁b ▁-> ▁flags ▁= ▁0 ▁; ▁break ▁; ▁case ▁BIO _ C _ DO _ STATE _ MACHINE ▁: ▁if ▁( ▁data ▁-> ▁state ▁!= ▁BIO _ CONN _ S _ OK ▁) ▁ret ▁= ▁( ▁long ▁) ▁conn _ state ▁( ▁b ▁, ▁data ▁) ▁; ▁else ▁ret ▁= ▁1 ▁; ▁break ▁; ▁case ▁BIO _ C _ GET _ CONNECT ▁: ▁if ▁( ▁ptr ▁!= ▁NULL ▁) ▁{ ▁pptr ▁= ▁( ▁const ▁char ▁* ▁* ▁) ▁ptr ▁; ▁} ▁if ▁( ▁b ▁-> ▁init ▁) ▁{ ▁if ▁( ▁pptr ▁!= ▁NULL ▁) ▁{ ▁ret ▁= ▁1 ▁; ▁if ▁( ▁num ▁== ▁0 ▁) ▁{ ▁* ▁pptr ▁= ▁data ▁-> ▁param _ hostname ▁; ▁} ▁else ▁if ▁( ▁num ▁== ▁1 ▁) ▁{ ▁* ▁pptr ▁= ▁data ▁-> ▁param _ port ▁; ▁} ▁else ▁if ▁( ▁num ▁== ▁2 ▁) ▁{ ▁* ▁pptr ▁= ▁( ▁char ▁* ▁) ▁& ▁( ▁data ▁-> ▁ip ▁[ ▁0 ▁] ▁) ▁; ▁} ▁else ▁{ ▁ret ▁= ▁0 ▁; ▁} ▁} ▁if ▁( ▁num ▁== ▁3 ▁) ▁{ ▁ret ▁= ▁data ▁-> ▁port ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁pptr ▁!= ▁NULL ▁) ▁* ▁pptr ▁= ▁" not initialized " ▁; ▁ret ▁= ▁0 ▁; ▁} ▁break ▁; ▁case ▁BIO _ C _ SET _ CONNECT ▁: ▁if ▁( ▁ptr ▁!= ▁NULL ▁) ▁{ ▁b ▁-> ▁init ▁= ▁1 ▁; ▁if ▁( ▁num ▁== ▁0 ▁) ▁{ ▁OPENSSL _ free ▁( ▁data ▁-> ▁param _ hostname ▁) ▁; ▁data ▁-> ▁param _ hostname ▁= ▁OPENSSL _ strdup ▁( ▁ptr ▁) ▁; ▁} ▁else ▁if ▁( ▁num ▁== ▁1 ▁) ▁{ ▁OPENSSL _ free ▁( ▁data ▁-> ▁param _ port ▁) ▁; ▁data ▁-> ▁param _ port ▁= ▁OPENSSL _ strdup ▁( ▁ptr ▁) ▁; ▁} ▁else ▁if ▁( ▁num ▁== ▁2 ▁) ▁{ ▁char ▁buf ▁[ ▁16 ▁] ▁; ▁unsigned ▁char ▁* ▁p ▁= ▁ptr ▁; ▁BIO _ snprintf ▁( ▁buf ▁, ▁sizeof ▁buf ▁, ▁"% d .% d .% d .% d " ▁, ▁p ▁[ ▁0 ▁] ▁, ▁p ▁[ ▁1 ▁] ▁, ▁p ▁[ ▁2 ▁] ▁, ▁p ▁[ ▁3 ▁] ▁) ▁; ▁OPENSSL _ free ▁( ▁data ▁-> ▁param _ hostname ▁) ▁; ▁data ▁-> ▁param _ hostname ▁= ▁OPENSSL _ strdup ▁( ▁buf ▁) ▁; ▁memcpy ▁( ▁& ▁( ▁data ▁-> ▁ip ▁[ ▁0 ▁] ▁) ▁, ▁ptr ▁, ▁4 ▁) ▁; ▁} ▁else ▁if ▁( ▁num ▁== ▁3 ▁) ▁{ ▁char ▁buf ▁[ ▁DECIMAL _ SIZE ▁( ▁int ▁) ▁+ ▁1 ▁] ▁; ▁BIO _ snprintf ▁( ▁buf ▁, ▁sizeof ▁buf ▁, ▁"% d " ▁, ▁* ▁( ▁int ▁* ▁) ▁ptr ▁) ▁; ▁OPENSSL _ free ▁( ▁data ▁-> ▁param _ port ▁) ▁; ▁data ▁-> ▁param _ port ▁= ▁OPENSSL _ strdup ▁( ▁buf ▁) ▁; ▁data ▁-> ▁port ▁= ▁* ▁( ▁int ▁* ▁) ▁ptr ▁; ▁} ▁} ▁break ▁; ▁case ▁BIO _ C _ SET _ NB IO ▁: ▁data ▁-> ▁nbio ▁= ▁( ▁int ▁) ▁num ▁; ▁break ▁; ▁case ▁BIO _ C _ GET _ FD ▁: ▁if ▁( ▁b ▁-> ▁init ▁) ▁{ ▁ip ▁= ▁( ▁int ▁* ▁) ▁ptr ▁; ▁if ▁( ▁ip ▁!= ▁NULL ▁) ▁* ▁ip ▁= ▁b ▁-> ▁num ▁; ▁ret ▁= ▁b ▁-> ▁num ▁; ▁} ▁else ▁ret ▁= ▁-1 ▁; ▁break ▁; ▁case ▁BIO _ CTRL _ GET _ CLOSE ▁: ▁ret ▁= ▁b ▁-> ▁shutdown ▁; ▁break ▁; ▁case ▁BIO _ CTRL _ SET _ CLOSE ▁: ▁b ▁-> ▁shutdown ▁= ▁( ▁int ▁) ▁num ▁; ▁break ▁; ▁case ▁BIO _ CTRL _ PENDING ▁: ▁case ▁BIO _ CTRL _ W PENDING ▁: ▁ret ▁= ▁0 ▁; ▁break ▁; ▁case ▁BIO _ CTRL _ FLUSH ▁: ▁break ▁; ▁case ▁BIO _ CTRL _ DUP ▁: ▁{ ▁db io ▁= ▁( ▁BIO ▁* ▁) ▁ptr ▁; ▁if ▁( ▁data ▁-> ▁param _ port ▁) ▁BIO _ set _ conn _ port ▁( ▁db io ▁, ▁data ▁-> ▁param _ port ▁) ▁; ▁if ▁( ▁data ▁-> ▁param _ hostname ▁) ▁BIO _ set _ conn _ hostname ▁( ▁db io ▁, ▁data ▁-> ▁param _ hostname ▁) ▁; ▁BIO _ set _ nb io ▁( ▁db io ▁, ▁data ▁-> ▁nbio ▁) ▁; ▁( ▁void ▁) ▁BIO _ set _ info _ callback ▁( ▁db io ▁, ▁( ▁bio _ info _ cb ▁* ▁) ▁data ▁-> ▁info _ callback ▁) ▁; ▁} ▁break ▁; ▁case ▁BIO _ CTRL _ SET _ CALLBACK ▁: ▁{ ▁# if ▁0 ▁BIO err ▁( ▁BIO _ F _ CONN _ CTRL ▁, ▁ERR _ R _ SHOULD _ NOT _ HAVE _ BE EN _ CALLED ▁) ▁; ▁ret ▁= ▁-1 ▁; ▁# else ▁ret ▁= ▁0 ▁; ▁# endif ▁} ▁break ▁; ▁case ▁BIO _ CTRL _ GET _ CALLBACK ▁: ▁{ ▁int ▁( ▁* ▁* ▁fptr ▁) ▁( ▁const ▁BIO ▁* ▁bio ▁, ▁int ▁state ▁, ▁int ▁x ret ▁) ▁; ▁fptr ▁= ▁( ▁int ▁( ▁* ▁* ▁) ▁( ▁const ▁BIO ▁* ▁bio ▁, ▁int ▁state ▁, ▁int ▁x ret ▁) ▁) ▁ptr ▁; ▁* ▁fptr ▁= ▁data ▁-> ▁info _ callback ▁; ▁} ▁break ▁; ▁default ▁: ▁ret ▁= ▁0 ▁; ▁break ▁; ▁} ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁int ▁copy _ from ▁( ▁Ip video Context ▁* ▁s ▁, ▁AVFrame ▁* ▁src ▁, ▁int ▁delta _ x ▁, ▁int ▁delta _ y ▁) ▁{ ▁int ▁current _ offset ▁= ▁s ▁-> ▁pixel _ ptr ▁- ▁s ▁-> ▁current _ frame ▁. ▁data ▁[ ▁0 ▁] ▁; ▁int ▁motion _ offset ▁= ▁current _ offset ▁+ ▁delta _ y ▁* ▁s ▁-> ▁current _ frame ▁. ▁linesize ▁[ ▁0 ▁] ▁+ ▁delta _ x ▁* ▁( ▁1 ▁+ ▁s ▁-> ▁is _16 bpp ▁) ▁; ▁if ▁( ▁motion _ offset ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Inter play video : motion offset < 0 (% d )\ n " ▁, ▁motion _ offset ▁) ▁; ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁motion _ offset ▁> ▁s ▁-> ▁upper _ motion _ limit _ offset ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Inter play video : motion offset above limit (% d > =% d )\ n " ▁, ▁motion _ offset ▁, ▁s ▁-> ▁upper _ motion _ limit _ offset ▁) ▁; ▁return ▁-1 ▁; ▁} ▁s ▁-> ▁dsp ▁. ▁put _ pixels _ tab ▁[ ▁! ▁s ▁-> ▁is _16 bpp ▁] ▁[ ▁0 ▁] ▁( ▁s ▁-> ▁pixel _ ptr ▁, ▁src ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁motion _ offset ▁, ▁s ▁-> ▁current _ frame ▁. ▁linesize ▁[ ▁0 ▁] ▁, ▁8 ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁_ TIFF Reserve Large En ough Write Buffer ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 32 ▁strip _ or _ tile ▁) ▁{ ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁if ▁( ▁td ▁-> ▁td _ strip byte count ▁[ ▁strip _ or _ tile ▁] ▁> ▁0 ▁) ▁{ ▁uint 64 ▁safe _ buffer _ size ▁= ▁( ▁uint 64 ▁) ▁( ▁td ▁-> ▁td _ strip byte count ▁[ ▁strip _ or _ tile ▁] ▁+ ▁1 ▁+ ▁4 ▁) ▁; ▁if ▁( ▁tif ▁-> ▁tif _ raw datas ize ▁<= ▁( ▁tm size _ t ▁) ▁safe _ buffer _ size ▁) ▁{ ▁if ▁( ▁! ▁( ▁TIFF Write Buffer Setup ▁( ▁tif ▁, ▁NULL ▁, ▁( ▁tm size _ t ▁) ▁TIFF round up _64 ▁( ▁safe _ buffer _ size ▁, ▁1024 ▁) ▁) ▁) ▁) ▁return ▁0 ▁; ▁} ▁tif ▁-> ▁tif _ cur off ▁= ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁int ▁EVP _ Encrypt Final _ ex ▁( ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁int ▁* ▁outl ▁) ▁{ ▁int ▁i ▁, ▁n ▁, ▁b ▁, ▁bl ▁, ▁ret ▁; ▁b ▁= ▁ctx ▁-> ▁cipher ▁-> ▁block _ size ▁; ▁OPENSSL _ assert ▁( ▁b ▁<= ▁sizeof ▁ctx ▁-> ▁buf ▁) ▁; ▁if ▁( ▁b ▁== ▁1 ▁) ▁{ ▁* ▁outl ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁bl ▁= ▁ctx ▁-> ▁buf _ len ▁; ▁if ▁( ▁ctx ▁-> ▁flags ▁& ▁EVP _ C IPH _ NO _ PADDING ▁) ▁{ ▁if ▁( ▁bl ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ ENCRYPT FINAL ▁, ▁EVP _ R _ DATA _ NOT _ MULTIPLE _ OF _ BLOCK _ LENGTH ▁) ▁; ▁return ▁0 ▁; ▁} ▁* ▁outl ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁n ▁= ▁b ▁- ▁bl ▁; ▁for ▁( ▁i ▁= ▁bl ▁; ▁i ▁< ▁b ▁; ▁i ▁++ ▁) ▁ctx ▁-> ▁buf ▁[ ▁i ▁] ▁= ▁n ▁; ▁ret ▁= ▁ctx ▁-> ▁cipher ▁-> ▁do _ cipher ▁( ▁ctx ▁, ▁out ▁, ▁ctx ▁-> ▁buf ▁, ▁b ▁) ▁; ▁if ▁( ▁ret ▁) ▁* ▁outl ▁= ▁b ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁ass _ get _ duration ▁( ▁AVFormatContext ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁p ▁) ▁{ ▁int ▁sh ▁, ▁sm ▁, ▁ss ▁, ▁sc ▁, ▁eh ▁, ▁em ▁, ▁es ▁, ▁ec ▁; ▁uint 64_ t ▁start ▁, ▁end ▁; ▁if ▁( ▁sscanf ▁( ▁p ▁, ▁"%* [ ^ , ], % d :% d :% d % * c % d ,% d :% d :% d % * c % d " ▁, ▁& ▁sh ▁, ▁& ▁sm ▁, ▁& ▁ss ▁, ▁& ▁sc ▁, ▁& ▁eh ▁, ▁& ▁em ▁, ▁& ▁es ▁, ▁& ▁ec ▁) ▁!= ▁8 ▁) ▁return ▁0 ▁; ▁if ▁( ▁sh ▁> ▁9 ▁|| ▁sm ▁> ▁59 ▁|| ▁ss ▁> ▁59 ▁|| ▁sc ▁> ▁99 ▁|| ▁eh ▁> ▁9 ▁|| ▁em ▁> ▁59 ▁|| ▁es ▁> ▁59 ▁|| ▁ec ▁> ▁99 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Non - standard timer eference % d :% d :% d .% d ,% d :% d :% d .% d \ n " ▁, ▁sh ▁, ▁sm ▁, ▁ss ▁, ▁sc ▁, ▁eh ▁, ▁em ▁, ▁es ▁, ▁ec ▁) ▁; ▁return ▁0 ▁; ▁} ▁start ▁= ▁36 00000 ▁* ▁sh ▁+ ▁60000 ▁* ▁sm ▁+ ▁1000 ▁* ▁ss ▁+ ▁10 ▁* ▁sc ▁; ▁end ▁= ▁36 00000 ▁* ▁eh ▁+ ▁60000 ▁* ▁em ▁+ ▁1000 ▁* ▁es ▁+ ▁10 ▁* ▁ec ▁; ▁if ▁( ▁start ▁> ▁end ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Unexpected timer eference % d :% d :% d .% d ,% d :% d :% d .% d \ n " ▁, ▁sh ▁, ▁sm ▁, ▁ss ▁, ▁sc ▁, ▁eh ▁, ▁em ▁, ▁es ▁, ▁ec ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁end ▁- ▁start ▁; ▁}	0
▁static ▁int ▁get _ slice _ offset ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁n ▁, ▁int ▁slice _ count ▁, ▁int ▁buf _ size ▁) ▁{ ▁if ▁( ▁n ▁< ▁slice _ count ▁) ▁{ ▁if ▁( ▁avctx ▁-> ▁slice _ count ▁) ▁return ▁avctx ▁-> ▁slice _ offset ▁[ ▁n ▁] ▁; ▁else ▁return ▁AV _ RL 32 ▁( ▁buf ▁+ ▁n ▁* ▁8 ▁- ▁4 ▁) ▁== ▁1 ▁? ▁AV _ RL 32 ▁( ▁buf ▁+ ▁n ▁* ▁8 ▁) ▁: ▁AV _ RB 32 ▁( ▁buf ▁+ ▁n ▁* ▁8 ▁) ▁; ▁} ▁else ▁return ▁buf _ size ▁; ▁}	0
▁int ▁avfilter _ open ▁( ▁AVFilter Context ▁* ▁* ▁filter _ ctx ▁, ▁AVFilter ▁* ▁filter ▁, ▁const ▁char ▁* ▁inst _ name ▁) ▁{ ▁AVFilter Context ▁* ▁ret ▁; ▁* ▁filter _ ctx ▁= ▁NULL ▁; ▁if ▁( ▁! ▁filter ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁ret ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Context ▁) ▁) ▁; ▁ret ▁-> ▁av _ class ▁= ▁& ▁avfilter _ class ▁; ▁ret ▁-> ▁filter ▁= ▁filter ▁; ▁ret ▁-> ▁name ▁= ▁inst _ name ▁? ▁av _ strdup ▁( ▁inst _ name ▁) ▁: ▁NULL ▁; ▁if ▁( ▁filter ▁-> ▁priv _ size ▁) ▁ret ▁-> ▁priv ▁= ▁av _ malloc z ▁( ▁filter ▁-> ▁priv _ size ▁) ▁; ▁ret ▁-> ▁input _ count ▁= ▁pad _ count ▁( ▁filter ▁-> ▁inputs ▁) ▁; ▁if ▁( ▁ret ▁-> ▁input _ count ▁) ▁{ ▁ret ▁-> ▁input _ pads ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁input _ count ▁) ▁; ▁memcpy ▁( ▁ret ▁-> ▁input _ pads ▁, ▁filter ▁-> ▁inputs ▁, ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁input _ count ▁) ▁; ▁ret ▁-> ▁inputs ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Link ▁* ▁) ▁* ▁ret ▁-> ▁input _ count ▁) ▁; ▁} ▁ret ▁-> ▁output _ count ▁= ▁pad _ count ▁( ▁filter ▁-> ▁outputs ▁) ▁; ▁if ▁( ▁ret ▁-> ▁output _ count ▁) ▁{ ▁ret ▁-> ▁output _ pads ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁output _ count ▁) ▁; ▁memcpy ▁( ▁ret ▁-> ▁output _ pads ▁, ▁filter ▁-> ▁outputs ▁, ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁output _ count ▁) ▁; ▁ret ▁-> ▁outputs ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Link ▁* ▁) ▁* ▁ret ▁-> ▁output _ count ▁) ▁; ▁} ▁* ▁filter _ ctx ▁= ▁ret ▁; ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁dh _ init ▁( ▁void ▁* ▁v pd h ctx ▁, ▁void ▁* ▁v dh ▁) ▁{ ▁PRO V _ DH _ CTX ▁* ▁pd h ctx ▁= ▁( ▁PRO V _ DH _ CTX ▁* ▁) ▁v pd h ctx ▁; ▁DH _ free ▁( ▁pd h ctx ▁-> ▁dh ▁) ▁; ▁pd h ctx ▁-> ▁dh ▁= ▁v dh ▁; ▁DH _ up _ ref ▁( ▁pd h ctx ▁-> ▁dh ▁) ▁; ▁return ▁pd h ctx ▁-> ▁dh ▁!= ▁NULL ▁; ▁}	0
▁void ▁ff _ er _ add _ slice ▁( ▁ER Context ▁* ▁s ▁, ▁int ▁start x ▁, ▁int ▁start y ▁, ▁int ▁end x ▁, ▁int ▁end y ▁, ▁int ▁status ▁) ▁{ ▁const ▁int ▁start _ i ▁= ▁av _ clip ▁( ▁start x ▁+ ▁start y ▁* ▁s ▁-> ▁mb _ width ▁, ▁0 ▁, ▁s ▁-> ▁mb _ num ▁- ▁1 ▁) ▁; ▁const ▁int ▁end _ i ▁= ▁av _ clip ▁( ▁end x ▁+ ▁end y ▁* ▁s ▁-> ▁mb _ width ▁, ▁0 ▁, ▁s ▁-> ▁mb _ num ▁) ▁; ▁const ▁int ▁start _ xy ▁= ▁s ▁-> ▁mb _ index 2 xy ▁[ ▁start _ i ▁] ▁; ▁const ▁int ▁end _ xy ▁= ▁s ▁-> ▁mb _ index 2 xy ▁[ ▁end _ i ▁] ▁; ▁int ▁mask ▁= ▁-1 ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁hw accel ▁&& ▁s ▁-> ▁avctx ▁-> ▁hw accel ▁-> ▁decode _ slice ▁) ▁return ▁; ▁if ▁( ▁start _ i ▁> ▁end _ i ▁|| ▁start _ xy ▁> ▁end _ xy ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" internal error , slice end before start \ n " ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁s ▁-> ▁avctx ▁-> ▁error _ con ce al ment ▁) ▁return ▁; ▁mask ▁&= ▁ ~ ▁VP _ START ▁; ▁if ▁( ▁status ▁& ▁( ▁ER _ AC _ ERROR ▁| ▁ER _ AC _ END ▁) ▁) ▁{ ▁mask ▁&= ▁ ~ ▁( ▁ER _ AC _ ERROR ▁| ▁ER _ AC _ END ▁) ▁; ▁avpriv _ atomic _ int _ add _ and _ fetch ▁( ▁& ▁s ▁-> ▁error _ count ▁, ▁start _ i ▁- ▁end _ i ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁status ▁& ▁( ▁ER _ DC _ ERROR ▁| ▁ER _ DC _ END ▁) ▁) ▁{ ▁mask ▁&= ▁ ~ ▁( ▁ER _ DC _ ERROR ▁| ▁ER _ DC _ END ▁) ▁; ▁avpriv _ atomic _ int _ add _ and _ fetch ▁( ▁& ▁s ▁-> ▁error _ count ▁, ▁start _ i ▁- ▁end _ i ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁status ▁& ▁( ▁ER _ MV _ ERROR ▁| ▁ER _ MV _ END ▁) ▁) ▁{ ▁mask ▁&= ▁ ~ ▁( ▁ER _ MV _ ERROR ▁| ▁ER _ MV _ END ▁) ▁; ▁avpriv _ atomic _ int _ add _ and _ fetch ▁( ▁& ▁s ▁-> ▁error _ count ▁, ▁start _ i ▁- ▁end _ i ▁- ▁1 ▁) ▁; ▁} ▁if ▁( ▁status ▁& ▁ER _ MB _ ERROR ▁) ▁{ ▁s ▁-> ▁error _ occ urred ▁= ▁1 ▁; ▁avpriv _ atomic _ int _ set ▁( ▁& ▁s ▁-> ▁error _ count ▁, ▁INT _ MAX ▁) ▁; ▁} ▁if ▁( ▁mask ▁== ▁ ~ ▁0 x 7 F ▁) ▁{ ▁memset ▁( ▁& ▁s ▁-> ▁error _ status _ table ▁[ ▁start _ xy ▁] ▁, ▁0 ▁, ▁( ▁end _ xy ▁- ▁start _ xy ▁) ▁* ▁sizeof ▁( ▁uint 8_ t ▁) ▁) ▁; ▁} ▁else ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁start _ xy ▁; ▁i ▁< ▁end _ xy ▁; ▁i ▁++ ▁) ▁s ▁-> ▁error _ status _ table ▁[ ▁i ▁] ▁&= ▁mask ▁; ▁} ▁if ▁( ▁end _ i ▁== ▁s ▁-> ▁mb _ num ▁) ▁avpriv _ atomic _ int _ set ▁( ▁& ▁s ▁-> ▁error _ count ▁, ▁INT _ MAX ▁) ▁; ▁else ▁{ ▁s ▁-> ▁error _ status _ table ▁[ ▁end _ xy ▁] ▁&= ▁mask ▁; ▁s ▁-> ▁error _ status _ table ▁[ ▁end _ xy ▁] ▁|= ▁status ▁; ▁} ▁s ▁-> ▁error _ status _ table ▁[ ▁start _ xy ▁] ▁|= ▁VP _ START ▁; ▁if ▁( ▁start _ xy ▁> ▁0 ▁&& ▁! ▁( ▁s ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁&& ▁er _ supported ▁( ▁s ▁) ▁&& ▁s ▁-> ▁avctx ▁-> ▁skip _ top ▁* ▁s ▁-> ▁mb _ width ▁< ▁start _ i ▁) ▁{ ▁int ▁prev _ status ▁= ▁s ▁-> ▁error _ status _ table ▁[ ▁s ▁-> ▁mb _ index 2 xy ▁[ ▁start _ i ▁- ▁1 ▁] ▁] ▁; ▁prev _ status ▁&= ▁ ~ ▁VP _ START ▁; ▁if ▁( ▁prev _ status ▁!= ▁( ▁ER _ MV _ END ▁| ▁ER _ DC _ END ▁| ▁ER _ AC _ END ▁) ▁) ▁{ ▁s ▁-> ▁error _ occ urred ▁= ▁1 ▁; ▁avpriv _ atomic _ int _ set ▁( ▁& ▁s ▁-> ▁error _ count ▁, ▁INT _ MAX ▁) ▁; ▁} ▁} ▁}	0
▁int ▁ff _ index _ search _ timestamp ▁( ▁const ▁AV Index Entry ▁* ▁entries ▁, ▁int ▁nb _ entries ▁, ▁int 64_ t ▁wanted _ timestamp ▁, ▁int ▁flags ▁) ▁{ ▁int ▁a ▁, ▁b ▁, ▁m ▁; ▁int 64_ t ▁timestamp ▁; ▁a ▁= ▁-1 ▁; ▁b ▁= ▁nb _ entries ▁; ▁if ▁( ▁b ▁&& ▁entries ▁[ ▁b ▁- ▁1 ▁] ▁. ▁timestamp ▁< ▁wanted _ timestamp ▁) ▁a ▁= ▁b ▁- ▁1 ▁; ▁while ▁( ▁b ▁- ▁a ▁> ▁1 ▁) ▁{ ▁m ▁= ▁( ▁a ▁+ ▁b ▁) ▁>> ▁1 ▁; ▁while ▁( ▁( ▁entries ▁[ ▁m ▁] ▁. ▁flags ▁& ▁AV INDEX _ DISCARD _ FRAME ▁) ▁&& ▁m ▁< ▁b ▁) ▁{ ▁m ▁++ ▁; ▁if ▁( ▁m ▁== ▁b ▁&& ▁entries ▁[ ▁m ▁] ▁. ▁timestamp ▁>= ▁wanted _ timestamp ▁) ▁{ ▁m ▁= ▁b ▁- ▁1 ▁; ▁break ▁; ▁} ▁} ▁timestamp ▁= ▁entries ▁[ ▁m ▁] ▁. ▁timestamp ▁; ▁if ▁( ▁timestamp ▁>= ▁wanted _ timestamp ▁) ▁b ▁= ▁m ▁; ▁if ▁( ▁timestamp ▁<= ▁wanted _ timestamp ▁) ▁a ▁= ▁m ▁; ▁} ▁m ▁= ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁) ▁? ▁a ▁: ▁b ▁; ▁if ▁( ▁! ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ ANY ▁) ▁) ▁while ▁( ▁m ▁>= ▁0 ▁&& ▁m ▁< ▁nb _ entries ▁&& ▁! ▁( ▁entries ▁[ ▁m ▁] ▁. ▁flags ▁& ▁AV INDEX _ KEY FRAME ▁) ▁) ▁m ▁+= ▁( ▁flags ▁& ▁AV SEEK _ FLAG _ BACK WARD ▁) ▁? ▁-1 ▁: ▁1 ▁; ▁if ▁( ▁m ▁== ▁nb _ entries ▁) ▁return ▁-1 ▁; ▁return ▁m ▁; ▁}	1
▁void ▁ff _ init _ range _ decoder ▁( ▁Range Coder ▁* ▁c ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁ff _ init _ range _ encoder ▁( ▁c ▁, ▁( ▁uint 8_ t ▁* ▁) ▁buf ▁, ▁buf _ size ▁) ▁; ▁c ▁-> ▁low ▁= ▁AV _ RB 16 ▁( ▁c ▁-> ▁bytestream ▁) ▁; ▁c ▁-> ▁bytestream ▁+= ▁2 ▁; ▁if ▁( ▁c ▁-> ▁low ▁>= ▁0 xFF 00 ▁) ▁{ ▁c ▁-> ▁low ▁= ▁0 xFF 00 ▁; ▁c ▁-> ▁bytestream _ end ▁= ▁c ▁-> ▁bytestream ▁+ ▁2 ▁; ▁} ▁}	0
▁void ▁ngx _ slab _ init ▁( ▁ngx _ slab _ pool _ t ▁* ▁pool ▁) ▁{ ▁u _ char ▁* ▁p ▁; ▁size _ t ▁size ▁; ▁ngx _ int _ t ▁m ▁; ▁ngx _ uint _ t ▁i ▁, ▁n ▁, ▁pages ▁; ▁ngx _ slab _ page _ t ▁* ▁slots ▁, ▁* ▁page ▁; ▁if ▁( ▁ngx _ slab _ max _ size ▁== ▁0 ▁) ▁{ ▁ngx _ slab _ max _ size ▁= ▁ngx _ pagesize ▁/ ▁2 ▁; ▁ngx _ slab _ exact _ size ▁= ▁ngx _ pagesize ▁/ ▁( ▁8 ▁* ▁sizeof ▁( ▁uintptr _ t ▁) ▁) ▁; ▁for ▁( ▁n ▁= ▁ngx _ slab _ exact _ size ▁; ▁n ▁>>= ▁1 ▁; ▁ngx _ slab _ exact _ shift ▁++ ▁) ▁{ ▁} ▁} ▁pool ▁-> ▁min _ size ▁= ▁1 ▁<< ▁pool ▁-> ▁min _ shift ▁; ▁slots ▁= ▁ngx _ slab _ slots ▁( ▁pool ▁) ▁; ▁p ▁= ▁( ▁u _ char ▁* ▁) ▁slots ▁; ▁size ▁= ▁pool ▁-> ▁end ▁- ▁p ▁; ▁ngx _ slab _ junk ▁( ▁p ▁, ▁size ▁) ▁; ▁n ▁= ▁ngx _ pagesize _ shift ▁- ▁pool ▁-> ▁min _ shift ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁slots ▁[ ▁i ▁] ▁. ▁slab ▁= ▁0 ▁; ▁slots ▁[ ▁i ▁] ▁. ▁next ▁= ▁& ▁slots ▁[ ▁i ▁] ▁; ▁slots ▁[ ▁i ▁] ▁. ▁prev ▁= ▁0 ▁; ▁} ▁p ▁+= ▁n ▁* ▁sizeof ▁( ▁ngx _ slab _ page _ t ▁) ▁; ▁size ▁-= ▁n ▁* ▁sizeof ▁( ▁ngx _ slab _ page _ t ▁) ▁; ▁pages ▁= ▁( ▁ngx _ uint _ t ▁) ▁( ▁size ▁/ ▁( ▁ngx _ pagesize ▁+ ▁sizeof ▁( ▁ngx _ slab _ page _ t ▁) ▁) ▁) ▁; ▁pool ▁-> ▁pages ▁= ▁( ▁ngx _ slab _ page _ t ▁* ▁) ▁p ▁; ▁ngx _ mem zero ▁( ▁pool ▁-> ▁pages ▁, ▁pages ▁* ▁sizeof ▁( ▁ngx _ slab _ page _ t ▁) ▁) ▁; ▁page ▁= ▁pool ▁-> ▁pages ▁; ▁pool ▁-> ▁free ▁. ▁slab ▁= ▁0 ▁; ▁pool ▁-> ▁free ▁. ▁next ▁= ▁page ▁; ▁pool ▁-> ▁free ▁. ▁prev ▁= ▁0 ▁; ▁page ▁-> ▁slab ▁= ▁pages ▁; ▁page ▁-> ▁next ▁= ▁& ▁pool ▁-> ▁free ▁; ▁page ▁-> ▁prev ▁= ▁( ▁uintptr _ t ▁) ▁& ▁pool ▁-> ▁free ▁; ▁pool ▁-> ▁start ▁= ▁ngx _ align _ ptr ▁( ▁p ▁+ ▁pages ▁* ▁sizeof ▁( ▁ngx _ slab _ page _ t ▁) ▁, ▁ngx _ pagesize ▁) ▁; ▁m ▁= ▁pages ▁- ▁( ▁pool ▁-> ▁end ▁- ▁pool ▁-> ▁start ▁) ▁/ ▁ngx _ pagesize ▁; ▁if ▁( ▁m ▁> ▁0 ▁) ▁{ ▁pages ▁-= ▁m ▁; ▁page ▁-> ▁slab ▁= ▁pages ▁; ▁} ▁pool ▁-> ▁last ▁= ▁pool ▁-> ▁pages ▁+ ▁pages ▁; ▁pool ▁-> ▁log _ nomem ▁= ▁1 ▁; ▁pool ▁-> ▁log _ ctx ▁= ▁& ▁pool ▁-> ▁zero ▁; ▁pool ▁-> ▁zero ▁= ▁' ▁\0 ▁' ▁; ▁}	1
▁int ▁BN _ sqr ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁max ▁, ▁al ▁; ▁int ▁ret ▁= ▁0 ▁; ▁BIGNUM ▁* ▁tmp ▁, ▁* ▁rr ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁al ▁= ▁a ▁-> ▁top ▁; ▁if ▁( ▁al ▁<= ▁0 ▁) ▁{ ▁r ▁-> ▁top ▁= ▁0 ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁rr ▁= ▁( ▁a ▁!= ▁r ▁) ▁? ▁r ▁: ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁tmp ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁rr ▁== ▁NULL ▁|| ▁tmp ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁max ▁= ▁2 ▁* ▁al ▁; ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁al ▁== ▁4 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁BN _ ULONG ▁t ▁[ ▁8 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁4 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 4 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁else ▁if ▁( ▁al ▁== ▁8 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁BN _ ULONG ▁t ▁[ ▁16 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁8 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 8 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁else ▁{ ▁# if ▁defined ▁( ▁BN _ RECUR SION ▁) ▁if ▁( ▁al ▁< ▁BN _ SQR _ RECURSIVE _ SIZE _ NORMAL ▁) ▁{ ▁BN _ ULONG ▁t ▁[ ▁BN _ SQR _ RECURSIVE _ SIZE _ NORMAL ▁* ▁2 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁t ▁) ▁; ▁} ▁else ▁{ ▁int ▁j ▁, ▁k ▁; ▁j ▁= ▁BN _ num _ bits _ word ▁( ▁( ▁BN _ ULONG ▁) ▁al ▁) ▁; ▁j ▁= ▁1 ▁<< ▁( ▁j ▁- ▁1 ▁) ▁; ▁k ▁= ▁j ▁+ ▁j ▁; ▁if ▁( ▁al ▁== ▁j ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁k ▁* ▁2 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ recursive ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁} ▁} ▁# else ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁rr ▁-> ▁neg ▁= ▁0 ▁; ▁rr ▁-> ▁top ▁= ▁max ▁; ▁bn _ correct _ top ▁( ▁rr ▁) ▁; ▁if ▁( ▁r ▁!= ▁rr ▁&& ▁BN _ copy ▁( ▁r ▁, ▁rr ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁bn _ check _ top ▁( ▁rr ▁) ▁; ▁bn _ check _ top ▁( ▁tmp ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁void ▁fill _ coding _ method _ array ▁( ▁sb _ int 8_ array ▁tone _ level _ idx ▁, ▁sb _ int 8_ array ▁tone _ level _ idx _ temp ▁, ▁sb _ int 8_ array ▁coding _ method ▁, ▁int ▁nb _ channels ▁, ▁int ▁c ▁, ▁int ▁super block type _2_ 3 ▁, ▁int ▁cm _ table _ select ▁) ▁{ ▁int ▁ch ▁, ▁sb ▁, ▁j ▁; ▁int ▁tmp ▁, ▁acc ▁, ▁esp _40 ▁, ▁comp ▁; ▁int ▁add 1 ▁, ▁add 2 ▁, ▁add 3 ▁, ▁add 4 ▁; ▁int 64_ t ▁mult res ▁; ▁if ▁( ▁nb _ channels ▁<= ▁0 ▁) ▁return ▁; ▁if ▁( ▁! ▁super block type _2_ 3 ▁) ▁{ ▁SAM PLES _ NEEDED ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁nb _ channels ▁; ▁ch ▁++ ▁) ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁30 ▁; ▁sb ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁1 ▁; ▁j ▁< ▁64 ▁; ▁j ▁++ ▁) ▁{ ▁add 1 ▁= ▁tone _ level _ idx ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁- ▁10 ▁; ▁if ▁( ▁add 1 ▁< ▁0 ▁) ▁add 1 ▁= ▁0 ▁; ▁add 2 ▁= ▁add 3 ▁= ▁add 4 ▁= ▁0 ▁; ▁if ▁( ▁sb ▁> ▁1 ▁) ▁{ ▁add 2 ▁= ▁tone _ level _ idx ▁[ ▁ch ▁] ▁[ ▁sb ▁- ▁2 ▁] ▁[ ▁j ▁] ▁+ ▁tone _ level _ idx _ offset _ table ▁[ ▁sb ▁] ▁[ ▁0 ▁] ▁- ▁6 ▁; ▁if ▁( ▁add 2 ▁< ▁0 ▁) ▁add 2 ▁= ▁0 ▁; ▁} ▁if ▁( ▁sb ▁> ▁0 ▁) ▁{ ▁add 3 ▁= ▁tone _ level _ idx ▁[ ▁ch ▁] ▁[ ▁sb ▁- ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁tone _ level _ idx _ offset _ table ▁[ ▁sb ▁] ▁[ ▁1 ▁] ▁- ▁6 ▁; ▁if ▁( ▁add 3 ▁< ▁0 ▁) ▁add 3 ▁= ▁0 ▁; ▁} ▁if ▁( ▁sb ▁< ▁29 ▁) ▁{ ▁add 4 ▁= ▁tone _ level _ idx ▁[ ▁ch ▁] ▁[ ▁sb ▁+ ▁1 ▁] ▁[ ▁j ▁] ▁+ ▁tone _ level _ idx _ offset _ table ▁[ ▁sb ▁] ▁[ ▁3 ▁] ▁- ▁6 ▁; ▁if ▁( ▁add 4 ▁< ▁0 ▁) ▁add 4 ▁= ▁0 ▁; ▁} ▁tmp ▁= ▁tone _ level _ idx ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁* ▁2 ▁- ▁add 4 ▁- ▁add 3 ▁- ▁add 2 ▁- ▁add 1 ▁; ▁if ▁( ▁tmp ▁< ▁0 ▁) ▁tmp ▁= ▁0 ▁; ▁tone _ level _ idx _ temp ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁+ ▁1 ▁] ▁= ▁tmp ▁& ▁0 xff ▁; ▁} ▁tone _ level _ idx _ temp ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁0 ▁] ▁= ▁tone _ level _ idx _ temp ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁1 ▁] ▁; ▁} ▁acc ▁= ▁0 ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁nb _ channels ▁; ▁ch ▁++ ▁) ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁30 ▁; ▁sb ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁64 ▁; ▁j ▁++ ▁) ▁acc ▁+= ▁tone _ level _ idx _ temp ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁; ▁if ▁( ▁acc ▁) ▁tmp ▁= ▁c ▁* ▁256 ▁/ ▁( ▁acc ▁& ▁0 xffff ▁) ▁; ▁mult res ▁= ▁0 x 6666 66 67 ▁* ▁( ▁acc ▁* ▁10 ▁) ▁; ▁esp _40 ▁= ▁( ▁mult res ▁>> ▁32 ▁) ▁/ ▁8 ▁+ ▁( ▁( ▁mult res ▁& ▁0 xffffffff ▁) ▁>> ▁31 ▁) ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁nb _ channels ▁; ▁ch ▁++ ▁) ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁30 ▁; ▁sb ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁64 ▁; ▁j ▁++ ▁) ▁{ ▁comp ▁= ▁tone _ level _ idx _ temp ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁* ▁esp _40 ▁* ▁10 ▁; ▁if ▁( ▁comp ▁< ▁0 ▁) ▁comp ▁+= ▁0 xff ▁; ▁comp ▁/= ▁256 ▁; ▁switch ▁( ▁sb ▁) ▁{ ▁case ▁0 ▁: ▁if ▁( ▁comp ▁< ▁30 ▁) ▁comp ▁= ▁30 ▁; ▁comp ▁+= ▁15 ▁; ▁break ▁; ▁case ▁1 ▁: ▁if ▁( ▁comp ▁< ▁24 ▁) ▁comp ▁= ▁24 ▁; ▁comp ▁+= ▁10 ▁; ▁break ▁; ▁case ▁2 ▁: ▁case ▁3 ▁: ▁case ▁4 ▁: ▁if ▁( ▁comp ▁< ▁16 ▁) ▁comp ▁= ▁16 ▁; ▁} ▁if ▁( ▁comp ▁<= ▁5 ▁) ▁tmp ▁= ▁0 ▁; ▁else ▁if ▁( ▁comp ▁<= ▁10 ▁) ▁tmp ▁= ▁10 ▁; ▁else ▁if ▁( ▁comp ▁<= ▁16 ▁) ▁tmp ▁= ▁16 ▁; ▁else ▁if ▁( ▁comp ▁<= ▁24 ▁) ▁tmp ▁= ▁-1 ▁; ▁else ▁tmp ▁= ▁0 ▁; ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁= ▁( ▁( ▁tmp ▁& ▁0 xff fa ▁) ▁+ ▁30 ▁) ▁& ▁0 xff ▁; ▁} ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁30 ▁; ▁sb ▁++ ▁) ▁fix _ coding _ method _ array ▁( ▁sb ▁, ▁nb _ channels ▁, ▁coding _ method ▁) ▁; ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁nb _ channels ▁; ▁ch ▁++ ▁) ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁30 ▁; ▁sb ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁64 ▁; ▁j ▁++ ▁) ▁if ▁( ▁sb ▁>= ▁10 ▁) ▁{ ▁if ▁( ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁< ▁10 ▁) ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁= ▁10 ▁; ▁} ▁else ▁{ ▁if ▁( ▁sb ▁>= ▁2 ▁) ▁{ ▁if ▁( ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁< ▁16 ▁) ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁= ▁16 ▁; ▁} ▁else ▁{ ▁if ▁( ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁< ▁30 ▁) ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁= ▁30 ▁; ▁} ▁} ▁} ▁else ▁{ ▁for ▁( ▁ch ▁= ▁0 ▁; ▁ch ▁< ▁nb _ channels ▁; ▁ch ▁++ ▁) ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁30 ▁; ▁sb ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁64 ▁; ▁j ▁++ ▁) ▁coding _ method ▁[ ▁ch ▁] ▁[ ▁sb ▁] ▁[ ▁j ▁] ▁= ▁coding _ method _ table ▁[ ▁cm _ table _ select ▁] ▁[ ▁sb ▁] ▁; ▁} ▁return ▁; ▁}	1
▁int ▁av _ lzo 1 x _ decode ▁( ▁void ▁* ▁out ▁, ▁int ▁* ▁outlen ▁, ▁const ▁void ▁* ▁in ▁, ▁int ▁* ▁inlen ▁) ▁{ ▁int ▁state ▁= ▁0 ▁; ▁int ▁x ▁; ▁LZO Context ▁c ▁; ▁if ▁( ▁* ▁outlen ▁<= ▁0 ▁|| ▁* ▁inlen ▁<= ▁0 ▁) ▁{ ▁int ▁res ▁= ▁0 ▁; ▁if ▁( ▁* ▁outlen ▁<= ▁0 ▁) ▁res ▁|= ▁AV _ LZ O _ OUTPUT _ FULL ▁; ▁if ▁( ▁* ▁inlen ▁<= ▁0 ▁) ▁res ▁|= ▁AV _ LZ O _ INPUT _ DEP LETED ▁; ▁return ▁res ▁; ▁} ▁c ▁. ▁in ▁= ▁in ▁; ▁c ▁. ▁in _ end ▁= ▁( ▁const ▁uint 8_ t ▁* ▁) ▁in ▁+ ▁* ▁inlen ▁; ▁c ▁. ▁out ▁= ▁c ▁. ▁out _ start ▁= ▁out ▁; ▁c ▁. ▁out _ end ▁= ▁( ▁uint 8_ t ▁* ▁) ▁out ▁+ ▁* ▁outlen ▁; ▁c ▁. ▁error ▁= ▁0 ▁; ▁x ▁= ▁GET B ▁( ▁c ▁) ▁; ▁if ▁( ▁x ▁> ▁17 ▁) ▁{ ▁copy ▁( ▁& ▁c ▁, ▁x ▁- ▁17 ▁) ▁; ▁x ▁= ▁GET B ▁( ▁c ▁) ▁; ▁if ▁( ▁x ▁< ▁16 ▁) ▁c ▁. ▁error ▁|= ▁AV _ LZ O _ ERROR ▁; ▁} ▁if ▁( ▁c ▁. ▁in ▁> ▁c ▁. ▁in _ end ▁) ▁c ▁. ▁error ▁|= ▁AV _ LZ O _ INPUT _ DEP LETED ▁; ▁while ▁( ▁! ▁c ▁. ▁error ▁) ▁{ ▁int ▁cnt ▁, ▁back ▁; ▁if ▁( ▁x ▁> ▁15 ▁) ▁{ ▁if ▁( ▁x ▁> ▁63 ▁) ▁{ ▁cnt ▁= ▁( ▁x ▁>> ▁5 ▁) ▁- ▁1 ▁; ▁back ▁= ▁( ▁GET B ▁( ▁c ▁) ▁<< ▁3 ▁) ▁+ ▁( ▁( ▁x ▁>> ▁2 ▁) ▁& ▁7 ▁) ▁+ ▁1 ▁; ▁} ▁else ▁if ▁( ▁x ▁> ▁31 ▁) ▁{ ▁cnt ▁= ▁get _ len ▁( ▁& ▁c ▁, ▁x ▁, ▁31 ▁) ▁; ▁x ▁= ▁GET B ▁( ▁c ▁) ▁; ▁back ▁= ▁( ▁GET B ▁( ▁c ▁) ▁<< ▁6 ▁) ▁+ ▁( ▁x ▁>> ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁cnt ▁= ▁get _ len ▁( ▁& ▁c ▁, ▁x ▁, ▁7 ▁) ▁; ▁back ▁= ▁( ▁1 ▁<< ▁14 ▁) ▁+ ▁( ▁( ▁x ▁& ▁8 ▁) ▁<< ▁11 ▁) ▁; ▁x ▁= ▁GET B ▁( ▁c ▁) ▁; ▁back ▁+= ▁( ▁GET B ▁( ▁c ▁) ▁<< ▁6 ▁) ▁+ ▁( ▁x ▁>> ▁2 ▁) ▁; ▁if ▁( ▁back ▁== ▁( ▁1 ▁<< ▁14 ▁) ▁) ▁{ ▁if ▁( ▁cnt ▁!= ▁1 ▁) ▁c ▁. ▁error ▁|= ▁AV _ LZ O _ ERROR ▁; ▁break ▁; ▁} ▁} ▁} ▁else ▁if ▁( ▁! ▁state ▁) ▁{ ▁cnt ▁= ▁get _ len ▁( ▁& ▁c ▁, ▁x ▁, ▁15 ▁) ▁; ▁copy ▁( ▁& ▁c ▁, ▁cnt ▁+ ▁3 ▁) ▁; ▁x ▁= ▁GET B ▁( ▁c ▁) ▁; ▁if ▁( ▁x ▁> ▁15 ▁) ▁continue ▁; ▁cnt ▁= ▁1 ▁; ▁back ▁= ▁( ▁1 ▁<< ▁11 ▁) ▁+ ▁( ▁GET B ▁( ▁c ▁) ▁<< ▁2 ▁) ▁+ ▁( ▁x ▁>> ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁cnt ▁= ▁0 ▁; ▁back ▁= ▁( ▁GET B ▁( ▁c ▁) ▁<< ▁2 ▁) ▁+ ▁( ▁x ▁>> ▁2 ▁) ▁+ ▁1 ▁; ▁} ▁copy _ back ptr ▁( ▁& ▁c ▁, ▁back ▁, ▁cnt ▁+ ▁2 ▁) ▁; ▁state ▁= ▁cnt ▁= ▁x ▁& ▁3 ▁; ▁copy ▁( ▁& ▁c ▁, ▁cnt ▁) ▁; ▁x ▁= ▁GET B ▁( ▁c ▁) ▁; ▁} ▁* ▁inlen ▁= ▁c ▁. ▁in _ end ▁- ▁c ▁. ▁in ▁; ▁if ▁( ▁c ▁. ▁in ▁> ▁c ▁. ▁in _ end ▁) ▁* ▁inlen ▁= ▁0 ▁; ▁* ▁outlen ▁= ▁c ▁. ▁out _ end ▁- ▁c ▁. ▁out ▁; ▁return ▁c ▁. ▁error ▁; ▁}	1
▁static ▁ngx _ int _ t ▁ngx _ http _ alloc _ large _ header _ buffer ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ uint _ t ▁request _ line ▁) ▁{ ▁u _ char ▁* ▁old ▁, ▁* ▁new ▁; ▁ngx _ buf _ t ▁* ▁b ▁; ▁ngx _ chain _ t ▁* ▁cl ▁; ▁ngx _ http _ connection _ t ▁* ▁hc ▁; ▁ngx _ http _ core _ srv _ conf _ t ▁* ▁csc f ▁; ▁ngx _ log _ debug 0 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" http allo cl arge header buffer " ▁) ▁; ▁if ▁( ▁request _ line ▁&& ▁r ▁-> ▁state ▁== ▁0 ▁) ▁{ ▁r ▁-> ▁header _ in ▁-> ▁pos ▁= ▁r ▁-> ▁header _ in ▁-> ▁start ▁; ▁r ▁-> ▁header _ in ▁-> ▁last ▁= ▁r ▁-> ▁header _ in ▁-> ▁start ▁; ▁return ▁NGX _ OK ▁; ▁} ▁old ▁= ▁request _ line ▁? ▁r ▁-> ▁request _ start ▁: ▁r ▁-> ▁header _ name _ start ▁; ▁csc f ▁= ▁ngx _ http _ get _ module _ srv _ conf ▁( ▁r ▁, ▁ngx _ http _ core _ module ▁) ▁; ▁if ▁( ▁r ▁-> ▁state ▁!= ▁0 ▁&& ▁( ▁size _ t ▁) ▁( ▁r ▁-> ▁header _ in ▁-> ▁pos ▁- ▁old ▁) ▁>= ▁csc f ▁-> ▁large _ client _ header _ buffers ▁. ▁size ▁) ▁{ ▁return ▁NGX _ DECL INED ▁; ▁} ▁hc ▁= ▁r ▁-> ▁http _ connection ▁; ▁if ▁( ▁hc ▁-> ▁free ▁) ▁{ ▁cl ▁= ▁hc ▁-> ▁free ▁; ▁hc ▁-> ▁free ▁= ▁cl ▁-> ▁next ▁; ▁b ▁= ▁cl ▁-> ▁buf ▁; ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" http large header free :% p % uz " ▁, ▁b ▁-> ▁pos ▁, ▁b ▁-> ▁end ▁- ▁b ▁-> ▁last ▁) ▁; ▁} ▁else ▁if ▁( ▁hc ▁-> ▁n busy ▁< ▁csc f ▁-> ▁large _ client _ header _ buffers ▁. ▁num ▁) ▁{ ▁b ▁= ▁ngx _ create _ temp _ buf ▁( ▁r ▁-> ▁connection ▁-> ▁pool ▁, ▁csc f ▁-> ▁large _ client _ header _ buffers ▁. ▁size ▁) ▁; ▁if ▁( ▁b ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁cl ▁= ▁ngx _ alloc _ chain _ link ▁( ▁r ▁-> ▁connection ▁-> ▁pool ▁) ▁; ▁if ▁( ▁cl ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁cl ▁-> ▁buf ▁= ▁b ▁; ▁ngx _ log _ debug 2 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" http large header alloc :% p % uz " ▁, ▁b ▁-> ▁pos ▁, ▁b ▁-> ▁end ▁- ▁b ▁-> ▁last ▁) ▁; ▁} ▁else ▁{ ▁return ▁NGX _ DECL INED ▁; ▁} ▁cl ▁-> ▁next ▁= ▁hc ▁-> ▁busy ▁; ▁hc ▁-> ▁busy ▁= ▁cl ▁; ▁hc ▁-> ▁n busy ▁++ ▁; ▁if ▁( ▁r ▁-> ▁state ▁== ▁0 ▁) ▁{ ▁r ▁-> ▁header _ in ▁= ▁b ▁; ▁return ▁NGX _ OK ▁; ▁} ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" http large header copy :% uz " ▁, ▁r ▁-> ▁header _ in ▁-> ▁pos ▁- ▁old ▁) ▁; ▁new ▁= ▁b ▁-> ▁start ▁; ▁ngx _ memcpy ▁( ▁new ▁, ▁old ▁, ▁r ▁-> ▁header _ in ▁-> ▁pos ▁- ▁old ▁) ▁; ▁b ▁-> ▁pos ▁= ▁new ▁+ ▁( ▁r ▁-> ▁header _ in ▁-> ▁pos ▁- ▁old ▁) ▁; ▁b ▁-> ▁last ▁= ▁new ▁+ ▁( ▁r ▁-> ▁header _ in ▁-> ▁pos ▁- ▁old ▁) ▁; ▁if ▁( ▁request _ line ▁) ▁{ ▁r ▁-> ▁request _ start ▁= ▁new ▁; ▁if ▁( ▁r ▁-> ▁request _ end ▁) ▁{ ▁r ▁-> ▁request _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁request _ end ▁- ▁old ▁) ▁; ▁} ▁r ▁-> ▁method _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁method _ end ▁- ▁old ▁) ▁; ▁r ▁-> ▁uri _ start ▁= ▁new ▁+ ▁( ▁r ▁-> ▁uri _ start ▁- ▁old ▁) ▁; ▁r ▁-> ▁uri _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁uri _ end ▁- ▁old ▁) ▁; ▁if ▁( ▁r ▁-> ▁schema _ start ▁) ▁{ ▁r ▁-> ▁schema _ start ▁= ▁new ▁+ ▁( ▁r ▁-> ▁schema _ start ▁- ▁old ▁) ▁; ▁r ▁-> ▁schema _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁schema _ end ▁- ▁old ▁) ▁; ▁} ▁if ▁( ▁r ▁-> ▁host _ start ▁) ▁{ ▁r ▁-> ▁host _ start ▁= ▁new ▁+ ▁( ▁r ▁-> ▁host _ start ▁- ▁old ▁) ▁; ▁if ▁( ▁r ▁-> ▁host _ end ▁) ▁{ ▁r ▁-> ▁host _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁host _ end ▁- ▁old ▁) ▁; ▁} ▁} ▁if ▁( ▁r ▁-> ▁port _ start ▁) ▁{ ▁r ▁-> ▁port _ start ▁= ▁new ▁+ ▁( ▁r ▁-> ▁port _ start ▁- ▁old ▁) ▁; ▁r ▁-> ▁port _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁port _ end ▁- ▁old ▁) ▁; ▁} ▁if ▁( ▁r ▁-> ▁uri _ ext ▁) ▁{ ▁r ▁-> ▁uri _ ext ▁= ▁new ▁+ ▁( ▁r ▁-> ▁uri _ ext ▁- ▁old ▁) ▁; ▁} ▁if ▁( ▁r ▁-> ▁args _ start ▁) ▁{ ▁r ▁-> ▁args _ start ▁= ▁new ▁+ ▁( ▁r ▁-> ▁args _ start ▁- ▁old ▁) ▁; ▁} ▁if ▁( ▁r ▁-> ▁http _ protocol ▁. ▁data ▁) ▁{ ▁r ▁-> ▁http _ protocol ▁. ▁data ▁= ▁new ▁+ ▁( ▁r ▁-> ▁http _ protocol ▁. ▁data ▁- ▁old ▁) ▁; ▁} ▁} ▁else ▁{ ▁r ▁-> ▁header _ name _ start ▁= ▁new ▁; ▁r ▁-> ▁header _ name _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁header _ name _ end ▁- ▁old ▁) ▁; ▁r ▁-> ▁header _ start ▁= ▁new ▁+ ▁( ▁r ▁-> ▁header _ start ▁- ▁old ▁) ▁; ▁r ▁-> ▁header _ end ▁= ▁new ▁+ ▁( ▁r ▁-> ▁header _ end ▁- ▁old ▁) ▁; ▁} ▁r ▁-> ▁header _ in ▁= ▁b ▁; ▁return ▁NGX _ OK ▁; ▁}	0
▁static ▁void ▁l fe _ down sample ▁( ▁D CA Enc Context ▁* ▁c ▁, ▁const ▁int 32_ t ▁* ▁input ▁) ▁{ ▁const ▁int ▁l fe ch ▁= ▁l fe _ index ▁[ ▁c ▁-> ▁channel _ config ▁] ▁; ▁int ▁i ▁, ▁j ▁, ▁lf es ▁; ▁int 32_ t ▁hist ▁[ ▁512 ▁] ▁; ▁int 32_ t ▁accum ▁; ▁int ▁hist _ start ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁512 ▁; ▁i ▁++ ▁) ▁hist ▁[ ▁i ▁] ▁= ▁c ▁-> ▁history ▁[ ▁i ▁] ▁[ ▁c ▁-> ▁channels ▁- ▁1 ▁] ▁; ▁for ▁( ▁lf es ▁= ▁0 ▁; ▁lf es ▁< ▁D CA _ L FE _ SAMPLES ▁; ▁lf es ▁++ ▁) ▁{ ▁accum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁hist _ start ▁, ▁j ▁= ▁0 ▁; ▁i ▁< ▁512 ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁accum ▁+= ▁mul 32 ▁( ▁hist ▁[ ▁i ▁] ▁, ▁l fe _ fir _64 i ▁[ ▁j ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁hist _ start ▁; ▁i ▁++ ▁, ▁j ▁++ ▁) ▁accum ▁+= ▁mul 32 ▁( ▁hist ▁[ ▁i ▁] ▁, ▁l fe _ fir _64 i ▁[ ▁j ▁] ▁) ▁; ▁c ▁-> ▁down sample d _ lf e ▁[ ▁lf es ▁] ▁= ▁accum ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁; ▁i ▁++ ▁) ▁hist ▁[ ▁i ▁+ ▁hist _ start ▁] ▁= ▁input ▁[ ▁( ▁lf es ▁* ▁64 ▁+ ▁i ▁) ▁* ▁c ▁-> ▁channels ▁+ ▁l fe ch ▁] ▁; ▁hist _ start ▁= ▁( ▁hist _ start ▁+ ▁64 ▁) ▁& ▁511 ▁; ▁} ▁}	1
▁static ▁int ▁dr bg _ bytes ▁( ▁unsigned ▁char ▁* ▁out ▁, ▁int ▁count ▁) ▁{ ▁DR BG _ CTX ▁* ▁dctx ▁= ▁RAND _ DR BG _ get _ default ▁( ▁) ▁; ▁int ▁ret ▁= ▁0 ▁; ▁CRYPTO _ THREAD _ write _ lock ▁( ▁dctx ▁-> ▁lock ▁) ▁; ▁do ▁{ ▁size _ t ▁rc nt ▁; ▁if ▁( ▁count ▁> ▁( ▁int ▁) ▁dctx ▁-> ▁max _ request ▁) ▁rc nt ▁= ▁dctx ▁-> ▁max _ request ▁; ▁else ▁rc nt ▁= ▁count ▁; ▁ret ▁= ▁RAND _ DR BG _ generate ▁( ▁dctx ▁, ▁out ▁, ▁rc nt ▁, ▁0 ▁, ▁NULL ▁, ▁0 ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁goto ▁err ▁; ▁out ▁+= ▁rc nt ▁; ▁count ▁-= ▁rc nt ▁; ▁} ▁while ▁( ▁count ▁) ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁CRYPTO _ THREAD _ unlock ▁( ▁dctx ▁-> ▁lock ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁static ▁int ▁get _ q cx ▁( ▁J 2 k Decoder Context ▁* ▁s ▁, ▁int ▁n ▁, ▁J 2 k Quant Style ▁* ▁q ▁) ▁{ ▁int ▁i ▁, ▁x ▁; ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁1 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁x ▁= ▁bytestream _ get _ byte ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁q ▁-> ▁n guard bits ▁= ▁x ▁>> ▁5 ▁; ▁q ▁-> ▁quant st y ▁= ▁x ▁& ▁0 x 1 f ▁; ▁if ▁( ▁q ▁-> ▁quant st y ▁== ▁J 2 K _ Q STY _ NONE ▁) ▁{ ▁n ▁-= ▁3 ▁; ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁n ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁q ▁-> ▁exp n ▁[ ▁i ▁] ▁= ▁bytestream _ get _ byte ▁( ▁& ▁s ▁-> ▁buf ▁) ▁>> ▁3 ▁; ▁} ▁else ▁if ▁( ▁q ▁-> ▁quant st y ▁== ▁J 2 K _ Q STY _ SI ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁2 ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁x ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁q ▁-> ▁exp n ▁[ ▁0 ▁] ▁= ▁x ▁>> ▁11 ▁; ▁q ▁-> ▁mant ▁[ ▁0 ▁] ▁= ▁x ▁& ▁0 x 7 ff ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁32 ▁* ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁c ure x pn ▁= ▁FF MAX ▁( ▁0 ▁, ▁q ▁-> ▁exp n ▁[ ▁0 ▁] ▁- ▁( ▁i ▁- ▁1 ▁) ▁/ ▁3 ▁) ▁; ▁q ▁-> ▁exp n ▁[ ▁i ▁] ▁= ▁c ure x pn ▁; ▁q ▁-> ▁mant ▁[ ▁i ▁] ▁= ▁q ▁-> ▁mant ▁[ ▁0 ▁] ▁; ▁} ▁} ▁else ▁{ ▁n ▁= ▁( ▁n ▁- ▁3 ▁) ▁>> ▁1 ▁; ▁if ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf ▁< ▁n ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁x ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁s ▁-> ▁buf ▁) ▁; ▁q ▁-> ▁exp n ▁[ ▁i ▁] ▁= ▁x ▁>> ▁11 ▁; ▁q ▁-> ▁mant ▁[ ▁i ▁] ▁= ▁x ▁& ▁0 x 7 ff ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁SR P _ V BASE _ init ▁( ▁SR P _ V BASE ▁* ▁vb ▁, ▁char ▁* ▁verifier _ file ▁) ▁{ ▁int ▁error _ code ▁; ▁STACK _ OF ▁( ▁SR P _ g N ▁) ▁* ▁SR P _ g N _ tab ▁= ▁sk _ SR P _ g N _ new _ null ▁( ▁) ▁; ▁char ▁* ▁last _ index ▁= ▁NULL ▁; ▁int ▁i ▁; ▁char ▁* ▁* ▁pp ▁; ▁SR P _ g N ▁* ▁g N ▁= ▁NULL ▁; ▁SR P _ user _ pwd ▁* ▁user _ pwd ▁= ▁NULL ▁; ▁TXT _ DB ▁* ▁tmp db ▁= ▁NULL ▁; ▁BIO ▁* ▁in ▁= ▁BIO _ new ▁( ▁BIO _ s _ file ▁( ▁) ▁) ▁; ▁error _ code ▁= ▁SR P _ ERR _ OPEN _ FILE ▁; ▁if ▁( ▁in ▁== ▁NULL ▁|| ▁BIO _ read _ filename ▁( ▁in ▁, ▁verifier _ file ▁) ▁<= ▁0 ▁) ▁goto ▁err ▁; ▁error _ code ▁= ▁SR P _ ERR _ V BASE _ IN COMPLETE _ FILE ▁; ▁if ▁( ▁( ▁tmp db ▁= ▁TXT _ DB _ read ▁( ▁in ▁, ▁DB _ NUMBER ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁error _ code ▁= ▁SR P _ ERR _ MEMORY ▁; ▁if ▁( ▁vb ▁-> ▁seed _ key ▁) ▁{ ▁last _ index ▁= ▁SR P _ get _ default _ g N ▁( ▁NULL ▁) ▁-> ▁id ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ OPENSSL _ P STRING _ num ▁( ▁tmp db ▁-> ▁data ▁) ▁; ▁i ▁++ ▁) ▁{ ▁pp ▁= ▁sk _ OPENSSL _ P STRING _ value ▁( ▁tmp db ▁-> ▁data ▁, ▁i ▁) ▁; ▁if ▁( ▁pp ▁[ ▁DB _ sr pt ype ▁] ▁[ ▁0 ▁] ▁== ▁DB _ SR P _ INDEX ▁) ▁{ ▁if ▁( ▁( ▁g N ▁= ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁* ▁g N ▁) ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁g N ▁-> ▁id ▁= ▁OPENSSL _ strdup ▁( ▁pp ▁[ ▁DB _ sr pid ▁] ▁) ▁) ▁== ▁NULL ▁|| ▁( ▁g N ▁-> ▁N ▁= ▁SR P _ g N _ place _ bn ▁( ▁vb ▁-> ▁g N _ cache ▁, ▁pp ▁[ ▁DB _ sr p verifier ▁] ▁) ▁) ▁== ▁NULL ▁|| ▁( ▁g N ▁-> ▁g ▁= ▁SR P _ g N _ place _ bn ▁( ▁vb ▁-> ▁g N _ cache ▁, ▁pp ▁[ ▁DB _ sr ps alt ▁] ▁) ▁) ▁== ▁NULL ▁|| ▁sk _ SR P _ g N _ insert ▁( ▁SR P _ g N _ tab ▁, ▁g N ▁, ▁0 ▁) ▁== ▁0 ▁) ▁goto ▁err ▁; ▁g N ▁= ▁NULL ▁; ▁if ▁( ▁vb ▁-> ▁seed _ key ▁!= ▁NULL ▁) ▁{ ▁last _ index ▁= ▁pp ▁[ ▁DB _ sr pid ▁] ▁; ▁} ▁} ▁else ▁if ▁( ▁pp ▁[ ▁DB _ sr pt ype ▁] ▁[ ▁0 ▁] ▁== ▁DB _ SR P _ VALID ▁) ▁{ ▁const ▁SR P _ g N ▁* ▁lg N ▁; ▁if ▁( ▁( ▁lg N ▁= ▁SR P _ get _ g N _ by _ id ▁( ▁pp ▁[ ▁DB _ sr pg N ▁] ▁, ▁SR P _ g N _ tab ▁) ▁) ▁!= ▁NULL ▁) ▁{ ▁error _ code ▁= ▁SR P _ ERR _ MEMORY ▁; ▁if ▁( ▁( ▁user _ pwd ▁= ▁SR P _ user _ pwd _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁SR P _ user _ pwd _ set _ g N ▁( ▁user _ pwd ▁, ▁lg N ▁-> ▁g ▁, ▁lg N ▁-> ▁N ▁) ▁; ▁if ▁( ▁! ▁SR P _ user _ pwd _ set _ ids ▁( ▁user _ pwd ▁, ▁pp ▁[ ▁DB _ sr pid ▁] ▁, ▁pp ▁[ ▁DB _ sr p info ▁] ▁) ▁) ▁goto ▁err ▁; ▁error _ code ▁= ▁SR P _ ERR _ V BASE _ BN _ LIB ▁; ▁if ▁( ▁! ▁SR P _ user _ pwd _ set _ sv ▁( ▁user _ pwd ▁, ▁pp ▁[ ▁DB _ sr ps alt ▁] ▁, ▁pp ▁[ ▁DB _ sr p verifier ▁] ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁sk _ SR P _ user _ pwd _ insert ▁( ▁vb ▁-> ▁users _ pwd ▁, ▁user _ pwd ▁, ▁0 ▁) ▁== ▁0 ▁) ▁goto ▁err ▁; ▁user _ pwd ▁= ▁NULL ▁; ▁} ▁} ▁} ▁if ▁( ▁last _ index ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁( ▁g N ▁= ▁SR P _ get _ g N _ by _ id ▁( ▁last _ index ▁, ▁SR P _ g N _ tab ▁) ▁) ▁== ▁NULL ▁) ▁) ▁{ ▁error _ code ▁= ▁SR P _ ERR _ V BASE _ BN _ LIB ▁; ▁goto ▁err ▁; ▁} ▁vb ▁-> ▁default _ g ▁= ▁g N ▁-> ▁g ▁; ▁vb ▁-> ▁default _ N ▁= ▁g N ▁-> ▁N ▁; ▁g N ▁= ▁NULL ▁; ▁} ▁error _ code ▁= ▁SR P _ NO _ ERROR ▁; ▁err ▁: ▁if ▁( ▁g N ▁!= ▁NULL ▁) ▁{ ▁OPENSSL _ free ▁( ▁g N ▁-> ▁id ▁) ▁; ▁OPENSSL _ free ▁( ▁g N ▁) ▁; ▁} ▁SR P _ user _ pwd _ free ▁( ▁user _ pwd ▁) ▁; ▁TXT _ DB _ free ▁( ▁tmp db ▁) ▁; ▁BIO _ free _ all ▁( ▁in ▁) ▁; ▁sk _ SR P _ g N _ free ▁( ▁SR P _ g N _ tab ▁) ▁; ▁return ▁error _ code ▁; ▁}	0
▁int ▁test _ rshift 1 ▁( ▁BIO ▁* ▁bp ▁) ▁{ ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁, ▁* ▁c ▁; ▁int ▁i ▁; ▁a ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁= ▁BN _ new ▁( ▁) ▁; ▁c ▁= ▁BN _ new ▁( ▁) ▁; ▁BN _ bn test _ rand ▁( ▁a ▁, ▁200 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁a ▁-> ▁neg ▁= ▁rand _ neg ▁( ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num 0 ▁; ▁i ▁++ ▁) ▁{ ▁BN _ rshift 1 ▁( ▁b ▁, ▁a ▁) ▁; ▁if ▁( ▁bp ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁results ▁) ▁{ ▁BN _ print ▁( ▁bp ▁, ▁a ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"/ 2" ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"-" ▁) ▁; ▁} ▁BN _ print ▁( ▁bp ▁, ▁b ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"\ n " ▁) ▁; ▁} ▁BN _ sub ▁( ▁c ▁, ▁a ▁, ▁b ▁) ▁; ▁BN _ sub ▁( ▁c ▁, ▁c ▁, ▁b ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ zero ▁( ▁c ▁) ▁&& ▁! ▁BN _ abs _ is _ word ▁( ▁c ▁, ▁1 ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" Right sh if ton etest failed !\ n " ▁) ▁; ▁return ▁0 ▁; ▁} ▁BN _ copy ▁( ▁a ▁, ▁b ▁) ▁; ▁} ▁BN _ free ▁( ▁a ▁) ▁; ▁BN _ free ▁( ▁b ▁) ▁; ▁BN _ free ▁( ▁c ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁inline ▁void ▁encode _ dc ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁int ▁diff ▁, ▁int ▁component ▁) ▁{ ▁if ▁( ▁( ▁( ▁unsigned ▁) ▁( ▁diff ▁+ ▁255 ▁) ▁) ▁>= ▁511 ▁) ▁{ ▁int ▁index ▁; ▁if ▁( ▁diff ▁< ▁0 ▁) ▁{ ▁index ▁= ▁av _ log 2_ 16 bit ▁( ▁-2 ▁* ▁diff ▁) ▁; ▁diff ▁-- ▁; ▁} ▁else ▁{ ▁index ▁= ▁av _ log 2_ 16 bit ▁( ▁2 ▁* ▁diff ▁) ▁; ▁} ▁if ▁( ▁component ▁== ▁0 ▁) ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁ff _ mpeg 12_ vlc _ dc _ l um _ bits ▁[ ▁index ▁] ▁+ ▁index ▁, ▁( ▁ff _ mpeg 12_ vlc _ dc _ l um _ code ▁[ ▁index ▁] ▁<< ▁index ▁) ▁+ ▁( ▁diff ▁& ▁( ▁( ▁1 ▁<< ▁index ▁) ▁- ▁1 ▁) ▁) ▁) ▁; ▁else ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁ff _ mpeg 12_ vlc _ dc _ chroma _ bits ▁[ ▁index ▁] ▁+ ▁index ▁, ▁( ▁ff _ mpeg 12_ vlc _ dc _ chroma _ code ▁[ ▁index ▁] ▁<< ▁index ▁) ▁+ ▁( ▁diff ▁& ▁( ▁( ▁1 ▁<< ▁index ▁) ▁- ▁1 ▁) ▁) ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁component ▁== ▁0 ▁) ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁mpeg 1_ l um _ dc _ uni ▁[ ▁diff ▁+ ▁255 ▁] ▁& ▁0 xFF ▁, ▁mpeg 1_ l um _ dc _ uni ▁[ ▁diff ▁+ ▁255 ▁] ▁>> ▁8 ▁) ▁; ▁else ▁put _ bits ▁( ▁& ▁s ▁-> ▁pb ▁, ▁mpeg 1_ chr _ dc _ uni ▁[ ▁diff ▁+ ▁255 ▁] ▁& ▁0 xFF ▁, ▁mpeg 1_ chr _ dc _ uni ▁[ ▁diff ▁+ ▁255 ▁] ▁>> ▁8 ▁) ▁; ▁} ▁}	1
▁static ▁av _ always _ inline ▁int ▁check _ block ▁( ▁Snow Context ▁* ▁s ▁, ▁int ▁mb _ x ▁, ▁int ▁mb _ y ▁, ▁int ▁p ▁[ ▁3 ▁] ▁, ▁int ▁in tra ▁, ▁const ▁uint 8_ t ▁* ▁ob mc _ ed ged ▁, ▁int ▁* ▁best _ rd ▁) ▁{ ▁const ▁int ▁b _ stride ▁= ▁s ▁-> ▁b _ width ▁<< ▁s ▁-> ▁block _ max _ depth ▁; ▁Block Node ▁* ▁block ▁= ▁& ▁s ▁-> ▁block ▁[ ▁mb _ x ▁+ ▁mb _ y ▁* ▁b _ stride ▁] ▁; ▁Block Node ▁backup ▁= ▁* ▁block ▁; ▁unsigned ▁value ▁; ▁int ▁rd ▁, ▁index ▁; ▁assert ▁( ▁mb _ x ▁>= ▁0 ▁&& ▁mb _ y ▁>= ▁0 ▁) ▁; ▁assert ▁( ▁mb _ x ▁< ▁b _ stride ▁) ▁; ▁if ▁( ▁in tra ▁) ▁{ ▁block ▁-> ▁color ▁[ ▁0 ▁] ▁= ▁p ▁[ ▁0 ▁] ▁; ▁block ▁-> ▁color ▁[ ▁1 ▁] ▁= ▁p ▁[ ▁1 ▁] ▁; ▁block ▁-> ▁color ▁[ ▁2 ▁] ▁= ▁p ▁[ ▁2 ▁] ▁; ▁block ▁-> ▁type ▁|= ▁BLOCK _ INTR A ▁; ▁} ▁else ▁{ ▁index ▁= ▁( ▁p ▁[ ▁0 ▁] ▁+ ▁31 ▁* ▁p ▁[ ▁1 ▁] ▁) ▁& ▁( ▁ME _ CACHE _ SIZE ▁- ▁1 ▁) ▁; ▁value ▁= ▁s ▁-> ▁me _ cache _ generation ▁+ ▁( ▁p ▁[ ▁0 ▁] ▁>> ▁10 ▁) ▁+ ▁( ▁p ▁[ ▁1 ▁] ▁<< ▁6 ▁) ▁+ ▁( ▁block ▁-> ▁ref ▁<< ▁12 ▁) ▁; ▁if ▁( ▁s ▁-> ▁me _ cache ▁[ ▁index ▁] ▁== ▁value ▁) ▁return ▁0 ▁; ▁s ▁-> ▁me _ cache ▁[ ▁index ▁] ▁= ▁value ▁; ▁block ▁-> ▁mx ▁= ▁p ▁[ ▁0 ▁] ▁; ▁block ▁-> ▁my ▁= ▁p ▁[ ▁1 ▁] ▁; ▁block ▁-> ▁type ▁&= ▁ ~ ▁BLOCK _ INTR A ▁; ▁} ▁rd ▁= ▁get _ block _ rd ▁( ▁s ▁, ▁mb _ x ▁, ▁mb _ y ▁, ▁0 ▁, ▁ob mc _ ed ged ▁) ▁; ▁if ▁( ▁rd ▁< ▁* ▁best _ rd ▁) ▁{ ▁* ▁best _ rd ▁= ▁rd ▁; ▁return ▁1 ▁; ▁} ▁else ▁{ ▁* ▁block ▁= ▁backup ▁; ▁return ▁0 ▁; ▁} ▁}	0
▁AVFilter Buffer Ref ▁* ▁avfilter _ default _ get _ video _ buffer ▁( ▁AVFilter Link ▁* ▁link ▁, ▁int ▁perms ▁, ▁int ▁w ▁, ▁int ▁h ▁) ▁{ ▁AVFilter Buffer ▁* ▁pic ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Buffer ▁) ▁) ▁; ▁AVFilter Buffer Ref ▁* ▁ref ▁= ▁NULL ▁; ▁int ▁i ▁, ▁temp size ▁; ▁char ▁* ▁buf ▁= ▁NULL ▁; ▁if ▁( ▁! ▁pic ▁|| ▁! ▁( ▁ref ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Buffer Ref ▁) ▁) ▁) ▁) ▁goto ▁fail ▁; ▁ref ▁-> ▁buf ▁= ▁pic ▁; ▁ref ▁-> ▁video ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Buffer Ref Video Props ▁) ▁) ▁; ▁ref ▁-> ▁video ▁-> ▁w ▁= ▁w ▁; ▁ref ▁-> ▁video ▁-> ▁h ▁= ▁h ▁; ▁ref ▁-> ▁perms ▁= ▁perms ▁| ▁AV _ PERM _ READ ▁; ▁pic ▁-> ▁refcount ▁= ▁1 ▁; ▁ref ▁-> ▁format ▁= ▁link ▁-> ▁format ▁; ▁pic ▁-> ▁free ▁= ▁avfilter _ default _ free _ buffer ▁; ▁av _ fill _ image _ lines izes ▁( ▁pic ▁-> ▁linesize ▁, ▁ref ▁-> ▁format ▁, ▁ref ▁-> ▁video ▁-> ▁w ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁pic ▁-> ▁linesize ▁[ ▁i ▁] ▁= ▁FF ALIGN ▁( ▁pic ▁-> ▁linesize ▁[ ▁i ▁] ▁, ▁16 ▁) ▁; ▁temp size ▁= ▁av _ fill _ image _ pointers ▁( ▁pic ▁-> ▁data ▁, ▁ref ▁-> ▁format ▁, ▁ref ▁-> ▁video ▁-> ▁h ▁, ▁NULL ▁, ▁pic ▁-> ▁linesize ▁) ▁; ▁buf ▁= ▁av _ malloc ▁( ▁temp size ▁+ ▁16 ▁) ▁; ▁if ▁( ▁! ▁buf ▁) ▁goto ▁fail ▁; ▁av _ fill _ image _ pointers ▁( ▁pic ▁-> ▁data ▁, ▁ref ▁-> ▁format ▁, ▁ref ▁-> ▁video ▁-> ▁h ▁, ▁buf ▁, ▁pic ▁-> ▁linesize ▁) ▁; ▁memcpy ▁( ▁ref ▁-> ▁data ▁, ▁pic ▁-> ▁data ▁, ▁sizeof ▁( ▁ref ▁-> ▁data ▁) ▁) ▁; ▁memcpy ▁( ▁ref ▁-> ▁linesize ▁, ▁pic ▁-> ▁linesize ▁, ▁sizeof ▁( ▁ref ▁-> ▁linesize ▁) ▁) ▁; ▁return ▁ref ▁; ▁fail ▁: ▁av _ free ▁( ▁buf ▁) ▁; ▁if ▁( ▁ref ▁&& ▁ref ▁-> ▁video ▁) ▁av _ free ▁( ▁ref ▁-> ▁video ▁) ▁; ▁av _ free ▁( ▁ref ▁) ▁; ▁av _ free ▁( ▁pic ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁void ▁write _ code books ▁( ▁Ro q Context ▁* ▁enc ▁, ▁Ro q Temp data ▁* ▁temp Data ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁uint 8_ t ▁* ▁* ▁outp ▁= ▁& ▁enc ▁-> ▁out _ buf ▁; ▁if ▁( ▁temp Data ▁-> ▁num CB 2 ▁) ▁{ ▁bytestream _ put _ le 16 ▁( ▁outp ▁, ▁Ro Q _ QUAD _ CODE BOOK ▁) ▁; ▁bytestream _ put _ le 32 ▁( ▁outp ▁, ▁temp Data ▁-> ▁num CB 2 ▁* ▁6 ▁+ ▁temp Data ▁-> ▁num CB 4 ▁* ▁4 ▁) ▁; ▁bytestream _ put _ byte ▁( ▁outp ▁, ▁temp Data ▁-> ▁num CB 4 ▁) ▁; ▁bytestream _ put _ byte ▁( ▁outp ▁, ▁temp Data ▁-> ▁num CB 2 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁temp Data ▁-> ▁num CB 2 ▁; ▁i ▁++ ▁) ▁{ ▁bytestream _ put _ buffer ▁( ▁outp ▁, ▁enc ▁-> ▁cb 2 x 2 ▁[ ▁temp Data ▁-> ▁f 2 i 2 ▁[ ▁i ▁] ▁] ▁. ▁y ▁, ▁4 ▁) ▁; ▁bytestream _ put _ byte ▁( ▁outp ▁, ▁enc ▁-> ▁cb 2 x 2 ▁[ ▁temp Data ▁-> ▁f 2 i 2 ▁[ ▁i ▁] ▁] ▁. ▁u ▁) ▁; ▁bytestream _ put _ byte ▁( ▁outp ▁, ▁enc ▁-> ▁cb 2 x 2 ▁[ ▁temp Data ▁-> ▁f 2 i 2 ▁[ ▁i ▁] ▁] ▁. ▁v ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁temp Data ▁-> ▁num CB 4 ▁; ▁i ▁++ ▁) ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁bytestream _ put _ byte ▁( ▁outp ▁, ▁temp Data ▁-> ▁i 2 f 2 ▁[ ▁enc ▁-> ▁cb 4 x 4 ▁[ ▁temp Data ▁-> ▁f 2 i 4 ▁[ ▁i ▁] ▁] ▁. ▁idx ▁[ ▁j ▁] ▁] ▁) ▁; ▁} ▁}	1
▁static ▁void ▁ctr _ B CC _ update ▁( ▁RAND _ DR BG _ CTR ▁* ▁ctr ▁, ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁size _ t ▁inlen ▁) ▁{ ▁if ▁( ▁in ▁== ▁NULL ▁|| ▁inlen ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁ctr ▁-> ▁blt mp _ pos ▁) ▁{ ▁size _ t ▁left ▁= ▁16 ▁- ▁ctr ▁-> ▁blt mp _ pos ▁; ▁if ▁( ▁inlen ▁>= ▁left ▁) ▁{ ▁memcpy ▁( ▁ctr ▁-> ▁blt mp ▁+ ▁ctr ▁-> ▁blt mp _ pos ▁, ▁in ▁, ▁left ▁) ▁; ▁ctr _ B CC _ blocks ▁( ▁ctr ▁, ▁ctr ▁-> ▁blt mp ▁) ▁; ▁ctr ▁-> ▁blt mp _ pos ▁= ▁0 ▁; ▁inlen ▁-= ▁left ▁; ▁in ▁+= ▁left ▁; ▁} ▁} ▁for ▁( ▁; ▁inlen ▁>= ▁16 ▁; ▁in ▁+= ▁16 ▁, ▁inlen ▁-= ▁16 ▁) ▁{ ▁ctr _ B CC _ blocks ▁( ▁ctr ▁, ▁in ▁) ▁; ▁} ▁if ▁( ▁inlen ▁> ▁0 ▁) ▁{ ▁memcpy ▁( ▁ctr ▁-> ▁blt mp ▁+ ▁ctr ▁-> ▁blt mp _ pos ▁, ▁in ▁, ▁inlen ▁) ▁; ▁ctr ▁-> ▁blt mp _ pos ▁+= ▁inlen ▁; ▁} ▁}	0
▁static ▁int ▁F ax 3 Setup State ▁( ▁TIFF ▁* ▁tif ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" F ax 3 Setup State " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁F ax 3 Base State ▁* ▁sp ▁= ▁F ax 3 State ▁( ▁tif ▁) ▁; ▁int ▁needs Ref Line ▁; ▁F ax 3 Codec State ▁* ▁dsp ▁= ▁( ▁F ax 3 Codec State ▁* ▁) ▁F ax 3 State ▁( ▁tif ▁) ▁; ▁tm size _ t ▁row bytes ▁; ▁uint 32 ▁row pixels ▁, ▁n runs ▁; ▁if ▁( ▁td ▁-> ▁td _ bits pers ample ▁!= ▁1 ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Bits / sample must be 1 for Group 3/ 4 encoding / de coding " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁is Tiled ▁( ▁tif ▁) ▁) ▁{ ▁row bytes ▁= ▁TIFF Tile Row Size ▁( ▁tif ▁) ▁; ▁row pixels ▁= ▁td ▁-> ▁td _ tile width ▁; ▁} ▁else ▁{ ▁row bytes ▁= ▁TIFF Scan line Size ▁( ▁tif ▁) ▁; ▁row pixels ▁= ▁td ▁-> ▁td _ image width ▁; ▁} ▁sp ▁-> ▁row bytes ▁= ▁row bytes ▁; ▁sp ▁-> ▁row pixels ▁= ▁row pixels ▁; ▁needs Ref Line ▁= ▁( ▁( ▁sp ▁-> ▁group options ▁& ▁GROUP 3 OPT _2 DEN CODING ▁) ▁|| ▁td ▁-> ▁td _ compression ▁== ▁COMPRESS ION _ CC ITT FA X 4 ▁) ▁; ▁n runs ▁= ▁needs Ref Line ▁? ▁2 ▁* ▁TIFF round up _32 ▁( ▁row pixels ▁, ▁32 ▁) ▁: ▁row pixels ▁; ▁n runs ▁+= ▁3 ▁; ▁dsp ▁-> ▁runs ▁= ▁( ▁uint 32 ▁* ▁) ▁_ TIFF Check Malloc ▁( ▁tif ▁, ▁2 ▁* ▁n runs ▁, ▁sizeof ▁( ▁uint 32 ▁) ▁, ▁" for Group 3/ 4 run arrays " ▁) ▁; ▁if ▁( ▁dsp ▁-> ▁runs ▁== ▁NULL ▁) ▁return ▁( ▁0 ▁) ▁; ▁dsp ▁-> ▁cur runs ▁= ▁dsp ▁-> ▁runs ▁; ▁if ▁( ▁needs Ref Line ▁) ▁dsp ▁-> ▁ref runs ▁= ▁dsp ▁-> ▁runs ▁+ ▁n runs ▁; ▁else ▁dsp ▁-> ▁ref runs ▁= ▁NULL ▁; ▁if ▁( ▁td ▁-> ▁td _ compression ▁== ▁COMPRESS ION _ CC ITT FA X 3 ▁&& ▁is 2 D Encoding ▁( ▁dsp ▁) ▁) ▁{ ▁tif ▁-> ▁tif _ decoder ow ▁= ▁F ax 3 Decode 2 D ▁; ▁tif ▁-> ▁tif _ decode strip ▁= ▁F ax 3 Decode 2 D ▁; ▁tif ▁-> ▁tif _ decode tile ▁= ▁F ax 3 Decode 2 D ▁; ▁} ▁if ▁( ▁needs Ref Line ▁) ▁{ ▁F ax 3 Codec State ▁* ▁esp ▁= ▁Encoder State ▁( ▁tif ▁) ▁; ▁esp ▁-> ▁ref line ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁_ TIFF malloc ▁( ▁row bytes ▁) ▁; ▁if ▁( ▁esp ▁-> ▁ref line ▁== ▁NULL ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" N os pace for Group 3/ 4 reference line " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁else ▁Encoder State ▁( ▁tif ▁) ▁-> ▁ref line ▁= ▁NULL ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁BIGNUM ▁* ▁bn _ expand 2 ▁( ▁BIGNUM ▁* ▁b ▁, ▁int ▁words ▁) ▁{ ▁BN _ ULONG ▁* ▁A ▁, ▁* ▁a ▁; ▁const ▁BN _ ULONG ▁* ▁B ▁; ▁int ▁i ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁words ▁> ▁b ▁-> ▁dmax ▁) ▁{ ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁BN _ get _ flags ▁( ▁b ▁, ▁BN _ FLG _ STATIC _ DATA ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ EXPAND 2 ▁, ▁BN _ R _ EXPAND _ ON _ STATIC _ BIG NUM _ DATA ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁a ▁= ▁A ▁= ▁( ▁BN _ ULONG ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁BN _ ULONG ▁) ▁* ▁( ▁words ▁+ ▁1 ▁) ▁) ▁; ▁if ▁( ▁A ▁== ▁NULL ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ EXPAND 2 ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁# if ▁1 ▁B ▁= ▁b ▁-> ▁d ▁; ▁if ▁( ▁B ▁!= ▁NULL ▁) ▁{ ▁# if ▁0 ▁for ▁( ▁i ▁= ▁b ▁-> ▁top ▁& ▁( ▁ ~ ▁7 ▁) ▁; ▁i ▁> ▁0 ▁; ▁i ▁-= ▁8 ▁) ▁{ ▁A ▁[ ▁0 ▁] ▁= ▁B ▁[ ▁0 ▁] ▁; ▁A ▁[ ▁1 ▁] ▁= ▁B ▁[ ▁1 ▁] ▁; ▁A ▁[ ▁2 ▁] ▁= ▁B ▁[ ▁2 ▁] ▁; ▁A ▁[ ▁3 ▁] ▁= ▁B ▁[ ▁3 ▁] ▁; ▁A ▁[ ▁4 ▁] ▁= ▁B ▁[ ▁4 ▁] ▁; ▁A ▁[ ▁5 ▁] ▁= ▁B ▁[ ▁5 ▁] ▁; ▁A ▁[ ▁6 ▁] ▁= ▁B ▁[ ▁6 ▁] ▁; ▁A ▁[ ▁7 ▁] ▁= ▁B ▁[ ▁7 ▁] ▁; ▁A ▁+= ▁8 ▁; ▁B ▁+= ▁8 ▁; ▁} ▁switch ▁( ▁b ▁-> ▁top ▁& ▁7 ▁) ▁{ ▁case ▁7 ▁: ▁A ▁[ ▁6 ▁] ▁= ▁B ▁[ ▁6 ▁] ▁; ▁case ▁6 ▁: ▁A ▁[ ▁5 ▁] ▁= ▁B ▁[ ▁5 ▁] ▁; ▁case ▁5 ▁: ▁A ▁[ ▁4 ▁] ▁= ▁B ▁[ ▁4 ▁] ▁; ▁case ▁4 ▁: ▁A ▁[ ▁3 ▁] ▁= ▁B ▁[ ▁3 ▁] ▁; ▁case ▁3 ▁: ▁A ▁[ ▁2 ▁] ▁= ▁B ▁[ ▁2 ▁] ▁; ▁case ▁2 ▁: ▁A ▁[ ▁1 ▁] ▁= ▁B ▁[ ▁1 ▁] ▁; ▁case ▁1 ▁: ▁A ▁[ ▁0 ▁] ▁= ▁B ▁[ ▁0 ▁] ▁; ▁case ▁0 ▁: ▁; ▁} ▁# else ▁for ▁( ▁i ▁= ▁b ▁-> ▁top ▁>> ▁2 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁+= ▁4 ▁, ▁B ▁+= ▁4 ▁) ▁{ ▁BN _ ULONG ▁a 0 ▁, ▁a 1 ▁, ▁a 2 ▁, ▁a 3 ▁; ▁a 0 ▁= ▁B ▁[ ▁0 ▁] ▁; ▁a 1 ▁= ▁B ▁[ ▁1 ▁] ▁; ▁a 2 ▁= ▁B ▁[ ▁2 ▁] ▁; ▁a 3 ▁= ▁B ▁[ ▁3 ▁] ▁; ▁A ▁[ ▁0 ▁] ▁= ▁a 0 ▁; ▁A ▁[ ▁1 ▁] ▁= ▁a 1 ▁; ▁A ▁[ ▁2 ▁] ▁= ▁a 2 ▁; ▁A ▁[ ▁3 ▁] ▁= ▁a 3 ▁; ▁} ▁switch ▁( ▁b ▁-> ▁top ▁& ▁3 ▁) ▁{ ▁case ▁3 ▁: ▁A ▁[ ▁2 ▁] ▁= ▁B ▁[ ▁2 ▁] ▁; ▁case ▁2 ▁: ▁A ▁[ ▁1 ▁] ▁= ▁B ▁[ ▁1 ▁] ▁; ▁case ▁1 ▁: ▁A ▁[ ▁0 ▁] ▁= ▁B ▁[ ▁0 ▁] ▁; ▁case ▁0 ▁: ▁; ▁} ▁# endif ▁OPENSSL _ free ▁( ▁b ▁-> ▁d ▁) ▁; ▁} ▁b ▁-> ▁d ▁= ▁a ▁; ▁b ▁-> ▁dmax ▁= ▁words ▁; ▁A ▁= ▁& ▁( ▁b ▁-> ▁d ▁[ ▁b ▁-> ▁top ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁( ▁b ▁-> ▁dmax ▁- ▁b ▁-> ▁top ▁) ▁>> ▁3 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁+= ▁8 ▁) ▁{ ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁1 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁2 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁3 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁4 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁5 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁6 ▁] ▁= ▁0 ▁; ▁A ▁[ ▁7 ▁] ▁= ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁( ▁b ▁-> ▁dmax ▁- ▁b ▁-> ▁top ▁) ▁& ▁7 ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁, ▁A ▁++ ▁) ▁A ▁[ ▁0 ▁] ▁= ▁0 ▁; ▁# else ▁memset ▁( ▁A ▁, ▁0 ▁, ▁sizeof ▁( ▁BN _ ULONG ▁) ▁* ▁( ▁words ▁+ ▁1 ▁) ▁) ▁; ▁memcpy ▁( ▁A ▁, ▁b ▁-> ▁d ▁, ▁sizeof ▁( ▁b ▁-> ▁d ▁[ ▁0 ▁] ▁) ▁* ▁b ▁-> ▁top ▁) ▁; ▁b ▁-> ▁d ▁= ▁a ▁; ▁b ▁-> ▁max ▁= ▁words ▁; ▁# endif ▁} ▁return ▁( ▁b ▁) ▁; ▁}	1
▁BIGNUM ▁* ▁BN _ copy ▁( ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁) ▁{ ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁if ▁( ▁a ▁== ▁b ▁) ▁return ▁a ▁; ▁if ▁( ▁bn _ w expand ▁( ▁a ▁, ▁b ▁-> ▁top ▁) ▁== ▁NULL ▁) ▁return ▁NULL ▁; ▁if ▁( ▁b ▁-> ▁top ▁> ▁0 ▁) ▁memcpy ▁( ▁a ▁-> ▁d ▁, ▁b ▁-> ▁d ▁, ▁sizeof ▁( ▁b ▁-> ▁d ▁[ ▁0 ▁] ▁) ▁* ▁b ▁-> ▁top ▁) ▁; ▁if ▁( ▁BN _ get _ flags ▁( ▁b ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁) ▁BN _ set _ flags ▁( ▁a ▁, ▁BN _ FLG _ CONST TIME ▁) ▁; ▁a ▁-> ▁top ▁= ▁b ▁-> ▁top ▁; ▁a ▁-> ▁neg ▁= ▁b ▁-> ▁neg ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁return ▁a ▁; ▁}	1
▁static ▁inline ▁int ▁init _ pf a _ re index _ tabs ▁( ▁MD CT 15 Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁const ▁int ▁b _ pt wo ▁= ▁s ▁-> ▁pt wo _ fft ▁. ▁nbits ▁; ▁const ▁int ▁l _ pt wo ▁= ▁1 ▁<< ▁b _ pt wo ▁; ▁const ▁int ▁inv _1 ▁= ▁l _ pt wo ▁<< ▁( ▁( ▁4 ▁- ▁b _ pt wo ▁) ▁& ▁3 ▁) ▁; ▁const ▁int ▁inv _2 ▁= ▁0 xee ee eee f ▁& ▁( ▁( ▁1 U ▁<< ▁b _ pt wo ▁) ▁- ▁1 ▁) ▁; ▁s ▁-> ▁p fa _ pr ere index ▁= ▁av _ malloc ▁( ▁15 ▁* ▁l _ pt wo ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁p fa _ pr ere index ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁p fa _ pr ere index ▁) ▁return ▁1 ▁; ▁s ▁-> ▁p fa _ post re index ▁= ▁av _ malloc ▁( ▁15 ▁* ▁l _ pt wo ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁p fa _ post re index ▁) ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁p fa _ post re index ▁) ▁return ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁l _ pt wo ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁15 ▁; ▁j ▁++ ▁) ▁{ ▁const ▁int ▁q _ pre ▁= ▁( ▁( ▁l _ pt wo ▁* ▁j ▁) ▁/ ▁15 ▁+ ▁i ▁) ▁>> ▁b _ pt wo ▁; ▁const ▁int ▁q _ post ▁= ▁( ▁( ▁( ▁j ▁* ▁inv _1 ▁) ▁/ ▁15 ▁) ▁+ ▁( ▁i ▁* ▁inv _2 ▁) ▁) ▁>> ▁b _ pt wo ▁; ▁const ▁int ▁k _ pre ▁= ▁15 ▁* ▁i ▁+ ▁( ▁( ▁j ▁- ▁q _ pre ▁* ▁15 ▁) ▁<< ▁b _ pt wo ▁) ▁; ▁const ▁int ▁k _ post ▁= ▁i ▁* ▁inv _2 ▁* ▁15 ▁+ ▁j ▁* ▁inv _1 ▁- ▁15 ▁* ▁q _ post ▁* ▁l _ pt wo ▁; ▁s ▁-> ▁p fa _ pr ere index ▁[ ▁i ▁* ▁15 ▁+ ▁j ▁] ▁= ▁k _ pre ▁; ▁s ▁-> ▁p fa _ post re index ▁[ ▁k _ post ▁] ▁= ▁l _ pt wo ▁* ▁j ▁+ ▁i ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁ngx _ int _ t ▁ngx _ http _ core _ try _ files _ phase ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ http _ phase _ handler _ t ▁* ▁ph ▁) ▁{ ▁size _ t ▁len ▁, ▁root ▁, ▁alias ▁, ▁reserve ▁, ▁allocated ▁; ▁u _ char ▁* ▁p ▁, ▁* ▁name ▁; ▁ngx _ str _ t ▁path ▁, ▁args ▁; ▁ngx _ uint _ t ▁test _ dir ▁; ▁ngx _ http _ try _ file _ t ▁* ▁tf ▁; ▁ngx _ open _ file _ info _ t ▁of ▁; ▁ngx _ http _ script _ code _ pt ▁code ▁; ▁ngx _ http _ script _ engine _ t ▁e ▁; ▁ngx _ http _ core _ loc _ conf _ t ▁* ▁cl cf ▁; ▁ngx _ http _ script _ len _ code _ pt ▁l code ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" try file sph ase :% ui " ▁, ▁r ▁-> ▁phase _ handler ▁) ▁; ▁cl cf ▁= ▁ngx _ http _ get _ module _ loc _ conf ▁( ▁r ▁, ▁ngx _ http _ core _ module ▁) ▁; ▁if ▁( ▁cl cf ▁-> ▁try _ files ▁== ▁NULL ▁) ▁{ ▁r ▁-> ▁phase _ handler ▁++ ▁; ▁return ▁NGX _ AGAIN ▁; ▁} ▁allocated ▁= ▁0 ▁; ▁root ▁= ▁0 ▁; ▁name ▁= ▁NULL ▁; ▁path ▁. ▁data ▁= ▁NULL ▁; ▁tf ▁= ▁cl cf ▁-> ▁try _ files ▁; ▁alias ▁= ▁cl cf ▁-> ▁alias ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁tf ▁-> ▁lengths ▁) ▁{ ▁ngx _ mem zero ▁( ▁& ▁e ▁, ▁sizeof ▁( ▁ngx _ http _ script _ engine _ t ▁) ▁) ▁; ▁e ▁. ▁ip ▁= ▁tf ▁-> ▁lengths ▁-> ▁elts ▁; ▁e ▁. ▁request ▁= ▁r ▁; ▁len ▁= ▁1 ▁; ▁while ▁( ▁* ▁( ▁uintptr _ t ▁* ▁) ▁e ▁. ▁ip ▁) ▁{ ▁l code ▁= ▁* ▁( ▁ngx _ http _ script _ len _ code _ pt ▁* ▁) ▁e ▁. ▁ip ▁; ▁len ▁+= ▁l code ▁( ▁& ▁e ▁) ▁; ▁} ▁} ▁else ▁{ ▁len ▁= ▁tf ▁-> ▁name ▁. ▁len ▁; ▁} ▁if ▁( ▁! ▁alias ▁) ▁{ ▁reserve ▁= ▁len ▁> ▁r ▁-> ▁uri ▁. ▁len ▁? ▁len ▁- ▁r ▁-> ▁uri ▁. ▁len ▁: ▁0 ▁; ▁} ▁else ▁if ▁( ▁alias ▁== ▁NGX _ MAX _ SIZE _ T _ VALUE ▁) ▁{ ▁reserve ▁= ▁len ▁; ▁} ▁else ▁{ ▁reserve ▁= ▁len ▁> ▁r ▁-> ▁uri ▁. ▁len ▁- ▁alias ▁? ▁len ▁- ▁( ▁r ▁-> ▁uri ▁. ▁len ▁- ▁alias ▁) ▁: ▁0 ▁; ▁} ▁if ▁( ▁reserve ▁> ▁allocated ▁|| ▁! ▁allocated ▁) ▁{ ▁allocated ▁= ▁reserve ▁+ ▁16 ▁; ▁if ▁( ▁ngx _ http _ map _ uri _ to _ path ▁( ▁r ▁, ▁& ▁path ▁, ▁& ▁root ▁, ▁allocated ▁) ▁== ▁NULL ▁) ▁{ ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁NGX _ OK ▁; ▁} ▁name ▁= ▁path ▁. ▁data ▁+ ▁root ▁; ▁} ▁if ▁( ▁tf ▁-> ▁values ▁== ▁NULL ▁) ▁{ ▁ngx _ memcpy ▁( ▁name ▁, ▁tf ▁-> ▁name ▁. ▁data ▁, ▁tf ▁-> ▁name ▁. ▁len ▁) ▁; ▁path ▁. ▁len ▁= ▁( ▁name ▁+ ▁tf ▁-> ▁name ▁. ▁len ▁- ▁1 ▁) ▁- ▁path ▁. ▁data ▁; ▁} ▁else ▁{ ▁e ▁. ▁ip ▁= ▁tf ▁-> ▁values ▁-> ▁elts ▁; ▁e ▁. ▁pos ▁= ▁name ▁; ▁e ▁. ▁flushed ▁= ▁1 ▁; ▁while ▁( ▁* ▁( ▁uintptr _ t ▁* ▁) ▁e ▁. ▁ip ▁) ▁{ ▁code ▁= ▁* ▁( ▁ngx _ http _ script _ code _ pt ▁* ▁) ▁e ▁. ▁ip ▁; ▁code ▁( ▁( ▁ngx _ http _ script _ engine _ t ▁* ▁) ▁& ▁e ▁) ▁; ▁} ▁path ▁. ▁len ▁= ▁e ▁. ▁pos ▁- ▁path ▁. ▁data ▁; ▁* ▁e ▁. ▁pos ▁= ▁' ▁\0 ▁' ▁; ▁if ▁( ▁alias ▁&& ▁alias ▁!= ▁NGX _ MAX _ SIZE _ T _ VALUE ▁&& ▁ngx _ strncmp ▁( ▁name ▁, ▁r ▁-> ▁uri ▁. ▁data ▁, ▁alias ▁) ▁== ▁0 ▁) ▁{ ▁ngx _ memmove ▁( ▁name ▁, ▁name ▁+ ▁alias ▁, ▁len ▁- ▁alias ▁) ▁; ▁path ▁. ▁len ▁-= ▁alias ▁; ▁} ▁} ▁test _ dir ▁= ▁tf ▁-> ▁test _ dir ▁; ▁tf ▁++ ▁; ▁ngx _ log _ debug 3 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" try ing t ouse % s : \"% s \" \"% s \"" ▁, ▁test _ dir ▁? ▁" dir " ▁: ▁" file " ▁, ▁name ▁, ▁path ▁. ▁data ▁) ▁; ▁if ▁( ▁tf ▁-> ▁lengths ▁== ▁NULL ▁&& ▁tf ▁-> ▁name ▁. ▁len ▁== ▁0 ▁) ▁{ ▁if ▁( ▁tf ▁-> ▁code ▁) ▁{ ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁tf ▁-> ▁code ▁) ▁; ▁return ▁NGX _ OK ▁; ▁} ▁path ▁. ▁len ▁-= ▁root ▁; ▁path ▁. ▁data ▁+= ▁root ▁; ▁if ▁( ▁path ▁. ▁data ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁( ▁void ▁) ▁ngx _ http _ named _ location ▁( ▁r ▁, ▁& ▁path ▁) ▁; ▁} ▁else ▁{ ▁ngx _ http _ split _ args ▁( ▁r ▁, ▁& ▁path ▁, ▁& ▁args ▁) ▁; ▁( ▁void ▁) ▁ngx _ http _ internal _ redirect ▁( ▁r ▁, ▁& ▁path ▁, ▁& ▁args ▁) ▁; ▁} ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁NGX _ DONE ▁) ▁; ▁return ▁NGX _ OK ▁; ▁} ▁ngx _ mem zero ▁( ▁& ▁of ▁, ▁sizeof ▁( ▁ngx _ open _ file _ info _ t ▁) ▁) ▁; ▁of ▁. ▁read _ ahead ▁= ▁cl cf ▁-> ▁read _ ahead ▁; ▁of ▁. ▁direct io ▁= ▁cl cf ▁-> ▁direct io ▁; ▁of ▁. ▁valid ▁= ▁cl cf ▁-> ▁open _ file _ cache _ valid ▁; ▁of ▁. ▁min _ uses ▁= ▁cl cf ▁-> ▁open _ file _ cache _ min _ uses ▁; ▁of ▁. ▁test _ only ▁= ▁1 ▁; ▁of ▁. ▁errors ▁= ▁cl cf ▁-> ▁open _ file _ cache _ errors ▁; ▁of ▁. ▁events ▁= ▁cl cf ▁-> ▁open _ file _ cache _ events ▁; ▁if ▁( ▁ngx _ http _ set _ disable _ sym links ▁( ▁r ▁, ▁cl cf ▁, ▁& ▁path ▁, ▁& ▁of ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁NGX _ OK ▁; ▁} ▁if ▁( ▁ngx _ open _ cached _ file ▁( ▁cl cf ▁-> ▁open _ file _ cache ▁, ▁& ▁path ▁, ▁& ▁of ▁, ▁r ▁-> ▁pool ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁if ▁( ▁of ▁. ▁err ▁== ▁0 ▁) ▁{ ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁NGX _ OK ▁; ▁} ▁if ▁( ▁of ▁. ▁err ▁!= ▁NGX _ ENO ENT ▁&& ▁of ▁. ▁err ▁!= ▁NGX _ EN OT DIR ▁&& ▁of ▁. ▁err ▁!= ▁NGX _ ENAME TOOLONG ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ CRIT ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁of ▁. ▁err ▁, ▁"% s \"% s \" failed " ▁, ▁of ▁. ▁failed ▁, ▁path ▁. ▁data ▁) ▁; ▁} ▁continue ▁; ▁} ▁if ▁( ▁of ▁. ▁is _ dir ▁!= ▁test _ dir ▁) ▁{ ▁continue ▁; ▁} ▁path ▁. ▁len ▁-= ▁root ▁; ▁path ▁. ▁data ▁+= ▁root ▁; ▁if ▁( ▁! ▁alias ▁) ▁{ ▁r ▁-> ▁uri ▁= ▁path ▁; ▁} ▁else ▁if ▁( ▁alias ▁== ▁NGX _ MAX _ SIZE _ T _ VALUE ▁) ▁{ ▁if ▁( ▁! ▁test _ dir ▁) ▁{ ▁r ▁-> ▁uri ▁= ▁path ▁; ▁r ▁-> ▁add _ uri _ to _ alias ▁= ▁1 ▁; ▁} ▁} ▁else ▁{ ▁name ▁= ▁r ▁-> ▁uri ▁. ▁data ▁; ▁r ▁-> ▁uri ▁. ▁len ▁= ▁alias ▁+ ▁path ▁. ▁len ▁; ▁r ▁-> ▁uri ▁. ▁data ▁= ▁ngx _ pn alloc ▁( ▁r ▁-> ▁pool ▁, ▁r ▁-> ▁uri ▁. ▁len ▁) ▁; ▁if ▁( ▁r ▁-> ▁uri ▁. ▁data ▁== ▁NULL ▁) ▁{ ▁r ▁-> ▁uri ▁. ▁len ▁= ▁0 ▁; ▁ngx _ http _ finalize _ request ▁( ▁r ▁, ▁NGX _ HTTP _ INTERNAL _ SERVER _ ERROR ▁) ▁; ▁return ▁NGX _ OK ▁; ▁} ▁p ▁= ▁ngx _ copy ▁( ▁r ▁-> ▁uri ▁. ▁data ▁, ▁name ▁, ▁alias ▁) ▁; ▁ngx _ memcpy ▁( ▁p ▁, ▁path ▁. ▁data ▁, ▁path ▁. ▁len ▁) ▁; ▁} ▁ngx _ http _ set _ ext en ▁( ▁r ▁) ▁; ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" try file uri : \"% V \"" ▁, ▁& ▁r ▁-> ▁uri ▁) ▁; ▁r ▁-> ▁phase _ handler ▁++ ▁; ▁return ▁NGX _ AGAIN ▁; ▁} ▁}	0
▁X 509 ▁* ▁ssl _ get _ server _ send _ cert ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁unsigned ▁long ▁alg _ k ▁, ▁alg _ a ▁, ▁mask _ k ▁, ▁mask _ a ▁; ▁C ERT ▁* ▁c ▁; ▁int ▁i ▁, ▁is _ export ▁; ▁c ▁= ▁s ▁-> ▁cert ▁; ▁ssl _ set _ cert _ masks ▁( ▁c ▁, ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁) ▁; ▁is _ export ▁= ▁SSL _ C _ IS _ EXPORT ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁) ▁; ▁if ▁( ▁is _ export ▁) ▁{ ▁mask _ k ▁= ▁c ▁-> ▁export _ mask _ k ▁; ▁mask _ a ▁= ▁c ▁-> ▁export _ mask _ a ▁; ▁} ▁else ▁{ ▁mask _ k ▁= ▁c ▁-> ▁mask _ k ▁; ▁mask _ a ▁= ▁c ▁-> ▁mask _ a ▁; ▁} ▁alg _ k ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithm _ m key ▁; ▁alg _ a ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithm _ auth ▁; ▁if ▁( ▁alg _ k ▁& ▁( ▁SSL _ k E ECDH ▁| ▁SSL _ k ECDH r ▁| ▁SSL _ k EC D He ▁) ▁) ▁{ ▁i ▁= ▁SSL _ PKEY _ ECC ▁; ▁} ▁else ▁if ▁( ▁alg _ a ▁& ▁SSL _ a ECDSA ▁) ▁{ ▁i ▁= ▁SSL _ PKEY _ ECC ▁; ▁} ▁else ▁if ▁( ▁alg _ k ▁& ▁SSL _ k DH r ▁) ▁i ▁= ▁SSL _ PKEY _ DH _ RSA ▁; ▁else ▁if ▁( ▁alg _ k ▁& ▁SSL _ k DH d ▁) ▁i ▁= ▁SSL _ PKEY _ DH _ DSA ▁; ▁else ▁if ▁( ▁alg _ a ▁& ▁SSL _ a DSS ▁) ▁i ▁= ▁SSL _ PKEY _ DSA _ SIGN ▁; ▁else ▁if ▁( ▁alg _ a ▁& ▁SSL _ a RSA ▁) ▁{ ▁if ▁( ▁c ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ RSA _ ENC ▁] ▁. ▁x 509 ▁== ▁NULL ▁) ▁i ▁= ▁SSL _ PKEY _ RSA _ SIGN ▁; ▁else ▁i ▁= ▁SSL _ PKEY _ RSA _ ENC ▁; ▁} ▁else ▁if ▁( ▁alg _ a ▁& ▁SSL _ a KRB 5 ▁) ▁{ ▁return ▁( ▁NULL ▁) ▁; ▁} ▁else ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ GET _ SERVER _ SEND _ CERT ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁if ▁( ▁c ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁== ▁NULL ▁) ▁return ▁( ▁NULL ▁) ▁; ▁return ▁( ▁c ▁-> ▁p keys ▁[ ▁i ▁] ▁. ▁x 509 ▁) ▁; ▁}	0
▁int ▁avio _ read ▁( ▁AVIO Context ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁buf ▁, ▁int ▁size ▁) ▁{ ▁int ▁len ▁, ▁size 1 ▁; ▁size 1 ▁= ▁size ▁; ▁while ▁( ▁size ▁> ▁0 ▁) ▁{ ▁len ▁= ▁FF MIN ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf _ ptr ▁, ▁size ▁) ▁; ▁if ▁( ▁len ▁== ▁0 ▁|| ▁s ▁-> ▁write _ flag ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁direct ▁|| ▁size ▁> ▁s ▁-> ▁buffer _ size ▁) ▁&& ▁! ▁s ▁-> ▁update _ checksum ▁) ▁{ ▁len ▁= ▁read _ packet _ wrapper ▁( ▁s ▁, ▁buf ▁, ▁size ▁) ▁; ▁if ▁( ▁len ▁== ▁AVERROR _ EOF ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁len ▁< ▁0 ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁s ▁-> ▁error ▁= ▁len ▁; ▁break ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pos ▁+= ▁len ▁; ▁s ▁-> ▁bytes _ read ▁+= ▁len ▁; ▁size ▁-= ▁len ▁; ▁buf ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁s ▁-> ▁buf _ end ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁} ▁else ▁{ ▁fill _ buffer ▁( ▁s ▁) ▁; ▁len ▁= ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf _ ptr ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁break ▁; ▁} ▁} ▁else ▁{ ▁memcpy ▁( ▁buf ▁, ▁s ▁-> ▁buf _ ptr ▁, ▁len ▁) ▁; ▁buf ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁+= ▁len ▁; ▁size ▁-= ▁len ▁; ▁} ▁} ▁if ▁( ▁size 1 ▁== ▁size ▁) ▁{ ▁if ▁( ▁s ▁-> ▁error ▁) ▁return ▁s ▁-> ▁error ▁; ▁if ▁( ▁avio _ fe of ▁( ▁s ▁) ▁) ▁return ▁AVERROR _ EOF ▁; ▁} ▁return ▁size 1 ▁- ▁size ▁; ▁}	0
▁static ▁void ▁rv 34_ pred _ mv _ rv 3 ▁( ▁R V 34 Dec Context ▁* ▁r ▁, ▁int ▁block _ type ▁, ▁int ▁dir ▁) ▁{ ▁Mpeg Enc Context ▁* ▁s ▁= ▁& ▁r ▁-> ▁s ▁; ▁int ▁mv _ pos ▁= ▁s ▁-> ▁mb _ x ▁* ▁2 ▁+ ▁s ▁-> ▁mb _ y ▁* ▁2 ▁* ▁s ▁-> ▁b 8_ stride ▁; ▁int ▁A ▁[ ▁2 ▁] ▁= ▁{ ▁0 ▁} ▁, ▁B ▁[ ▁2 ▁] ▁, ▁C ▁[ ▁2 ▁] ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁; ▁int ▁mx ▁, ▁my ▁; ▁int ▁* ▁avail ▁= ▁r ▁-> ▁avail _ cache ▁+ ▁avail _ indexes ▁[ ▁0 ▁] ▁; ▁if ▁( ▁avail ▁[ ▁-1 ▁] ▁) ▁{ ▁A ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁A ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁if ▁( ▁avail ▁[ ▁-4 ▁] ▁) ▁{ ▁B ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁s ▁-> ▁b 8_ stride ▁] ▁[ ▁0 ▁] ▁; ▁B ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁s ▁-> ▁b 8_ stride ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁B ▁[ ▁0 ▁] ▁= ▁A ▁[ ▁0 ▁] ▁; ▁B ▁[ ▁1 ▁] ▁= ▁A ▁[ ▁1 ▁] ▁; ▁} ▁if ▁( ▁! ▁avail ▁[ ▁-4 ▁+ ▁2 ▁] ▁) ▁{ ▁if ▁( ▁avail ▁[ ▁-4 ▁] ▁&& ▁( ▁avail ▁[ ▁-1 ▁] ▁) ▁) ▁{ ▁C ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁s ▁-> ▁b 8_ stride ▁- ▁1 ▁] ▁[ ▁0 ▁] ▁; ▁C ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁s ▁-> ▁b 8_ stride ▁- ▁1 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁C ▁[ ▁0 ▁] ▁= ▁A ▁[ ▁0 ▁] ▁; ▁C ▁[ ▁1 ▁] ▁= ▁A ▁[ ▁1 ▁] ▁; ▁} ▁} ▁else ▁{ ▁C ▁[ ▁0 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁s ▁-> ▁b 8_ stride ▁+ ▁2 ▁] ▁[ ▁0 ▁] ▁; ▁C ▁[ ▁1 ▁] ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁0 ▁] ▁[ ▁mv _ pos ▁- ▁s ▁-> ▁b 8_ stride ▁+ ▁2 ▁] ▁[ ▁1 ▁] ▁; ▁} ▁mx ▁= ▁mid _ pred ▁( ▁A ▁[ ▁0 ▁] ▁, ▁B ▁[ ▁0 ▁] ▁, ▁C ▁[ ▁0 ▁] ▁) ▁; ▁my ▁= ▁mid _ pred ▁( ▁A ▁[ ▁1 ▁] ▁, ▁B ▁[ ▁1 ▁] ▁, ▁C ▁[ ▁1 ▁] ▁) ▁; ▁mx ▁+= ▁r ▁-> ▁dm v ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁my ▁+= ▁r ▁-> ▁dm v ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁2 ▁; ▁k ▁++ ▁) ▁{ ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁k ▁] ▁[ ▁mv _ pos ▁+ ▁i ▁+ ▁j ▁* ▁s ▁-> ▁b 8_ stride ▁] ▁[ ▁0 ▁] ▁= ▁mx ▁; ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁motion _ val ▁[ ▁k ▁] ▁[ ▁mv _ pos ▁+ ▁i ▁+ ▁j ▁* ▁s ▁-> ▁b 8_ stride ▁] ▁[ ▁1 ▁] ▁= ▁my ▁; ▁} ▁} ▁} ▁}	0
▁void ▁OPENSSL _ L H _ node _ usage _ stats _ bio ▁( ▁const ▁OPENSSL _ L HASH ▁* ▁lh ▁, ▁BIO ▁* ▁out ▁) ▁{ ▁OPENSSL _ L H _ NODE ▁* ▁n ▁; ▁unsigned ▁long ▁num ▁; ▁unsigned ▁int ▁i ▁; ▁unsigned ▁long ▁total ▁= ▁0 ▁, ▁n _ used ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁lh ▁-> ▁num _ nodes ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁n ▁= ▁lh ▁-> ▁b ▁[ ▁i ▁] ▁, ▁num ▁= ▁0 ▁; ▁n ▁!= ▁NULL ▁; ▁n ▁= ▁n ▁-> ▁next ▁) ▁num ▁++ ▁; ▁if ▁( ▁num ▁!= ▁0 ▁) ▁{ ▁n _ used ▁++ ▁; ▁total ▁+= ▁num ▁; ▁} ▁} ▁BIO _ printf ▁( ▁out ▁, ▁"% l un odes used out of % u \ n " ▁, ▁n _ used ▁, ▁lh ▁-> ▁num _ nodes ▁) ▁; ▁BIO _ printf ▁( ▁out ▁, ▁"% lu items \ n " ▁, ▁total ▁) ▁; ▁if ▁( ▁n _ used ▁== ▁0 ▁) ▁return ▁; ▁BIO _ printf ▁( ▁out ▁, ▁" load % d . %02 d actual load % d . %02 d \ n " ▁, ▁( ▁int ▁) ▁( ▁total ▁/ ▁lh ▁-> ▁num _ nodes ▁) ▁, ▁( ▁int ▁) ▁( ▁( ▁total ▁% ▁lh ▁-> ▁num _ nodes ▁) ▁* ▁100 ▁/ ▁lh ▁-> ▁num _ nodes ▁) ▁, ▁( ▁int ▁) ▁( ▁total ▁/ ▁n _ used ▁) ▁, ▁( ▁int ▁) ▁( ▁( ▁total ▁% ▁n _ used ▁) ▁* ▁100 ▁/ ▁n _ used ▁) ▁) ▁; ▁}	1
▁static ▁void ▁vp 8_ idct _ add _ c ▁( ▁uint 8_ t ▁* ▁dst ▁, ▁DCT ELEM ▁block ▁[ ▁16 ▁] ▁, ▁ptrdiff _ t ▁stride ▁) ▁{ ▁int ▁i ▁, ▁t 0 ▁, ▁t 1 ▁, ▁t 2 ▁, ▁t 3 ▁; ▁DCT ELEM ▁tmp ▁[ ▁16 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁t 0 ▁= ▁block ▁[ ▁0 ▁* ▁4 ▁+ ▁i ▁] ▁+ ▁block ▁[ ▁2 ▁* ▁4 ▁+ ▁i ▁] ▁; ▁t 1 ▁= ▁block ▁[ ▁0 ▁* ▁4 ▁+ ▁i ▁] ▁- ▁block ▁[ ▁2 ▁* ▁4 ▁+ ▁i ▁] ▁; ▁t 2 ▁= ▁MUL _ 354 68 ▁( ▁block ▁[ ▁1 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁- ▁MUL _200 91 ▁( ▁block ▁[ ▁3 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁; ▁t 3 ▁= ▁MUL _200 91 ▁( ▁block ▁[ ▁1 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁+ ▁MUL _ 354 68 ▁( ▁block ▁[ ▁3 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁; ▁block ▁[ ▁0 ▁* ▁4 ▁+ ▁i ▁] ▁= ▁0 ▁; ▁block ▁[ ▁1 ▁* ▁4 ▁+ ▁i ▁] ▁= ▁0 ▁; ▁block ▁[ ▁2 ▁* ▁4 ▁+ ▁i ▁] ▁= ▁0 ▁; ▁block ▁[ ▁3 ▁* ▁4 ▁+ ▁i ▁] ▁= ▁0 ▁; ▁tmp ▁[ ▁i ▁* ▁4 ▁+ ▁0 ▁] ▁= ▁t 0 ▁+ ▁t 3 ▁; ▁tmp ▁[ ▁i ▁* ▁4 ▁+ ▁1 ▁] ▁= ▁t 1 ▁+ ▁t 2 ▁; ▁tmp ▁[ ▁i ▁* ▁4 ▁+ ▁2 ▁] ▁= ▁t 1 ▁- ▁t 2 ▁; ▁tmp ▁[ ▁i ▁* ▁4 ▁+ ▁3 ▁] ▁= ▁t 0 ▁- ▁t 3 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁t 0 ▁= ▁tmp ▁[ ▁0 ▁* ▁4 ▁+ ▁i ▁] ▁+ ▁tmp ▁[ ▁2 ▁* ▁4 ▁+ ▁i ▁] ▁; ▁t 1 ▁= ▁tmp ▁[ ▁0 ▁* ▁4 ▁+ ▁i ▁] ▁- ▁tmp ▁[ ▁2 ▁* ▁4 ▁+ ▁i ▁] ▁; ▁t 2 ▁= ▁MUL _ 354 68 ▁( ▁tmp ▁[ ▁1 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁- ▁MUL _200 91 ▁( ▁tmp ▁[ ▁3 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁; ▁t 3 ▁= ▁MUL _200 91 ▁( ▁tmp ▁[ ▁1 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁+ ▁MUL _ 354 68 ▁( ▁tmp ▁[ ▁3 ▁* ▁4 ▁+ ▁i ▁] ▁) ▁; ▁dst ▁[ ▁0 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dst ▁[ ▁0 ▁] ▁+ ▁( ▁( ▁t 0 ▁+ ▁t 3 ▁+ ▁4 ▁) ▁>> ▁3 ▁) ▁) ▁; ▁dst ▁[ ▁1 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dst ▁[ ▁1 ▁] ▁+ ▁( ▁( ▁t 1 ▁+ ▁t 2 ▁+ ▁4 ▁) ▁>> ▁3 ▁) ▁) ▁; ▁dst ▁[ ▁2 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dst ▁[ ▁2 ▁] ▁+ ▁( ▁( ▁t 1 ▁- ▁t 2 ▁+ ▁4 ▁) ▁>> ▁3 ▁) ▁) ▁; ▁dst ▁[ ▁3 ▁] ▁= ▁av _ clip _ uint 8 ▁( ▁dst ▁[ ▁3 ▁] ▁+ ▁( ▁( ▁t 0 ▁- ▁t 3 ▁+ ▁4 ▁) ▁>> ▁3 ▁) ▁) ▁; ▁dst ▁+= ▁stride ▁; ▁} ▁}	0
▁static ▁void ▁chroma ▁( ▁Wave form Context ▁* ▁s ▁, ▁AVFrame ▁* ▁in ▁, ▁AVFrame ▁* ▁out ▁, ▁int ▁component ▁, ▁int ▁intensity ▁, ▁int ▁offset ▁, ▁int ▁column ▁) ▁{ ▁const ▁int ▁plane ▁= ▁s ▁-> ▁desc ▁-> ▁comp ▁[ ▁component ▁] ▁. ▁plane ▁; ▁const ▁int ▁mirror ▁= ▁s ▁-> ▁mirror ▁; ▁const ▁int ▁c 0_ lines ize ▁= ▁in ▁-> ▁linesize ▁[ ▁( ▁plane ▁+ ▁1 ▁) ▁% ▁s ▁-> ▁n comp ▁] ▁; ▁const ▁int ▁c 1_ lines ize ▁= ▁in ▁-> ▁linesize ▁[ ▁( ▁plane ▁+ ▁2 ▁) ▁% ▁s ▁-> ▁n comp ▁] ▁; ▁const ▁int ▁dst _ lines ize ▁= ▁out ▁-> ▁linesize ▁[ ▁plane ▁] ▁; ▁const ▁int ▁max ▁= ▁255 ▁- ▁intensity ▁; ▁const ▁int ▁src _ h ▁= ▁in ▁-> ▁height ▁; ▁const ▁int ▁src _ w ▁= ▁in ▁-> ▁width ▁; ▁int ▁x ▁, ▁y ▁; ▁if ▁( ▁column ▁) ▁{ ▁const ▁int ▁dst _ signed _ lines ize ▁= ▁dst _ lines ize ▁* ▁( ▁mirror ▁== ▁1 ▁? ▁-1 ▁: ▁1 ▁) ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁src _ w ▁; ▁x ▁++ ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁c 0_ data ▁= ▁in ▁-> ▁data ▁[ ▁( ▁plane ▁+ ▁1 ▁) ▁% ▁s ▁-> ▁n comp ▁] ▁; ▁const ▁uint 8_ t ▁* ▁c 1_ data ▁= ▁in ▁-> ▁data ▁[ ▁( ▁plane ▁+ ▁2 ▁) ▁% ▁s ▁-> ▁n comp ▁] ▁; ▁uint 8_ t ▁* ▁dst _ data ▁= ▁out ▁-> ▁data ▁[ ▁plane ▁] ▁+ ▁offset ▁* ▁dst _ lines ize ▁; ▁uint 8_ t ▁* ▁const ▁dst _ bottom _ line ▁= ▁dst _ data ▁+ ▁dst _ lines ize ▁* ▁( ▁s ▁-> ▁size ▁- ▁1 ▁) ▁; ▁uint 8_ t ▁* ▁const ▁dst _ line ▁= ▁( ▁mirror ▁? ▁dst _ bottom _ line ▁: ▁dst _ data ▁) ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁dst _ line ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁src _ h ▁; ▁y ▁++ ▁) ▁{ ▁const ▁int ▁sum ▁= ▁FF ABS ▁( ▁c 0_ data ▁[ ▁x ▁] ▁- ▁128 ▁) ▁+ ▁FF ABS ▁( ▁c 1_ data ▁[ ▁x ▁] ▁- ▁128 ▁) ▁; ▁uint 8_ t ▁* ▁target ▁; ▁target ▁= ▁dst ▁+ ▁x ▁+ ▁dst _ signed _ lines ize ▁* ▁( ▁256 ▁- ▁sum ▁) ▁; ▁update ▁( ▁target ▁, ▁max ▁, ▁intensity ▁) ▁; ▁target ▁= ▁dst ▁+ ▁x ▁+ ▁dst _ signed _ lines ize ▁* ▁( ▁255 ▁+ ▁sum ▁) ▁; ▁update ▁( ▁target ▁, ▁max ▁, ▁intensity ▁) ▁; ▁c 0_ data ▁+= ▁c 0_ lines ize ▁; ▁c 1_ data ▁+= ▁c 1_ lines ize ▁; ▁dst _ data ▁+= ▁dst _ lines ize ▁; ▁} ▁} ▁} ▁else ▁{ ▁const ▁uint 8_ t ▁* ▁c 0_ data ▁= ▁in ▁-> ▁data ▁[ ▁( ▁plane ▁+ ▁1 ▁) ▁% ▁s ▁-> ▁n comp ▁] ▁; ▁const ▁uint 8_ t ▁* ▁c 1_ data ▁= ▁in ▁-> ▁data ▁[ ▁( ▁plane ▁+ ▁2 ▁) ▁% ▁s ▁-> ▁n comp ▁] ▁; ▁uint 8_ t ▁* ▁dst _ data ▁= ▁out ▁-> ▁data ▁[ ▁plane ▁] ▁+ ▁offset ▁; ▁if ▁( ▁mirror ▁) ▁dst _ data ▁+= ▁s ▁-> ▁size ▁- ▁1 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁src _ h ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁src _ w ▁; ▁x ▁++ ▁) ▁{ ▁const ▁int ▁sum ▁= ▁FF ABS ▁( ▁c 0_ data ▁[ ▁x ▁] ▁- ▁128 ▁) ▁+ ▁FF ABS ▁( ▁c 1_ data ▁[ ▁x ▁] ▁- ▁128 ▁) ▁; ▁uint 8_ t ▁* ▁target ▁; ▁if ▁( ▁mirror ▁) ▁{ ▁target ▁= ▁dst _ data ▁- ▁( ▁256 ▁- ▁sum ▁) ▁; ▁update ▁( ▁target ▁, ▁max ▁, ▁intensity ▁) ▁; ▁target ▁= ▁dst _ data ▁- ▁( ▁255 ▁+ ▁sum ▁) ▁; ▁update ▁( ▁target ▁, ▁max ▁, ▁intensity ▁) ▁; ▁} ▁else ▁{ ▁target ▁= ▁dst _ data ▁+ ▁( ▁256 ▁- ▁sum ▁) ▁; ▁update ▁( ▁target ▁, ▁max ▁, ▁intensity ▁) ▁; ▁target ▁= ▁dst _ data ▁+ ▁( ▁255 ▁+ ▁sum ▁) ▁; ▁update ▁( ▁target ▁, ▁max ▁, ▁intensity ▁) ▁; ▁} ▁} ▁c 0_ data ▁+= ▁c 0_ lines ize ▁; ▁c 1_ data ▁+= ▁c 1_ lines ize ▁; ▁dst _ data ▁+= ▁dst _ lines ize ▁; ▁} ▁} ▁envelope ▁( ▁s ▁, ▁out ▁, ▁plane ▁, ▁( ▁plane ▁+ ▁0 ▁) ▁% ▁s ▁-> ▁n comp ▁) ▁; ▁}	0
▁int ▁test _ gf 2 m _ mod _ mul ▁( ▁BIO ▁* ▁bp ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁BIGNUM ▁* ▁a ▁, ▁* ▁b ▁[ ▁2 ▁] ▁, ▁* ▁c ▁, ▁* ▁d ▁, ▁* ▁e ▁, ▁* ▁f ▁, ▁* ▁g ▁, ▁* ▁h ▁; ▁int ▁i ▁, ▁j ▁, ▁ret ▁= ▁0 ▁; ▁int ▁p 0 ▁[ ▁] ▁= ▁{ ▁16 3 ▁, ▁7 ▁, ▁6 ▁, ▁3 ▁, ▁0 ▁, ▁-1 ▁} ▁; ▁int ▁p 1 ▁[ ▁] ▁= ▁{ ▁19 3 ▁, ▁15 ▁, ▁0 ▁, ▁-1 ▁} ▁; ▁a ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁[ ▁0 ▁] ▁= ▁BN _ new ▁( ▁) ▁; ▁b ▁[ ▁1 ▁] ▁= ▁BN _ new ▁( ▁) ▁; ▁c ▁= ▁BN _ new ▁( ▁) ▁; ▁d ▁= ▁BN _ new ▁( ▁) ▁; ▁e ▁= ▁BN _ new ▁( ▁) ▁; ▁f ▁= ▁BN _ new ▁( ▁) ▁; ▁g ▁= ▁BN _ new ▁( ▁) ▁; ▁h ▁= ▁BN _ new ▁( ▁) ▁; ▁BN _ GF 2 m _ arr 2 poly ▁( ▁p 0 ▁, ▁b ▁[ ▁0 ▁] ▁) ▁; ▁BN _ GF 2 m _ arr 2 poly ▁( ▁p 1 ▁, ▁b ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num 0 ▁; ▁i ▁++ ▁) ▁{ ▁BN _ bn test _ rand ▁( ▁a ▁, ▁1024 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁BN _ bn test _ rand ▁( ▁c ▁, ▁1024 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁BN _ bn test _ rand ▁( ▁d ▁, ▁1024 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁BN _ GF 2 m _ mod _ mul ▁( ▁e ▁, ▁a ▁, ▁c ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁# if ▁0 ▁if ▁( ▁bp ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁results ▁) ▁{ ▁BN _ print ▁( ▁bp ▁, ▁a ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"*" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁c ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"%" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁b ▁[ ▁j ▁] ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"-" ▁) ▁; ▁BN _ print ▁( ▁bp ▁, ▁e ▁) ▁; ▁BIO _ puts ▁( ▁bp ▁, ▁"\ n " ▁) ▁; ▁} ▁} ▁# endif ▁BN _ GF 2 m _ add ▁( ▁f ▁, ▁a ▁, ▁d ▁) ▁; ▁BN _ GF 2 m _ mod _ mul ▁( ▁g ▁, ▁f ▁, ▁c ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁BN _ GF 2 m _ mod _ mul ▁( ▁h ▁, ▁d ▁, ▁c ▁, ▁b ▁[ ▁j ▁] ▁, ▁ctx ▁) ▁; ▁BN _ GF 2 m _ add ▁( ▁f ▁, ▁e ▁, ▁g ▁) ▁; ▁BN _ GF 2 m _ add ▁( ▁f ▁, ▁f ▁, ▁h ▁) ▁; ▁if ▁( ▁! ▁BN _ is _ zero ▁( ▁f ▁) ▁) ▁{ ▁fprintf ▁( ▁stderr ▁, ▁" GF (2 ^ m ) mod ular multip lication test failed !\ n " ▁) ▁; ▁goto ▁err ▁; ▁} ▁} ▁} ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ free ▁( ▁a ▁) ▁; ▁BN _ free ▁( ▁b ▁[ ▁0 ▁] ▁) ▁; ▁BN _ free ▁( ▁b ▁[ ▁1 ▁] ▁) ▁; ▁BN _ free ▁( ▁c ▁) ▁; ▁BN _ free ▁( ▁d ▁) ▁; ▁BN _ free ▁( ▁e ▁) ▁; ▁BN _ free ▁( ▁f ▁) ▁; ▁BN _ free ▁( ▁g ▁) ▁; ▁BN _ free ▁( ▁h ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁DECLARE read Func ▁( ▁read Separ ate Tiles Into Buffer ▁) ▁{ ▁int ▁status ▁= ▁1 ▁; ▁uint 32 ▁image w ▁= ▁TIFF Raster Scan line Size ▁( ▁in ▁) ▁; ▁uint 32 ▁tile w ▁= ▁TIFF Tile Row Size ▁( ▁in ▁) ▁; ▁int ▁is k ew ▁; ▁tsize _ t ▁tile size ▁= ▁TIFF Tile Size ▁( ▁in ▁) ▁; ▁t data _ t ▁tile buf ▁; ▁uint 8 ▁* ▁bufp ▁= ▁( ▁uint 8 ▁* ▁) ▁buf ▁; ▁uint 32 ▁tw ▁, ▁tl ▁; ▁uint 32 ▁row ▁; ▁uint 16 ▁bps ▁= ▁0 ▁, ▁bytes _ per _ sample ▁; ▁if ▁( ▁s pp ▁> ▁( ▁INT _ MAX ▁/ ▁tile w ▁) ▁) ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , cannot handle that m uch samples per til er ow ( Tile Width * Samples / Pixel )" ▁) ▁; ▁return ▁0 ▁; ▁} ▁is k ew ▁= ▁image w ▁- ▁tile w ▁* ▁s pp ▁; ▁tile buf ▁= ▁_ TIFF malloc ▁( ▁tile size ▁) ▁; ▁if ▁( ▁tile buf ▁== ▁0 ▁) ▁return ▁0 ▁; ▁_ TIFF memset ▁( ▁tile buf ▁, ▁0 ▁, ▁tile size ▁) ▁; ▁( ▁void ▁) ▁TIFF Get Field ▁( ▁in ▁, ▁TIFF TAG _ TILE WIDTH ▁, ▁& ▁tw ▁) ▁; ▁( ▁void ▁) ▁TIFF Get Field ▁( ▁in ▁, ▁TIFF TAG _ TILE LENGTH ▁, ▁& ▁tl ▁) ▁; ▁( ▁void ▁) ▁TIFF Get Field ▁( ▁in ▁, ▁TIFF TAG _ BIT SP ER SAMPLE ▁, ▁& ▁bps ▁) ▁; ▁if ▁( ▁bps ▁== ▁0 ▁) ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , cannot read Bits PerSample " ▁) ▁; ▁status ▁= ▁0 ▁; ▁goto ▁done ▁; ▁} ▁if ▁( ▁( ▁bps ▁% ▁8 ▁) ▁!= ▁0 ▁) ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , cannot handle Bits PerSample th atis not am ultiple of 8" ▁) ▁; ▁status ▁= ▁0 ▁; ▁goto ▁done ▁; ▁} ▁bytes _ per _ sample ▁= ▁bps ▁/ ▁8 ▁; ▁for ▁( ▁row ▁= ▁0 ▁; ▁row ▁< ▁image length ▁; ▁row ▁+= ▁tl ▁) ▁{ ▁uint 32 ▁nrow ▁= ▁( ▁row ▁+ ▁tl ▁> ▁image length ▁) ▁? ▁image length ▁- ▁row ▁: ▁tl ▁; ▁uint 32 ▁col b ▁= ▁0 ▁; ▁uint 32 ▁col ▁; ▁for ▁( ▁col ▁= ▁0 ▁; ▁col ▁< ▁image width ▁; ▁col ▁+= ▁tw ▁) ▁{ ▁ts ample _ t ▁s ▁; ▁for ▁( ▁s ▁= ▁0 ▁; ▁s ▁< ▁s pp ▁; ▁s ▁++ ▁) ▁{ ▁if ▁( ▁TIFF Read Tile ▁( ▁in ▁, ▁tile buf ▁, ▁col ▁, ▁row ▁, ▁0 ▁, ▁s ▁) ▁< ▁0 ▁&& ▁! ▁ignore ▁) ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , can ' t read tile at % lu % lu ," ▁" sample % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁col ▁, ▁( ▁unsigned ▁long ▁) ▁row ▁, ▁( ▁unsigned ▁long ▁) ▁s ▁) ▁; ▁status ▁= ▁0 ▁; ▁goto ▁done ▁; ▁} ▁if ▁( ▁col b ▁+ ▁tile w ▁* ▁s pp ▁> ▁image w ▁) ▁{ ▁uint 32 ▁width ▁= ▁image w ▁- ▁col b ▁; ▁int ▁o skew ▁= ▁tile w ▁* ▁s pp ▁- ▁width ▁; ▁cp Separ ate Buf To Cont ig Buf ▁( ▁bufp ▁+ ▁col b ▁+ ▁s ▁* ▁bytes _ per _ sample ▁, ▁tile buf ▁, ▁nrow ▁, ▁width ▁/ ▁( ▁s pp ▁* ▁bytes _ per _ sample ▁) ▁, ▁o skew ▁+ ▁is k ew ▁, ▁o skew ▁/ ▁s pp ▁, ▁s pp ▁, ▁bytes _ per _ sample ▁) ▁; ▁} ▁else ▁cp Separ ate Buf To Cont ig Buf ▁( ▁bufp ▁+ ▁col b ▁+ ▁s ▁* ▁bytes _ per _ sample ▁, ▁tile buf ▁, ▁nrow ▁, ▁tw ▁, ▁is k ew ▁, ▁0 ▁, ▁s pp ▁, ▁bytes _ per _ sample ▁) ▁; ▁} ▁col b ▁+= ▁tile w ▁* ▁s pp ▁; ▁} ▁bufp ▁+= ▁image w ▁* ▁nrow ▁; ▁} ▁done ▁: ▁_ TIFF free ▁( ▁tile buf ▁) ▁; ▁return ▁status ▁; ▁}	1
▁void ▁ff _ mq c _ init _ contexts ▁( ▁M qc State ▁* ▁mqc ▁) ▁{ ▁int ▁i ▁; ▁memset ▁( ▁mqc ▁-> ▁cx _ states ▁, ▁0 ▁, ▁sizeof ▁( ▁mqc ▁-> ▁cx _ states ▁) ▁) ▁; ▁mqc ▁-> ▁cx _ states ▁[ ▁MQ C _ CX _ UNI ▁] ▁= ▁2 ▁* ▁46 ▁; ▁mqc ▁-> ▁cx _ states ▁[ ▁MQ C _ CX _ RL ▁] ▁= ▁2 ▁* ▁3 ▁; ▁mqc ▁-> ▁cx _ states ▁[ ▁0 ▁] ▁= ▁2 ▁* ▁4 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁47 ▁; ▁i ▁++ ▁) ▁{ ▁ff _ mq c _ qe ▁[ ▁2 ▁* ▁i ▁] ▁= ▁ff _ mq c _ qe ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁= ▁cx _ states ▁[ ▁i ▁] ▁. ▁qe ▁; ▁ff _ mq c _ nl ps ▁[ ▁2 ▁* ▁i ▁] ▁= ▁2 ▁* ▁cx _ states ▁[ ▁i ▁] ▁. ▁nl ps ▁+ ▁cx _ states ▁[ ▁i ▁] ▁. ▁sw ▁; ▁ff _ mq c _ nl ps ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁= ▁2 ▁* ▁cx _ states ▁[ ▁i ▁] ▁. ▁nl ps ▁+ ▁1 ▁- ▁cx _ states ▁[ ▁i ▁] ▁. ▁sw ▁; ▁ff _ mq c _ n mps ▁[ ▁2 ▁* ▁i ▁] ▁= ▁2 ▁* ▁cx _ states ▁[ ▁i ▁] ▁. ▁n mps ▁; ▁ff _ mq c _ n mps ▁[ ▁2 ▁* ▁i ▁+ ▁1 ▁] ▁= ▁2 ▁* ▁cx _ states ▁[ ▁i ▁] ▁. ▁n mps ▁+ ▁1 ▁; ▁} ▁}	1
▁void ▁sk _ pop _ free ▁( ▁_ STACK ▁* ▁st ▁, ▁void ▁( ▁* ▁func ▁) ▁( ▁void ▁* ▁) ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁st ▁== ▁NULL ▁) ▁return ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁st ▁-> ▁num ▁; ▁i ▁++ ▁) ▁if ▁( ▁st ▁-> ▁data ▁[ ▁i ▁] ▁!= ▁NULL ▁) ▁func ▁( ▁st ▁-> ▁data ▁[ ▁i ▁] ▁) ▁; ▁sk _ free ▁( ▁st ▁) ▁; ▁}	1
▁int ▁tls 13_ h kdf _ expand ▁( ▁SSL ▁* ▁s ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁const ▁unsigned ▁char ▁* ▁secret ▁, ▁const ▁unsigned ▁char ▁* ▁label ▁, ▁size _ t ▁label len ▁, ▁const ▁unsigned ▁char ▁* ▁data ▁, ▁size _ t ▁datalen ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁size _ t ▁outlen ▁, ▁int ▁fatal ▁) ▁{ ▁static ▁const ▁unsigned ▁char ▁label _ prefix ▁[ ▁] ▁= ▁" tls 13" ▁; ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new _ id ▁( ▁EVP _ PKEY _ HK DF ▁, ▁NULL ▁) ▁; ▁int ▁ret ▁; ▁size _ t ▁hk df label len ▁; ▁size _ t ▁hash len ▁; ▁unsigned ▁char ▁hk df label ▁[ ▁sizeof ▁( ▁uint 16_ t ▁) ▁+ ▁sizeof ▁( ▁uint 8_ t ▁) ▁+ ▁+ ▁( ▁sizeof ▁( ▁label _ prefix ▁) ▁- ▁1 ▁) ▁+ ▁TLS 13_ MAX _ LABEL _ LEN ▁+ ▁1 ▁+ ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁W PACKET ▁pkt ▁; ▁if ▁( ▁pctx ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁if ▁( ▁label len ▁> ▁TLS 13_ MAX _ LABEL _ LEN ▁) ▁{ ▁if ▁( ▁fatal ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS 13_ HK DF _ EXPAND ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁} ▁else ▁{ ▁SSL err ▁( ▁SSL _ F _ TLS 13_ HK DF _ EXPAND ▁, ▁SSL _ R _ TLS _ ILLEGAL _ EXP OR TER _ LABEL ▁) ▁; ▁} ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁0 ▁; ▁} ▁hash len ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁if ▁( ▁! ▁W PACKET _ init _ static _ len ▁( ▁& ▁pkt ▁, ▁hk df label ▁, ▁sizeof ▁( ▁hk df label ▁) ▁, ▁0 ▁) ▁|| ▁! ▁W PACKET _ put _ bytes _ u 16 ▁( ▁& ▁pkt ▁, ▁outlen ▁) ▁|| ▁! ▁W PACKET _ start _ sub _ packet _ u 8 ▁( ▁& ▁pkt ▁) ▁|| ▁! ▁W PACKET _ memcpy ▁( ▁& ▁pkt ▁, ▁label _ prefix ▁, ▁sizeof ▁( ▁label _ prefix ▁) ▁- ▁1 ▁) ▁|| ▁! ▁W PACKET _ memcpy ▁( ▁& ▁pkt ▁, ▁label ▁, ▁label len ▁) ▁|| ▁! ▁W PACKET _ close ▁( ▁& ▁pkt ▁) ▁|| ▁! ▁W PACKET _ sub _ memcpy _ u 8 ▁( ▁& ▁pkt ▁, ▁data ▁, ▁( ▁data ▁== ▁NULL ▁) ▁? ▁0 ▁: ▁datalen ▁) ▁|| ▁! ▁W PACKET _ get _ total _ written ▁( ▁& ▁pkt ▁, ▁& ▁hk df label len ▁) ▁|| ▁! ▁W PACKET _ finish ▁( ▁& ▁pkt ▁) ▁) ▁{ ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁W PACKET _ cleanup ▁( ▁& ▁pkt ▁) ▁; ▁if ▁( ▁fatal ▁) ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS 13_ HK DF _ EXPAND ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁else ▁SSL err ▁( ▁SSL _ F _ TLS 13_ HK DF _ EXPAND ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁0 ▁; ▁} ▁ret ▁= ▁EVP _ PKEY _ der ive _ init ▁( ▁pctx ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ h kdf _ mode ▁( ▁pctx ▁, ▁EVP _ PKEY _ HK DEF _ MODE _ EXPAND _ ONLY ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set _ h kdf _ md ▁( ▁pctx ▁, ▁md ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ set 1_ h kdf _ key ▁( ▁pctx ▁, ▁secret ▁, ▁hash len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ CTX _ add 1_ h kdf _ info ▁( ▁pctx ▁, ▁hk df label ▁, ▁hk df label len ▁) ▁<= ▁0 ▁|| ▁EVP _ PKEY _ der ive ▁( ▁pctx ▁, ▁out ▁, ▁& ▁outlen ▁) ▁<= ▁0 ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁if ▁( ▁ret ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁fatal ▁) ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ TLS 13_ HK DF _ EXPAND ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁else ▁SSL err ▁( ▁SSL _ F _ TLS 13_ HK DF _ EXPAND ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁} ▁return ▁ret ▁== ▁0 ▁; ▁}	0
▁static ▁int ▁mat ro sk a _ find _ track _ by _ num ▁( ▁Mat ro sk a Demux Context ▁* ▁mat ro sk a ▁, ▁int ▁num ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁mat ro sk a ▁-> ▁num _ tr acks ▁; ▁i ▁++ ▁) ▁if ▁( ▁mat ro sk a ▁-> ▁tracks ▁[ ▁i ▁] ▁-> ▁num ▁== ▁num ▁) ▁return ▁i ▁; ▁return ▁-1 ▁; ▁}	1
▁static ▁int ▁allocate _ buffers ▁( ▁Short en Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁, ▁chan ▁; ▁int ▁* ▁coeffs ▁; ▁void ▁* ▁tmp _ ptr ▁; ▁for ▁( ▁chan ▁= ▁0 ▁; ▁chan ▁< ▁s ▁-> ▁channels ▁; ▁chan ▁++ ▁) ▁{ ▁if ▁( ▁FF MAX ▁( ▁1 ▁, ▁s ▁-> ▁n mean ▁) ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁int 32_ t ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" n me ant ool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁s ▁-> ▁blocksize ▁+ ▁s ▁-> ▁n wrap ▁>= ▁UINT _ MAX ▁/ ▁sizeof ▁( ▁int 32_ t ▁) ▁|| ▁s ▁-> ▁blocksize ▁+ ▁s ▁-> ▁n wrap ▁<= ▁( ▁unsigned ▁) ▁s ▁-> ▁n wrap ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" s -> blocksize + s -> nw ra pt ool arge \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁tmp _ ptr ▁= ▁av _ realloc ▁( ▁s ▁-> ▁offset ▁[ ▁chan ▁] ▁, ▁sizeof ▁( ▁int 32_ t ▁) ▁* ▁FF MAX ▁( ▁1 ▁, ▁s ▁-> ▁n mean ▁) ▁) ▁; ▁if ▁( ▁! ▁tmp _ ptr ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁offset ▁[ ▁chan ▁] ▁= ▁tmp _ ptr ▁; ▁tmp _ ptr ▁= ▁av _ realloc ▁( ▁s ▁-> ▁decoded _ base ▁[ ▁chan ▁] ▁, ▁( ▁s ▁-> ▁blocksize ▁+ ▁s ▁-> ▁n wrap ▁) ▁* ▁sizeof ▁( ▁s ▁-> ▁decoded _ base ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁! ▁tmp _ ptr ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁decoded _ base ▁[ ▁chan ▁] ▁= ▁tmp _ ptr ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁n wrap ▁; ▁i ▁++ ▁) ▁s ▁-> ▁decoded _ base ▁[ ▁chan ▁] ▁[ ▁i ▁] ▁= ▁0 ▁; ▁s ▁-> ▁decoded ▁[ ▁chan ▁] ▁= ▁s ▁-> ▁decoded _ base ▁[ ▁chan ▁] ▁+ ▁s ▁-> ▁n wrap ▁; ▁} ▁coeffs ▁= ▁av _ realloc ▁( ▁s ▁-> ▁coeffs ▁, ▁s ▁-> ▁n wrap ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁coeffs ▁) ▁) ▁; ▁if ▁( ▁! ▁coeffs ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁coeffs ▁= ▁coeffs ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁ct _ base 64_ decode ▁( ▁const ▁char ▁* ▁in ▁, ▁unsigned ▁char ▁* ▁* ▁out ▁) ▁{ ▁size _ t ▁inlen ▁= ▁strlen ▁( ▁in ▁) ▁; ▁int ▁outlen ▁; ▁unsigned ▁char ▁* ▁outbuf ▁= ▁NULL ▁; ▁if ▁( ▁inlen ▁== ▁0 ▁) ▁{ ▁* ▁out ▁= ▁NULL ▁; ▁return ▁0 ▁; ▁} ▁outlen ▁= ▁( ▁inlen ▁/ ▁4 ▁) ▁* ▁3 ▁; ▁outbuf ▁= ▁OPENSSL _ malloc ▁( ▁outlen ▁) ▁; ▁if ▁( ▁outbuf ▁== ▁NULL ▁) ▁{ ▁CT err ▁( ▁CT _ F _ CT _ BASE 64_ DECODE ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁outlen ▁= ▁EVP _ Decode Block ▁( ▁outbuf ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁in ▁, ▁inlen ▁) ▁; ▁if ▁( ▁outlen ▁< ▁0 ▁) ▁{ ▁CT err ▁( ▁CT _ F _ CT _ BASE 64_ DECODE ▁, ▁CT _ R _ BASE 64_ DECODE _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁while ▁( ▁in ▁[ ▁-- ▁inlen ▁] ▁== ▁' ▁' ▁) ▁{ ▁-- ▁outlen ▁; ▁} ▁* ▁out ▁= ▁outbuf ▁; ▁return ▁outlen ▁; ▁err ▁: ▁OPENSSL _ free ▁( ▁outbuf ▁) ▁; ▁return ▁-1 ▁; ▁}	0
▁static ▁int ▁ape _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁A PE Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁int 16_ t ▁* ▁samples ▁= ▁data ▁; ▁uint 32_ t ▁nblocks ▁; ▁int ▁i ▁; ▁int ▁block st ode code ▁, ▁out _ size ▁; ▁int ▁bytes _ used ▁; ▁av _ assert 0 ▁( ▁s ▁-> ▁samples ▁>= ▁0 ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁samples ▁) ▁{ ▁uint 32_ t ▁offset ▁; ▁void ▁* ▁tmp _ data ▁; ▁if ▁( ▁buf _ size ▁< ▁8 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Packet ist oo small \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁tmp _ data ▁= ▁av _ realloc ▁( ▁s ▁-> ▁data ▁, ▁FF ALIGN ▁( ▁buf _ size ▁, ▁4 ▁) ▁) ▁; ▁if ▁( ▁! ▁tmp _ data ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁s ▁-> ▁data ▁= ▁tmp _ data ▁; ▁s ▁-> ▁dsp ▁. ▁bswap _ buf ▁( ▁( ▁uint 32_ t ▁* ▁) ▁s ▁-> ▁data ▁, ▁( ▁const ▁uint 32_ t ▁* ▁) ▁buf ▁, ▁buf _ size ▁>> ▁2 ▁) ▁; ▁s ▁-> ▁ptr ▁= ▁s ▁-> ▁last _ ptr ▁= ▁s ▁-> ▁data ▁; ▁s ▁-> ▁data _ end ▁= ▁s ▁-> ▁data ▁+ ▁buf _ size ▁; ▁nblocks ▁= ▁bytestream _ get _ be 32 ▁( ▁& ▁s ▁-> ▁ptr ▁) ▁; ▁offset ▁= ▁bytestream _ get _ be 32 ▁( ▁& ▁s ▁-> ▁ptr ▁) ▁; ▁if ▁( ▁offset ▁> ▁3 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Incorrect offset passed \ n " ▁) ▁; ▁s ▁-> ▁data ▁= ▁NULL ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁s ▁-> ▁data _ end ▁- ▁s ▁-> ▁ptr ▁< ▁offset ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Packet ist oo small \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁ptr ▁+= ▁offset ▁; ▁if ▁( ▁! ▁nblocks ▁|| ▁nblocks ▁> ▁INT _ MAX ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid sample count :% u .\ n " ▁, ▁nblocks ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁s ▁-> ▁samples ▁= ▁nblocks ▁; ▁memset ▁( ▁s ▁-> ▁decoded 0 ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁decoded 0 ▁) ▁) ▁; ▁memset ▁( ▁s ▁-> ▁decoded 1 ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁decoded 1 ▁) ▁) ▁; ▁if ▁( ▁init _ frame _ decoder ▁( ▁s ▁) ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error reading frame header \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁if ▁( ▁! ▁s ▁-> ▁data ▁) ▁{ ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁buf _ size ▁; ▁} ▁nblocks ▁= ▁s ▁-> ▁samples ▁; ▁block st ode code ▁= ▁FF MIN ▁( ▁BLOCK S _ PER _ LOOP ▁, ▁nblocks ▁) ▁; ▁out _ size ▁= ▁block st ode code ▁* ▁avctx ▁-> ▁channels ▁* ▁av _ get _ bytes _ per _ sample ▁( ▁avctx ▁-> ▁sample _ fmt ▁) ▁; ▁if ▁( ▁* ▁data _ size ▁< ▁out _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Output buffer ist oo small .\ n " ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁s ▁-> ▁error ▁= ▁0 ▁; ▁if ▁( ▁( ▁s ▁-> ▁channels ▁== ▁1 ▁) ▁|| ▁( ▁s ▁-> ▁frame flags ▁& ▁A PE _ FRAME CODE _ PSE U DO _ STEREO ▁) ▁) ▁ape _ unpack _ mono ▁( ▁s ▁, ▁block st ode code ▁) ▁; ▁else ▁ape _ unpack _ stereo ▁( ▁s ▁, ▁block st ode code ▁) ▁; ▁e mm s _ c ▁( ▁) ▁; ▁if ▁( ▁s ▁-> ▁error ▁) ▁{ ▁s ▁-> ▁samples ▁= ▁0 ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error de coding frame \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁block st ode code ▁; ▁i ▁++ ▁) ▁{ ▁* ▁samples ▁++ ▁= ▁s ▁-> ▁decoded 0 ▁[ ▁i ▁] ▁; ▁if ▁( ▁s ▁-> ▁channels ▁== ▁2 ▁) ▁* ▁samples ▁++ ▁= ▁s ▁-> ▁decoded 1 ▁[ ▁i ▁] ▁; ▁} ▁s ▁-> ▁samples ▁-= ▁block st ode code ▁; ▁bytes _ used ▁= ▁s ▁-> ▁samples ▁? ▁s ▁-> ▁ptr ▁- ▁s ▁-> ▁last _ ptr ▁: ▁buf _ size ▁; ▁s ▁-> ▁last _ ptr ▁= ▁s ▁-> ▁ptr ▁; ▁* ▁data _ size ▁= ▁out _ size ▁; ▁return ▁bytes _ used ▁; ▁}	0
▁int ▁ff _ rm _ read _ md pr _ codec data ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁, ▁AVStream ▁* ▁st ▁, ▁RM Stream ▁* ▁rst ▁, ▁unsigned ▁int ▁codec _ data _ size ▁, ▁const ▁uint 8_ t ▁* ▁mime ▁) ▁{ ▁unsigned ▁int ▁v ▁; ▁int ▁size ▁; ▁int 64_ t ▁codec _ pos ▁; ▁int ▁ret ▁; ▁if ▁( ▁codec _ data _ size ▁> ▁INT _ MAX ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁1000 ▁) ▁; ▁codec _ pos ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁v ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁v ▁== ▁M KB ET AG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁int ▁number _ of _ streams ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁int ▁number _ of _ md pr ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁number _ of _ streams ▁; ▁i ▁++ ▁) ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁number _ of _ md pr ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁number _ of _ md pr ▁!= ▁1 ▁) ▁{ ▁avpriv _ request _ sample ▁( ▁s ▁, ▁" ML TI with multiple MD PR " ▁) ▁; ▁} ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁v ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁} ▁if ▁( ▁v ▁== ▁MKTAG ▁( ▁0 xfd ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁if ▁( ▁rm _ read _ audio _ stream _ info ▁( ▁s ▁, ▁pb ▁, ▁st ▁, ▁rst ▁, ▁0 ▁) ▁) ▁return ▁-1 ▁; ▁} ▁else ▁if ▁( ▁v ▁== ▁M KB ET AG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁avio _ seek ▁( ▁pb ▁, ▁-4 ▁, ▁SEEK _ CUR ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁rm _ read _ extr adata ▁( ▁pb ▁, ▁st ▁-> ▁codec ▁, ▁codec _ data _ size ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁= ▁AV _ RL 32 ▁( ▁st ▁-> ▁codec ▁-> ▁extradata ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁ff _ codec _ get _ id ▁( ▁ff _ rm _ codec _ tags ▁, ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁) ▁; ▁} ▁else ▁if ▁( ▁mime ▁&& ▁! ▁strcmp ▁( ▁mime ▁, ▁" logical - file info " ▁) ▁) ▁{ ▁int ▁stream _ count ▁, ▁rule _ count ▁, ▁property _ count ▁, ▁i ▁; ▁ff _ free _ stream ▁( ▁s ▁, ▁st ▁) ▁; ▁if ▁( ▁avio _ rb 16 ▁( ▁pb ▁) ▁!= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Unsupported version \ n " ▁) ▁; ▁goto ▁skip ▁; ▁} ▁stream _ count ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁6 ▁* ▁stream _ count ▁) ▁; ▁rule _ count ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁2 ▁* ▁rule _ count ▁) ▁; ▁property _ count ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁property _ count ▁; ▁i ▁++ ▁) ▁{ ▁uint 8_ t ▁name ▁[ ▁128 ▁] ▁, ▁val ▁[ ▁128 ▁] ▁; ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁avio _ rb 16 ▁( ▁pb ▁) ▁!= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Unsupported Name value property version \ n " ▁) ▁; ▁goto ▁skip ▁; ▁} ▁get _ str 8 ▁( ▁pb ▁, ▁name ▁, ▁sizeof ▁( ▁name ▁) ▁) ▁; ▁switch ▁( ▁avio _ rb 32 ▁( ▁pb ▁) ▁) ▁{ ▁case ▁2 ▁: ▁get _ strl ▁( ▁pb ▁, ▁val ▁, ▁sizeof ▁( ▁val ▁) ▁, ▁avio _ rb 16 ▁( ▁pb ▁) ▁) ▁; ▁av _ dict _ set ▁( ▁& ▁s ▁-> ▁metadata ▁, ▁name ▁, ▁val ▁, ▁0 ▁) ▁; ▁break ▁; ▁default ▁: ▁avio _ skip ▁( ▁pb ▁, ▁avio _ rb 16 ▁( ▁pb ▁) ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁int ▁fps ▁; ▁if ▁( ▁avio _ rl 32 ▁( ▁pb ▁) ▁!= ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁{ ▁fail 1 ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Unsupported stream type %08 x \ n " ▁, ▁v ▁) ▁; ▁goto ▁skip ▁; ▁} ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁ff _ codec _ get _ id ▁( ▁ff _ rm _ codec _ tags ▁, ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁) ▁; ▁av _ d log ▁( ▁s ▁, ▁"% X % X \ n " ▁, ▁st ▁-> ▁codec ▁-> ▁codec _ tag ▁, ▁MKTAG ▁( ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁) ▁) ▁; ▁if ▁( ▁st ▁-> ▁codec ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ NONE ▁) ▁goto ▁fail 1 ▁; ▁st ▁-> ▁codec ▁-> ▁width ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁height ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁2 ▁) ▁; ▁avio _ skip ▁( ▁pb ▁, ▁4 ▁) ▁; ▁st ▁-> ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ VIDEO ▁; ▁st ▁-> ▁need _ parsing ▁= ▁AV STREAM _ PARSE _ TIMESTAMP S ▁; ▁fps ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁rm _ read _ extr adata ▁( ▁pb ▁, ▁st ▁-> ▁codec ▁, ▁codec _ data _ size ▁- ▁( ▁avio _ tell ▁( ▁pb ▁) ▁- ▁codec _ pos ▁) ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁fps ▁> ▁0 ▁) ▁{ ▁av _ reduce ▁( ▁& ▁st ▁-> ▁avg _ frame _ rate ▁. ▁den ▁, ▁& ▁st ▁-> ▁avg _ frame _ rate ▁. ▁num ▁, ▁0 x 10000 ▁, ▁fps ▁, ▁( ▁1 ▁<< ▁30 ▁) ▁- ▁1 ▁) ▁; ▁# if ▁FF _ API _ R _ FRAME _ RATE ▁st ▁-> ▁r _ frame _ rate ▁= ▁st ▁-> ▁avg _ frame _ rate ▁; ▁# endif ▁} ▁else ▁if ▁( ▁s ▁-> ▁error _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid f ramerate \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁skip ▁: ▁size ▁= ▁avio _ tell ▁( ▁pb ▁) ▁- ▁codec _ pos ▁; ▁if ▁( ▁codec _ data _ size ▁>= ▁size ▁) ▁{ ▁avio _ skip ▁( ▁pb ▁, ▁codec _ data _ size ▁- ▁size ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" codec _ data _ size % u < size % d \ n " ▁, ▁codec _ data _ size ▁, ▁size ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁ff _ mpeg _ ref _ picture ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁Picture ▁* ▁dst ▁, ▁Picture ▁* ▁src ▁) ▁{ ▁int ▁ret ▁; ▁av _ assert 0 ▁( ▁! ▁dst ▁-> ▁f ▁-> ▁buf ▁[ ▁0 ▁] ▁) ▁; ▁av _ assert 0 ▁( ▁src ▁-> ▁f ▁-> ▁buf ▁[ ▁0 ▁] ▁) ▁; ▁src ▁-> ▁tf ▁. ▁f ▁= ▁src ▁-> ▁f ▁; ▁dst ▁-> ▁tf ▁. ▁f ▁= ▁dst ▁-> ▁f ▁; ▁ret ▁= ▁ff _ thread _ ref _ frame ▁( ▁& ▁dst ▁-> ▁tf ▁, ▁& ▁src ▁-> ▁tf ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁ret ▁= ▁update _ picture _ tables ▁( ▁dst ▁, ▁src ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁if ▁( ▁src ▁-> ▁hw accel _ picture _ private ▁) ▁{ ▁dst ▁-> ▁hw accel _ priv _ buf ▁= ▁av _ buffer _ ref ▁( ▁src ▁-> ▁hw accel _ priv _ buf ▁) ▁; ▁if ▁( ▁! ▁dst ▁-> ▁hw accel _ priv _ buf ▁) ▁goto ▁fail ▁; ▁dst ▁-> ▁hw accel _ picture _ private ▁= ▁dst ▁-> ▁hw accel _ priv _ buf ▁-> ▁data ▁; ▁} ▁dst ▁-> ▁field _ picture ▁= ▁src ▁-> ▁field _ picture ▁; ▁dst ▁-> ▁mb _ var _ sum ▁= ▁src ▁-> ▁mb _ var _ sum ▁; ▁dst ▁-> ▁mc _ mb _ var _ sum ▁= ▁src ▁-> ▁mc _ mb _ var _ sum ▁; ▁dst ▁-> ▁b _ frame _ score ▁= ▁src ▁-> ▁b _ frame _ score ▁; ▁dst ▁-> ▁needs _ realloc ▁= ▁src ▁-> ▁needs _ realloc ▁; ▁dst ▁-> ▁reference ▁= ▁src ▁-> ▁reference ▁; ▁dst ▁-> ▁shared ▁= ▁src ▁-> ▁shared ▁; ▁return ▁0 ▁; ▁fail ▁: ▁ff _ mpeg _ unref _ picture ▁( ▁s ▁, ▁dst ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁cd xl _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁C DX LD emux Context ▁* ▁cd xl ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁uint 32_ t ▁current _ size ▁, ▁video _ size ▁, ▁image _ size ▁; ▁uint 16_ t ▁audio _ size ▁, ▁palette _ size ▁, ▁width ▁, ▁height ▁; ▁int 64_ t ▁pos ▁; ▁int ▁format ▁, ▁frames ▁, ▁ret ▁; ▁if ▁( ▁avio _ fe of ▁( ▁pb ▁) ▁) ▁return ▁AVERROR _ EOF ▁; ▁pos ▁= ▁avio _ tell ▁( ▁pb ▁) ▁; ▁if ▁( ▁! ▁cd xl ▁-> ▁read _ chunk ▁&& ▁avio _ read ▁( ▁pb ▁, ▁cd xl ▁-> ▁header ▁, ▁CDXL _ HEADER _ SIZE ▁) ▁!= ▁CDXL _ HEADER _ SIZE ▁) ▁return ▁AVERROR _ EOF ▁; ▁if ▁( ▁cd xl ▁-> ▁header ▁[ ▁0 ▁] ▁!= ▁1 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" non - standard cd xl file \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁format ▁= ▁cd xl ▁-> ▁header ▁[ ▁1 ▁] ▁& ▁0 xE 0 ▁; ▁current _ size ▁= ▁AV _ RB 32 ▁( ▁& ▁cd xl ▁-> ▁header ▁[ ▁2 ▁] ▁) ▁; ▁width ▁= ▁AV _ RB 16 ▁( ▁& ▁cd xl ▁-> ▁header ▁[ ▁14 ▁] ▁) ▁; ▁height ▁= ▁AV _ RB 16 ▁( ▁& ▁cd xl ▁-> ▁header ▁[ ▁16 ▁] ▁) ▁; ▁palette _ size ▁= ▁AV _ RB 16 ▁( ▁& ▁cd xl ▁-> ▁header ▁[ ▁20 ▁] ▁) ▁; ▁audio _ size ▁= ▁AV _ RB 16 ▁( ▁& ▁cd xl ▁-> ▁header ▁[ ▁22 ▁] ▁) ▁; ▁if ▁( ▁FF ALIGN ▁( ▁width ▁, ▁16 ▁) ▁* ▁( ▁uint 64_ t ▁) ▁height ▁* ▁cd xl ▁-> ▁header ▁[ ▁19 ▁] ▁> ▁INT _ MAX ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁format ▁== ▁0 x 20 ▁) ▁image _ size ▁= ▁width ▁* ▁height ▁* ▁cd xl ▁-> ▁header ▁[ ▁19 ▁] ▁/ ▁8 ▁; ▁else ▁image _ size ▁= ▁FF ALIGN ▁( ▁width ▁, ▁16 ▁) ▁* ▁height ▁* ▁cd xl ▁-> ▁header ▁[ ▁19 ▁] ▁/ ▁8 ▁; ▁video _ size ▁= ▁palette _ size ▁+ ▁image _ size ▁; ▁if ▁( ▁palette _ size ▁> ▁512 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁current _ size ▁< ▁( ▁uint 64_ t ▁) ▁audio _ size ▁+ ▁video _ size ▁+ ▁CDXL _ HEADER _ SIZE ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁if ▁( ▁cd xl ▁-> ▁read _ chunk ▁&& ▁audio _ size ▁) ▁{ ▁if ▁( ▁cd xl ▁-> ▁audio _ stream _ index ▁== ▁-1 ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ tag ▁= ▁0 ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ PCM _ S 8 ▁; ▁if ▁( ▁cd xl ▁-> ▁header ▁[ ▁1 ▁] ▁& ▁0 x 10 ▁) ▁{ ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁2 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ STEREO ▁; ▁} ▁else ▁{ ▁st ▁-> ▁codecpar ▁-> ▁channels ▁= ▁1 ▁; ▁st ▁-> ▁codecpar ▁-> ▁channel _ layout ▁= ▁AV _ CH _ LAYOUT _ MONO ▁; ▁} ▁st ▁-> ▁codecpar ▁-> ▁sample _ rate ▁= ▁cd xl ▁-> ▁sample _ rate ▁; ▁st ▁-> ▁start _ time ▁= ▁0 ▁; ▁cd xl ▁-> ▁audio _ stream _ index ▁= ▁st ▁-> ▁index ▁; ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁cd xl ▁-> ▁sample _ rate ▁) ▁; ▁} ▁ret ▁= ▁av _ get _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁audio _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁cd xl ▁-> ▁audio _ stream _ index ▁; ▁pkt ▁-> ▁pos ▁= ▁pos ▁; ▁pkt ▁-> ▁duration ▁= ▁audio _ size ▁; ▁cd xl ▁-> ▁read _ chunk ▁= ▁0 ▁; ▁} ▁else ▁{ ▁if ▁( ▁cd xl ▁-> ▁video _ stream _ index ▁== ▁-1 ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁st ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ VIDEO ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ tag ▁= ▁0 ▁; ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ CD XL ▁; ▁st ▁-> ▁codecpar ▁-> ▁width ▁= ▁width ▁; ▁st ▁-> ▁codecpar ▁-> ▁height ▁= ▁height ▁; ▁if ▁( ▁audio _ size ▁+ ▁video _ size ▁&& ▁cd xl ▁-> ▁filesize ▁> ▁0 ▁) ▁{ ▁frames ▁= ▁cd xl ▁-> ▁filesize ▁/ ▁( ▁audio _ size ▁+ ▁video _ size ▁) ▁; ▁if ▁( ▁cd xl ▁-> ▁fram erate ▁) ▁st ▁-> ▁duration ▁= ▁frames ▁; ▁else ▁st ▁-> ▁duration ▁= ▁frames ▁* ▁( ▁int 64_ t ▁) ▁audio _ size ▁; ▁} ▁st ▁-> ▁start _ time ▁= ▁0 ▁; ▁cd xl ▁-> ▁video _ stream _ index ▁= ▁st ▁-> ▁index ▁; ▁if ▁( ▁cd xl ▁-> ▁fram erate ▁) ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁cd xl ▁-> ▁fps ▁. ▁den ▁, ▁cd xl ▁-> ▁fps ▁. ▁num ▁) ▁; ▁else ▁avpriv _ set _ pts _ info ▁( ▁st ▁, ▁64 ▁, ▁1 ▁, ▁cd xl ▁-> ▁sample _ rate ▁) ▁; ▁} ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁video _ size ▁+ ▁CDXL _ HEADER _ SIZE ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁cd xl ▁-> ▁header ▁, ▁CDXL _ HEADER _ SIZE ▁) ▁; ▁ret ▁= ▁avio _ read ▁( ▁pb ▁, ▁pkt ▁-> ▁data ▁+ ▁CDXL _ HEADER _ SIZE ▁, ▁video _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ packet _ unref ▁( ▁pkt ▁) ▁; ▁return ▁ret ▁; ▁} ▁av _ shrink _ packet ▁( ▁pkt ▁, ▁CDXL _ HEADER _ SIZE ▁+ ▁ret ▁) ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁cd xl ▁-> ▁video _ stream _ index ▁; ▁pkt ▁-> ▁flags ▁|= ▁AV _ PKT _ FLAG _ KEY ▁; ▁pkt ▁-> ▁pos ▁= ▁pos ▁; ▁pkt ▁-> ▁duration ▁= ▁cd xl ▁-> ▁fram erate ▁? ▁1 ▁: ▁audio _ size ▁? ▁audio _ size ▁: ▁220 ▁; ▁cd xl ▁-> ▁read _ chunk ▁= ▁audio _ size ▁; ▁} ▁if ▁( ▁! ▁cd xl ▁-> ▁read _ chunk ▁) ▁avio _ skip ▁( ▁pb ▁, ▁current _ size ▁- ▁audio _ size ▁- ▁video _ size ▁- ▁CDXL _ HEADER _ SIZE ▁) ▁; ▁return ▁ret ▁; ▁}	1
▁int ▁EVP _ Decrypt Update ▁( ▁EVP _ CIPHER _ CTX ▁* ▁ctx ▁, ▁unsigned ▁char ▁* ▁out ▁, ▁int ▁* ▁outl ▁, ▁const ▁unsigned ▁char ▁* ▁in ▁, ▁int ▁inl ▁) ▁{ ▁int ▁fix _ len ▁, ▁c mpl ▁= ▁inl ▁; ▁unsigned ▁int ▁b ▁; ▁b ▁= ▁ctx ▁-> ▁cipher ▁-> ▁block _ size ▁; ▁if ▁( ▁EVP _ CIPHER _ CTX _ test _ flags ▁( ▁ctx ▁, ▁EVP _ C IPH _ FLAG _ LENGTH _ BITS ▁) ▁) ▁c mpl ▁= ▁( ▁c mpl ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁if ▁( ▁ctx ▁-> ▁cipher ▁-> ▁flags ▁& ▁EVP _ C IPH _ FLAG _ CUSTOM _ CIPHER ▁) ▁{ ▁if ▁( ▁b ▁== ▁1 ▁&& ▁is _ part ially _ over lapping ▁( ▁out ▁, ▁in ▁, ▁c mpl ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DECRYPT UPDATE ▁, ▁EVP _ R _ PAR TI ALLY _ OVER L APP ING ▁) ▁; ▁return ▁0 ▁; ▁} ▁fix _ len ▁= ▁ctx ▁-> ▁cipher ▁-> ▁do _ cipher ▁( ▁ctx ▁, ▁out ▁, ▁in ▁, ▁inl ▁) ▁; ▁if ▁( ▁fix _ len ▁< ▁0 ▁) ▁{ ▁* ▁outl ▁= ▁0 ▁; ▁return ▁0 ▁; ▁} ▁else ▁* ▁outl ▁= ▁fix _ len ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁inl ▁<= ▁0 ▁) ▁{ ▁* ▁outl ▁= ▁0 ▁; ▁return ▁inl ▁== ▁0 ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁flags ▁& ▁EVP _ C IPH _ NO _ PADDING ▁) ▁return ▁EVP _ Encrypt Update ▁( ▁ctx ▁, ▁out ▁, ▁outl ▁, ▁in ▁, ▁inl ▁) ▁; ▁OPENSSL _ assert ▁( ▁b ▁<= ▁sizeof ▁ctx ▁-> ▁final ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁final _ used ▁) ▁{ ▁if ▁( ▁( ▁( ▁PTR DIFF _ T ▁) ▁out ▁== ▁( ▁PTR DIFF _ T ▁) ▁in ▁) ▁|| ▁is _ part ially _ over lapping ▁( ▁out ▁, ▁in ▁, ▁b ▁) ▁) ▁{ ▁EVP err ▁( ▁EVP _ F _ EVP _ DECRYPT UPDATE ▁, ▁EVP _ R _ PAR TI ALLY _ OVER L APP ING ▁) ▁; ▁return ▁0 ▁; ▁} ▁memcpy ▁( ▁out ▁, ▁ctx ▁-> ▁final ▁, ▁b ▁) ▁; ▁out ▁+= ▁b ▁; ▁fix _ len ▁= ▁1 ▁; ▁} ▁else ▁fix _ len ▁= ▁0 ▁; ▁if ▁( ▁! ▁EVP _ Encrypt Update ▁( ▁ctx ▁, ▁out ▁, ▁outl ▁, ▁in ▁, ▁inl ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁b ▁> ▁1 ▁&& ▁! ▁ctx ▁-> ▁buf _ len ▁) ▁{ ▁* ▁outl ▁-= ▁b ▁; ▁ctx ▁-> ▁final _ used ▁= ▁1 ▁; ▁memcpy ▁( ▁ctx ▁-> ▁final ▁, ▁& ▁out ▁[ ▁* ▁outl ▁] ▁, ▁b ▁) ▁; ▁} ▁else ▁ctx ▁-> ▁final _ used ▁= ▁0 ▁; ▁if ▁( ▁fix _ len ▁) ▁* ▁outl ▁+= ▁b ▁; ▁return ▁1 ▁; ▁}	0
▁int ▁dv _ produce _ packet ▁( ▁D VD emux Context ▁* ▁c ▁, ▁AVPacket ▁* ▁pkt ▁, ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁) ▁{ ▁int ▁size ▁, ▁i ▁; ▁uint 8_ t ▁* ▁p pcm ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁if ▁( ▁buf _ size ▁< ▁DV _ PROFILE _ BYTES ▁|| ▁! ▁( ▁c ▁-> ▁sys ▁= ▁dv _ frame _ profile ▁( ▁c ▁-> ▁sys ▁, ▁buf ▁, ▁buf _ size ▁) ▁) ▁|| ▁buf _ size ▁< ▁c ▁-> ▁sys ▁-> ▁frame _ size ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁size ▁= ▁dv _ extract _ audio _ info ▁( ▁c ▁, ▁buf ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁ach ▁; ▁i ▁++ ▁) ▁{ ▁c ▁-> ▁audio _ pkt ▁[ ▁i ▁] ▁. ▁size ▁= ▁size ▁; ▁c ▁-> ▁audio _ pkt ▁[ ▁i ▁] ▁. ▁pts ▁= ▁c ▁-> ▁ab ytes ▁* ▁30000 ▁* ▁8 ▁/ ▁c ▁-> ▁ast ▁[ ▁i ▁] ▁-> ▁codec ▁-> ▁bit _ rate ▁; ▁p pcm ▁[ ▁i ▁] ▁= ▁c ▁-> ▁audio _ buf ▁[ ▁i ▁] ▁; ▁} ▁dv _ extract _ audio ▁( ▁buf ▁, ▁p pcm ▁, ▁c ▁-> ▁sys ▁) ▁; ▁c ▁-> ▁ab ytes ▁+= ▁size ▁; ▁if ▁( ▁c ▁-> ▁sys ▁-> ▁height ▁== ▁720 ▁) ▁{ ▁if ▁( ▁buf ▁[ ▁1 ▁] ▁& ▁0 x 0 C ▁) ▁c ▁-> ▁audio _ pkt ▁[ ▁2 ▁] ▁. ▁size ▁= ▁c ▁-> ▁audio _ pkt ▁[ ▁3 ▁] ▁. ▁size ▁= ▁0 ▁; ▁else ▁c ▁-> ▁audio _ pkt ▁[ ▁0 ▁] ▁. ▁size ▁= ▁c ▁-> ▁audio _ pkt ▁[ ▁1 ▁] ▁. ▁size ▁= ▁0 ▁; ▁} ▁size ▁= ▁dv _ extract _ video _ info ▁( ▁c ▁, ▁buf ▁) ▁; ▁av _ init _ packet ▁( ▁pkt ▁) ▁; ▁pkt ▁-> ▁data ▁= ▁buf ▁; ▁pkt ▁-> ▁size ▁= ▁size ▁; ▁pkt ▁-> ▁flags ▁|= ▁PK T _ FLAG _ KEY ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁c ▁-> ▁vst ▁-> ▁id ▁; ▁pkt ▁-> ▁pts ▁= ▁c ▁-> ▁frames ▁; ▁c ▁-> ▁frames ▁++ ▁; ▁return ▁size ▁; ▁}	0
▁static ▁void ▁write _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁, ▁OutputStream ▁* ▁o st ▁) ▁{ ▁AVStream ▁* ▁st ▁= ▁o st ▁-> ▁st ▁; ▁int ▁ret ▁; ▁if ▁( ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁&& ▁video _ sync _ method ▁== ▁V SYNC _ DROP ▁) ▁|| ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁&& ▁audio _ sync _ method ▁< ▁0 ▁) ▁) ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁dts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁if ▁( ▁! ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁&& ▁o st ▁-> ▁encoding _ needed ▁) ▁) ▁{ ▁if ▁( ▁o st ▁-> ▁frame _ number ▁>= ▁o st ▁-> ▁max _ frames ▁) ▁{ ▁av _ packet _ unref ▁( ▁pkt ▁) ▁; ▁return ▁; ▁} ▁o st ▁-> ▁frame _ number ▁++ ▁; ▁} ▁if ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁int ▁i ▁; ▁uint 8_ t ▁* ▁sd ▁= ▁av _ packet _ get _ side _ data ▁( ▁pkt ▁, ▁AV _ PKT _ DATA _ QUAL ITY _ STATS ▁, ▁NULL ▁) ▁; ▁o st ▁-> ▁quality ▁= ▁sd ▁? ▁AV _ RL 32 ▁( ▁sd ▁) ▁: ▁-1 ▁; ▁o st ▁-> ▁pict _ type ▁= ▁sd ▁? ▁sd ▁[ ▁4 ▁] ▁: ▁AV _ PICTURE _ TYPE _ NONE ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁o st ▁-> ▁error ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sd ▁&& ▁i ▁< ▁sd ▁[ ▁5 ▁] ▁) ▁o st ▁-> ▁error ▁[ ▁i ▁] ▁= ▁AV _ RL 64 ▁( ▁sd ▁+ ▁8 ▁+ ▁8 ▁* ▁i ▁) ▁; ▁else ▁o st ▁-> ▁error ▁[ ▁i ▁] ▁= ▁-1 ▁; ▁} ▁if ▁( ▁o st ▁-> ▁frame _ rate ▁. ▁num ▁&& ▁o st ▁-> ▁is _ c fr ▁) ▁{ ▁if ▁( ▁pkt ▁-> ▁duration ▁> ▁0 ▁) ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ WARNING ▁, ▁" Over riding packet duration by f ramerate , th iss h ould not h appen \ n " ▁) ▁; ▁pkt ▁-> ▁duration ▁= ▁av _ re scale _ q ▁( ▁1 ▁, ▁av _ inv _ q ▁( ▁o st ▁-> ▁frame _ rate ▁) ▁, ▁o st ▁-> ▁st ▁-> ▁time _ base ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁( ▁s ▁-> ▁of orm at ▁-> ▁flags ▁& ▁AV FMT _ NO TIMESTAMP S ▁) ▁) ▁{ ▁if ▁( ▁pkt ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁pkt ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁pkt ▁-> ▁dts ▁> ▁pkt ▁-> ▁pts ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Invalid D TS :% " ▁PRId 64 ▁" PT S :% " ▁PRId 64 ▁" in output stream % d :% d , repl acing by guess \ n " ▁, ▁pkt ▁-> ▁dts ▁, ▁pkt ▁-> ▁pts ▁, ▁o st ▁-> ▁file _ index ▁, ▁o st ▁-> ▁st ▁-> ▁index ▁) ▁; ▁pkt ▁-> ▁pts ▁= ▁pkt ▁-> ▁dts ▁= ▁pkt ▁-> ▁pts ▁+ ▁pkt ▁-> ▁dts ▁+ ▁o st ▁-> ▁last _ mux _ dts ▁+ ▁1 ▁- ▁FF MIN 3 ▁( ▁pkt ▁-> ▁pts ▁, ▁pkt ▁-> ▁dts ▁, ▁o st ▁-> ▁last _ mux _ dts ▁+ ▁1 ▁) ▁- ▁FF MAX 3 ▁( ▁pkt ▁-> ▁pts ▁, ▁pkt ▁-> ▁dts ▁, ▁o st ▁-> ▁last _ mux _ dts ▁+ ▁1 ▁) ▁; ▁} ▁if ▁( ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ AUDIO ▁|| ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁&& ▁pkt ▁-> ▁dts ▁!= ▁AV _ NOP TS _ VALUE ▁&& ▁! ▁( ▁st ▁-> ▁codecpar ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ VP 9 ▁&& ▁o st ▁-> ▁stream _ copy ▁) ▁&& ▁o st ▁-> ▁last _ mux _ dts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁int 64_ t ▁max ▁= ▁o st ▁-> ▁last _ mux _ dts ▁+ ▁! ▁( ▁s ▁-> ▁of orm at ▁-> ▁flags ▁& ▁AV FMT _ TS _ NON STRICT ▁) ▁; ▁if ▁( ▁pkt ▁-> ▁dts ▁< ▁max ▁) ▁{ ▁int ▁log level ▁= ▁max ▁- ▁pkt ▁-> ▁dts ▁> ▁2 ▁|| ▁st ▁-> ▁codecpar ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁? ▁AV _ LOG _ WARNING ▁: ▁AV _ LOG _ DEBUG ▁; ▁av _ log ▁( ▁s ▁, ▁log level ▁, ▁" Non - mon ot on ous D TS in output stream " ▁"% d :% d ; previous :% " ▁PRId 64 ▁", current :% " ▁PRId 64 ▁";" ▁, ▁o st ▁-> ▁file _ index ▁, ▁o st ▁-> ▁st ▁-> ▁index ▁, ▁o st ▁-> ▁last _ mux _ dts ▁, ▁pkt ▁-> ▁dts ▁) ▁; ▁if ▁( ▁exit _ on _ error ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ FATAL ▁, ▁" abort ing .\ n " ▁) ▁; ▁exit _ program ▁( ▁1 ▁) ▁; ▁} ▁av _ log ▁( ▁s ▁, ▁log level ▁, ▁" ch anging to %" ▁PRId 64 ▁". This may result " ▁" in inc orrect timestamp sint he output file .\ n " ▁, ▁max ▁) ▁; ▁if ▁( ▁pkt ▁-> ▁pts ▁>= ▁pkt ▁-> ▁dts ▁) ▁pkt ▁-> ▁pts ▁= ▁FF MAX ▁( ▁pkt ▁-> ▁pts ▁, ▁max ▁) ▁; ▁pkt ▁-> ▁dts ▁= ▁max ▁; ▁} ▁} ▁} ▁o st ▁-> ▁last _ mux _ dts ▁= ▁pkt ▁-> ▁dts ▁; ▁o st ▁-> ▁data _ size ▁+= ▁pkt ▁-> ▁size ▁; ▁o st ▁-> ▁packets _ written ▁++ ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁o st ▁-> ▁index ▁; ▁if ▁( ▁debug _ ts ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ INFO ▁, ▁" mux er < - type :% s " ▁" pkt _ pts :% sp kt _ pts _ time :% sp kt _ dts :% sp kt _ dts _ time :% ssize :% d \ n " ▁, ▁av _ get _ media _ type _ string ▁( ▁o st ▁-> ▁enc _ ctx ▁-> ▁codec _ type ▁) ▁, ▁av _ ts 2 str ▁( ▁pkt ▁-> ▁pts ▁) ▁, ▁av _ ts 2 tim estr ▁( ▁pkt ▁-> ▁pts ▁, ▁& ▁o st ▁-> ▁st ▁-> ▁time _ base ▁) ▁, ▁av _ ts 2 str ▁( ▁pkt ▁-> ▁dts ▁) ▁, ▁av _ ts 2 tim estr ▁( ▁pkt ▁-> ▁dts ▁, ▁& ▁o st ▁-> ▁st ▁-> ▁time _ base ▁) ▁, ▁pkt ▁-> ▁size ▁) ▁; ▁} ▁ret ▁= ▁av _ inter leaved _ write _ frame ▁( ▁s ▁, ▁pkt ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁print _ error ▁( ▁" av _ inter leaved _ write _ frame ()" ▁, ▁ret ▁) ▁; ▁main _ return _ code ▁= ▁1 ▁; ▁close _ all _ output _ streams ▁( ▁o st ▁, ▁MUX ER _ FINISHED ▁| ▁EN CODER _ FINISHED ▁, ▁EN CODER _ FINISHED ▁) ▁; ▁} ▁av _ packet _ unref ▁( ▁pkt ▁) ▁; ▁}	0
▁static ▁ssize _ t ▁ngx _ http _ validate _ host ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁u _ char ▁* ▁* ▁host ▁, ▁size _ t ▁len ▁, ▁ngx _ uint _ t ▁alloc ▁) ▁{ ▁u _ char ▁* ▁h ▁, ▁ch ▁; ▁size _ t ▁i ▁, ▁last ▁; ▁ngx _ uint _ t ▁dot ▁; ▁last ▁= ▁len ▁; ▁h ▁= ▁* ▁host ▁; ▁dot ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁ch ▁= ▁h ▁[ ▁i ▁] ▁; ▁if ▁( ▁ch ▁== ▁' ▁' ▁) ▁{ ▁if ▁( ▁dot ▁) ▁{ ▁return ▁0 ▁; ▁} ▁dot ▁= ▁1 ▁; ▁continue ▁; ▁} ▁dot ▁= ▁0 ▁; ▁if ▁( ▁ch ▁== ▁' ▁' ▁) ▁{ ▁last ▁= ▁i ▁; ▁continue ▁; ▁} ▁if ▁( ▁ngx _ path _ separator ▁( ▁ch ▁) ▁|| ▁ch ▁== ▁' ▁\0 ▁' ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁ch ▁>= ▁' ▁' ▁|| ▁ch ▁< ▁' ▁' ▁) ▁{ ▁alloc ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁dot ▁) ▁{ ▁last ▁-- ▁; ▁} ▁if ▁( ▁alloc ▁) ▁{ ▁* ▁host ▁= ▁ngx _ pn alloc ▁( ▁r ▁-> ▁pool ▁, ▁last ▁) ▁; ▁if ▁( ▁* ▁host ▁== ▁NULL ▁) ▁{ ▁return ▁-1 ▁; ▁} ▁ngx _ str low ▁( ▁* ▁host ▁, ▁h ▁, ▁last ▁) ▁; ▁} ▁return ▁last ▁; ▁}	1
▁static ▁void ▁md ct 512 ▁( ▁int 32_ t ▁* ▁out ▁, ▁int 16_ t ▁* ▁in ▁) ▁{ ▁int ▁i ▁, ▁re ▁, ▁im ▁, ▁re 1 ▁, ▁im 1 ▁; ▁int 16_ t ▁rot ▁[ ▁MD CT _ SAMPLES ▁] ▁; ▁I Complex ▁x ▁[ ▁MD CT _ SAMPLES ▁/ ▁4 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MD CT _ SAMPLES ▁/ ▁4 ▁; ▁i ▁++ ▁) ▁rot ▁[ ▁i ▁] ▁= ▁- ▁in ▁[ ▁i ▁+ ▁3 ▁* ▁MD CT _ SAMPLES ▁/ ▁4 ▁] ▁; ▁for ▁( ▁; ▁i ▁< ▁MD CT _ SAMPLES ▁; ▁i ▁++ ▁) ▁rot ▁[ ▁i ▁] ▁= ▁in ▁[ ▁i ▁- ▁MD CT _ SAMPLES ▁/ ▁4 ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MD CT _ SAMPLES ▁/ ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁re ▁= ▁( ▁( ▁int ▁) ▁rot ▁[ ▁2 ▁* ▁i ▁] ▁- ▁( ▁int ▁) ▁rot ▁[ ▁MD CT _ SAMPLES ▁- ▁1 ▁- ▁2 ▁* ▁i ▁] ▁) ▁>> ▁1 ▁; ▁im ▁= ▁- ▁( ▁( ▁int ▁) ▁rot ▁[ ▁MD CT _ SAMPLES ▁/ ▁2 ▁+ ▁2 ▁* ▁i ▁] ▁- ▁( ▁int ▁) ▁rot ▁[ ▁MD CT _ SAMPLES ▁/ ▁2 ▁- ▁1 ▁- ▁2 ▁* ▁i ▁] ▁) ▁>> ▁1 ▁; ▁C MUL ▁( ▁x ▁[ ▁i ▁] ▁. ▁re ▁, ▁x ▁[ ▁i ▁] ▁. ▁im ▁, ▁re ▁, ▁im ▁, ▁- ▁x cos 1 ▁[ ▁i ▁] ▁, ▁xs in 1 ▁[ ▁i ▁] ▁) ▁; ▁} ▁fft ▁( ▁x ▁, ▁MD CT _ N BITS ▁- ▁2 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MD CT _ SAMPLES ▁/ ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁re ▁= ▁x ▁[ ▁i ▁] ▁. ▁re ▁; ▁im ▁= ▁x ▁[ ▁i ▁] ▁. ▁im ▁; ▁C MUL ▁( ▁re 1 ▁, ▁im 1 ▁, ▁re ▁, ▁im ▁, ▁xs in 1 ▁[ ▁i ▁] ▁, ▁x cos 1 ▁[ ▁i ▁] ▁) ▁; ▁out ▁[ ▁2 ▁* ▁i ▁] ▁= ▁im 1 ▁; ▁out ▁[ ▁MD CT _ SAMPLES ▁/ ▁2 ▁- ▁1 ▁- ▁2 ▁* ▁i ▁] ▁= ▁re 1 ▁; ▁} ▁}	1
▁void ▁avfilter _ start _ frame ▁( ▁AVFilter Link ▁* ▁link ▁, ▁AVFilter Buffer Ref ▁* ▁pic ref ▁) ▁{ ▁void ▁( ▁* ▁start _ frame ▁) ▁( ▁AVFilter Link ▁* ▁, ▁AVFilter Buffer Ref ▁* ▁) ▁; ▁AVFilter Pad ▁* ▁dst ▁= ▁& ▁link _ dp ad ▁( ▁link ▁) ▁; ▁FF _ D PRINTF _ START ▁( ▁NULL ▁, ▁start _ frame ▁) ▁; ▁ff _ d printf _ link ▁( ▁NULL ▁, ▁link ▁, ▁0 ▁) ▁; ▁dprintf ▁( ▁NULL ▁, ▁"" ▁) ▁; ▁ff _ d printf _ ref ▁( ▁NULL ▁, ▁pic ref ▁, ▁1 ▁) ▁; ▁if ▁( ▁! ▁( ▁start _ frame ▁= ▁dst ▁-> ▁start _ frame ▁) ▁) ▁start _ frame ▁= ▁avfilter _ default _ start _ frame ▁; ▁if ▁( ▁( ▁dst ▁-> ▁min _ perms ▁& ▁pic ref ▁-> ▁perms ▁) ▁!= ▁dst ▁-> ▁min _ perms ▁|| ▁dst ▁-> ▁re j _ perms ▁& ▁pic ref ▁-> ▁perms ▁) ▁{ ▁av _ log ▁( ▁link ▁-> ▁dst ▁, ▁AV _ LOG _ DEBUG ▁, ▁" frame copy needed ( have perms % x , need % x , reject % x )\ n " ▁, ▁pic ref ▁-> ▁perms ▁, ▁link _ dp ad ▁( ▁link ▁) ▁. ▁min _ perms ▁, ▁link _ dp ad ▁( ▁link ▁) ▁. ▁re j _ perms ▁) ▁; ▁link ▁-> ▁cur _ buf ▁= ▁avfilter _ get _ video _ buffer ▁( ▁link ▁, ▁dst ▁-> ▁min _ perms ▁, ▁link ▁-> ▁w ▁, ▁link ▁-> ▁h ▁) ▁; ▁link ▁-> ▁src _ buf ▁= ▁pic ref ▁; ▁avfilter _ copy _ buffer _ ref _ props ▁( ▁link ▁-> ▁cur _ buf ▁, ▁link ▁-> ▁src _ buf ▁) ▁; ▁} ▁else ▁link ▁-> ▁cur _ buf ▁= ▁pic ref ▁; ▁start _ frame ▁( ▁link ▁, ▁link ▁-> ▁cur _ buf ▁) ▁; ▁}	0
▁static ▁void ▁m cl ms _ predict ▁( ▁W mall Decode Ctx ▁* ▁s ▁, ▁int ▁ic o ef ▁, ▁int ▁* ▁pred ▁) ▁{ ▁int ▁ich ▁, ▁i ▁; ▁int ▁order ▁= ▁s ▁-> ▁m cl ms _ order ▁; ▁int ▁num _ channels ▁= ▁s ▁-> ▁num _ channels ▁; ▁for ▁( ▁ich ▁= ▁0 ▁; ▁ich ▁< ▁num _ channels ▁; ▁ich ▁++ ▁) ▁{ ▁pred ▁[ ▁ich ▁] ▁= ▁0 ▁; ▁if ▁( ▁! ▁s ▁-> ▁is _ channel _ coded ▁[ ▁ich ▁] ▁) ▁continue ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁order ▁* ▁num _ channels ▁; ▁i ▁++ ▁) ▁pred ▁[ ▁ich ▁] ▁+= ▁( ▁uint 32_ t ▁) ▁s ▁-> ▁m cl ms _ prev values ▁[ ▁i ▁+ ▁s ▁-> ▁m cl ms _ re cent ▁] ▁* ▁s ▁-> ▁m cl ms _ coeffs ▁[ ▁i ▁+ ▁order ▁* ▁num _ channels ▁* ▁ich ▁] ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ich ▁; ▁i ▁++ ▁) ▁pred ▁[ ▁ich ▁] ▁+= ▁( ▁uint 32_ t ▁) ▁s ▁-> ▁channel _ resid ues ▁[ ▁i ▁] ▁[ ▁ic o ef ▁] ▁* ▁s ▁-> ▁m cl ms _ coeffs _ cur ▁[ ▁i ▁+ ▁num _ channels ▁* ▁ich ▁] ▁; ▁pred ▁[ ▁ich ▁] ▁+= ▁1 ▁<< ▁s ▁-> ▁m cl ms _ scaling ▁- ▁1 ▁; ▁pred ▁[ ▁ich ▁] ▁>>= ▁s ▁-> ▁m cl ms _ scaling ▁; ▁s ▁-> ▁channel _ resid ues ▁[ ▁ich ▁] ▁[ ▁ic o ef ▁] ▁+= ▁pred ▁[ ▁ich ▁] ▁; ▁} ▁}	0
▁void ▁BN _ clear _ free ▁( ▁BIGNUM ▁* ▁a ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁a ▁== ▁NULL ▁) ▁return ▁; ▁if ▁( ▁a ▁-> ▁d ▁!= ▁NULL ▁) ▁{ ▁memset ▁( ▁a ▁-> ▁d ▁, ▁0 ▁, ▁a ▁-> ▁max ▁* ▁sizeof ▁( ▁a ▁-> ▁d ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁! ▁( ▁BN _ get _ flags ▁( ▁a ▁, ▁BN _ FLG _ STATIC _ DATA ▁) ▁) ▁) ▁Free ▁( ▁a ▁-> ▁d ▁) ▁; ▁} ▁i ▁= ▁BN _ get _ flags ▁( ▁a ▁, ▁BN _ FLG _ MALLOC ED ▁) ▁; ▁memset ▁( ▁a ▁, ▁0 ▁, ▁sizeof ▁( ▁BIGNUM ▁) ▁) ▁; ▁if ▁( ▁i ▁) ▁Free ▁( ▁a ▁) ▁; ▁}	1
▁static ▁int ▁sb r _ hf _ calc _ np atches ▁( ▁AAC Context ▁* ▁ac ▁, ▁S pectral Band Replication ▁* ▁sb r ▁) ▁{ ▁int ▁i ▁, ▁k ▁, ▁sb ▁= ▁0 ▁; ▁int ▁msb ▁= ▁sb r ▁-> ▁k ▁[ ▁0 ▁] ▁; ▁int ▁usb ▁= ▁sb r ▁-> ▁kx ▁[ ▁1 ▁] ▁; ▁int ▁goal _ sb ▁= ▁( ▁( ▁1000 ▁<< ▁11 ▁) ▁+ ▁( ▁sb r ▁-> ▁sample _ rate ▁>> ▁1 ▁) ▁) ▁/ ▁sb r ▁-> ▁sample _ rate ▁; ▁sb r ▁-> ▁num _ patch es ▁= ▁0 ▁; ▁if ▁( ▁goal _ sb ▁< ▁sb r ▁-> ▁kx ▁[ ▁1 ▁] ▁+ ▁sb r ▁-> ▁m ▁[ ▁1 ▁] ▁) ▁{ ▁for ▁( ▁k ▁= ▁0 ▁; ▁sb r ▁-> ▁f _ master ▁[ ▁k ▁] ▁< ▁goal _ sb ▁; ▁k ▁++ ▁) ▁; ▁} ▁else ▁k ▁= ▁sb r ▁-> ▁n _ master ▁; ▁do ▁{ ▁int ▁odd ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁k ▁; ▁i ▁== ▁k ▁|| ▁sb ▁> ▁( ▁sb r ▁-> ▁k ▁[ ▁0 ▁] ▁- ▁1 ▁+ ▁msb ▁- ▁odd ▁) ▁; ▁i ▁-- ▁) ▁{ ▁sb ▁= ▁sb r ▁-> ▁f _ master ▁[ ▁i ▁] ▁; ▁odd ▁= ▁( ▁sb ▁+ ▁sb r ▁-> ▁k ▁[ ▁0 ▁] ▁) ▁& ▁1 ▁; ▁} ▁if ▁( ▁sb r ▁-> ▁num _ patch es ▁> ▁5 ▁) ▁{ ▁av _ log ▁( ▁ac ▁-> ▁av c context ▁, ▁AV _ LOG _ ERROR ▁, ▁" T oom any patch es :% d \ n " ▁, ▁sb r ▁-> ▁num _ patch es ▁) ▁; ▁return ▁-1 ▁; ▁} ▁sb r ▁-> ▁patch _ num _ sub band s ▁[ ▁sb r ▁-> ▁num _ patch es ▁] ▁= ▁FF MAX ▁( ▁sb ▁- ▁usb ▁, ▁0 ▁) ▁; ▁sb r ▁-> ▁patch _ start _ sub band ▁[ ▁sb r ▁-> ▁num _ patch es ▁] ▁= ▁sb r ▁-> ▁k ▁[ ▁0 ▁] ▁- ▁odd ▁- ▁sb r ▁-> ▁patch _ num _ sub band s ▁[ ▁sb r ▁-> ▁num _ patch es ▁] ▁; ▁if ▁( ▁sb r ▁-> ▁patch _ num _ sub band s ▁[ ▁sb r ▁-> ▁num _ patch es ▁] ▁> ▁0 ▁) ▁{ ▁usb ▁= ▁sb ▁; ▁msb ▁= ▁sb ▁; ▁sb r ▁-> ▁num _ patch es ▁++ ▁; ▁} ▁else ▁msb ▁= ▁sb r ▁-> ▁kx ▁[ ▁1 ▁] ▁; ▁if ▁( ▁sb r ▁-> ▁f _ master ▁[ ▁k ▁] ▁- ▁sb ▁< ▁3 ▁) ▁k ▁= ▁sb r ▁-> ▁n _ master ▁; ▁} ▁while ▁( ▁sb ▁!= ▁sb r ▁-> ▁kx ▁[ ▁1 ▁] ▁+ ▁sb r ▁-> ▁m ▁[ ▁1 ▁] ▁) ▁; ▁if ▁( ▁sb r ▁-> ▁patch _ num _ sub band s ▁[ ▁sb r ▁-> ▁num _ patch es ▁- ▁1 ▁] ▁< ▁3 ▁&& ▁sb r ▁-> ▁num _ patch es ▁> ▁1 ▁) ▁sb r ▁-> ▁num _ patch es ▁-- ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁asn 1_ get _ length ▁( ▁const ▁unsigned ▁char ▁* ▁* ▁pp ▁, ▁int ▁* ▁inf ▁, ▁long ▁* ▁rl ▁, ▁int ▁max ▁) ▁{ ▁const ▁unsigned ▁char ▁* ▁p ▁= ▁* ▁pp ▁; ▁unsigned ▁long ▁ret ▁= ▁0 ▁; ▁unsigned ▁int ▁i ▁; ▁if ▁( ▁max ▁-- ▁< ▁1 ▁) ▁return ▁( ▁0 ▁) ▁; ▁if ▁( ▁* ▁p ▁== ▁0 x 80 ▁) ▁{ ▁* ▁inf ▁= ▁1 ▁; ▁ret ▁= ▁0 ▁; ▁p ▁++ ▁; ▁} ▁else ▁{ ▁* ▁inf ▁= ▁0 ▁; ▁i ▁= ▁* ▁p ▁& ▁0 x 7 f ▁; ▁if ▁( ▁* ▁( ▁p ▁++ ▁) ▁& ▁0 x 80 ▁) ▁{ ▁if ▁( ▁max ▁< ▁( ▁int ▁) ▁i ▁) ▁return ▁0 ▁; ▁while ▁( ▁i ▁&& ▁* ▁p ▁== ▁0 ▁) ▁{ ▁p ▁++ ▁; ▁i ▁-- ▁; ▁} ▁if ▁( ▁i ▁> ▁sizeof ▁( ▁long ▁) ▁) ▁return ▁0 ▁; ▁while ▁( ▁i ▁-- ▁> ▁0 ▁) ▁{ ▁ret ▁<<= ▁8 L ▁; ▁ret ▁|= ▁* ▁( ▁p ▁++ ▁) ▁; ▁} ▁} ▁else ▁ret ▁= ▁i ▁; ▁} ▁if ▁( ▁ret ▁> ▁LONG _ MAX ▁) ▁return ▁0 ▁; ▁* ▁pp ▁= ▁p ▁; ▁* ▁rl ▁= ▁( ▁long ▁) ▁ret ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁static ▁int ▁mpl 2_ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁int ▁i ▁; ▁char ▁c ▁; ▁int 64_ t ▁start ▁, ▁end ▁; ▁const ▁unsigned ▁char ▁* ▁ptr ▁= ▁p ▁-> ▁buf ▁; ▁const ▁unsigned ▁char ▁* ▁ptr _ end ▁= ▁ptr ▁+ ▁p ▁-> ▁buf _ size ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁2 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁sscanf ▁( ▁ptr ▁, ▁"[ %" ▁SC Nd 64 ▁"] [% " ▁SC Nd 64 ▁"] % c " ▁, ▁& ▁start ▁, ▁& ▁end ▁, ▁& ▁c ▁) ▁!= ▁3 ▁&& ▁sscanf ▁( ▁ptr ▁, ▁"[ %" ▁SC Nd 64 ▁"] [] % c " ▁, ▁& ▁start ▁, ▁& ▁c ▁) ▁!= ▁2 ▁) ▁return ▁0 ▁; ▁ptr ▁+= ▁strcspn ▁( ▁ptr ▁, ▁"\ n " ▁) ▁+ ▁1 ▁; ▁if ▁( ▁ptr ▁>= ▁ptr _ end ▁) ▁return ▁0 ▁; ▁} ▁return ▁AV PROBE _ SCORE _ MAX ▁; ▁}	1
▁enum ▁AVCodec ID ▁ff _ fmt _ v 4 l 2 codec ▁( ▁uint 32_ t ▁v 4 l 2_ fmt ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁ff _ fmt _ conversion _ table ▁[ ▁i ▁] ▁. ▁codec _ id ▁!= ▁AV _ CODEC _ ID _ NONE ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ff _ fmt _ conversion _ table ▁[ ▁i ▁] ▁. ▁v 4 l 2_ fmt ▁== ▁v 4 l 2_ fmt ▁) ▁{ ▁return ▁ff _ fmt _ conversion _ table ▁[ ▁i ▁] ▁. ▁codec _ id ▁; ▁} ▁} ▁return ▁AV _ CODEC _ ID _ NONE ▁; ▁}	0
▁static ▁void ▁ss im _4 x 4 x n ▁( ▁const ▁uint 8_ t ▁* ▁main ▁, ▁int ▁main _ stride ▁, ▁const ▁uint 8_ t ▁* ▁ref ▁, ▁int ▁ref _ stride ▁, ▁int ▁( ▁* ▁sums ▁) ▁[ ▁4 ▁] ▁, ▁int ▁width ▁) ▁{ ▁int ▁x ▁, ▁y ▁, ▁z ▁; ▁for ▁( ▁z ▁= ▁0 ▁; ▁z ▁< ▁width ▁; ▁z ▁++ ▁) ▁{ ▁uint 32_ t ▁s 1 ▁= ▁0 ▁, ▁s 2 ▁= ▁0 ▁, ▁ss ▁= ▁0 ▁, ▁s 12 ▁= ▁0 ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁4 ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁4 ▁; ▁x ▁++ ▁) ▁{ ▁int ▁a ▁= ▁main ▁[ ▁x ▁+ ▁y ▁* ▁main _ stride ▁] ▁; ▁int ▁b ▁= ▁ref ▁[ ▁x ▁+ ▁y ▁* ▁ref _ stride ▁] ▁; ▁s 1 ▁+= ▁a ▁; ▁s 2 ▁+= ▁b ▁; ▁ss ▁+= ▁a ▁* ▁a ▁; ▁ss ▁+= ▁b ▁* ▁b ▁; ▁s 12 ▁+= ▁a ▁* ▁b ▁; ▁} ▁} ▁sums ▁[ ▁z ▁] ▁[ ▁0 ▁] ▁= ▁s 1 ▁; ▁sums ▁[ ▁z ▁] ▁[ ▁1 ▁] ▁= ▁s 2 ▁; ▁sums ▁[ ▁z ▁] ▁[ ▁2 ▁] ▁= ▁ss ▁; ▁sums ▁[ ▁z ▁] ▁[ ▁3 ▁] ▁= ▁s 12 ▁; ▁main ▁+= ▁4 ▁; ▁ref ▁+= ▁4 ▁; ▁} ▁}	0
▁int ▁ff _ am f _ get _ field _ value ▁( ▁const ▁uint 8_ t ▁* ▁data ▁, ▁const ▁uint 8_ t ▁* ▁data _ end ▁, ▁const ▁uint 8_ t ▁* ▁name ▁, ▁uint 8_ t ▁* ▁dst ▁, ▁int ▁dst _ size ▁) ▁{ ▁int ▁namelen ▁= ▁strlen ▁( ▁name ▁) ▁; ▁int ▁len ▁; ▁while ▁( ▁* ▁data ▁!= ▁AM F _ DATA _ TYPE _ OBJECT ▁&& ▁data ▁< ▁data _ end ▁) ▁{ ▁len ▁= ▁ff _ am f _ tag _ size ▁( ▁data ▁, ▁data _ end ▁) ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁len ▁= ▁data _ end ▁- ▁data ▁; ▁data ▁+= ▁len ▁; ▁} ▁if ▁( ▁data _ end ▁- ▁data ▁< ▁3 ▁) ▁return ▁-1 ▁; ▁data ▁++ ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁int ▁size ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁data ▁) ▁; ▁if ▁( ▁! ▁size ▁) ▁break ▁; ▁if ▁( ▁size ▁< ▁0 ▁|| ▁size ▁>= ▁data _ end ▁- ▁data ▁) ▁return ▁-1 ▁; ▁data ▁+= ▁size ▁; ▁if ▁( ▁size ▁== ▁namelen ▁&& ▁! ▁memcmp ▁( ▁data ▁- ▁size ▁, ▁name ▁, ▁namelen ▁) ▁) ▁{ ▁switch ▁( ▁* ▁data ▁++ ▁) ▁{ ▁case ▁AM F _ DATA _ TYPE _ NUMBER ▁: ▁snprintf ▁( ▁dst ▁, ▁dst _ size ▁, ▁"% g " ▁, ▁av _ int 2 double ▁( ▁AV _ RB 64 ▁( ▁data ▁) ▁) ▁) ▁; ▁break ▁; ▁case ▁AM F _ DATA _ TYPE _ BOOL ▁: ▁snprintf ▁( ▁dst ▁, ▁dst _ size ▁, ▁"% s " ▁, ▁* ▁data ▁? ▁" true " ▁: ▁" false " ▁) ▁; ▁break ▁; ▁case ▁AM F _ DATA _ TYPE _ STRING ▁: ▁len ▁= ▁bytestream _ get _ be 16 ▁( ▁& ▁data ▁) ▁; ▁av _ strlcpy ▁( ▁dst ▁, ▁data ▁, ▁FF MIN ▁( ▁len ▁+ ▁1 ▁, ▁dst _ size ▁) ▁) ▁; ▁break ▁; ▁default ▁: ▁return ▁-1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁len ▁= ▁ff _ am f _ tag _ size ▁( ▁data ▁, ▁data _ end ▁) ▁; ▁if ▁( ▁len ▁< ▁0 ▁|| ▁len ▁>= ▁data _ end ▁- ▁data ▁) ▁return ▁-1 ▁; ▁data ▁+= ▁len ▁; ▁} ▁return ▁-1 ▁; ▁}	1
▁static ▁void ▁end _ frame ▁( ▁AVFilter Link ▁* ▁link ▁) ▁{ ▁Un sh arp Context ▁* ▁un sh arp ▁= ▁link ▁-> ▁dst ▁-> ▁priv ▁; ▁AVFilter Buffer Ref ▁* ▁in ▁= ▁link ▁-> ▁cur _ buf ▁; ▁AVFilter Buffer Ref ▁* ▁out ▁= ▁link ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁-> ▁out _ buf ▁; ▁int ▁cw ▁= ▁SHIFT UP ▁( ▁link ▁-> ▁w ▁, ▁un sh arp ▁-> ▁h sub ▁) ▁; ▁int ▁ch ▁= ▁SHIFT UP ▁( ▁link ▁-> ▁h ▁, ▁un sh arp ▁-> ▁v sub ▁) ▁; ▁apply _ un sh arp ▁( ▁out ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁out ▁-> ▁linesize ▁[ ▁0 ▁] ▁, ▁in ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁in ▁-> ▁linesize ▁[ ▁0 ▁] ▁, ▁link ▁-> ▁w ▁, ▁link ▁-> ▁h ▁, ▁& ▁un sh arp ▁-> ▁lum a ▁) ▁; ▁apply _ un sh arp ▁( ▁out ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁out ▁-> ▁linesize ▁[ ▁1 ▁] ▁, ▁in ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁in ▁-> ▁linesize ▁[ ▁1 ▁] ▁, ▁cw ▁, ▁ch ▁, ▁& ▁un sh arp ▁-> ▁chroma ▁) ▁; ▁apply _ un sh arp ▁( ▁out ▁-> ▁data ▁[ ▁2 ▁] ▁, ▁out ▁-> ▁linesize ▁[ ▁2 ▁] ▁, ▁in ▁-> ▁data ▁[ ▁2 ▁] ▁, ▁in ▁-> ▁linesize ▁[ ▁2 ▁] ▁, ▁cw ▁, ▁ch ▁, ▁& ▁un sh arp ▁-> ▁chroma ▁) ▁; ▁ff _ draw _ slice ▁( ▁link ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁, ▁0 ▁, ▁link ▁-> ▁h ▁, ▁1 ▁) ▁; ▁ff _ end _ frame ▁( ▁link ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁) ▁; ▁avfilter _ unref _ buffer ▁( ▁out ▁) ▁; ▁}	0
▁static ▁int ▁p mp _ header ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁P MP Context ▁* ▁p mp ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVIO Context ▁* ▁pb ▁= ▁s ▁-> ▁pb ▁; ▁int ▁tb _ num ▁, ▁tb _ den ▁; ▁uint 32_ t ▁index _ cnt ▁; ▁int ▁audio _ codec _ id ▁= ▁AV _ CODEC _ ID _ NONE ▁; ▁int ▁s rate ▁, ▁channels ▁; ▁int ▁i ▁; ▁uint 64_ t ▁pos ▁; ▁int 64_ t ▁fsize ▁= ▁avio _ size ▁( ▁pb ▁) ▁; ▁AVStream ▁* ▁vst ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁vst ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁vst ▁-> ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ VIDEO ▁; ▁avio _ skip ▁( ▁pb ▁, ▁8 ▁) ▁; ▁switch ▁( ▁avio _ rl 32 ▁( ▁pb ▁) ▁) ▁{ ▁case ▁0 ▁: ▁vst ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ MPEG 4 ▁; ▁break ▁; ▁case ▁1 ▁: ▁vst ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁AV _ CODEC _ ID _ H 264 ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported vide of orm at \ n " ▁) ▁; ▁break ▁; ▁} ▁index _ cnt ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁vst ▁-> ▁codec ▁-> ▁width ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁vst ▁-> ▁codec ▁-> ▁height ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁tb _ num ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁tb _ den ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁avpriv _ set _ pts _ info ▁( ▁vst ▁, ▁32 ▁, ▁tb _ num ▁, ▁tb _ den ▁) ▁; ▁vst ▁-> ▁nb _ frames ▁= ▁index _ cnt ▁; ▁vst ▁-> ▁duration ▁= ▁index _ cnt ▁; ▁switch ▁( ▁avio _ rl 32 ▁( ▁pb ▁) ▁) ▁{ ▁case ▁0 ▁: ▁audio _ codec _ id ▁= ▁AV _ CODEC _ ID _ MP 3 ▁; ▁break ▁; ▁case ▁1 ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" A AC not y et correct ly supported \ n " ▁) ▁; ▁audio _ codec _ id ▁= ▁AV _ CODEC _ ID _ A AC ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported aud iof orm at \ n " ▁) ▁; ▁break ▁; ▁} ▁p mp ▁-> ▁num _ streams ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁+ ▁1 ▁; ▁avio _ skip ▁( ▁pb ▁, ▁10 ▁) ▁; ▁s rate ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁channels ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁+ ▁1 ▁; ▁pos ▁= ▁avio _ tell ▁( ▁pb ▁) ▁+ ▁4 LL ▁* ▁index _ cnt ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁index _ cnt ▁; ▁i ▁++ ▁) ▁{ ▁uint 32_ t ▁size ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁int ▁flags ▁= ▁size ▁& ▁1 ▁? ▁AV INDEX _ KEY FRAME ▁: ▁0 ▁; ▁if ▁( ▁url _ fe of ▁( ▁pb ▁) ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ FATAL ▁, ▁" En countered EOF wh il ere ading index .\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁size ▁>>= ▁1 ▁; ▁if ▁( ▁size ▁< ▁9 ▁+ ▁4 ▁* ▁p mp ▁-> ▁num _ streams ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Packet too small \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁av _ add _ index _ entry ▁( ▁vst ▁, ▁pos ▁, ▁i ▁, ▁size ▁, ▁0 ▁, ▁flags ▁) ▁; ▁pos ▁+= ▁size ▁; ▁if ▁( ▁fsize ▁> ▁0 ▁&& ▁i ▁== ▁0 ▁&& ▁pos ▁> ▁fsize ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" File ends be fo ref irst packet \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁p mp ▁-> ▁num _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁ast ▁= ▁avformat _ new _ stream ▁( ▁s ▁, ▁NULL ▁) ▁; ▁if ▁( ▁! ▁ast ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁ast ▁-> ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁ast ▁-> ▁codec ▁-> ▁codec _ id ▁= ▁audio _ codec _ id ▁; ▁ast ▁-> ▁codec ▁-> ▁channels ▁= ▁channels ▁; ▁ast ▁-> ▁codec ▁-> ▁sample _ rate ▁= ▁s rate ▁; ▁avpriv _ set _ pts _ info ▁( ▁ast ▁, ▁32 ▁, ▁1 ▁, ▁s rate ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁d nx hd _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁D NX HD Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁Thread Frame ▁frame ▁= ▁{ ▁. ▁f ▁= ▁data ▁} ▁; ▁AVFrame ▁* ▁picture ▁= ▁data ▁; ▁int ▁first _ field ▁= ▁1 ▁; ▁int ▁ret ▁, ▁i ▁; ▁ff _ d log ▁( ▁avctx ▁, ▁" frames ize % d \ n " ▁, ▁buf _ size ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁thread _ count ▁; ▁i ▁++ ▁) ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁format ▁= ▁-1 ▁; ▁decode _ coding _ unit ▁: ▁if ▁( ▁( ▁ret ▁= ▁d nx hd _ decode _ header ▁( ▁ctx ▁, ▁picture ▁, ▁buf ▁, ▁buf _ size ▁, ▁first _ field ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁avctx ▁-> ▁width ▁|| ▁avctx ▁-> ▁height ▁) ▁&& ▁( ▁ctx ▁-> ▁width ▁!= ▁avctx ▁-> ▁width ▁|| ▁ctx ▁-> ▁height ▁!= ▁avctx ▁-> ▁height ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" frames ize changed :% dx % d -> % dx % d \ n " ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁, ▁ctx ▁-> ▁width ▁, ▁ctx ▁-> ▁height ▁) ▁; ▁first _ field ▁= ▁1 ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ NONE ▁&& ▁avctx ▁-> ▁pix _ fmt ▁!= ▁ctx ▁-> ▁pix _ fmt ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" pix _ fmt changed :% s -> % s \ n " ▁, ▁av _ get _ pix _ fmt _ name ▁( ▁avctx ▁-> ▁pix _ fmt ▁) ▁, ▁av _ get _ pix _ fmt _ name ▁( ▁ctx ▁-> ▁pix _ fmt ▁) ▁) ▁; ▁first _ field ▁= ▁1 ▁; ▁} ▁avctx ▁-> ▁pix _ fmt ▁= ▁ctx ▁-> ▁pix _ fmt ▁; ▁ret ▁= ▁ff _ set _ dimensions ▁( ▁avctx ▁, ▁ctx ▁-> ▁width ▁, ▁ctx ▁-> ▁height ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁first _ field ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁ff _ thread _ get _ buffer ▁( ▁avctx ▁, ▁& ▁frame ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁picture ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁picture ▁-> ▁key _ frame ▁= ▁1 ▁; ▁} ▁ctx ▁-> ▁buf _ size ▁= ▁buf _ size ▁- ▁ctx ▁-> ▁data _ offset ▁; ▁ctx ▁-> ▁buf ▁= ▁buf ▁+ ▁ctx ▁-> ▁data _ offset ▁; ▁avctx ▁-> ▁execute 2 ▁( ▁avctx ▁, ▁d nx hd _ decode _ row ▁, ▁picture ▁, ▁NULL ▁, ▁ctx ▁-> ▁mb _ height ▁) ▁; ▁if ▁( ▁first _ field ▁&& ▁picture ▁-> ▁inter l aced _ frame ▁) ▁{ ▁buf ▁+= ▁ctx ▁-> ▁cid _ table ▁-> ▁coding _ unit _ size ▁; ▁buf _ size ▁-= ▁ctx ▁-> ▁cid _ table ▁-> ▁coding _ unit _ size ▁; ▁first _ field ▁= ▁0 ▁; ▁goto ▁decode _ coding _ unit ▁; ▁} ▁ret ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁+= ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁errors ▁; ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁errors ▁= ▁0 ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁act ▁) ▁{ ▁static ▁int ▁act _ warn ed ▁; ▁int ▁format ▁= ▁ctx ▁-> ▁rows ▁[ ▁0 ▁] ▁. ▁format ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁avctx ▁-> ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁format ▁!= ▁format ▁&& ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁format ▁!= ▁-1 ▁) ▁{ ▁format ▁= ▁2 ▁; ▁break ▁; ▁} ▁} ▁switch ▁( ▁format ▁) ▁{ ▁case ▁-1 ▁: ▁case ▁2 ▁: ▁if ▁( ▁! ▁act _ warn ed ▁) ▁{ ▁act _ warn ed ▁= ▁1 ▁; ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported : variable ACT flag .\ n " ▁) ▁; ▁} ▁break ▁; ▁case ▁0 ▁: ▁ctx ▁-> ▁pix _ fmt ▁= ▁ctx ▁-> ▁bit _ depth ▁== ▁10 ▁? ▁AV _ PIX _ FMT _ GB RP 10 ▁: ▁AV _ PIX _ FMT _ GB RP 12 ▁; ▁break ▁; ▁case ▁1 ▁: ▁ctx ▁-> ▁pix _ fmt ▁= ▁ctx ▁-> ▁bit _ depth ▁== ▁10 ▁? ▁AV _ PIX _ FMT _ YUV 444 P 10 ▁: ▁AV _ PIX _ FMT _ YUV 444 P 12 ▁; ▁break ▁; ▁} ▁} ▁avctx ▁-> ▁pix _ fmt ▁= ▁ctx ▁-> ▁pix _ fmt ▁; ▁if ▁( ▁ret ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"% d lines with errors \ n " ▁, ▁ret ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁* ▁got _ frame ▁= ▁1 ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁}	1
▁static ▁void ▁get _ tag ▁( ▁AVFormatContext ▁* ▁s ▁, ▁const ▁char ▁* ▁key ▁, ▁int ▁type ▁, ▁int ▁len ▁, ▁int ▁type 2_ size ▁) ▁{ ▁char ▁* ▁value ▁; ▁int 64_ t ▁off ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁; ▁# define ▁LEN ▁22 ▁if ▁( ▁( ▁unsigned ▁) ▁len ▁>= ▁( ▁UINT _ MAX ▁- ▁LEN ▁) ▁/ ▁2 ▁) ▁return ▁; ▁value ▁= ▁av _ malloc ▁( ▁2 ▁* ▁len ▁+ ▁LEN ▁) ▁; ▁if ▁( ▁! ▁value ▁) ▁goto ▁finish ▁; ▁if ▁( ▁type ▁== ▁0 ▁) ▁{ ▁avio _ get _ str 16 le ▁( ▁s ▁-> ▁pb ▁, ▁len ▁, ▁value ▁, ▁2 ▁* ▁len ▁+ ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁-1 ▁) ▁{ ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁value ▁, ▁len ▁) ▁; ▁value ▁[ ▁len ▁] ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁1 ▁) ▁{ ▁if ▁( ▁! ▁strcmp ▁( ▁key ▁, ▁" WM / Picture " ▁) ▁) ▁{ ▁as f _ read _ picture ▁( ▁s ▁, ▁len ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁key ▁, ▁" ID 3" ▁) ▁) ▁{ ▁get _ id 3_ tag ▁( ▁s ▁, ▁len ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" Unsupported byte array int ag % s .\ n " ▁, ▁key ▁) ▁; ▁} ▁goto ▁finish ▁; ▁} ▁else ▁if ▁( ▁type ▁> ▁1 ▁&& ▁type ▁<= ▁5 ▁) ▁{ ▁uint 64_ t ▁num ▁= ▁get _ value ▁( ▁s ▁-> ▁pb ▁, ▁type ▁, ▁type 2_ size ▁) ▁; ▁snprintf ▁( ▁value ▁, ▁LEN ▁, ▁"%" ▁PRIu 64 ▁, ▁num ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁6 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Unsupported GUID value int ag % s .\ n " ▁, ▁key ▁) ▁; ▁goto ▁finish ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Unsupported valu etype % d int ag % s .\ n " ▁, ▁type ▁, ▁key ▁) ▁; ▁goto ▁finish ▁; ▁} ▁if ▁( ▁* ▁value ▁) ▁av _ dict _ set ▁( ▁& ▁s ▁-> ▁metadata ▁, ▁key ▁, ▁value ▁, ▁0 ▁) ▁; ▁finish ▁: ▁av _ freep ▁( ▁& ▁value ▁) ▁; ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁off ▁+ ▁len ▁, ▁SEEK _ SET ▁) ▁; ▁}	0
▁c 44 8_ error _ t ▁c 44 8_ ed 44 8_ verify ▁( ▁const ▁uint 8_ t ▁signature ▁[ ▁E DD SA _44 8_ SIGNATURE _ BYTES ▁] ▁, ▁const ▁uint 8_ t ▁pubkey ▁[ ▁E DD SA _44 8_ PUBLIC _ BYTES ▁] ▁, ▁const ▁uint 8_ t ▁* ▁message ▁, ▁size _ t ▁message _ len ▁, ▁uint 8_ t ▁pre hash ed ▁, ▁const ▁uint 8_ t ▁* ▁context ▁, ▁uint 8_ t ▁context _ len ▁) ▁{ ▁curve 44 8_ point _ t ▁pk _ point ▁, ▁r _ point ▁; ▁c 44 8_ error _ t ▁error ▁= ▁curve 44 8_ point _ decode _ like _ ed dsa _ and _ mul _ by _ ratio ▁( ▁pk _ point ▁, ▁pubkey ▁) ▁; ▁curve 44 8_ scalar _ t ▁challenge _ scalar ▁; ▁curve 44 8_ scalar _ t ▁response _ scalar ▁; ▁if ▁( ▁C 44 8_ SUCCESS ▁!= ▁error ▁) ▁return ▁error ▁; ▁error ▁= ▁curve 44 8_ point _ decode _ like _ ed dsa _ and _ mul _ by _ ratio ▁( ▁r _ point ▁, ▁signature ▁) ▁; ▁if ▁( ▁C 44 8_ SUCCESS ▁!= ▁error ▁) ▁return ▁error ▁; ▁{ ▁EVP _ MD _ CTX ▁* ▁hash ctx ▁= ▁EVP _ MD _ CTX _ new ▁( ▁) ▁; ▁uint 8_ t ▁challenge ▁[ ▁2 ▁* ▁E DD SA _44 8_ PRIVATE _ BYTES ▁] ▁; ▁if ▁( ▁hash ctx ▁== ▁NULL ▁|| ▁! ▁hash _ init _ with _ dom ▁( ▁hash ctx ▁, ▁pre hash ed ▁, ▁0 ▁, ▁context ▁, ▁context _ len ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁hash ctx ▁, ▁signature ▁, ▁E DD SA _44 8_ PUBLIC _ BYTES ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁hash ctx ▁, ▁pubkey ▁, ▁E DD SA _44 8_ PUBLIC _ BYTES ▁) ▁|| ▁! ▁EVP _ DigestUpdate ▁( ▁hash ctx ▁, ▁message ▁, ▁message _ len ▁) ▁|| ▁! ▁EVP _ Digest Final X OF ▁( ▁hash ctx ▁, ▁challenge ▁, ▁sizeof ▁( ▁challenge ▁) ▁) ▁) ▁{ ▁EVP _ MD _ CTX _ free ▁( ▁hash ctx ▁) ▁; ▁return ▁C 44 8_ FAILURE ▁; ▁} ▁EVP _ MD _ CTX _ free ▁( ▁hash ctx ▁) ▁; ▁curve 44 8_ scalar _ decode _ long ▁( ▁challenge _ scalar ▁, ▁challenge ▁, ▁sizeof ▁( ▁challenge ▁) ▁) ▁; ▁OPENSSL _ cleanse ▁( ▁challenge ▁, ▁sizeof ▁( ▁challenge ▁) ▁) ▁; ▁} ▁curve 44 8_ scalar _ sub ▁( ▁challenge _ scalar ▁, ▁curve 44 8_ scalar _ zero ▁, ▁challenge _ scalar ▁) ▁; ▁curve 44 8_ scalar _ decode _ long ▁( ▁response _ scalar ▁, ▁& ▁signature ▁[ ▁E DD SA _44 8_ PUBLIC _ BYTES ▁] ▁, ▁E DD SA _44 8_ PRIVATE _ BYTES ▁) ▁; ▁curve 44 8_ base _ double _ scalarm ul _ non _ secret ▁( ▁pk _ point ▁, ▁response _ scalar ▁, ▁pk _ point ▁, ▁challenge _ scalar ▁) ▁; ▁return ▁c 44 8_ su cceed _ if ▁( ▁curve 44 8_ point _ eq ▁( ▁pk _ point ▁, ▁r _ point ▁) ▁) ▁; ▁}	1
▁static ▁void ▁* ▁APR _ THREAD _ FUNC ▁worker _ thread ▁( ▁apr _ thread _ t ▁* ▁thd ▁, ▁void ▁* ▁dummy ▁) ▁{ ▁proc _ info ▁* ▁ti ▁= ▁dummy ▁; ▁int ▁process _ slot ▁= ▁ti ▁-> ▁pid ▁; ▁int ▁thread _ slot ▁= ▁ti ▁-> ▁tid ▁; ▁apr _ socket _ t ▁* ▁cs d ▁= ▁NULL ▁; ▁event _ conn _ state _ t ▁* ▁cs ▁; ▁apr _ pool _ t ▁* ▁ptr ans ▁; ▁apr _ status _ t ▁rv ▁; ▁int ▁is _ idle ▁= ▁0 ▁; ▁timer _ event _ t ▁* ▁te ▁= ▁NULL ▁; ▁free ▁( ▁ti ▁) ▁; ▁ap _ score board _ image ▁-> ▁servers ▁[ ▁process _ slot ▁] ▁[ ▁thread _ slot ▁] ▁. ▁pid ▁= ▁ap _ my _ pid ▁; ▁ap _ score board _ image ▁-> ▁servers ▁[ ▁process _ slot ▁] ▁[ ▁thread _ slot ▁] ▁. ▁tid ▁= ▁apr _ os _ thread _ current ▁( ▁) ▁; ▁ap _ score board _ image ▁-> ▁servers ▁[ ▁process _ slot ▁] ▁[ ▁thread _ slot ▁] ▁. ▁generation ▁= ▁retained ▁-> ▁my _ generation ▁; ▁ap _ update _ child _ status _ from _ indexes ▁( ▁process _ slot ▁, ▁thread _ slot ▁, ▁SERVER _ START ING ▁, ▁NULL ▁) ▁; ▁while ▁( ▁! ▁workers _ may _ exit ▁) ▁{ ▁if ▁( ▁! ▁is _ idle ▁) ▁{ ▁rv ▁= ▁ap _ queue _ info _ set _ idle ▁( ▁worker _ queue _ info ▁, ▁NULL ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ EMERG ▁, ▁rv ▁, ▁ap _ server _ conf ▁, ▁" ap _ queue _ info _ set _ idle failed . Attemp ting to " ▁" shutdown process gr ace fully ." ▁) ▁; ▁signal _ threads ▁( ▁ST _ GR ACE FUL ▁) ▁; ▁break ▁; ▁} ▁is _ idle ▁= ▁1 ▁; ▁} ▁ap _ update _ child _ status _ from _ indexes ▁( ▁process _ slot ▁, ▁thread _ slot ▁, ▁d ying ▁? ▁SERVER _ GR ACE FUL ▁: ▁SERVER _ READY ▁, ▁NULL ▁) ▁; ▁worker _ pop ▁: ▁if ▁( ▁workers _ may _ exit ▁) ▁{ ▁break ▁; ▁} ▁te ▁= ▁NULL ▁; ▁rv ▁= ▁ap _ queue _ pop _ something ▁( ▁worker _ queue ▁, ▁& ▁cs d ▁, ▁& ▁cs ▁, ▁& ▁ptr ans ▁, ▁& ▁te ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁) ▁{ ▁if ▁( ▁APR _ STATUS _ IS _ EOF ▁( ▁rv ▁) ▁) ▁{ ▁break ▁; ▁} ▁else ▁if ▁( ▁APR _ STATUS _ IS _ E INTR ▁( ▁rv ▁) ▁) ▁{ ▁goto ▁worker _ pop ▁; ▁} ▁else ▁if ▁( ▁! ▁workers _ may _ exit ▁) ▁{ ▁ap _ log _ error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ CRIT ▁, ▁rv ▁, ▁ap _ server _ conf ▁, ▁" ap _ queue _ pop failed " ▁) ▁; ▁} ▁continue ▁; ▁} ▁if ▁( ▁te ▁!= ▁NULL ▁) ▁{ ▁te ▁-> ▁cb func ▁( ▁te ▁-> ▁bat on ▁) ▁; ▁{ ▁apr _ thread _ mutex _ lock ▁( ▁g _ timer _ ring _ mtx ▁) ▁; ▁APR _ RING _ INSERT _ TAIL ▁( ▁& ▁timer _ free _ ring ▁, ▁te ▁, ▁timer _ event _ t ▁, ▁link ▁) ▁; ▁apr _ thread _ mutex _ unlock ▁( ▁g _ timer _ ring _ mtx ▁) ▁; ▁} ▁} ▁else ▁{ ▁is _ idle ▁= ▁0 ▁; ▁worker _ sockets ▁[ ▁thread _ slot ▁] ▁= ▁cs d ▁; ▁rv ▁= ▁process _ socket ▁( ▁thd ▁, ▁ptr ans ▁, ▁cs d ▁, ▁cs ▁, ▁process _ slot ▁, ▁thread _ slot ▁) ▁; ▁if ▁( ▁! ▁rv ▁) ▁{ ▁requests _ this _ child ▁-- ▁; ▁} ▁worker _ sockets ▁[ ▁thread _ slot ▁] ▁= ▁NULL ▁; ▁} ▁} ▁ap _ update _ child _ status _ from _ indexes ▁( ▁process _ slot ▁, ▁thread _ slot ▁, ▁d ying ▁? ▁SERVER _ DEAD ▁: ▁SERVER _ GR ACE FUL ▁, ▁( ▁request _ rec ▁* ▁) ▁NULL ▁) ▁; ▁apr _ thread _ exit ▁( ▁thd ▁, ▁APR _ SUCCESS ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁update _ prob ▁( ▁VP 56 Range Coder ▁* ▁c ▁, ▁int ▁p ▁) ▁{ ▁static ▁const ▁int ▁inv _ map _ table ▁[ ▁254 ▁] ▁= ▁{ ▁7 ▁, ▁20 ▁, ▁33 ▁, ▁46 ▁, ▁59 ▁, ▁72 ▁, ▁85 ▁, ▁98 ▁, ▁111 ▁, ▁124 ▁, ▁13 7 ▁, ▁150 ▁, ▁16 3 ▁, ▁176 ▁, ▁1 89 ▁, ▁202 ▁, ▁2 15 ▁, ▁2 28 ▁, ▁24 1 ▁, ▁254 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁8 ▁, ▁9 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁, ▁17 ▁, ▁18 ▁, ▁19 ▁, ▁21 ▁, ▁22 ▁, ▁23 ▁, ▁24 ▁, ▁25 ▁, ▁26 ▁, ▁27 ▁, ▁28 ▁, ▁29 ▁, ▁30 ▁, ▁31 ▁, ▁32 ▁, ▁34 ▁, ▁35 ▁, ▁36 ▁, ▁37 ▁, ▁38 ▁, ▁39 ▁, ▁40 ▁, ▁41 ▁, ▁42 ▁, ▁43 ▁, ▁44 ▁, ▁45 ▁, ▁47 ▁, ▁48 ▁, ▁49 ▁, ▁50 ▁, ▁51 ▁, ▁52 ▁, ▁53 ▁, ▁54 ▁, ▁55 ▁, ▁56 ▁, ▁57 ▁, ▁58 ▁, ▁60 ▁, ▁61 ▁, ▁62 ▁, ▁63 ▁, ▁64 ▁, ▁65 ▁, ▁66 ▁, ▁67 ▁, ▁68 ▁, ▁69 ▁, ▁70 ▁, ▁71 ▁, ▁73 ▁, ▁74 ▁, ▁75 ▁, ▁76 ▁, ▁77 ▁, ▁78 ▁, ▁79 ▁, ▁80 ▁, ▁81 ▁, ▁82 ▁, ▁83 ▁, ▁84 ▁, ▁86 ▁, ▁87 ▁, ▁88 ▁, ▁89 ▁, ▁90 ▁, ▁91 ▁, ▁92 ▁, ▁93 ▁, ▁94 ▁, ▁95 ▁, ▁96 ▁, ▁97 ▁, ▁99 ▁, ▁100 ▁, ▁101 ▁, ▁102 ▁, ▁103 ▁, ▁104 ▁, ▁105 ▁, ▁106 ▁, ▁107 ▁, ▁108 ▁, ▁109 ▁, ▁110 ▁, ▁112 ▁, ▁113 ▁, ▁114 ▁, ▁115 ▁, ▁116 ▁, ▁117 ▁, ▁118 ▁, ▁119 ▁, ▁120 ▁, ▁121 ▁, ▁122 ▁, ▁123 ▁, ▁125 ▁, ▁126 ▁, ▁127 ▁, ▁128 ▁, ▁129 ▁, ▁130 ▁, ▁131 ▁, ▁132 ▁, ▁133 ▁, ▁134 ▁, ▁135 ▁, ▁136 ▁, ▁138 ▁, ▁139 ▁, ▁140 ▁, ▁14 1 ▁, ▁14 2 ▁, ▁143 ▁, ▁144 ▁, ▁14 5 ▁, ▁14 6 ▁, ▁14 7 ▁, ▁14 8 ▁, ▁14 9 ▁, ▁15 1 ▁, ▁152 ▁, ▁153 ▁, ▁154 ▁, ▁155 ▁, ▁156 ▁, ▁15 7 ▁, ▁15 8 ▁, ▁15 9 ▁, ▁160 ▁, ▁16 1 ▁, ▁16 2 ▁, ▁1 64 ▁, ▁165 ▁, ▁166 ▁, ▁16 7 ▁, ▁168 ▁, ▁16 9 ▁, ▁170 ▁, ▁17 1 ▁, ▁17 2 ▁, ▁17 3 ▁, ▁1 74 ▁, ▁175 ▁, ▁1 77 ▁, ▁1 78 ▁, ▁17 9 ▁, ▁180 ▁, ▁18 1 ▁, ▁18 2 ▁, ▁18 3 ▁, ▁184 ▁, ▁1 85 ▁, ▁1 86 ▁, ▁1 87 ▁, ▁1 88 ▁, ▁190 ▁, ▁191 ▁, ▁192 ▁, ▁19 3 ▁, ▁19 4 ▁, ▁19 5 ▁, ▁196 ▁, ▁19 7 ▁, ▁19 8 ▁, ▁199 ▁, ▁200 ▁, ▁201 ▁, ▁203 ▁, ▁204 ▁, ▁205 ▁, ▁20 6 ▁, ▁20 7 ▁, ▁208 ▁, ▁209 ▁, ▁210 ▁, ▁2 11 ▁, ▁212 ▁, ▁213 ▁, ▁214 ▁, ▁216 ▁, ▁2 17 ▁, ▁2 18 ▁, ▁2 19 ▁, ▁220 ▁, ▁2 21 ▁, ▁222 ▁, ▁2 23 ▁, ▁224 ▁, ▁225 ▁, ▁2 26 ▁, ▁2 27 ▁, ▁2 29 ▁, ▁230 ▁, ▁231 ▁, ▁2 32 ▁, ▁2 33 ▁, ▁234 ▁, ▁235 ▁, ▁2 36 ▁, ▁2 37 ▁, ▁2 38 ▁, ▁2 39 ▁, ▁240 ▁, ▁24 2 ▁, ▁24 3 ▁, ▁2 44 ▁, ▁24 5 ▁, ▁24 6 ▁, ▁24 7 ▁, ▁248 ▁, ▁24 9 ▁, ▁250 ▁, ▁25 1 ▁, ▁252 ▁, ▁253 ▁, ▁} ▁; ▁int ▁d ▁; ▁if ▁( ▁! ▁vp 8_ rac _ get ▁( ▁c ▁) ▁) ▁{ ▁d ▁= ▁vp 8_ rac _ get _ uint ▁( ▁c ▁, ▁4 ▁) ▁+ ▁0 ▁; ▁} ▁else ▁if ▁( ▁! ▁vp 8_ rac _ get ▁( ▁c ▁) ▁) ▁{ ▁d ▁= ▁vp 8_ rac _ get _ uint ▁( ▁c ▁, ▁4 ▁) ▁+ ▁16 ▁; ▁} ▁else ▁if ▁( ▁! ▁vp 8_ rac _ get ▁( ▁c ▁) ▁) ▁{ ▁d ▁= ▁vp 8_ rac _ get _ uint ▁( ▁c ▁, ▁5 ▁) ▁+ ▁32 ▁; ▁} ▁else ▁{ ▁d ▁= ▁vp 8_ rac _ get _ uint ▁( ▁c ▁, ▁7 ▁) ▁; ▁if ▁( ▁d ▁>= ▁65 ▁) ▁d ▁= ▁( ▁d ▁<< ▁1 ▁) ▁- ▁65 ▁+ ▁vp 8_ rac _ get ▁( ▁c ▁) ▁; ▁d ▁+= ▁64 ▁; ▁} ▁return ▁p ▁<= ▁128 ▁? ▁1 ▁+ ▁inv _ rec enter _ non neg ▁( ▁inv _ map _ table ▁[ ▁d ▁] ▁, ▁p ▁- ▁1 ▁) ▁: ▁255 ▁- ▁inv _ rec enter _ non neg ▁( ▁inv _ map _ table ▁[ ▁d ▁] ▁, ▁255 ▁- ▁p ▁) ▁; ▁}	1
▁static ▁void ▁byte out ▁( ▁M qc State ▁* ▁mqc ▁) ▁{ ▁retry ▁: ▁if ▁( ▁* ▁mqc ▁-> ▁bp ▁== ▁0 xff ▁) ▁{ ▁mqc ▁-> ▁bp ▁++ ▁; ▁* ▁mqc ▁-> ▁bp ▁= ▁mqc ▁-> ▁c ▁>> ▁20 ▁; ▁mqc ▁-> ▁c ▁&= ▁0 xfffff ▁; ▁mqc ▁-> ▁ct ▁= ▁7 ▁; ▁} ▁else ▁if ▁( ▁( ▁mqc ▁-> ▁c ▁& ▁0 x 8000000 ▁) ▁) ▁{ ▁( ▁* ▁mqc ▁-> ▁bp ▁) ▁++ ▁; ▁mqc ▁-> ▁c ▁&= ▁0 x 7 ffffff ▁; ▁goto ▁retry ▁; ▁} ▁else ▁{ ▁mqc ▁-> ▁bp ▁++ ▁; ▁* ▁mqc ▁-> ▁bp ▁= ▁mqc ▁-> ▁c ▁>> ▁19 ▁; ▁mqc ▁-> ▁c ▁&= ▁0 x 7 ffff ▁; ▁mqc ▁-> ▁ct ▁= ▁8 ▁; ▁} ▁}	1
▁int ▁ff _ dir ac _ go lo mb _ read _16 bit ▁( ▁Dir ac Go lo mb LUT ▁* ▁lut _ ctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁bytes ▁, ▁uint 8_ t ▁* ▁_ dst ▁, ▁int ▁coeffs ▁) ▁{ ▁int ▁i ▁, ▁b ▁, ▁c _ idx ▁= ▁0 ▁; ▁int 16_ t ▁* ▁dst ▁= ▁( ▁int 16_ t ▁* ▁) ▁_ dst ▁; ▁Dir ac Go lo mb LUT ▁* ▁future ▁[ ▁4 ▁] ▁, ▁* ▁l ▁= ▁& ▁lut _ ctx ▁[ ▁2 ▁* ▁L UT _ SIZE ▁+ ▁buf ▁[ ▁0 ▁] ▁] ▁; ▁INIT _ RES ID UE ▁( ▁res ▁) ▁; ▁for ▁( ▁b ▁= ▁1 ▁; ▁b ▁<= ▁bytes ▁; ▁b ▁++ ▁) ▁{ ▁future ▁[ ▁0 ▁] ▁= ▁& ▁lut _ ctx ▁[ ▁buf ▁[ ▁b ▁] ▁] ▁; ▁future ▁[ ▁1 ▁] ▁= ▁future ▁[ ▁0 ▁] ▁+ ▁1 ▁* ▁L UT _ SIZE ▁; ▁future ▁[ ▁2 ▁] ▁= ▁future ▁[ ▁0 ▁] ▁+ ▁2 ▁* ▁L UT _ SIZE ▁; ▁future ▁[ ▁3 ▁] ▁= ▁future ▁[ ▁0 ▁] ▁+ ▁3 ▁* ▁L UT _ SIZE ▁; ▁if ▁( ▁( ▁c _ idx ▁+ ▁1 ▁) ▁> ▁coeffs ▁) ▁return ▁c _ idx ▁; ▁if ▁( ▁res _ bits ▁>= ▁R SIZE _ BITS ▁) ▁res _ bits ▁= ▁res ▁= ▁0 ▁; ▁if ▁( ▁res _ bits ▁&& ▁l ▁-> ▁sign ▁) ▁{ ▁int 32_ t ▁coeff ▁= ▁1 ▁; ▁APP END _ RES ID UE ▁( ▁res ▁, ▁l ▁-> ▁p reamble ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁( ▁res _ bits ▁>> ▁1 ▁) ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁coeff ▁<<= ▁1 ▁; ▁coeff ▁|= ▁( ▁res ▁>> ▁( ▁R SIZE _ BITS ▁- ▁2 ▁* ▁i ▁- ▁2 ▁) ▁) ▁& ▁1 ▁; ▁} ▁dst ▁[ ▁c _ idx ▁++ ▁] ▁= ▁l ▁-> ▁sign ▁* ▁( ▁coeff ▁- ▁1 ▁) ▁; ▁res _ bits ▁= ▁res ▁= ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁L UT _ BITS ▁; ▁i ▁++ ▁) ▁dst ▁[ ▁c _ idx ▁+ ▁i ▁] ▁= ▁l ▁-> ▁ready ▁[ ▁i ▁] ▁; ▁c _ idx ▁+= ▁l ▁-> ▁ready _ num ▁; ▁APP END _ RES ID UE ▁( ▁res ▁, ▁l ▁-> ▁lefto ver ▁) ▁; ▁l ▁= ▁future ▁[ ▁l ▁-> ▁need _ s ▁? ▁3 ▁: ▁! ▁res _ bits ▁? ▁2 ▁: ▁res _ bits ▁& ▁1 ▁] ▁; ▁} ▁return ▁c _ idx ▁; ▁}	0
▁static ▁int ▁cache _ control _ remove ▁( ▁request _ rec ▁* ▁r ▁, ▁const ▁char ▁* ▁cc _ header ▁, ▁apr _ table _ t ▁* ▁headers ▁) ▁{ ▁char ▁* ▁last ▁, ▁* ▁s last ▁, ▁* ▁s header ▁; ▁int ▁found ▁= ▁0 ▁; ▁if ▁( ▁cc _ header ▁) ▁{ ▁apr _ status _ t ▁rv ▁; ▁char ▁* ▁header ▁= ▁apr _ p strdup ▁( ▁r ▁-> ▁pool ▁, ▁cc _ header ▁) ▁, ▁* ▁token ▁, ▁* ▁arg ▁; ▁for ▁( ▁rv ▁= ▁cache _ str q tok ▁( ▁header ▁, ▁& ▁token ▁, ▁& ▁arg ▁, ▁& ▁last ▁) ▁; ▁rv ▁== ▁APR _ SUCCESS ▁; ▁rv ▁= ▁cache _ str q tok ▁( ▁NULL ▁, ▁& ▁token ▁, ▁& ▁arg ▁, ▁& ▁last ▁) ▁) ▁{ ▁if ▁( ▁! ▁arg ▁) ▁{ ▁continue ▁; ▁} ▁switch ▁( ▁token ▁[ ▁0 ▁] ▁) ▁{ ▁case ▁' ▁' ▁: ▁case ▁' ▁' ▁: ▁if ▁( ▁! ▁ap _ cstr _ casecmp ▁( ▁token ▁, ▁" no - cache " ▁) ▁) ▁{ ▁for ▁( ▁rv ▁= ▁cache _ str q tok ▁( ▁arg ▁, ▁& ▁s header ▁, ▁NULL ▁, ▁& ▁s last ▁) ▁; ▁rv ▁== ▁APR _ SUCCESS ▁; ▁rv ▁= ▁cache _ str q tok ▁( ▁NULL ▁, ▁& ▁s header ▁, ▁NULL ▁, ▁& ▁s last ▁) ▁) ▁{ ▁apr _ table _ unset ▁( ▁headers ▁, ▁s header ▁) ▁; ▁} ▁found ▁= ▁1 ▁; ▁} ▁break ▁; ▁case ▁' ▁' ▁: ▁case ▁' ▁' ▁: ▁if ▁( ▁! ▁ap _ cstr _ casecmp ▁( ▁token ▁, ▁" private " ▁) ▁) ▁{ ▁for ▁( ▁rv ▁= ▁cache _ str q tok ▁( ▁arg ▁, ▁& ▁s header ▁, ▁NULL ▁, ▁& ▁s last ▁) ▁; ▁rv ▁== ▁APR _ SUCCESS ▁; ▁rv ▁= ▁cache _ str q tok ▁( ▁NULL ▁, ▁& ▁s header ▁, ▁NULL ▁, ▁& ▁s last ▁) ▁) ▁{ ▁apr _ table _ unset ▁( ▁headers ▁, ▁s header ▁) ▁; ▁} ▁found ▁= ▁1 ▁; ▁} ▁break ▁; ▁} ▁} ▁} ▁return ▁found ▁; ▁}	0
▁int ▁CRYPTO _ alloc _ ex _ data ▁( ▁int ▁class _ index ▁, ▁void ▁* ▁obj ▁, ▁CRYPTO _ EX _ DATA ▁* ▁ad ▁, ▁int ▁idx ▁) ▁{ ▁EX _ CALLBACK ▁* ▁f ▁; ▁EX _ CALLBACK S ▁* ▁ip ▁; ▁void ▁* ▁cur val ▁; ▁cur val ▁= ▁CRYPTO _ get _ ex _ data ▁( ▁ad ▁, ▁idx ▁) ▁; ▁if ▁( ▁cur val ▁!= ▁NULL ▁) ▁return ▁1 ▁; ▁ip ▁= ▁get _ and _ lock ▁( ▁class _ index ▁) ▁; ▁if ▁( ▁ip ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁f ▁= ▁sk _ EX _ CALLBACK _ value ▁( ▁ip ▁-> ▁meth ▁, ▁idx ▁) ▁; ▁CRYPTO _ THREAD _ unlock ▁( ▁ex _ data _ lock ▁) ▁; ▁if ▁( ▁f ▁-> ▁new _ func ▁== ▁NULL ▁) ▁return ▁0 ▁; ▁f ▁-> ▁new _ func ▁( ▁obj ▁, ▁cur val ▁, ▁ad ▁, ▁idx ▁, ▁f ▁-> ▁arg l ▁, ▁f ▁-> ▁argp ▁) ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁int ▁adx _ decode _ header ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁bufsize ▁) ▁{ ▁int ▁offset ▁; ▁if ▁( ▁buf ▁[ ▁0 ▁] ▁!= ▁0 x 80 ▁) ▁return ▁0 ▁; ▁offset ▁= ▁( ▁AV _ RB 32 ▁( ▁buf ▁) ▁ ^ ▁0 x 80000000 ▁) ▁+ ▁4 ▁; ▁if ▁( ▁bufsize ▁< ▁offset ▁|| ▁memcmp ▁( ▁buf ▁+ ▁offset ▁- ▁6 ▁, ▁"( c ) CR I " ▁, ▁6 ▁) ▁) ▁return ▁0 ▁; ▁avctx ▁-> ▁channels ▁= ▁buf ▁[ ▁7 ▁] ▁; ▁avctx ▁-> ▁sample _ rate ▁= ▁AV _ RB 32 ▁( ▁buf ▁+ ▁8 ▁) ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁avctx ▁-> ▁sample _ rate ▁* ▁avctx ▁-> ▁channels ▁* ▁18 ▁* ▁8 ▁/ ▁32 ▁; ▁return ▁offset ▁; ▁}	1
▁static ▁void ▁* ▁ev p _ signature _ from _ dispatch ▁( ▁int ▁name _ id ▁, ▁const ▁OSSL _ DISPATCH ▁* ▁fns ▁, ▁OSSL _ PROVIDER ▁* ▁prov ▁, ▁void ▁* ▁v key mgmt _ data ▁) ▁{ ▁struct ▁key mgmt _ data _ st ▁* ▁key mgmt _ data ▁= ▁v key mgmt _ data ▁; ▁EVP _ KEY MG MT ▁* ▁key mgmt ▁= ▁ev p _ key mgmt _ fetch _ by _ number ▁( ▁key mgmt _ data ▁-> ▁ctx ▁, ▁name _ id ▁, ▁key mgmt _ data ▁-> ▁properties ▁) ▁; ▁EVP _ SIGNATURE ▁* ▁signature ▁= ▁NULL ▁; ▁int ▁ctx fn cnt ▁= ▁0 ▁, ▁sign fn cnt ▁= ▁0 ▁, ▁verify fn cnt ▁= ▁0 ▁, ▁verify rec fn cnt ▁= ▁0 ▁; ▁int ▁g param fn cnt ▁= ▁0 ▁, ▁s param fn cnt ▁= ▁0 ▁; ▁if ▁( ▁key mgmt ▁== ▁NULL ▁|| ▁EVP _ KEY MG MT _ provider ▁( ▁key mgmt ▁) ▁!= ▁prov ▁) ▁{ ▁ERR _ raise ▁( ▁ERR _ LIB _ EVP ▁, ▁EVP _ R _ NO _ KEY MG MT _ AVAILABLE ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁signature ▁= ▁ev p _ signature _ new ▁( ▁prov ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁ERR _ raise ▁( ▁ERR _ LIB _ EVP ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁goto ▁err ▁; ▁} ▁signature ▁-> ▁name _ id ▁= ▁name _ id ▁; ▁signature ▁-> ▁key mgmt ▁= ▁key mgmt ▁; ▁key mgmt ▁= ▁NULL ▁; ▁for ▁( ▁; ▁fns ▁-> ▁function _ id ▁!= ▁0 ▁; ▁fns ▁++ ▁) ▁{ ▁switch ▁( ▁fns ▁-> ▁function _ id ▁) ▁{ ▁case ▁OSSL _ FUNC _ SIGNATURE _ NEW CTX ▁: ▁if ▁( ▁signature ▁-> ▁new ctx ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁new ctx ▁= ▁OSSL _ get _ OP _ signature _ new ctx ▁( ▁fns ▁) ▁; ▁ctx fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ SIGN _ INIT ▁: ▁if ▁( ▁signature ▁-> ▁sign _ init ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁sign _ init ▁= ▁OSSL _ get _ OP _ signature _ sign _ init ▁( ▁fns ▁) ▁; ▁sign fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ SIGN ▁: ▁if ▁( ▁signature ▁-> ▁sign ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁sign ▁= ▁OSSL _ get _ OP _ signature _ sign ▁( ▁fns ▁) ▁; ▁sign fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ VERIFY _ INIT ▁: ▁if ▁( ▁signature ▁-> ▁verify _ init ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁verify _ init ▁= ▁OSSL _ get _ OP _ signature _ verify _ init ▁( ▁fns ▁) ▁; ▁verify fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ VERIFY ▁: ▁if ▁( ▁signature ▁-> ▁verify ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁verify ▁= ▁OSSL _ get _ OP _ signature _ verify ▁( ▁fns ▁) ▁; ▁verify fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ VERIFY _ RECOVER _ INIT ▁: ▁if ▁( ▁signature ▁-> ▁verify _ re cover _ init ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁verify _ re cover _ init ▁= ▁OSSL _ get _ OP _ signature _ verify _ re cover _ init ▁( ▁fns ▁) ▁; ▁verify rec fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ VERIFY _ RECOVER ▁: ▁if ▁( ▁signature ▁-> ▁verify _ re cover ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁verify _ re cover ▁= ▁OSSL _ get _ OP _ signature _ verify _ re cover ▁( ▁fns ▁) ▁; ▁verify rec fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ FRE ECT X ▁: ▁if ▁( ▁signature ▁-> ▁fre ect x ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁fre ect x ▁= ▁OSSL _ get _ OP _ signature _ fre ect x ▁( ▁fns ▁) ▁; ▁ctx fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ DUP CTX ▁: ▁if ▁( ▁signature ▁-> ▁dup ctx ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁dup ctx ▁= ▁OSSL _ get _ OP _ signature _ dup ctx ▁( ▁fns ▁) ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ GET _ CTX _ PARAMS ▁: ▁if ▁( ▁signature ▁-> ▁get _ ctx _ params ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁get _ ctx _ params ▁= ▁OSSL _ get _ OP _ signature _ get _ ctx _ params ▁( ▁fns ▁) ▁; ▁g param fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ GET TABLE _ CTX _ PARAMS ▁: ▁if ▁( ▁signature ▁-> ▁get table _ ctx _ params ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁get table _ ctx _ params ▁= ▁OSSL _ get _ OP _ signature _ get table _ ctx _ params ▁( ▁fns ▁) ▁; ▁g param fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ SET _ CTX _ PARAMS ▁: ▁if ▁( ▁signature ▁-> ▁set _ ctx _ params ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁set _ ctx _ params ▁= ▁OSSL _ get _ OP _ signature _ set _ ctx _ params ▁( ▁fns ▁) ▁; ▁s param fn cnt ▁++ ▁; ▁break ▁; ▁case ▁OSSL _ FUNC _ SIGNATURE _ SET TABLE _ CTX _ PARAMS ▁: ▁if ▁( ▁signature ▁-> ▁set table _ ctx _ params ▁!= ▁NULL ▁) ▁break ▁; ▁signature ▁-> ▁set table _ ctx _ params ▁= ▁OSSL _ get _ OP _ signature _ set table _ ctx _ params ▁( ▁fns ▁) ▁; ▁s param fn cnt ▁++ ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁ctx fn cnt ▁!= ▁2 ▁|| ▁( ▁sign fn cnt ▁!= ▁2 ▁&& ▁verify fn cnt ▁!= ▁2 ▁&& ▁verify rec fn cnt ▁!= ▁2 ▁) ▁|| ▁( ▁g param fn cnt ▁!= ▁0 ▁&& ▁g param fn cnt ▁!= ▁2 ▁) ▁|| ▁( ▁s param fn cnt ▁!= ▁0 ▁&& ▁s param fn cnt ▁!= ▁2 ▁) ▁) ▁{ ▁ERR _ raise ▁( ▁ERR _ LIB _ EVP ▁, ▁EVP _ R _ INVALID _ PROVIDER _ FUNCTIONS ▁) ▁; ▁goto ▁err ▁; ▁} ▁return ▁signature ▁; ▁err ▁: ▁EVP _ SIGNATURE _ free ▁( ▁signature ▁) ▁; ▁EVP _ KEY MG MT _ free ▁( ▁key mgmt ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁static ▁void ▁dvb sub _ parse _ pixel _ data _ block ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁DVB Sub Object Display ▁* ▁display ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁buf _ size ▁, ▁int ▁top _ bottom ▁, ▁int ▁non _ mod ▁) ▁{ ▁DVB Sub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁DVB Sub Region ▁* ▁region ▁= ▁get _ region ▁( ▁ctx ▁, ▁display ▁-> ▁region _ id ▁) ▁; ▁const ▁uint 8_ t ▁* ▁buf _ end ▁= ▁buf ▁+ ▁buf _ size ▁; ▁uint 8_ t ▁* ▁pbuf ▁; ▁int ▁x _ pos ▁, ▁y _ pos ▁; ▁int ▁i ▁; ▁uint 8_ t ▁map 2 to 4 ▁[ ▁] ▁= ▁{ ▁0 x 0 ▁, ▁0 x 7 ▁, ▁0 x 8 ▁, ▁0 xf ▁} ▁; ▁uint 8_ t ▁map 2 to 8 ▁[ ▁] ▁= ▁{ ▁0 x 00 ▁, ▁0 x 77 ▁, ▁0 x 88 ▁, ▁0 xff ▁} ▁; ▁uint 8_ t ▁map 4 to 8 ▁[ ▁] ▁= ▁{ ▁0 x 00 ▁, ▁0 x 11 ▁, ▁0 x 22 ▁, ▁0 x 33 ▁, ▁0 x 44 ▁, ▁0 x 55 ▁, ▁0 x 66 ▁, ▁0 x 77 ▁, ▁0 x 88 ▁, ▁0 x 99 ▁, ▁0 xaa ▁, ▁0 xbb ▁, ▁0 xcc ▁, ▁0 xdd ▁, ▁0 xee ▁, ▁0 xff ▁} ▁; ▁uint 8_ t ▁* ▁map _ table ▁; ▁av _ d log ▁( ▁avctx ▁, ▁" D VB pixel blocksize % d ,% s field :\ n " ▁, ▁buf _ size ▁, ▁top _ bottom ▁? ▁" bottom " ▁: ▁" top " ▁) ▁; ▁# ifdef ▁DEBUG _ PACKET _ CONT ENTS ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁buf _ size ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁% ▁16 ▁== ▁0 ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ INFO ▁, ▁"0 x %08 p :" ▁, ▁buf ▁+ ▁i ▁) ▁; ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ INFO ▁, ▁"%02 x " ▁, ▁buf ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁i ▁% ▁16 ▁== ▁15 ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ INFO ▁, ▁"\ n " ▁) ▁; ▁} ▁if ▁( ▁i ▁% ▁16 ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ INFO ▁, ▁"\ n " ▁) ▁; ▁# endif ▁if ▁( ▁region ▁== ▁0 ▁) ▁return ▁; ▁pbuf ▁= ▁region ▁-> ▁pbuf ▁; ▁x _ pos ▁= ▁display ▁-> ▁x _ pos ▁; ▁y _ pos ▁= ▁display ▁-> ▁y _ pos ▁; ▁if ▁( ▁( ▁y _ pos ▁& ▁1 ▁) ▁!= ▁top _ bottom ▁) ▁y _ pos ▁++ ▁; ▁while ▁( ▁buf ▁< ▁buf _ end ▁) ▁{ ▁if ▁( ▁x _ pos ▁> ▁region ▁-> ▁width ▁|| ▁y _ pos ▁> ▁region ▁-> ▁height ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid object location !\ n " ▁) ▁; ▁return ▁; ▁} ▁switch ▁( ▁* ▁buf ▁++ ▁) ▁{ ▁case ▁0 x 10 ▁: ▁if ▁( ▁region ▁-> ▁depth ▁== ▁8 ▁) ▁map _ table ▁= ▁map 2 to 8 ▁; ▁else ▁if ▁( ▁region ▁-> ▁depth ▁== ▁4 ▁) ▁map _ table ▁= ▁map 2 to 4 ▁; ▁else ▁map _ table ▁= ▁NULL ▁; ▁x _ pos ▁+= ▁dvb sub _ read _2 bit _ string ▁( ▁pbuf ▁+ ▁( ▁y _ pos ▁* ▁region ▁-> ▁width ▁) ▁+ ▁x _ pos ▁, ▁region ▁-> ▁width ▁- ▁x _ pos ▁, ▁& ▁buf ▁, ▁buf _ end ▁- ▁buf ▁, ▁non _ mod ▁, ▁map _ table ▁) ▁; ▁break ▁; ▁case ▁0 x 11 ▁: ▁if ▁( ▁region ▁-> ▁depth ▁< ▁4 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"4 - bit pixel string in % d - bit region !\ n " ▁, ▁region ▁-> ▁depth ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁region ▁-> ▁depth ▁== ▁8 ▁) ▁map _ table ▁= ▁map 4 to 8 ▁; ▁else ▁map _ table ▁= ▁NULL ▁; ▁x _ pos ▁+= ▁dvb sub _ read _4 bit _ string ▁( ▁pbuf ▁+ ▁( ▁y _ pos ▁* ▁region ▁-> ▁width ▁) ▁+ ▁x _ pos ▁, ▁region ▁-> ▁width ▁- ▁x _ pos ▁, ▁& ▁buf ▁, ▁buf _ end ▁- ▁buf ▁, ▁non _ mod ▁, ▁map _ table ▁) ▁; ▁break ▁; ▁case ▁0 x 12 ▁: ▁if ▁( ▁region ▁-> ▁depth ▁< ▁8 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" 8- bit pixel string in % d - bit region !\ n " ▁, ▁region ▁-> ▁depth ▁) ▁; ▁return ▁; ▁} ▁x _ pos ▁+= ▁dvb sub _ read _8 bit _ string ▁( ▁pbuf ▁+ ▁( ▁y _ pos ▁* ▁region ▁-> ▁width ▁) ▁+ ▁x _ pos ▁, ▁region ▁-> ▁width ▁- ▁x _ pos ▁, ▁& ▁buf ▁, ▁buf _ end ▁- ▁buf ▁, ▁non _ mod ▁, ▁NULL ▁) ▁; ▁break ▁; ▁case ▁0 x 20 ▁: ▁map 2 to 4 ▁[ ▁0 ▁] ▁= ▁( ▁* ▁buf ▁) ▁>> ▁4 ▁; ▁map 2 to 4 ▁[ ▁1 ▁] ▁= ▁( ▁* ▁buf ▁++ ▁) ▁& ▁0 xf ▁; ▁map 2 to 4 ▁[ ▁2 ▁] ▁= ▁( ▁* ▁buf ▁) ▁>> ▁4 ▁; ▁map 2 to 4 ▁[ ▁3 ▁] ▁= ▁( ▁* ▁buf ▁++ ▁) ▁& ▁0 xf ▁; ▁break ▁; ▁case ▁0 x 21 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁map 2 to 8 ▁[ ▁i ▁] ▁= ▁* ▁buf ▁++ ▁; ▁break ▁; ▁case ▁0 x 22 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁16 ▁; ▁i ▁++ ▁) ▁map 4 to 8 ▁[ ▁i ▁] ▁= ▁* ▁buf ▁++ ▁; ▁break ▁; ▁case ▁0 xf 0 ▁: ▁x _ pos ▁= ▁display ▁-> ▁x _ pos ▁; ▁y _ pos ▁+= ▁2 ▁; ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ INFO ▁, ▁" Unknown / unsupported pixel block 0 x % x \ n " ▁, ▁* ▁( ▁buf ▁- ▁1 ▁) ▁) ▁; ▁} ▁} ▁}	0
▁static ▁inline ▁struct ▁rgb vec ▁interp _ tri linear ▁( ▁const ▁L UT 3 D Context ▁* ▁lut 3 d ▁, ▁const ▁struct ▁rgb vec ▁* ▁s ▁) ▁{ ▁const ▁int ▁prev ▁[ ▁] ▁= ▁{ ▁PRE V ▁( ▁s ▁-> ▁r ▁) ▁, ▁PRE V ▁( ▁s ▁-> ▁g ▁) ▁, ▁PRE V ▁( ▁s ▁-> ▁b ▁) ▁} ▁; ▁const ▁int ▁next ▁[ ▁] ▁= ▁{ ▁NEXT ▁( ▁s ▁-> ▁r ▁) ▁, ▁NEXT ▁( ▁s ▁-> ▁g ▁) ▁, ▁NEXT ▁( ▁s ▁-> ▁b ▁) ▁} ▁; ▁const ▁struct ▁rgb vec ▁d ▁= ▁{ ▁s ▁-> ▁r ▁- ▁prev ▁[ ▁0 ▁] ▁, ▁s ▁-> ▁g ▁- ▁prev ▁[ ▁1 ▁] ▁, ▁s ▁-> ▁b ▁- ▁prev ▁[ ▁2 ▁] ▁} ▁; ▁const ▁struct ▁rgb vec ▁c 000 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁prev ▁[ ▁0 ▁] ▁] ▁[ ▁prev ▁[ ▁1 ▁] ▁] ▁[ ▁prev ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 001 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁prev ▁[ ▁0 ▁] ▁] ▁[ ▁prev ▁[ ▁1 ▁] ▁] ▁[ ▁next ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 010 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁prev ▁[ ▁0 ▁] ▁] ▁[ ▁next ▁[ ▁1 ▁] ▁] ▁[ ▁prev ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 011 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁prev ▁[ ▁0 ▁] ▁] ▁[ ▁next ▁[ ▁1 ▁] ▁] ▁[ ▁next ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 100 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁next ▁[ ▁0 ▁] ▁] ▁[ ▁prev ▁[ ▁1 ▁] ▁] ▁[ ▁prev ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 101 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁next ▁[ ▁0 ▁] ▁] ▁[ ▁prev ▁[ ▁1 ▁] ▁] ▁[ ▁next ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 110 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁next ▁[ ▁0 ▁] ▁] ▁[ ▁next ▁[ ▁1 ▁] ▁] ▁[ ▁prev ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 111 ▁= ▁lut 3 d ▁-> ▁lut ▁[ ▁next ▁[ ▁0 ▁] ▁] ▁[ ▁next ▁[ ▁1 ▁] ▁] ▁[ ▁next ▁[ ▁2 ▁] ▁] ▁; ▁const ▁struct ▁rgb vec ▁c 00 ▁= ▁l erp ▁( ▁& ▁c 000 ▁, ▁& ▁c 100 ▁, ▁d ▁. ▁r ▁) ▁; ▁const ▁struct ▁rgb vec ▁c 10 ▁= ▁l erp ▁( ▁& ▁c 010 ▁, ▁& ▁c 110 ▁, ▁d ▁. ▁r ▁) ▁; ▁const ▁struct ▁rgb vec ▁c 01 ▁= ▁l erp ▁( ▁& ▁c 001 ▁, ▁& ▁c 101 ▁, ▁d ▁. ▁r ▁) ▁; ▁const ▁struct ▁rgb vec ▁c 11 ▁= ▁l erp ▁( ▁& ▁c 011 ▁, ▁& ▁c 111 ▁, ▁d ▁. ▁r ▁) ▁; ▁const ▁struct ▁rgb vec ▁c 0 ▁= ▁l erp ▁( ▁& ▁c 00 ▁, ▁& ▁c 10 ▁, ▁d ▁. ▁g ▁) ▁; ▁const ▁struct ▁rgb vec ▁c 1 ▁= ▁l erp ▁( ▁& ▁c 01 ▁, ▁& ▁c 11 ▁, ▁d ▁. ▁g ▁) ▁; ▁const ▁struct ▁rgb vec ▁c ▁= ▁l erp ▁( ▁& ▁c 0 ▁, ▁& ▁c 1 ▁, ▁d ▁. ▁b ▁) ▁; ▁return ▁c ▁; ▁}	0
▁int ▁ssl 3_ new ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁SSL 3_ CTX ▁* ▁s 3 ▁; ▁if ▁( ▁( ▁s 3 ▁= ▁( ▁SSL 3_ CTX ▁* ▁) ▁Malloc ▁( ▁sizeof ▁( ▁SSL 3_ CTX ▁) ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁memset ▁( ▁s 3 ▁, ▁0 ▁, ▁sizeof ▁( ▁SSL 3_ CTX ▁) ▁) ▁; ▁s ▁-> ▁s 3 ▁= ▁s 3 ▁; ▁s ▁-> ▁method ▁-> ▁ssl _ clear ▁( ▁s ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁err ▁: ▁return ▁( ▁0 ▁) ▁; ▁}	1
▁void ▁wait _ for _ async ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁int ▁width ▁, ▁fd ▁; ▁fd _ set ▁async fds ▁; ▁fd ▁= ▁SSL _ get _ async _ wait _ fd ▁( ▁s ▁) ▁; ▁if ▁( ▁fd ▁< ▁0 ▁) ▁return ▁; ▁width ▁= ▁fd ▁+ ▁1 ▁; ▁FD _ ZERO ▁( ▁& ▁async fds ▁) ▁; ▁openssl _ fd set ▁( ▁fd ▁, ▁& ▁async fds ▁) ▁; ▁select ▁( ▁width ▁, ▁( ▁void ▁* ▁) ▁& ▁async fds ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁}	1
▁static ▁void ▁de quant ization _ float ▁( ▁int ▁x ▁, ▁int ▁y ▁, ▁J peg 2000 C blk ▁* ▁cb lk ▁, ▁J peg 2000 Component ▁* ▁comp ▁, ▁J peg 2000 T 1 Context ▁* ▁t 1 ▁, ▁J peg 2000 Band ▁* ▁band ▁) ▁{ ▁int ▁i ▁, ▁j ▁; ▁int ▁w ▁= ▁cb lk ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁- ▁cb lk ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁( ▁cb lk ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁- ▁cb lk ▁-> ▁coord ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁) ▁; ▁++ ▁j ▁) ▁{ ▁float ▁* ▁datap ▁= ▁& ▁comp ▁-> ▁f _ data ▁[ ▁( ▁comp ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁- ▁comp ▁-> ▁coord ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁) ▁* ▁( ▁y ▁+ ▁j ▁) ▁+ ▁x ▁] ▁; ▁int ▁* ▁src ▁= ▁t 1 ▁-> ▁data ▁+ ▁j ▁* ▁t 1 ▁-> ▁stride ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁w ▁; ▁++ ▁i ▁) ▁datap ▁[ ▁i ▁] ▁= ▁src ▁[ ▁i ▁] ▁* ▁band ▁-> ▁f _ step size ▁; ▁} ▁}	0
▁static ▁int ▁iv i _ init _ tiles ▁( ▁IV IB and Desc ▁* ▁band ▁, ▁IV IT ile ▁* ▁ref _ tile ▁, ▁int ▁p ▁, ▁int ▁b ▁, ▁int ▁t _ height ▁, ▁int ▁t _ width ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁IV IT ile ▁* ▁tile ▁= ▁band ▁-> ▁tiles ▁; ▁for ▁( ▁y ▁= ▁0 ▁; ▁y ▁< ▁band ▁-> ▁height ▁; ▁y ▁+= ▁t _ height ▁) ▁{ ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁band ▁-> ▁width ▁; ▁x ▁+= ▁t _ width ▁) ▁{ ▁tile ▁-> ▁xpos ▁= ▁x ▁; ▁tile ▁-> ▁ypos ▁= ▁y ▁; ▁tile ▁-> ▁mb _ size ▁= ▁band ▁-> ▁mb _ size ▁; ▁tile ▁-> ▁width ▁= ▁FF MIN ▁( ▁band ▁-> ▁width ▁- ▁x ▁, ▁t _ width ▁) ▁; ▁tile ▁-> ▁height ▁= ▁FF MIN ▁( ▁band ▁-> ▁height ▁- ▁y ▁, ▁t _ height ▁) ▁; ▁tile ▁-> ▁is _ empty ▁= ▁tile ▁-> ▁data _ size ▁= ▁0 ▁; ▁tile ▁-> ▁num _ MB s ▁= ▁I VI _ MB s _ PER _ TILE ▁( ▁tile ▁-> ▁width ▁, ▁tile ▁-> ▁height ▁, ▁band ▁-> ▁mb _ size ▁) ▁; ▁av _ freep ▁( ▁& ▁tile ▁-> ▁mbs ▁) ▁; ▁tile ▁-> ▁mbs ▁= ▁av _ malloc z ▁( ▁tile ▁-> ▁num _ MB s ▁* ▁sizeof ▁( ▁IV IM b Info ▁) ▁) ▁; ▁if ▁( ▁! ▁tile ▁-> ▁mbs ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁tile ▁-> ▁ref _ mb s ▁= ▁0 ▁; ▁if ▁( ▁p ▁|| ▁b ▁) ▁{ ▁if ▁( ▁tile ▁-> ▁num _ MB s ▁!= ▁ref _ tile ▁-> ▁num _ MB s ▁) ▁{ ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ DEBUG ▁, ▁" ref _ tile mismatch \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁tile ▁-> ▁ref _ mb s ▁= ▁ref _ tile ▁-> ▁mbs ▁; ▁ref _ tile ▁++ ▁; ▁} ▁tile ▁++ ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	0
▁int ▁ff _ h 264_ execute _ decode _ s lices ▁( ▁H 264 Context ▁* ▁h ▁, ▁unsigned ▁context _ count ▁) ▁{ ▁AVCodecContext ▁* ▁const ▁avctx ▁= ▁h ▁-> ▁avctx ▁; ▁H 264 Slice Context ▁* ▁sl ▁; ▁int ▁i ▁, ▁j ▁; ▁if ▁( ▁h ▁-> ▁avctx ▁-> ▁hw accel ▁) ▁return ▁0 ▁; ▁if ▁( ▁context _ count ▁== ▁1 ▁) ▁{ ▁int ▁ret ▁; ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁. ▁next _ slice _ idx ▁= ▁h ▁-> ▁mb _ width ▁* ▁h ▁-> ▁mb _ height ▁; ▁ret ▁= ▁decode _ slice ▁( ▁avctx ▁, ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁) ▁; ▁h ▁-> ▁mb _ y ▁= ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁. ▁mb _ y ▁; ▁return ▁ret ▁; ▁} ▁else ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁context _ count ▁; ▁i ▁++ ▁) ▁{ ▁int ▁next _ slice _ idx ▁= ▁h ▁-> ▁mb _ width ▁* ▁h ▁-> ▁mb _ height ▁; ▁int ▁slice _ idx ▁; ▁sl ▁= ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁i ▁] ▁; ▁sl ▁-> ▁er ▁. ▁error _ count ▁= ▁0 ▁; ▁slice _ idx ▁= ▁sl ▁-> ▁mb _ y ▁* ▁h ▁-> ▁mb _ width ▁+ ▁sl ▁-> ▁mb _ x ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁context _ count ▁; ▁j ▁++ ▁) ▁{ ▁H 264 Slice Context ▁* ▁sl 2 ▁= ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁j ▁] ▁; ▁int ▁slice _ idx 2 ▁= ▁sl 2 ▁-> ▁mb _ y ▁* ▁h ▁-> ▁mb _ width ▁+ ▁sl 2 ▁-> ▁mb _ x ▁; ▁if ▁( ▁i ▁== ▁j ▁|| ▁slice _ idx 2 ▁< ▁slice _ idx ▁) ▁continue ▁; ▁next _ slice _ idx ▁= ▁FF MIN ▁( ▁next _ slice _ idx ▁, ▁slice _ idx 2 ▁) ▁; ▁} ▁sl ▁-> ▁next _ slice _ idx ▁= ▁next _ slice _ idx ▁; ▁} ▁avctx ▁-> ▁execute ▁( ▁avctx ▁, ▁decode _ slice ▁, ▁h ▁-> ▁slice _ ctx ▁, ▁NULL ▁, ▁context _ count ▁, ▁sizeof ▁( ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁) ▁) ▁; ▁sl ▁= ▁& ▁h ▁-> ▁slice _ ctx ▁[ ▁context _ count ▁- ▁1 ▁] ▁; ▁h ▁-> ▁mb _ y ▁= ▁sl ▁-> ▁mb _ y ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁context _ count ▁; ▁i ▁++ ▁) ▁h ▁-> ▁slice _ ctx ▁[ ▁0 ▁] ▁. ▁er ▁. ▁error _ count ▁+= ▁h ▁-> ▁slice _ ctx ▁[ ▁i ▁] ▁. ▁er ▁. ▁error _ count ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁save _ sub title _ set ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AV Subtitle ▁* ▁sub ▁, ▁int ▁* ▁got _ output ▁) ▁{ ▁DVB Sub Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁DVB Sub Region Display ▁* ▁display ▁; ▁DVB Sub Display Definition ▁* ▁display _ def ▁= ▁ctx ▁-> ▁display _ definition ▁; ▁DVB Sub Region ▁* ▁region ▁; ▁AV Subtitle Rect ▁* ▁rect ▁; ▁DVB Sub CL UT ▁* ▁cl ut ▁; ▁uint 32_ t ▁* ▁cl ut _ table ▁; ▁int ▁i ▁; ▁int ▁offset _ x ▁= ▁0 ▁, ▁offset _ y ▁= ▁0 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁display _ def ▁) ▁{ ▁offset _ x ▁= ▁display _ def ▁-> ▁x ▁; ▁offset _ y ▁= ▁display _ def ▁-> ▁y ▁; ▁} ▁if ▁( ▁sub ▁-> ▁num _ rect s ▁) ▁{ ▁avpriv _ request _ sample ▁( ▁ctx ▁, ▁" Different Version of Segment ask ed Tw ice " ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁for ▁( ▁display ▁= ▁ctx ▁-> ▁display _ list ▁; ▁display ▁; ▁display ▁= ▁display ▁-> ▁next ▁) ▁{ ▁region ▁= ▁get _ region ▁( ▁ctx ▁, ▁display ▁-> ▁region _ id ▁) ▁; ▁if ▁( ▁region ▁&& ▁region ▁-> ▁dirty ▁) ▁sub ▁-> ▁num _ rect s ▁++ ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁compute _ ed t ▁== ▁0 ▁) ▁{ ▁sub ▁-> ▁end _ display _ time ▁= ▁ctx ▁-> ▁time _ out ▁* ▁1000 ▁; ▁* ▁got _ output ▁= ▁1 ▁; ▁} ▁else ▁if ▁( ▁ctx ▁-> ▁prev _ start ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁sub ▁-> ▁end _ display _ time ▁= ▁av _ re scale _ q ▁( ▁( ▁sub ▁-> ▁pts ▁- ▁ctx ▁-> ▁prev _ start ▁) ▁, ▁AV _ TIME _ BASE _ Q ▁, ▁( ▁AVR ational ▁) ▁{ ▁1 ▁, ▁1000 ▁} ▁) ▁- ▁1 ▁; ▁* ▁got _ output ▁= ▁1 ▁; ▁} ▁if ▁( ▁sub ▁-> ▁num _ rect s ▁> ▁0 ▁) ▁{ ▁sub ▁-> ▁rects ▁= ▁av _ malloc z _ array ▁( ▁sizeof ▁( ▁* ▁sub ▁-> ▁rects ▁) ▁, ▁sub ▁-> ▁num _ rect s ▁) ▁; ▁if ▁( ▁! ▁sub ▁-> ▁rects ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sub ▁-> ▁num _ rect s ▁; ▁i ▁++ ▁) ▁{ ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁) ▁) ▁; ▁if ▁( ▁! ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁} ▁i ▁= ▁0 ▁; ▁for ▁( ▁display ▁= ▁ctx ▁-> ▁display _ list ▁; ▁display ▁; ▁display ▁= ▁display ▁-> ▁next ▁) ▁{ ▁region ▁= ▁get _ region ▁( ▁ctx ▁, ▁display ▁-> ▁region _ id ▁) ▁; ▁if ▁( ▁! ▁region ▁) ▁continue ▁; ▁if ▁( ▁! ▁region ▁-> ▁dirty ▁) ▁continue ▁; ▁rect ▁= ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁; ▁rect ▁-> ▁x ▁= ▁display ▁-> ▁x _ pos ▁+ ▁offset _ x ▁; ▁rect ▁-> ▁y ▁= ▁display ▁-> ▁y _ pos ▁+ ▁offset _ y ▁; ▁rect ▁-> ▁w ▁= ▁region ▁-> ▁width ▁; ▁rect ▁-> ▁h ▁= ▁region ▁-> ▁height ▁; ▁rect ▁-> ▁nb _ colors ▁= ▁( ▁1 ▁<< ▁region ▁-> ▁depth ▁) ▁; ▁rect ▁-> ▁type ▁= ▁SUB TITLE _ BITMAP ▁; ▁rect ▁-> ▁linesize ▁[ ▁0 ▁] ▁= ▁region ▁-> ▁width ▁; ▁cl ut ▁= ▁get _ cl ut ▁( ▁ctx ▁, ▁region ▁-> ▁cl ut ▁) ▁; ▁if ▁( ▁! ▁cl ut ▁) ▁cl ut ▁= ▁& ▁default _ cl ut ▁; ▁switch ▁( ▁region ▁-> ▁depth ▁) ▁{ ▁case ▁2 ▁: ▁cl ut _ table ▁= ▁cl ut ▁-> ▁cl ut 4 ▁; ▁break ▁; ▁case ▁8 ▁: ▁cl ut _ table ▁= ▁cl ut ▁-> ▁cl ut 256 ▁; ▁break ▁; ▁case ▁4 ▁: ▁default ▁: ▁cl ut _ table ▁= ▁cl ut ▁-> ▁cl ut 16 ▁; ▁break ▁; ▁} ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁= ▁av _ malloc z ▁( ▁AV PALETTE _ SIZE ▁) ▁; ▁if ▁( ▁! ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁memcpy ▁( ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁cl ut _ table ▁, ▁( ▁1 ▁<< ▁region ▁-> ▁depth ▁) ▁* ▁sizeof ▁( ▁uint 32_ t ▁) ▁) ▁; ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁= ▁av _ malloc ▁( ▁region ▁-> ▁buf _ size ▁) ▁; ▁if ▁( ▁! ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁{ ▁ret ▁= ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁goto ▁fail ▁; ▁} ▁memcpy ▁( ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁region ▁-> ▁pbuf ▁, ▁region ▁-> ▁buf _ size ▁) ▁; ▁if ▁( ▁( ▁cl ut ▁== ▁& ▁default _ cl ut ▁&& ▁ctx ▁-> ▁compute _ cl ut ▁== ▁-1 ▁) ▁|| ▁ctx ▁-> ▁compute _ cl ut ▁== ▁1 ▁) ▁{ ▁if ▁( ▁! ▁region ▁-> ▁has _ computed _ cl ut ▁) ▁{ ▁compute _ default _ cl ut ▁( ▁region ▁-> ▁computed _ cl ut ▁, ▁rect ▁, ▁rect ▁-> ▁w ▁, ▁rect ▁-> ▁h ▁) ▁; ▁region ▁-> ▁has _ computed _ cl ut ▁= ▁1 ▁; ▁} ▁memcpy ▁( ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁, ▁region ▁-> ▁computed _ cl ut ▁, ▁sizeof ▁( ▁region ▁-> ▁computed _ cl ut ▁) ▁) ▁; ▁} ▁# if ▁FF _ API _ AV PICTURE ▁FF _ DISABLE _ DEPREC ATION _ WARNINGS ▁{ ▁int ▁j ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁4 ▁; ▁j ▁++ ▁) ▁{ ▁rect ▁-> ▁pict ▁. ▁data ▁[ ▁j ▁] ▁= ▁rect ▁-> ▁data ▁[ ▁j ▁] ▁; ▁rect ▁-> ▁pict ▁. ▁linesize ▁[ ▁j ▁] ▁= ▁rect ▁-> ▁linesize ▁[ ▁j ▁] ▁; ▁} ▁} ▁FF _ ENABLE _ DEPREC ATION _ WARNINGS ▁# endif ▁i ▁++ ▁; ▁} ▁} ▁return ▁0 ▁; ▁fail ▁: ▁if ▁( ▁sub ▁-> ▁rects ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sub ▁-> ▁num _ rect s ▁; ▁i ▁++ ▁) ▁{ ▁rect ▁= ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁; ▁if ▁( ▁rect ▁) ▁{ ▁av _ freep ▁( ▁& ▁rect ▁-> ▁data ▁[ ▁0 ▁] ▁) ▁; ▁av _ freep ▁( ▁& ▁rect ▁-> ▁data ▁[ ▁1 ▁] ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁sub ▁-> ▁rects ▁[ ▁i ▁] ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁sub ▁-> ▁rects ▁) ▁; ▁} ▁sub ▁-> ▁num _ rect s ▁= ▁0 ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁wipe _ side _ data ▁( ▁AVFrame ▁* ▁frame ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁frame ▁-> ▁nb _ side _ data ▁; ▁i ▁++ ▁) ▁{ ▁free _ side _ data ▁( ▁& ▁frame ▁-> ▁side _ data ▁[ ▁i ▁] ▁) ▁; ▁} ▁frame ▁-> ▁nb _ side _ data ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁frame ▁-> ▁side _ data ▁) ▁; ▁}	1
▁static ▁int ▁addr _ strings ▁( ▁const ▁BIO _ ADDR ▁* ▁ap ▁, ▁int ▁numeric ▁, ▁char ▁* ▁* ▁hostname ▁, ▁char ▁* ▁* ▁service ▁) ▁{ ▁if ▁( ▁BIO _ sock _ init ▁( ▁) ▁!= ▁1 ▁) ▁return ▁0 ▁; ▁if ▁( ▁1 ▁) ▁{ ▁# ifdef ▁AI _ PAS SIVE ▁int ▁ret ▁= ▁0 ▁; ▁char ▁host ▁[ ▁NI _ MAX HOST ▁] ▁= ▁"" ▁, ▁serv ▁[ ▁NI _ MAX SERV ▁] ▁= ▁"" ▁; ▁int ▁flags ▁= ▁0 ▁; ▁if ▁( ▁numeric ▁) ▁flags ▁|= ▁NI _ NUMERIC HOST ▁| ▁NI _ NUMERIC SERV ▁; ▁if ▁( ▁( ▁ret ▁= ▁get nameinfo ▁( ▁BIO _ ADDR _ sockaddr ▁( ▁ap ▁) ▁, ▁BIO _ ADDR _ sockaddr _ size ▁( ▁ap ▁) ▁, ▁host ▁, ▁sizeof ▁( ▁host ▁) ▁, ▁serv ▁, ▁sizeof ▁( ▁serv ▁) ▁, ▁flags ▁) ▁) ▁!= ▁0 ▁) ▁{ ▁# ifdef ▁EAI _ SYSTEM ▁if ▁( ▁ret ▁== ▁EAI _ SYSTEM ▁) ▁{ ▁SYS err ▁( ▁SYS _ F _ GET NAME INFO ▁, ▁get _ last _ socket _ error ▁( ▁) ▁) ▁; ▁BIO err ▁( ▁BIO _ F _ ADDR _ STRINGS ▁, ▁ERR _ R _ SYS _ LIB ▁) ▁; ▁} ▁else ▁# endif ▁{ ▁BIO err ▁( ▁BIO _ F _ ADDR _ STRINGS ▁, ▁ERR _ R _ SYS _ LIB ▁) ▁; ▁ERR _ add _ error _ data ▁( ▁1 ▁, ▁gai _ strerror ▁( ▁ret ▁) ▁) ▁; ▁} ▁return ▁0 ▁; ▁} ▁if ▁( ▁serv ▁[ ▁0 ▁] ▁== ▁' ▁\0 ▁' ▁) ▁{ ▁BIO _ snprintf ▁( ▁serv ▁, ▁sizeof ▁( ▁serv ▁) ▁, ▁"% d " ▁, ▁ntohs ▁( ▁BIO _ ADDR _ raw port ▁( ▁ap ▁) ▁) ▁) ▁; ▁} ▁if ▁( ▁hostname ▁) ▁* ▁hostname ▁= ▁OPENSSL _ strdup ▁( ▁host ▁) ▁; ▁if ▁( ▁service ▁) ▁* ▁service ▁= ▁OPENSSL _ strdup ▁( ▁serv ▁) ▁; ▁} ▁else ▁{ ▁# endif ▁if ( hostname ) ▁* ▁hostname ▁= ▁OPENSSL _ strdup ▁( ▁inet _ ntoa ▁( ▁ap ▁-> ▁sin ▁. ▁sin _ addr ▁) ▁) ▁; ▁if ▁( ▁service ▁) ▁{ ▁char ▁serv ▁[ ▁6 ▁] ▁; ▁BIO _ snprintf ▁( ▁serv ▁, ▁sizeof ▁( ▁serv ▁) ▁, ▁"% d " ▁, ▁ntohs ▁( ▁ap ▁-> ▁sin ▁. ▁sin _ port ▁) ▁) ▁; ▁* ▁service ▁= ▁OPENSSL _ strdup ▁( ▁serv ▁) ▁; ▁} ▁} ▁return ▁1 ▁; ▁}	0
▁int ▁BN _ BL IND ING _ update ▁( ▁BN _ BL IND ING ▁* ▁b ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁if ▁( ▁( ▁b ▁-> ▁A ▁== ▁NULL ▁) ▁|| ▁( ▁b ▁-> ▁Ai ▁== ▁NULL ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ BL IND ING _ UPDATE ▁, ▁BN _ R _ NOT _ INITIALIZED ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁b ▁-> ▁counter ▁== ▁-1 ▁) ▁b ▁-> ▁counter ▁= ▁0 ▁; ▁if ▁( ▁++ ▁b ▁-> ▁counter ▁== ▁BN _ BL IND ING _ COUNTER ▁&& ▁b ▁-> ▁e ▁!= ▁NULL ▁&& ▁! ▁( ▁b ▁-> ▁flags ▁& ▁BN _ BL IND ING _ NO _ RE CREATE ▁) ▁) ▁{ ▁if ▁( ▁! ▁BN _ BL IND ING _ create _ param ▁( ▁b ▁, ▁NULL ▁, ▁NULL ▁, ▁ctx ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁if ▁( ▁! ▁( ▁b ▁-> ▁flags ▁& ▁BN _ BL IND ING _ NO _ UPDATE ▁) ▁) ▁{ ▁if ▁( ▁! ▁BN _ mod _ mul ▁( ▁b ▁-> ▁A ▁, ▁b ▁-> ▁A ▁, ▁b ▁-> ▁A ▁, ▁b ▁-> ▁mod ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ mod _ mul ▁( ▁b ▁-> ▁Ai ▁, ▁b ▁-> ▁Ai ▁, ▁b ▁-> ▁Ai ▁, ▁b ▁-> ▁mod ▁, ▁ctx ▁) ▁) ▁goto ▁err ▁; ▁} ▁ret ▁= ▁1 ▁; ▁err ▁: ▁if ▁( ▁b ▁-> ▁counter ▁== ▁BN _ BL IND ING _ COUNTER ▁) ▁b ▁-> ▁counter ▁= ▁0 ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁int ▁av _ stream _ add _ side _ data ▁( ▁AVStream ▁* ▁st ▁, ▁enum ▁AVPacket Side DataType ▁type ▁, ▁uint 8_ t ▁* ▁data ▁, ▁size _ t ▁size ▁) ▁{ ▁AVPacket Side Data ▁* ▁sd ▁, ▁* ▁tmp ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁st ▁-> ▁nb _ side _ data ▁; ▁i ▁++ ▁) ▁{ ▁sd ▁= ▁& ▁st ▁-> ▁side _ data ▁[ ▁i ▁] ▁; ▁if ▁( ▁sd ▁-> ▁type ▁== ▁type ▁) ▁{ ▁av _ freep ▁( ▁& ▁sd ▁-> ▁data ▁) ▁; ▁sd ▁-> ▁data ▁= ▁data ▁; ▁sd ▁-> ▁size ▁= ▁size ▁; ▁return ▁0 ▁; ▁} ▁} ▁if ▁( ▁( ▁unsigned ▁) ▁st ▁-> ▁nb _ side _ data ▁+ ▁1 ▁>= ▁INT _ MAX ▁/ ▁sizeof ▁( ▁* ▁st ▁-> ▁side _ data ▁) ▁) ▁return ▁AVERROR ▁( ▁ERANGE ▁) ▁; ▁tmp ▁= ▁av _ realloc ▁( ▁st ▁-> ▁side _ data ▁, ▁st ▁-> ▁nb _ side _ data ▁+ ▁1 ▁* ▁sizeof ▁( ▁* ▁tmp ▁) ▁) ▁; ▁if ▁( ▁! ▁tmp ▁) ▁{ ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁st ▁-> ▁side _ data ▁= ▁tmp ▁; ▁st ▁-> ▁nb _ side _ data ▁++ ▁; ▁sd ▁= ▁& ▁st ▁-> ▁side _ data ▁[ ▁st ▁-> ▁nb _ side _ data ▁- ▁1 ▁] ▁; ▁sd ▁-> ▁type ▁= ▁type ▁; ▁sd ▁-> ▁data ▁= ▁data ▁; ▁sd ▁-> ▁size ▁= ▁size ▁; ▁return ▁0 ▁; ▁}	0
▁int ▁BN _ GF 2 m _ mod _ inv ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁p ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁BIGNUM ▁* ▁b ▁, ▁* ▁c ▁, ▁* ▁u ▁, ▁* ▁v ▁, ▁* ▁tmp ▁; ▁int ▁ret ▁= ▁0 ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁p ▁) ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁if ▁( ▁( ▁b ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁c ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁u ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁( ▁v ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ GF 2 m _ mod ▁( ▁u ▁, ▁a ▁, ▁p ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁u ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ copy ▁( ▁v ▁, ▁p ▁) ▁) ▁goto ▁err ▁; ▁# if ▁0 ▁if ▁( ▁! ▁BN _ one ▁( ▁b ▁) ▁) ▁goto ▁err ▁; ▁while ▁( ▁1 ▁) ▁{ ▁while ▁( ▁! ▁BN _ is _ odd ▁( ▁u ▁) ▁) ▁{ ▁if ▁( ▁! ▁BN _ rshift 1 ▁( ▁u ▁, ▁u ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ is _ odd ▁( ▁b ▁) ▁) ▁{ ▁if ▁( ▁! ▁BN _ GF 2 m _ add ▁( ▁b ▁, ▁b ▁, ▁p ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁BN _ rshift 1 ▁( ▁b ▁, ▁b ▁) ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁BN _ abs _ is _ word ▁( ▁u ▁, ▁1 ▁) ▁) ▁break ▁; ▁if ▁( ▁BN _ num _ bits ▁( ▁u ▁) ▁< ▁BN _ num _ bits ▁( ▁v ▁) ▁) ▁{ ▁tmp ▁= ▁u ▁; ▁u ▁= ▁v ▁; ▁v ▁= ▁tmp ▁; ▁tmp ▁= ▁b ▁; ▁b ▁= ▁c ▁; ▁c ▁= ▁tmp ▁; ▁} ▁if ▁( ▁! ▁BN _ GF 2 m _ add ▁( ▁u ▁, ▁u ▁, ▁v ▁) ▁) ▁goto ▁err ▁; ▁if ▁( ▁! ▁BN _ GF 2 m _ add ▁( ▁b ▁, ▁b ▁, ▁c ▁) ▁) ▁goto ▁err ▁; ▁} ▁# else ▁{ ▁int ▁i ▁, ▁ub its ▁= ▁BN _ num _ bits ▁( ▁u ▁) ▁, ▁v bits ▁= ▁BN _ num _ bits ▁( ▁v ▁) ▁, ▁top ▁= ▁p ▁-> ▁top ▁; ▁BN _ ULONG ▁* ▁udp ▁, ▁* ▁b dp ▁, ▁* ▁v dp ▁, ▁* ▁cdp ▁; ▁bn _ w expand ▁( ▁u ▁, ▁top ▁) ▁; ▁udp ▁= ▁u ▁-> ▁d ▁; ▁for ▁( ▁i ▁= ▁u ▁-> ▁top ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁udp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁u ▁-> ▁top ▁= ▁top ▁; ▁bn _ w expand ▁( ▁b ▁, ▁top ▁) ▁; ▁b dp ▁= ▁b ▁-> ▁d ▁; ▁b dp ▁[ ▁0 ▁] ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁b dp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁b ▁-> ▁top ▁= ▁top ▁; ▁bn _ w expand ▁( ▁c ▁, ▁top ▁) ▁; ▁cdp ▁= ▁c ▁-> ▁d ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁cdp ▁[ ▁i ▁] ▁= ▁0 ▁; ▁c ▁-> ▁top ▁= ▁top ▁; ▁v dp ▁= ▁v ▁-> ▁d ▁; ▁while ▁( ▁1 ▁) ▁{ ▁while ▁( ▁ub its ▁&& ▁! ▁( ▁udp ▁[ ▁0 ▁] ▁& ▁1 ▁) ▁) ▁{ ▁BN _ ULONG ▁u 0 ▁, ▁u 1 ▁, ▁b 0 ▁, ▁b 1 ▁, ▁mask ▁; ▁u 0 ▁= ▁udp ▁[ ▁0 ▁] ▁; ▁b 0 ▁= ▁b dp ▁[ ▁0 ▁] ▁; ▁mask ▁= ▁( ▁BN _ ULONG ▁) ▁0 ▁- ▁( ▁b 0 ▁& ▁1 ▁) ▁; ▁b 0 ▁ ^ = ▁p ▁-> ▁d ▁[ ▁0 ▁] ▁& ▁mask ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁- ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁u 1 ▁= ▁udp ▁[ ▁i ▁+ ▁1 ▁] ▁; ▁udp ▁[ ▁i ▁] ▁= ▁( ▁( ▁u 0 ▁>> ▁1 ▁) ▁| ▁( ▁u 1 ▁<< ▁( ▁BN _ BITS 2 ▁- ▁1 ▁) ▁) ▁) ▁& ▁BN _ MASK 2 ▁; ▁u 0 ▁= ▁u 1 ▁; ▁b 1 ▁= ▁b dp ▁[ ▁i ▁+ ▁1 ▁] ▁ ^ ▁( ▁p ▁-> ▁d ▁[ ▁i ▁+ ▁1 ▁] ▁& ▁mask ▁) ▁; ▁b dp ▁[ ▁i ▁] ▁= ▁( ▁( ▁b 0 ▁>> ▁1 ▁) ▁| ▁( ▁b 1 ▁<< ▁( ▁BN _ BITS 2 ▁- ▁1 ▁) ▁) ▁) ▁& ▁BN _ MASK 2 ▁; ▁b 0 ▁= ▁b 1 ▁; ▁} ▁udp ▁[ ▁i ▁] ▁= ▁u 0 ▁>> ▁1 ▁; ▁b dp ▁[ ▁i ▁] ▁= ▁b 0 ▁>> ▁1 ▁; ▁ub its ▁-- ▁; ▁} ▁if ▁( ▁ub its ▁<= ▁BN _ BITS 2 ▁&& ▁udp ▁[ ▁0 ▁] ▁== ▁1 ▁) ▁break ▁; ▁if ▁( ▁ub its ▁< ▁v bits ▁) ▁{ ▁i ▁= ▁ub its ▁; ▁ub its ▁= ▁v bits ▁; ▁v bits ▁= ▁i ▁; ▁tmp ▁= ▁u ▁; ▁u ▁= ▁v ▁; ▁v ▁= ▁tmp ▁; ▁tmp ▁= ▁b ▁; ▁b ▁= ▁c ▁; ▁c ▁= ▁tmp ▁; ▁udp ▁= ▁v dp ▁; ▁v dp ▁= ▁v ▁-> ▁d ▁; ▁b dp ▁= ▁cdp ▁; ▁cdp ▁= ▁c ▁-> ▁d ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁top ▁; ▁i ▁++ ▁) ▁{ ▁udp ▁[ ▁i ▁] ▁ ^ = ▁v dp ▁[ ▁i ▁] ▁; ▁b dp ▁[ ▁i ▁] ▁ ^ = ▁cdp ▁[ ▁i ▁] ▁; ▁} ▁if ▁( ▁ub its ▁== ▁v bits ▁) ▁{ ▁bn _ fix _ top ▁( ▁u ▁) ▁; ▁ub its ▁= ▁BN _ num _ bits ▁( ▁u ▁) ▁; ▁} ▁} ▁bn _ fix _ top ▁( ▁b ▁) ▁; ▁} ▁# endif ▁if ▁( ▁! ▁BN _ copy ▁( ▁r ▁, ▁b ▁) ▁) ▁goto ▁err ▁; ▁bn _ check _ top ▁( ▁r ▁) ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁ASN 1_ INTEGER ▁* ▁c 2 i _ ASN 1_ INTEGER ▁( ▁ASN 1_ INTEGER ▁* ▁* ▁a ▁, ▁unsigned ▁char ▁* ▁* ▁pp ▁, ▁long ▁len ▁) ▁{ ▁ASN 1_ INTEGER ▁* ▁ret ▁= ▁NULL ▁; ▁unsigned ▁char ▁* ▁p ▁, ▁* ▁to ▁, ▁* ▁s ▁, ▁* ▁pend ▁; ▁int ▁i ▁; ▁if ▁( ▁( ▁a ▁== ▁NULL ▁) ▁|| ▁( ▁( ▁* ▁a ▁) ▁== ▁NULL ▁) ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁M _ ASN 1_ INTEGER _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁return ▁( ▁NULL ▁) ▁; ▁ret ▁-> ▁type ▁= ▁V _ ASN 1_ INTEGER ▁; ▁} ▁else ▁ret ▁= ▁( ▁* ▁a ▁) ▁; ▁p ▁= ▁* ▁pp ▁; ▁pend ▁= ▁p ▁+ ▁len ▁; ▁s ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁OPENSSL _ malloc ▁( ▁( ▁int ▁) ▁len ▁+ ▁1 ▁) ▁; ▁if ▁( ▁s ▁== ▁NULL ▁) ▁{ ▁i ▁= ▁ERR _ R _ MALLOC _ FAILURE ▁; ▁goto ▁err ▁; ▁} ▁to ▁= ▁s ▁; ▁if ▁( ▁! ▁len ▁) ▁{ ▁ret ▁-> ▁type ▁= ▁V _ ASN 1_ INTEGER ▁; ▁} ▁else ▁if ▁( ▁* ▁p ▁& ▁0 x 80 ▁) ▁{ ▁ret ▁-> ▁type ▁= ▁V _ ASN 1_ NEG _ INTEGER ▁; ▁if ▁( ▁( ▁* ▁p ▁== ▁0 xff ▁) ▁&& ▁( ▁len ▁!= ▁1 ▁) ▁) ▁{ ▁p ▁++ ▁; ▁len ▁-- ▁; ▁} ▁i ▁= ▁len ▁; ▁p ▁+= ▁i ▁- ▁1 ▁; ▁to ▁+= ▁i ▁- ▁1 ▁; ▁while ▁( ▁( ▁! ▁* ▁p ▁) ▁&& ▁i ▁) ▁{ ▁* ▁( ▁to ▁-- ▁) ▁= ▁0 ▁; ▁i ▁-- ▁; ▁p ▁-- ▁; ▁} ▁if ▁( ▁! ▁i ▁) ▁{ ▁* ▁s ▁= ▁1 ▁; ▁s ▁[ ▁len ▁] ▁= ▁0 ▁; ▁len ▁++ ▁; ▁} ▁else ▁{ ▁* ▁( ▁to ▁-- ▁) ▁= ▁( ▁* ▁( ▁p ▁-- ▁) ▁ ^ ▁0 xff ▁) ▁+ ▁1 ▁; ▁i ▁-- ▁; ▁for ▁( ▁; ▁i ▁> ▁0 ▁; ▁i ▁-- ▁) ▁* ▁( ▁to ▁-- ▁) ▁= ▁* ▁( ▁p ▁-- ▁) ▁ ^ ▁0 xff ▁; ▁} ▁} ▁else ▁{ ▁ret ▁-> ▁type ▁= ▁V _ ASN 1_ INTEGER ▁; ▁if ▁( ▁( ▁* ▁p ▁== ▁0 ▁) ▁&& ▁( ▁len ▁!= ▁1 ▁) ▁) ▁{ ▁p ▁++ ▁; ▁len ▁-- ▁; ▁} ▁memcpy ▁( ▁s ▁, ▁p ▁, ▁( ▁int ▁) ▁len ▁) ▁; ▁} ▁if ▁( ▁ret ▁-> ▁data ▁!= ▁NULL ▁) ▁OPENSSL _ free ▁( ▁ret ▁-> ▁data ▁) ▁; ▁ret ▁-> ▁data ▁= ▁s ▁; ▁ret ▁-> ▁length ▁= ▁( ▁int ▁) ▁len ▁; ▁if ▁( ▁a ▁!= ▁NULL ▁) ▁( ▁* ▁a ▁) ▁= ▁ret ▁; ▁* ▁pp ▁= ▁pend ▁; ▁return ▁( ▁ret ▁) ▁; ▁err ▁: ▁ASN 1 err ▁( ▁ASN 1_ F _ D 2 I _ ASN 1_ INTEGER ▁, ▁i ▁) ▁; ▁if ▁( ▁( ▁ret ▁!= ▁NULL ▁) ▁&& ▁( ▁( ▁a ▁== ▁NULL ▁) ▁|| ▁( ▁* ▁a ▁!= ▁ret ▁) ▁) ▁) ▁M _ ASN 1_ INTEGER _ free ▁( ▁ret ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	1
▁BIGNUM ▁* ▁g ost _ get 0_ priv _ key ▁( ▁const ▁EVP _ PKEY ▁* ▁pkey ▁) ▁{ ▁switch ▁( ▁EVP _ PKEY _ base _ id ▁( ▁pkey ▁) ▁) ▁{ ▁case ▁NID _ id _ G ost R 34 10_ 94 ▁: ▁{ ▁DSA ▁* ▁dsa ▁= ▁EVP _ PKEY _ get 0 ▁( ▁( ▁EVP _ PKEY ▁* ▁) ▁pkey ▁) ▁; ▁if ▁( ▁! ▁dsa ▁) ▁{ ▁return ▁NULL ▁; ▁} ▁if ▁( ▁! ▁dsa ▁-> ▁priv _ key ▁) ▁return ▁NULL ▁; ▁return ▁dsa ▁-> ▁priv _ key ▁; ▁break ▁; ▁} ▁case ▁NID _ id _ G ost R 34 10 _2 001 ▁: ▁{ ▁EC _ KEY ▁* ▁ec ▁= ▁EVP _ PKEY _ get 0 ▁( ▁( ▁EVP _ PKEY ▁* ▁) ▁pkey ▁) ▁; ▁const ▁BIGNUM ▁* ▁priv ▁; ▁if ▁( ▁! ▁ec ▁) ▁{ ▁return ▁NULL ▁; ▁} ▁if ▁( ▁! ▁( ▁priv ▁= ▁EC _ KEY _ get 0_ private _ key ▁( ▁ec ▁) ▁) ▁) ▁return ▁NULL ▁; ▁return ▁( ▁BIGNUM ▁* ▁) ▁priv ▁; ▁break ▁; ▁} ▁} ▁return ▁NULL ▁; ▁}	0
▁static ▁int ▁mov _ read _ col r ▁( ▁MOV Context ▁* ▁c ▁, ▁AVIO Context ▁* ▁pb ▁, ▁MOV Atom ▁atom ▁) ▁{ ▁AVStream ▁* ▁st ▁; ▁char ▁color _ parameter _ type ▁[ ▁5 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁int ▁color _ pri maries ▁, ▁color _ tr c ▁, ▁color _ matrix ▁; ▁if ▁( ▁c ▁-> ▁fc ▁-> ▁nb _ streams ▁< ▁1 ▁) ▁return ▁0 ▁; ▁st ▁= ▁c ▁-> ▁fc ▁-> ▁streams ▁[ ▁c ▁-> ▁fc ▁-> ▁nb _ streams ▁- ▁1 ▁] ▁; ▁avio _ read ▁( ▁pb ▁, ▁color _ parameter _ type ▁, ▁4 ▁) ▁; ▁if ▁( ▁strncmp ▁( ▁color _ parameter _ type ▁, ▁" n cl x " ▁, ▁4 ▁) ▁&& ▁strncmp ▁( ▁color _ parameter _ type ▁, ▁" n cl c " ▁, ▁4 ▁) ▁) ▁{ ▁av _ log ▁( ▁c ▁-> ▁fc ▁, ▁AV _ LOG _ WARNING ▁, ▁" unsupported color _ parameter _ type % s \ n " ▁, ▁color _ parameter _ type ▁) ▁; ▁return ▁0 ▁; ▁} ▁color _ pri maries ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁color _ tr c ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁color _ matrix ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁"% s : pri % dtr c % dm atrix % d " ▁, ▁color _ parameter _ type ▁, ▁color _ pri maries ▁, ▁color _ tr c ▁, ▁color _ matrix ▁) ▁; ▁if ▁( ▁strncmp ▁( ▁color _ parameter _ type ▁, ▁" n cl x " ▁, ▁4 ▁) ▁== ▁0 ▁) ▁{ ▁uint 8_ t ▁color _ range ▁= ▁avio _ r 8 ▁( ▁pb ▁) ▁>> ▁7 ▁; ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁" full %" ▁PRIu 8 ▁"" ▁, ▁color _ range ▁) ▁; ▁if ▁( ▁color _ range ▁) ▁st ▁-> ▁codec ▁-> ▁color _ range ▁= ▁AV COL _ RANGE _ JPEG ▁; ▁else ▁st ▁-> ▁codec ▁-> ▁color _ range ▁= ▁AV COL _ RANGE _ MPEG ▁; ▁if ▁( ▁color _ pri maries ▁>= ▁AV COL _ PRI _ FIL M ▁) ▁color _ pri maries ▁= ▁AV COL _ PRI _ UNSPEC IFIED ▁; ▁if ▁( ▁( ▁color _ tr c ▁>= ▁AV COL _ TR C _ LINEAR ▁&& ▁color _ tr c ▁<= ▁AV COL _ TR C _ LOG _ SQRT ▁) ▁|| ▁color _ tr c ▁>= ▁AV COL _ TR C _ BT 202 0_ 10 ▁) ▁color _ tr c ▁= ▁AV COL _ TR C _ UNSPEC IFIED ▁; ▁if ▁( ▁color _ matrix ▁>= ▁AV COL _ SPC _ BT 202 0_ N CL ▁) ▁color _ matrix ▁= ▁AV COL _ SPC _ UNSPEC IFIED ▁; ▁st ▁-> ▁codec ▁-> ▁color _ pri maries ▁= ▁color _ pri maries ▁; ▁st ▁-> ▁codec ▁-> ▁color _ tr c ▁= ▁color _ tr c ▁; ▁st ▁-> ▁codec ▁-> ▁colors pace ▁= ▁color _ matrix ▁; ▁} ▁else ▁{ ▁switch ▁( ▁color _ pri maries ▁) ▁{ ▁case ▁1 ▁: ▁st ▁-> ▁codec ▁-> ▁color _ pri maries ▁= ▁AV COL _ PRI _ BT 709 ▁; ▁break ▁; ▁case ▁5 ▁: ▁st ▁-> ▁codec ▁-> ▁color _ pri maries ▁= ▁AV COL _ PRI _ SMP TE 170 M ▁; ▁break ▁; ▁case ▁6 ▁: ▁st ▁-> ▁codec ▁-> ▁color _ pri maries ▁= ▁AV COL _ PRI _ SMP TE 240 M ▁; ▁break ▁; ▁} ▁switch ▁( ▁color _ tr c ▁) ▁{ ▁case ▁1 ▁: ▁st ▁-> ▁codec ▁-> ▁color _ tr c ▁= ▁AV COL _ TR C _ BT 709 ▁; ▁break ▁; ▁case ▁7 ▁: ▁st ▁-> ▁codec ▁-> ▁color _ tr c ▁= ▁AV COL _ TR C _ SMP TE 240 M ▁; ▁break ▁; ▁} ▁switch ▁( ▁color _ matrix ▁) ▁{ ▁case ▁1 ▁: ▁st ▁-> ▁codec ▁-> ▁colors pace ▁= ▁AV COL _ SPC _ BT 709 ▁; ▁break ▁; ▁case ▁6 ▁: ▁st ▁-> ▁codec ▁-> ▁colors pace ▁= ▁AV COL _ SPC _ BT 47 0 BG ▁; ▁break ▁; ▁case ▁7 ▁: ▁st ▁-> ▁codec ▁-> ▁colors pace ▁= ▁AV COL _ SPC _ SMP TE 240 M ▁; ▁break ▁; ▁} ▁} ▁av _ d log ▁( ▁c ▁-> ▁fc ▁, ▁"\ n " ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁void ▁sh _ free ▁( ▁char ▁* ▁ptr ▁) ▁{ ▁size _ t ▁list ▁; ▁char ▁* ▁buddy ▁; ▁if ▁( ▁ptr ▁== ▁NULL ▁) ▁return ▁; ▁OPENSSL _ assert ▁( ▁WITH IN _ AR ENA ▁( ▁ptr ▁) ▁) ▁; ▁if ▁( ▁! ▁WITH IN _ AR ENA ▁( ▁ptr ▁) ▁) ▁return ▁; ▁list ▁= ▁sh _ get list ▁( ▁ptr ▁) ▁; ▁OPENSSL _ assert ▁( ▁sh _ test bit ▁( ▁ptr ▁, ▁list ▁, ▁sh ▁. ▁bit table ▁) ▁) ▁; ▁sh _ clear bit ▁( ▁ptr ▁, ▁list ▁, ▁sh ▁. ▁bit malloc ▁) ▁; ▁sh _ add _ to _ list ▁( ▁& ▁sh ▁. ▁fre elist ▁[ ▁list ▁] ▁, ▁ptr ▁) ▁; ▁while ▁( ▁( ▁buddy ▁= ▁sh _ find _ my _ buddy ▁( ▁ptr ▁, ▁list ▁) ▁) ▁!= ▁NULL ▁) ▁{ ▁OPENSSL _ assert ▁( ▁ptr ▁== ▁sh _ find _ my _ buddy ▁( ▁buddy ▁, ▁list ▁) ▁) ▁; ▁OPENSSL _ assert ▁( ▁ptr ▁!= ▁NULL ▁) ▁; ▁OPENSSL _ assert ▁( ▁! ▁sh _ test bit ▁( ▁ptr ▁, ▁list ▁, ▁sh ▁. ▁bit malloc ▁) ▁) ▁; ▁sh _ clear bit ▁( ▁ptr ▁, ▁list ▁, ▁sh ▁. ▁bit table ▁) ▁; ▁sh _ remove _ from _ list ▁( ▁ptr ▁) ▁; ▁OPENSSL _ assert ▁( ▁! ▁sh _ test bit ▁( ▁ptr ▁, ▁list ▁, ▁sh ▁. ▁bit malloc ▁) ▁) ▁; ▁sh _ clear bit ▁( ▁buddy ▁, ▁list ▁, ▁sh ▁. ▁bit table ▁) ▁; ▁sh _ remove _ from _ list ▁( ▁buddy ▁) ▁; ▁list ▁-- ▁; ▁if ▁( ▁ptr ▁> ▁buddy ▁) ▁ptr ▁= ▁buddy ▁; ▁OPENSSL _ assert ▁( ▁! ▁sh _ test bit ▁( ▁ptr ▁, ▁list ▁, ▁sh ▁. ▁bit malloc ▁) ▁) ▁; ▁sh _ set bit ▁( ▁ptr ▁, ▁list ▁, ▁sh ▁. ▁bit table ▁) ▁; ▁sh _ add _ to _ list ▁( ▁& ▁sh ▁. ▁fre elist ▁[ ▁list ▁] ▁, ▁ptr ▁) ▁; ▁OPENSSL _ assert ▁( ▁sh ▁. ▁fre elist ▁[ ▁list ▁] ▁== ▁ptr ▁) ▁; ▁} ▁}	0
▁void ▁ff _ aac _ search _ for _ t ns ▁( ▁AAC Enc Context ▁* ▁s ▁, ▁Single Channel Element ▁* ▁sce ▁) ▁{ ▁Temporal Noise Sh ap ing ▁* ▁t ns ▁= ▁& ▁sce ▁-> ▁t ns ▁; ▁double ▁gain ▁, ▁co efs ▁[ ▁MAX _ LPC _ ORDER ▁] ▁; ▁int ▁w ▁, ▁w 2 ▁, ▁g ▁, ▁count ▁= ▁0 ▁; ▁const ▁int ▁m mm ▁= ▁FF MIN ▁( ▁sce ▁-> ▁ics ▁. ▁t ns _ max _ band s ▁, ▁sce ▁-> ▁ics ▁. ▁max _ s fb ▁) ▁; ▁const ▁int ▁is 8 ▁= ▁sce ▁-> ▁ics ▁. ▁window _ sequence ▁[ ▁0 ▁] ▁== ▁E IGHT _ SHORT _ SEQUENCE ▁; ▁const ▁int ▁c _ bits ▁= ▁is 8 ▁? ▁T NS _ Q _ BITS _ IS 8 ▁== ▁4 ▁: ▁T NS _ Q _ BITS ▁== ▁4 ▁; ▁const ▁int ▁sl ant ▁= ▁sce ▁-> ▁ics ▁. ▁window _ sequence ▁[ ▁0 ▁] ▁== ▁LONG _ STOP _ SEQUENCE ▁? ▁1 ▁: ▁sce ▁-> ▁ics ▁. ▁window _ sequence ▁[ ▁0 ▁] ▁== ▁LONG _ START _ SEQUENCE ▁? ▁0 ▁: ▁2 ▁; ▁int ▁sf b _ start ▁= ▁av _ clip ▁( ▁t ns _ min _ s fb ▁[ ▁is 8 ▁] ▁[ ▁s ▁-> ▁sampler ate _ index ▁] ▁, ▁0 ▁, ▁m mm ▁) ▁; ▁int ▁sf b _ end ▁= ▁av _ clip ▁( ▁sce ▁-> ▁ics ▁. ▁num _ sw b ▁, ▁0 ▁, ▁m mm ▁) ▁; ▁int ▁order ▁= ▁is 8 ▁? ▁5 ▁: ▁s ▁-> ▁profile ▁== ▁FF _ PROFILE _ A AC _ LOW ▁? ▁12 ▁: ▁T NS _ MAX _ ORDER ▁; ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁sce ▁-> ▁ics ▁. ▁num _ windows ▁; ▁w ▁++ ▁) ▁{ ▁float ▁en ▁[ ▁2 ▁] ▁= ▁{ ▁0.0 f ▁, ▁0.0 f ▁} ▁; ▁int ▁coef _ start ▁= ▁w ▁* ▁sce ▁-> ▁ics ▁. ▁num _ sw b ▁+ ▁sce ▁-> ▁ics ▁. ▁sw b _ offset ▁[ ▁sf b _ start ▁] ▁; ▁int ▁coef _ len ▁= ▁sce ▁-> ▁ics ▁. ▁sw b _ offset ▁[ ▁sf b _ end ▁] ▁- ▁sce ▁-> ▁ics ▁. ▁sw b _ offset ▁[ ▁sf b _ start ▁] ▁; ▁for ▁( ▁g ▁= ▁0 ▁; ▁g ▁< ▁sce ▁-> ▁ics ▁. ▁num _ sw b ▁; ▁g ▁++ ▁) ▁{ ▁if ▁( ▁w ▁* ▁16 ▁+ ▁g ▁< ▁sf b _ start ▁|| ▁w ▁* ▁16 ▁+ ▁g ▁> ▁sf b _ end ▁) ▁continue ▁; ▁for ▁( ▁w 2 ▁= ▁0 ▁; ▁w 2 ▁< ▁sce ▁-> ▁ics ▁. ▁group _ len ▁[ ▁w ▁] ▁; ▁w 2 ▁++ ▁) ▁{ ▁F FP sy Band ▁* ▁band ▁= ▁& ▁s ▁-> ▁ps y ▁. ▁ch ▁[ ▁s ▁-> ▁cur _ channel ▁] ▁. ▁ps y _ band s ▁[ ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁] ▁; ▁if ▁( ▁( ▁w ▁+ ▁w 2 ▁) ▁* ▁16 ▁+ ▁g ▁> ▁sf b _ start ▁+ ▁( ▁( ▁sf b _ end ▁- ▁sf b _ start ▁) ▁/ ▁2 ▁) ▁) ▁en ▁[ ▁1 ▁] ▁+= ▁band ▁-> ▁energy ▁; ▁else ▁en ▁[ ▁0 ▁] ▁+= ▁band ▁-> ▁energy ▁; ▁} ▁} ▁if ▁( ▁coef _ len ▁<= ▁0 ▁|| ▁( ▁sf b _ end ▁- ▁sf b _ start ▁) ▁<= ▁0 ▁) ▁continue ▁; ▁gain ▁= ▁ff _ lpc _ calc _ ref _ co efs _ f ▁( ▁& ▁s ▁-> ▁lpc ▁, ▁& ▁sce ▁-> ▁coeffs ▁[ ▁coef _ start ▁] ▁, ▁coef _ len ▁, ▁order ▁, ▁co efs ▁) ▁; ▁if ▁( ▁! ▁order ▁|| ▁gain ▁< ▁T NS _ GAIN _ THRESHOLD _ LOW ▁|| ▁gain ▁> ▁T NS _ GAIN _ THRESHOLD _ HIGH ▁) ▁continue ▁; ▁if ▁( ▁is 8 ▁&& ▁( ▁gain ▁< ▁T NS _ GAIN _ THRESHOLD _ LOW _ IS 8 ▁|| ▁gain ▁> ▁T NS _ GAIN _ THRESHOLD _ HIGH _ IS 8 ▁) ▁) ▁continue ▁; ▁if ▁( ▁is 8 ▁|| ▁order ▁< ▁2 ▁) ▁{ ▁t ns ▁-> ▁n _ filt ▁[ ▁w ▁] ▁= ▁1 ▁; ▁for ▁( ▁g ▁= ▁0 ▁; ▁g ▁< ▁t ns ▁-> ▁n _ filt ▁[ ▁w ▁] ▁; ▁g ▁++ ▁) ▁{ ▁t ns ▁-> ▁length ▁[ ▁w ▁] ▁[ ▁g ▁] ▁= ▁sf b _ end ▁- ▁sf b _ start ▁; ▁t ns ▁-> ▁direction ▁[ ▁w ▁] ▁[ ▁g ▁] ▁= ▁sl ant ▁!= ▁2 ▁? ▁sl ant ▁: ▁en ▁[ ▁0 ▁] ▁< ▁en ▁[ ▁1 ▁] ▁; ▁t ns ▁-> ▁order ▁[ ▁w ▁] ▁[ ▁g ▁] ▁= ▁order ▁; ▁quant ize _ co efs ▁( ▁co efs ▁, ▁t ns ▁-> ▁coef _ idx ▁[ ▁w ▁] ▁[ ▁g ▁] ▁, ▁t ns ▁-> ▁coef ▁[ ▁w ▁] ▁[ ▁g ▁] ▁, ▁order ▁, ▁c _ bits ▁) ▁; ▁} ▁} ▁else ▁{ ▁t ns ▁-> ▁n _ filt ▁[ ▁w ▁] ▁= ▁2 ▁; ▁for ▁( ▁g ▁= ▁0 ▁; ▁g ▁< ▁t ns ▁-> ▁n _ filt ▁[ ▁w ▁] ▁; ▁g ▁++ ▁) ▁{ ▁t ns ▁-> ▁direction ▁[ ▁w ▁] ▁[ ▁g ▁] ▁= ▁sl ant ▁!= ▁2 ▁? ▁sl ant ▁: ▁en ▁[ ▁g ▁] ▁< ▁en ▁[ ▁! ▁g ▁] ▁; ▁t ns ▁-> ▁order ▁[ ▁w ▁] ▁[ ▁g ▁] ▁= ▁! ▁g ▁? ▁order ▁/ ▁2 ▁: ▁order ▁- ▁t ns ▁-> ▁order ▁[ ▁w ▁] ▁[ ▁g ▁- ▁1 ▁] ▁; ▁t ns ▁-> ▁length ▁[ ▁w ▁] ▁[ ▁g ▁] ▁= ▁! ▁g ▁? ▁( ▁sf b _ end ▁- ▁sf b _ start ▁) ▁/ ▁2 ▁: ▁( ▁sf b _ end ▁- ▁sf b _ start ▁) ▁- ▁t ns ▁-> ▁length ▁[ ▁w ▁] ▁[ ▁g ▁- ▁1 ▁] ▁; ▁quant ize _ co efs ▁( ▁& ▁co efs ▁[ ▁! ▁g ▁? ▁0 ▁: ▁order ▁- ▁t ns ▁-> ▁order ▁[ ▁w ▁] ▁[ ▁g ▁- ▁1 ▁] ▁] ▁, ▁t ns ▁-> ▁coef _ idx ▁[ ▁w ▁] ▁[ ▁g ▁] ▁, ▁t ns ▁-> ▁coef ▁[ ▁w ▁] ▁[ ▁g ▁] ▁, ▁t ns ▁-> ▁order ▁[ ▁w ▁] ▁[ ▁g ▁] ▁, ▁c _ bits ▁) ▁; ▁} ▁} ▁count ▁+= ▁t ns ▁-> ▁n _ filt ▁[ ▁w ▁] ▁; ▁} ▁sce ▁-> ▁t ns ▁. ▁present ▁= ▁! ▁! ▁count ▁; ▁}	1
▁int ▁ssl 3_ send _ server _ certificate ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁C ERT _ PKEY ▁* ▁cp k ▁; ▁if ▁( ▁s ▁-> ▁state ▁== ▁SSL 3_ ST _ SW _ CERT _ A ▁) ▁{ ▁cp k ▁= ▁ssl _ get _ server _ send _ pkey ▁( ▁s ▁) ▁; ▁if ▁( ▁cp k ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithm _ auth ▁!= ▁SSL _ a KRB 5 ▁) ▁|| ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithm _ m key ▁& ▁SSL _ k KRB 5 ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ SERVER _ CERTIFICATE ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁} ▁ssl 3_ output _ cert _ chain ▁( ▁s ▁, ▁cp k ▁) ▁; ▁s ▁-> ▁state ▁= ▁SSL 3_ ST _ SW _ CERT _ B ▁; ▁} ▁return ▁ssl _ do _ write ▁( ▁s ▁) ▁; ▁}	0
▁static ▁void ▁frame _ thread _ free ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁int ▁thread _ count ▁) ▁{ ▁Frame ThreadContext ▁* ▁fctx ▁= ▁avctx ▁-> ▁thread _ opaque ▁; ▁AVCodec ▁* ▁codec ▁= ▁avctx ▁-> ▁codec ▁; ▁int ▁i ▁; ▁park _ frame _ worker _ threads ▁( ▁fctx ▁, ▁thread _ count ▁) ▁; ▁if ▁( ▁fctx ▁-> ▁prev _ thread ▁&& ▁fctx ▁-> ▁prev _ thread ▁!= ▁fctx ▁-> ▁threads ▁) ▁update _ context _ from _ thread ▁( ▁fctx ▁-> ▁threads ▁-> ▁avctx ▁, ▁fctx ▁-> ▁prev _ thread ▁-> ▁avctx ▁, ▁0 ▁) ▁; ▁fctx ▁-> ▁die ▁= ▁1 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁Per ThreadContext ▁* ▁p ▁= ▁& ▁fctx ▁-> ▁threads ▁[ ▁i ▁] ▁; ▁pthread _ mutex _ lock ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁pthread _ cond _ signal ▁( ▁& ▁p ▁-> ▁input _ cond ▁) ▁; ▁pthread _ mutex _ unlock ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁pthread _ join ▁( ▁p ▁-> ▁thread ▁, ▁NULL ▁) ▁; ▁if ▁( ▁codec ▁-> ▁close ▁) ▁codec ▁-> ▁close ▁( ▁p ▁-> ▁avctx ▁) ▁; ▁avctx ▁-> ▁codec ▁= ▁NULL ▁; ▁release _ delayed _ buffers ▁( ▁p ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁Per ThreadContext ▁* ▁p ▁= ▁& ▁fctx ▁-> ▁threads ▁[ ▁i ▁] ▁; ▁avcodec _ default _ free _ buffers ▁( ▁p ▁-> ▁avctx ▁) ▁; ▁pthread _ mutex _ destroy ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁pthread _ mutex _ destroy ▁( ▁& ▁p ▁-> ▁progress _ mutex ▁) ▁; ▁pthread _ cond _ destroy ▁( ▁& ▁p ▁-> ▁input _ cond ▁) ▁; ▁pthread _ cond _ destroy ▁( ▁& ▁p ▁-> ▁progress _ cond ▁) ▁; ▁pthread _ cond _ destroy ▁( ▁& ▁p ▁-> ▁output _ cond ▁) ▁; ▁av _ freep ▁( ▁& ▁p ▁-> ▁avpkt ▁. ▁data ▁) ▁; ▁if ▁( ▁i ▁) ▁av _ freep ▁( ▁& ▁p ▁-> ▁avctx ▁-> ▁priv _ data ▁) ▁; ▁av _ freep ▁( ▁& ▁p ▁-> ▁avctx ▁) ▁; ▁} ▁av _ freep ▁( ▁& ▁fctx ▁-> ▁threads ▁) ▁; ▁pthread _ mutex _ destroy ▁( ▁& ▁fctx ▁-> ▁buffer _ mutex ▁) ▁; ▁av _ freep ▁( ▁& ▁avctx ▁-> ▁thread _ opaque ▁) ▁; ▁}	0
▁static ▁char ▁* ▁ngx _ http _ map ▁( ▁ngx _ conf _ t ▁* ▁cf ▁, ▁ngx _ command _ t ▁* ▁dummy ▁, ▁void ▁* ▁conf ▁) ▁{ ▁ngx _ int _ t ▁rc ▁, ▁index ▁; ▁ngx _ str _ t ▁* ▁value ▁, ▁file ▁, ▁name ▁; ▁ngx _ uint _ t ▁i ▁, ▁key ▁; ▁ngx _ http _ map _ conf _ ctx _ t ▁* ▁ctx ▁; ▁ngx _ http _ variable _ value _ t ▁* ▁var ▁, ▁* ▁* ▁vp ▁; ▁ctx ▁= ▁cf ▁-> ▁ctx ▁; ▁value ▁= ▁cf ▁-> ▁args ▁-> ▁elts ▁; ▁if ▁( ▁cf ▁-> ▁args ▁-> ▁nel ts ▁== ▁1 ▁&& ▁ngx _ strcmp ▁( ▁value ▁[ ▁0 ▁] ▁. ▁data ▁, ▁" host names " ▁) ▁== ▁0 ▁) ▁{ ▁ctx ▁-> ▁host names ▁= ▁1 ▁; ▁return ▁NGX _ CONF _ OK ▁; ▁} ▁else ▁if ▁( ▁cf ▁-> ▁args ▁-> ▁nel ts ▁!= ▁2 ▁) ▁{ ▁ngx _ conf _ log _ error ▁( ▁NGX _ LOG _ EMERG ▁, ▁cf ▁, ▁0 ▁, ▁" invalid number oft he map parameters " ▁) ▁; ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁if ▁( ▁ngx _ strcmp ▁( ▁value ▁[ ▁0 ▁] ▁. ▁data ▁, ▁" include " ▁) ▁== ▁0 ▁) ▁{ ▁file ▁= ▁value ▁[ ▁1 ▁] ▁; ▁if ▁( ▁ngx _ conf _ full _ name ▁( ▁cf ▁-> ▁cycle ▁, ▁& ▁file ▁, ▁1 ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ CORE ▁, ▁cf ▁-> ▁log ▁, ▁0 ▁, ▁" include % s " ▁, ▁file ▁. ▁data ▁) ▁; ▁return ▁ngx _ conf _ parse ▁( ▁cf ▁, ▁& ▁file ▁) ▁; ▁} ▁if ▁( ▁value ▁[ ▁1 ▁] ▁. ▁data ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁name ▁= ▁value ▁[ ▁1 ▁] ▁; ▁name ▁. ▁len ▁-- ▁; ▁name ▁. ▁data ▁++ ▁; ▁index ▁= ▁ngx _ http _ get _ variable _ index ▁( ▁ctx ▁-> ▁cf ▁, ▁& ▁name ▁) ▁; ▁if ▁( ▁index ▁== ▁NGX _ ERROR ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁var ▁= ▁ctx ▁-> ▁var _ values ▁. ▁elts ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ctx ▁-> ▁var _ values ▁. ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁index ▁== ▁( ▁ngx _ int _ t ▁) ▁var ▁[ ▁i ▁] ▁. ▁data ▁) ▁{ ▁goto ▁found ▁; ▁} ▁} ▁var ▁= ▁ngx _ palloc ▁( ▁ctx ▁-> ▁keys ▁. ▁pool ▁, ▁sizeof ▁( ▁ngx _ http _ variable _ value _ t ▁) ▁) ▁; ▁if ▁( ▁var ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁var ▁-> ▁valid ▁= ▁0 ▁; ▁var ▁-> ▁no _ cache able ▁= ▁0 ▁; ▁var ▁-> ▁not _ found ▁= ▁0 ▁; ▁var ▁-> ▁len ▁= ▁0 ▁; ▁var ▁-> ▁data ▁= ▁( ▁u _ char ▁* ▁) ▁index ▁; ▁vp ▁= ▁ngx _ array _ push ▁( ▁& ▁ctx ▁-> ▁var _ values ▁) ▁; ▁if ▁( ▁vp ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁* ▁vp ▁= ▁var ▁; ▁goto ▁found ▁; ▁} ▁key ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁value ▁[ ▁1 ▁] ▁. ▁len ▁; ▁i ▁++ ▁) ▁{ ▁key ▁= ▁ngx _ hash ▁( ▁key ▁, ▁value ▁[ ▁1 ▁] ▁. ▁data ▁[ ▁i ▁] ▁) ▁; ▁} ▁key ▁%= ▁ctx ▁-> ▁keys ▁. ▁hsize ▁; ▁vp ▁= ▁ctx ▁-> ▁values _ hash ▁[ ▁key ▁] ▁. ▁elts ▁; ▁if ▁( ▁vp ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ctx ▁-> ▁values _ hash ▁[ ▁key ▁] ▁. ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁value ▁[ ▁1 ▁] ▁. ▁len ▁!= ▁( ▁size _ t ▁) ▁vp ▁[ ▁i ▁] ▁-> ▁len ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁ngx _ strncmp ▁( ▁value ▁[ ▁1 ▁] ▁. ▁data ▁, ▁vp ▁[ ▁i ▁] ▁-> ▁data ▁, ▁value ▁[ ▁1 ▁] ▁. ▁len ▁) ▁== ▁0 ▁) ▁{ ▁var ▁= ▁vp ▁[ ▁i ▁] ▁; ▁goto ▁found ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁ngx _ array _ init ▁( ▁& ▁ctx ▁-> ▁values _ hash ▁[ ▁key ▁] ▁, ▁cf ▁-> ▁pool ▁, ▁4 ▁, ▁sizeof ▁( ▁ngx _ http _ variable _ value _ t ▁* ▁) ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁} ▁var ▁= ▁ngx _ palloc ▁( ▁ctx ▁-> ▁keys ▁. ▁pool ▁, ▁sizeof ▁( ▁ngx _ http _ variable _ value _ t ▁) ▁) ▁; ▁if ▁( ▁var ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁var ▁-> ▁len ▁= ▁value ▁[ ▁1 ▁] ▁. ▁len ▁; ▁var ▁-> ▁data ▁= ▁ngx _ p strdup ▁( ▁ctx ▁-> ▁keys ▁. ▁pool ▁, ▁& ▁value ▁[ ▁1 ▁] ▁) ▁; ▁if ▁( ▁var ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁var ▁-> ▁valid ▁= ▁1 ▁; ▁var ▁-> ▁no _ cache able ▁= ▁0 ▁; ▁var ▁-> ▁not _ found ▁= ▁0 ▁; ▁vp ▁= ▁ngx _ array _ push ▁( ▁& ▁ctx ▁-> ▁values _ hash ▁[ ▁key ▁] ▁) ▁; ▁if ▁( ▁vp ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁* ▁vp ▁= ▁var ▁; ▁found ▁: ▁if ▁( ▁ngx _ strcmp ▁( ▁value ▁[ ▁0 ▁] ▁. ▁data ▁, ▁" default " ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁default _ value ▁) ▁{ ▁ngx _ conf _ log _ error ▁( ▁NGX _ LOG _ EMERG ▁, ▁cf ▁, ▁0 ▁, ▁" duplicate default map parameter " ▁) ▁; ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁ctx ▁-> ▁default _ value ▁= ▁var ▁; ▁return ▁NGX _ CONF _ OK ▁; ▁} ▁# if ▁( ▁NGX _ PC RE ▁) ▁if ▁( ▁value ▁[ ▁0 ▁] ▁. ▁len ▁&& ▁value ▁[ ▁0 ▁] ▁. ▁data ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁ngx _ regex _ compile _ t ▁rc ▁; ▁ngx _ http _ map _ regex _ t ▁* ▁regex ▁; ▁u _ char ▁errstr ▁[ ▁NGX _ MAX _ CONF _ ERR STR ▁] ▁; ▁regex ▁= ▁ngx _ array _ push ▁( ▁& ▁ctx ▁-> ▁regex es ▁) ▁; ▁if ▁( ▁regex ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁value ▁[ ▁0 ▁] ▁. ▁len ▁-- ▁; ▁value ▁[ ▁0 ▁] ▁. ▁data ▁++ ▁; ▁ngx _ mem zero ▁( ▁& ▁rc ▁, ▁sizeof ▁( ▁ngx _ regex _ compile _ t ▁) ▁) ▁; ▁if ▁( ▁value ▁[ ▁0 ▁] ▁. ▁data ▁[ ▁0 ▁] ▁== ▁' ▁' ▁) ▁{ ▁value ▁[ ▁0 ▁] ▁. ▁len ▁-- ▁; ▁value ▁[ ▁0 ▁] ▁. ▁data ▁++ ▁; ▁rc ▁. ▁options ▁= ▁NGX _ REGEX _ CAS EL ESS ▁; ▁} ▁rc ▁. ▁pattern ▁= ▁value ▁[ ▁0 ▁] ▁; ▁rc ▁. ▁err ▁. ▁len ▁= ▁NGX _ MAX _ CONF _ ERR STR ▁; ▁rc ▁. ▁err ▁. ▁data ▁= ▁errstr ▁; ▁regex ▁-> ▁regex ▁= ▁ngx _ http _ regex _ compile ▁( ▁ctx ▁-> ▁cf ▁, ▁& ▁rc ▁) ▁; ▁if ▁( ▁regex ▁-> ▁regex ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁regex ▁-> ▁value ▁= ▁var ▁; ▁return ▁NGX _ CONF _ OK ▁; ▁} ▁# endif ▁if ▁( ▁value ▁[ ▁0 ▁] ▁. ▁len ▁&& ▁value ▁[ ▁0 ▁] ▁. ▁data ▁[ ▁0 ▁] ▁== ▁' ▁\\ ▁' ▁) ▁{ ▁value ▁[ ▁0 ▁] ▁. ▁len ▁-- ▁; ▁value ▁[ ▁0 ▁] ▁. ▁data ▁++ ▁; ▁} ▁rc ▁= ▁ngx _ hash _ add _ key ▁( ▁& ▁ctx ▁-> ▁keys ▁, ▁& ▁value ▁[ ▁0 ▁] ▁, ▁var ▁, ▁( ▁ctx ▁-> ▁host names ▁) ▁? ▁NGX _ HASH _ W ILDCARD _ KEY ▁: ▁0 ▁) ▁; ▁if ▁( ▁rc ▁== ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ CONF _ OK ▁; ▁} ▁if ▁( ▁rc ▁== ▁NGX _ DECL INED ▁) ▁{ ▁ngx _ conf _ log _ error ▁( ▁NGX _ LOG _ EMERG ▁, ▁cf ▁, ▁0 ▁, ▁" invalid hostname or w ildcard \"% V \"" ▁, ▁& ▁value ▁[ ▁0 ▁] ▁) ▁; ▁} ▁if ▁( ▁rc ▁== ▁NGX _ BUSY ▁) ▁{ ▁ngx _ conf _ log _ error ▁( ▁NGX _ LOG _ EMERG ▁, ▁cf ▁, ▁0 ▁, ▁" conf licting parameter \"% V \"" ▁, ▁& ▁value ▁[ ▁0 ▁] ▁) ▁; ▁} ▁return ▁NGX _ CONF _ ERROR ▁; ▁}	1
▁static ▁int ▁check _ cert _ time ▁( ▁X 509_ STORE _ CTX ▁* ▁ctx ▁, ▁X 509 ▁* ▁x ▁) ▁{ ▁time _ t ▁* ▁ptime ▁; ▁int ▁i ▁; ▁if ▁( ▁ctx ▁-> ▁param ▁-> ▁flags ▁& ▁X 509_ V _ FLAG _ USE _ CHECK _ TIME ▁) ▁ptime ▁= ▁& ▁ctx ▁-> ▁param ▁-> ▁check _ time ▁; ▁else ▁ptime ▁= ▁NULL ▁; ▁i ▁= ▁X 509_ cmp _ time ▁( ▁X 509_ get _ not Before ▁( ▁x ▁) ▁, ▁ptime ▁) ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁ctx ▁-> ▁error ▁= ▁X 509_ V _ ERR _ ERROR _ IN _ CERT _ NOT _ BEFORE _ FIELD ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁x ▁; ▁if ▁( ▁! ▁ctx ▁-> ▁verify _ cb ▁( ▁0 ▁, ▁ctx ▁) ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁i ▁> ▁0 ▁) ▁{ ▁ctx ▁-> ▁error ▁= ▁X 509_ V _ ERR _ CERT _ NOT _ Y ET _ VALID ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁x ▁; ▁if ▁( ▁! ▁ctx ▁-> ▁verify _ cb ▁( ▁0 ▁, ▁ctx ▁) ▁) ▁return ▁0 ▁; ▁} ▁i ▁= ▁X 509_ cmp _ time ▁( ▁X 509_ get _ not After ▁( ▁x ▁) ▁, ▁ptime ▁) ▁; ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁ctx ▁-> ▁error ▁= ▁X 509_ V _ ERR _ ERROR _ IN _ CERT _ NOT _ AFTER _ FIELD ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁x ▁; ▁if ▁( ▁! ▁ctx ▁-> ▁verify _ cb ▁( ▁0 ▁, ▁ctx ▁) ▁) ▁return ▁0 ▁; ▁} ▁if ▁( ▁i ▁< ▁0 ▁) ▁{ ▁ctx ▁-> ▁error ▁= ▁X 509_ V _ ERR _ CERT _ HAS _ EXPIRED ▁; ▁ctx ▁-> ▁current _ cert ▁= ▁x ▁; ▁if ▁( ▁! ▁ctx ▁-> ▁verify _ cb ▁( ▁0 ▁, ▁ctx ▁) ▁) ▁return ▁0 ▁; ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁inline ▁int ▁ff _ fast _ malloc ▁( ▁void ▁* ▁ptr ▁, ▁unsigned ▁int ▁* ▁size ▁, ▁size _ t ▁min _ size ▁, ▁int ▁zero _ realloc ▁) ▁{ ▁void ▁* ▁val ▁; ▁if ▁( ▁min _ size ▁< ▁* ▁size ▁) ▁return ▁0 ▁; ▁min _ size ▁= ▁FF MAX ▁( ▁17 ▁* ▁min _ size ▁/ ▁16 ▁+ ▁32 ▁, ▁min _ size ▁) ▁; ▁av _ freep ▁( ▁ptr ▁) ▁; ▁val ▁= ▁zero _ realloc ▁? ▁av _ malloc z ▁( ▁min _ size ▁) ▁: ▁av _ malloc ▁( ▁min _ size ▁) ▁; ▁memcpy ▁( ▁ptr ▁, ▁& ▁val ▁, ▁sizeof ▁( ▁val ▁) ▁) ▁; ▁if ▁( ▁! ▁val ▁) ▁min _ size ▁= ▁0 ▁; ▁* ▁size ▁= ▁min _ size ▁; ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁adx _ decode _ header ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁const ▁uint 8_ t ▁* ▁buf ▁, ▁int ▁bufsize ▁) ▁{ ▁int ▁offset ▁; ▁if ▁( ▁buf ▁[ ▁0 ▁] ▁!= ▁0 x 80 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁offset ▁= ▁( ▁AV _ RB 32 ▁( ▁buf ▁) ▁ ^ ▁0 x 80000000 ▁) ▁+ ▁4 ▁; ▁if ▁( ▁bufsize ▁< ▁offset ▁|| ▁memcmp ▁( ▁buf ▁+ ▁offset ▁- ▁6 ▁, ▁"( c ) CR I " ▁, ▁6 ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avctx ▁-> ▁channels ▁= ▁buf ▁[ ▁7 ▁] ▁; ▁if ▁( ▁avctx ▁-> ▁channels ▁> ▁2 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avctx ▁-> ▁sample _ rate ▁= ▁AV _ RB 32 ▁( ▁buf ▁+ ▁8 ▁) ▁; ▁if ▁( ▁avctx ▁-> ▁sample _ rate ▁< ▁1 ▁|| ▁avctx ▁-> ▁sample _ rate ▁> ▁INT _ MAX ▁/ ▁( ▁avctx ▁-> ▁channels ▁* ▁18 ▁* ▁8 ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁avctx ▁-> ▁bit _ rate ▁= ▁avctx ▁-> ▁sample _ rate ▁* ▁avctx ▁-> ▁channels ▁* ▁18 ▁* ▁8 ▁/ ▁32 ▁; ▁return ▁offset ▁; ▁}	0
▁static ▁void ▁vp 6_ parse _ coeff ▁( ▁VP 56 Context ▁* ▁s ▁) ▁{ ▁VP 56 Range Coder ▁* ▁c ▁= ▁s ▁-> ▁c cp ▁; ▁VP 56 Model ▁* ▁model ▁= ▁s ▁-> ▁model p ▁; ▁uint 8_ t ▁* ▁perm ute ▁= ▁s ▁-> ▁sc ant able ▁. ▁perm ut ated ▁; ▁uint 8_ t ▁* ▁model 1 ▁, ▁* ▁model 2 ▁, ▁* ▁model 3 ▁; ▁int ▁coeff ▁, ▁sign ▁, ▁coeff _ idx ▁; ▁int ▁b ▁, ▁i ▁, ▁cg ▁, ▁idx ▁, ▁ctx ▁; ▁int ▁pt ▁= ▁0 ▁; ▁for ▁( ▁b ▁= ▁0 ▁; ▁b ▁< ▁6 ▁; ▁b ▁++ ▁) ▁{ ▁int ▁ct ▁= ▁1 ▁; ▁int ▁run ▁= ▁1 ▁; ▁if ▁( ▁b ▁> ▁3 ▁) ▁pt ▁= ▁1 ▁; ▁ctx ▁= ▁s ▁-> ▁left _ block ▁[ ▁vp 5 6_ b 6 to 4 ▁[ ▁b ▁] ▁] ▁. ▁not _ null _ dc ▁+ ▁s ▁-> ▁above _ blocks ▁[ ▁s ▁-> ▁above _ block _ idx ▁[ ▁b ▁] ▁] ▁. ▁not _ null _ dc ▁; ▁model 1 ▁= ▁model ▁-> ▁coeff _ dcc v ▁[ ▁pt ▁] ▁; ▁model 2 ▁= ▁model ▁-> ▁coeff _ dc ct ▁[ ▁pt ▁] ▁[ ▁ctx ▁] ▁; ▁for ▁( ▁coeff _ idx ▁= ▁0 ▁; ▁coeff _ idx ▁< ▁64 ▁; ▁) ▁{ ▁if ▁( ▁( ▁coeff _ idx ▁> ▁1 ▁&& ▁ct ▁== ▁0 ▁) ▁|| ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁model 2 ▁[ ▁0 ▁] ▁) ▁) ▁{ ▁if ▁( ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁model 2 ▁[ ▁2 ▁] ▁) ▁) ▁{ ▁if ▁( ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁model 2 ▁[ ▁3 ▁] ▁) ▁) ▁{ ▁idx ▁= ▁vp 5 6_ rac _ get _ tree ▁( ▁c ▁, ▁vp 5 6_ pc _ tree ▁, ▁model 1 ▁) ▁; ▁coeff ▁= ▁vp 5 6_ coeff _ bias ▁[ ▁idx ▁+ ▁5 ▁] ▁; ▁for ▁( ▁i ▁= ▁vp 5 6_ coeff _ bit _ length ▁[ ▁idx ▁] ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁coeff ▁+= ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁vp 5 6_ coeff _ parse _ table ▁[ ▁idx ▁] ▁[ ▁i ▁] ▁) ▁<< ▁i ▁; ▁} ▁else ▁{ ▁if ▁( ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁model 2 ▁[ ▁4 ▁] ▁) ▁) ▁coeff ▁= ▁3 ▁+ ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁model 1 ▁[ ▁5 ▁] ▁) ▁; ▁else ▁coeff ▁= ▁2 ▁; ▁} ▁ct ▁= ▁2 ▁; ▁} ▁else ▁{ ▁ct ▁= ▁1 ▁; ▁coeff ▁= ▁1 ▁; ▁} ▁sign ▁= ▁vp 5 6_ rac _ get ▁( ▁c ▁) ▁; ▁coeff ▁= ▁( ▁coeff ▁ ^ ▁- ▁sign ▁) ▁+ ▁sign ▁; ▁if ▁( ▁coeff _ idx ▁) ▁coeff ▁*= ▁s ▁-> ▁de quant _ ac ▁; ▁idx ▁= ▁model ▁-> ▁coeff _ index _ to _ pos ▁[ ▁coeff _ idx ▁] ▁; ▁s ▁-> ▁block _ coeff ▁[ ▁b ▁] ▁[ ▁perm ute ▁[ ▁idx ▁] ▁] ▁= ▁coeff ▁; ▁run ▁= ▁1 ▁; ▁} ▁else ▁{ ▁ct ▁= ▁0 ▁; ▁if ▁( ▁coeff _ idx ▁> ▁0 ▁) ▁{ ▁if ▁( ▁! ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁model 2 ▁[ ▁1 ▁] ▁) ▁) ▁break ▁; ▁model 3 ▁= ▁model ▁-> ▁coeff _ run v ▁[ ▁coeff _ idx ▁>= ▁6 ▁] ▁; ▁run ▁= ▁vp 5 6_ rac _ get _ tree ▁( ▁c ▁, ▁vp 6_ pcr _ tree ▁, ▁model 3 ▁) ▁; ▁if ▁( ▁! ▁run ▁) ▁for ▁( ▁run ▁= ▁9 ▁, ▁i ▁= ▁0 ▁; ▁i ▁< ▁6 ▁; ▁i ▁++ ▁) ▁run ▁+= ▁vp 5 6_ rac _ get _ prob ▁( ▁c ▁, ▁model 3 ▁[ ▁i ▁+ ▁8 ▁] ▁) ▁<< ▁i ▁; ▁} ▁} ▁cg ▁= ▁vp 6_ coeff _ groups ▁[ ▁coeff _ idx ▁+= ▁run ▁] ▁; ▁model 1 ▁= ▁model 2 ▁= ▁model ▁-> ▁coeff _ ract ▁[ ▁pt ▁] ▁[ ▁ct ▁] ▁[ ▁cg ▁] ▁; ▁} ▁s ▁-> ▁left _ block ▁[ ▁vp 5 6_ b 6 to 4 ▁[ ▁b ▁] ▁] ▁. ▁not _ null _ dc ▁= ▁s ▁-> ▁above _ blocks ▁[ ▁s ▁-> ▁above _ block _ idx ▁[ ▁b ▁] ▁] ▁. ▁not _ null _ dc ▁= ▁! ▁! ▁s ▁-> ▁block _ coeff ▁[ ▁b ▁] ▁[ ▁0 ▁] ▁; ▁} ▁}	1
▁int ▁ssl 3_ send _ client _ verify ▁( ▁SSL ▁* ▁s ▁) ▁{ ▁unsigned ▁char ▁* ▁p ▁; ▁unsigned ▁char ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁+ ▁SHA _ DIGEST _ LENGTH ▁] ▁; ▁EVP _ PKEY ▁* ▁pkey ▁; ▁EVP _ PKEY _ CTX ▁* ▁pctx ▁= ▁NULL ▁; ▁EVP _ MD _ CTX ▁mctx ▁; ▁unsigned ▁u ▁= ▁0 ▁; ▁unsigned ▁long ▁n ▁; ▁int ▁j ▁; ▁EVP _ MD _ CTX _ init ▁( ▁& ▁mctx ▁) ▁; ▁if ▁( ▁s ▁-> ▁state ▁== ▁SSL 3_ ST _ CW _ CERT _ V RF Y _ A ▁) ▁{ ▁p ▁= ▁ssl _ handshake _ start ▁( ▁s ▁) ▁; ▁pkey ▁= ▁s ▁-> ▁cert ▁-> ▁key ▁-> ▁private key ▁; ▁pctx ▁= ▁EVP _ PKEY _ CTX _ new ▁( ▁pkey ▁, ▁NULL ▁) ▁; ▁EVP _ PKEY _ sign _ init ▁( ▁pctx ▁) ▁; ▁if ▁( ▁EVP _ PKEY _ CTX _ set _ signature _ md ▁( ▁pctx ▁, ▁EVP _ sha 1 ▁( ▁) ▁) ▁> ▁0 ▁) ▁{ ▁if ▁( ▁! ▁SSL _ USE _ SIG ALG S ▁( ▁s ▁) ▁) ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ sha 1 ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁ERR _ clear _ error ▁( ▁) ▁; ▁} ▁if ▁( ▁SSL _ USE _ SIG ALG S ▁( ▁s ▁) ▁) ▁{ ▁long ▁hd atal en ▁= ▁0 ▁; ▁void ▁* ▁h data ▁; ▁const ▁EVP _ MD ▁* ▁md ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁md ▁[ ▁s ▁-> ▁cert ▁-> ▁key ▁- ▁s ▁-> ▁cert ▁-> ▁p keys ▁] ▁; ▁hd atal en ▁= ▁BIO _ get _ mem _ data ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ buffer ▁, ▁& ▁h data ▁) ▁; ▁if ▁( ▁hd atal en ▁<= ▁0 ▁|| ▁! ▁tls 12_ get _ sig and hash ▁( ▁p ▁, ▁pkey ▁, ▁md ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁p ▁+= ▁2 ▁; ▁# ifdef ▁SSL _ DEBUG ▁fprintf ▁( ▁stderr ▁, ▁" Using TLS 1.2 with client alg % s \ n " ▁, ▁EVP _ MD _ name ▁( ▁md ▁) ▁) ▁; ▁# endif ▁if ▁( ▁! ▁EVP _ Sign Init _ ex ▁( ▁& ▁mctx ▁, ▁md ▁, ▁NULL ▁) ▁|| ▁! ▁EVP _ Sign Update ▁( ▁& ▁mctx ▁, ▁h data ▁, ▁hd atal en ▁) ▁|| ▁! ▁EVP _ Sign Final ▁( ▁& ▁mctx ▁, ▁p ▁+ ▁2 ▁, ▁& ▁u ▁, ▁pkey ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ EVP _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁u ▁, ▁p ▁) ▁; ▁n ▁= ▁u ▁+ ▁4 ▁; ▁if ▁( ▁! ▁ssl 3_ digest _ cached _ records ▁( ▁s ▁, ▁0 ▁) ▁) ▁goto ▁err ▁; ▁} ▁else ▁# ifndef ▁OPENSSL _ NO _ RSA ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ RSA ▁) ▁{ ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ md 5 ▁, ▁& ▁( ▁data ▁[ ▁0 ▁] ▁) ▁) ▁; ▁if ▁( ▁RSA _ sign ▁( ▁NID _ md 5_ sha 1 ▁, ▁data ▁, ▁MD 5_ DIGEST _ LENGTH ▁+ ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁& ▁u ▁, ▁pkey ▁-> ▁pkey ▁. ▁rsa ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ RSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁u ▁, ▁p ▁) ▁; ▁n ▁= ▁u ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁# ifndef ▁OPENSSL _ NO _ DSA ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ DSA ▁) ▁{ ▁if ▁( ▁! ▁DSA _ sign ▁( ▁pkey ▁-> ▁save _ type ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁, ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁( ▁unsigned ▁int ▁* ▁) ▁& ▁j ▁, ▁pkey ▁-> ▁pkey ▁. ▁dsa ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ DSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁EVP _ PKEY _ EC ▁) ▁{ ▁if ▁( ▁! ▁ECDSA _ sign ▁( ▁pkey ▁-> ▁save _ type ▁, ▁& ▁( ▁data ▁[ ▁MD 5_ DIGEST _ LENGTH ▁] ▁) ▁, ▁SHA _ DIGEST _ LENGTH ▁, ▁& ▁( ▁p ▁[ ▁2 ▁] ▁) ▁, ▁( ▁unsigned ▁int ▁* ▁) ▁& ▁j ▁, ▁pkey ▁-> ▁pkey ▁. ▁ec ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ ECDSA _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁# endif ▁if ▁( ▁pkey ▁-> ▁type ▁== ▁NID _ id _ G ost R 34 10 _2 001 ▁) ▁{ ▁unsigned ▁char ▁sign buf ▁[ ▁64 ▁] ▁; ▁int ▁i ▁; ▁size _ t ▁sig size ▁= ▁64 ▁; ▁s ▁-> ▁method ▁-> ▁ssl 3_ enc ▁-> ▁cert _ verify _ mac ▁( ▁s ▁, ▁NID _ id _ G ost R 34 11_ 94 ▁, ▁data ▁) ▁; ▁if ▁( ▁EVP _ PKEY _ sign ▁( ▁pctx ▁, ▁sign buf ▁, ▁& ▁sig size ▁, ▁data ▁, ▁32 ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁for ▁( ▁i ▁= ▁63 ▁, ▁j ▁= ▁0 ▁; ▁i ▁>= ▁0 ▁; ▁j ▁++ ▁, ▁i ▁-- ▁) ▁{ ▁p ▁[ ▁2 ▁+ ▁j ▁] ▁= ▁sign buf ▁[ ▁i ▁] ▁; ▁} ▁s 2 n ▁( ▁j ▁, ▁p ▁) ▁; ▁n ▁= ▁j ▁+ ▁2 ▁; ▁} ▁else ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁! ▁ssl _ set _ handshake _ header ▁( ▁s ▁, ▁SSL 3_ MT _ CERTIFICATE _ VERIFY ▁, ▁n ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL 3_ SEND _ CLIENT _ VERIFY ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁s ▁-> ▁state ▁= ▁SSL 3_ ST _ CW _ CERT _ V RF Y _ B ▁; ▁} ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁mctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁return ▁ssl _ do _ write ▁( ▁s ▁) ▁; ▁err ▁: ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁mctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁pctx ▁) ▁; ▁s ▁-> ▁state ▁= ▁SSL _ ST _ ERR ▁; ▁return ▁( ▁-1 ▁) ▁; ▁}	1
▁static ▁int ▁derive _ secret _ key _ and _ iv ▁( ▁SSL ▁* ▁s ▁, ▁int ▁sending ▁, ▁const ▁EVP _ MD ▁* ▁md ▁, ▁const ▁EVP _ CIPHER ▁* ▁c iph ▁, ▁const ▁unsigned ▁char ▁* ▁in secret ▁, ▁const ▁unsigned ▁char ▁* ▁hash ▁, ▁const ▁unsigned ▁char ▁* ▁label ▁, ▁size _ t ▁label len ▁, ▁unsigned ▁char ▁* ▁secret ▁, ▁unsigned ▁char ▁* ▁iv ▁, ▁EVP _ CIPHER _ CTX ▁* ▁c iph _ ctx ▁) ▁{ ▁unsigned ▁char ▁key ▁[ ▁EVP _ MAX _ KEY _ LENGTH ▁] ▁; ▁size _ t ▁iv len ▁, ▁keylen ▁, ▁tag len ▁; ▁int ▁hash len i ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁size _ t ▁hash len ▁; ▁if ▁( ▁! ▁ossl _ assert ▁( ▁hash len i ▁>= ▁0 ▁) ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ DER IVE _ SECRET _ KEY _ AND _ IV ▁, ▁ERR _ R _ EVP _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁hash len ▁= ▁( ▁size _ t ▁) ▁hash len i ▁; ▁if ▁( ▁! ▁tls 13_ h kdf _ expand ▁( ▁s ▁, ▁md ▁, ▁in secret ▁, ▁label ▁, ▁label len ▁, ▁hash ▁, ▁hash len ▁, ▁secret ▁, ▁hash len ▁, ▁1 ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁keylen ▁= ▁EVP _ CIPHER _ key _ length ▁( ▁c iph ▁) ▁; ▁if ▁( ▁EVP _ CIPHER _ mode ▁( ▁c iph ▁) ▁== ▁EVP _ C IPH _ CCM _ MODE ▁) ▁{ ▁uint 32_ t ▁al gen c ▁; ▁iv len ▁= ▁EVP _ CCM _ TLS _ IV _ LEN ▁; ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁== ▁NULL ▁) ▁{ ▁al gen c ▁= ▁s ▁-> ▁session ▁-> ▁cipher ▁-> ▁algorithm _ enc ▁; ▁} ▁else ▁{ ▁al gen c ▁= ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁new _ cipher ▁-> ▁algorithm _ enc ▁; ▁} ▁if ▁( ▁al gen c ▁& ▁( ▁SSL _ AES 128 CCM 8 ▁| ▁SSL _ AES 256 CCM 8 ▁) ▁) ▁tag len ▁= ▁EVP _ CCM 8_ TLS _ TAG _ LEN ▁; ▁else ▁tag len ▁= ▁EVP _ CCM _ TLS _ TAG _ LEN ▁; ▁} ▁else ▁{ ▁iv len ▁= ▁EVP _ CIPHER _ iv _ length ▁( ▁c iph ▁) ▁; ▁tag len ▁= ▁0 ▁; ▁} ▁if ▁( ▁! ▁tls 13_ der ive _ key ▁( ▁s ▁, ▁md ▁, ▁secret ▁, ▁key ▁, ▁keylen ▁) ▁|| ▁! ▁tls 13_ der ive _ iv ▁( ▁s ▁, ▁md ▁, ▁secret ▁, ▁iv ▁, ▁iv len ▁) ▁) ▁{ ▁goto ▁err ▁; ▁} ▁if ▁( ▁EVP _ Cipher Init _ ex ▁( ▁c iph _ ctx ▁, ▁c iph ▁, ▁NULL ▁, ▁NULL ▁, ▁NULL ▁, ▁sending ▁) ▁<= ▁0 ▁|| ▁! ▁EVP _ CIPHER _ CTX _ ctrl ▁( ▁c iph _ ctx ▁, ▁EVP _ CTRL _ A EAD _ SET _ IV LEN ▁, ▁iv len ▁, ▁NULL ▁) ▁|| ▁( ▁tag len ▁!= ▁0 ▁&& ▁! ▁EVP _ CIPHER _ CTX _ ctrl ▁( ▁c iph _ ctx ▁, ▁EVP _ CTRL _ A EAD _ SET _ TAG ▁, ▁tag len ▁, ▁NULL ▁) ▁) ▁|| ▁EVP _ Cipher Init _ ex ▁( ▁c iph _ ctx ▁, ▁NULL ▁, ▁NULL ▁, ▁key ▁, ▁NULL ▁, ▁-1 ▁) ▁<= ▁0 ▁) ▁{ ▁SSL fatal ▁( ▁s ▁, ▁SSL _ AD _ INTERNAL _ ERROR ▁, ▁SSL _ F _ DER IVE _ SECRET _ KEY _ AND _ IV ▁, ▁ERR _ R _ EVP _ LIB ▁) ▁; ▁goto ▁err ▁; ▁} ▁return ▁1 ▁; ▁err ▁: ▁OPENSSL _ cleanse ▁( ▁key ▁, ▁sizeof ▁( ▁key ▁) ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁X 509_ NAME ▁* ▁parse _ name ▁( ▁char ▁* ▁subject ▁, ▁long ▁chtype ▁, ▁int ▁mult ird n ▁) ▁{ ▁size _ t ▁buflen ▁= ▁strlen ▁( ▁subject ▁) ▁+ ▁1 ▁; ▁char ▁* ▁buf ▁= ▁OPENSSL _ malloc ▁( ▁buflen ▁) ▁; ▁size _ t ▁max _ ne ▁= ▁buflen ▁/ ▁2 ▁+ ▁1 ▁; ▁char ▁* ▁* ▁ne _ types ▁= ▁OPENSSL _ malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁char ▁* ▁* ▁ne _ values ▁= ▁OPENSSL _ malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁int ▁* ▁m val ▁= ▁OPENSSL _ malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁char ▁* ▁sp ▁= ▁subject ▁, ▁* ▁bp ▁= ▁buf ▁; ▁int ▁i ▁, ▁ne _ num ▁= ▁0 ▁; ▁X 509_ NAME ▁* ▁n ▁= ▁NULL ▁; ▁int ▁nid ▁; ▁if ▁( ▁! ▁buf ▁|| ▁! ▁ne _ types ▁|| ▁! ▁ne _ values ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" malloc error \ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁if ▁( ▁* ▁subject ▁!= ▁' ▁' ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Subject does not start with ' / ' .\ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁sp ▁++ ▁; ▁m val ▁[ ▁ne _ num ▁] ▁= ▁0 ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁ne _ types ▁[ ▁ne _ num ▁] ▁= ▁bp ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁if ▁( ▁* ▁sp ▁== ▁' ▁\\ ▁' ▁) ▁{ ▁if ▁( ▁* ▁++ ▁sp ▁) ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" escape character at end of string \ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁) ▁{ ▁sp ▁++ ▁; ▁* ▁bp ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁break ▁; ▁} ▁else ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁} ▁if ▁( ▁! ▁* ▁sp ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" end of string en countered while processing typeof subject name element #% d \ n " ▁, ▁ne _ num ▁) ▁; ▁goto ▁error ▁; ▁} ▁ne _ values ▁[ ▁ne _ num ▁] ▁= ▁bp ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁if ▁( ▁* ▁sp ▁== ▁' ▁\\ ▁' ▁) ▁{ ▁if ▁( ▁* ▁++ ▁sp ▁) ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" escape character at end of string \ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁) ▁{ ▁sp ▁++ ▁; ▁m val ▁[ ▁ne _ num ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁&& ▁mult ird n ▁) ▁{ ▁sp ▁++ ▁; ▁m val ▁[ ▁ne _ num ▁+ ▁1 ▁] ▁= ▁-1 ▁; ▁break ▁; ▁} ▁else ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁} ▁* ▁bp ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁ne _ num ▁++ ▁; ▁} ▁if ▁( ▁! ▁( ▁n ▁= ▁X 509_ NAME _ new ▁( ▁) ▁) ▁) ▁goto ▁error ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ne _ num ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁nid ▁= ▁OBJ _ txt 2 nid ▁( ▁ne _ types ▁[ ▁i ▁] ▁) ▁) ▁== ▁NID _ undef ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Subject Attribute % sh as no known NID , skipped \ n " ▁, ▁ne _ types ▁[ ▁i ▁] ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁! ▁* ▁ne _ values ▁[ ▁i ▁] ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" No value provide df or Subject Attribute % s , skipped \ n " ▁, ▁ne _ types ▁[ ▁i ▁] ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁! ▁X 509_ NAME _ add _ entry _ by _ NID ▁( ▁n ▁, ▁nid ▁, ▁chtype ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁ne _ values ▁[ ▁i ▁] ▁, ▁-1 ▁, ▁-1 ▁, ▁m val ▁[ ▁i ▁] ▁) ▁) ▁goto ▁error ▁; ▁} ▁OPENSSL _ free ▁( ▁ne _ values ▁) ▁; ▁OPENSSL _ free ▁( ▁ne _ types ▁) ▁; ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁OPENSSL _ free ▁( ▁m val ▁) ▁; ▁return ▁n ▁; ▁error ▁: ▁X 509_ NAME _ free ▁( ▁n ▁) ▁; ▁if ▁( ▁ne _ values ▁) ▁OPENSSL _ free ▁( ▁ne _ values ▁) ▁; ▁if ▁( ▁ne _ types ▁) ▁OPENSSL _ free ▁( ▁ne _ types ▁) ▁; ▁if ▁( ▁m val ▁) ▁OPENSSL _ free ▁( ▁m val ▁) ▁; ▁if ▁( ▁buf ▁) ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁int ▁ASN 1_ TIME _ diff ▁( ▁int ▁* ▁p day ▁, ▁int ▁* ▁p sec ▁, ▁const ▁ASN 1_ TIME ▁* ▁from ▁, ▁const ▁ASN 1_ TIME ▁* ▁to ▁) ▁{ ▁struct ▁tm ▁tm _ from ▁, ▁tm _ to ▁; ▁if ▁( ▁! ▁ASN 1_ TIME _ to _ tm ▁( ▁from ▁, ▁& ▁tm _ from ▁) ▁) ▁return ▁0 ▁; ▁if ▁( ▁! ▁ASN 1_ TIME _ to _ tm ▁( ▁to ▁, ▁& ▁tm _ to ▁) ▁) ▁return ▁0 ▁; ▁return ▁OPENSSL _ gmt ime _ diff ▁( ▁p day ▁, ▁p sec ▁, ▁& ▁tm _ from ▁, ▁& ▁tm _ to ▁) ▁; ▁}	0
▁void ▁SSL _ CTX _ free ▁( ▁SSL _ CTX ▁* ▁a ▁) ▁{ ▁int ▁i ▁; ▁if ▁( ▁a ▁== ▁NULL ▁) ▁return ▁; ▁CRYPTO _ DOWN _ REF ▁( ▁& ▁a ▁-> ▁references ▁, ▁& ▁i ▁, ▁a ▁-> ▁lock ▁) ▁; ▁REF _ PRINT _ COUNT ▁( ▁" SSL _ CTX " ▁, ▁a ▁) ▁; ▁if ▁( ▁i ▁> ▁0 ▁) ▁return ▁; ▁REF _ ASSERT _ IS NT ▁( ▁i ▁< ▁0 ▁) ▁; ▁X 509_ VERIFY _ PARAM _ free ▁( ▁a ▁-> ▁param ▁) ▁; ▁d ane _ ctx _ final ▁( ▁& ▁a ▁-> ▁d ane ▁) ▁; ▁if ▁( ▁a ▁-> ▁sessions ▁!= ▁NULL ▁) ▁SSL _ CTX _ flush _ sess ions ▁( ▁a ▁, ▁0 ▁) ▁; ▁CRYPTO _ free _ ex _ data ▁( ▁CRYPTO _ EX _ INDEX _ SSL _ CTX ▁, ▁a ▁, ▁& ▁a ▁-> ▁ex _ data ▁) ▁; ▁lh _ SSL _ SESSION _ free ▁( ▁a ▁-> ▁sessions ▁) ▁; ▁X 509_ STORE _ free ▁( ▁a ▁-> ▁cert _ store ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ CT ▁CT LOG _ STORE _ free ▁( ▁a ▁-> ▁ct log _ store ▁) ▁; ▁# endif ▁sk _ SSL _ CIPHER _ free ▁( ▁a ▁-> ▁cipher _ list ▁) ▁; ▁sk _ SSL _ CIPHER _ free ▁( ▁a ▁-> ▁cipher _ list _ by _ id ▁) ▁; ▁sk _ SSL _ CIPHER _ free ▁( ▁a ▁-> ▁tls 13_ c iphers u ites ▁) ▁; ▁ssl _ cert _ free ▁( ▁a ▁-> ▁cert ▁) ▁; ▁sk _ X 509_ NAME _ pop _ free ▁( ▁a ▁-> ▁ca _ names ▁, ▁X 509_ NAME _ free ▁) ▁; ▁sk _ X 509_ pop _ free ▁( ▁a ▁-> ▁extra _ certs ▁, ▁X 509_ free ▁) ▁; ▁a ▁-> ▁comp _ methods ▁= ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ SR TP ▁sk _ SR TP _ PROTECTION _ PROFILE _ free ▁( ▁a ▁-> ▁srtp _ profiles ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ SR P ▁SSL _ CTX _ SR P _ CTX _ free ▁( ▁a ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ ENGINE ▁ENGINE _ finish ▁( ▁a ▁-> ▁client _ cert _ engine ▁) ▁; ▁# endif ▁# ifndef ▁OPENSSL _ NO _ EC ▁OPENSSL _ free ▁( ▁a ▁-> ▁ext ▁. ▁ec point formats ▁) ▁; ▁OPENSSL _ free ▁( ▁a ▁-> ▁ext ▁. ▁supported groups ▁) ▁; ▁# endif ▁OPENSSL _ free ▁( ▁a ▁-> ▁ext ▁. ▁al pn ▁) ▁; ▁CRYPTO _ THREAD _ lock _ free ▁( ▁a ▁-> ▁lock ▁) ▁; ▁OPENSSL _ free ▁( ▁a ▁) ▁; ▁}	0
▁static ▁double ▁s ws _ dc Vec ▁( ▁S ws Vector ▁* ▁a ▁) ▁{ ▁int ▁i ▁; ▁double ▁sum ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁a ▁-> ▁length ▁; ▁i ▁++ ▁) ▁sum ▁+= ▁a ▁-> ▁coeff ▁[ ▁i ▁] ▁; ▁return ▁sum ▁; ▁}	1
▁static ▁HW Device ▁* ▁hw _ device _ match _ by _ codec ▁( ▁const ▁AVCodec ▁* ▁codec ▁) ▁{ ▁const ▁AVCodec HW Config ▁* ▁config ▁; ▁HW Device ▁* ▁dev ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁; ▁i ▁++ ▁) ▁{ ▁config ▁= ▁avcodec _ get _ hw _ config ▁( ▁codec ▁, ▁i ▁) ▁; ▁if ▁( ▁! ▁config ▁) ▁return ▁NULL ▁; ▁if ▁( ▁! ▁( ▁config ▁-> ▁methods ▁& ▁AV _ CODEC _ HW _ CONFIG _ METHOD _ HW _ DEVICE _ CTX ▁) ▁) ▁continue ▁; ▁dev ▁= ▁hw _ device _ get _ by _ type ▁( ▁config ▁-> ▁device _ type ▁) ▁; ▁if ▁( ▁dev ▁) ▁return ▁dev ▁; ▁} ▁}	0
▁static ▁void ▁filter _ mb _ mb aff _ ed g ec v ▁( ▁H 264 Context ▁* ▁h ▁, ▁uint 8_ t ▁* ▁pix ▁, ▁int ▁stride ▁, ▁int 16_ t ▁b S ▁[ ▁7 ▁] ▁, ▁int ▁b si ▁, ▁int ▁qp ▁) ▁{ ▁int ▁index _ a ▁= ▁qp ▁+ ▁h ▁-> ▁slice _ alpha _ c 0_ offset ▁; ▁int ▁alpha ▁= ▁alpha _ table ▁[ ▁index _ a ▁] ▁; ▁int ▁beta ▁= ▁beta _ table ▁[ ▁qp ▁+ ▁h ▁-> ▁slice _ beta _ offset ▁] ▁; ▁if ▁( ▁alpha ▁== ▁0 ▁|| ▁beta ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁b S ▁[ ▁0 ▁] ▁< ▁4 ▁) ▁{ ▁int 8_ t ▁tc ▁[ ▁4 ▁] ▁; ▁tc ▁[ ▁0 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁0 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁tc ▁[ ▁1 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁1 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁tc ▁[ ▁2 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁2 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁tc ▁[ ▁3 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁3 ▁* ▁b si ▁] ▁] ▁+ ▁1 ▁; ▁h ▁-> ▁h 264 dsp ▁. ▁h 264_ h _ loop _ filter _ chroma _ mb aff ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁, ▁tc ▁) ▁; ▁} ▁else ▁{ ▁h ▁-> ▁h 264 dsp ▁. ▁h 264_ h _ loop _ filter _ chroma _ mb aff _ intra ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁) ▁; ▁} ▁}	0
▁static ▁void ▁get _ tag ▁( ▁AVFormatContext ▁* ▁s ▁, ▁const ▁char ▁* ▁key ▁, ▁int ▁type ▁, ▁int ▁len ▁, ▁int ▁type 2_ size ▁) ▁{ ▁char ▁* ▁value ▁; ▁int 64_ t ▁off ▁= ▁avio _ tell ▁( ▁s ▁-> ▁pb ▁) ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁len ▁>= ▁( ▁UINT _ MAX ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁return ▁; ▁value ▁= ▁av _ malloc ▁( ▁2 ▁* ▁len ▁+ ▁1 ▁) ▁; ▁if ▁( ▁! ▁value ▁) ▁goto ▁finish ▁; ▁if ▁( ▁type ▁== ▁0 ▁) ▁{ ▁avio _ get _ str 16 le ▁( ▁s ▁-> ▁pb ▁, ▁len ▁, ▁value ▁, ▁2 ▁* ▁len ▁+ ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁-1 ▁) ▁{ ▁avio _ read ▁( ▁s ▁-> ▁pb ▁, ▁value ▁, ▁len ▁) ▁; ▁value ▁[ ▁len ▁] ▁= ▁0 ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁1 ▁) ▁{ ▁if ▁( ▁! ▁strcmp ▁( ▁key ▁, ▁" WM / Picture " ▁) ▁) ▁{ ▁as f _ read _ picture ▁( ▁s ▁, ▁len ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁strcmp ▁( ▁key ▁, ▁" ID 3" ▁) ▁) ▁{ ▁get _ id 3_ tag ▁( ▁s ▁, ▁len ▁) ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ VERBOSE ▁, ▁" Unsupported byte array int ag % s .\ n " ▁, ▁key ▁) ▁; ▁} ▁goto ▁finish ▁; ▁} ▁else ▁if ▁( ▁type ▁> ▁1 ▁&& ▁type ▁<= ▁5 ▁) ▁{ ▁uint 64_ t ▁num ▁= ▁get _ value ▁( ▁s ▁-> ▁pb ▁, ▁type ▁, ▁type 2_ size ▁) ▁; ▁snprintf ▁( ▁value ▁, ▁len ▁, ▁"%" ▁PRIu 64 ▁, ▁num ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁== ▁6 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Unsupported GUID value int ag % s .\ n " ▁, ▁key ▁) ▁; ▁goto ▁finish ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ DEBUG ▁, ▁" Unsupported valu etype % d int ag % s .\ n " ▁, ▁type ▁, ▁key ▁) ▁; ▁goto ▁finish ▁; ▁} ▁if ▁( ▁* ▁value ▁) ▁av _ dict _ set ▁( ▁& ▁s ▁-> ▁metadata ▁, ▁key ▁, ▁value ▁, ▁0 ▁) ▁; ▁finish ▁: ▁av _ freep ▁( ▁& ▁value ▁) ▁; ▁avio _ seek ▁( ▁s ▁-> ▁pb ▁, ▁off ▁+ ▁len ▁, ▁SEEK _ SET ▁) ▁; ▁}	1
▁int ▁BN _ BL IND ING _ convert _ ex ▁( ▁BIGNUM ▁* ▁n ▁, ▁BIGNUM ▁* ▁r ▁, ▁BN _ BL IND ING ▁* ▁b ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁ret ▁= ▁1 ▁; ▁bn _ check _ top ▁( ▁n ▁) ▁; ▁if ▁( ▁( ▁b ▁-> ▁A ▁== ▁NULL ▁) ▁|| ▁( ▁b ▁-> ▁Ai ▁== ▁NULL ▁) ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ BL IND ING _ CONVERT _ EX ▁, ▁BN _ R _ NOT _ INITIALIZED ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁b ▁-> ▁counter ▁== ▁-1 ▁) ▁b ▁-> ▁counter ▁= ▁0 ▁; ▁else ▁if ▁( ▁! ▁BN _ BL IND ING _ update ▁( ▁b ▁, ▁ctx ▁) ▁) ▁return ▁( ▁0 ▁) ▁; ▁if ▁( ▁r ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁BN _ copy ▁( ▁r ▁, ▁b ▁-> ▁Ai ▁) ▁) ▁ret ▁= ▁0 ▁; ▁} ▁if ▁( ▁! ▁BN _ mod _ mul ▁( ▁n ▁, ▁n ▁, ▁b ▁-> ▁A ▁, ▁b ▁-> ▁mod ▁, ▁ctx ▁) ▁) ▁ret ▁= ▁0 ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁ff _ rm _ ret rieve _ cache ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁, ▁AVStream ▁* ▁st ▁, ▁RM Stream ▁* ▁ast ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁R MD emux Context ▁* ▁rm ▁= ▁s ▁-> ▁priv _ data ▁; ▁av _ assert 0 ▁( ▁rm ▁-> ▁audio _ pkt _ cnt ▁> ▁0 ▁) ▁; ▁if ▁( ▁ast ▁-> ▁de int _ id ▁== ▁DE INT _ ID _ V BR F ▁|| ▁ast ▁-> ▁de int _ id ▁== ▁DE INT _ ID _ V BR S ▁) ▁av _ get _ packet ▁( ▁pb ▁, ▁pkt ▁, ▁ast ▁-> ▁sub _ packet _ length s ▁[ ▁ast ▁-> ▁sub _ packet _ cnt ▁- ▁rm ▁-> ▁audio _ pkt _ cnt ▁] ▁) ▁; ▁else ▁{ ▁if ▁( ▁av _ new _ packet ▁( ▁pkt ▁, ▁st ▁-> ▁codec ▁-> ▁block _ align ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁memcpy ▁( ▁pkt ▁-> ▁data ▁, ▁ast ▁-> ▁pkt ▁. ▁data ▁+ ▁st ▁-> ▁codec ▁-> ▁block _ align ▁* ▁( ▁ast ▁-> ▁sub _ packet _ h ▁* ▁ast ▁-> ▁audio _ frames ize ▁/ ▁st ▁-> ▁codec ▁-> ▁block _ align ▁- ▁rm ▁-> ▁audio _ pkt _ cnt ▁) ▁, ▁st ▁-> ▁codec ▁-> ▁block _ align ▁) ▁; ▁} ▁rm ▁-> ▁audio _ pkt _ cnt ▁-- ▁; ▁if ▁( ▁( ▁pkt ▁-> ▁pts ▁= ▁ast ▁-> ▁aud iot im estamp ▁) ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁ast ▁-> ▁aud iot im estamp ▁= ▁AV _ NOP TS _ VALUE ▁; ▁pkt ▁-> ▁flags ▁= ▁AV _ PKT _ FLAG _ KEY ▁; ▁} ▁else ▁pkt ▁-> ▁flags ▁= ▁0 ▁; ▁pkt ▁-> ▁stream _ index ▁= ▁st ▁-> ▁index ▁; ▁return ▁rm ▁-> ▁audio _ pkt _ cnt ▁; ▁}	1
▁static ▁char ▁* ▁ngx _ http _ core _ type ▁( ▁ngx _ conf _ t ▁* ▁cf ▁, ▁ngx _ command _ t ▁* ▁dummy ▁, ▁void ▁* ▁conf ▁) ▁{ ▁ngx _ http _ core _ loc _ conf _ t ▁* ▁cl cf ▁= ▁conf ▁; ▁ngx _ str _ t ▁* ▁value ▁, ▁* ▁content _ type ▁, ▁* ▁old ▁; ▁ngx _ uint _ t ▁i ▁, ▁n ▁, ▁hash ▁; ▁ngx _ hash _ key _ t ▁* ▁type ▁; ▁value ▁= ▁cf ▁-> ▁args ▁-> ▁elts ▁; ▁if ▁( ▁ngx _ strcmp ▁( ▁value ▁[ ▁0 ▁] ▁. ▁data ▁, ▁" include " ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁cf ▁-> ▁args ▁-> ▁nel ts ▁!= ▁2 ▁) ▁{ ▁ngx _ conf _ log _ error ▁( ▁NGX _ LOG _ EMERG ▁, ▁cf ▁, ▁0 ▁, ▁" invalid number of arguments " ▁" in \" include \" direct ive " ▁) ▁; ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁return ▁ngx _ conf _ include ▁( ▁cf ▁, ▁dummy ▁, ▁conf ▁) ▁; ▁} ▁content _ type ▁= ▁ngx _ palloc ▁( ▁cf ▁-> ▁pool ▁, ▁sizeof ▁( ▁ngx _ str _ t ▁) ▁) ▁; ▁if ▁( ▁content _ type ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁* ▁content _ type ▁= ▁value ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁cf ▁-> ▁args ▁-> ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁hash ▁= ▁ngx _ hash _ str low ▁( ▁value ▁[ ▁i ▁] ▁. ▁data ▁, ▁value ▁[ ▁i ▁] ▁. ▁data ▁, ▁value ▁[ ▁i ▁] ▁. ▁len ▁) ▁; ▁type ▁= ▁cl cf ▁-> ▁types ▁-> ▁elts ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁cl cf ▁-> ▁types ▁-> ▁nel ts ▁; ▁n ▁++ ▁) ▁{ ▁if ▁( ▁ngx _ strcmp ▁( ▁value ▁[ ▁i ▁] ▁. ▁data ▁, ▁type ▁[ ▁n ▁] ▁. ▁key ▁. ▁data ▁) ▁== ▁0 ▁) ▁{ ▁old ▁= ▁type ▁[ ▁n ▁] ▁. ▁value ▁; ▁type ▁[ ▁n ▁] ▁. ▁value ▁= ▁content _ type ▁; ▁ngx _ conf _ log _ error ▁( ▁NGX _ LOG _ WARN ▁, ▁cf ▁, ▁0 ▁, ▁" duplicate extension \"% V \"," ▁" content type : \"% V \"," ▁" previous content type : \"% V \"" ▁, ▁& ▁value ▁[ ▁i ▁] ▁, ▁content _ type ▁, ▁old ▁) ▁; ▁goto ▁next ▁; ▁} ▁} ▁type ▁= ▁ngx _ array _ push ▁( ▁cl cf ▁-> ▁types ▁) ▁; ▁if ▁( ▁type ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ CONF _ ERROR ▁; ▁} ▁type ▁-> ▁key ▁= ▁value ▁[ ▁i ▁] ▁; ▁type ▁-> ▁key _ hash ▁= ▁hash ▁; ▁type ▁-> ▁value ▁= ▁content _ type ▁; ▁next ▁: ▁continue ▁; ▁} ▁return ▁NGX _ CONF _ OK ▁; ▁}	0
▁static ▁ngx _ int _ t ▁ngx _ http _ ssi _ include ▁( ▁ngx _ http _ request _ t ▁* ▁r ▁, ▁ngx _ http _ ssi _ ctx _ t ▁* ▁ctx ▁, ▁ngx _ str _ t ▁* ▁* ▁params ▁) ▁{ ▁ngx _ int _ t ▁rc ▁, ▁key ▁; ▁ngx _ str _ t ▁* ▁uri ▁, ▁* ▁file ▁, ▁* ▁wait ▁, ▁* ▁set ▁, ▁* ▁stub ▁, ▁args ▁; ▁ngx _ buf _ t ▁* ▁b ▁; ▁ngx _ uint _ t ▁flags ▁, ▁i ▁; ▁ngx _ chain _ t ▁* ▁cl ▁, ▁* ▁tl ▁, ▁* ▁* ▁ll ▁, ▁* ▁out ▁; ▁ngx _ http _ request _ t ▁* ▁sr ▁; ▁ngx _ http _ ssi _ var _ t ▁* ▁var ▁; ▁ngx _ http _ ssi _ ctx _ t ▁* ▁mctx ▁; ▁ngx _ http _ ssi _ block _ t ▁* ▁bl ▁; ▁ngx _ http _ post _ sub request _ t ▁* ▁psr ▁; ▁uri ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ VIRTUAL ▁] ▁; ▁file ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ FILE ▁] ▁; ▁wait ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ WAIT ▁] ▁; ▁set ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ SET ▁] ▁; ▁stub ▁= ▁params ▁[ ▁NGX _ HTTP _ S SI _ INCLUDE _ STUB ▁] ▁; ▁if ▁( ▁uri ▁&& ▁file ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" in lc usion may bee ither virtual =\"% V \" or file =\"% V \"" ▁, ▁uri ▁, ▁file ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁uri ▁== ▁NULL ▁&& ▁file ▁== ▁NULL ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" nop arameter in \" include \" S SI command " ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁set ▁&& ▁stub ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁"\" set \" and \" stub \" cannot be used to gether " ▁" in \" include \" S SI command " ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁wait ▁) ▁{ ▁if ▁( ▁uri ▁== ▁NULL ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁"\" wait \" cannot be used with file =\"% V \"" ▁, ▁file ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁wait ▁-> ▁len ▁== ▁2 ▁&& ▁ngx _ strncasecmp ▁( ▁wait ▁-> ▁data ▁, ▁( ▁u _ char ▁* ▁) ▁" no " ▁, ▁2 ▁) ▁== ▁0 ▁) ▁{ ▁wait ▁= ▁NULL ▁; ▁} ▁else ▁if ▁( ▁wait ▁-> ▁len ▁!= ▁3 ▁|| ▁ngx _ strncasecmp ▁( ▁wait ▁-> ▁data ▁, ▁( ▁u _ char ▁* ▁) ▁" yes " ▁, ▁3 ▁) ▁!= ▁0 ▁) ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" invalid value \"% V \" int he \" wait \" parameter " ▁, ▁wait ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁} ▁if ▁( ▁uri ▁== ▁NULL ▁) ▁{ ▁uri ▁= ▁file ▁; ▁wait ▁= ▁( ▁ngx _ str _ t ▁* ▁) ▁-1 ▁; ▁} ▁rc ▁= ▁ngx _ http _ ssi _ evaluate _ string ▁( ▁r ▁, ▁ctx ▁, ▁uri ▁, ▁NGX _ HTTP _ S SI _ ADD _ PREFIX ▁) ▁; ▁if ▁( ▁rc ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁rc ▁; ▁} ▁ngx _ log _ debug 1 ▁( ▁NGX _ LOG _ DEBUG _ HTTP ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" ssi include : \"% V \"" ▁, ▁uri ▁) ▁; ▁ngx _ str _ null ▁( ▁& ▁args ▁) ▁; ▁flags ▁= ▁NGX _ HTTP _ LOG _ UN SAFE ▁; ▁if ▁( ▁ngx _ http _ parse _ unsafe _ uri ▁( ▁r ▁, ▁uri ▁, ▁& ▁args ▁, ▁& ▁flags ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁psr ▁= ▁NULL ▁; ▁mctx ▁= ▁ngx _ http _ get _ module _ ctx ▁( ▁r ▁-> ▁main ▁, ▁ngx _ http _ ssi _ filter _ module ▁) ▁; ▁if ▁( ▁stub ▁) ▁{ ▁if ▁( ▁mctx ▁-> ▁blocks ▁) ▁{ ▁bl ▁= ▁mctx ▁-> ▁blocks ▁-> ▁elts ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁mctx ▁-> ▁blocks ▁-> ▁nel ts ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁stub ▁-> ▁len ▁== ▁bl ▁[ ▁i ▁] ▁. ▁name ▁. ▁len ▁&& ▁ngx _ strncmp ▁( ▁stub ▁-> ▁data ▁, ▁bl ▁[ ▁i ▁] ▁. ▁name ▁. ▁data ▁, ▁stub ▁-> ▁len ▁) ▁== ▁0 ▁) ▁{ ▁goto ▁found ▁; ▁} ▁} ▁} ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁"\" stub \" =\"% V \" for \" include \" not found " ▁, ▁stub ▁) ▁; ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁found ▁: ▁psr ▁= ▁ngx _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁sizeof ▁( ▁ngx _ http _ post _ sub request _ t ▁) ▁) ▁; ▁if ▁( ▁psr ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁psr ▁-> ▁handler ▁= ▁ngx _ http _ ssi _ stub _ output ▁; ▁if ▁( ▁bl ▁[ ▁i ▁] ▁. ▁count ▁++ ▁) ▁{ ▁out ▁= ▁NULL ▁; ▁ll ▁= ▁& ▁out ▁; ▁for ▁( ▁tl ▁= ▁bl ▁[ ▁i ▁] ▁. ▁bufs ▁; ▁tl ▁; ▁tl ▁= ▁tl ▁-> ▁next ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁free ▁) ▁{ ▁cl ▁= ▁ctx ▁-> ▁free ▁; ▁ctx ▁-> ▁free ▁= ▁ctx ▁-> ▁free ▁-> ▁next ▁; ▁b ▁= ▁cl ▁-> ▁buf ▁; ▁} ▁else ▁{ ▁b ▁= ▁ngx _ alloc _ buf ▁( ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁b ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁cl ▁= ▁ngx _ alloc _ chain _ link ▁( ▁r ▁-> ▁pool ▁) ▁; ▁if ▁( ▁cl ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁cl ▁-> ▁buf ▁= ▁b ▁; ▁} ▁ngx _ memcpy ▁( ▁b ▁, ▁tl ▁-> ▁buf ▁, ▁sizeof ▁( ▁ngx _ buf _ t ▁) ▁) ▁; ▁b ▁-> ▁pos ▁= ▁b ▁-> ▁start ▁; ▁* ▁ll ▁= ▁cl ▁; ▁cl ▁-> ▁next ▁= ▁NULL ▁; ▁ll ▁= ▁& ▁cl ▁-> ▁next ▁; ▁} ▁psr ▁-> ▁data ▁= ▁out ▁; ▁} ▁else ▁{ ▁psr ▁-> ▁data ▁= ▁bl ▁[ ▁i ▁] ▁. ▁bufs ▁; ▁} ▁} ▁if ▁( ▁wait ▁) ▁{ ▁flags ▁|= ▁NGX _ HTTP _ SUB REQUEST _ WAIT ED ▁; ▁} ▁if ▁( ▁set ▁) ▁{ ▁key ▁= ▁ngx _ hash _ str low ▁( ▁set ▁-> ▁data ▁, ▁set ▁-> ▁data ▁, ▁set ▁-> ▁len ▁) ▁; ▁psr ▁= ▁ngx _ palloc ▁( ▁r ▁-> ▁pool ▁, ▁sizeof ▁( ▁ngx _ http _ post _ sub request _ t ▁) ▁) ▁; ▁if ▁( ▁psr ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁psr ▁-> ▁handler ▁= ▁ngx _ http _ ssi _ set _ variable ▁; ▁psr ▁-> ▁data ▁= ▁ngx _ http _ ssi _ get _ variable ▁( ▁r ▁, ▁set ▁, ▁key ▁) ▁; ▁if ▁( ▁psr ▁-> ▁data ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁mctx ▁-> ▁variables ▁== ▁NULL ▁) ▁{ ▁mctx ▁-> ▁variables ▁= ▁ngx _ list _ create ▁( ▁r ▁-> ▁pool ▁, ▁4 ▁, ▁sizeof ▁( ▁ngx _ http _ ssi _ var _ t ▁) ▁) ▁; ▁if ▁( ▁mctx ▁-> ▁variables ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁} ▁var ▁= ▁ngx _ list _ push ▁( ▁mctx ▁-> ▁variables ▁) ▁; ▁if ▁( ▁var ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ ERROR ▁; ▁} ▁var ▁-> ▁name ▁= ▁* ▁set ▁; ▁var ▁-> ▁key ▁= ▁key ▁; ▁var ▁-> ▁value ▁= ▁ngx _ http _ ssi _ null _ string ▁; ▁psr ▁-> ▁data ▁= ▁& ▁var ▁-> ▁value ▁; ▁} ▁flags ▁|= ▁NGX _ HTTP _ SUB REQUEST _ IN _ MEMORY ▁| ▁NGX _ HTTP _ SUB REQUEST _ WAIT ED ▁; ▁} ▁if ▁( ▁ngx _ http _ sub request ▁( ▁r ▁, ▁uri ▁, ▁& ▁args ▁, ▁& ▁sr ▁, ▁psr ▁, ▁flags ▁) ▁!= ▁NGX _ OK ▁) ▁{ ▁return ▁NGX _ HTTP _ S SI _ ERROR ▁; ▁} ▁if ▁( ▁wait ▁== ▁NULL ▁&& ▁set ▁== ▁NULL ▁) ▁{ ▁return ▁NGX _ OK ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁wait ▁== ▁NULL ▁) ▁{ ▁ctx ▁-> ▁wait ▁= ▁sr ▁; ▁return ▁NGX _ AGAIN ▁; ▁} ▁else ▁{ ▁ngx _ log _ error ▁( ▁NGX _ LOG _ ERR ▁, ▁r ▁-> ▁connection ▁-> ▁log ▁, ▁0 ▁, ▁" can only wait for ones ub request at atime " ▁) ▁; ▁} ▁return ▁NGX _ OK ▁; ▁}	0
▁static ▁int ▁h ls _ slice _ data _ w pp ▁( ▁H EV C Context ▁* ▁s ▁, ▁const ▁uint 8_ t ▁* ▁nal ▁, ▁int ▁length ▁) ▁{ ▁H EV CL ocal Context ▁* ▁lc ▁= ▁s ▁-> ▁H EV C lc ▁; ▁int ▁* ▁ret ▁= ▁av _ malloc _ array ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁, ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁* ▁arg ▁= ▁av _ malloc _ array ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁, ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁int ▁offset ▁; ▁int ▁start header ▁, ▁c mpt ▁= ▁0 ▁; ▁int ▁i ▁, ▁j ▁, ▁res ▁= ▁0 ▁; ▁if ▁( ▁! ▁s ▁-> ▁s List ▁[ ▁1 ▁] ▁) ▁{ ▁ff _ alloc _ entries ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁H EV CL ocal Context ▁) ▁) ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁} ▁} ▁offset ▁= ▁( ▁lc ▁-> ▁gb ▁. ▁index ▁>> ▁3 ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁, ▁c mpt ▁= ▁0 ▁, ▁start header ▁= ▁offset ▁+ ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁0 ▁] ▁; ▁j ▁< ▁s ▁-> ▁skipped _ bytes ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁>= ▁offset ▁&& ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁< ▁start header ▁) ▁{ ▁start header ▁-- ▁; ▁c mpt ▁++ ▁; ▁} ▁} ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁{ ▁offset ▁+= ▁( ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁- ▁1 ▁] ▁- ▁c mpt ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁, ▁c mpt ▁= ▁0 ▁, ▁start header ▁= ▁offset ▁+ ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁] ▁; ▁j ▁< ▁s ▁-> ▁skipped _ bytes ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁>= ▁offset ▁&& ▁s ▁-> ▁skipped _ bytes _ pos ▁[ ▁j ▁] ▁< ▁start header ▁) ▁{ ▁start header ▁-- ▁; ▁c mpt ▁++ ▁; ▁} ▁} ▁s ▁-> ▁sh ▁. ▁size ▁[ ▁i ▁- ▁1 ▁] ▁= ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁i ▁] ▁- ▁c mpt ▁; ▁s ▁-> ▁sh ▁. ▁offset ▁[ ▁i ▁- ▁1 ▁] ▁= ▁offset ▁; ▁} ▁if ▁( ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁!= ▁0 ▁) ▁{ ▁offset ▁+= ▁s ▁-> ▁sh ▁. ▁entry _ point _ offset ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁- ▁c mpt ▁; ▁s ▁-> ▁sh ▁. ▁size ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁= ▁length ▁- ▁offset ▁; ▁s ▁-> ▁sh ▁. ▁offset ▁[ ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁- ▁1 ▁] ▁= ▁offset ▁; ▁} ▁s ▁-> ▁data ▁= ▁nal ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁s ▁-> ▁threads _ number ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁-> ▁first _ qp _ group ▁= ▁1 ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁-> ▁qp _ y ▁= ▁s ▁-> ▁s List ▁[ ▁0 ▁] ▁-> ▁H EV C lc ▁-> ▁qp _ y ▁; ▁memcpy ▁( ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁H EV C Context ▁) ▁) ▁; ▁s ▁-> ▁s List ▁[ ▁i ▁] ▁-> ▁H EV C lc ▁= ▁s ▁-> ▁H EV C lc List ▁[ ▁i ▁] ▁; ▁} ▁avpriv _ atomic _ int _ set ▁( ▁& ▁s ▁-> ▁w pp _ err ▁, ▁0 ▁) ▁; ▁ff _ reset _ entries ▁( ▁s ▁-> ▁avctx ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁{ ▁arg ▁[ ▁i ▁] ▁= ▁i ▁; ▁ret ▁[ ▁i ▁] ▁= ▁0 ▁; ▁} ▁if ▁( ▁s ▁-> ▁pps ▁-> ▁entropy _ coding _ sync _ enabled _ flag ▁) ▁s ▁-> ▁avctx ▁-> ▁execute 2 ▁( ▁s ▁-> ▁avctx ▁, ▁( ▁void ▁* ▁) ▁h ls _ decode _ entry _ w pp ▁, ▁arg ▁, ▁ret ▁, ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁+ ▁1 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁<= ▁s ▁-> ▁sh ▁. ▁num _ entry _ point _ offsets ▁; ▁i ▁++ ▁) ▁res ▁+= ▁ret ▁[ ▁i ▁] ▁; ▁av _ free ▁( ▁ret ▁) ▁; ▁av _ free ▁( ▁arg ▁) ▁; ▁return ▁res ▁; ▁}	1
▁static ▁int ▁d nx hd _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁data ▁, ▁int ▁* ▁got _ frame ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁int ▁buf _ size ▁= ▁avpkt ▁-> ▁size ▁; ▁D NX HD Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁Thread Frame ▁frame ▁= ▁{ ▁. ▁f ▁= ▁data ▁} ▁; ▁AVFrame ▁* ▁picture ▁= ▁data ▁; ▁int ▁first _ field ▁= ▁1 ▁; ▁int ▁ret ▁, ▁i ▁; ▁ff _ d log ▁( ▁avctx ▁, ▁" frames ize % d \ n " ▁, ▁buf _ size ▁) ▁; ▁decode _ coding _ unit ▁: ▁if ▁( ▁( ▁ret ▁= ▁d nx hd _ decode _ header ▁( ▁ctx ▁, ▁picture ▁, ▁buf ▁, ▁buf _ size ▁, ▁first _ field ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁( ▁avctx ▁-> ▁width ▁|| ▁avctx ▁-> ▁height ▁) ▁&& ▁( ▁ctx ▁-> ▁width ▁!= ▁avctx ▁-> ▁width ▁|| ▁ctx ▁-> ▁height ▁!= ▁avctx ▁-> ▁height ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" frames ize changed :% dx % d -> % dx % d \ n " ▁, ▁avctx ▁-> ▁width ▁, ▁avctx ▁-> ▁height ▁, ▁ctx ▁-> ▁width ▁, ▁ctx ▁-> ▁height ▁) ▁; ▁first _ field ▁= ▁1 ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁pix _ fmt ▁!= ▁AV _ PIX _ FMT _ NONE ▁&& ▁avctx ▁-> ▁pix _ fmt ▁!= ▁ctx ▁-> ▁pix _ fmt ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" pix _ fmt changed :% s -> % s \ n " ▁, ▁av _ get _ pix _ fmt _ name ▁( ▁avctx ▁-> ▁pix _ fmt ▁) ▁, ▁av _ get _ pix _ fmt _ name ▁( ▁ctx ▁-> ▁pix _ fmt ▁) ▁) ▁; ▁first _ field ▁= ▁1 ▁; ▁} ▁avctx ▁-> ▁pix _ fmt ▁= ▁ctx ▁-> ▁pix _ fmt ▁; ▁ret ▁= ▁ff _ set _ dimensions ▁( ▁avctx ▁, ▁ctx ▁-> ▁width ▁, ▁ctx ▁-> ▁height ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁first _ field ▁) ▁{ ▁if ▁( ▁( ▁ret ▁= ▁ff _ thread _ get _ buffer ▁( ▁avctx ▁, ▁& ▁frame ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁picture ▁-> ▁pict _ type ▁= ▁AV _ PICTURE _ TYPE _ I ▁; ▁picture ▁-> ▁key _ frame ▁= ▁1 ▁; ▁} ▁ctx ▁-> ▁buf _ size ▁= ▁buf _ size ▁- ▁ctx ▁-> ▁data _ offset ▁; ▁ctx ▁-> ▁buf ▁= ▁buf ▁+ ▁ctx ▁-> ▁data _ offset ▁; ▁avctx ▁-> ▁execute 2 ▁( ▁avctx ▁, ▁d nx hd _ decode _ row ▁, ▁picture ▁, ▁NULL ▁, ▁ctx ▁-> ▁mb _ height ▁) ▁; ▁if ▁( ▁first _ field ▁&& ▁picture ▁-> ▁inter l aced _ frame ▁) ▁{ ▁buf ▁+= ▁ctx ▁-> ▁cid _ table ▁-> ▁coding _ unit _ size ▁; ▁buf _ size ▁-= ▁ctx ▁-> ▁cid _ table ▁-> ▁coding _ unit _ size ▁; ▁first _ field ▁= ▁0 ▁; ▁goto ▁decode _ coding _ unit ▁; ▁} ▁ret ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁avctx ▁-> ▁thread _ count ▁; ▁i ▁++ ▁) ▁{ ▁ret ▁+= ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁errors ▁; ▁ctx ▁-> ▁rows ▁[ ▁i ▁] ▁. ▁errors ▁= ▁0 ▁; ▁} ▁if ▁( ▁ret ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"% d lines with errors \ n " ▁, ▁ret ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁* ▁got _ frame ▁= ▁1 ▁; ▁return ▁avpkt ▁-> ▁size ▁; ▁}	0
▁static ▁void ▁decode _ ton es _ a mplitude ▁( ▁Get Bit Context ▁* ▁gb ▁, ▁A tr ac 3 p Chan Unit Ctx ▁* ▁ctx ▁, ▁int ▁ch _ num ▁, ▁int ▁band _ has _ ton es ▁[ ▁] ▁) ▁{ ▁int ▁mode ▁, ▁sb ▁, ▁j ▁, ▁i ▁, ▁diff ▁, ▁max diff ▁, ▁fi ▁, ▁delta ▁, ▁pred ▁; ▁A tr ac 3 p Wave Param ▁* ▁w src ▁, ▁* ▁w ref ▁; ▁int ▁ref w aves ▁[ ▁48 ▁] ▁; ▁A tr ac 3 p W aves Data ▁* ▁dst ▁= ▁ctx ▁-> ▁channels ▁[ ▁ch _ num ▁] ▁. ▁t ones _ info ▁; ▁A tr ac 3 p W aves Data ▁* ▁ref ▁= ▁ctx ▁-> ▁channels ▁[ ▁0 ▁] ▁. ▁t ones _ info ▁; ▁if ▁( ▁ch _ num ▁) ▁{ ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁ctx ▁-> ▁w aves _ info ▁-> ▁num _ tone _ band s ▁; ▁sb ▁++ ▁) ▁{ ▁if ▁( ▁! ▁band _ has _ ton es ▁[ ▁sb ▁] ▁|| ▁! ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁) ▁continue ▁; ▁w src ▁= ▁& ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁] ▁; ▁w ref ▁= ▁& ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁ref ▁[ ▁sb ▁] ▁. ▁start _ index ▁] ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁; ▁j ▁++ ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁, ▁fi ▁= ▁0 ▁, ▁max diff ▁= ▁1024 ▁; ▁i ▁< ▁ref ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁; ▁i ▁++ ▁) ▁{ ▁diff ▁= ▁FF ABS ▁( ▁w src ▁[ ▁j ▁] ▁. ▁freq _ index ▁- ▁w ref ▁[ ▁i ▁] ▁. ▁freq _ index ▁) ▁; ▁if ▁( ▁diff ▁< ▁max diff ▁) ▁{ ▁max diff ▁= ▁diff ▁; ▁fi ▁= ▁i ▁; ▁} ▁} ▁if ▁( ▁max diff ▁< ▁8 ▁) ▁ref w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁j ▁] ▁= ▁fi ▁+ ▁ref ▁[ ▁sb ▁] ▁. ▁start _ index ▁; ▁else ▁if ▁( ▁j ▁< ▁ref ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁) ▁ref w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁j ▁] ▁= ▁j ▁+ ▁ref ▁[ ▁sb ▁] ▁. ▁start _ index ▁; ▁else ▁ref w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁j ▁] ▁= ▁-1 ▁; ▁} ▁} ▁} ▁mode ▁= ▁get _ bits ▁( ▁gb ▁, ▁ch _ num ▁+ ▁1 ▁) ▁; ▁switch ▁( ▁mode ▁) ▁{ ▁case ▁0 ▁: ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁ctx ▁-> ▁w aves _ info ▁-> ▁num _ tone _ band s ▁; ▁sb ▁++ ▁) ▁{ ▁if ▁( ▁! ▁band _ has _ ton es ▁[ ▁sb ▁] ▁|| ▁! ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁) ▁continue ▁; ▁if ▁( ▁ctx ▁-> ▁w aves _ info ▁-> ▁amplitude _ mode ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁; ▁i ▁++ ▁) ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁. ▁amp _ sf ▁= ▁get _ bits ▁( ▁gb ▁, ▁6 ▁) ▁; ▁else ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁] ▁. ▁amp _ sf ▁= ▁get _ bits ▁( ▁gb ▁, ▁6 ▁) ▁; ▁} ▁break ▁; ▁case ▁1 ▁: ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁ctx ▁-> ▁w aves _ info ▁-> ▁num _ tone _ band s ▁; ▁sb ▁++ ▁) ▁{ ▁if ▁( ▁! ▁band _ has _ ton es ▁[ ▁sb ▁] ▁|| ▁! ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁) ▁continue ▁; ▁if ▁( ▁ctx ▁-> ▁w aves _ info ▁-> ▁amplitude _ mode ▁) ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁; ▁i ▁++ ▁) ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁. ▁amp _ sf ▁= ▁get _ vlc 2 ▁( ▁gb ▁, ▁tone _ vlc _ tabs ▁[ ▁3 ▁] ▁. ▁table ▁, ▁tone _ vlc _ tabs ▁[ ▁3 ▁] ▁. ▁bits ▁, ▁1 ▁) ▁+ ▁20 ▁; ▁else ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁] ▁. ▁amp _ sf ▁= ▁get _ vlc 2 ▁( ▁gb ▁, ▁tone _ vlc _ tabs ▁[ ▁4 ▁] ▁. ▁table ▁, ▁tone _ vlc _ tabs ▁[ ▁4 ▁] ▁. ▁bits ▁, ▁1 ▁) ▁+ ▁24 ▁; ▁} ▁break ▁; ▁case ▁2 ▁: ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁ctx ▁-> ▁w aves _ info ▁-> ▁num _ tone _ band s ▁; ▁sb ▁++ ▁) ▁{ ▁if ▁( ▁! ▁band _ has _ ton es ▁[ ▁sb ▁] ▁|| ▁! ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁) ▁continue ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁; ▁i ▁++ ▁) ▁{ ▁delta ▁= ▁get _ vlc 2 ▁( ▁gb ▁, ▁tone _ vlc _ tabs ▁[ ▁5 ▁] ▁. ▁table ▁, ▁tone _ vlc _ tabs ▁[ ▁5 ▁] ▁. ▁bits ▁, ▁1 ▁) ▁; ▁delta ▁= ▁sign _ extend ▁( ▁delta ▁, ▁5 ▁) ▁; ▁pred ▁= ▁ref w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁>= ▁0 ▁? ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁ref w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁] ▁. ▁amp _ sf ▁: ▁34 ▁; ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁. ▁amp _ sf ▁= ▁( ▁pred ▁+ ▁delta ▁) ▁& ▁0 x 3 F ▁; ▁} ▁} ▁break ▁; ▁case ▁3 ▁: ▁for ▁( ▁sb ▁= ▁0 ▁; ▁sb ▁< ▁ctx ▁-> ▁w aves _ info ▁-> ▁num _ tone _ band s ▁; ▁sb ▁++ ▁) ▁{ ▁if ▁( ▁! ▁band _ has _ ton es ▁[ ▁sb ▁] ▁) ▁continue ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst ▁[ ▁sb ▁] ▁. ▁num _ wav s ▁; ▁i ▁++ ▁) ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁. ▁amp _ sf ▁= ▁ref w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁>= ▁0 ▁? ▁ctx ▁-> ▁w aves _ info ▁-> ▁w aves ▁[ ▁ref w aves ▁[ ▁dst ▁[ ▁sb ▁] ▁. ▁start _ index ▁+ ▁i ▁] ▁] ▁. ▁amp _ sf ▁: ▁32 ▁; ▁} ▁break ▁; ▁} ▁}	1
▁static ▁void ▁filter 18 1 ▁( ▁int 16_ t ▁* ▁data ▁, ▁int ▁width ▁, ▁int ▁height ▁, ▁int ▁stride ▁) ▁{ ▁int ▁x ▁, ▁y ▁; ▁for ▁( ▁y ▁= ▁1 ▁; ▁y ▁< ▁height ▁- ▁1 ▁; ▁y ▁++ ▁) ▁{ ▁int ▁prev _ dc ▁= ▁data ▁[ ▁0 ▁+ ▁y ▁* ▁stride ▁] ▁; ▁for ▁( ▁x ▁= ▁1 ▁; ▁x ▁< ▁width ▁- ▁1 ▁; ▁x ▁++ ▁) ▁{ ▁int ▁dc ▁; ▁dc ▁= ▁- ▁prev _ dc ▁+ ▁data ▁[ ▁x ▁+ ▁y ▁* ▁stride ▁] ▁* ▁8 ▁- ▁data ▁[ ▁x ▁+ ▁1 ▁+ ▁y ▁* ▁stride ▁] ▁; ▁dc ▁= ▁( ▁dc ▁* ▁109 23 ▁+ ▁32768 ▁) ▁>> ▁16 ▁; ▁prev _ dc ▁= ▁data ▁[ ▁x ▁+ ▁y ▁* ▁stride ▁] ▁; ▁data ▁[ ▁x ▁+ ▁y ▁* ▁stride ▁] ▁= ▁dc ▁; ▁} ▁} ▁for ▁( ▁x ▁= ▁1 ▁; ▁x ▁< ▁width ▁- ▁1 ▁; ▁x ▁++ ▁) ▁{ ▁int ▁prev _ dc ▁= ▁data ▁[ ▁x ▁] ▁; ▁for ▁( ▁y ▁= ▁1 ▁; ▁y ▁< ▁height ▁- ▁1 ▁; ▁y ▁++ ▁) ▁{ ▁int ▁dc ▁; ▁dc ▁= ▁- ▁prev _ dc ▁+ ▁data ▁[ ▁x ▁+ ▁y ▁* ▁stride ▁] ▁* ▁8 ▁- ▁data ▁[ ▁x ▁+ ▁( ▁y ▁+ ▁1 ▁) ▁* ▁stride ▁] ▁; ▁dc ▁= ▁( ▁dc ▁* ▁109 23 ▁+ ▁32768 ▁) ▁>> ▁16 ▁; ▁prev _ dc ▁= ▁data ▁[ ▁x ▁+ ▁y ▁* ▁stride ▁] ▁; ▁data ▁[ ▁x ▁+ ▁y ▁* ▁stride ▁] ▁= ▁dc ▁; ▁} ▁} ▁}	1
▁static ▁av _ always _ inline ▁void ▁yuv 2 mono _1_ c _ template ▁( ▁S ws Context ▁* ▁c ▁, ▁const ▁int 16_ t ▁* ▁buf 0 ▁, ▁const ▁int 16_ t ▁* ▁ubuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁vbuf ▁[ ▁2 ▁] ▁, ▁const ▁int 16_ t ▁* ▁a buf 0 ▁, ▁uint 8_ t ▁* ▁dest ▁, ▁int ▁dst W ▁, ▁int ▁u val pha ▁, ▁int ▁y ▁, ▁enum ▁PixelFormat ▁target ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁const ▁d 128 ▁= ▁d ither _8 x 8_ 220 ▁[ ▁y ▁& ▁7 ▁] ▁; ▁uint 8_ t ▁* ▁g ▁= ▁c ▁-> ▁table _ g U ▁[ ▁128 ▁] ▁+ ▁c ▁-> ▁table _ g V ▁[ ▁128 ▁] ▁; ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁dst W ▁- ▁7 ▁; ▁i ▁+= ▁8 ▁) ▁{ ▁int ▁acc ▁= ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁0 ▁] ▁] ▁; ▁acc ▁+= ▁acc ▁+ ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁+ ▁1 ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁1 ▁] ▁] ▁; ▁acc ▁+= ▁acc ▁+ ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁+ ▁2 ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁2 ▁] ▁] ▁; ▁acc ▁+= ▁acc ▁+ ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁+ ▁3 ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁3 ▁] ▁] ▁; ▁acc ▁+= ▁acc ▁+ ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁+ ▁4 ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁4 ▁] ▁] ▁; ▁acc ▁+= ▁acc ▁+ ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁+ ▁5 ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁5 ▁] ▁] ▁; ▁acc ▁+= ▁acc ▁+ ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁+ ▁6 ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁6 ▁] ▁] ▁; ▁acc ▁+= ▁acc ▁+ ▁g ▁[ ▁( ▁buf 0 ▁[ ▁i ▁+ ▁7 ▁] ▁>> ▁7 ▁) ▁+ ▁d 128 ▁[ ▁7 ▁] ▁] ▁; ▁output _ pixel ▁( ▁* ▁dest ▁++ ▁, ▁acc ▁) ▁; ▁} ▁}	0
▁static ▁int ▁raised _ error ▁( ▁void ▁) ▁{ ▁const ▁char ▁* ▁f ▁, ▁* ▁data ▁; ▁int ▁l ▁; ▁unsigned ▁long ▁e ▁; ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ FIL EN AMES ▁) ▁&& ▁! ▁defined ▁( ▁OPENSSL _ NO _ ERR ▁) ▁const ▁char ▁* ▁file ▁; ▁int ▁line ▁; ▁file ▁= ▁__ FILE __ ▁; ▁line ▁= ▁__ LINE __ ▁+ ▁2 ▁; ▁# endif ▁ERR _ raise _ data ▁( ▁ERR _ LIB _ SYS ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁, ▁" call ing exit ()" ▁) ▁; ▁if ▁( ▁! ▁TEST _ ulong _ ne ▁( ▁e ▁= ▁ERR _ get _ error _ line _ data ▁( ▁& ▁f ▁, ▁& ▁l ▁, ▁& ▁data ▁, ▁NULL ▁) ▁, ▁0 ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁ERR _ GET _ REASON ▁( ▁e ▁) ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ FIL EN AMES ▁) ▁&& ▁! ▁defined ▁( ▁OPENSSL _ NO _ ERR ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁l ▁, ▁line ▁) ▁|| ▁! ▁TEST _ str _ eq ▁( ▁f ▁, ▁file ▁) ▁# endif ▁|| ▁! ▁TEST _ str _ eq ▁( ▁data ▁, ▁" call ing exit ()" ▁) ▁) ▁return ▁0 ▁; ▁return ▁1 ▁; ▁}	0
▁static ▁char ▁* ▁app _ get _ pass ▁( ▁char ▁* ▁arg ▁, ▁int ▁keep bio ▁) ▁{ ▁char ▁* ▁tmp ▁, ▁tp ass ▁[ ▁APP _ PASS _ LEN ▁] ▁; ▁static ▁BIO ▁* ▁pw db io ▁= ▁NULL ▁; ▁int ▁i ▁; ▁if ▁( ▁strncmp ▁( ▁arg ▁, ▁" pass :" ▁, ▁5 ▁) ▁== ▁0 ▁) ▁return ▁OPENSSL _ strdup ▁( ▁arg ▁+ ▁5 ▁) ▁; ▁if ▁( ▁strncmp ▁( ▁arg ▁, ▁" env :" ▁, ▁4 ▁) ▁== ▁0 ▁) ▁{ ▁tmp ▁= ▁getenv ▁( ▁arg ▁+ ▁4 ▁) ▁; ▁if ▁( ▁! ▁tmp ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Can ' t read environment variable % s \ n " ▁, ▁arg ▁+ ▁4 ▁) ▁; ▁return ▁NULL ▁; ▁} ▁return ▁OPENSSL _ strdup ▁( ▁tmp ▁) ▁; ▁} ▁if ▁( ▁! ▁keep bio ▁|| ▁! ▁pw db io ▁) ▁{ ▁if ▁( ▁strncmp ▁( ▁arg ▁, ▁" file :" ▁, ▁5 ▁) ▁== ▁0 ▁) ▁{ ▁pw db io ▁= ▁BIO _ new _ file ▁( ▁arg ▁+ ▁5 ▁, ▁" r " ▁) ▁; ▁if ▁( ▁! ▁pw db io ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Can ' t open file % s \ n " ▁, ▁arg ▁+ ▁5 ▁) ▁; ▁return ▁NULL ▁; ▁} ▁# if ▁! ▁defined ▁( ▁_ WIN 32 ▁) ▁} ▁else ▁if ▁( ▁strncmp ▁( ▁arg ▁, ▁" fd :" ▁, ▁3 ▁) ▁== ▁0 ▁) ▁{ ▁BIO ▁* ▁bt mp ▁; ▁i ▁= ▁atoi ▁( ▁arg ▁+ ▁3 ▁) ▁; ▁if ▁( ▁i ▁>= ▁0 ▁) ▁pw db io ▁= ▁BIO _ new _ fd ▁( ▁i ▁, ▁BIO _ NO CLOSE ▁) ▁; ▁if ▁( ▁( ▁i ▁< ▁0 ▁) ▁|| ▁! ▁pw db io ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Can ' t access file descriptor % s \ n " ▁, ▁arg ▁+ ▁3 ▁) ▁; ▁return ▁NULL ▁; ▁} ▁bt mp ▁= ▁BIO _ new ▁( ▁BIO _ f _ buffer ▁( ▁) ▁) ▁; ▁pw db io ▁= ▁BIO _ push ▁( ▁bt mp ▁, ▁pw db io ▁) ▁; ▁# endif ▁} else if ( strcmp ( arg ," stdin ") == 0) { ▁pw db io ▁= ▁dup _ bio _ in ▁( ▁FORMAT _ TEXT ▁) ▁; ▁if ▁( ▁! ▁pw db io ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Can ' t open BIO for stdin \ n " ▁) ▁; ▁return ▁NULL ▁; ▁} ▁} ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Invalid password argument \"% s \"\ n " ▁, ▁arg ▁) ▁; ▁return ▁NULL ▁; ▁} ▁} ▁i ▁= ▁BIO _ gets ▁( ▁pw db io ▁, ▁tp ass ▁, ▁APP _ PASS _ LEN ▁) ▁; ▁if ▁( ▁keep bio ▁!= ▁1 ▁) ▁{ ▁BIO _ free _ all ▁( ▁pw db io ▁) ▁; ▁pw db io ▁= ▁NULL ▁; ▁} ▁if ▁( ▁i ▁<= ▁0 ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Error reading password from BIO \ n " ▁) ▁; ▁return ▁NULL ▁; ▁} ▁tmp ▁= ▁strchr ▁( ▁tp ass ▁, ▁' ▁\ n ▁' ▁) ▁; ▁if ▁( ▁tmp ▁) ▁* ▁tmp ▁= ▁0 ▁; ▁return ▁OPENSSL _ strdup ▁( ▁tp ass ▁) ▁; ▁}	0
▁static ▁const ▁unsigned ▁char ▁* ▁seq _ unpack _ r le _ block ▁( ▁const ▁unsigned ▁char ▁* ▁src ▁, ▁unsigned ▁char ▁* ▁dst ▁, ▁int ▁dst _ size ▁) ▁{ ▁int ▁i ▁, ▁len ▁, ▁sz ▁; ▁Get Bit Context ▁gb ▁; ▁int ▁code _ table ▁[ ▁64 ▁] ▁; ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁src ▁, ▁64 ▁* ▁8 ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁, ▁sz ▁= ▁0 ▁; ▁i ▁< ▁64 ▁&& ▁sz ▁< ▁dst _ size ▁; ▁i ▁++ ▁) ▁{ ▁code _ table ▁[ ▁i ▁] ▁= ▁get _ s bits ▁( ▁& ▁gb ▁, ▁4 ▁) ▁; ▁sz ▁+= ▁FF ABS ▁( ▁code _ table ▁[ ▁i ▁] ▁) ▁; ▁} ▁src ▁+= ▁( ▁get _ bits _ count ▁( ▁& ▁gb ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁64 ▁&& ▁dst _ size ▁> ▁0 ▁; ▁i ▁++ ▁) ▁{ ▁len ▁= ▁code _ table ▁[ ▁i ▁] ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁{ ▁len ▁= ▁- ▁len ▁; ▁memset ▁( ▁dst ▁, ▁* ▁src ▁++ ▁, ▁FF MIN ▁( ▁len ▁, ▁dst _ size ▁) ▁) ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁dst ▁, ▁src ▁, ▁FF MIN ▁( ▁len ▁, ▁dst _ size ▁) ▁) ▁; ▁src ▁+= ▁len ▁; ▁} ▁dst ▁+= ▁len ▁; ▁dst _ size ▁-= ▁len ▁; ▁} ▁return ▁src ▁; ▁}	1
▁static ▁void ▁expand ▁( ▁L HASH ▁* ▁lh ▁) ▁{ ▁L HASH _ NODE ▁* ▁* ▁n ▁, ▁* ▁* ▁n 1 ▁, ▁* ▁* ▁n 2 ▁, ▁* ▁np ▁; ▁unsigned ▁int ▁p ▁, ▁i ▁, ▁j ▁; ▁unsigned ▁long ▁hash ▁, ▁n ni ▁; ▁lh ▁-> ▁num _ nodes ▁++ ▁; ▁lh ▁-> ▁num _ expand s ▁++ ▁; ▁p ▁= ▁( ▁int ▁) ▁lh ▁-> ▁p ▁++ ▁; ▁n 1 ▁= ▁& ▁( ▁lh ▁-> ▁b ▁[ ▁p ▁] ▁) ▁; ▁n 2 ▁= ▁& ▁( ▁lh ▁-> ▁b ▁[ ▁p ▁+ ▁( ▁int ▁) ▁lh ▁-> ▁p max ▁] ▁) ▁; ▁* ▁n 2 ▁= ▁NULL ▁; ▁n ni ▁= ▁lh ▁-> ▁num _ alloc _ nodes ▁; ▁for ▁( ▁np ▁= ▁* ▁n 1 ▁; ▁np ▁!= ▁NULL ▁; ▁) ▁{ ▁# ifndef ▁NO _ HASH _ COMP ▁hash ▁= ▁np ▁-> ▁hash ▁; ▁# else ▁hash ▁= ▁( ▁* ▁( ▁lh ▁-> ▁hash ▁) ▁) ▁( ▁np ▁-> ▁data ▁) ▁; ▁lh ▁-> ▁num _ hash _ calls ▁++ ▁; ▁# endif ▁if ▁( ▁( ▁hash ▁% ▁n ni ▁) ▁!= ▁p ▁) ▁{ ▁* ▁n 1 ▁= ▁( ▁* ▁n 1 ▁) ▁-> ▁next ▁; ▁np ▁-> ▁next ▁= ▁* ▁n 2 ▁; ▁* ▁n 2 ▁= ▁np ▁; ▁} ▁else ▁n 1 ▁= ▁& ▁( ▁( ▁* ▁n 1 ▁) ▁-> ▁next ▁) ▁; ▁np ▁= ▁* ▁n 1 ▁; ▁} ▁if ▁( ▁( ▁lh ▁-> ▁p ▁) ▁>= ▁lh ▁-> ▁p max ▁) ▁{ ▁j ▁= ▁( ▁int ▁) ▁lh ▁-> ▁num _ alloc _ nodes ▁* ▁2 ▁; ▁n ▁= ▁( ▁L HASH _ NODE ▁* ▁* ▁) ▁Re alloc ▁( ▁( ▁char ▁* ▁) ▁lh ▁-> ▁b ▁, ▁( ▁unsigned ▁int ▁) ▁sizeof ▁( ▁L HASH _ NODE ▁* ▁) ▁* ▁j ▁) ▁; ▁if ▁( ▁n ▁== ▁NULL ▁) ▁{ ▁lh ▁-> ▁error ▁++ ▁; ▁lh ▁-> ▁p ▁= ▁0 ▁; ▁return ▁; ▁} ▁for ▁( ▁i ▁= ▁( ▁int ▁) ▁lh ▁-> ▁num _ alloc _ nodes ▁; ▁i ▁< ▁j ▁; ▁i ▁++ ▁) ▁n ▁[ ▁i ▁] ▁= ▁NULL ▁; ▁lh ▁-> ▁p max ▁= ▁lh ▁-> ▁num _ alloc _ nodes ▁; ▁lh ▁-> ▁num _ alloc _ nodes ▁= ▁j ▁; ▁lh ▁-> ▁num _ expand _ realloc s ▁++ ▁; ▁lh ▁-> ▁p ▁= ▁0 ▁; ▁lh ▁-> ▁b ▁= ▁n ▁; ▁} ▁}	1
▁SSL _ CIPHER ▁* ▁ssl 3_ choose _ cipher ▁( ▁SSL ▁* ▁s ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁clnt ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁sr vr ▁) ▁{ ▁SSL _ CIPHER ▁* ▁c ▁, ▁* ▁ret ▁= ▁NULL ▁; ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁prio ▁, ▁* ▁allow ▁; ▁int ▁i ▁, ▁ii ▁, ▁ok ▁; ▁# if ▁! ▁defined ▁( ▁OPENSSL _ NO _ TL SE XT ▁) ▁&& ▁! ▁defined ▁( ▁OPENSSL _ NO _ EC ▁) ▁unsigned ▁int ▁j ▁; ▁int ▁ec _ ok ▁, ▁ec _ nid ▁; ▁unsigned ▁char ▁ec _ search 1 ▁= ▁0 ▁, ▁ec _ search 2 ▁= ▁0 ▁; ▁# endif ▁C ERT ▁* ▁cert ▁; ▁unsigned ▁long ▁alg _ k ▁, ▁alg _ a ▁, ▁mask _ k ▁, ▁mask _ a ▁, ▁e mask _ k ▁, ▁e mask _ a ▁; ▁cert ▁= ▁s ▁-> ▁cert ▁; ▁# if ▁0 ▁sk _ SSL _ CIPHER _ set _ cmp _ func ▁( ▁sr vr ▁, ▁ssl _ cipher _ ptr _ id _ cmp ▁) ▁; ▁sk _ SSL _ CIPHER _ set _ cmp _ func ▁( ▁clnt ▁, ▁ssl _ cipher _ ptr _ id _ cmp ▁) ▁; ▁# endif ▁# ifdef ▁C IPHER _ DEBUG ▁printf ▁( ▁" Server has % df rom % p :\ n " ▁, ▁sk _ SSL _ CIPHER _ num ▁( ▁sr vr ▁) ▁, ▁( ▁void ▁* ▁) ▁sr vr ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁sr vr ▁) ▁; ▁++ ▁i ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁sr vr ▁, ▁i ▁) ▁; ▁printf ▁( ▁"% p :% s \ n " ▁, ▁( ▁void ▁* ▁) ▁c ▁, ▁c ▁-> ▁name ▁) ▁; ▁} ▁printf ▁( ▁" Client sent % df rom % p :\ n " ▁, ▁sk _ SSL _ CIPHER _ num ▁( ▁clnt ▁) ▁, ▁( ▁void ▁* ▁) ▁clnt ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁clnt ▁) ▁; ▁++ ▁i ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁clnt ▁, ▁i ▁) ▁; ▁printf ▁( ▁"% p :% s \ n " ▁, ▁( ▁void ▁* ▁) ▁c ▁, ▁c ▁-> ▁name ▁) ▁; ▁} ▁# endif ▁if ▁( ▁s ▁-> ▁options ▁& ▁SSL _ OP _ CIPHER _ SERVER _ PRE FERENCE ▁) ▁{ ▁prio ▁= ▁sr vr ▁; ▁allow ▁= ▁clnt ▁; ▁} ▁else ▁{ ▁prio ▁= ▁clnt ▁; ▁allow ▁= ▁sr vr ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁prio ▁) ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁prio ▁, ▁i ▁) ▁; ▁if ▁( ▁( ▁c ▁-> ▁algorithm _ ssl ▁& ▁SSL _ TLS V 1_2 ▁) ▁&& ▁( ▁TLS 1_ get _ version ▁( ▁s ▁) ▁< ▁TLS 1_ 2_ VERSION ▁) ▁) ▁continue ▁; ▁ssl _ set _ cert _ masks ▁( ▁cert ▁, ▁c ▁) ▁; ▁mask _ k ▁= ▁cert ▁-> ▁mask _ k ▁; ▁mask _ a ▁= ▁cert ▁-> ▁mask _ a ▁; ▁e mask _ k ▁= ▁cert ▁-> ▁export _ mask _ k ▁; ▁e mask _ a ▁= ▁cert ▁-> ▁export _ mask _ a ▁; ▁# ifndef ▁OPENSSL _ NO _ SR P ▁mask _ k ▁= ▁cert ▁-> ▁mask _ k ▁| ▁s ▁-> ▁sr p _ ctx ▁. ▁sr p _ Mask ▁; ▁e mask _ k ▁= ▁cert ▁-> ▁export _ mask _ k ▁| ▁s ▁-> ▁sr p _ ctx ▁. ▁sr p _ Mask ▁; ▁# endif ▁# ifdef ▁K SSL _ DEBUG ▁# endif ▁alg _ k ▁= ▁c ▁-> ▁algorithm _ m key ▁; ▁alg _ a ▁= ▁c ▁-> ▁algorithm _ auth ▁; ▁# ifndef ▁OPENSSL _ NO _ KRB 5 ▁if ▁( ▁alg _ k ▁& ▁SSL _ k KRB 5 ▁) ▁{ ▁if ▁( ▁! ▁k ssl _ key tab _ is _ available ▁( ▁s ▁-> ▁k ssl _ ctx ▁) ▁) ▁continue ▁; ▁} ▁# endif ▁# ifndef ▁OPENSSL _ NO _ PS K ▁if ▁( ▁( ▁alg _ k ▁& ▁SSL _ k PS K ▁) ▁&& ▁s ▁-> ▁p sk _ server _ callback ▁== ▁NULL ▁) ▁continue ▁; ▁# endif ▁if ▁( ▁SSL _ C _ IS _ EXPORT ▁( ▁c ▁) ▁) ▁{ ▁ok ▁= ▁( ▁alg _ k ▁& ▁e mask _ k ▁) ▁&& ▁( ▁alg _ a ▁& ▁e mask _ a ▁) ▁; ▁# ifdef ▁C IPHER _ DEBUG ▁printf ▁( ▁"% d :[ %08 lX :% 08 lX :% 08 lX :% 08 lX ] % p :% s ( export )\ n " ▁, ▁ok ▁, ▁alg _ k ▁, ▁alg _ a ▁, ▁e mask _ k ▁, ▁e mask _ a ▁, ▁( ▁void ▁* ▁) ▁c ▁, ▁c ▁-> ▁name ▁) ▁; ▁# endif ▁} ▁else ▁{ ▁ok ▁= ▁( ▁alg _ k ▁& ▁mask _ k ▁) ▁&& ▁( ▁alg _ a ▁& ▁mask _ a ▁) ▁; ▁# ifdef ▁C IPHER _ DEBUG ▁printf ▁( ▁"% d :[ %08 lX :% 08 lX :% 08 lX :% 08 lX ] % p :% s \ n " ▁, ▁ok ▁, ▁alg _ k ▁, ▁alg _ a ▁, ▁mask _ k ▁, ▁mask _ a ▁, ▁( ▁void ▁* ▁) ▁c ▁, ▁c ▁-> ▁name ▁) ▁; ▁# endif ▁} ▁# ifndef ▁OPENSSL _ NO _ TL SE XT ▁# ifndef ▁OPENSSL _ NO _ EC ▁if ▁( ▁( ▁alg _ a ▁& ▁SSL _ a ECDSA ▁|| ▁alg _ a ▁& ▁SSL _ a ECDH ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁!= ▁NULL ▁) ▁&& ▁( ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ ec point format list _ length ▁> ▁0 ▁) ▁&& ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ ec point format list ▁!= ▁NULL ▁) ▁) ▁&& ▁( ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁-> ▁cert _ info ▁!= ▁NULL ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁-> ▁cert _ info ▁-> ▁key ▁!= ▁NULL ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁-> ▁cert _ info ▁-> ▁key ▁-> ▁public _ key ▁!= ▁NULL ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁-> ▁cert _ info ▁-> ▁key ▁-> ▁public _ key ▁-> ▁data ▁!= ▁NULL ▁) ▁&& ▁( ▁( ▁* ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁-> ▁cert _ info ▁-> ▁key ▁-> ▁public _ key ▁-> ▁data ▁) ▁== ▁POINT _ CONVERSION _ COMPRESSED ▁) ▁|| ▁( ▁* ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁-> ▁cert _ info ▁-> ▁key ▁-> ▁public _ key ▁-> ▁data ▁) ▁== ▁POINT _ CONVERSION _ COMPRESSED ▁+ ▁1 ▁) ▁) ▁) ▁) ▁{ ▁ec _ ok ▁= ▁0 ▁; ▁if ▁( ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁!= ▁NULL ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁!= ▁NULL ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁-> ▁meth ▁!= ▁NULL ▁) ▁&& ▁( ▁EC _ METHOD _ get _ field _ type ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁-> ▁meth ▁) ▁== ▁NID _ X 9_ 62_ prime _ field ▁) ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁-> ▁session ▁-> ▁tl se xt _ ec point format list _ length ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ ec point format list ▁[ ▁j ▁] ▁== ▁TL SE XT _ EC POINT FORMAT _ ansi X 96 2_ compressed _ prime ▁) ▁{ ▁ec _ ok ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁else ▁if ▁( ▁EC _ METHOD _ get _ field _ type ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁-> ▁meth ▁) ▁== ▁NID _ X 9_ 62_ character istic _ two _ field ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁-> ▁session ▁-> ▁tl se xt _ ec point format list _ length ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ ec point format list ▁[ ▁j ▁] ▁== ▁TL SE XT _ EC POINT FORMAT _ ansi X 96 2_ compressed _ char 2 ▁) ▁{ ▁ec _ ok ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁ok ▁= ▁ok ▁&& ▁ec _ ok ▁; ▁} ▁if ▁( ▁( ▁alg _ a ▁& ▁SSL _ a ECDSA ▁|| ▁alg _ a ▁& ▁SSL _ a ECDH ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁x 509 ▁!= ▁NULL ▁) ▁&& ▁( ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist _ length ▁> ▁0 ▁) ▁&& ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist ▁!= ▁NULL ▁) ▁) ▁) ▁{ ▁ec _ ok ▁= ▁0 ▁; ▁if ▁( ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁!= ▁NULL ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁!= ▁NULL ▁) ▁) ▁{ ▁ec _ nid ▁= ▁EC _ GROUP _ get _ curve _ name ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁) ▁; ▁if ▁( ▁( ▁ec _ nid ▁== ▁0 ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁-> ▁meth ▁!= ▁NULL ▁) ▁) ▁{ ▁if ▁( ▁EC _ METHOD _ get _ field _ type ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁-> ▁meth ▁) ▁== ▁NID _ X 9_ 62_ prime _ field ▁) ▁{ ▁ec _ search 1 ▁= ▁0 xFF ▁; ▁ec _ search 2 ▁= ▁0 x 01 ▁; ▁} ▁else ▁if ▁( ▁EC _ METHOD _ get _ field _ type ▁( ▁s ▁-> ▁cert ▁-> ▁p keys ▁[ ▁SSL _ PKEY _ ECC ▁] ▁. ▁private key ▁-> ▁pkey ▁. ▁ec ▁-> ▁group ▁-> ▁meth ▁) ▁== ▁NID _ X 9_ 62_ character istic _ two _ field ▁) ▁{ ▁ec _ search 1 ▁= ▁0 xFF ▁; ▁ec _ search 2 ▁= ▁0 x 02 ▁; ▁} ▁} ▁else ▁{ ▁ec _ search 1 ▁= ▁0 x 00 ▁; ▁ec _ search 2 ▁= ▁tls 1_ ec _ nid 2 curve _ id ▁( ▁ec _ nid ▁) ▁; ▁} ▁if ▁( ▁( ▁ec _ search 1 ▁!= ▁0 ▁) ▁|| ▁( ▁ec _ search 2 ▁!= ▁0 ▁) ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist _ length ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist ▁[ ▁2 ▁* ▁j ▁] ▁== ▁ec _ search 1 ▁) ▁&& ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist ▁[ ▁2 ▁* ▁j ▁+ ▁1 ▁] ▁== ▁ec _ search 2 ▁) ▁) ▁{ ▁ec _ ok ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁ok ▁= ▁ok ▁&& ▁ec _ ok ▁; ▁} ▁if ▁( ▁( ▁alg _ k ▁& ▁SSL _ k E ECDH ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁ecdh _ tmp ▁!= ▁NULL ▁) ▁&& ▁( ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist _ length ▁> ▁0 ▁) ▁&& ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist ▁!= ▁NULL ▁) ▁) ▁) ▁{ ▁ec _ ok ▁= ▁0 ▁; ▁if ▁( ▁s ▁-> ▁cert ▁-> ▁ecdh _ tmp ▁-> ▁group ▁!= ▁NULL ▁) ▁{ ▁ec _ nid ▁= ▁EC _ GROUP _ get _ curve _ name ▁( ▁s ▁-> ▁cert ▁-> ▁ecdh _ tmp ▁-> ▁group ▁) ▁; ▁if ▁( ▁( ▁ec _ nid ▁== ▁0 ▁) ▁&& ▁( ▁s ▁-> ▁cert ▁-> ▁ecdh _ tmp ▁-> ▁group ▁-> ▁meth ▁!= ▁NULL ▁) ▁) ▁{ ▁if ▁( ▁EC _ METHOD _ get _ field _ type ▁( ▁s ▁-> ▁cert ▁-> ▁ecdh _ tmp ▁-> ▁group ▁-> ▁meth ▁) ▁== ▁NID _ X 9_ 62_ prime _ field ▁) ▁{ ▁ec _ search 1 ▁= ▁0 xFF ▁; ▁ec _ search 2 ▁= ▁0 x 01 ▁; ▁} ▁else ▁if ▁( ▁EC _ METHOD _ get _ field _ type ▁( ▁s ▁-> ▁cert ▁-> ▁ecdh _ tmp ▁-> ▁group ▁-> ▁meth ▁) ▁== ▁NID _ X 9_ 62_ character istic _ two _ field ▁) ▁{ ▁ec _ search 1 ▁= ▁0 xFF ▁; ▁ec _ search 2 ▁= ▁0 x 02 ▁; ▁} ▁} ▁else ▁{ ▁ec _ search 1 ▁= ▁0 x 00 ▁; ▁ec _ search 2 ▁= ▁tls 1_ ec _ nid 2 curve _ id ▁( ▁ec _ nid ▁) ▁; ▁} ▁if ▁( ▁( ▁ec _ search 1 ▁!= ▁0 ▁) ▁|| ▁( ▁ec _ search 2 ▁!= ▁0 ▁) ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist _ length ▁/ ▁2 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist ▁[ ▁2 ▁* ▁j ▁] ▁== ▁ec _ search 1 ▁) ▁&& ▁( ▁s ▁-> ▁session ▁-> ▁tl se xt _ el liptic cur vel ist ▁[ ▁2 ▁* ▁j ▁+ ▁1 ▁] ▁== ▁ec _ search 2 ▁) ▁) ▁{ ▁ec _ ok ▁= ▁1 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁ok ▁= ▁ok ▁&& ▁ec _ ok ▁; ▁} ▁# endif ▁# endif ▁if ▁( ▁! ▁ok ▁) ▁continue ▁; ▁ii ▁= ▁sk _ SSL _ CIPHER _ find ▁( ▁allow ▁, ▁c ▁) ▁; ▁if ▁( ▁ii ▁>= ▁0 ▁) ▁{ ▁ret ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁allow ▁, ▁ii ▁) ▁; ▁break ▁; ▁} ▁} ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁int ▁am v _ encode _ picture ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVPacket ▁* ▁pkt ▁, ▁const ▁AVFrame ▁* ▁pic _ arg ▁, ▁int ▁* ▁got _ packet ▁) ▁{ ▁Mpeg Enc Context ▁* ▁s ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁AVFrame ▁* ▁pic ▁; ▁int ▁i ▁, ▁ret ▁; ▁int ▁chroma _ h _ shift ▁, ▁chroma _ v _ shift ▁; ▁av _ pix _ fmt _ get _ chroma _ sub _ sample ▁( ▁avctx ▁-> ▁pix _ fmt ▁, ▁& ▁chroma _ h _ shift ▁, ▁& ▁chroma _ v _ shift ▁) ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁flags ▁& ▁CODEC _ FLAG _ EMU _ EDGE ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁pic ▁= ▁av _ frame _ clone ▁( ▁pic _ arg ▁) ▁; ▁if ▁( ▁! ▁pic ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁v sample ▁= ▁i ▁? ▁2 ▁>> ▁chroma _ v _ shift ▁: ▁2 ▁; ▁pic ▁-> ▁data ▁[ ▁i ▁] ▁+= ▁( ▁pic ▁-> ▁linesize ▁[ ▁i ▁] ▁* ▁( ▁v sample ▁* ▁( ▁8 ▁* ▁s ▁-> ▁mb _ height ▁- ▁( ▁( ▁s ▁-> ▁height ▁/ ▁V _ MAX ▁) ▁& ▁7 ▁) ▁) ▁- ▁1 ▁) ▁) ▁; ▁pic ▁-> ▁linesize ▁[ ▁i ▁] ▁*= ▁-1 ▁; ▁} ▁ret ▁= ▁ff _ MP V _ encode _ picture ▁( ▁avctx ▁, ▁pkt ▁, ▁pic ▁, ▁got _ packet ▁) ▁; ▁av _ frame _ free ▁( ▁& ▁pic ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁tls 1_ cbc _ remove _ padding ▁( ▁const ▁SSL ▁* ▁s ▁, ▁SSL 3_ RECORD ▁* ▁rec ▁, ▁unsigned ▁block _ size ▁, ▁unsigned ▁mac _ size ▁) ▁{ ▁unsigned ▁padding _ length ▁, ▁good ▁, ▁to _ check ▁, ▁i ▁; ▁const ▁unsigned ▁overhead ▁= ▁1 ▁+ ▁mac _ size ▁; ▁if ▁( ▁SSL _ USE _ EXPLICIT _ IV ▁( ▁s ▁) ▁) ▁{ ▁if ▁( ▁overhead ▁+ ▁block _ size ▁> ▁rec ▁-> ▁length ▁) ▁return ▁0 ▁; ▁rec ▁-> ▁data ▁+= ▁block _ size ▁; ▁rec ▁-> ▁input ▁+= ▁block _ size ▁; ▁rec ▁-> ▁length ▁-= ▁block _ size ▁; ▁rec ▁-> ▁orig _ len ▁-= ▁block _ size ▁; ▁} ▁else ▁if ▁( ▁overhead ▁> ▁rec ▁-> ▁length ▁) ▁return ▁0 ▁; ▁padding _ length ▁= ▁rec ▁-> ▁data ▁[ ▁rec ▁-> ▁length ▁- ▁1 ▁] ▁; ▁if ▁( ▁EVP _ CIPHER _ flags ▁( ▁EVP _ CIPHER _ CTX _ cipher ▁( ▁s ▁-> ▁enc _ read _ ctx ▁) ▁) ▁& ▁EVP _ C IPH _ FLAG _ A EAD _ CIPHER ▁) ▁{ ▁rec ▁-> ▁length ▁-= ▁padding _ length ▁+ ▁1 ▁; ▁return ▁1 ▁; ▁} ▁good ▁= ▁constant _ time _ ge ▁( ▁rec ▁-> ▁length ▁, ▁overhead ▁+ ▁padding _ length ▁) ▁; ▁to _ check ▁= ▁256 ▁; ▁if ▁( ▁to _ check ▁> ▁rec ▁-> ▁length ▁) ▁to _ check ▁= ▁rec ▁-> ▁length ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁to _ check ▁; ▁i ▁++ ▁) ▁{ ▁unsigned ▁char ▁mask ▁= ▁constant _ time _ ge _8 ▁( ▁padding _ length ▁, ▁i ▁) ▁; ▁unsigned ▁char ▁b ▁= ▁rec ▁-> ▁data ▁[ ▁rec ▁-> ▁length ▁- ▁1 ▁- ▁i ▁] ▁; ▁good ▁&= ▁ ~ ▁( ▁mask ▁& ▁( ▁padding _ length ▁ ^ ▁b ▁) ▁) ▁; ▁} ▁good ▁= ▁constant _ time _ eq ▁( ▁0 xff ▁, ▁good ▁& ▁0 xff ▁) ▁; ▁rec ▁-> ▁length ▁-= ▁good ▁& ▁( ▁padding _ length ▁+ ▁1 ▁) ▁; ▁return ▁constant _ time _ select _ int ▁( ▁good ▁, ▁1 ▁, ▁-1 ▁) ▁; ▁}	0
▁int ▁ASN 1_ TIME _ set _ string _ X 509 ▁( ▁ASN 1_ TIME ▁* ▁s ▁, ▁const ▁char ▁* ▁str ▁) ▁{ ▁ASN 1_ TIME ▁t ▁; ▁struct ▁tm ▁tm ▁; ▁int ▁rv ▁= ▁0 ▁; ▁t ▁. ▁length ▁= ▁strlen ▁( ▁str ▁) ▁; ▁t ▁. ▁data ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁str ▁; ▁t ▁. ▁flags ▁= ▁ASN 1_ STRING _ FLAG _ X 509_ TIME ▁; ▁t ▁. ▁type ▁= ▁V _ ASN 1_ UTC TIME ▁; ▁if ▁( ▁! ▁ASN 1_ TIME _ check ▁( ▁& ▁t ▁) ▁) ▁{ ▁t ▁. ▁type ▁= ▁V _ ASN 1_ GENERAL IZED TIME ▁; ▁if ▁( ▁! ▁ASN 1_ TIME _ check ▁( ▁& ▁t ▁) ▁) ▁goto ▁out ▁; ▁} ▁if ▁( ▁s ▁!= ▁NULL ▁&& ▁t ▁. ▁type ▁== ▁V _ ASN 1_ GENERAL IZED TIME ▁) ▁{ ▁if ▁( ▁! ▁asn 1_ time _ to _ tm ▁( ▁& ▁tm ▁, ▁& ▁t ▁) ▁) ▁goto ▁out ▁; ▁if ▁( ▁tm ▁. ▁tm _ year ▁>= ▁50 ▁&& ▁tm ▁. ▁tm _ year ▁< ▁150 ▁) ▁{ ▁t ▁. ▁length ▁-= ▁2 ▁; ▁t ▁. ▁data ▁= ▁OPENSSL _ zalloc ▁( ▁t ▁. ▁length ▁+ ▁1 ▁) ▁; ▁if ▁( ▁t ▁. ▁data ▁== ▁NULL ▁) ▁goto ▁out ▁; ▁memcpy ▁( ▁t ▁. ▁data ▁, ▁str ▁+ ▁2 ▁, ▁t ▁. ▁length ▁) ▁; ▁t ▁. ▁type ▁= ▁V _ ASN 1_ UTC TIME ▁; ▁} ▁} ▁if ▁( ▁s ▁== ▁NULL ▁|| ▁ASN 1_ STRING _ copy ▁( ▁( ▁ASN 1_ STRING ▁* ▁) ▁s ▁, ▁( ▁ASN 1_ STRING ▁* ▁) ▁& ▁t ▁) ▁) ▁rv ▁= ▁1 ▁; ▁if ▁( ▁t ▁. ▁data ▁!= ▁( ▁unsigned ▁char ▁* ▁) ▁str ▁) ▁OPENSSL _ free ▁( ▁t ▁. ▁data ▁) ▁; ▁out ▁: ▁return ▁rv ▁; ▁}	0
▁static ▁int ▁idp _ check _ cr li ss uer ▁( ▁DIST _ POINT ▁* ▁dp ▁, ▁X 509_ CRL ▁* ▁crl ▁, ▁int ▁* ▁p im atch ▁) ▁{ ▁int ▁i ▁; ▁X 509_ NAME ▁* ▁nm ▁= ▁X 509_ CRL _ get _ iss uer ▁( ▁crl ▁) ▁; ▁if ▁( ▁! ▁dp ▁-> ▁CRL iss uer ▁) ▁return ▁* ▁p im atch ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ GENERAL _ NAME _ num ▁( ▁dp ▁-> ▁CRL iss uer ▁) ▁; ▁i ▁++ ▁) ▁{ ▁GENERAL _ NAME ▁* ▁gen ▁= ▁sk _ GENERAL _ NAME _ value ▁( ▁dp ▁-> ▁CRL iss uer ▁, ▁i ▁) ▁; ▁if ▁( ▁gen ▁-> ▁type ▁!= ▁GEN _ DIR NAME ▁) ▁continue ▁; ▁if ▁( ▁! ▁X 509_ NAME _ cmp ▁( ▁gen ▁-> ▁d ▁. ▁directory Name ▁, ▁nm ▁) ▁) ▁{ ▁* ▁p im atch ▁= ▁1 ▁; ▁return ▁1 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}	1
▁void ▁CRYPTO _ free ▁( ▁void ▁* ▁str ▁, ▁const ▁char ▁* ▁file ▁, ▁int ▁line ▁) ▁{ ▁if ▁( ▁free _ impl ▁!= ▁NULL ▁&& ▁free _ impl ▁!= ▁& ▁CRYPTO _ free ▁) ▁{ ▁free _ impl ▁( ▁str ▁, ▁file ▁, ▁line ▁) ▁; ▁return ▁; ▁} ▁# ifndef ▁OPENSSL _ NO _ CRYPTO _ M DEBUG ▁if ▁( ▁call _ malloc _ debug ▁) ▁{ ▁CRYPTO _ mem _ debug _ free ▁( ▁str ▁, ▁0 ▁, ▁file ▁, ▁line ▁) ▁; ▁free ▁( ▁str ▁) ▁; ▁CRYPTO _ mem _ debug _ free ▁( ▁str ▁, ▁1 ▁, ▁file ▁, ▁line ▁) ▁; ▁} ▁else ▁{ ▁free ▁( ▁str ▁) ▁; ▁} ▁# else ▁free ▁( ▁str ▁) ▁; ▁# endif ▁}	1
▁int ▁avio _ read ▁( ▁AVIO Context ▁* ▁s ▁, ▁unsigned ▁char ▁* ▁buf ▁, ▁int ▁size ▁) ▁{ ▁int ▁len ▁, ▁size 1 ▁; ▁size 1 ▁= ▁size ▁; ▁while ▁( ▁size ▁> ▁0 ▁) ▁{ ▁len ▁= ▁FF MIN ▁( ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf _ ptr ▁, ▁size ▁) ▁; ▁if ▁( ▁len ▁== ▁0 ▁|| ▁s ▁-> ▁write _ flag ▁) ▁{ ▁if ▁( ▁( ▁s ▁-> ▁direct ▁|| ▁size ▁> ▁s ▁-> ▁buffer _ size ▁) ▁&& ▁! ▁s ▁-> ▁update _ checksum ▁) ▁{ ▁if ▁( ▁s ▁-> ▁read _ packet ▁) ▁len ▁= ▁s ▁-> ▁read _ packet ▁( ▁s ▁-> ▁opaque ▁, ▁buf ▁, ▁size ▁) ▁; ▁if ▁( ▁len ▁<= ▁0 ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁s ▁-> ▁error ▁= ▁len ▁; ▁break ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pos ▁+= ▁len ▁; ▁s ▁-> ▁bytes _ read ▁+= ▁len ▁; ▁size ▁-= ▁len ▁; ▁buf ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁s ▁-> ▁buf _ end ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁} ▁else ▁{ ▁fill _ buffer ▁( ▁s ▁) ▁; ▁len ▁= ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buf _ ptr ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁break ▁; ▁} ▁} ▁else ▁{ ▁memcpy ▁( ▁buf ▁, ▁s ▁-> ▁buf _ ptr ▁, ▁len ▁) ▁; ▁buf ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁+= ▁len ▁; ▁size ▁-= ▁len ▁; ▁} ▁} ▁if ▁( ▁size 1 ▁== ▁size ▁) ▁{ ▁if ▁( ▁s ▁-> ▁error ▁) ▁return ▁s ▁-> ▁error ▁; ▁if ▁( ▁avio _ fe of ▁( ▁s ▁) ▁) ▁return ▁AVERROR _ EOF ▁; ▁} ▁return ▁size 1 ▁- ▁size ▁; ▁}	1
▁int ▁BN _ sqr ▁( ▁BIGNUM ▁* ▁r ▁, ▁const ▁BIGNUM ▁* ▁a ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁max ▁, ▁al ▁; ▁int ▁ret ▁= ▁0 ▁; ▁BIGNUM ▁* ▁tmp ▁, ▁* ▁rr ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁al ▁= ▁a ▁-> ▁top ▁; ▁if ▁( ▁al ▁<= ▁0 ▁) ▁{ ▁r ▁-> ▁top ▁= ▁0 ▁; ▁r ▁-> ▁neg ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁rr ▁= ▁( ▁a ▁!= ▁r ▁) ▁? ▁r ▁: ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁tmp ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁; ▁if ▁( ▁! ▁rr ▁|| ▁! ▁tmp ▁) ▁goto ▁err ▁; ▁max ▁= ▁2 ▁* ▁al ▁; ▁if ▁( ▁bn _ w expand ▁( ▁rr ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁al ▁== ▁4 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁BN _ ULONG ▁t ▁[ ▁8 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁4 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 4 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁else ▁if ▁( ▁al ▁== ▁8 ▁) ▁{ ▁# ifndef ▁BN _ SQR _ COMB A ▁BN _ ULONG ▁t ▁[ ▁16 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁8 ▁, ▁t ▁) ▁; ▁# else ▁bn _ sqr _ com ba 8 ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁else ▁{ ▁# if ▁defined ▁( ▁BN _ RECUR SION ▁) ▁if ▁( ▁al ▁< ▁BN _ SQR _ RECURSIVE _ SIZE _ NORMAL ▁) ▁{ ▁BN _ ULONG ▁t ▁[ ▁BN _ SQR _ RECURSIVE _ SIZE _ NORMAL ▁* ▁2 ▁] ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁t ▁) ▁; ▁} ▁else ▁{ ▁int ▁j ▁, ▁k ▁; ▁j ▁= ▁BN _ num _ bits _ word ▁( ▁( ▁BN _ ULONG ▁) ▁al ▁) ▁; ▁j ▁= ▁1 ▁<< ▁( ▁j ▁- ▁1 ▁) ▁; ▁k ▁= ▁j ▁+ ▁j ▁; ▁if ▁( ▁al ▁== ▁j ▁) ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁k ▁* ▁2 ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ recursive ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁} ▁} ▁# else ▁if ▁( ▁bn _ w expand ▁( ▁tmp ▁, ▁max ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁bn _ sqr _ normal ▁( ▁rr ▁-> ▁d ▁, ▁a ▁-> ▁d ▁, ▁al ▁, ▁tmp ▁-> ▁d ▁) ▁; ▁# endif ▁} ▁rr ▁-> ▁neg ▁= ▁0 ▁; ▁if ▁( ▁a ▁-> ▁d ▁[ ▁al ▁- ▁1 ▁] ▁== ▁( ▁a ▁-> ▁d ▁[ ▁al ▁- ▁1 ▁] ▁& ▁BN _ MASK 2 l ▁) ▁) ▁rr ▁-> ▁top ▁= ▁max ▁- ▁1 ▁; ▁else ▁rr ▁-> ▁top ▁= ▁max ▁; ▁if ▁( ▁r ▁!= ▁rr ▁&& ▁BN _ copy ▁( ▁r ▁, ▁rr ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁= ▁1 ▁; ▁err ▁: ▁bn _ check _ top ▁( ▁rr ▁) ▁; ▁bn _ check _ top ▁( ▁tmp ▁) ▁; ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	1
▁int ▁ff _ get _ wav _ header ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVIO Context ▁* ▁pb ▁, ▁AVCodecContext ▁* ▁codec ▁, ▁int ▁size ▁, ▁int ▁big _ endian ▁) ▁{ ▁int ▁id ▁; ▁uint 64_ t ▁bitrate ▁= ▁0 ▁; ▁if ▁( ▁size ▁< ▁14 ▁) ▁{ ▁avpriv _ request _ sample ▁( ▁codec ▁, ▁" wav headers ize < 14" ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁codec ▁-> ▁codec _ type ▁= ▁AVMEDIA _ TYPE _ AUDIO ▁; ▁if ▁( ▁! ▁big _ endian ▁) ▁{ ▁id ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁id ▁!= ▁0 x 01 65 ▁) ▁{ ▁codec ▁-> ▁channels ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁codec ▁-> ▁sample _ rate ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁; ▁bitrate ▁= ▁avio _ rl 32 ▁( ▁pb ▁) ▁* ▁8 LL ▁; ▁codec ▁-> ▁block _ align ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁} ▁} ▁else ▁{ ▁id ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁codec ▁-> ▁channels ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁codec ▁-> ▁sample _ rate ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁; ▁bitrate ▁= ▁avio _ rb 32 ▁( ▁pb ▁) ▁* ▁8 LL ▁; ▁codec ▁-> ▁block _ align ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁} ▁if ▁( ▁size ▁== ▁14 ▁) ▁{ ▁codec ▁-> ▁bits _ per _ coded _ sample ▁= ▁8 ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁big _ endian ▁) ▁{ ▁codec ▁-> ▁bits _ per _ coded _ sample ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁} ▁else ▁{ ▁codec ▁-> ▁bits _ per _ coded _ sample ▁= ▁avio _ rb 16 ▁( ▁pb ▁) ▁; ▁} ▁} ▁if ▁( ▁id ▁== ▁0 xFF FE ▁) ▁{ ▁codec ▁-> ▁codec _ tag ▁= ▁0 ▁; ▁} ▁else ▁{ ▁codec ▁-> ▁codec _ tag ▁= ▁id ▁; ▁codec ▁-> ▁codec _ id ▁= ▁ff _ wav _ codec _ get _ id ▁( ▁id ▁, ▁codec ▁-> ▁bits _ per _ coded _ sample ▁) ▁; ▁} ▁if ▁( ▁size ▁>= ▁18 ▁&& ▁id ▁!= ▁0 x 01 65 ▁) ▁{ ▁int ▁cb Size ▁= ▁avio _ rl 16 ▁( ▁pb ▁) ▁; ▁if ▁( ▁big _ endian ▁) ▁{ ▁avpriv _ report _ missing _ feature ▁( ▁codec ▁, ▁" WAVE FORMAT EX support for R IF X files \ n " ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁size ▁-= ▁18 ▁; ▁cb Size ▁= ▁FF MIN ▁( ▁size ▁, ▁cb Size ▁) ▁; ▁if ▁( ▁cb Size ▁>= ▁22 ▁&& ▁id ▁== ▁0 xfffe ▁) ▁{ ▁parse _ wave form atex ▁( ▁pb ▁, ▁codec ▁) ▁; ▁cb Size ▁-= ▁22 ▁; ▁size ▁-= ▁22 ▁; ▁} ▁if ▁( ▁cb Size ▁> ▁0 ▁) ▁{ ▁av _ freep ▁( ▁& ▁codec ▁-> ▁extradata ▁) ▁; ▁if ▁( ▁ff _ get _ extr adata ▁( ▁codec ▁, ▁pb ▁, ▁cb Size ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁size ▁-= ▁cb Size ▁; ▁} ▁if ▁( ▁size ▁> ▁0 ▁) ▁avio _ skip ▁( ▁pb ▁, ▁size ▁) ▁; ▁} ▁else ▁if ▁( ▁id ▁== ▁0 x 01 65 ▁&& ▁size ▁>= ▁32 ▁) ▁{ ▁int ▁nb _ streams ▁, ▁i ▁; ▁size ▁-= ▁4 ▁; ▁av _ freep ▁( ▁& ▁codec ▁-> ▁extradata ▁) ▁; ▁if ▁( ▁ff _ get _ extr adata ▁( ▁codec ▁, ▁pb ▁, ▁size ▁) ▁< ▁0 ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁nb _ streams ▁= ▁AV _ RL 16 ▁( ▁codec ▁-> ▁extradata ▁+ ▁4 ▁) ▁; ▁codec ▁-> ▁sample _ rate ▁= ▁AV _ RL 32 ▁( ▁codec ▁-> ▁extradata ▁+ ▁12 ▁) ▁; ▁codec ▁-> ▁channels ▁= ▁0 ▁; ▁bitrate ▁= ▁0 ▁; ▁if ▁( ▁size ▁< ▁8 ▁+ ▁nb _ streams ▁* ▁20 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ streams ▁; ▁i ▁++ ▁) ▁codec ▁-> ▁channels ▁+= ▁codec ▁-> ▁extradata ▁[ ▁8 ▁+ ▁i ▁* ▁20 ▁+ ▁17 ▁] ▁; ▁} ▁if ▁( ▁bitrate ▁> ▁INT _ MAX ▁) ▁{ ▁if ▁( ▁s ▁-> ▁error _ recogn ition ▁& ▁AV _ EF _ EXP LO DE ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" The bitrate %" ▁PRIu 64 ▁" ist ool arge .\ n " ▁, ▁bitrate ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁else ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" The bitrate %" ▁PRIu 64 ▁" ist ool arge , reset ting to 0 ." ▁, ▁bitrate ▁) ▁; ▁codec ▁-> ▁bit _ rate ▁= ▁0 ▁; ▁} ▁} ▁else ▁{ ▁codec ▁-> ▁bit _ rate ▁= ▁bitrate ▁; ▁} ▁if ▁( ▁codec ▁-> ▁sample _ rate ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid sampler ate :% d \ n " ▁, ▁codec ▁-> ▁sample _ rate ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁codec ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ A AC _ LAT M ▁) ▁{ ▁codec ▁-> ▁channels ▁= ▁0 ▁; ▁codec ▁-> ▁sample _ rate ▁= ▁0 ▁; ▁} ▁if ▁( ▁codec ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ AD PCM _ G 726 ▁&& ▁codec ▁-> ▁sample _ rate ▁) ▁codec ▁-> ▁bits _ per _ coded _ sample ▁= ▁codec ▁-> ▁bit _ rate ▁/ ▁codec ▁-> ▁sample _ rate ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁double ▁* ▁create _ freq _ table ▁( ▁double ▁base ▁, ▁double ▁end ▁, ▁int ▁n ▁) ▁{ ▁double ▁log _ base ▁, ▁log _ end ▁; ▁double ▁rcp _ n ▁= ▁1.0 ▁/ ▁n ▁; ▁double ▁* ▁freq ▁; ▁int ▁x ▁; ▁freq ▁= ▁av _ malloc _ array ▁( ▁n ▁, ▁sizeof ▁( ▁* ▁freq ▁) ▁) ▁; ▁if ▁( ▁! ▁freq ▁) ▁return ▁NULL ▁; ▁log _ base ▁= ▁log ▁( ▁base ▁) ▁; ▁log _ end ▁= ▁log ▁( ▁end ▁) ▁; ▁for ▁( ▁x ▁= ▁0 ▁; ▁x ▁< ▁n ▁; ▁x ▁++ ▁) ▁{ ▁double ▁log _ freq ▁= ▁log _ base ▁+ ▁( ▁x ▁+ ▁0.5 ▁) ▁* ▁( ▁log _ end ▁- ▁log _ base ▁) ▁* ▁rcp _ n ▁; ▁freq ▁[ ▁x ▁] ▁= ▁exp ▁( ▁log _ freq ▁) ▁; ▁} ▁return ▁freq ▁; ▁}	1
▁int ▁sw ri _ get _ d ither ▁( ▁S wr Context ▁* ▁s ▁, ▁void ▁* ▁dst ▁, ▁int ▁len ▁, ▁unsigned ▁seed ▁, ▁enum ▁AV Sample Format ▁noise _ fmt ▁) ▁{ ▁double ▁scale ▁= ▁s ▁-> ▁d ither ▁. ▁noise _ scale ▁; ▁# define ▁TMP _ EXTRA ▁2 ▁double ▁* ▁tmp ▁= ▁av _ malloc _ array ▁( ▁len ▁+ ▁TMP _ EXTRA ▁, ▁sizeof ▁( ▁double ▁) ▁) ▁; ▁int ▁i ▁; ▁if ▁( ▁! ▁tmp ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁+ ▁TMP _ EXTRA ▁; ▁i ▁++ ▁) ▁{ ▁double ▁v ▁; ▁seed ▁= ▁seed ▁* ▁16 645 25 ▁+ ▁101 39 04 223 ▁; ▁switch ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁) ▁{ ▁case ▁S WR _ DIT HER _ RECT ANG ULAR ▁: ▁v ▁= ▁( ▁( ▁double ▁) ▁seed ▁) ▁/ ▁UINT _ MAX ▁- ▁0.5 ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁< ▁S WR _ DIT HER _ NB ▁) ▁; ▁v ▁= ▁( ▁( ▁double ▁) ▁seed ▁) ▁/ ▁UINT _ MAX ▁; ▁seed ▁= ▁seed ▁* ▁16 645 25 ▁+ ▁101 39 04 223 ▁; ▁v ▁-= ▁( ▁( ▁double ▁) ▁seed ▁) ▁/ ▁UINT _ MAX ▁; ▁break ▁; ▁} ▁tmp ▁[ ▁i ▁] ▁= ▁v ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁len ▁; ▁i ▁++ ▁) ▁{ ▁double ▁v ▁; ▁switch ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁) ▁{ ▁default ▁: ▁av _ assert 0 ▁( ▁s ▁-> ▁d ither ▁. ▁method ▁< ▁S WR _ DIT HER _ NB ▁) ▁; ▁v ▁= ▁tmp ▁[ ▁i ▁] ▁; ▁break ▁; ▁case ▁S WR _ DIT HER _ TRIAN G ULAR _ HIGH PASS ▁: ▁v ▁= ▁( ▁- ▁tmp ▁[ ▁i ▁] ▁+ ▁2 ▁* ▁tmp ▁[ ▁i ▁+ ▁1 ▁] ▁- ▁tmp ▁[ ▁i ▁+ ▁2 ▁] ▁) ▁/ ▁sqrt ▁( ▁6 ▁) ▁; ▁break ▁; ▁} ▁v ▁*= ▁scale ▁; ▁switch ▁( ▁noise _ fmt ▁) ▁{ ▁case ▁AV _ SAMPLE _ FMT _ S 16 P ▁: ▁( ▁( ▁int 16_ t ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ S 32 P ▁: ▁( ▁( ▁int 32_ t ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ FL TP ▁: ▁( ▁( ▁float ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁case ▁AV _ SAMPLE _ FMT _ DB LP ▁: ▁( ▁( ▁double ▁* ▁) ▁dst ▁) ▁[ ▁i ▁] ▁= ▁v ▁; ▁break ▁; ▁default ▁: ▁av _ assert 0 ▁( ▁0 ▁) ▁; ▁} ▁} ▁av _ free ▁( ▁tmp ▁) ▁; ▁return ▁0 ▁; ▁}	0
▁char ▁* ▁SSL _ get _ shared _ c iphers ▁( ▁const ▁SSL ▁* ▁s ▁, ▁char ▁* ▁buf ▁, ▁int ▁len ▁) ▁{ ▁char ▁* ▁p ▁; ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁sk ▁; ▁SSL _ CIPHER ▁* ▁c ▁; ▁int ▁i ▁; ▁if ▁( ▁( ▁s ▁-> ▁session ▁== ▁NULL ▁) ▁|| ▁( ▁s ▁-> ▁session ▁-> ▁ciphers ▁== ▁NULL ▁) ▁|| ▁( ▁len ▁< ▁2 ▁) ▁) ▁return ▁( ▁NULL ▁) ▁; ▁if ▁( ▁sk _ SSL _ CIPHER _ num ▁( ▁sk ▁) ▁== ▁0 ▁) ▁return ▁NULL ▁; ▁p ▁= ▁buf ▁; ▁sk ▁= ▁s ▁-> ▁session ▁-> ▁ciphers ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ SSL _ CIPHER _ num ▁( ▁sk ▁) ▁; ▁i ▁++ ▁) ▁{ ▁int ▁n ▁; ▁c ▁= ▁sk _ SSL _ CIPHER _ value ▁( ▁sk ▁, ▁i ▁) ▁; ▁n ▁= ▁strlen ▁( ▁c ▁-> ▁name ▁) ▁; ▁if ▁( ▁n ▁+ ▁1 ▁> ▁len ▁) ▁{ ▁if ▁( ▁p ▁!= ▁buf ▁) ▁-- ▁p ▁; ▁* ▁p ▁= ▁' ▁\0 ▁' ▁; ▁return ▁buf ▁; ▁} ▁strcpy ▁( ▁p ▁, ▁c ▁-> ▁name ▁) ▁; ▁p ▁+= ▁n ▁; ▁* ▁( ▁p ▁++ ▁) ▁= ▁' ▁' ▁; ▁len ▁-= ▁n ▁+ ▁1 ▁; ▁} ▁p ▁[ ▁-1 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁return ▁( ▁buf ▁) ▁; ▁}	1
▁int ▁url _ open ▁( ▁URL Context ▁* ▁* ▁puc ▁, ▁const ▁char ▁* ▁filename ▁, ▁int ▁flags ▁) ▁{ ▁URL Protocol ▁* ▁up ▁; ▁const ▁char ▁* ▁p ▁; ▁char ▁proto _ str ▁[ ▁128 ▁] ▁, ▁* ▁q ▁; ▁p ▁= ▁filename ▁; ▁q ▁= ▁proto _ str ▁; ▁while ▁( ▁* ▁p ▁!= ▁' ▁\0 ▁' ▁&& ▁* ▁p ▁!= ▁' ▁' ▁) ▁{ ▁if ▁( ▁! ▁isalpha ▁( ▁* ▁p ▁) ▁) ▁goto ▁file _ proto ▁; ▁if ▁( ▁( ▁q ▁- ▁proto _ str ▁) ▁< ▁sizeof ▁( ▁proto _ str ▁) ▁- ▁1 ▁) ▁* ▁q ▁++ ▁= ▁* ▁p ▁; ▁p ▁++ ▁; ▁} ▁if ▁( ▁* ▁p ▁== ▁' ▁\0 ▁' ▁|| ▁( ▁q ▁- ▁proto _ str ▁) ▁<= ▁1 ▁) ▁{ ▁file _ proto ▁: ▁strcpy ▁( ▁proto _ str ▁, ▁" file " ▁) ▁; ▁} ▁else ▁{ ▁* ▁q ▁= ▁' ▁\0 ▁' ▁; ▁} ▁up ▁= ▁first _ protocol ▁; ▁while ▁( ▁up ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁strcmp ▁( ▁proto _ str ▁, ▁up ▁-> ▁name ▁) ▁) ▁return ▁url _ open _ protocol ▁( ▁puc ▁, ▁up ▁, ▁filename ▁, ▁flags ▁) ▁; ▁up ▁= ▁up ▁-> ▁next ▁; ▁} ▁* ▁puc ▁= ▁NULL ▁; ▁return ▁AVERROR ▁( ▁ENOENT ▁) ▁; ▁}	1
▁int ▁ff _ MP V _ common _ init ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁i ▁; ▁int ▁nb _ s lices ▁= ▁( ▁HAVE _ THREADS ▁&& ▁s ▁-> ▁avctx ▁-> ▁active _ thread _ type ▁& ▁FF _ THREAD _ SL ICE ▁) ▁? ▁s ▁-> ▁avctx ▁-> ▁thread _ count ▁: ▁1 ▁; ▁if ▁( ▁s ▁-> ▁encoding ▁&& ▁s ▁-> ▁avctx ▁-> ▁slices ▁) ▁nb _ s lices ▁= ▁s ▁-> ▁avctx ▁-> ▁slices ▁; ▁if ▁( ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁&& ▁! ▁s ▁-> ▁progress ive _ sequence ▁) ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁31 ▁) ▁/ ▁32 ▁* ▁2 ▁; ▁else ▁s ▁-> ▁mb _ height ▁= ▁( ▁s ▁-> ▁height ▁+ ▁15 ▁) ▁/ ▁16 ▁; ▁if ▁( ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ NONE ▁) ▁{ ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" de coding to AV _ PIX _ FMT _ NONE is not supported .\ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁nb _ s lices ▁> ▁MAX _ THREADS ▁|| ▁( ▁nb _ s lices ▁> ▁s ▁-> ▁mb _ height ▁&& ▁s ▁-> ▁mb _ height ▁) ▁) ▁{ ▁int ▁max _ s lices ▁; ▁if ▁( ▁s ▁-> ▁mb _ height ▁) ▁max _ s lices ▁= ▁FF MIN ▁( ▁MAX _ THREADS ▁, ▁s ▁-> ▁mb _ height ▁) ▁; ▁else ▁max _ s lices ▁= ▁MAX _ THREADS ▁; ▁av _ log ▁( ▁s ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" t oom any threads / s lices (% d )," ▁" red uc ing to % d \ n " ▁, ▁nb _ s lices ▁, ▁max _ s lices ▁) ▁; ▁nb _ s lices ▁= ▁max _ s lices ▁; ▁} ▁if ▁( ▁( ▁s ▁-> ▁width ▁|| ▁s ▁-> ▁height ▁) ▁&& ▁av _ image _ check _ size ▁( ▁s ▁-> ▁width ▁, ▁s ▁-> ▁height ▁, ▁0 ▁, ▁s ▁-> ▁avctx ▁) ▁) ▁return ▁-1 ▁; ▁ff _ dct _ common _ init ▁( ▁s ▁) ▁; ▁s ▁-> ▁flags ▁= ▁s ▁-> ▁avctx ▁-> ▁flags ▁; ▁s ▁-> ▁flags 2 ▁= ▁s ▁-> ▁avctx ▁-> ▁flags 2 ▁; ▁av _ pix _ fmt _ get _ chroma _ sub _ sample ▁( ▁s ▁-> ▁avctx ▁-> ▁pix _ fmt ▁, ▁& ▁s ▁-> ▁chroma _ x _ shift ▁, ▁& ▁s ▁-> ▁chroma _ y _ shift ▁) ▁; ▁s ▁-> ▁codec _ tag ▁= ▁avpriv _ toupper 4 ▁( ▁s ▁-> ▁avctx ▁-> ▁codec _ tag ▁) ▁; ▁s ▁-> ▁stream _ codec _ tag ▁= ▁avpriv _ toupper 4 ▁( ▁s ▁-> ▁avctx ▁-> ▁stream _ codec _ tag ▁) ▁; ▁FF _ ALLOC Z _ OR _ GOTO ▁( ▁s ▁-> ▁avctx ▁, ▁s ▁-> ▁picture ▁, ▁MAX _ PICTURE _ COUNT ▁* ▁sizeof ▁( ▁Picture ▁) ▁, ▁fail ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁MAX _ PICTURE _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁picture ▁[ ▁i ▁] ▁. ▁f ▁) ▁goto ▁fail ▁; ▁} ▁memset ▁( ▁& ▁s ▁-> ▁next _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁next _ picture ▁) ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁last _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁last _ picture ▁) ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁current _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁current _ picture ▁) ▁) ▁; ▁memset ▁( ▁& ▁s ▁-> ▁new _ picture ▁, ▁0 ▁, ▁sizeof ▁( ▁s ▁-> ▁new _ picture ▁) ▁) ▁; ▁s ▁-> ▁next _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁next _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁last _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁last _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁current _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁current _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁new _ picture ▁. ▁f ▁= ▁av _ frame _ alloc ▁( ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁new _ picture ▁. ▁f ▁) ▁goto ▁fail ▁; ▁if ▁( ▁s ▁-> ▁width ▁&& ▁s ▁-> ▁height ▁) ▁{ ▁if ▁( ▁init _ context _ frame ▁( ▁s ▁) ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁parse _ context ▁. ▁state ▁= ▁-1 ▁; ▁} ▁s ▁-> ▁context _ initialized ▁= ▁1 ▁; ▁s ▁-> ▁thread _ context ▁[ ▁0 ▁] ▁= ▁s ▁; ▁if ▁( ▁s ▁-> ▁width ▁&& ▁s ▁-> ▁height ▁) ▁{ ▁if ▁( ▁nb _ s lices ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁, ▁s ▁, ▁sizeof ▁( ▁Mpeg Enc Context ▁) ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ s lices ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁init _ duplicate _ context ▁( ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁start _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁s ▁-> ▁thread _ context ▁[ ▁i ▁] ▁-> ▁end _ mb _ y ▁= ▁( ▁s ▁-> ▁mb _ height ▁* ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁nb _ s lices ▁/ ▁2 ▁) ▁/ ▁nb _ s lices ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁init _ duplicate _ context ▁( ▁s ▁) ▁< ▁0 ▁) ▁goto ▁fail ▁; ▁s ▁-> ▁start _ mb _ y ▁= ▁0 ▁; ▁s ▁-> ▁end _ mb _ y ▁= ▁s ▁-> ▁mb _ height ▁; ▁} ▁s ▁-> ▁slice _ context _ count ▁= ▁nb _ s lices ▁; ▁} ▁return ▁0 ▁; ▁fail ▁: ▁ff _ MP V _ common _ end ▁( ▁s ▁) ▁; ▁return ▁-1 ▁; ▁}	0
▁int ▁bn _ prob able _ prime _ dh _ retry ▁( ▁BIGNUM ▁* ▁rnd ▁, ▁int ▁bits ▁, ▁BN _ CTX ▁* ▁ctx ▁) ▁{ ▁int ▁i ▁; ▁BIGNUM ▁* ▁t 1 ▁; ▁int ▁ret ▁= ▁0 ▁; ▁BN _ CTX _ start ▁( ▁ctx ▁) ▁; ▁if ▁( ▁( ▁t 1 ▁= ▁BN _ CTX _ get ▁( ▁ctx ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁loop ▁: ▁if ▁( ▁! ▁BN _ rand ▁( ▁rnd ▁, ▁bits ▁, ▁0 ▁, ▁1 ▁) ▁) ▁goto ▁err ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁NU MP R IM ES ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁BN _ mod _ word ▁( ▁rnd ▁, ▁( ▁BN _ ULONG ▁) ▁primes ▁[ ▁i ▁] ▁) ▁<= ▁1 ▁) ▁{ ▁goto ▁loop ▁; ▁} ▁} ▁ret ▁= ▁1 ▁; ▁err ▁: ▁BN _ CTX _ end ▁( ▁ctx ▁) ▁; ▁bn _ check _ top ▁( ▁rnd ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁}	0
▁static ▁int ▁d xt ory _ decode _ v 1_ 420 ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁AVFrame ▁* ▁pic ▁, ▁const ▁uint 8_ t ▁* ▁src ▁, ▁int ▁src _ size ▁) ▁{ ▁int ▁h ▁, ▁w ▁; ▁uint 8_ t ▁* ▁Y 1 ▁, ▁* ▁Y 2 ▁, ▁* ▁U ▁, ▁* ▁V ▁; ▁int ▁ret ▁; ▁if ▁( ▁src _ size ▁< ▁avctx ▁-> ▁width ▁* ▁avctx ▁-> ▁height ▁* ▁3 LL ▁/ ▁2 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" packet too small \ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁avctx ▁-> ▁pix _ fmt ▁= ▁AV _ PIX _ FMT _ YUV 420 P ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ get _ buffer ▁( ▁avctx ▁, ▁pic ▁, ▁0 ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁Y 1 ▁= ▁pic ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁Y 2 ▁= ▁pic ▁-> ▁data ▁[ ▁0 ▁] ▁+ ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁; ▁U ▁= ▁pic ▁-> ▁data ▁[ ▁1 ▁] ▁; ▁V ▁= ▁pic ▁-> ▁data ▁[ ▁2 ▁] ▁; ▁for ▁( ▁h ▁= ▁0 ▁; ▁h ▁< ▁avctx ▁-> ▁height ▁; ▁h ▁+= ▁2 ▁) ▁{ ▁for ▁( ▁w ▁= ▁0 ▁; ▁w ▁< ▁avctx ▁-> ▁width ▁; ▁w ▁+= ▁2 ▁) ▁{ ▁AV _ COPY 16 ▁( ▁Y 1 ▁+ ▁w ▁, ▁src ▁) ▁; ▁AV _ COPY 16 ▁( ▁Y 2 ▁+ ▁w ▁, ▁src ▁+ ▁2 ▁) ▁; ▁U ▁[ ▁w ▁>> ▁1 ▁] ▁= ▁src ▁[ ▁4 ▁] ▁+ ▁0 x 80 ▁; ▁V ▁[ ▁w ▁>> ▁1 ▁] ▁= ▁src ▁[ ▁5 ▁] ▁+ ▁0 x 80 ▁; ▁src ▁+= ▁6 ▁; ▁} ▁Y 1 ▁+= ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁<< ▁1 ▁; ▁Y 2 ▁+= ▁pic ▁-> ▁linesize ▁[ ▁0 ▁] ▁<< ▁1 ▁; ▁U ▁+= ▁pic ▁-> ▁linesize ▁[ ▁1 ▁] ▁; ▁V ▁+= ▁pic ▁-> ▁linesize ▁[ ▁2 ▁] ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁inline ▁int 64_ t ▁bs _ get _ v ▁( ▁const ▁uint 8_ t ▁* ▁* ▁bs ▁) ▁{ ▁int 64_ t ▁v ▁= ▁0 ▁; ▁int ▁br ▁= ▁0 ▁; ▁int ▁c ▁; ▁do ▁{ ▁c ▁= ▁* ▁* ▁bs ▁; ▁( ▁* ▁bs ▁) ▁++ ▁; ▁v ▁<<= ▁7 ▁; ▁v ▁|= ▁c ▁& ▁0 x 7 F ▁; ▁br ▁++ ▁; ▁if ▁( ▁br ▁> ▁10 ▁) ▁return ▁-1 ▁; ▁} ▁while ▁( ▁c ▁& ▁0 x 80 ▁) ▁; ▁return ▁v ▁- ▁br ▁; ▁}	1
▁int ▁BN _ sub _ word ▁( ▁BIGNUM ▁* ▁a ▁, ▁BN _ ULONG ▁w ▁) ▁{ ▁int ▁i ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁w ▁&= ▁BN _ MASK 2 ▁; ▁if ▁( ▁! ▁w ▁) ▁return ▁1 ▁; ▁if ▁( ▁BN _ is _ zero ▁( ▁a ▁) ▁) ▁{ ▁i ▁= ▁BN _ set _ word ▁( ▁a ▁, ▁w ▁) ▁; ▁if ▁( ▁i ▁!= ▁0 ▁) ▁BN _ set _ negative ▁( ▁a ▁, ▁1 ▁) ▁; ▁return ▁i ▁; ▁} ▁if ▁( ▁a ▁-> ▁neg ▁) ▁{ ▁a ▁-> ▁neg ▁= ▁0 ▁; ▁i ▁= ▁BN _ add _ word ▁( ▁a ▁, ▁w ▁) ▁; ▁a ▁-> ▁neg ▁= ▁1 ▁; ▁return ▁( ▁i ▁) ▁; ▁} ▁if ▁( ▁( ▁a ▁-> ▁top ▁== ▁1 ▁) ▁&& ▁( ▁a ▁-> ▁d ▁[ ▁0 ▁] ▁< ▁w ▁) ▁) ▁{ ▁a ▁-> ▁d ▁[ ▁0 ▁] ▁= ▁w ▁- ▁a ▁-> ▁d ▁[ ▁0 ▁] ▁; ▁a ▁-> ▁neg ▁= ▁1 ▁; ▁return ▁( ▁1 ▁) ▁; ▁} ▁i ▁= ▁0 ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁if ▁( ▁a ▁-> ▁d ▁[ ▁i ▁] ▁>= ▁w ▁) ▁{ ▁a ▁-> ▁d ▁[ ▁i ▁] ▁-= ▁w ▁; ▁break ▁; ▁} ▁else ▁{ ▁a ▁-> ▁d ▁[ ▁i ▁] ▁= ▁( ▁a ▁-> ▁d ▁[ ▁i ▁] ▁- ▁w ▁) ▁& ▁BN _ MASK 2 ▁; ▁i ▁++ ▁; ▁w ▁= ▁1 ▁; ▁} ▁} ▁if ▁( ▁( ▁a ▁-> ▁d ▁[ ▁i ▁] ▁== ▁0 ▁) ▁&& ▁( ▁i ▁== ▁( ▁a ▁-> ▁top ▁- ▁1 ▁) ▁) ▁) ▁a ▁-> ▁top ▁-- ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	1
▁void ▁av _ free ▁( ▁void ▁* ▁ptr ▁) ▁{ ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁if ▁( ▁ptr ▁) ▁{ ▁int ▁v ▁= ▁( ▁( ▁char ▁* ▁) ▁ptr ▁) ▁[ ▁-1 ▁] ▁; ▁av _ assert 0 ▁( ▁v ▁> ▁0 ▁&& ▁v ▁<= ▁ALIGN ▁) ▁; ▁free ▁( ▁( ▁char ▁* ▁) ▁ptr ▁- ▁v ▁) ▁; ▁} ▁# elif ▁HAVE _ ALIGNED _ MALLOC ▁_ aligned _ free ▁( ▁ptr ▁) ▁; ▁# else ▁free ▁( ▁ptr ▁) ▁; ▁# endif ▁}	1
▁static ▁av _ always _ inline ▁int ▁vm nc _ get _ pixel ▁( ▁Get Byte Context ▁* ▁gb ▁, ▁int ▁bpp ▁, ▁int ▁be ▁) ▁{ ▁switch ▁( ▁bpp ▁* ▁2 ▁+ ▁be ▁) ▁{ ▁case ▁2 ▁: ▁case ▁3 ▁: ▁return ▁bytestream 2_ get _ byte ▁( ▁gb ▁) ▁; ▁case ▁4 ▁: ▁return ▁bytestream 2_ get _ le 16 ▁( ▁gb ▁) ▁; ▁case ▁5 ▁: ▁return ▁bytestream 2_ get _ be 16 ▁( ▁gb ▁) ▁; ▁case ▁8 ▁: ▁return ▁bytestream 2_ get _ le 32 ▁( ▁gb ▁) ▁; ▁case ▁9 ▁: ▁return ▁bytestream 2_ get _ be 32 ▁( ▁gb ▁) ▁; ▁default ▁: ▁return ▁0 ▁; ▁} ▁}	1
▁AV Res ample Context ▁* ▁av _ res ample _ init ▁( ▁int ▁out _ rate ▁, ▁int ▁in _ rate ▁, ▁int ▁filter _ size ▁, ▁int ▁phase _ shift ▁, ▁int ▁linear ▁, ▁double ▁cutoff ▁) ▁{ ▁AV Res ample Context ▁* ▁c ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AV Res ample Context ▁) ▁) ▁; ▁double ▁factor ▁= ▁FF MIN ▁( ▁out _ rate ▁* ▁cutoff ▁/ ▁in _ rate ▁, ▁1.0 ▁) ▁; ▁int ▁phase _ count ▁= ▁1 ▁<< ▁phase _ shift ▁; ▁if ▁( ▁! ▁c ▁) ▁return ▁NULL ▁; ▁c ▁-> ▁phase _ shift ▁= ▁phase _ shift ▁; ▁c ▁-> ▁phase _ mask ▁= ▁phase _ count ▁- ▁1 ▁; ▁c ▁-> ▁linear ▁= ▁linear ▁; ▁c ▁-> ▁filter _ length ▁= ▁FF MAX ▁( ▁( ▁int ▁) ▁ceil ▁( ▁filter _ size ▁/ ▁factor ▁) ▁, ▁1 ▁) ▁; ▁c ▁-> ▁filter _ bank ▁= ▁av _ malloc z ▁( ▁c ▁-> ▁filter _ length ▁* ▁( ▁phase _ count ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁F ELEM ▁) ▁) ▁; ▁if ▁( ▁! ▁c ▁-> ▁filter _ bank ▁) ▁goto ▁error ▁; ▁if ▁( ▁build _ filter ▁( ▁c ▁-> ▁filter _ bank ▁, ▁factor ▁, ▁c ▁-> ▁filter _ length ▁, ▁phase _ count ▁, ▁1 ▁<< ▁FILTER _ SHIFT ▁, ▁WINDOW _ TYPE ▁) ▁) ▁goto ▁error ▁; ▁memcpy ▁( ▁& ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁* ▁phase _ count ▁+ ▁1 ▁] ▁, ▁c ▁-> ▁filter _ bank ▁, ▁( ▁c ▁-> ▁filter _ length ▁- ▁1 ▁) ▁* ▁sizeof ▁( ▁F ELEM ▁) ▁) ▁; ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁* ▁phase _ count ▁] ▁= ▁c ▁-> ▁filter _ bank ▁[ ▁c ▁-> ▁filter _ length ▁- ▁1 ▁] ▁; ▁c ▁-> ▁src _ incr ▁= ▁out _ rate ▁; ▁c ▁-> ▁ideal _ dst _ incr ▁= ▁c ▁-> ▁dst _ incr ▁= ▁in _ rate ▁* ▁phase _ count ▁; ▁c ▁-> ▁index ▁= ▁- ▁phase _ count ▁* ▁( ▁( ▁c ▁-> ▁filter _ length ▁- ▁1 ▁) ▁/ ▁2 ▁) ▁; ▁return ▁c ▁; ▁error ▁: ▁av _ free ▁( ▁c ▁-> ▁filter _ bank ▁) ▁; ▁av _ free ▁( ▁c ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁void ▁show _ stream ▁( ▁Writer Context ▁* ▁w ▁, ▁AVFormatContext ▁* ▁fmt _ ctx ▁, ▁int ▁stream _ idx ▁) ▁{ ▁AVStream ▁* ▁stream ▁= ▁fmt _ ctx ▁-> ▁streams ▁[ ▁stream _ idx ▁] ▁; ▁AVCodecContext ▁* ▁dec _ ctx ▁; ▁AVCodec ▁* ▁dec ▁; ▁char ▁val _ str ▁[ ▁128 ▁] ▁; ▁const ▁char ▁* ▁s ▁; ▁AVR ational ▁display _ aspect _ ratio ▁; ▁struct ▁print _ buf ▁pbuf ▁= ▁{ ▁. ▁s ▁= ▁NULL ▁} ▁; ▁print _ section _ header ▁( ▁" stream " ▁) ▁; ▁print _ int ▁( ▁" index " ▁, ▁stream ▁-> ▁index ▁) ▁; ▁if ▁( ▁( ▁dec _ ctx ▁= ▁stream ▁-> ▁codec ▁) ▁) ▁{ ▁if ▁( ▁( ▁dec ▁= ▁dec _ ctx ▁-> ▁codec ▁) ▁) ▁{ ▁print _ str ▁( ▁" codec _ name " ▁, ▁dec ▁-> ▁name ▁) ▁; ▁print _ str ▁( ▁" codec _ long _ name " ▁, ▁dec ▁-> ▁long _ name ▁) ▁; ▁} ▁else ▁{ ▁print _ str _ opt ▁( ▁" codec _ name " ▁, ▁" unknown " ▁) ▁; ▁print _ str _ opt ▁( ▁" codec _ long _ name " ▁, ▁" unknown " ▁) ▁; ▁} ▁s ▁= ▁av _ get _ media _ type _ string ▁( ▁dec _ ctx ▁-> ▁codec _ type ▁) ▁; ▁if ▁( ▁s ▁) ▁print _ str ▁( ▁" codec _ type " ▁, ▁s ▁) ▁; ▁else ▁print _ str _ opt ▁( ▁" codec _ type " ▁, ▁" unknown " ▁) ▁; ▁print _ fmt ▁( ▁" codec _ time _ base " ▁, ▁"% d /% d " ▁, ▁dec _ ctx ▁-> ▁time _ base ▁. ▁num ▁, ▁dec _ ctx ▁-> ▁time _ base ▁. ▁den ▁) ▁; ▁av _ get _ codec _ tag _ string ▁( ▁val _ str ▁, ▁sizeof ▁( ▁val _ str ▁) ▁, ▁dec _ ctx ▁-> ▁codec _ tag ▁) ▁; ▁print _ str ▁( ▁" codec _ tag _ string " ▁, ▁val _ str ▁) ▁; ▁print _ fmt ▁( ▁" codec _ tag " ▁, ▁"0 x %04 x " ▁, ▁dec _ ctx ▁-> ▁codec _ tag ▁) ▁; ▁switch ▁( ▁dec _ ctx ▁-> ▁codec _ type ▁) ▁{ ▁case ▁AVMEDIA _ TYPE _ VIDEO ▁: ▁print _ int ▁( ▁" width " ▁, ▁dec _ ctx ▁-> ▁width ▁) ▁; ▁print _ int ▁( ▁" height " ▁, ▁dec _ ctx ▁-> ▁height ▁) ▁; ▁print _ int ▁( ▁" has _ b _ frames " ▁, ▁dec _ ctx ▁-> ▁has _ b _ frames ▁) ▁; ▁if ▁( ▁dec _ ctx ▁-> ▁sample _ aspect _ ratio ▁. ▁num ▁) ▁{ ▁print _ fmt ▁( ▁" sample _ aspect _ ratio " ▁, ▁"% d :% d " ▁, ▁dec _ ctx ▁-> ▁sample _ aspect _ ratio ▁. ▁num ▁, ▁dec _ ctx ▁-> ▁sample _ aspect _ ratio ▁. ▁den ▁) ▁; ▁av _ reduce ▁( ▁& ▁display _ aspect _ ratio ▁. ▁num ▁, ▁& ▁display _ aspect _ ratio ▁. ▁den ▁, ▁dec _ ctx ▁-> ▁width ▁* ▁dec _ ctx ▁-> ▁sample _ aspect _ ratio ▁. ▁num ▁, ▁dec _ ctx ▁-> ▁height ▁* ▁dec _ ctx ▁-> ▁sample _ aspect _ ratio ▁. ▁den ▁, ▁1024 ▁* ▁1024 ▁) ▁; ▁print _ fmt ▁( ▁" display _ aspect _ ratio " ▁, ▁"% d :% d " ▁, ▁display _ aspect _ ratio ▁. ▁num ▁, ▁display _ aspect _ ratio ▁. ▁den ▁) ▁; ▁} ▁else ▁{ ▁print _ str _ opt ▁( ▁" sample _ aspect _ ratio " ▁, ▁" N / A " ▁) ▁; ▁print _ str _ opt ▁( ▁" display _ aspect _ ratio " ▁, ▁" N / A " ▁) ▁; ▁} ▁s ▁= ▁av _ get _ pix _ fmt _ name ▁( ▁dec _ ctx ▁-> ▁pix _ fmt ▁) ▁; ▁if ▁( ▁s ▁) ▁print _ str ▁( ▁" pix _ fmt " ▁, ▁s ▁) ▁; ▁else ▁print _ str _ opt ▁( ▁" pix _ fmt " ▁, ▁" unknown " ▁) ▁; ▁print _ int ▁( ▁" level " ▁, ▁dec _ ctx ▁-> ▁level ▁) ▁; ▁break ▁; ▁case ▁AVMEDIA _ TYPE _ AUDIO ▁: ▁s ▁= ▁av _ get _ sample _ fmt _ name ▁( ▁dec _ ctx ▁-> ▁sample _ fmt ▁) ▁; ▁if ▁( ▁s ▁) ▁print _ str ▁( ▁" sample _ fmt " ▁, ▁s ▁) ▁; ▁else ▁print _ str _ opt ▁( ▁" sample _ fmt " ▁, ▁" unknown " ▁) ▁; ▁print _ val ▁( ▁" sample _ rate " ▁, ▁dec _ ctx ▁-> ▁sample _ rate ▁, ▁unit _ h ert z _ str ▁) ▁; ▁print _ int ▁( ▁" channels " ▁, ▁dec _ ctx ▁-> ▁channels ▁) ▁; ▁print _ int ▁( ▁" bits _ per _ sample " ▁, ▁av _ get _ bits _ per _ sample ▁( ▁dec _ ctx ▁-> ▁codec _ id ▁) ▁) ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁print _ str _ opt ▁( ▁" codec _ type " ▁, ▁" unknown " ▁) ▁; ▁} ▁if ▁( ▁dec _ ctx ▁-> ▁codec ▁&& ▁dec _ ctx ▁-> ▁codec ▁-> ▁priv _ class ▁) ▁{ ▁const ▁AV Option ▁* ▁opt ▁= ▁NULL ▁; ▁while ▁( ▁opt ▁= ▁av _ opt _ next ▁( ▁dec _ ctx ▁-> ▁priv _ data ▁, ▁opt ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁str ▁; ▁if ▁( ▁opt ▁-> ▁flags ▁) ▁continue ▁; ▁if ▁( ▁av _ opt _ get ▁( ▁dec _ ctx ▁-> ▁priv _ data ▁, ▁opt ▁-> ▁name ▁, ▁0 ▁, ▁& ▁str ▁) ▁>= ▁0 ▁) ▁{ ▁print _ str ▁( ▁opt ▁-> ▁name ▁, ▁str ▁) ▁; ▁av _ free ▁( ▁str ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁fmt _ ctx ▁-> ▁if orm at ▁-> ▁flags ▁& ▁AV FMT _ SHOW _ IDS ▁) ▁print _ fmt ▁( ▁" id " ▁, ▁"0 x % x " ▁, ▁stream ▁-> ▁id ▁) ▁; ▁else ▁print _ str _ opt ▁( ▁" id " ▁, ▁" N / A " ▁) ▁; ▁print _ fmt ▁( ▁" r _ frame _ rate " ▁, ▁"% d /% d " ▁, ▁stream ▁-> ▁r _ frame _ rate ▁. ▁num ▁, ▁stream ▁-> ▁r _ frame _ rate ▁. ▁den ▁) ▁; ▁print _ fmt ▁( ▁" avg _ frame _ rate " ▁, ▁"% d /% d " ▁, ▁stream ▁-> ▁avg _ frame _ rate ▁. ▁num ▁, ▁stream ▁-> ▁avg _ frame _ rate ▁. ▁den ▁) ▁; ▁print _ fmt ▁( ▁" time _ base " ▁, ▁"% d /% d " ▁, ▁stream ▁-> ▁time _ base ▁. ▁num ▁, ▁stream ▁-> ▁time _ base ▁. ▁den ▁) ▁; ▁print _ time ▁( ▁" start _ time " ▁, ▁stream ▁-> ▁start _ time ▁, ▁& ▁stream ▁-> ▁time _ base ▁) ▁; ▁print _ time ▁( ▁" duration " ▁, ▁stream ▁-> ▁duration ▁, ▁& ▁stream ▁-> ▁time _ base ▁) ▁; ▁if ▁( ▁stream ▁-> ▁nb _ frames ▁) ▁print _ fmt ▁( ▁" nb _ frames " ▁, ▁"%" ▁PRId 64 ▁, ▁stream ▁-> ▁nb _ frames ▁) ▁; ▁else ▁print _ str _ opt ▁( ▁" nb _ frames " ▁, ▁" N / A " ▁) ▁; ▁show _ tags ▁( ▁stream ▁-> ▁metadata ▁) ▁; ▁print _ section _ footer ▁( ▁" stream " ▁) ▁; ▁av _ free ▁( ▁pbuf ▁. ▁s ▁) ▁; ▁fflush ▁( ▁stdout ▁) ▁; ▁}	0
▁static ▁int ▁synth _ super frame ▁( ▁AVCodecContext ▁* ▁ctx ▁, ▁float ▁* ▁samples ▁, ▁int ▁* ▁data _ size ▁) ▁{ ▁W MA Voice Context ▁* ▁s ▁= ▁ctx ▁-> ▁priv _ data ▁; ▁Get Bit Context ▁* ▁gb ▁= ▁& ▁s ▁-> ▁gb ▁, ▁s _ gb ▁; ▁int ▁n ▁, ▁res ▁, ▁n _ samples ▁= ▁480 ▁; ▁double ▁ls ps ▁[ ▁MAX _ FRAMES ▁] ▁[ ▁MAX _ L SP S ▁] ▁; ▁const ▁double ▁* ▁mean _ ls f ▁= ▁s ▁-> ▁ls ps ▁== ▁16 ▁? ▁wm av oice _ mean _ ls f 16 ▁[ ▁s ▁-> ▁lsp _ def _ mode ▁] ▁: ▁wm av oice _ mean _ ls f 10 ▁[ ▁s ▁-> ▁lsp _ def _ mode ▁] ▁; ▁float ▁exc itation ▁[ ▁MAX _ SIGNAL _ HISTORY ▁+ ▁MAX _ S FRAMES IZE ▁+ ▁12 ▁] ▁; ▁float ▁synth ▁[ ▁MAX _ L SP S ▁+ ▁MAX _ S FRAMES IZE ▁] ▁; ▁memcpy ▁( ▁synth ▁, ▁s ▁-> ▁synth _ history ▁, ▁s ▁-> ▁ls ps ▁* ▁sizeof ▁( ▁* ▁synth ▁) ▁) ▁; ▁memcpy ▁( ▁exc itation ▁, ▁s ▁-> ▁exc itation _ history ▁, ▁s ▁-> ▁history _ ns amples ▁* ▁sizeof ▁( ▁* ▁exc itation ▁) ▁) ▁; ▁if ▁( ▁s ▁-> ▁sf rame _ cache _ size ▁> ▁0 ▁) ▁{ ▁gb ▁= ▁& ▁s _ gb ▁; ▁init _ get _ bits ▁( ▁gb ▁, ▁s ▁-> ▁sf rame _ cache ▁, ▁s ▁-> ▁sf rame _ cache _ size ▁) ▁; ▁s ▁-> ▁sf rame _ cache _ size ▁= ▁0 ▁; ▁} ▁if ▁( ▁( ▁res ▁= ▁check _ bits _ for _ super frame ▁( ▁gb ▁, ▁s ▁) ▁) ▁== ▁1 ▁) ▁{ ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁1 ▁; ▁} ▁if ▁( ▁! ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁av _ log _ missing _ feature ▁( ▁ctx ▁, ▁" W MA Pro - in - W MA Vo ices upport " ▁, ▁1 ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁if ▁( ▁( ▁n _ samples ▁= ▁get _ bits ▁( ▁gb ▁, ▁12 ▁) ▁) ▁> ▁480 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Super frame encode s > 4 80 samples (% d ), not allowed \ n " ▁, ▁n _ samples ▁) ▁; ▁return ▁-1 ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁has _ residual _ ls ps ▁) ▁{ ▁double ▁prev _ ls ps ▁[ ▁MAX _ L SP S ▁] ▁, ▁a 1 ▁[ ▁MAX _ L SP S ▁* ▁2 ▁] ▁, ▁a 2 ▁[ ▁MAX _ L SP S ▁* ▁2 ▁] ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁s ▁-> ▁ls ps ▁; ▁n ▁++ ▁) ▁prev _ ls ps ▁[ ▁n ▁] ▁= ▁s ▁-> ▁prev _ ls ps ▁[ ▁n ▁] ▁- ▁mean _ ls f ▁[ ▁n ▁] ▁; ▁if ▁( ▁s ▁-> ▁ls ps ▁== ▁10 ▁) ▁{ ▁de quant _ l sp 10 r ▁( ▁gb ▁, ▁ls ps ▁[ ▁2 ▁] ▁, ▁prev _ ls ps ▁, ▁a 1 ▁, ▁a 2 ▁, ▁s ▁-> ▁lsp _ q _ mode ▁) ▁; ▁} ▁else ▁de quant _ l sp 16 r ▁( ▁gb ▁, ▁ls ps ▁[ ▁2 ▁] ▁, ▁prev _ ls ps ▁, ▁a 1 ▁, ▁a 2 ▁, ▁s ▁-> ▁lsp _ q _ mode ▁) ▁; ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁s ▁-> ▁ls ps ▁; ▁n ▁++ ▁) ▁{ ▁ls ps ▁[ ▁0 ▁] ▁[ ▁n ▁] ▁= ▁mean _ ls f ▁[ ▁n ▁] ▁+ ▁( ▁a 1 ▁[ ▁n ▁] ▁- ▁a 2 ▁[ ▁n ▁* ▁2 ▁] ▁) ▁; ▁ls ps ▁[ ▁1 ▁] ▁[ ▁n ▁] ▁= ▁mean _ ls f ▁[ ▁n ▁] ▁+ ▁( ▁a 1 ▁[ ▁s ▁-> ▁ls ps ▁+ ▁n ▁] ▁- ▁a 2 ▁[ ▁n ▁* ▁2 ▁+ ▁1 ▁] ▁) ▁; ▁ls ps ▁[ ▁2 ▁] ▁[ ▁n ▁] ▁+= ▁mean _ ls f ▁[ ▁n ▁] ▁; ▁} ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁3 ▁; ▁n ▁++ ▁) ▁st abil ize _ ls ps ▁( ▁ls ps ▁[ ▁n ▁] ▁, ▁s ▁-> ▁ls ps ▁) ▁; ▁} ▁for ▁( ▁n ▁= ▁0 ▁; ▁n ▁< ▁3 ▁; ▁n ▁++ ▁) ▁{ ▁if ▁( ▁! ▁s ▁-> ▁has _ residual _ ls ps ▁) ▁{ ▁int ▁m ▁; ▁if ▁( ▁s ▁-> ▁ls ps ▁== ▁10 ▁) ▁{ ▁de quant _ l sp 10 i ▁( ▁gb ▁, ▁ls ps ▁[ ▁n ▁] ▁) ▁; ▁} ▁else ▁de quant _ l sp 16 i ▁( ▁gb ▁, ▁ls ps ▁[ ▁n ▁] ▁) ▁; ▁for ▁( ▁m ▁= ▁0 ▁; ▁m ▁< ▁s ▁-> ▁ls ps ▁; ▁m ▁++ ▁) ▁ls ps ▁[ ▁n ▁] ▁[ ▁m ▁] ▁+= ▁mean _ ls f ▁[ ▁m ▁] ▁; ▁st abil ize _ ls ps ▁( ▁ls ps ▁[ ▁n ▁] ▁, ▁s ▁-> ▁ls ps ▁) ▁; ▁} ▁if ▁( ▁( ▁res ▁= ▁synth _ frame ▁( ▁ctx ▁, ▁gb ▁, ▁n ▁, ▁& ▁samples ▁[ ▁n ▁* ▁MAX _ FRAMES IZE ▁] ▁, ▁ls ps ▁[ ▁n ▁] ▁, ▁n ▁== ▁0 ▁? ▁s ▁-> ▁prev _ ls ps ▁: ▁ls ps ▁[ ▁n ▁- ▁1 ▁] ▁, ▁& ▁exc itation ▁[ ▁s ▁-> ▁history _ ns amples ▁+ ▁n ▁* ▁MAX _ FRAMES IZE ▁] ▁, ▁& ▁synth ▁[ ▁s ▁-> ▁ls ps ▁+ ▁n ▁* ▁MAX _ FRAMES IZE ▁] ▁) ▁) ▁) ▁{ ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁res ▁; ▁} ▁} ▁if ▁( ▁get _ bits 1 ▁( ▁gb ▁) ▁) ▁{ ▁res ▁= ▁get _ bits ▁( ▁gb ▁, ▁4 ▁) ▁; ▁skip _ bits ▁( ▁gb ▁, ▁10 ▁* ▁( ▁res ▁+ ▁1 ▁) ▁) ▁; ▁} ▁* ▁data _ size ▁= ▁n _ samples ▁* ▁sizeof ▁( ▁float ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁prev _ ls ps ▁, ▁ls ps ▁[ ▁2 ▁] ▁, ▁s ▁-> ▁ls ps ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁prev _ ls ps ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁synth _ history ▁, ▁& ▁synth ▁[ ▁MAX _ S FRAMES IZE ▁] ▁, ▁s ▁-> ▁ls ps ▁* ▁sizeof ▁( ▁* ▁synth ▁) ▁) ▁; ▁memcpy ▁( ▁s ▁-> ▁exc itation _ history ▁, ▁& ▁exc itation ▁[ ▁MAX _ S FRAMES IZE ▁] ▁, ▁s ▁-> ▁history _ ns amples ▁* ▁sizeof ▁( ▁* ▁exc itation ▁) ▁) ▁; ▁if ▁( ▁s ▁-> ▁do _ ap f ▁) ▁memmove ▁( ▁s ▁-> ▁zero _ exc _ pf ▁, ▁& ▁s ▁-> ▁zero _ exc _ pf ▁[ ▁MAX _ S FRAMES IZE ▁] ▁, ▁s ▁-> ▁history _ ns amples ▁* ▁sizeof ▁( ▁* ▁s ▁-> ▁zero _ exc _ pf ▁) ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁int ▁av _ image _ fill _ pointers ▁( ▁uint 8_ t ▁* ▁data ▁[ ▁4 ▁] ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁, ▁int ▁height ▁, ▁uint 8_ t ▁* ▁ptr ▁, ▁const ▁int ▁lines izes ▁[ ▁4 ▁] ▁) ▁{ ▁int ▁i ▁, ▁total _ size ▁, ▁size ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁, ▁has _ plane ▁[ ▁4 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁const ▁AV Pix Fmt Descriptor ▁* ▁desc ▁= ▁av _ pix _ fmt _ desc _ get ▁( ▁pix _ fmt ▁) ▁; ▁memset ▁( ▁data ▁, ▁0 ▁, ▁sizeof ▁( ▁data ▁[ ▁0 ▁] ▁) ▁* ▁4 ▁) ▁; ▁if ▁( ▁! ▁desc ▁|| ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ HW ACCEL ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁data ▁[ ▁0 ▁] ▁= ▁ptr ▁; ▁if ▁( ▁lines izes ▁[ ▁0 ▁] ▁> ▁( ▁INT _ MAX ▁- ▁1024 ▁) ▁/ ▁height ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁size ▁[ ▁0 ▁] ▁= ▁lines izes ▁[ ▁0 ▁] ▁* ▁height ▁; ▁if ▁( ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PAL ▁|| ▁desc ▁-> ▁flags ▁& ▁AV _ PIX _ FMT _ FLAG _ PSE UD OP AL ▁) ▁{ ▁size ▁[ ▁0 ▁] ▁= ▁( ▁size ▁[ ▁0 ▁] ▁+ ▁3 ▁) ▁& ▁ ~ ▁3 ▁; ▁data ▁[ ▁1 ▁] ▁= ▁ptr ▁+ ▁size ▁[ ▁0 ▁] ▁; ▁return ▁size ▁[ ▁0 ▁] ▁+ ▁256 ▁* ▁4 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁has _ plane ▁[ ▁desc ▁-> ▁comp ▁[ ▁i ▁] ▁. ▁plane ▁] ▁= ▁1 ▁; ▁total _ size ▁= ▁size ▁[ ▁0 ▁] ▁; ▁for ▁( ▁i ▁= ▁1 ▁; ▁i ▁< ▁4 ▁&& ▁has _ plane ▁[ ▁i ▁] ▁; ▁i ▁++ ▁) ▁{ ▁int ▁h ▁, ▁s ▁= ▁( ▁i ▁== ▁1 ▁|| ▁i ▁== ▁2 ▁) ▁? ▁desc ▁-> ▁log 2_ chroma _ h ▁: ▁0 ▁; ▁data ▁[ ▁i ▁] ▁= ▁data ▁[ ▁i ▁- ▁1 ▁] ▁+ ▁size ▁[ ▁i ▁- ▁1 ▁] ▁; ▁h ▁= ▁( ▁height ▁+ ▁( ▁1 ▁<< ▁s ▁) ▁- ▁1 ▁) ▁>> ▁s ▁; ▁if ▁( ▁lines izes ▁[ ▁i ▁] ▁> ▁INT _ MAX ▁/ ▁h ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁size ▁[ ▁i ▁] ▁= ▁h ▁* ▁lines izes ▁[ ▁i ▁] ▁; ▁if ▁( ▁total _ size ▁> ▁INT _ MAX ▁- ▁size ▁[ ▁i ▁] ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁total _ size ▁+= ▁size ▁[ ▁i ▁] ▁; ▁} ▁return ▁total _ size ▁; ▁}	1
▁static ▁void ▁fill _ buffer ▁( ▁AVIO Context ▁* ▁s ▁) ▁{ ▁int ▁max _ buffer _ size ▁= ▁s ▁-> ▁max _ packet _ size ▁? ▁s ▁-> ▁max _ packet _ size ▁: ▁IO _ BUFFER _ SIZE ▁; ▁uint 8_ t ▁* ▁dst ▁= ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁buffer ▁+ ▁max _ buffer _ size ▁< ▁s ▁-> ▁buffer _ size ▁? ▁s ▁-> ▁buf _ end ▁: ▁s ▁-> ▁buffer ▁; ▁int ▁len ▁= ▁s ▁-> ▁buffer _ size ▁- ▁( ▁dst ▁- ▁s ▁-> ▁buffer ▁) ▁; ▁if ▁( ▁! ▁s ▁-> ▁read _ packet ▁&& ▁s ▁-> ▁buf _ ptr ▁>= ▁s ▁-> ▁buf _ end ▁) ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁if ▁( ▁s ▁-> ▁eof _ reached ▁) ▁return ▁; ▁if ▁( ▁s ▁-> ▁update _ checksum ▁&& ▁dst ▁== ▁s ▁-> ▁buffer ▁) ▁{ ▁if ▁( ▁s ▁-> ▁buf _ end ▁> ▁s ▁-> ▁checksum _ ptr ▁) ▁s ▁-> ▁checksum ▁= ▁s ▁-> ▁update _ checksum ▁( ▁s ▁-> ▁checksum ▁, ▁s ▁-> ▁checksum _ ptr ▁, ▁s ▁-> ▁buf _ end ▁- ▁s ▁-> ▁checksum _ ptr ▁) ▁; ▁s ▁-> ▁checksum _ ptr ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁if ▁( ▁s ▁-> ▁read _ packet ▁&& ▁s ▁-> ▁orig _ buffer _ size ▁&& ▁s ▁-> ▁buffer _ size ▁> ▁s ▁-> ▁orig _ buffer _ size ▁) ▁{ ▁if ▁( ▁dst ▁== ▁s ▁-> ▁buffer ▁&& ▁s ▁-> ▁buf _ ptr ▁!= ▁dst ▁) ▁{ ▁int ▁ret ▁= ▁ff io _ set _ buf _ size ▁( ▁s ▁, ▁s ▁-> ▁orig _ buffer _ size ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁av _ log ▁( ▁s ▁, ▁AV _ LOG _ WARNING ▁, ▁" Failed t ode crease buffers ize \ n " ▁) ▁; ▁s ▁-> ▁checksum _ ptr ▁= ▁dst ▁= ▁s ▁-> ▁buffer ▁; ▁} ▁av _ assert 0 ▁( ▁len ▁>= ▁s ▁-> ▁orig _ buffer _ size ▁) ▁; ▁len ▁= ▁s ▁-> ▁orig _ buffer _ size ▁; ▁} ▁if ▁( ▁s ▁-> ▁read _ packet ▁) ▁len ▁= ▁s ▁-> ▁read _ packet ▁( ▁s ▁-> ▁opaque ▁, ▁dst ▁, ▁len ▁) ▁; ▁else ▁len ▁= ▁0 ▁; ▁if ▁( ▁len ▁<= ▁0 ▁) ▁{ ▁s ▁-> ▁eof _ reached ▁= ▁1 ▁; ▁if ▁( ▁len ▁< ▁0 ▁) ▁s ▁-> ▁error ▁= ▁len ▁; ▁} ▁else ▁{ ▁s ▁-> ▁pos ▁+= ▁len ▁; ▁s ▁-> ▁buf _ ptr ▁= ▁dst ▁; ▁s ▁-> ▁buf _ end ▁= ▁dst ▁+ ▁len ▁; ▁s ▁-> ▁bytes _ read ▁+= ▁len ▁; ▁} ▁}	1
▁static ▁inline ▁void ▁q pel _ motion ▁( ▁Mpeg Enc Context ▁* ▁s ▁, ▁uint 8_ t ▁* ▁dest _ y ▁, ▁uint 8_ t ▁* ▁dest _ cb ▁, ▁uint 8_ t ▁* ▁dest _ cr ▁, ▁int ▁field _ based ▁, ▁int ▁bottom _ field ▁, ▁int ▁field _ select ▁, ▁uint 8_ t ▁* ▁* ▁ref _ picture ▁, ▁op _ pixels _ func ▁( ▁* ▁pix _ op ▁) ▁[ ▁4 ▁] ▁, ▁q pel _ mc _ func ▁( ▁* ▁q pix _ op ▁) ▁[ ▁16 ▁] ▁, ▁int ▁motion _ x ▁, ▁int ▁motion _ y ▁, ▁int ▁h ▁) ▁{ ▁uint 8_ t ▁* ▁ptr _ y ▁, ▁* ▁ptr _ cb ▁, ▁* ▁ptr _ cr ▁; ▁int ▁d xy ▁, ▁uv d xy ▁, ▁mx ▁, ▁my ▁, ▁src _ x ▁, ▁src _ y ▁, ▁uv src _ x ▁, ▁uv src _ y ▁, ▁v _ edge _ pos ▁; ▁ptrdiff _ t ▁linesize ▁, ▁uv lines ize ▁; ▁d xy ▁= ▁( ▁( ▁motion _ y ▁& ▁3 ▁) ▁<< ▁2 ▁) ▁| ▁( ▁motion _ x ▁& ▁3 ▁) ▁; ▁src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁16 ▁+ ▁( ▁motion _ x ▁>> ▁2 ▁) ▁; ▁src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁( ▁16 ▁>> ▁field _ based ▁) ▁+ ▁( ▁motion _ y ▁>> ▁2 ▁) ▁; ▁v _ edge _ pos ▁= ▁s ▁-> ▁v _ edge _ pos ▁>> ▁field _ based ▁; ▁linesize ▁= ▁s ▁-> ▁linesize ▁<< ▁field _ based ▁; ▁uv lines ize ▁= ▁s ▁-> ▁uv lines ize ▁<< ▁field _ based ▁; ▁if ▁( ▁field _ based ▁) ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁>> ▁1 ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ Q PE L _ CH RO MA 2 ▁) ▁{ ▁static ▁const ▁int ▁rt ab ▁[ ▁8 ▁] ▁= ▁{ ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁} ▁; ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁+ ▁rt ab ▁[ ▁motion _ x ▁& ▁7 ▁] ▁; ▁my ▁= ▁( ▁motion _ y ▁>> ▁1 ▁) ▁+ ▁rt ab ▁[ ▁motion _ y ▁& ▁7 ▁] ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁workaround _ bugs ▁& ▁FF _ BUG _ Q PE L _ CH RO MA ▁) ▁{ ▁mx ▁= ▁( ▁motion _ x ▁>> ▁1 ▁) ▁| ▁( ▁motion _ x ▁& ▁1 ▁) ▁; ▁my ▁= ▁( ▁motion _ y ▁>> ▁1 ▁) ▁| ▁( ▁motion _ y ▁& ▁1 ▁) ▁; ▁} ▁else ▁{ ▁mx ▁= ▁motion _ x ▁/ ▁2 ▁; ▁my ▁= ▁motion _ y ▁/ ▁2 ▁; ▁} ▁mx ▁= ▁( ▁mx ▁>> ▁1 ▁) ▁| ▁( ▁mx ▁& ▁1 ▁) ▁; ▁my ▁= ▁( ▁my ▁>> ▁1 ▁) ▁| ▁( ▁my ▁& ▁1 ▁) ▁; ▁uv d xy ▁= ▁( ▁mx ▁& ▁1 ▁) ▁| ▁( ▁( ▁my ▁& ▁1 ▁) ▁<< ▁1 ▁) ▁; ▁mx ▁>>= ▁1 ▁; ▁my ▁>>= ▁1 ▁; ▁uv src _ x ▁= ▁s ▁-> ▁mb _ x ▁* ▁8 ▁+ ▁mx ▁; ▁uv src _ y ▁= ▁s ▁-> ▁mb _ y ▁* ▁( ▁8 ▁>> ▁field _ based ▁) ▁+ ▁my ▁; ▁ptr _ y ▁= ▁ref _ picture ▁[ ▁0 ▁] ▁+ ▁src _ y ▁* ▁linesize ▁+ ▁src _ x ▁; ▁ptr _ cb ▁= ▁ref _ picture ▁[ ▁1 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁ptr _ cr ▁= ▁ref _ picture ▁[ ▁2 ▁] ▁+ ▁uv src _ y ▁* ▁uv lines ize ▁+ ▁uv src _ x ▁; ▁if ▁( ▁( ▁unsigned ▁) ▁src _ x ▁> ▁FF MAX ▁( ▁s ▁-> ▁h _ edge _ pos ▁- ▁( ▁motion _ x ▁& ▁3 ▁) ▁- ▁16 ▁, ▁0 ▁) ▁|| ▁( ▁unsigned ▁) ▁src _ y ▁> ▁FF MAX ▁( ▁v _ edge _ pos ▁- ▁( ▁motion _ y ▁& ▁3 ▁) ▁- ▁h ▁, ▁0 ▁) ▁) ▁{ ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁s ▁-> ▁edge _ emu _ buffer ▁, ▁ptr _ y ▁, ▁s ▁-> ▁linesize ▁, ▁17 ▁, ▁17 ▁+ ▁field _ based ▁, ▁src _ x ▁, ▁src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁, ▁s ▁-> ▁v _ edge _ pos ▁) ▁; ▁ptr _ y ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁; ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁uint 8_ t ▁* ▁uv buf ▁= ▁s ▁-> ▁edge _ emu _ buffer ▁+ ▁18 ▁* ▁s ▁-> ▁linesize ▁; ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁, ▁ptr _ cb ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁s ▁-> ▁v dsp ▁. ▁emulated _ edge _ mc ▁( ▁uv buf ▁+ ▁16 ▁, ▁ptr _ cr ▁, ▁s ▁-> ▁uv lines ize ▁, ▁9 ▁, ▁9 ▁+ ▁field _ based ▁, ▁uv src _ x ▁, ▁uv src _ y ▁<< ▁field _ based ▁, ▁s ▁-> ▁h _ edge _ pos ▁>> ▁1 ▁, ▁s ▁-> ▁v _ edge _ pos ▁>> ▁1 ▁) ▁; ▁ptr _ cb ▁= ▁uv buf ▁; ▁ptr _ cr ▁= ▁uv buf ▁+ ▁16 ▁; ▁} ▁} ▁if ▁( ▁! ▁field _ based ▁) ▁q pix _ op ▁[ ▁0 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁) ▁; ▁else ▁{ ▁if ▁( ▁bottom _ field ▁) ▁{ ▁dest _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁dest _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁dest _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁if ▁( ▁field _ select ▁) ▁{ ▁ptr _ y ▁+= ▁s ▁-> ▁linesize ▁; ▁ptr _ cb ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁ptr _ cr ▁+= ▁s ▁-> ▁uv lines ize ▁; ▁} ▁q pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁, ▁ptr _ y ▁, ▁linesize ▁) ▁; ▁q pix _ op ▁[ ▁1 ▁] ▁[ ▁d xy ▁] ▁( ▁dest _ y ▁+ ▁8 ▁, ▁ptr _ y ▁+ ▁8 ▁, ▁linesize ▁) ▁; ▁} ▁if ▁( ▁! ▁CONFIG _ GRAY ▁|| ▁! ▁( ▁s ▁-> ▁flags ▁& ▁CODEC _ FLAG _ GRAY ▁) ▁) ▁{ ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cr ▁, ▁ptr _ cr ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁pix _ op ▁[ ▁1 ▁] ▁[ ▁uv d xy ▁] ▁( ▁dest _ cb ▁, ▁ptr _ cb ▁, ▁uv lines ize ▁, ▁h ▁>> ▁1 ▁) ▁; ▁} ▁}	0
▁static ▁int ▁filter _ frame ▁( ▁AVFilter Link ▁* ▁inlink ▁, ▁AVFilter Buffer Ref ▁* ▁in pic ref ▁) ▁{ ▁I lContext ▁* ▁il ▁= ▁inlink ▁-> ▁dst ▁-> ▁priv ▁; ▁AVFilter Link ▁* ▁out link ▁= ▁inlink ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁AVFilter Buffer Ref ▁* ▁out ▁; ▁int ▁ret ▁, ▁comp ▁; ▁out ▁= ▁ff _ get _ video _ buffer ▁( ▁out link ▁, ▁AV _ PERM _ WRITE ▁, ▁out link ▁-> ▁w ▁, ▁out link ▁-> ▁h ▁) ▁; ▁if ▁( ▁! ▁out ▁) ▁{ ▁avfilter _ unref _ buffer p ▁( ▁& ▁in pic ref ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁avfilter _ copy _ buffer _ ref _ props ▁( ▁out ▁, ▁in pic ref ▁) ▁; ▁interleave ▁( ▁out ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁in pic ref ▁-> ▁data ▁[ ▁0 ▁] ▁, ▁il ▁-> ▁linesize ▁[ ▁0 ▁] ▁, ▁inlink ▁-> ▁h ▁, ▁out ▁-> ▁linesize ▁[ ▁0 ▁] ▁, ▁in pic ref ▁-> ▁linesize ▁[ ▁0 ▁] ▁, ▁il ▁-> ▁lum a _ mode ▁, ▁il ▁-> ▁lum a _ swap ▁) ▁; ▁for ▁( ▁comp ▁= ▁1 ▁; ▁comp ▁< ▁( ▁il ▁-> ▁nb _ planes ▁- ▁il ▁-> ▁has _ alpha ▁) ▁; ▁comp ▁++ ▁) ▁{ ▁interleave ▁( ▁out ▁-> ▁data ▁[ ▁comp ▁] ▁, ▁in pic ref ▁-> ▁data ▁[ ▁comp ▁] ▁, ▁il ▁-> ▁linesize ▁[ ▁comp ▁] ▁, ▁il ▁-> ▁chroma _ height ▁, ▁out ▁-> ▁linesize ▁[ ▁comp ▁] ▁, ▁in pic ref ▁-> ▁linesize ▁[ ▁comp ▁] ▁, ▁il ▁-> ▁chroma _ mode ▁, ▁il ▁-> ▁chroma _ swap ▁) ▁; ▁} ▁if ▁( ▁il ▁-> ▁has _ alpha ▁) ▁{ ▁int ▁comp ▁= ▁il ▁-> ▁nb _ planes ▁- ▁1 ▁; ▁interleave ▁( ▁out ▁-> ▁data ▁[ ▁comp ▁] ▁, ▁in pic ref ▁-> ▁data ▁[ ▁comp ▁] ▁, ▁il ▁-> ▁linesize ▁[ ▁comp ▁] ▁, ▁inlink ▁-> ▁h ▁, ▁out ▁-> ▁linesize ▁[ ▁comp ▁] ▁, ▁in pic ref ▁-> ▁linesize ▁[ ▁comp ▁] ▁, ▁il ▁-> ▁alpha _ mode ▁, ▁il ▁-> ▁alpha _ swap ▁) ▁; ▁} ▁ret ▁= ▁ff _ filter _ frame ▁( ▁out link ▁, ▁out ▁) ▁; ▁avfilter _ unref _ buffer p ▁( ▁& ▁in pic ref ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁inline ▁void ▁render _ line _ un rolled ▁( ▁intptr _ t ▁x ▁, ▁int ▁y ▁, ▁int ▁x 1 ▁, ▁intptr _ t ▁sy ▁, ▁int ▁ad y ▁, ▁int ▁adx ▁, ▁float ▁* ▁buf ▁) ▁{ ▁int ▁err ▁= ▁- ▁adx ▁; ▁x ▁-= ▁x 1 ▁- ▁1 ▁; ▁buf ▁+= ▁x 1 ▁- ▁1 ▁; ▁while ▁( ▁++ ▁x ▁< ▁0 ▁) ▁{ ▁err ▁+= ▁ad y ▁; ▁if ▁( ▁err ▁>= ▁0 ▁) ▁{ ▁err ▁+= ▁ad y ▁- ▁adx ▁; ▁y ▁+= ▁sy ▁; ▁buf ▁[ ▁x ▁++ ▁] ▁= ▁ff _ vorbis _ floor 1_ inverse _ db _ table ▁[ ▁av _ clip _ uint 8 ▁( ▁y ▁) ▁] ▁; ▁} ▁buf ▁[ ▁x ▁] ▁= ▁ff _ vorbis _ floor 1_ inverse _ db _ table ▁[ ▁av _ clip _ uint 8 ▁( ▁y ▁) ▁] ▁; ▁} ▁if ▁( ▁x ▁<= ▁0 ▁) ▁{ ▁if ▁( ▁err ▁+ ▁ad y ▁>= ▁0 ▁) ▁y ▁+= ▁sy ▁; ▁buf ▁[ ▁x ▁] ▁= ▁ff _ vorbis _ floor 1_ inverse _ db _ table ▁[ ▁av _ clip _ uint 8 ▁( ▁y ▁) ▁] ▁; ▁} ▁}	0
▁static ▁int ▁parse _ b intree ▁( ▁In de o 3 Decode Context ▁* ▁ctx ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁Plane ▁* ▁plane ▁, ▁int ▁code ▁, ▁Cell ▁* ▁ref _ cell ▁, ▁const ▁int ▁depth ▁, ▁const ▁int ▁strip _ width ▁) ▁{ ▁Cell ▁curr _ cell ▁; ▁int ▁bytes _ used ▁; ▁if ▁( ▁depth ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Stack overflow ( cor rupted binary tree ) !\ n " ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁curr _ cell ▁= ▁* ▁ref _ cell ▁; ▁if ▁( ▁code ▁== ▁H _ SPLIT ▁) ▁{ ▁SPLIT _ CELL ▁( ▁ref _ cell ▁-> ▁height ▁, ▁curr _ cell ▁. ▁height ▁) ▁; ▁ref _ cell ▁-> ▁ypos ▁+= ▁curr _ cell ▁. ▁height ▁; ▁ref _ cell ▁-> ▁height ▁-= ▁curr _ cell ▁. ▁height ▁; ▁} ▁else ▁if ▁( ▁code ▁== ▁V _ SPLIT ▁) ▁{ ▁if ▁( ▁curr _ cell ▁. ▁width ▁> ▁strip _ width ▁) ▁{ ▁curr _ cell ▁. ▁width ▁= ▁( ▁curr _ cell ▁. ▁width ▁<= ▁( ▁strip _ width ▁<< ▁1 ▁) ▁? ▁1 ▁: ▁2 ▁) ▁* ▁strip _ width ▁; ▁} ▁else ▁SPLIT _ CELL ▁( ▁ref _ cell ▁-> ▁width ▁, ▁curr _ cell ▁. ▁width ▁) ▁; ▁ref _ cell ▁-> ▁xpos ▁+= ▁curr _ cell ▁. ▁width ▁; ▁ref _ cell ▁-> ▁width ▁-= ▁curr _ cell ▁. ▁width ▁; ▁} ▁while ▁( ▁get _ bits _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁>= ▁2 ▁) ▁{ ▁RES YNC _ BIT STREAM ▁; ▁switch ▁( ▁code ▁= ▁get _ bits ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁2 ▁) ▁) ▁{ ▁case ▁H _ SPLIT ▁: ▁case ▁V _ SPLIT ▁: ▁if ▁( ▁parse _ b intree ▁( ▁ctx ▁, ▁avctx ▁, ▁plane ▁, ▁code ▁, ▁& ▁curr _ cell ▁, ▁depth ▁- ▁1 ▁, ▁strip _ width ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁break ▁; ▁case ▁IN TRA _ NULL ▁: ▁if ▁( ▁! ▁curr _ cell ▁. ▁tree ▁) ▁{ ▁curr _ cell ▁. ▁mv _ ptr ▁= ▁0 ▁; ▁curr _ cell ▁. ▁tree ▁= ▁1 ▁; ▁} ▁else ▁{ ▁RES YNC _ BIT STREAM ▁; ▁code ▁= ▁get _ bits ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁2 ▁) ▁; ▁if ▁( ▁code ▁>= ▁2 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Invalid V Q _ NULL code :% d \ n " ▁, ▁code ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁if ▁( ▁code ▁== ▁1 ▁) ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Skip Cell procedure not implemented y et !\ n " ▁) ▁; ▁CHECK _ CELL ▁if ▁( ▁! ▁curr _ cell ▁. ▁mv _ ptr ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁copy _ cell ▁( ▁ctx ▁, ▁plane ▁, ▁& ▁curr _ cell ▁) ▁; ▁return ▁0 ▁; ▁} ▁break ▁; ▁case ▁INTER _ DATA ▁: ▁if ▁( ▁! ▁curr _ cell ▁. ▁tree ▁) ▁{ ▁if ▁( ▁! ▁ctx ▁-> ▁need _ res ync ▁) ▁ctx ▁-> ▁next _ cell _ data ▁= ▁& ▁ctx ▁-> ▁gb ▁. ▁buffer ▁[ ▁( ▁get _ bits _ count ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁+ ▁7 ▁) ▁>> ▁3 ▁] ▁; ▁if ▁( ▁ctx ▁-> ▁mc _ vectors ▁) ▁curr _ cell ▁. ▁mv _ ptr ▁= ▁& ▁ctx ▁-> ▁mc _ vectors ▁[ ▁* ▁( ▁ctx ▁-> ▁next _ cell _ data ▁++ ▁) ▁<< ▁1 ▁] ▁; ▁curr _ cell ▁. ▁tree ▁= ▁1 ▁; ▁UPDATE _ BIT POS ▁( ▁8 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁ctx ▁-> ▁need _ res ync ▁) ▁ctx ▁-> ▁next _ cell _ data ▁= ▁& ▁ctx ▁-> ▁gb ▁. ▁buffer ▁[ ▁( ▁get _ bits _ count ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁+ ▁7 ▁) ▁>> ▁3 ▁] ▁; ▁CHECK _ CELL ▁bytes _ used ▁= ▁decode _ cell ▁( ▁ctx ▁, ▁avctx ▁, ▁plane ▁, ▁& ▁curr _ cell ▁, ▁ctx ▁-> ▁next _ cell _ data ▁, ▁ctx ▁-> ▁last _ byte ▁) ▁; ▁if ▁( ▁bytes _ used ▁< ▁0 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁UPDATE _ BIT POS ▁( ▁bytes _ used ▁<< ▁3 ▁) ▁; ▁ctx ▁-> ▁next _ cell _ data ▁+= ▁bytes _ used ▁; ▁return ▁0 ▁; ▁} ▁break ▁; ▁} ▁} ▁return ▁AVERROR _ INVALIDDATA ▁; ▁}	0
▁BN _ BL IND ING ▁* ▁BN _ BL IND ING _ new ▁( ▁const ▁BIGNUM ▁* ▁A ▁, ▁const ▁BIGNUM ▁* ▁Ai ▁, ▁BIGNUM ▁* ▁mod ▁) ▁{ ▁BN _ BL IND ING ▁* ▁ret ▁= ▁NULL ▁; ▁bn _ check _ top ▁( ▁mod ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁( ▁BN _ BL IND ING ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁BN _ BL IND ING ▁) ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁BN err ▁( ▁BN _ F _ BN _ BL IND ING _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁memset ▁( ▁ret ▁, ▁0 ▁, ▁sizeof ▁( ▁BN _ BL IND ING ▁) ▁) ▁; ▁if ▁( ▁A ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ret ▁-> ▁A ▁= ▁BN _ dup ▁( ▁A ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁Ai ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁( ▁ret ▁-> ▁Ai ▁= ▁BN _ dup ▁( ▁Ai ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁mod ▁= ▁BN _ dup ▁( ▁mod ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁if ▁( ▁BN _ get _ flags ▁( ▁mod ▁, ▁BN _ FLG _ CONST TIME ▁) ▁!= ▁0 ▁) ▁BN _ set _ flags ▁( ▁ret ▁-> ▁mod ▁, ▁BN _ FLG _ CONST TIME ▁) ▁; ▁ret ▁-> ▁counter ▁= ▁BN _ BL IND ING _ COUNTER ▁; ▁return ▁( ▁ret ▁) ▁; ▁err ▁: ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁BN _ BL IND ING _ free ▁( ▁ret ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	1
▁int ▁tls 1_ final _ finish _ mac ▁( ▁SSL ▁* ▁s ▁, ▁const ▁char ▁* ▁str ▁, ▁int ▁slen ▁, ▁unsigned ▁char ▁* ▁out ▁) ▁{ ▁unsigned ▁int ▁i ▁; ▁EVP _ MD _ CTX ▁ctx ▁; ▁unsigned ▁char ▁buf ▁[ ▁2 ▁* ▁EVP _ MAX _ MD _ SIZE ▁] ▁; ▁unsigned ▁char ▁* ▁q ▁, ▁buf 2 ▁[ ▁12 ▁] ▁; ▁int ▁idx ▁; ▁long ▁mask ▁; ▁int ▁err ▁= ▁0 ▁; ▁const ▁EVP _ MD ▁* ▁md ▁; ▁q ▁= ▁buf ▁; ▁if ▁( ▁s ▁-> ▁s 3 ▁-> ▁handshake _ buffer ▁) ▁if ▁( ▁! ▁ssl 3_ digest _ cached _ records ▁( ▁s ▁) ▁) ▁return ▁0 ▁; ▁EVP _ MD _ CTX _ init ▁( ▁& ▁ctx ▁) ▁; ▁for ▁( ▁idx ▁= ▁0 ▁; ▁ssl _ get _ handshake _ digest ▁( ▁idx ▁, ▁& ▁mask ▁, ▁& ▁md ▁) ▁; ▁idx ▁++ ▁) ▁{ ▁if ▁( ▁mask ▁& ▁ssl _ get _ algorithm 2 ▁( ▁s ▁) ▁) ▁{ ▁int ▁hash size ▁= ▁EVP _ MD _ size ▁( ▁md ▁) ▁; ▁if ▁( ▁hash size ▁< ▁0 ▁|| ▁hash size ▁> ▁( ▁int ▁) ▁( ▁sizeof ▁buf ▁- ▁( ▁size _ t ▁) ▁( ▁q ▁- ▁buf ▁) ▁) ▁) ▁{ ▁err ▁= ▁1 ▁; ▁} ▁else ▁{ ▁EVP _ MD _ CTX _ copy _ ex ▁( ▁& ▁ctx ▁, ▁s ▁-> ▁s 3 ▁-> ▁handshake _ dg st ▁[ ▁idx ▁] ▁) ▁; ▁EVP _ Digest Final _ ex ▁( ▁& ▁ctx ▁, ▁q ▁, ▁& ▁i ▁) ▁; ▁if ▁( ▁i ▁!= ▁( ▁unsigned ▁int ▁) ▁hash size ▁) ▁err ▁= ▁1 ▁; ▁q ▁+= ▁i ▁; ▁} ▁} ▁} ▁if ▁( ▁! ▁tls 1_ PR F ▁( ▁ssl _ get _ algorithm 2 ▁( ▁s ▁) ▁, ▁str ▁, ▁slen ▁, ▁buf ▁, ▁( ▁int ▁) ▁( ▁q ▁- ▁buf ▁) ▁, ▁NULL ▁, ▁0 ▁, ▁NULL ▁, ▁0 ▁, ▁NULL ▁, ▁0 ▁, ▁s ▁-> ▁session ▁-> ▁master _ key ▁, ▁s ▁-> ▁session ▁-> ▁master _ key _ length ▁, ▁out ▁, ▁buf 2 ▁, ▁sizeof ▁buf 2 ▁) ▁) ▁err ▁= ▁1 ▁; ▁EVP _ MD _ CTX _ cleanup ▁( ▁& ▁ctx ▁) ▁; ▁if ▁( ▁err ▁) ▁return ▁0 ▁; ▁else ▁return ▁sizeof ▁buf 2 ▁; ▁}	1
▁static ▁int ▁filter _ samples ▁( ▁AVFilter Link ▁* ▁inlink ▁, ▁AVFilter Buffer Ref ▁* ▁ins amples ref ▁) ▁{ ▁A Res ample Context ▁* ▁ares ample ▁= ▁inlink ▁-> ▁dst ▁-> ▁priv ▁; ▁const ▁int ▁n _ in ▁= ▁ins amples ref ▁-> ▁audio ▁-> ▁nb _ samples ▁; ▁int ▁n _ out ▁= ▁FF MAX ▁( ▁n _ in ▁* ▁ares ample ▁-> ▁ratio ▁* ▁2 ▁, ▁1 ▁) ▁; ▁AVFilter Link ▁* ▁const ▁out link ▁= ▁inlink ▁-> ▁dst ▁-> ▁outputs ▁[ ▁0 ▁] ▁; ▁AVFilter Buffer Ref ▁* ▁out samples ref ▁= ▁ff _ get _ audio _ buffer ▁( ▁out link ▁, ▁AV _ PERM _ WRITE ▁, ▁n _ out ▁) ▁; ▁int ▁ret ▁; ▁if ▁( ▁! ▁out samples ref ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁avfilter _ copy _ buffer _ ref _ props ▁( ▁out samples ref ▁, ▁ins amples ref ▁) ▁; ▁out samples ref ▁-> ▁format ▁= ▁out link ▁-> ▁format ▁; ▁out samples ref ▁-> ▁audio ▁-> ▁channel _ layout ▁= ▁out link ▁-> ▁channel _ layout ▁; ▁out samples ref ▁-> ▁audio ▁-> ▁sample _ rate ▁= ▁out link ▁-> ▁sample _ rate ▁; ▁if ▁( ▁ins amples ref ▁-> ▁pts ▁!= ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁int 64_ t ▁in pts ▁= ▁av _ re scale ▁( ▁ins amples ref ▁-> ▁pts ▁, ▁inlink ▁-> ▁time _ base ▁. ▁num ▁* ▁( ▁int 64_ t ▁) ▁out link ▁-> ▁sample _ rate ▁* ▁inlink ▁-> ▁sample _ rate ▁, ▁inlink ▁-> ▁time _ base ▁. ▁den ▁) ▁; ▁int 64_ t ▁out pts ▁= ▁sw r _ next _ pts ▁( ▁ares ample ▁-> ▁sw r ▁, ▁in pts ▁) ▁; ▁ares ample ▁-> ▁next _ pts ▁= ▁out samples ref ▁-> ▁pts ▁= ▁RO UN DED _ DIV ▁( ▁out pts ▁, ▁inlink ▁-> ▁sample _ rate ▁) ▁; ▁} ▁else ▁{ ▁out samples ref ▁-> ▁pts ▁= ▁AV _ NOP TS _ VALUE ▁; ▁} ▁n _ out ▁= ▁sw r _ convert ▁( ▁ares ample ▁-> ▁sw r ▁, ▁out samples ref ▁-> ▁extended _ data ▁, ▁n _ out ▁, ▁( ▁void ▁* ▁) ▁ins amples ref ▁-> ▁extended _ data ▁, ▁n _ in ▁) ▁; ▁if ▁( ▁n _ out ▁<= ▁0 ▁) ▁{ ▁avfilter _ unref _ buffer ▁( ▁out samples ref ▁) ▁; ▁avfilter _ unref _ buffer ▁( ▁ins amples ref ▁) ▁; ▁return ▁0 ▁; ▁} ▁out samples ref ▁-> ▁audio ▁-> ▁nb _ samples ▁= ▁n _ out ▁; ▁ret ▁= ▁ff _ filter _ samples ▁( ▁out link ▁, ▁out samples ref ▁) ▁; ▁ares ample ▁-> ▁req _ full filled ▁= ▁1 ▁; ▁avfilter _ unref _ buffer ▁( ▁ins amples ref ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁frame _ start ▁( ▁Mpeg Enc Context ▁* ▁s ▁) ▁{ ▁int ▁ret ▁; ▁if ▁( ▁s ▁-> ▁pict _ type ▁!= ▁AV _ PICTURE _ TYPE _ B ▁&& ▁s ▁-> ▁last _ picture _ ptr ▁&& ▁s ▁-> ▁last _ picture _ ptr ▁!= ▁s ▁-> ▁next _ picture _ ptr ▁&& ▁s ▁-> ▁last _ picture _ ptr ▁-> ▁f ▁. ▁buf ▁[ ▁0 ▁] ▁) ▁{ ▁ff _ mpeg _ unref _ picture ▁( ▁s ▁, ▁s ▁-> ▁last _ picture _ ptr ▁) ▁; ▁} ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁pict _ type ▁= ▁s ▁-> ▁pict _ type ▁; ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁f ▁. ▁key _ frame ▁= ▁s ▁-> ▁pict _ type ▁== ▁AV _ PICTURE _ TYPE _ I ▁; ▁ff _ mpeg _ unref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁current _ picture ▁) ▁; ▁if ▁( ▁( ▁ret ▁= ▁ff _ mpeg _ ref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁current _ picture ▁, ▁s ▁-> ▁current _ picture _ ptr ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁if ▁( ▁s ▁-> ▁pict _ type ▁!= ▁AV _ PICTURE _ TYPE _ B ▁) ▁{ ▁s ▁-> ▁last _ picture _ ptr ▁= ▁s ▁-> ▁next _ picture _ ptr ▁; ▁if ▁( ▁! ▁s ▁-> ▁dro pp able ▁) ▁s ▁-> ▁next _ picture _ ptr ▁= ▁s ▁-> ▁current _ picture _ ptr ▁; ▁} ▁if ▁( ▁s ▁-> ▁last _ picture _ ptr ▁) ▁{ ▁ff _ mpeg _ unref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁last _ picture ▁) ▁; ▁if ▁( ▁s ▁-> ▁last _ picture _ ptr ▁-> ▁f ▁. ▁buf ▁[ ▁0 ▁] ▁&& ▁( ▁ret ▁= ▁ff _ mpeg _ ref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁last _ picture ▁, ▁s ▁-> ▁last _ picture _ ptr ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁s ▁-> ▁next _ picture _ ptr ▁) ▁{ ▁ff _ mpeg _ unref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁next _ picture ▁) ▁; ▁if ▁( ▁s ▁-> ▁next _ picture _ ptr ▁-> ▁f ▁. ▁buf ▁[ ▁0 ▁] ▁&& ▁( ▁ret ▁= ▁ff _ mpeg _ ref _ picture ▁( ▁s ▁, ▁& ▁s ▁-> ▁next _ picture ▁, ▁s ▁-> ▁next _ picture _ ptr ▁) ▁) ▁< ▁0 ▁) ▁return ▁ret ▁; ▁} ▁if ▁( ▁s ▁-> ▁picture _ structure ▁!= ▁P ICT _ FRAME ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ BOTTOM _ FIELD ▁) ▁{ ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁data ▁[ ▁i ▁] ▁+= ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁linesize ▁[ ▁i ▁] ▁; ▁} ▁s ▁-> ▁current _ picture ▁. ▁f ▁. ▁linesize ▁[ ▁i ▁] ▁*= ▁2 ▁; ▁s ▁-> ▁last _ picture ▁. ▁f ▁. ▁linesize ▁[ ▁i ▁] ▁*= ▁2 ▁; ▁s ▁-> ▁next _ picture ▁. ▁f ▁. ▁linesize ▁[ ▁i ▁] ▁*= ▁2 ▁; ▁} ▁} ▁if ▁( ▁s ▁-> ▁mpeg _ quant ▁|| ▁s ▁-> ▁codec _ id ▁== ▁AV _ CODEC _ ID _ MPEG 2 VIDEO ▁) ▁{ ▁s ▁-> ▁dct _ un quantize _ intra ▁= ▁s ▁-> ▁dct _ un quantize _ mpeg 2_ intra ▁; ▁s ▁-> ▁dct _ un quantize _ inter ▁= ▁s ▁-> ▁dct _ un quantize _ mpeg 2_ inter ▁; ▁} ▁else ▁if ▁( ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 263 ▁|| ▁s ▁-> ▁out _ format ▁== ▁FMT _ H 26 1 ▁) ▁{ ▁s ▁-> ▁dct _ un quantize _ intra ▁= ▁s ▁-> ▁dct _ un quantize _ h 263_ intra ▁; ▁s ▁-> ▁dct _ un quantize _ inter ▁= ▁s ▁-> ▁dct _ un quantize _ h 263_ inter ▁; ▁} ▁else ▁{ ▁s ▁-> ▁dct _ un quantize _ intra ▁= ▁s ▁-> ▁dct _ un quantize _ mpeg 1_ intra ▁; ▁s ▁-> ▁dct _ un quantize _ inter ▁= ▁s ▁-> ▁dct _ un quantize _ mpeg 1_ inter ▁; ▁} ▁if ▁( ▁s ▁-> ▁dct _ error _ sum ▁) ▁{ ▁assert ▁( ▁s ▁-> ▁avctx ▁-> ▁noise _ reduction ▁&& ▁s ▁-> ▁encoding ▁) ▁; ▁update _ noise _ reduction ▁( ▁s ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁int ▁BLAKE 2 s _ Update ▁( ▁BLAKE 2 S _ CTX ▁* ▁c ▁, ▁const ▁void ▁* ▁data ▁, ▁size _ t ▁datalen ▁) ▁{ ▁const ▁uint 8_ t ▁* ▁in ▁= ▁data ▁; ▁size _ t ▁fill ▁; ▁while ▁( ▁datalen ▁> ▁0 ▁) ▁{ ▁fill ▁= ▁sizeof ▁( ▁c ▁-> ▁buf ▁) ▁- ▁c ▁-> ▁buflen ▁; ▁if ▁( ▁datalen ▁> ▁fill ▁) ▁{ ▁memcpy ▁( ▁c ▁-> ▁buf ▁+ ▁c ▁-> ▁buflen ▁, ▁in ▁, ▁fill ▁) ▁; ▁blake 2 s _ increment _ counter ▁( ▁c ▁, ▁BLAKE 2 S _ BLOCK BYTES ▁) ▁; ▁blake 2 s _ compress ▁( ▁c ▁, ▁c ▁-> ▁buf ▁) ▁; ▁c ▁-> ▁buflen ▁= ▁0 ▁; ▁in ▁+= ▁fill ▁; ▁datalen ▁-= ▁fill ▁; ▁} ▁else ▁{ ▁memcpy ▁( ▁c ▁-> ▁buf ▁+ ▁c ▁-> ▁buflen ▁, ▁in ▁, ▁datalen ▁) ▁; ▁c ▁-> ▁buflen ▁+= ▁datalen ▁; ▁return ▁1 ▁; ▁} ▁} ▁return ▁1 ▁; ▁}	1
▁static ▁int ▁sip r _ decode _ frame ▁( ▁AVCodecContext ▁* ▁avctx ▁, ▁void ▁* ▁datap ▁, ▁int ▁* ▁data _ size ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁Sip r Context ▁* ▁ctx ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁const ▁uint 8_ t ▁* ▁buf ▁= ▁avpkt ▁-> ▁data ▁; ▁Sip r Parameters ▁parm ▁; ▁const ▁Sip r Mode Param ▁* ▁mode _ par ▁= ▁& ▁modes ▁[ ▁ctx ▁-> ▁mode ▁] ▁; ▁Get Bit Context ▁gb ▁; ▁float ▁* ▁data ▁= ▁datap ▁; ▁int ▁sub frame _ size ▁= ▁ctx ▁-> ▁mode ▁== ▁MODE _16 k ▁? ▁L _ SUBFR _16 k ▁: ▁SUB FR _ SIZE ▁; ▁int ▁i ▁, ▁out _ size ▁; ▁ctx ▁-> ▁avctx ▁= ▁avctx ▁; ▁if ▁( ▁avpkt ▁-> ▁size ▁< ▁( ▁mode _ par ▁-> ▁bits _ per _ frame ▁>> ▁3 ▁) ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error processing packet : packet size (% d ) too small \ n " ▁, ▁avpkt ▁-> ▁size ▁) ▁; ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁-1 ▁; ▁} ▁out _ size ▁= ▁mode _ par ▁-> ▁frames _ per _ packet ▁* ▁sub frame _ size ▁* ▁mode _ par ▁-> ▁sub frame _ count ▁* ▁av _ get _ bytes _ per _ sample ▁( ▁avctx ▁-> ▁sample _ fmt ▁) ▁; ▁if ▁( ▁* ▁data _ size ▁< ▁out _ size ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error processing packet : output buffer (% d ) too small \ n " ▁, ▁* ▁data _ size ▁) ▁; ▁* ▁data _ size ▁= ▁0 ▁; ▁return ▁-1 ▁; ▁} ▁init _ get _ bits ▁( ▁& ▁gb ▁, ▁buf ▁, ▁mode _ par ▁-> ▁bits _ per _ frame ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁mode _ par ▁-> ▁frames _ per _ packet ▁; ▁i ▁++ ▁) ▁{ ▁decode _ parameters ▁( ▁& ▁parm ▁, ▁& ▁gb ▁, ▁mode _ par ▁) ▁; ▁if ▁( ▁ctx ▁-> ▁mode ▁== ▁MODE _16 k ▁) ▁ff _ sip r _ decode _ frame _16 k ▁( ▁ctx ▁, ▁& ▁parm ▁, ▁data ▁) ▁; ▁else ▁decode _ frame ▁( ▁ctx ▁, ▁& ▁parm ▁, ▁data ▁) ▁; ▁data ▁+= ▁sub frame _ size ▁* ▁mode _ par ▁-> ▁sub frame _ count ▁; ▁} ▁* ▁data _ size ▁= ▁out _ size ▁; ▁return ▁mode _ par ▁-> ▁bits _ per _ frame ▁>> ▁3 ▁; ▁}	0
▁static ▁int ▁as ink _ query _ formats ▁( ▁AVFilter Context ▁* ▁ctx ▁) ▁{ ▁Buffer Sink Context ▁* ▁buf ▁= ▁ctx ▁-> ▁priv ▁; ▁AVFilter Formats ▁* ▁formats ▁= ▁NULL ▁; ▁AVFilter Channel Layout s ▁* ▁layouts ▁= ▁NULL ▁; ▁unsigned ▁i ▁; ▁int ▁ret ▁; ▁CHECK _ LIST _ SIZE ▁( ▁sample _ fmts ▁) ▁CHECK _ LIST _ SIZE ▁( ▁sample _ rates ▁) ▁CHECK _ LIST _ SIZE ▁( ▁channel _ layout s ▁) ▁CHECK _ LIST _ SIZE ▁( ▁channel _ counts ▁) ▁if ▁( ▁buf ▁-> ▁sample _ fmts _ size ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁sample _ fmts ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ format ▁( ▁& ▁formats ▁, ▁buf ▁-> ▁sample _ fmts ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁{ ▁ff _ formats _ unref ▁( ▁& ▁formats ▁) ▁; ▁return ▁ret ▁; ▁} ▁ff _ set _ common _ formats ▁( ▁ctx ▁, ▁formats ▁) ▁; ▁} ▁if ▁( ▁buf ▁-> ▁channel _ layout s _ size ▁|| ▁buf ▁-> ▁channel _ counts _ size ▁|| ▁buf ▁-> ▁all _ channel _ counts ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁channel _ layout s ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ channel _ layout ▁( ▁& ▁layouts ▁, ▁buf ▁-> ▁channel _ layout s ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁{ ▁ff _ channel _ layout s _ unref ▁( ▁& ▁layouts ▁) ▁; ▁return ▁ret ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁channel _ counts ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ channel _ layout ▁( ▁& ▁layouts ▁, ▁FF _ COUNT 2 LAYOUT ▁( ▁buf ▁-> ▁channel _ counts ▁[ ▁i ▁] ▁) ▁) ▁) ▁< ▁0 ▁) ▁{ ▁ff _ channel _ layout s _ unref ▁( ▁& ▁layouts ▁) ▁; ▁return ▁ret ▁; ▁} ▁if ▁( ▁buf ▁-> ▁all _ channel _ counts ▁) ▁{ ▁if ▁( ▁layouts ▁) ▁av _ log ▁( ▁ctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" Conflicting all _ channel _ counts and list in options \ n " ▁) ▁; ▁else ▁if ▁( ▁! ▁( ▁layouts ▁= ▁ff _ all _ channel _ counts ▁( ▁) ▁) ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁ff _ set _ common _ channel _ layout s ▁( ▁ctx ▁, ▁layouts ▁) ▁; ▁} ▁if ▁( ▁buf ▁-> ▁sample _ rates _ size ▁) ▁{ ▁formats ▁= ▁NULL ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁NB _ ITEMS ▁( ▁buf ▁-> ▁sample _ rates ▁) ▁; ▁i ▁++ ▁) ▁if ▁( ▁( ▁ret ▁= ▁ff _ add _ format ▁( ▁& ▁formats ▁, ▁buf ▁-> ▁sample _ rates ▁[ ▁i ▁] ▁) ▁) ▁< ▁0 ▁) ▁{ ▁ff _ formats _ unref ▁( ▁& ▁formats ▁) ▁; ▁return ▁ret ▁; ▁} ▁ff _ set _ common _ sampler ates ▁( ▁ctx ▁, ▁formats ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁split _ field _ ref _ list ▁( ▁Picture ▁* ▁dest ▁, ▁int ▁dest _ len ▁, ▁Picture ▁* ▁src ▁, ▁int ▁src _ len ▁, ▁int ▁parity ▁, ▁int ▁long _ i ▁) ▁{ ▁int ▁i ▁= ▁split _ field _ half _ ref _ list ▁( ▁dest ▁, ▁dest _ len ▁, ▁src ▁, ▁long _ i ▁, ▁parity ▁) ▁; ▁dest ▁+= ▁i ▁; ▁dest _ len ▁-= ▁i ▁; ▁i ▁+= ▁split _ field _ half _ ref _ list ▁( ▁dest ▁, ▁dest _ len ▁, ▁src ▁+ ▁long _ i ▁, ▁src _ len ▁- ▁long _ i ▁, ▁parity ▁) ▁; ▁return ▁i ▁; ▁}	1
▁static ▁int ▁test _ EVP _ PKEY _ check ▁( ▁int ▁i ▁) ▁{ ▁int ▁ret ▁= ▁0 ▁; ▁const ▁unsigned ▁char ▁* ▁p ▁; ▁EVP _ PKEY ▁* ▁pkey ▁= ▁NULL ▁; ▁# ifndef ▁OPENSSL _ NO _ EC ▁EC _ KEY ▁* ▁e ckey ▁= ▁NULL ▁; ▁# endif ▁EVP _ PKEY _ CTX ▁* ▁ctx ▁= ▁NULL ▁; ▁EVP _ PKEY _ CTX ▁* ▁ctx 2 ▁= ▁NULL ▁; ▁const ▁AP K _ DATA ▁* ▁ak ▁= ▁& ▁key check data ▁[ ▁i ▁] ▁; ▁const ▁unsigned ▁char ▁* ▁input ▁= ▁ak ▁-> ▁k der ▁; ▁size _ t ▁input _ len ▁= ▁ak ▁-> ▁size ▁; ▁int ▁expected _ id ▁= ▁ak ▁-> ▁ev pt ype ▁; ▁int ▁expected _ check ▁= ▁ak ▁-> ▁check ▁; ▁int ▁expected _ pub _ check ▁= ▁ak ▁-> ▁pub _ check ▁; ▁int ▁expected _ param _ check ▁= ▁ak ▁-> ▁param _ check ▁; ▁int ▁type ▁= ▁ak ▁-> ▁type ▁; ▁BIO ▁* ▁pubkey ▁= ▁NULL ▁; ▁p ▁= ▁input ▁; ▁switch ▁( ▁type ▁) ▁{ ▁case ▁0 ▁: ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁pkey ▁= ▁d 2 i _ Auto PrivateKey ▁( ▁NULL ▁, ▁& ▁p ▁, ▁input _ len ▁) ▁) ▁|| ▁! ▁TEST _ ptr _ eq ▁( ▁p ▁, ▁input ▁+ ▁input _ len ▁) ▁|| ▁! ▁TEST _ int _ eq ▁( ▁EVP _ PKEY _ id ▁( ▁pkey ▁) ▁, ▁expected _ id ▁) ▁) ▁goto ▁done ▁; ▁break ▁; ▁# ifndef ▁OPENSSL _ NO _ EC ▁case ▁1 ▁: ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁pubkey ▁= ▁BIO _ new _ mem _ buf ▁( ▁input ▁, ▁input _ len ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁e ckey ▁= ▁d 2 i _ EC _ PUB KEY _ bio ▁( ▁pubkey ▁, ▁NULL ▁) ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁pkey ▁= ▁EVP _ PKEY _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁EVP _ PKEY _ assign _ EC _ KEY ▁( ▁pkey ▁, ▁e ckey ▁) ▁) ▁) ▁goto ▁done ▁; ▁break ▁; ▁case ▁2 ▁: ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁e ckey ▁= ▁d 2 i _ EC Parameters ▁( ▁NULL ▁, ▁& ▁p ▁, ▁input _ len ▁) ▁) ▁|| ▁! ▁TEST _ ptr _ eq ▁( ▁p ▁, ▁input ▁+ ▁input _ len ▁) ▁|| ▁! ▁TEST _ ptr ▁( ▁pkey ▁= ▁EVP _ PKEY _ new ▁( ▁) ▁) ▁|| ▁! ▁TEST _ true ▁( ▁EVP _ PKEY _ assign _ EC _ KEY ▁( ▁pkey ▁, ▁e ckey ▁) ▁) ▁) ▁goto ▁done ▁; ▁break ▁; ▁# endif ▁default ▁: ▁return ▁0 ▁; ▁} ▁if ▁( ▁! ▁TEST _ ptr ▁( ▁ctx ▁= ▁EVP _ PKEY _ CTX _ new ▁( ▁pkey ▁, ▁NULL ▁) ▁) ▁) ▁goto ▁done ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁EVP _ PKEY _ check ▁( ▁ctx ▁) ▁, ▁expected _ check ▁) ▁) ▁goto ▁done ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁EVP _ PKEY _ public _ check ▁( ▁ctx ▁) ▁, ▁expected _ pub _ check ▁) ▁) ▁goto ▁done ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁EVP _ PKEY _ param _ check ▁( ▁ctx ▁) ▁, ▁expected _ param _ check ▁) ▁) ▁goto ▁done ▁; ▁ctx 2 ▁= ▁EVP _ PKEY _ CTX _ new _ id ▁( ▁0 x def aced ▁, ▁NULL ▁) ▁; ▁EVP _ PKEY _ up _ ref ▁( ▁pkey ▁) ▁; ▁ctx 2 ▁-> ▁pkey ▁= ▁pkey ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁EVP _ PKEY _ check ▁( ▁ctx 2 ▁) ▁, ▁0 xb eef ▁) ▁) ▁goto ▁done ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁EVP _ PKEY _ public _ check ▁( ▁ctx 2 ▁) ▁, ▁0 xb eef ▁) ▁) ▁goto ▁done ▁; ▁if ▁( ▁! ▁TEST _ int _ eq ▁( ▁EVP _ PKEY _ param _ check ▁( ▁ctx 2 ▁) ▁, ▁0 xb eef ▁) ▁) ▁goto ▁done ▁; ▁ret ▁= ▁1 ▁; ▁done ▁: ▁EVP _ PKEY _ CTX _ free ▁( ▁ctx ▁) ▁; ▁EVP _ PKEY _ CTX _ free ▁( ▁ctx 2 ▁) ▁; ▁EVP _ PKEY _ free ▁( ▁pkey ▁) ▁; ▁BIO _ free ▁( ▁pubkey ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁int ▁ff _ set _ system atic _ pal 2 ▁( ▁uint 32_ t ▁pal ▁[ ▁256 ▁] ▁, ▁enum ▁AV PixelFormat ▁pix _ fmt ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁256 ▁; ▁i ▁++ ▁) ▁{ ▁int ▁r ▁, ▁g ▁, ▁b ▁; ▁switch ▁( ▁pix _ fmt ▁) ▁{ ▁case ▁AV _ PIX _ FMT _ RGB 8 ▁: ▁r ▁= ▁( ▁i ▁>> ▁5 ▁) ▁* ▁36 ▁; ▁g ▁= ▁( ▁( ▁i ▁>> ▁2 ▁) ▁& ▁7 ▁) ▁* ▁36 ▁; ▁b ▁= ▁( ▁i ▁& ▁3 ▁) ▁* ▁85 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ BGR 8 ▁: ▁b ▁= ▁( ▁i ▁>> ▁6 ▁) ▁* ▁85 ▁; ▁g ▁= ▁( ▁( ▁i ▁>> ▁3 ▁) ▁& ▁7 ▁) ▁* ▁36 ▁; ▁r ▁= ▁( ▁i ▁& ▁7 ▁) ▁* ▁36 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ RGB 4_ BYTE ▁: ▁r ▁= ▁( ▁i ▁>> ▁3 ▁) ▁* ▁255 ▁; ▁g ▁= ▁( ▁( ▁i ▁>> ▁1 ▁) ▁& ▁3 ▁) ▁* ▁85 ▁; ▁b ▁= ▁( ▁i ▁& ▁1 ▁) ▁* ▁255 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ BGR 4_ BYTE ▁: ▁b ▁= ▁( ▁i ▁>> ▁3 ▁) ▁* ▁255 ▁; ▁g ▁= ▁( ▁( ▁i ▁>> ▁1 ▁) ▁& ▁3 ▁) ▁* ▁85 ▁; ▁r ▁= ▁( ▁i ▁& ▁1 ▁) ▁* ▁255 ▁; ▁break ▁; ▁case ▁AV _ PIX _ FMT _ GRAY 8 ▁: ▁r ▁= ▁b ▁= ▁g ▁= ▁i ▁; ▁break ▁; ▁default ▁: ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁pal ▁[ ▁i ▁] ▁= ▁b ▁+ ▁( ▁g ▁<< ▁8 ▁) ▁+ ▁( ▁r ▁<< ▁16 ▁) ▁+ ▁( ▁0 xFF U ▁<< ▁24 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁ssl _ cipher _ process _ rule str ▁( ▁const ▁char ▁* ▁rule _ str ▁, ▁C IPHER _ ORDER ▁* ▁* ▁head _ p ▁, ▁C IPHER _ ORDER ▁* ▁* ▁tail _ p ▁, ▁SSL _ CIPHER ▁* ▁* ▁ca _ list ▁) ▁{ ▁unsigned ▁long ▁algorithms ▁, ▁mask ▁, ▁algo _ strength ▁, ▁mask _ strength ▁; ▁const ▁char ▁* ▁l ▁, ▁* ▁start ▁, ▁* ▁buf ▁; ▁int ▁j ▁, ▁multi ▁, ▁found ▁, ▁rule ▁, ▁retval ▁, ▁ok ▁, ▁buflen ▁; ▁unsigned ▁long ▁cipher _ id ▁; ▁char ▁ch ▁; ▁retval ▁= ▁1 ▁; ▁l ▁= ▁rule _ str ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁ch ▁= ▁* ▁l ▁; ▁if ▁( ▁ch ▁== ▁' ▁\0 ▁' ▁) ▁break ▁; ▁if ▁( ▁ch ▁== ▁' ▁' ▁) ▁{ ▁rule ▁= ▁C IPHER _ DEL ▁; ▁l ▁++ ▁; ▁} ▁else ▁if ▁( ▁ch ▁== ▁' ▁' ▁) ▁{ ▁rule ▁= ▁C IPHER _ ORD ▁; ▁l ▁++ ▁; ▁} ▁else ▁if ▁( ▁ch ▁== ▁' ▁' ▁) ▁{ ▁rule ▁= ▁C IPHER _ KILL ▁; ▁l ▁++ ▁; ▁} ▁else ▁if ▁( ▁ch ▁== ▁' ▁' ▁) ▁{ ▁rule ▁= ▁C IPHER _ SPECIAL ▁; ▁l ▁++ ▁; ▁} ▁else ▁{ ▁rule ▁= ▁C IPHER _ ADD ▁; ▁} ▁if ▁( ▁ITEM _ SEP ▁( ▁ch ▁) ▁) ▁{ ▁l ▁++ ▁; ▁continue ▁; ▁} ▁algorithms ▁= ▁mask ▁= ▁algo _ strength ▁= ▁mask _ strength ▁= ▁0 ▁; ▁start ▁= ▁l ▁; ▁for ▁( ▁; ▁; ▁) ▁{ ▁ch ▁= ▁* ▁l ▁; ▁buf ▁= ▁l ▁; ▁buflen ▁= ▁0 ▁; ▁# ifndef ▁CHARSET _ EBCDIC ▁while ▁( ▁( ▁( ▁ch ▁>= ▁' ▁' ▁) ▁&& ▁( ▁ch ▁<= ▁' ▁' ▁) ▁) ▁|| ▁( ▁( ▁ch ▁>= ▁' ▁' ▁) ▁&& ▁( ▁ch ▁<= ▁' ▁' ▁) ▁) ▁|| ▁( ▁( ▁ch ▁>= ▁' ▁' ▁) ▁&& ▁( ▁ch ▁<= ▁' ▁' ▁) ▁) ▁|| ▁( ▁ch ▁== ▁' ▁' ▁) ▁) ▁# else ▁while ▁( ▁isalnum ▁( ▁ch ▁) ▁|| ▁( ▁ch ▁== ▁' ▁' ▁) ▁) ▁# endif ▁{ ▁ch ▁= ▁* ▁( ▁++ ▁l ▁) ▁; ▁buflen ▁++ ▁; ▁} ▁if ▁( ▁buflen ▁== ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CIPHER _ PROCESS _ R ULES TR ▁, ▁SSL _ R _ INVALID _ COMMAND ▁) ▁; ▁retval ▁= ▁found ▁= ▁0 ▁; ▁l ▁++ ▁; ▁break ▁; ▁} ▁if ▁( ▁rule ▁== ▁C IPHER _ SPECIAL ▁) ▁{ ▁found ▁= ▁0 ▁; ▁break ▁; ▁} ▁if ▁( ▁ch ▁== ▁' ▁' ▁) ▁{ ▁multi ▁= ▁1 ▁; ▁l ▁++ ▁; ▁} ▁else ▁multi ▁= ▁0 ▁; ▁j ▁= ▁found ▁= ▁0 ▁; ▁cipher _ id ▁= ▁0 ▁; ▁while ▁( ▁ca _ list ▁[ ▁j ▁] ▁) ▁{ ▁if ▁( ▁! ▁strncmp ▁( ▁buf ▁, ▁ca _ list ▁[ ▁j ▁] ▁-> ▁name ▁, ▁buflen ▁) ▁&& ▁( ▁ca _ list ▁[ ▁j ▁] ▁-> ▁name ▁[ ▁buflen ▁] ▁== ▁' ▁\0 ▁' ▁) ▁) ▁{ ▁found ▁= ▁1 ▁; ▁break ▁; ▁} ▁else ▁j ▁++ ▁; ▁} ▁if ▁( ▁! ▁found ▁) ▁break ▁; ▁if ▁( ▁ca _ list ▁[ ▁j ▁] ▁-> ▁valid ▁) ▁{ ▁cipher _ id ▁= ▁ca _ list ▁[ ▁j ▁] ▁-> ▁id ▁; ▁break ▁; ▁} ▁algorithms ▁= ▁( ▁algorithms ▁& ▁ ~ ▁ca _ list ▁[ ▁j ▁] ▁-> ▁mask ▁) ▁| ▁( ▁ca _ list ▁[ ▁j ▁] ▁-> ▁algorithms ▁& ▁ ~ ▁mask ▁) ▁| ▁( ▁algorithms ▁& ▁ca _ list ▁[ ▁j ▁] ▁-> ▁algorithms ▁) ▁; ▁mask ▁|= ▁ca _ list ▁[ ▁j ▁] ▁-> ▁mask ▁; ▁algo _ strength ▁= ▁( ▁algo _ strength ▁& ▁ ~ ▁ca _ list ▁[ ▁j ▁] ▁-> ▁mask _ strength ▁) ▁| ▁( ▁ca _ list ▁[ ▁j ▁] ▁-> ▁algo _ strength ▁& ▁ ~ ▁mask _ strength ▁) ▁| ▁( ▁algo _ strength ▁& ▁ca _ list ▁[ ▁j ▁] ▁-> ▁algo _ strength ▁) ▁; ▁mask _ strength ▁|= ▁ca _ list ▁[ ▁j ▁] ▁-> ▁mask _ strength ▁; ▁if ▁( ▁! ▁multi ▁) ▁break ▁; ▁} ▁if ▁( ▁rule ▁== ▁C IPHER _ SPECIAL ▁) ▁{ ▁ok ▁= ▁0 ▁; ▁if ▁( ▁( ▁buflen ▁== ▁8 ▁) ▁&& ▁! ▁strncmp ▁( ▁buf ▁, ▁" STR ENGTH " ▁, ▁8 ▁) ▁) ▁ok ▁= ▁ssl _ cipher _ strength _ sort ▁( ▁head _ p ▁, ▁tail _ p ▁) ▁; ▁else ▁SSL err ▁( ▁SSL _ F _ SSL _ CIPHER _ PROCESS _ R ULES TR ▁, ▁SSL _ R _ INVALID _ COMMAND ▁) ▁; ▁if ▁( ▁ok ▁== ▁0 ▁) ▁retval ▁= ▁0 ▁; ▁while ▁( ▁( ▁* ▁l ▁!= ▁' ▁\0 ▁' ▁) ▁&& ▁ITEM _ SEP ▁( ▁* ▁l ▁) ▁) ▁l ▁++ ▁; ▁} ▁else ▁if ▁( ▁found ▁) ▁{ ▁ssl _ cipher _ apply _ rule ▁( ▁cipher _ id ▁, ▁algorithms ▁, ▁mask ▁, ▁algo _ strength ▁, ▁mask _ strength ▁, ▁rule ▁, ▁-1 ▁, ▁head _ p ▁, ▁tail _ p ▁) ▁; ▁} ▁else ▁{ ▁while ▁( ▁( ▁* ▁l ▁!= ▁' ▁\0 ▁' ▁) ▁&& ▁ITEM _ SEP ▁( ▁* ▁l ▁) ▁) ▁l ▁++ ▁; ▁} ▁if ▁( ▁* ▁l ▁== ▁' ▁\0 ▁' ▁) ▁break ▁; ▁} ▁return ▁( ▁retval ▁) ▁; ▁}	1
▁static ▁int ▁create _ filter ▁( ▁AVFilter Context ▁* ▁* ▁filt _ ctx ▁, ▁AVFilter Graph ▁* ▁ctx ▁, ▁int ▁index ▁, ▁const ▁char ▁* ▁filt _ name ▁, ▁const ▁char ▁* ▁args ▁, ▁void ▁* ▁log _ ctx ▁) ▁{ ▁AVFilter ▁* ▁filt ▁; ▁char ▁inst _ name ▁[ ▁30 ▁] ▁; ▁char ▁* ▁tmp _ args ▁= ▁NULL ▁; ▁int ▁ret ▁; ▁snprintf ▁( ▁inst _ name ▁, ▁sizeof ▁( ▁inst _ name ▁) ▁, ▁" Parsed _% s _% d " ▁, ▁filt _ name ▁, ▁index ▁) ▁; ▁filt ▁= ▁avfilter _ get _ by _ name ▁( ▁filt _ name ▁) ▁; ▁if ▁( ▁! ▁filt ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" N os uch filter :' % s '\ n " ▁, ▁filt _ name ▁) ▁; ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁} ▁* ▁filt _ ctx ▁= ▁avfilter _ graph _ alloc _ filter ▁( ▁ctx ▁, ▁filt ▁, ▁inst _ name ▁) ▁; ▁if ▁( ▁! ▁* ▁filt _ ctx ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error cre ating filter ' % s '\ n " ▁, ▁filt _ name ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁} ▁if ▁( ▁! ▁strcmp ▁( ▁filt _ name ▁, ▁" scale " ▁) ▁&& ▁args ▁&& ▁! ▁strstr ▁( ▁args ▁, ▁" flags " ▁) ▁&& ▁ctx ▁-> ▁scale _ s ws _ opts ▁) ▁{ ▁tmp _ args ▁= ▁av _ asprintf ▁( ▁"% s :% s " ▁, ▁args ▁, ▁ctx ▁-> ▁scale _ s ws _ opts ▁) ▁; ▁if ▁( ▁! ▁tmp _ args ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁args ▁= ▁tmp _ args ▁; ▁} ▁ret ▁= ▁avfilter _ init _ str ▁( ▁* ▁filt _ ctx ▁, ▁args ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Error init ializing filter ' % s '" ▁, ▁filt _ name ▁) ▁; ▁if ▁( ▁args ▁) ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" with args ' % s '" ▁, ▁args ▁) ▁; ▁av _ log ▁( ▁log _ ctx ▁, ▁AV _ LOG _ ERROR ▁, ▁"\ n " ▁) ▁; ▁} ▁av _ free ▁( ▁tmp _ args ▁) ▁; ▁return ▁ret ▁; ▁}	0
▁static ▁int ▁submit _ packet ▁( ▁Per ThreadContext ▁* ▁p ▁, ▁AVCodecContext ▁* ▁user _ av ctx ▁, ▁AVPacket ▁* ▁avpkt ▁) ▁{ ▁Frame ThreadContext ▁* ▁fctx ▁= ▁p ▁-> ▁parent ▁; ▁Per ThreadContext ▁* ▁prev _ thread ▁= ▁fctx ▁-> ▁prev _ thread ▁; ▁const ▁AVCodec ▁* ▁codec ▁= ▁p ▁-> ▁avctx ▁-> ▁codec ▁; ▁int ▁ret ▁; ▁if ▁( ▁! ▁avpkt ▁-> ▁size ▁&& ▁! ▁( ▁codec ▁-> ▁capabilities ▁& ▁AV _ CODEC _ CAP _ DELAY ▁) ▁) ▁return ▁0 ▁; ▁pthread _ mutex _ lock ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁ret ▁= ▁update _ context _ from _ user ▁( ▁p ▁-> ▁avctx ▁, ▁user _ av ctx ▁) ▁; ▁if ▁( ▁ret ▁) ▁{ ▁pthread _ mutex _ unlock ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁return ▁ret ▁; ▁} ▁release _ delayed _ buffers ▁( ▁p ▁) ▁; ▁if ▁( ▁prev _ thread ▁) ▁{ ▁int ▁err ▁; ▁if ▁( ▁atomic _ load ▁( ▁& ▁prev _ thread ▁-> ▁state ▁) ▁== ▁STATE _ SETTING _ UP ▁) ▁{ ▁pthread _ mutex _ lock ▁( ▁& ▁prev _ thread ▁-> ▁progress _ mutex ▁) ▁; ▁while ▁( ▁atomic _ load ▁( ▁& ▁prev _ thread ▁-> ▁state ▁) ▁== ▁STATE _ SETTING _ UP ▁) ▁pthread _ cond _ wait ▁( ▁& ▁prev _ thread ▁-> ▁progress _ cond ▁, ▁& ▁prev _ thread ▁-> ▁progress _ mutex ▁) ▁; ▁pthread _ mutex _ unlock ▁( ▁& ▁prev _ thread ▁-> ▁progress _ mutex ▁) ▁; ▁} ▁err ▁= ▁update _ context _ from _ thread ▁( ▁p ▁-> ▁avctx ▁, ▁prev _ thread ▁-> ▁avctx ▁, ▁0 ▁) ▁; ▁if ▁( ▁err ▁) ▁{ ▁pthread _ mutex _ unlock ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁return ▁err ▁; ▁} ▁} ▁av _ packet _ unref ▁( ▁& ▁p ▁-> ▁avpkt ▁) ▁; ▁ret ▁= ▁av _ packet _ ref ▁( ▁& ▁p ▁-> ▁avpkt ▁, ▁avpkt ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁pthread _ mutex _ unlock ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁av _ log ▁( ▁p ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" av _ packet _ ref () failed in submit _ packet ()\ n " ▁) ▁; ▁return ▁ret ▁; ▁} ▁atomic _ store ▁( ▁& ▁p ▁-> ▁state ▁, ▁STATE _ SETTING _ UP ▁) ▁; ▁pthread _ cond _ signal ▁( ▁& ▁p ▁-> ▁input _ cond ▁) ▁; ▁pthread _ mutex _ unlock ▁( ▁& ▁p ▁-> ▁mutex ▁) ▁; ▁if ▁( ▁! ▁p ▁-> ▁avctx ▁-> ▁thread _ safe _ callbacks ▁&& ▁( ▁p ▁-> ▁avctx ▁-> ▁get _ format ▁!= ▁avcodec _ default _ get _ format ▁|| ▁p ▁-> ▁avctx ▁-> ▁get _ buffer 2 ▁!= ▁avcodec _ default _ get _ buffer 2 ▁) ▁) ▁{ ▁while ▁( ▁atomic _ load ▁( ▁& ▁p ▁-> ▁state ▁) ▁!= ▁STATE _ SETUP _ FINISHED ▁&& ▁atomic _ load ▁( ▁& ▁p ▁-> ▁state ▁) ▁!= ▁STATE _ INPUT _ READY ▁) ▁{ ▁int ▁call _ done ▁= ▁1 ▁; ▁pthread _ mutex _ lock ▁( ▁& ▁p ▁-> ▁progress _ mutex ▁) ▁; ▁while ▁( ▁atomic _ load ▁( ▁& ▁p ▁-> ▁state ▁) ▁== ▁STATE _ SETTING _ UP ▁) ▁pthread _ cond _ wait ▁( ▁& ▁p ▁-> ▁progress _ cond ▁, ▁& ▁p ▁-> ▁progress _ mutex ▁) ▁; ▁switch ▁( ▁atomic _ load _ explicit ▁( ▁& ▁p ▁-> ▁state ▁, ▁memory _ order _ acquire ▁) ▁) ▁{ ▁case ▁STATE _ GET _ BUFFER ▁: ▁p ▁-> ▁result ▁= ▁ff _ get _ buffer ▁( ▁p ▁-> ▁avctx ▁, ▁p ▁-> ▁requested _ frame ▁, ▁p ▁-> ▁requested _ flags ▁) ▁; ▁break ▁; ▁case ▁STATE _ GET _ FORMAT ▁: ▁p ▁-> ▁result _ format ▁= ▁ff _ get _ format ▁( ▁p ▁-> ▁avctx ▁, ▁p ▁-> ▁available _ formats ▁) ▁; ▁break ▁; ▁default ▁: ▁call _ done ▁= ▁0 ▁; ▁break ▁; ▁} ▁if ▁( ▁call _ done ▁) ▁{ ▁atomic _ store ▁( ▁& ▁p ▁-> ▁state ▁, ▁STATE _ SETTING _ UP ▁) ▁; ▁pthread _ cond _ signal ▁( ▁& ▁p ▁-> ▁progress _ cond ▁) ▁; ▁} ▁pthread _ mutex _ unlock ▁( ▁& ▁p ▁-> ▁progress _ mutex ▁) ▁; ▁} ▁} ▁fctx ▁-> ▁prev _ thread ▁= ▁p ▁; ▁fctx ▁-> ▁next _ de coding ▁++ ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁queue _ attached _ p ict ures ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁int ▁i ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁disp osition ▁& ▁AV _ DIS POSITION _ AT TACHED _ PIC ▁&& ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁discard ▁< ▁AV DISCARD _ ALL ▁) ▁{ ▁AVPacket ▁copy ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁attached _ pic ▁; ▁copy ▁. ▁buf ▁= ▁av _ buffer _ ref ▁( ▁copy ▁. ▁buf ▁) ▁; ▁if ▁( ▁! ▁copy ▁. ▁buf ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁add _ to _ pkt buf ▁( ▁& ▁s ▁-> ▁raw _ packet _ buffer ▁, ▁& ▁copy ▁, ▁& ▁s ▁-> ▁raw _ packet _ buffer _ end ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁Pix ar Log Encode ▁( ▁TIFF ▁* ▁tif ▁, ▁uint 8 ▁* ▁bp ▁, ▁tm size _ t ▁cc ▁, ▁uint 16 ▁s ▁) ▁{ ▁static ▁const ▁char ▁module ▁[ ▁] ▁= ▁" Pix ar Log Encode " ▁; ▁TIFF Directory ▁* ▁td ▁= ▁& ▁tif ▁-> ▁tif _ dir ▁; ▁Pix ar Log State ▁* ▁sp ▁= ▁Encoder State ▁( ▁tif ▁) ▁; ▁tm size _ t ▁i ▁; ▁tm size _ t ▁n ▁; ▁int ▁l len ▁; ▁unsigned ▁short ▁* ▁up ▁; ▁( ▁void ▁) ▁s ▁; ▁switch ▁( ▁sp ▁-> ▁user _ data fmt ▁) ▁{ ▁case ▁PIX AR LOG DATA FMT _ FLOAT ▁: ▁n ▁= ▁cc ▁/ ▁sizeof ▁( ▁float ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _16 BIT ▁: ▁case ▁PIX AR LOG DATA FMT _12 BIT PIC IO ▁: ▁case ▁PIX AR LOG DATA FMT _11 BIT LOG ▁: ▁n ▁= ▁cc ▁/ ▁sizeof ▁( ▁uint 16 ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _8 BIT ▁: ▁case ▁PIX AR LOG DATA FMT _8 BIT AB GR ▁: ▁n ▁= ▁cc ▁; ▁break ▁; ▁default ▁: ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁"% db it input not supported in Pix ar Log " ▁, ▁td ▁-> ▁td _ bits pers ample ▁) ▁; ▁return ▁0 ▁; ▁} ▁l len ▁= ▁sp ▁-> ▁stride ▁* ▁td ▁-> ▁td _ image width ▁; ▁if ▁( ▁n ▁> ▁( ▁( ▁tm size _ t ▁) ▁td ▁-> ▁td _ rows per strip ▁* ▁l len ▁) ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" T oom any input bytes provided " ▁) ▁; ▁return ▁0 ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁, ▁up ▁= ▁sp ▁-> ▁tbuf ▁; ▁i ▁< ▁n ▁; ▁i ▁+= ▁l len ▁, ▁up ▁+= ▁l len ▁) ▁{ ▁switch ▁( ▁sp ▁-> ▁user _ data fmt ▁) ▁{ ▁case ▁PIX AR LOG DATA FMT _ FLOAT ▁: ▁horizontal Difference F ▁( ▁( ▁float ▁* ▁) ▁bp ▁, ▁l len ▁, ▁sp ▁-> ▁stride ▁, ▁up ▁, ▁sp ▁-> ▁From LT 2 ▁) ▁; ▁bp ▁+= ▁l len ▁* ▁sizeof ▁( ▁float ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _16 BIT ▁: ▁horizontal Difference 16 ▁( ▁( ▁uint 16 ▁* ▁) ▁bp ▁, ▁l len ▁, ▁sp ▁-> ▁stride ▁, ▁up ▁, ▁sp ▁-> ▁From 14 ▁) ▁; ▁bp ▁+= ▁l len ▁* ▁sizeof ▁( ▁uint 16 ▁) ▁; ▁break ▁; ▁case ▁PIX AR LOG DATA FMT _8 BIT ▁: ▁horizontal Difference 8 ▁( ▁( ▁unsigned ▁char ▁* ▁) ▁bp ▁, ▁l len ▁, ▁sp ▁-> ▁stride ▁, ▁up ▁, ▁sp ▁-> ▁From 8 ▁) ▁; ▁bp ▁+= ▁l len ▁* ▁sizeof ▁( ▁unsigned ▁char ▁) ▁; ▁break ▁; ▁default ▁: ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁"% db it input not supported in Pix ar Log " ▁, ▁td ▁-> ▁td _ bits pers ample ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁sp ▁-> ▁stream ▁. ▁next _ in ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁sp ▁-> ▁tbuf ▁; ▁assert ▁( ▁sizeof ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁) ▁== ▁4 ▁) ▁; ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁= ▁( ▁uInt ▁) ▁( ▁n ▁* ▁sizeof ▁( ▁uint 16 ▁) ▁) ▁; ▁if ▁( ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁/ ▁sizeof ▁( ▁uint 16 ▁) ▁) ▁!= ▁( ▁uInt ▁) ▁n ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Z Lib cannot de al with buffer sth iss ize " ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁do ▁{ ▁if ▁( ▁deflate ▁( ▁& ▁sp ▁-> ▁stream ▁, ▁Z _ NO _ FLUSH ▁) ▁!= ▁Z _ OK ▁) ▁{ ▁TIFF Error Ext ▁( ▁tif ▁-> ▁tif _ clientdata ▁, ▁module ▁, ▁" Encoder error :% s " ▁, ▁sp ▁-> ▁stream ▁. ▁msg ▁? ▁sp ▁-> ▁stream ▁. ▁msg ▁: ▁"( null )" ▁) ▁; ▁return ▁( ▁0 ▁) ▁; ▁} ▁if ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ out ▁== ▁0 ▁) ▁{ ▁tif ▁-> ▁tif _ raw cc ▁= ▁tif ▁-> ▁tif _ raw datas ize ▁; ▁TI FFF lush Data 1 ▁( ▁tif ▁) ▁; ▁sp ▁-> ▁stream ▁. ▁next _ out ▁= ▁tif ▁-> ▁tif _ raw data ▁; ▁sp ▁-> ▁stream ▁. ▁avail _ out ▁= ▁( ▁uInt ▁) ▁tif ▁-> ▁tif _ raw datas ize ▁; ▁} ▁} ▁while ▁( ▁sp ▁-> ▁stream ▁. ▁avail _ in ▁> ▁0 ▁) ▁; ▁return ▁( ▁1 ▁) ▁; ▁}	0
▁void ▁ff _ ri ff _ write _ info _ tag ▁( ▁AVIO Context ▁* ▁pb ▁, ▁const ▁char ▁* ▁tag ▁, ▁const ▁char ▁* ▁str ▁) ▁{ ▁int ▁len ▁= ▁strlen ▁( ▁str ▁) ▁; ▁if ▁( ▁len ▁> ▁0 ▁) ▁{ ▁len ▁++ ▁; ▁ff io _ w four cc ▁( ▁pb ▁, ▁tag ▁) ▁; ▁avio _ wl 32 ▁( ▁pb ▁, ▁len ▁) ▁; ▁avio _ put _ str ▁( ▁pb ▁, ▁str ▁) ▁; ▁if ▁( ▁len ▁& ▁1 ▁) ▁avio _ w 8 ▁( ▁pb ▁, ▁0 ▁) ▁; ▁} ▁}	1
▁int ▁ff _ ass _ add _ rect ▁( ▁AV Subtitle ▁* ▁sub ▁, ▁const ▁char ▁* ▁dialog ▁, ▁int ▁ts _ start ▁, ▁int ▁ts _ end ▁, ▁int ▁raw ▁) ▁{ ▁int ▁len ▁= ▁0 ▁, ▁dlen ▁, ▁duration ▁= ▁ts _ end ▁- ▁ts _ start ▁; ▁char ▁s _ start ▁[ ▁16 ▁] ▁, ▁s _ end ▁[ ▁16 ▁] ▁, ▁header ▁[ ▁48 ▁] ▁= ▁{ ▁0 ▁} ▁; ▁AV Subtitle Rect ▁* ▁* ▁rects ▁; ▁if ▁( ▁! ▁raw ▁) ▁{ ▁ts _ to _ string ▁( ▁s _ start ▁, ▁sizeof ▁( ▁s _ start ▁) ▁, ▁ts _ start ▁) ▁; ▁ts _ to _ string ▁( ▁s _ end ▁, ▁sizeof ▁( ▁s _ end ▁) ▁, ▁ts _ end ▁) ▁; ▁len ▁= ▁snprintf ▁( ▁header ▁, ▁sizeof ▁( ▁header ▁) ▁, ▁" Dialog ue : 0,% s ,% s ," ▁, ▁s _ start ▁, ▁s _ end ▁) ▁; ▁} ▁dlen ▁= ▁strcspn ▁( ▁dialog ▁, ▁"\ n " ▁) ▁; ▁dlen ▁+= ▁dialog ▁[ ▁dlen ▁] ▁== ▁' ▁\ n ▁' ▁; ▁rects ▁= ▁av _ realloc ▁( ▁sub ▁-> ▁rects ▁, ▁( ▁sub ▁-> ▁num _ rect s ▁+ ▁1 ▁) ▁* ▁sizeof ▁( ▁* ▁sub ▁-> ▁rects ▁) ▁) ▁; ▁if ▁( ▁! ▁rects ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁sub ▁-> ▁rects ▁= ▁rects ▁; ▁sub ▁-> ▁end _ display _ time ▁= ▁FF MAX ▁( ▁sub ▁-> ▁end _ display _ time ▁, ▁10 ▁* ▁duration ▁) ▁; ▁rects ▁[ ▁sub ▁-> ▁num _ rect s ▁] ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁* ▁rects ▁[ ▁0 ▁] ▁) ▁) ▁; ▁rects ▁[ ▁sub ▁-> ▁num _ rect s ▁] ▁-> ▁type ▁= ▁SUB TITLE _ ASS ▁; ▁rects ▁[ ▁sub ▁-> ▁num _ rect s ▁] ▁-> ▁ass ▁= ▁av _ malloc ▁( ▁len ▁+ ▁dlen ▁+ ▁1 ▁) ▁; ▁strcpy ▁( ▁rects ▁[ ▁sub ▁-> ▁num _ rect s ▁] ▁-> ▁ass ▁, ▁header ▁) ▁; ▁av _ strlcpy ▁( ▁rects ▁[ ▁sub ▁-> ▁num _ rect s ▁] ▁-> ▁ass ▁+ ▁len ▁, ▁dialog ▁, ▁dlen ▁+ ▁1 ▁) ▁; ▁sub ▁-> ▁num _ rect s ▁++ ▁; ▁return ▁dlen ▁; ▁}	1
▁X 509_ NAME ▁* ▁parse _ name ▁( ▁char ▁* ▁subject ▁, ▁long ▁chtype ▁, ▁int ▁mult ird n ▁) ▁{ ▁size _ t ▁buflen ▁= ▁strlen ▁( ▁subject ▁) ▁+ ▁1 ▁; ▁char ▁* ▁buf ▁= ▁OPENSSL _ malloc ▁( ▁buflen ▁) ▁; ▁size _ t ▁max _ ne ▁= ▁buflen ▁/ ▁2 ▁+ ▁1 ▁; ▁char ▁* ▁* ▁ne _ types ▁= ▁OPENSSL _ malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁char ▁* ▁* ▁ne _ values ▁= ▁OPENSSL _ malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁char ▁* ▁) ▁) ▁; ▁int ▁* ▁m val ▁= ▁OPENSSL _ malloc ▁( ▁max _ ne ▁* ▁sizeof ▁( ▁int ▁) ▁) ▁; ▁char ▁* ▁sp ▁= ▁subject ▁, ▁* ▁bp ▁= ▁buf ▁; ▁int ▁i ▁, ▁ne _ num ▁= ▁0 ▁; ▁X 509_ NAME ▁* ▁n ▁= ▁NULL ▁; ▁int ▁nid ▁; ▁if ▁( ▁! ▁buf ▁|| ▁! ▁ne _ types ▁|| ▁! ▁ne _ values ▁|| ▁! ▁m val ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" malloc error \ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁if ▁( ▁* ▁subject ▁!= ▁' ▁' ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Subject does not start with ' / ' .\ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁sp ▁++ ▁; ▁m val ▁[ ▁ne _ num ▁] ▁= ▁0 ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁ne _ types ▁[ ▁ne _ num ▁] ▁= ▁bp ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁if ▁( ▁* ▁sp ▁== ▁' ▁\\ ▁' ▁) ▁{ ▁if ▁( ▁* ▁++ ▁sp ▁) ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" escape character at end of string \ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁) ▁{ ▁sp ▁++ ▁; ▁* ▁bp ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁break ▁; ▁} ▁else ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁} ▁if ▁( ▁! ▁* ▁sp ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" end of string en countered while processing typeof subject name element #% d \ n " ▁, ▁ne _ num ▁) ▁; ▁goto ▁error ▁; ▁} ▁ne _ values ▁[ ▁ne _ num ▁] ▁= ▁bp ▁; ▁while ▁( ▁* ▁sp ▁) ▁{ ▁if ▁( ▁* ▁sp ▁== ▁' ▁\\ ▁' ▁) ▁{ ▁if ▁( ▁* ▁++ ▁sp ▁) ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁else ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" escape character at end of string \ n " ▁) ▁; ▁goto ▁error ▁; ▁} ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁) ▁{ ▁sp ▁++ ▁; ▁m val ▁[ ▁ne _ num ▁+ ▁1 ▁] ▁= ▁0 ▁; ▁break ▁; ▁} ▁else ▁if ▁( ▁* ▁sp ▁== ▁' ▁' ▁&& ▁mult ird n ▁) ▁{ ▁sp ▁++ ▁; ▁m val ▁[ ▁ne _ num ▁+ ▁1 ▁] ▁= ▁-1 ▁; ▁break ▁; ▁} ▁else ▁* ▁bp ▁++ ▁= ▁* ▁sp ▁++ ▁; ▁} ▁* ▁bp ▁++ ▁= ▁' ▁\0 ▁' ▁; ▁ne _ num ▁++ ▁; ▁} ▁if ▁( ▁! ▁( ▁n ▁= ▁X 509_ NAME _ new ▁( ▁) ▁) ▁) ▁goto ▁error ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁ne _ num ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁( ▁nid ▁= ▁OBJ _ txt 2 nid ▁( ▁ne _ types ▁[ ▁i ▁] ▁) ▁) ▁== ▁NID _ undef ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" Subject Attribute % sh as no known NID , skipped \ n " ▁, ▁ne _ types ▁[ ▁i ▁] ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁! ▁* ▁ne _ values ▁[ ▁i ▁] ▁) ▁{ ▁BIO _ printf ▁( ▁bio _ err ▁, ▁" No value provide df or Subject Attribute % s , skipped \ n " ▁, ▁ne _ types ▁[ ▁i ▁] ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁! ▁X 509_ NAME _ add _ entry _ by _ NID ▁( ▁n ▁, ▁nid ▁, ▁chtype ▁, ▁( ▁unsigned ▁char ▁* ▁) ▁ne _ values ▁[ ▁i ▁] ▁, ▁-1 ▁, ▁-1 ▁, ▁m val ▁[ ▁i ▁] ▁) ▁) ▁goto ▁error ▁; ▁} ▁OPENSSL _ free ▁( ▁ne _ values ▁) ▁; ▁OPENSSL _ free ▁( ▁ne _ types ▁) ▁; ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁OPENSSL _ free ▁( ▁m val ▁) ▁; ▁return ▁n ▁; ▁error ▁: ▁X 509_ NAME _ free ▁( ▁n ▁) ▁; ▁if ▁( ▁ne _ values ▁) ▁OPENSSL _ free ▁( ▁ne _ values ▁) ▁; ▁if ▁( ▁ne _ types ▁) ▁OPENSSL _ free ▁( ▁ne _ types ▁) ▁; ▁if ▁( ▁m val ▁) ▁OPENSSL _ free ▁( ▁m val ▁) ▁; ▁if ▁( ▁buf ▁) ▁OPENSSL _ free ▁( ▁buf ▁) ▁; ▁return ▁NULL ▁; ▁}	0
▁int ▁ff _ h 264_ fill _ default _ ref _ list ▁( ▁H 264 Context ▁* ▁h ▁) ▁{ ▁Mpeg Enc Context ▁* ▁const ▁s ▁= ▁& ▁h ▁-> ▁s ▁; ▁int ▁i ▁, ▁len ▁; ▁if ▁( ▁h ▁-> ▁slice _ type _ nos ▁== ▁FF _ B _ TYPE ▁) ▁{ ▁Picture ▁* ▁sorted ▁[ ▁32 ▁] ▁; ▁int ▁cur _ p oc ▁, ▁list ▁; ▁int ▁lens ▁[ ▁2 ▁] ▁; ▁if ▁( ▁FIELD _ PICTURE ▁) ▁cur _ p oc ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁field _ p oc ▁[ ▁s ▁-> ▁picture _ structure ▁== ▁P ICT _ BOTTOM _ FIELD ▁] ▁; ▁else ▁cur _ p oc ▁= ▁s ▁-> ▁current _ picture _ ptr ▁-> ▁p oc ▁; ▁for ▁( ▁list ▁= ▁0 ▁; ▁list ▁< ▁2 ▁; ▁list ▁++ ▁) ▁{ ▁len ▁= ▁add _ sorted ▁( ▁sorted ▁, ▁h ▁-> ▁short _ ref ▁, ▁h ▁-> ▁short _ ref _ count ▁, ▁cur _ p oc ▁, ▁1 ▁ ^ ▁list ▁) ▁; ▁len ▁+= ▁add _ sorted ▁( ▁sorted ▁+ ▁len ▁, ▁h ▁-> ▁short _ ref ▁, ▁h ▁-> ▁short _ ref _ count ▁, ▁cur _ p oc ▁, ▁0 ▁ ^ ▁list ▁) ▁; ▁assert ▁( ▁len ▁<= ▁32 ▁) ▁; ▁len ▁= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁list ▁] ▁, ▁sorted ▁, ▁len ▁, ▁0 ▁, ▁s ▁-> ▁picture _ structure ▁) ▁; ▁len ▁+= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁list ▁] ▁+ ▁len ▁, ▁h ▁-> ▁long _ ref ▁, ▁16 ▁, ▁1 ▁, ▁s ▁-> ▁picture _ structure ▁) ▁; ▁assert ▁( ▁len ▁<= ▁32 ▁) ▁; ▁if ▁( ▁len ▁< ▁h ▁-> ▁ref _ count ▁[ ▁list ▁] ▁) ▁memset ▁( ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁list ▁] ▁[ ▁len ▁] ▁, ▁0 ▁, ▁sizeof ▁( ▁Picture ▁) ▁* ▁( ▁h ▁-> ▁ref _ count ▁[ ▁list ▁] ▁- ▁len ▁) ▁) ▁; ▁lens ▁[ ▁list ▁] ▁= ▁len ▁; ▁} ▁if ▁( ▁lens ▁[ ▁0 ▁] ▁== ▁lens ▁[ ▁1 ▁] ▁&& ▁lens ▁[ ▁1 ▁] ▁> ▁1 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁data ▁[ ▁0 ▁] ▁== ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁data ▁[ ▁0 ▁] ▁&& ▁i ▁< ▁lens ▁[ ▁0 ▁] ▁; ▁i ▁++ ▁) ▁; ▁if ▁( ▁i ▁== ▁lens ▁[ ▁0 ▁] ▁) ▁F FS W AP ▁( ▁Picture ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁) ▁; ▁} ▁} ▁else ▁{ ▁len ▁= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁, ▁h ▁-> ▁short _ ref ▁, ▁h ▁-> ▁short _ ref _ count ▁, ▁0 ▁, ▁s ▁-> ▁picture _ structure ▁) ▁; ▁len ▁+= ▁build _ def _ list ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁+ ▁len ▁, ▁h ▁-> ▁long _ ref ▁, ▁16 ▁, ▁1 ▁, ▁s ▁-> ▁picture _ structure ▁) ▁; ▁assert ▁( ▁len ▁<= ▁32 ▁) ▁; ▁if ▁( ▁len ▁< ▁h ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁) ▁memset ▁( ▁& ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁len ▁] ▁, ▁0 ▁, ▁sizeof ▁( ▁Picture ▁) ▁* ▁( ▁h ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁- ▁len ▁) ▁) ▁; ▁} ▁# ifdef ▁TRACE ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁-> ▁ref _ count ▁[ ▁0 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁t printf ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁" List 0 :% s fn :% d 0 x % p \ n " ▁, ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁long _ ref ▁? ▁" LT " ▁: ▁" ST " ▁) ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁pic _ id ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁0 ▁] ▁[ ▁i ▁] ▁. ▁data ▁[ ▁0 ▁] ▁) ▁; ▁} ▁if ▁( ▁h ▁-> ▁slice _ type _ nos ▁== ▁FF _ B _ TYPE ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁h ▁-> ▁ref _ count ▁[ ▁1 ▁] ▁; ▁i ▁++ ▁) ▁{ ▁t printf ▁( ▁h ▁-> ▁s ▁. ▁avctx ▁, ▁" List 1 :% s fn :% d 0 x % p \ n " ▁, ▁( ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁long _ ref ▁? ▁" LT " ▁: ▁" ST " ▁) ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁pic _ id ▁, ▁h ▁-> ▁default _ ref _ list ▁[ ▁1 ▁] ▁[ ▁i ▁] ▁. ▁data ▁[ ▁0 ▁] ▁) ▁; ▁} ▁} ▁# endif ▁return ▁0 ▁; ▁}	1
▁static ▁void ▁print _ report ▁( ▁OutputFile ▁* ▁output _ files ▁, ▁OutputStream ▁* ▁o st _ table ▁, ▁int ▁nb _ ostream s ▁, ▁int ▁is _ last _ report ▁, ▁int 64_ t ▁timer _ start ▁) ▁{ ▁char ▁buf ▁[ ▁1024 ▁] ▁; ▁OutputStream ▁* ▁o st ▁; ▁AVFormatContext ▁* ▁oc ▁; ▁int 64_ t ▁total _ size ▁; ▁AVCodecContext ▁* ▁enc ▁; ▁int ▁frame _ number ▁, ▁vid ▁, ▁i ▁; ▁double ▁bitrate ▁; ▁int 64_ t ▁pts ▁= ▁INT 64_ MAX ▁; ▁static ▁int 64_ t ▁last _ time ▁= ▁-1 ▁; ▁static ▁int ▁qp _ histogram ▁[ ▁52 ▁] ▁; ▁int ▁hours ▁, ▁mins ▁, ▁secs ▁, ▁us ▁; ▁if ▁( ▁! ▁is _ last _ report ▁) ▁{ ▁int 64_ t ▁cur _ time ▁; ▁cur _ time ▁= ▁av _ gettime ▁( ▁) ▁; ▁if ▁( ▁last _ time ▁== ▁-1 ▁) ▁{ ▁last _ time ▁= ▁cur _ time ▁; ▁return ▁; ▁} ▁if ▁( ▁( ▁cur _ time ▁- ▁last _ time ▁) ▁< ▁500000 ▁) ▁return ▁; ▁last _ time ▁= ▁cur _ time ▁; ▁} ▁oc ▁= ▁output _ files ▁[ ▁0 ▁] ▁. ▁ctx ▁; ▁total _ size ▁= ▁avio _ size ▁( ▁oc ▁-> ▁pb ▁) ▁; ▁if ▁( ▁total _ size ▁< ▁0 ▁) ▁total _ size ▁= ▁avio _ tell ▁( ▁oc ▁-> ▁pb ▁) ▁; ▁buf ▁[ ▁0 ▁] ▁= ▁' ▁\0 ▁' ▁; ▁vid ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁nb _ ostream s ▁; ▁i ▁++ ▁) ▁{ ▁float ▁q ▁= ▁-1 ▁; ▁o st ▁= ▁& ▁o st _ table ▁[ ▁i ▁] ▁; ▁enc ▁= ▁o st ▁-> ▁st ▁-> ▁codec ▁; ▁if ▁( ▁! ▁o st ▁-> ▁st ▁-> ▁stream _ copy ▁&& ▁enc ▁-> ▁coded _ frame ▁) ▁q ▁= ▁enc ▁-> ▁coded _ frame ▁-> ▁quality ▁/ ▁( ▁float ▁) ▁FF _ QP 2 L AMBDA ▁; ▁if ▁( ▁vid ▁&& ▁enc ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" q =% 2.1 f " ▁, ▁q ▁) ▁; ▁} ▁if ▁( ▁! ▁vid ▁&& ▁enc ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ VIDEO ▁) ▁{ ▁float ▁t ▁= ▁( ▁av _ gettime ▁( ▁) ▁- ▁timer _ start ▁) ▁/ ▁1000000.0 ▁; ▁frame _ number ▁= ▁o st ▁-> ▁frame _ number ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" frame =% 5 df ps =% 3 dq =% 3.1 f " ▁, ▁frame _ number ▁, ▁( ▁t ▁> ▁1 ▁) ▁? ▁( ▁int ▁) ▁( ▁frame _ number ▁/ ▁t ▁+ ▁0.5 ▁) ▁: ▁0 ▁, ▁q ▁) ▁; ▁if ▁( ▁is _ last _ report ▁) ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" L " ▁) ▁; ▁if ▁( ▁qp _ hist ▁) ▁{ ▁int ▁j ▁; ▁int ▁qp ▁= ▁l rintf ▁( ▁q ▁) ▁; ▁if ▁( ▁qp ▁>= ▁0 ▁&& ▁qp ▁< ▁FF _ ARRAY _ ELEMS ▁( ▁qp _ histogram ▁) ▁) ▁qp _ histogram ▁[ ▁qp ▁] ▁++ ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁32 ▁; ▁j ▁++ ▁) ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"% X " ▁, ▁( ▁int ▁) ▁l rintf ▁( ▁log ▁( ▁qp _ histogram ▁[ ▁j ▁] ▁+ ▁1 ▁) ▁/ ▁log ▁( ▁2 ▁) ▁) ▁) ▁; ▁} ▁if ▁( ▁enc ▁-> ▁flags ▁& ▁CODEC _ FLAG _ PS NR ▁) ▁{ ▁int ▁j ▁; ▁double ▁error ▁, ▁error _ sum ▁= ▁0 ▁; ▁double ▁scale ▁, ▁scale _ sum ▁= ▁0 ▁; ▁char ▁type ▁[ ▁3 ▁] ▁= ▁{ ▁' ▁' ▁, ▁' ▁' ▁, ▁' ▁' ▁} ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" PS NR =" ▁) ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁3 ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁is _ last _ report ▁) ▁{ ▁error ▁= ▁enc ▁-> ▁error ▁[ ▁j ▁] ▁; ▁scale ▁= ▁enc ▁-> ▁width ▁* ▁enc ▁-> ▁height ▁* ▁255.0 ▁* ▁255.0 ▁* ▁frame _ number ▁; ▁} ▁else ▁{ ▁error ▁= ▁enc ▁-> ▁coded _ frame ▁-> ▁error ▁[ ▁j ▁] ▁; ▁scale ▁= ▁enc ▁-> ▁width ▁* ▁enc ▁-> ▁height ▁* ▁255.0 ▁* ▁255.0 ▁; ▁} ▁if ▁( ▁j ▁) ▁scale ▁/= ▁4 ▁; ▁error _ sum ▁+= ▁error ▁; ▁scale _ sum ▁+= ▁scale ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"% c :% 2.2 f " ▁, ▁type ▁[ ▁j ▁] ▁, ▁ps nr ▁( ▁error ▁/ ▁scale ▁) ▁) ▁; ▁} ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"* :% 2.2 f " ▁, ▁ps nr ▁( ▁error _ sum ▁/ ▁scale _ sum ▁) ▁) ▁; ▁} ▁vid ▁= ▁1 ▁; ▁} ▁pts ▁= ▁FF MIN ▁( ▁pts ▁, ▁av _ re scale _ q ▁( ▁o st ▁-> ▁st ▁-> ▁pts ▁. ▁val ▁, ▁o st ▁-> ▁st ▁-> ▁time _ base ▁, ▁AV _ TIME _ BASE _ Q ▁) ▁) ▁; ▁} ▁secs ▁= ▁pts ▁/ ▁AV _ TIME _ BASE ▁; ▁us ▁= ▁pts ▁% ▁AV _ TIME _ BASE ▁; ▁mins ▁= ▁secs ▁/ ▁60 ▁; ▁secs ▁%= ▁60 ▁; ▁hours ▁= ▁mins ▁/ ▁60 ▁; ▁mins ▁%= ▁60 ▁; ▁bitrate ▁= ▁pts ▁? ▁total _ size ▁* ▁8 ▁/ ▁( ▁pts ▁/ ▁1000.0 ▁) ▁: ▁0 ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" size =% 8 .0 f k B time =" ▁, ▁total _ size ▁/ ▁1024.0 ▁) ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁"%02 d :%02 d :%02 d . %02 d " ▁, ▁hours ▁, ▁mins ▁, ▁secs ▁, ▁( ▁100 ▁* ▁us ▁) ▁/ ▁AV _ TIME _ BASE ▁) ▁; ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" bitrate =% 6.1 f k bits / s " ▁, ▁bitrate ▁) ▁; ▁if ▁( ▁nb _ frames _ dup ▁|| ▁nb _ frames _ drop ▁) ▁snprintf ▁( ▁buf ▁+ ▁strlen ▁( ▁buf ▁) ▁, ▁sizeof ▁( ▁buf ▁) ▁- ▁strlen ▁( ▁buf ▁) ▁, ▁" dup =% dd rop =% d " ▁, ▁nb _ frames _ dup ▁, ▁nb _ frames _ drop ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁is _ last _ report ▁? ▁AV _ LOG _ WARNING ▁: ▁AV _ LOG _ INFO ▁, ▁"% s \ r " ▁, ▁buf ▁) ▁; ▁fflush ▁( ▁stderr ▁) ▁; ▁if ▁( ▁is _ last _ report ▁) ▁{ ▁int 64_ t ▁raw ▁= ▁audio _ size ▁+ ▁video _ size ▁+ ▁extra _ size ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ INFO ▁, ▁"\ n " ▁) ▁; ▁av _ log ▁( ▁NULL ▁, ▁AV _ LOG _ INFO ▁, ▁" video :% 1.0 f k B audio :% 1.0 f k B global headers :% 1.0 f k B mux ing overhead % f %% \ n " ▁, ▁video _ size ▁/ ▁1024.0 ▁, ▁audio _ size ▁/ ▁1024.0 ▁, ▁extra _ size ▁/ ▁1024.0 ▁, ▁100.0 ▁* ▁( ▁total _ size ▁- ▁raw ▁) ▁/ ▁raw ▁) ▁; ▁} ▁}	1
▁void ▁* ▁av _ realloc ▁( ▁void ▁* ▁ptr ▁, ▁size _ t ▁size ▁) ▁{ ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁int ▁diff ▁; ▁# endif ▁if ▁( ▁size ▁> ▁( ▁max _ alloc _ size ▁- ▁32 ▁) ▁) ▁return ▁NULL ▁; ▁# if ▁CONFIG _ MEM ALIGN _ H ACK ▁if ▁( ▁! ▁ptr ▁) ▁return ▁av _ malloc ▁( ▁size ▁) ▁; ▁diff ▁= ▁( ▁( ▁char ▁* ▁) ▁ptr ▁) ▁[ ▁-1 ▁] ▁; ▁av _ assert 0 ▁( ▁diff ▁> ▁0 ▁&& ▁diff ▁<= ▁ALIGN ▁) ▁; ▁ptr ▁= ▁realloc ▁( ▁( ▁char ▁* ▁) ▁ptr ▁- ▁diff ▁, ▁size ▁+ ▁diff ▁) ▁; ▁if ▁( ▁ptr ▁) ▁ptr ▁= ▁( ▁char ▁* ▁) ▁ptr ▁+ ▁diff ▁; ▁return ▁ptr ▁; ▁# elif ▁HAVE _ ALIGNED _ MALLOC ▁return ▁_ aligned _ realloc ▁( ▁ptr ▁, ▁size ▁+ ▁! ▁size ▁, ▁ALIGN ▁) ▁; ▁# else ▁return ▁realloc ▁( ▁ptr ▁, ▁size ▁+ ▁! ▁size ▁) ▁; ▁# endif ▁}	1
▁int ▁BN _ ucmp ▁( ▁const ▁BIGNUM ▁* ▁a ▁, ▁const ▁BIGNUM ▁* ▁b ▁) ▁{ ▁int ▁i ▁; ▁BN _ ULONG ▁t 1 ▁, ▁t 2 ▁, ▁* ▁ap ▁, ▁* ▁bp ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁bn _ check _ top ▁( ▁b ▁) ▁; ▁i ▁= ▁a ▁-> ▁top ▁- ▁b ▁-> ▁top ▁; ▁if ▁( ▁i ▁!= ▁0 ▁) ▁return ▁i ▁; ▁ap ▁= ▁a ▁-> ▁d ▁; ▁bp ▁= ▁b ▁-> ▁d ▁; ▁for ▁( ▁i ▁= ▁a ▁-> ▁top ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁t 1 ▁= ▁ap ▁[ ▁i ▁] ▁; ▁t 2 ▁= ▁bp ▁[ ▁i ▁] ▁; ▁if ▁( ▁t 1 ▁!= ▁t 2 ▁) ▁return ▁( ▁( ▁t 1 ▁> ▁t 2 ▁) ▁? ▁1 ▁: ▁-1 ▁) ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁av _ cold ▁int ▁g 72 6_ init ▁( ▁AVCodecContext ▁* ▁avctx ▁) ▁{ ▁G 726 Context ▁* ▁c ▁= ▁avctx ▁-> ▁priv _ data ▁; ▁unsigned ▁int ▁index ▁; ▁if ▁( ▁avctx ▁-> ▁sample _ rate ▁<= ▁0 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Sampler ate is invalid \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁index ▁= ▁( ▁avctx ▁-> ▁bit _ rate ▁+ ▁avctx ▁-> ▁sample _ rate ▁/ ▁2 ▁) ▁/ ▁avctx ▁-> ▁sample _ rate ▁- ▁2 ▁; ▁if ▁( ▁avctx ▁-> ▁bit _ rate ▁% ▁avctx ▁-> ▁sample _ rate ▁&& ▁avctx ▁-> ▁codec ▁-> ▁encode ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Bitrate - Sampler ate comb ination is invalid \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁avctx ▁-> ▁channels ▁!= ▁1 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Only mono iss upported \ n " ▁) ▁; ▁return ▁-1 ▁; ▁} ▁if ▁( ▁index ▁> ▁3 ▁) ▁{ ▁av _ log ▁( ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" Unsupported number of bits % d \ n " ▁, ▁index ▁+ ▁2 ▁) ▁; ▁return ▁-1 ▁; ▁} ▁g 72 6_ reset ▁( ▁c ▁, ▁index ▁) ▁; ▁c ▁-> ▁code _ size ▁= ▁index ▁+ ▁2 ▁; ▁avctx ▁-> ▁coded _ frame ▁= ▁avcodec _ alloc _ frame ▁( ▁) ▁; ▁if ▁( ▁! ▁avctx ▁-> ▁coded _ frame ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁avctx ▁-> ▁coded _ frame ▁-> ▁key _ frame ▁= ▁1 ▁; ▁if ▁( ▁avctx ▁-> ▁codec ▁-> ▁decode ▁) ▁avctx ▁-> ▁sample _ fmt ▁= ▁SAMPLE _ FMT _ S 16 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁inline ▁int ▁mov _ st sc _ index _ valid ▁( ▁unsigned ▁int ▁index ▁, ▁unsigned ▁int ▁count ▁) ▁{ ▁return ▁index ▁< ▁count ▁- ▁1 ▁; ▁}	0
▁static ▁int ▁jac os ub _ probe ▁( ▁AV Probe Data ▁* ▁p ▁) ▁{ ▁const ▁char ▁* ▁ptr ▁= ▁p ▁-> ▁buf ▁; ▁const ▁char ▁* ▁ptr _ end ▁= ▁p ▁-> ▁buf ▁+ ▁p ▁-> ▁buf _ size ▁; ▁if ▁( ▁AV _ RB 24 ▁( ▁ptr ▁) ▁== ▁0 xEF BB BF ▁) ▁ptr ▁+= ▁3 ▁; ▁while ▁( ▁ptr ▁< ▁ptr _ end ▁) ▁{ ▁while ▁( ▁j ss _ whitespace ▁( ▁* ▁ptr ▁) ▁) ▁ptr ▁++ ▁; ▁if ▁( ▁* ▁ptr ▁!= ▁' ▁' ▁&& ▁* ▁ptr ▁!= ▁' ▁\ n ▁' ▁) ▁{ ▁if ▁( ▁timed _ line ▁( ▁ptr ▁) ▁) ▁return ▁AV PROBE _ SCORE _ EXTENSION ▁+ ▁1 ▁; ▁return ▁0 ▁; ▁} ▁ptr ▁+= ▁strcspn ▁( ▁ptr ▁, ▁"\ n " ▁) ▁+ ▁1 ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁static ▁int ▁request _ frame ▁( ▁AVFilter Link ▁* ▁out link ▁) ▁{ ▁Show W aves Context ▁* ▁show w aves ▁= ▁out link ▁-> ▁src ▁-> ▁priv ▁; ▁AVFilter Link ▁* ▁inlink ▁= ▁out link ▁-> ▁src ▁-> ▁inputs ▁[ ▁0 ▁] ▁; ▁int ▁ret ▁; ▁ret ▁= ▁ff _ request _ frame ▁( ▁inlink ▁) ▁; ▁if ▁( ▁ret ▁== ▁AVERROR _ EOF ▁&& ▁show w aves ▁-> ▁out pic ref ▁) ▁{ ▁if ▁( ▁show w aves ▁-> ▁single _ pic ▁) ▁push _ single _ pic ▁( ▁out link ▁) ▁; ▁else ▁push _ frame ▁( ▁out link ▁) ▁; ▁} ▁return ▁ret ▁; ▁}	0
▁static ▁void ▁av _ noinline ▁filter _ mb _ edge v ▁( ▁uint 8_ t ▁* ▁pix ▁, ▁int ▁stride ▁, ▁int 16_ t ▁b S ▁[ ▁4 ▁] ▁, ▁unsigned ▁int ▁qp ▁, ▁H 264 Context ▁* ▁h ▁) ▁{ ▁const ▁unsigned ▁int ▁index _ a ▁= ▁52 ▁+ ▁qp ▁+ ▁h ▁-> ▁slice _ alpha _ c 0_ offset ▁; ▁const ▁int ▁alpha ▁= ▁alpha _ table ▁[ ▁index _ a ▁] ▁; ▁const ▁int ▁beta ▁= ▁( ▁beta _ table ▁+ ▁52 ▁) ▁[ ▁qp ▁+ ▁h ▁-> ▁slice _ beta _ offset ▁] ▁; ▁if ▁( ▁alpha ▁== ▁0 ▁|| ▁beta ▁== ▁0 ▁) ▁return ▁; ▁if ▁( ▁b S ▁[ ▁0 ▁] ▁< ▁4 ▁) ▁{ ▁int 8_ t ▁tc ▁[ ▁4 ▁] ▁; ▁tc ▁[ ▁0 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁0 ▁] ▁] ▁; ▁tc ▁[ ▁1 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁1 ▁] ▁] ▁; ▁tc ▁[ ▁2 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁2 ▁] ▁] ▁; ▁tc ▁[ ▁3 ▁] ▁= ▁tc 0_ table ▁[ ▁index _ a ▁] ▁[ ▁b S ▁[ ▁3 ▁] ▁] ▁; ▁h ▁-> ▁s ▁. ▁dsp ▁. ▁h 264_ h _ loop _ filter _ l uma ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁, ▁tc ▁) ▁; ▁} ▁else ▁{ ▁h ▁-> ▁s ▁. ▁dsp ▁. ▁h 264_ h _ loop _ filter _ l uma _ intra ▁( ▁pix ▁, ▁stride ▁, ▁alpha ▁, ▁beta ▁) ▁; ▁} ▁}	1
▁static ▁void ▁decode _ v 1_ vector ▁( ▁C ine p ak Enc Context ▁* ▁s ▁, ▁AV Picture ▁* ▁sub _ p ict ▁, ▁int ▁v 1_ vector ▁, ▁strip _ info ▁* ▁info ▁) ▁{ ▁int ▁entry _ size ▁= ▁s ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ RGB 24 ▁? ▁6 ▁: ▁4 ▁; ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁0 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁1 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁1 ▁+ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁info ▁-> ▁v 1_ code book ▁[ ▁v 1_ vector ▁* ▁entry _ size ▁] ▁; ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁2 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁3 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁2 ▁+ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁3 ▁+ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁info ▁-> ▁v 1_ code book ▁[ ▁v 1_ vector ▁* ▁entry _ size ▁+ ▁1 ▁] ▁; ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁2 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁1 ▁+ ▁2 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁3 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁1 ▁+ ▁3 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁info ▁-> ▁v 1_ code book ▁[ ▁v 1_ vector ▁* ▁entry _ size ▁+ ▁2 ▁] ▁; ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁2 ▁+ ▁2 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁3 ▁+ ▁2 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁2 ▁+ ▁3 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁0 ▁] ▁[ ▁3 ▁+ ▁3 ▁* ▁sub _ p ict ▁-> ▁linesize ▁[ ▁0 ▁] ▁] ▁= ▁info ▁-> ▁v 1_ code book ▁[ ▁v 1_ vector ▁* ▁entry _ size ▁+ ▁3 ▁] ▁; ▁if ▁( ▁s ▁-> ▁pix _ fmt ▁== ▁AV _ PIX _ FMT _ RGB 24 ▁) ▁{ ▁sub _ p ict ▁-> ▁data ▁[ ▁1 ▁] ▁[ ▁0 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁1 ▁] ▁[ ▁1 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁1 ▁] ▁[ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁1 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁1 ▁] ▁[ ▁1 ▁+ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁1 ▁] ▁] ▁= ▁info ▁-> ▁v 1_ code book ▁[ ▁v 1_ vector ▁* ▁entry _ size ▁+ ▁4 ▁] ▁; ▁sub _ p ict ▁-> ▁data ▁[ ▁2 ▁] ▁[ ▁0 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁2 ▁] ▁[ ▁1 ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁2 ▁] ▁[ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁2 ▁] ▁] ▁= ▁sub _ p ict ▁-> ▁data ▁[ ▁2 ▁] ▁[ ▁1 ▁+ ▁sub _ p ict ▁-> ▁linesize ▁[ ▁2 ▁] ▁] ▁= ▁info ▁-> ▁v 1_ code book ▁[ ▁v 1_ vector ▁* ▁entry _ size ▁+ ▁5 ▁] ▁; ▁} ▁}	0
▁SSL _ CTX ▁* ▁SSL _ CTX _ new ▁( ▁SSL _ METHOD ▁* ▁meth ▁) ▁{ ▁SSL _ CTX ▁* ▁ret ▁= ▁NULL ▁; ▁if ▁( ▁meth ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ NULL _ SSL _ METHOD _ PASSED ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁} ▁if ▁( ▁SSL _ get _ ex _ data _ X 509_ STORE _ CTX _ idx ▁( ▁) ▁< ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ X 509_ VER IFICATION _ SETUP _ PRO BLE MS ▁) ▁; ▁goto ▁err ▁; ▁} ▁ret ▁= ▁( ▁SSL _ CTX ▁* ▁) ▁OPENSSL _ malloc ▁( ▁sizeof ▁( ▁SSL _ CTX ▁) ▁) ▁; ▁if ▁( ▁ret ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁memset ▁( ▁ret ▁, ▁0 ▁, ▁sizeof ▁( ▁SSL _ CTX ▁) ▁) ▁; ▁ret ▁-> ▁method ▁= ▁meth ▁; ▁ret ▁-> ▁cert _ store ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ cache _ mode ▁= ▁SSL _ S ESS _ CACHE _ SERVER ▁; ▁ret ▁-> ▁session _ cache _ size ▁= ▁SSL _ SESSION _ CACHE _ MAX _ SIZE _ DEFAULT ▁; ▁ret ▁-> ▁session _ cache _ head ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ cache _ tail ▁= ▁NULL ▁; ▁ret ▁-> ▁session _ timeout ▁= ▁meth ▁-> ▁get _ timeout ▁( ▁) ▁; ▁ret ▁-> ▁new _ session _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁remove _ session _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁get _ session _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁generate _ session _ id ▁= ▁NULL ▁; ▁memset ▁( ▁( ▁char ▁* ▁) ▁& ▁ret ▁-> ▁stats ▁, ▁0 ▁, ▁sizeof ▁( ▁ret ▁-> ▁stats ▁) ▁) ▁; ▁ret ▁-> ▁references ▁= ▁1 ▁; ▁ret ▁-> ▁quiet _ shutdown ▁= ▁0 ▁; ▁ret ▁-> ▁info _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁app _ verify _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁app _ verify _ arg ▁= ▁NULL ▁; ▁ret ▁-> ▁read _ ahead ▁= ▁0 ▁; ▁ret ▁-> ▁verify _ mode ▁= ▁SSL _ VERIFY _ NONE ▁; ▁ret ▁-> ▁verify _ depth ▁= ▁-1 ▁; ▁ret ▁-> ▁default _ verify _ callback ▁= ▁NULL ▁; ▁if ▁( ▁( ▁ret ▁-> ▁cert ▁= ▁ssl _ cert _ new ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁default _ passwd _ callback ▁= ▁NULL ▁; ▁ret ▁-> ▁default _ passwd _ callback _ userdata ▁= ▁NULL ▁; ▁ret ▁-> ▁client _ cert _ cb ▁= ▁NULL ▁; ▁ret ▁-> ▁sessions ▁= ▁lh _ new ▁( ▁L HASH _ HASH _ FN ▁( ▁SSL _ SESSION _ hash ▁) ▁, ▁L HASH _ COMP _ FN ▁( ▁SSL _ SESSION _ cmp ▁) ▁) ▁; ▁if ▁( ▁ret ▁-> ▁sessions ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ret ▁-> ▁cert _ store ▁= ▁X 509_ STORE _ new ▁( ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cert _ store ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁ssl _ create _ cipher _ list ▁( ▁ret ▁-> ▁method ▁, ▁& ▁ret ▁-> ▁cipher _ list ▁, ▁& ▁ret ▁-> ▁cipher _ list _ by _ id ▁, ▁SSL _ DEFAULT _ CIPHER _ LIST ▁) ▁; ▁if ▁( ▁ret ▁-> ▁cipher _ list ▁== ▁NULL ▁|| ▁sk _ SSL _ CIPHER _ num ▁( ▁ret ▁-> ▁cipher _ list ▁) ▁<= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ LIBRARY _ HAS _ NO _ CIPHER S ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁rsa _ md 5 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 2- md 5" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 2_ MD 5_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁md 5 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- md 5" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ MD 5_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁sha 1 ▁= ▁EVP _ get _ digest byname ▁( ▁" ssl 3- sha 1" ▁) ▁) ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁SSL _ R _ UN ABLE _ TO _ LOAD _ SSL 3_ SHA 1_ ROUT INES ▁) ▁; ▁goto ▁err 2 ▁; ▁} ▁if ▁( ▁( ▁ret ▁-> ▁client _ CA ▁= ▁sk _ X 509_ NAME _ new _ null ▁( ▁) ▁) ▁== ▁NULL ▁) ▁goto ▁err ▁; ▁CRYPTO _ new _ ex _ data ▁( ▁ssl _ ctx _ meth ▁, ▁( ▁char ▁* ▁) ▁ret ▁, ▁& ▁ret ▁-> ▁ex _ data ▁) ▁; ▁ret ▁-> ▁extra _ certs ▁= ▁NULL ▁; ▁ret ▁-> ▁comp _ methods ▁= ▁SSL _ COMP _ get _ compression _ methods ▁( ▁) ▁; ▁return ▁( ▁ret ▁) ▁; ▁err ▁: ▁SSL err ▁( ▁SSL _ F _ SSL _ CTX _ NEW ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁err 2 ▁: ▁if ▁( ▁ret ▁!= ▁NULL ▁) ▁SSL _ CTX _ free ▁( ▁ret ▁) ▁; ▁return ▁( ▁NULL ▁) ▁; ▁}	0
▁int ▁ff _ ps y _ init ▁( ▁F FP sy Context ▁* ▁ctx ▁, ▁AVCodecContext ▁* ▁avctx ▁, ▁int ▁num _ lens ▁, ▁const ▁uint 8_ t ▁* ▁* ▁bands ▁, ▁const ▁int ▁* ▁num _ band s ▁, ▁int ▁num _ groups ▁, ▁const ▁uint 8_ t ▁* ▁group _ map ▁) ▁{ ▁int ▁i ▁, ▁j ▁, ▁k ▁= ▁0 ▁; ▁ctx ▁-> ▁avctx ▁= ▁avctx ▁; ▁ctx ▁-> ▁ch ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁ctx ▁-> ▁ch ▁[ ▁0 ▁] ▁) ▁* ▁avctx ▁-> ▁channels ▁* ▁2 ▁) ▁; ▁ctx ▁-> ▁group ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁ctx ▁-> ▁group ▁[ ▁0 ▁] ▁) ▁* ▁num _ groups ▁) ▁; ▁ctx ▁-> ▁bands ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁ctx ▁-> ▁bands ▁[ ▁0 ▁] ▁) ▁* ▁num _ lens ▁) ▁; ▁ctx ▁-> ▁num _ band s ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁ctx ▁-> ▁num _ band s ▁[ ▁0 ▁] ▁) ▁* ▁num _ lens ▁) ▁; ▁memcpy ▁( ▁ctx ▁-> ▁bands ▁, ▁bands ▁, ▁sizeof ▁( ▁ctx ▁-> ▁bands ▁[ ▁0 ▁] ▁) ▁* ▁num _ lens ▁) ▁; ▁memcpy ▁( ▁ctx ▁-> ▁num _ band s ▁, ▁num _ band s ▁, ▁sizeof ▁( ▁ctx ▁-> ▁num _ band s ▁[ ▁0 ▁] ▁) ▁* ▁num _ lens ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁num _ groups ▁; ▁i ▁++ ▁) ▁{ ▁ctx ▁-> ▁group ▁[ ▁i ▁] ▁. ▁num _ ch ▁= ▁group _ map ▁[ ▁i ▁] ▁+ ▁1 ▁; ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁ctx ▁-> ▁group ▁[ ▁i ▁] ▁. ▁num _ ch ▁* ▁2 ▁; ▁j ▁++ ▁) ▁ctx ▁-> ▁group ▁[ ▁i ▁] ▁. ▁ch ▁[ ▁j ▁] ▁= ▁& ▁ctx ▁-> ▁ch ▁[ ▁k ▁++ ▁] ▁; ▁} ▁switch ▁( ▁ctx ▁-> ▁avctx ▁-> ▁codec _ id ▁) ▁{ ▁case ▁CODEC _ ID _ A AC ▁: ▁ctx ▁-> ▁model ▁= ▁& ▁ff _ aac _ ps y _ model ▁; ▁break ▁; ▁} ▁if ▁( ▁ctx ▁-> ▁model ▁-> ▁init ▁) ▁return ▁ctx ▁-> ▁model ▁-> ▁init ▁( ▁ctx ▁) ▁; ▁return ▁0 ▁; ▁}	1
▁apr _ status _ t ▁ap _ core _ output _ filter ▁( ▁ap _ filter _ t ▁* ▁f ▁, ▁apr _ bucket _ b rig ade ▁* ▁bb ▁) ▁{ ▁conn _ rec ▁* ▁c ▁= ▁f ▁-> ▁c ▁; ▁core _ net _ rec ▁* ▁net ▁= ▁f ▁-> ▁ctx ▁; ▁apr _ socket _ t ▁* ▁sock ▁= ▁net ▁-> ▁client _ socket ▁; ▁core _ output _ filter _ ctx _ t ▁* ▁ctx ▁= ▁net ▁-> ▁out _ ctx ▁; ▁apr _ interval _ time _ t ▁sock _ timeout ▁= ▁0 ▁; ▁apr _ status _ t ▁rv ▁; ▁if ▁( ▁c ▁-> ▁aborted ▁) ▁{ ▁apr _ b rig ade _ cleanup ▁( ▁bb ▁) ▁; ▁return ▁APR _ ECON N ABORT ED ▁; ▁} ▁if ▁( ▁ctx ▁== ▁NULL ▁) ▁{ ▁ctx ▁= ▁apr _ pc alloc ▁( ▁c ▁-> ▁pool ▁, ▁sizeof ▁( ▁* ▁ctx ▁) ▁) ▁; ▁net ▁-> ▁out _ ctx ▁= ▁( ▁core _ output _ filter _ ctx _ t ▁* ▁) ▁ctx ▁; ▁ctx ▁-> ▁tmp _ flush _ bb ▁= ▁apr _ b rig ade _ create ▁( ▁c ▁-> ▁pool ▁, ▁c ▁-> ▁bucket _ alloc ▁) ▁; ▁} ▁if ▁( ▁bb ▁== ▁NULL ▁) ▁{ ▁if ▁( ▁ctx ▁-> ▁empty _ bb ▁== ▁NULL ▁) ▁{ ▁ctx ▁-> ▁empty _ bb ▁= ▁apr _ b rig ade _ create ▁( ▁c ▁-> ▁pool ▁, ▁c ▁-> ▁bucket _ alloc ▁) ▁; ▁} ▁bb ▁= ▁ctx ▁-> ▁empty _ bb ▁; ▁} ▁ap _ filter _ re in state _ b rig ade ▁( ▁f ▁, ▁bb ▁, ▁NULL ▁) ▁; ▁if ▁( ▁APR _ BR IG ADE _ EMPTY ▁( ▁bb ▁) ▁) ▁{ ▁return ▁APR _ SUCCESS ▁; ▁} ▁apr _ socket _ timeout _ get ▁( ▁sock ▁, ▁& ▁sock _ timeout ▁) ▁; ▁apr _ socket _ timeout _ set ▁( ▁sock ▁, ▁0 ▁) ▁; ▁do ▁{ ▁rv ▁= ▁send _ b rig ade _ non blocking ▁( ▁sock ▁, ▁bb ▁, ▁ctx ▁, ▁c ▁) ▁; ▁if ▁( ▁APR _ STATUS _ IS _ E AGAIN ▁( ▁rv ▁) ▁) ▁{ ▁apr _ bucket ▁* ▁flush _ upt o ▁; ▁ap _ filter _ re in state _ b rig ade ▁( ▁f ▁, ▁bb ▁, ▁& ▁flush _ upt o ▁) ▁; ▁if ▁( ▁flush _ upt o ▁) ▁{ ▁apr _ int 32_ t ▁n fd ▁; ▁apr _ pol lfd _ t ▁pfd ▁; ▁memset ▁( ▁& ▁pfd ▁, ▁0 ▁, ▁sizeof ▁( ▁pfd ▁) ▁) ▁; ▁pfd ▁. ▁req events ▁= ▁APR _ POL LOUT ▁; ▁pfd ▁. ▁desc _ type ▁= ▁APR _ POLL _ SOCKET ▁; ▁pfd ▁. ▁desc ▁. ▁s ▁= ▁sock ▁; ▁pfd ▁. ▁p ▁= ▁c ▁-> ▁pool ▁; ▁do ▁{ ▁rv ▁= ▁apr _ poll ▁( ▁& ▁pfd ▁, ▁1 ▁, ▁& ▁n fd ▁, ▁sock _ timeout ▁) ▁; ▁} ▁while ▁( ▁APR _ STATUS _ IS _ E INTR ▁( ▁rv ▁) ▁) ▁; ▁} ▁} ▁} ▁while ▁( ▁rv ▁== ▁APR _ SUCCESS ▁&& ▁! ▁APR _ BR IG ADE _ EMPTY ▁( ▁bb ▁) ▁) ▁; ▁apr _ socket _ timeout _ set ▁( ▁sock ▁, ▁sock _ timeout ▁) ▁; ▁if ▁( ▁rv ▁!= ▁APR _ SUCCESS ▁&& ▁! ▁APR _ STATUS _ IS _ E AGAIN ▁( ▁rv ▁) ▁) ▁{ ▁ap _ log _ c error ▁( ▁AP LOG _ MARK ▁, ▁AP LOG _ TRACE 1 ▁, ▁rv ▁, ▁c ▁, ▁" core _ output _ filter : writing datat ot hen etwork " ▁) ▁; ▁apr _ b rig ade _ cleanup ▁( ▁bb ▁) ▁; ▁c ▁-> ▁aborted ▁= ▁1 ▁; ▁return ▁rv ▁; ▁} ▁return ▁ap _ filter _ set as ide _ b rig ade ▁( ▁f ▁, ▁bb ▁) ▁; ▁}	0
▁int ▁BN _ bn 2 bin ▁( ▁const ▁BIGNUM ▁* ▁a ▁, ▁unsigned ▁char ▁* ▁to ▁) ▁{ ▁int ▁n ▁, ▁i ▁; ▁BN _ ULONG ▁l ▁; ▁bn _ check _ top ▁( ▁a ▁) ▁; ▁n ▁= ▁i ▁= ▁BN _ num _ bytes ▁( ▁a ▁) ▁; ▁while ▁( ▁i ▁-- ▁) ▁{ ▁l ▁= ▁a ▁-> ▁d ▁[ ▁i ▁/ ▁BN _ BYTES ▁] ▁; ▁* ▁( ▁to ▁++ ▁) ▁= ▁( ▁unsigned ▁char ▁) ▁( ▁l ▁>> ▁( ▁8 ▁* ▁( ▁i ▁% ▁BN _ BYTES ▁) ▁) ▁) ▁& ▁0 xff ▁; ▁} ▁return ▁( ▁n ▁) ▁; ▁}	1
▁static ▁int ▁read Separ ate Tiles Into Buffer ▁( ▁TIFF ▁* ▁in ▁, ▁uint 8 ▁* ▁obuf ▁, ▁uint 32 ▁image length ▁, ▁uint 32 ▁image width ▁, ▁uint 32 ▁tw ▁, ▁uint 32 ▁tl ▁, ▁uint 16 ▁s pp ▁, ▁uint 16 ▁bps ▁) ▁{ ▁int ▁i ▁, ▁status ▁= ▁1 ▁, ▁sample ▁; ▁int ▁shift _ width ▁, ▁bytes _ per _ pixel ▁; ▁uint 16 ▁bytes _ per _ sample ▁; ▁uint 32 ▁row ▁, ▁col ▁; ▁uint 32 ▁nrow ▁, ▁n col ▁; ▁uint 32 ▁row _ offset ▁, ▁col _ offset ▁; ▁tsize _ t ▁t bytes ▁= ▁0 ▁, ▁tile size ▁= ▁TIFF Tile Size ▁( ▁in ▁) ▁; ▁ts ample _ t ▁s ▁; ▁uint 8 ▁* ▁bufp ▁= ▁( ▁uint 8 ▁* ▁) ▁obuf ▁; ▁unsigned ▁char ▁* ▁src buff s ▁[ ▁MAX _ SAMPLES ▁] ▁; ▁unsigned ▁char ▁* ▁t buff ▁= ▁NULL ▁; ▁bytes _ per _ sample ▁= ▁( ▁bps ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁for ▁( ▁sample ▁= ▁0 ▁; ▁( ▁sample ▁< ▁s pp ▁) ▁&& ▁( ▁sample ▁< ▁MAX _ SAMPLES ▁) ▁; ▁sample ▁++ ▁) ▁{ ▁src buff s ▁[ ▁sample ▁] ▁= ▁NULL ▁; ▁t buff ▁= ▁( ▁unsigned ▁char ▁* ▁) ▁_ TIFF malloc ▁( ▁tile size ▁+ ▁8 ▁) ▁; ▁if ▁( ▁! ▁t buff ▁) ▁{ ▁TIFF Error ▁( ▁" read Separ ate Tiles Into Buffer " ▁, ▁" Unable to alloc at et il ere ad buffer f ors ample % d " ▁, ▁sample ▁) ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sample ▁; ▁i ▁++ ▁) ▁_ TIFF free ▁( ▁src buff s ▁[ ▁i ▁] ▁) ▁; ▁return ▁0 ▁; ▁} ▁src buff s ▁[ ▁sample ▁] ▁= ▁t buff ▁; ▁} ▁for ▁( ▁row ▁= ▁0 ▁; ▁row ▁< ▁image length ▁; ▁row ▁+= ▁tl ▁) ▁{ ▁nrow ▁= ▁( ▁row ▁+ ▁tl ▁> ▁image length ▁) ▁? ▁image length ▁- ▁row ▁: ▁tl ▁; ▁for ▁( ▁col ▁= ▁0 ▁; ▁col ▁< ▁image width ▁; ▁col ▁+= ▁tw ▁) ▁{ ▁for ▁( ▁s ▁= ▁0 ▁; ▁s ▁< ▁s pp ▁&& ▁s ▁< ▁MAX _ SAMPLES ▁; ▁s ▁++ ▁) ▁{ ▁t bytes ▁= ▁TIFF Read Tile ▁( ▁in ▁, ▁src buff s ▁[ ▁s ▁] ▁, ▁col ▁, ▁row ▁, ▁0 ▁, ▁s ▁) ▁; ▁if ▁( ▁t bytes ▁< ▁0 ▁&& ▁! ▁ignore ▁) ▁{ ▁TIFF Error ▁( ▁TIFF FileName ▁( ▁in ▁) ▁, ▁" Error , can ' t read tile for row % lu col % lu ," ▁" sample % lu " ▁, ▁( ▁unsigned ▁long ▁) ▁col ▁, ▁( ▁unsigned ▁long ▁) ▁row ▁, ▁( ▁unsigned ▁long ▁) ▁s ▁) ▁; ▁status ▁= ▁0 ▁; ▁for ▁( ▁sample ▁= ▁0 ▁; ▁( ▁sample ▁< ▁s pp ▁) ▁&& ▁( ▁sample ▁< ▁MAX _ SAMPLES ▁) ▁; ▁sample ▁++ ▁) ▁{ ▁t buff ▁= ▁src buff s ▁[ ▁sample ▁] ▁; ▁if ▁( ▁t buff ▁!= ▁NULL ▁) ▁_ TIFF free ▁( ▁t buff ▁) ▁; ▁} ▁return ▁status ▁; ▁} ▁} ▁if ▁( ▁col ▁+ ▁tw ▁> ▁image width ▁) ▁n col ▁= ▁image width ▁- ▁col ▁; ▁else ▁n col ▁= ▁tw ▁; ▁row _ offset ▁= ▁row ▁* ▁( ▁( ▁( ▁image width ▁* ▁s pp ▁* ▁bps ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁) ▁; ▁col _ offset ▁= ▁( ▁( ▁col ▁* ▁s pp ▁* ▁bps ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁bufp ▁= ▁obuf ▁+ ▁row _ offset ▁+ ▁col _ offset ▁; ▁if ▁( ▁( ▁bps ▁% ▁8 ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁combine Separ ate Tile Samples Bytes ▁( ▁src buff s ▁, ▁bufp ▁, ▁n col ▁, ▁nrow ▁, ▁image width ▁, ▁tw ▁, ▁s pp ▁, ▁bps ▁, ▁NULL ▁, ▁0 ▁, ▁0 ▁) ▁) ▁{ ▁status ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁else ▁{ ▁bytes _ per _ pixel ▁= ▁( ▁( ▁bps ▁* ▁s pp ▁) ▁+ ▁7 ▁) ▁/ ▁8 ▁; ▁if ▁( ▁bytes _ per _ pixel ▁< ▁( ▁bytes _ per _ sample ▁+ ▁1 ▁) ▁) ▁shift _ width ▁= ▁bytes _ per _ pixel ▁; ▁else ▁shift _ width ▁= ▁bytes _ per _ sample ▁+ ▁1 ▁; ▁switch ▁( ▁shift _ width ▁) ▁{ ▁case ▁1 ▁: ▁if ▁( ▁combine Separ ate Tile Samples 8 bits ▁( ▁src buff s ▁, ▁bufp ▁, ▁n col ▁, ▁nrow ▁, ▁image width ▁, ▁tw ▁, ▁s pp ▁, ▁bps ▁, ▁NULL ▁, ▁0 ▁, ▁0 ▁) ▁) ▁{ ▁status ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁case ▁2 ▁: ▁if ▁( ▁combine Separ ate Tile Samples 16 bits ▁( ▁src buff s ▁, ▁bufp ▁, ▁n col ▁, ▁nrow ▁, ▁image width ▁, ▁tw ▁, ▁s pp ▁, ▁bps ▁, ▁NULL ▁, ▁0 ▁, ▁0 ▁) ▁) ▁{ ▁status ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁case ▁3 ▁: ▁if ▁( ▁combine Separ ate Tile Samples 24 bits ▁( ▁src buff s ▁, ▁bufp ▁, ▁n col ▁, ▁nrow ▁, ▁image width ▁, ▁tw ▁, ▁s pp ▁, ▁bps ▁, ▁NULL ▁, ▁0 ▁, ▁0 ▁) ▁) ▁{ ▁status ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁case ▁4 ▁: ▁case ▁5 ▁: ▁case ▁6 ▁: ▁case ▁7 ▁: ▁case ▁8 ▁: ▁if ▁( ▁combine Separ ate Tile Samples 32 bits ▁( ▁src buff s ▁, ▁bufp ▁, ▁n col ▁, ▁nrow ▁, ▁image width ▁, ▁tw ▁, ▁s pp ▁, ▁bps ▁, ▁NULL ▁, ▁0 ▁, ▁0 ▁) ▁) ▁{ ▁status ▁= ▁0 ▁; ▁break ▁; ▁} ▁break ▁; ▁default ▁: ▁TIFF Error ▁( ▁" read Separ ate Tiles Into Buffer " ▁, ▁" Unsupported bit depth :% d " ▁, ▁bps ▁) ▁; ▁status ▁= ▁0 ▁; ▁break ▁; ▁} ▁} ▁} ▁} ▁for ▁( ▁sample ▁= ▁0 ▁; ▁( ▁sample ▁< ▁s pp ▁) ▁&& ▁( ▁sample ▁< ▁MAX _ SAMPLES ▁) ▁; ▁sample ▁++ ▁) ▁{ ▁t buff ▁= ▁src buff s ▁[ ▁sample ▁] ▁; ▁if ▁( ▁t buff ▁!= ▁NULL ▁) ▁_ TIFF free ▁( ▁t buff ▁) ▁; ▁} ▁return ▁status ▁; ▁}	1
▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁ssl _ bytes _ to _ cipher _ list ▁( ▁SSL ▁* ▁s ▁, ▁PACKET ▁* ▁cipher _ su ites ▁, ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁* ▁sk p ▁, ▁int ▁ssl v 2 format ▁, ▁int ▁* ▁al ▁) ▁{ ▁const ▁SSL _ CIPHER ▁* ▁c ▁; ▁STACK _ OF ▁( ▁SSL _ CIPHER ▁) ▁* ▁sk ▁; ▁int ▁n ▁; ▁unsigned ▁char ▁cipher ▁[ ▁SSL V 2_ CIPHER _ LEN ▁] ▁; ▁s ▁-> ▁s 3 ▁-> ▁send _ connection _ binding ▁= ▁0 ▁; ▁n ▁= ▁ssl v 2 format ▁? ▁SSL V 2_ CIPHER _ LEN ▁: ▁TLS _ CIPHER _ LEN ▁; ▁if ▁( ▁PACKET _ remaining ▁( ▁cipher _ su ites ▁) ▁== ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ BYTES _ TO _ CIPHER _ LIST ▁, ▁SSL _ R _ NO _ CIPHER S _ SPECIFIED ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ ILLEGAL _ PARAMETER ▁; ▁return ▁NULL ▁; ▁} ▁if ▁( ▁PACKET _ remaining ▁( ▁cipher _ su ites ▁) ▁% ▁n ▁!= ▁0 ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ BYTES _ TO _ CIPHER _ LIST ▁, ▁SSL _ R _ ERROR _ IN _ RECE IVED _ CIPHER _ LIST ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ DECODE _ ERROR ▁; ▁return ▁NULL ▁; ▁} ▁sk ▁= ▁sk _ SSL _ CIPHER _ new _ null ▁( ▁) ▁; ▁if ▁( ▁sk ▁== ▁NULL ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ BYTES _ TO _ CIPHER _ LIST ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁return ▁NULL ▁; ▁} ▁OPENSSL _ free ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw ▁) ▁; ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw ▁= ▁NULL ▁; ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw len ▁= ▁0 ▁; ▁if ▁( ▁ssl v 2 format ▁) ▁{ ▁size _ t ▁num c iphers ▁= ▁PACKET _ remaining ▁( ▁cipher _ su ites ▁) ▁/ ▁n ▁; ▁PACKET ▁ssl v 2 c iphers ▁= ▁* ▁cipher _ su ites ▁; ▁unsigned ▁int ▁lead byte ▁; ▁unsigned ▁char ▁* ▁raw ▁; ▁raw ▁= ▁OPENSSL _ malloc ▁( ▁num c iphers ▁* ▁TLS _ CIPHER _ LEN ▁) ▁; ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw ▁= ▁raw ▁; ▁if ▁( ▁raw ▁== ▁NULL ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁goto ▁err ▁; ▁} ▁for ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw len ▁= ▁0 ▁; ▁PACKET _ remaining ▁( ▁& ▁ssl v 2 c iphers ▁) ▁> ▁0 ▁; ▁raw ▁+= ▁TLS _ CIPHER _ LEN ▁) ▁{ ▁if ▁( ▁! ▁PACKET _ get _1 ▁( ▁& ▁ssl v 2 c iphers ▁, ▁& ▁lead byte ▁) ▁|| ▁( ▁lead byte ▁== ▁0 ▁&& ▁! ▁PACKET _ copy _ bytes ▁( ▁& ▁ssl v 2 c iphers ▁, ▁raw ▁, ▁TLS _ CIPHER _ LEN ▁) ▁) ▁|| ▁( ▁lead byte ▁!= ▁0 ▁&& ▁! ▁PACKET _ forward ▁( ▁& ▁ssl v 2 c iphers ▁, ▁TLS _ CIPHER _ LEN ▁) ▁) ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁OPENSSL _ free ▁( ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw ▁) ▁; ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw ▁= ▁NULL ▁; ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw len ▁= ▁0 ▁; ▁goto ▁err ▁; ▁} ▁if ▁( ▁lead byte ▁== ▁0 ▁) ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw len ▁+= ▁TLS _ CIPHER _ LEN ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁PACKET _ mem dup ▁( ▁cipher _ su ites ▁, ▁& ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw ▁, ▁& ▁s ▁-> ▁s 3 ▁-> ▁tmp ▁. ▁ciphers _ raw len ▁) ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁goto ▁err ▁; ▁} ▁while ▁( ▁PACKET _ copy _ bytes ▁( ▁cipher _ su ites ▁, ▁cipher ▁, ▁n ▁) ▁) ▁{ ▁if ▁( ▁ssl v 2 format ▁&& ▁cipher ▁[ ▁0 ▁] ▁!= ▁' ▁\0 ▁' ▁) ▁continue ▁; ▁if ▁( ▁( ▁cipher ▁[ ▁n ▁- ▁2 ▁] ▁== ▁( ▁( ▁SSL 3_ CK _ SC SV ▁>> ▁8 ▁) ▁& ▁0 xff ▁) ▁) ▁&& ▁( ▁cipher ▁[ ▁n ▁- ▁1 ▁] ▁== ▁( ▁SSL 3_ CK _ SC SV ▁& ▁0 xff ▁) ▁) ▁) ▁{ ▁if ▁( ▁s ▁-> ▁re neg ot iate ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ BYTES _ TO _ CIPHER _ LIST ▁, ▁SSL _ R _ SC SV _ RECE IVED _ WH EN _ R EN EG O TI ATING ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ HAND SHAKE _ FAILURE ▁; ▁goto ▁err ▁; ▁} ▁s ▁-> ▁s 3 ▁-> ▁send _ connection _ binding ▁= ▁1 ▁; ▁continue ▁; ▁} ▁if ▁( ▁( ▁cipher ▁[ ▁n ▁- ▁2 ▁] ▁== ▁( ▁( ▁SSL 3_ CK _ FALLBACK _ SC SV ▁>> ▁8 ▁) ▁& ▁0 xff ▁) ▁) ▁&& ▁( ▁cipher ▁[ ▁n ▁- ▁1 ▁] ▁== ▁( ▁SSL 3_ CK _ FALLBACK _ SC SV ▁& ▁0 xff ▁) ▁) ▁) ▁{ ▁if ▁( ▁! ▁ssl _ check _ version _ down grade ▁( ▁s ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ BYTES _ TO _ CIPHER _ LIST ▁, ▁SSL _ R _ IN AP PROP RI ATE _ FALLBACK ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ IN AP PROP RI ATE _ FALLBACK ▁; ▁goto ▁err ▁; ▁} ▁continue ▁; ▁} ▁c ▁= ▁ssl _ get _ cipher _ by _ char ▁( ▁s ▁, ▁ssl v 2 format ▁? ▁& ▁cipher ▁[ ▁1 ▁] ▁: ▁cipher ▁, ▁0 ▁) ▁; ▁if ▁( ▁c ▁!= ▁NULL ▁) ▁{ ▁if ▁( ▁! ▁sk _ SSL _ CIPHER _ push ▁( ▁sk ▁, ▁c ▁) ▁) ▁{ ▁SSL err ▁( ▁SSL _ F _ SSL _ BYTES _ TO _ CIPHER _ LIST ▁, ▁ERR _ R _ MALLOC _ FAILURE ▁) ▁; ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁goto ▁err ▁; ▁} ▁} ▁} ▁if ▁( ▁PACKET _ remaining ▁( ▁cipher _ su ites ▁) ▁> ▁0 ▁) ▁{ ▁* ▁al ▁= ▁SSL _ AD _ INTERNAL _ ERROR ▁; ▁SSL err ▁( ▁SSL _ F _ SSL _ BYTES _ TO _ CIPHER _ LIST ▁, ▁ERR _ R _ INTERNAL _ ERROR ▁) ▁; ▁goto ▁err ▁; ▁} ▁* ▁sk p ▁= ▁sk ▁; ▁return ▁sk ▁; ▁err ▁: ▁sk _ SSL _ CIPHER _ free ▁( ▁sk ▁) ▁; ▁return ▁NULL ▁; ▁}	1
▁static ▁int ▁old _ codec 37 ▁( ▁SAN M Video Context ▁* ▁ctx ▁, ▁int ▁top ▁, ▁int ▁left ▁, ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁int ▁stride ▁= ▁ctx ▁-> ▁pitch ▁; ▁int ▁i ▁, ▁j ▁, ▁k ▁, ▁t ▁; ▁int ▁skip _ run ▁= ▁0 ▁; ▁int ▁compr ▁, ▁mv off ▁, ▁seq ▁, ▁flags ▁; ▁uint 32_ t ▁decoded _ size ▁; ▁uint 8_ t ▁* ▁dst ▁, ▁* ▁prev ▁; ▁compr ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁mv off ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁seq ▁= ▁bytestream 2_ get _ le 16 ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁decoded _ size ▁= ▁bytestream 2_ get _ le 32 ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁bytestream 2_ skip ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁4 ▁) ▁; ▁flags ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁bytestream 2_ skip ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁3 ▁) ▁; ▁if ▁( ▁decoded _ size ▁> ▁height ▁* ▁stride ▁- ▁left ▁- ▁top ▁* ▁stride ▁) ▁{ ▁decoded _ size ▁= ▁height ▁* ▁stride ▁- ▁left ▁- ▁top ▁* ▁stride ▁; ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ WARNING ▁, ▁" decoded size ist ool arge \ n " ▁) ▁; ▁} ▁ctx ▁-> ▁rotate _ code ▁= ▁0 ▁; ▁if ▁( ▁( ▁( ▁seq ▁& ▁1 ▁) ▁|| ▁! ▁( ▁flags ▁& ▁1 ▁) ▁) ▁&& ▁( ▁compr ▁&& ▁compr ▁!= ▁2 ▁) ▁) ▁rotate _ bufs ▁( ▁ctx ▁, ▁1 ▁) ▁; ▁dst ▁= ▁( ▁( ▁uint 8_ t ▁* ▁) ▁ctx ▁-> ▁frm 0 ▁) ▁+ ▁left ▁+ ▁top ▁* ▁stride ▁; ▁prev ▁= ▁( ▁( ▁uint 8_ t ▁* ▁) ▁ctx ▁-> ▁frm 2 ▁) ▁+ ▁left ▁+ ▁top ▁* ▁stride ▁; ▁if ▁( ▁mv off ▁> ▁2 ▁) ▁{ ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" invalid motion base value % d \ n " ▁, ▁mv off ▁) ▁; ▁return ▁AVERROR _ INVALIDDATA ▁; ▁} ▁av _ d log ▁( ▁ctx ▁-> ▁avctx ▁, ▁" compression % d \ n " ▁, ▁compr ▁) ▁; ▁switch ▁( ▁compr ▁) ▁{ ▁case ▁0 ▁: ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁height ▁; ▁i ▁++ ▁) ▁{ ▁bytestream 2_ get _ buffer ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁dst ▁, ▁width ▁) ▁; ▁dst ▁+= ▁stride ▁; ▁} ▁memset ▁( ▁ctx ▁-> ▁frm 1 ▁, ▁0 ▁, ▁ctx ▁-> ▁height ▁* ▁stride ▁) ▁; ▁memset ▁( ▁ctx ▁-> ▁frm 2 ▁, ▁0 ▁, ▁ctx ▁-> ▁height ▁* ▁stride ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁if ▁( ▁r le _ decode ▁( ▁ctx ▁, ▁dst ▁, ▁decoded _ size ▁) ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁memset ▁( ▁ctx ▁-> ▁frm 1 ▁, ▁0 ▁, ▁ctx ▁-> ▁frm 1_ size ▁) ▁; ▁memset ▁( ▁ctx ▁-> ▁frm 2 ▁, ▁0 ▁, ▁ctx ▁-> ▁frm 2_ size ▁) ▁; ▁break ▁; ▁case ▁3 ▁: ▁case ▁4 ▁: ▁if ▁( ▁flags ▁& ▁4 ▁) ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁height ▁; ▁j ▁+= ▁4 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁; ▁i ▁+= ▁4 ▁) ▁{ ▁int ▁code ▁; ▁if ▁( ▁skip _ run ▁) ▁{ ▁skip _ run ▁-- ▁; ▁copy _ block 4 ▁( ▁dst ▁+ ▁i ▁, ▁prev ▁+ ▁i ▁, ▁stride ▁, ▁stride ▁, ▁4 ▁) ▁; ▁continue ▁; ▁} ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁code ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁switch ▁( ▁code ▁) ▁{ ▁case ▁0 xFF ▁: ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁16 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁4 ▁; ▁k ▁++ ▁) ▁bytestream 2_ get _ buffer u ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁dst ▁+ ▁i ▁+ ▁k ▁* ▁stride ▁, ▁4 ▁) ▁; ▁break ▁; ▁case ▁0 xFE ▁: ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁4 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁4 ▁; ▁k ▁++ ▁) ▁memset ▁( ▁dst ▁+ ▁i ▁+ ▁k ▁* ▁stride ▁, ▁bytestream 2_ get _ byte u ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁, ▁4 ▁) ▁; ▁break ▁; ▁case ▁0 xFD ▁: ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁t ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁4 ▁; ▁k ▁++ ▁) ▁memset ▁( ▁dst ▁+ ▁i ▁+ ▁k ▁* ▁stride ▁, ▁t ▁, ▁4 ▁) ▁; ▁break ▁; ▁default ▁: ▁if ▁( ▁compr ▁== ▁4 ▁&& ▁! ▁code ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁skip _ run ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁+ ▁1 ▁; ▁i ▁-= ▁4 ▁; ▁} ▁else ▁{ ▁int ▁mx ▁, ▁my ▁; ▁mx ▁= ▁c 3 7_ mv ▁[ ▁( ▁mv off ▁* ▁255 ▁+ ▁code ▁) ▁* ▁2 ▁] ▁; ▁my ▁= ▁c 3 7_ mv ▁[ ▁( ▁mv off ▁* ▁255 ▁+ ▁code ▁) ▁* ▁2 ▁+ ▁1 ▁] ▁; ▁codec 3 7_ mv ▁( ▁dst ▁+ ▁i ▁, ▁prev ▁+ ▁i ▁+ ▁mx ▁+ ▁my ▁* ▁stride ▁, ▁ctx ▁-> ▁height ▁, ▁stride ▁, ▁i ▁+ ▁mx ▁, ▁j ▁+ ▁my ▁) ▁; ▁} ▁} ▁} ▁dst ▁+= ▁stride ▁* ▁4 ▁; ▁prev ▁+= ▁stride ▁* ▁4 ▁; ▁} ▁} ▁else ▁{ ▁for ▁( ▁j ▁= ▁0 ▁; ▁j ▁< ▁height ▁; ▁j ▁+= ▁4 ▁) ▁{ ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁width ▁; ▁i ▁+= ▁4 ▁) ▁{ ▁int ▁code ▁; ▁if ▁( ▁skip _ run ▁) ▁{ ▁skip _ run ▁-- ▁; ▁copy _ block 4 ▁( ▁dst ▁+ ▁i ▁, ▁prev ▁+ ▁i ▁, ▁stride ▁, ▁stride ▁, ▁4 ▁) ▁; ▁continue ▁; ▁} ▁code ▁= ▁bytestream 2_ get _ byte ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁; ▁if ▁( ▁code ▁== ▁0 xFF ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁16 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁for ▁( ▁k ▁= ▁0 ▁; ▁k ▁< ▁4 ▁; ▁k ▁++ ▁) ▁bytestream 2_ get _ buffer u ▁( ▁& ▁ctx ▁-> ▁gb ▁, ▁dst ▁+ ▁i ▁+ ▁k ▁* ▁stride ▁, ▁4 ▁) ▁; ▁} ▁else ▁if ▁( ▁compr ▁== ▁4 ▁&& ▁! ▁code ▁) ▁{ ▁if ▁( ▁bytestream 2_ get _ bytes _ left ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁< ▁1 ▁) ▁return ▁AVERROR _ INVALIDDATA ▁; ▁skip _ run ▁= ▁bytestream 2_ get _ byte u ▁( ▁& ▁ctx ▁-> ▁gb ▁) ▁+ ▁1 ▁; ▁i ▁-= ▁4 ▁; ▁} ▁else ▁{ ▁int ▁mx ▁, ▁my ▁; ▁mx ▁= ▁c 3 7_ mv ▁[ ▁( ▁mv off ▁* ▁255 ▁+ ▁code ▁) ▁* ▁2 ▁] ▁; ▁my ▁= ▁c 3 7_ mv ▁[ ▁( ▁mv off ▁* ▁255 ▁+ ▁code ▁) ▁* ▁2 ▁+ ▁1 ▁] ▁; ▁codec 3 7_ mv ▁( ▁dst ▁+ ▁i ▁, ▁prev ▁+ ▁i ▁+ ▁mx ▁+ ▁my ▁* ▁stride ▁, ▁ctx ▁-> ▁height ▁, ▁stride ▁, ▁i ▁+ ▁mx ▁, ▁j ▁+ ▁my ▁) ▁; ▁} ▁} ▁dst ▁+= ▁stride ▁* ▁4 ▁; ▁prev ▁+= ▁stride ▁* ▁4 ▁; ▁} ▁} ▁break ▁; ▁default ▁: ▁av _ log ▁( ▁ctx ▁-> ▁avctx ▁, ▁AV _ LOG _ ERROR ▁, ▁" sub codec 37 compression % d not implemented \ n " ▁, ▁compr ▁) ▁; ▁return ▁AVERROR _ PATCH W EL CO ME ▁; ▁} ▁return ▁0 ▁; ▁}	1
▁char ▁* ▁av _ strdup ▁( ▁const ▁char ▁* ▁s ▁) ▁{ ▁char ▁* ▁ptr ▁= ▁NULL ▁; ▁if ▁( ▁s ▁) ▁{ ▁int ▁len ▁= ▁strlen ▁( ▁s ▁) ▁+ ▁1 ▁; ▁ptr ▁= ▁av _ malloc ▁( ▁len ▁) ▁; ▁if ▁( ▁ptr ▁) ▁memcpy ▁( ▁ptr ▁, ▁s ▁, ▁len ▁) ▁; ▁} ▁return ▁ptr ▁; ▁}	1
▁static ▁void ▁x 509 v 3_ cache _ extensions ▁( ▁X 509 ▁* ▁x ▁) ▁{ ▁BASIC _ CONSTRAINTS ▁* ▁bs ▁; ▁PROXY _ CERT _ INFO _ EXTENSION ▁* ▁pci ▁; ▁ASN 1_ BIT _ STRING ▁* ▁usage ▁; ▁ASN 1_ BIT _ STRING ▁* ▁ns ▁; ▁EXTENDED _ KEY _ USAGE ▁* ▁ext usage ▁; ▁X 509_ EXTENSION ▁* ▁ex ▁; ▁int ▁i ▁; ▁if ▁( ▁x ▁-> ▁ex _ flags ▁& ▁EX FLAG _ SET ▁) ▁return ▁; ▁# ifndef ▁OPENSSL _ NO _ SHA ▁X 509_ digest ▁( ▁x ▁, ▁EVP _ sha 1 ▁( ▁) ▁, ▁x ▁-> ▁sha 1_ hash ▁, ▁NULL ▁) ▁; ▁# endif ▁if ▁( ▁! ▁X 509_ NAME _ cmp ▁( ▁X 509_ get _ subject _ name ▁( ▁x ▁) ▁, ▁X 509_ get _ iss uer _ name ▁( ▁x ▁) ▁) ▁) ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ SI ▁; ▁if ▁( ▁! ▁X 509_ get _ version ▁( ▁x ▁) ▁) ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ V 1 ▁; ▁if ▁( ▁( ▁bs ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ basic _ constraints ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁if ▁( ▁bs ▁-> ▁ca ▁) ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ CA ▁; ▁if ▁( ▁bs ▁-> ▁path len ▁) ▁{ ▁if ▁( ▁( ▁bs ▁-> ▁path len ▁-> ▁type ▁== ▁V _ ASN 1_ NEG _ INTEGER ▁) ▁|| ▁! ▁bs ▁-> ▁ca ▁) ▁{ ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ INVALID ▁; ▁x ▁-> ▁ex _ path len ▁= ▁0 ▁; ▁} ▁else ▁x ▁-> ▁ex _ path len ▁= ▁ASN 1_ INTEGER _ get ▁( ▁bs ▁-> ▁path len ▁) ▁; ▁} ▁else ▁x ▁-> ▁ex _ path len ▁= ▁-1 ▁; ▁BASIC _ CONSTRAINTS _ free ▁( ▁bs ▁) ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ B CONS ▁; ▁} ▁if ▁( ▁( ▁pci ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ proxy Cert Info ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁if ▁( ▁x ▁-> ▁ex _ flags ▁& ▁EX FLAG _ CA ▁|| ▁X 509_ get _ ext _ by _ NID ▁( ▁x ▁, ▁NID _ subject _ alt _ name ▁, ▁0 ▁) ▁>= ▁0 ▁|| ▁X 509_ get _ ext _ by _ NID ▁( ▁x ▁, ▁NID _ iss uer _ alt _ name ▁, ▁0 ▁) ▁>= ▁0 ▁) ▁{ ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ INVALID ▁; ▁} ▁if ▁( ▁pci ▁-> ▁pc Path Length Constraint ▁) ▁{ ▁x ▁-> ▁ex _ pc path len ▁= ▁ASN 1_ INTEGER _ get ▁( ▁pci ▁-> ▁pc Path Length Constraint ▁) ▁; ▁} ▁else ▁x ▁-> ▁ex _ pc path len ▁= ▁-1 ▁; ▁PROXY _ CERT _ INFO _ EXTENSION _ free ▁( ▁pci ▁) ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ PROXY ▁; ▁} ▁if ▁( ▁( ▁usage ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ key _ usage ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁if ▁( ▁usage ▁-> ▁length ▁> ▁0 ▁) ▁{ ▁x ▁-> ▁ex _ k usage ▁= ▁usage ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁if ▁( ▁usage ▁-> ▁length ▁> ▁1 ▁) ▁x ▁-> ▁ex _ k usage ▁|= ▁usage ▁-> ▁data ▁[ ▁1 ▁] ▁<< ▁8 ▁; ▁} ▁else ▁x ▁-> ▁ex _ k usage ▁= ▁0 ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ K USAGE ▁; ▁ASN 1_ BIT _ STRING _ free ▁( ▁usage ▁) ▁; ▁} ▁x ▁-> ▁ex _ x k usage ▁= ▁0 ▁; ▁if ▁( ▁( ▁ext usage ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ ext _ key _ usage ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ X K USAGE ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁sk _ ASN 1_ OBJECT _ num ▁( ▁ext usage ▁) ▁; ▁i ▁++ ▁) ▁{ ▁switch ▁( ▁OBJ _ obj 2 nid ▁( ▁sk _ ASN 1_ OBJECT _ value ▁( ▁ext usage ▁, ▁i ▁) ▁) ▁) ▁{ ▁case ▁NID _ server _ auth ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ SSL _ SERVER ▁; ▁break ▁; ▁case ▁NID _ client _ auth ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ SSL _ CLIENT ▁; ▁break ▁; ▁case ▁NID _ email _ protect ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ S MIME ▁; ▁break ▁; ▁case ▁NID _ code _ sign ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ CODE _ SIGN ▁; ▁break ▁; ▁case ▁NID _ ms _ sg c ▁: ▁case ▁NID _ ns _ sg c ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ S GC ▁; ▁break ▁; ▁case ▁NID _ OCSP _ sign ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ OCSP _ SIGN ▁; ▁break ▁; ▁case ▁NID _ time _ stamp ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ TIMESTAMP ▁; ▁break ▁; ▁case ▁NID _ dv cs ▁: ▁x ▁-> ▁ex _ x k usage ▁|= ▁X K U _ DV CS ▁; ▁break ▁; ▁} ▁} ▁sk _ ASN 1_ OBJECT _ pop _ free ▁( ▁ext usage ▁, ▁ASN 1_ OBJECT _ free ▁) ▁; ▁} ▁if ▁( ▁( ▁ns ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ net scape _ cert _ type ▁, ▁NULL ▁, ▁NULL ▁) ▁) ▁) ▁{ ▁if ▁( ▁ns ▁-> ▁length ▁> ▁0 ▁) ▁x ▁-> ▁ex _ n sc ert ▁= ▁ns ▁-> ▁data ▁[ ▁0 ▁] ▁; ▁else ▁x ▁-> ▁ex _ n sc ert ▁= ▁0 ▁; ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ N SC ERT ▁; ▁ASN 1_ BIT _ STRING _ free ▁( ▁ns ▁) ▁; ▁} ▁x ▁-> ▁sk id ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ subject _ key _ identifier ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁x ▁-> ▁ak id ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ author ity _ key _ identifier ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁x ▁-> ▁cr ld p ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ c rl _ distribution _ points ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁# ifndef ▁OPENSSL _ NO _ RFC 3 779 ▁x ▁-> ▁rfc 377 9_ addr ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ sb gp _ ip Addr Block ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁x ▁-> ▁rfc 377 9_ asid ▁= ▁X 509_ get _ ext _ d 2 i ▁( ▁x ▁, ▁NID _ sb gp _ aut onom ous Sys Num ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁# endif ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁X 509_ get _ ext _ count ▁( ▁x ▁) ▁; ▁i ▁++ ▁) ▁{ ▁ex ▁= ▁X 509_ get _ ext ▁( ▁x ▁, ▁i ▁) ▁; ▁if ▁( ▁! ▁X 509_ EXTENSION _ get _ critical ▁( ▁ex ▁) ▁) ▁continue ▁; ▁if ▁( ▁! ▁X 509_ supported _ extension ▁( ▁ex ▁) ▁) ▁{ ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ CRITICAL ▁; ▁break ▁; ▁} ▁} ▁x ▁-> ▁ex _ flags ▁|= ▁EX FLAG _ SET ▁; ▁}	0
▁int ▁avfilter _ open ▁( ▁AVFilter Context ▁* ▁* ▁filter _ ctx ▁, ▁AVFilter ▁* ▁filter ▁, ▁const ▁char ▁* ▁inst _ name ▁) ▁{ ▁AVFilter Context ▁* ▁ret ▁; ▁* ▁filter _ ctx ▁= ▁NULL ▁; ▁if ▁( ▁! ▁filter ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁ret ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Context ▁) ▁) ▁; ▁if ▁( ▁! ▁ret ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁ret ▁-> ▁av _ class ▁= ▁& ▁avfilter _ class ▁; ▁ret ▁-> ▁filter ▁= ▁filter ▁; ▁ret ▁-> ▁name ▁= ▁inst _ name ▁? ▁av _ strdup ▁( ▁inst _ name ▁) ▁: ▁NULL ▁; ▁if ▁( ▁filter ▁-> ▁priv _ size ▁) ▁{ ▁ret ▁-> ▁priv ▁= ▁av _ malloc z ▁( ▁filter ▁-> ▁priv _ size ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁priv ▁) ▁goto ▁err ▁; ▁} ▁ret ▁-> ▁input _ count ▁= ▁pad _ count ▁( ▁filter ▁-> ▁inputs ▁) ▁; ▁if ▁( ▁ret ▁-> ▁input _ count ▁) ▁{ ▁ret ▁-> ▁input _ pads ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁input _ count ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁input _ pads ▁) ▁goto ▁err ▁; ▁memcpy ▁( ▁ret ▁-> ▁input _ pads ▁, ▁filter ▁-> ▁inputs ▁, ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁input _ count ▁) ▁; ▁ret ▁-> ▁inputs ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Link ▁* ▁) ▁* ▁ret ▁-> ▁input _ count ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁inputs ▁) ▁goto ▁err ▁; ▁} ▁ret ▁-> ▁output _ count ▁= ▁pad _ count ▁( ▁filter ▁-> ▁outputs ▁) ▁; ▁if ▁( ▁ret ▁-> ▁output _ count ▁) ▁{ ▁ret ▁-> ▁output _ pads ▁= ▁av _ malloc ▁( ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁output _ count ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁output _ pads ▁) ▁goto ▁err ▁; ▁memcpy ▁( ▁ret ▁-> ▁output _ pads ▁, ▁filter ▁-> ▁outputs ▁, ▁sizeof ▁( ▁AVFilter Pad ▁) ▁* ▁ret ▁-> ▁output _ count ▁) ▁; ▁ret ▁-> ▁outputs ▁= ▁av _ malloc z ▁( ▁sizeof ▁( ▁AVFilter Link ▁* ▁) ▁* ▁ret ▁-> ▁output _ count ▁) ▁; ▁if ▁( ▁! ▁ret ▁-> ▁outputs ▁) ▁goto ▁err ▁; ▁} ▁* ▁filter _ ctx ▁= ▁ret ▁; ▁return ▁0 ▁; ▁err ▁: ▁av _ freep ▁( ▁& ▁ret ▁-> ▁inputs ▁) ▁; ▁av _ freep ▁( ▁& ▁ret ▁-> ▁input _ pads ▁) ▁; ▁ret ▁-> ▁input _ count ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁ret ▁-> ▁outputs ▁) ▁; ▁av _ freep ▁( ▁& ▁ret ▁-> ▁output _ pads ▁) ▁; ▁ret ▁-> ▁output _ count ▁= ▁0 ▁; ▁av _ freep ▁( ▁& ▁ret ▁-> ▁priv ▁) ▁; ▁av _ free ▁( ▁ret ▁) ▁; ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁}	0
▁static ▁int ▁res ample ▁( ▁Res ample Context ▁* ▁c ▁, ▁void ▁* ▁dst ▁, ▁const ▁void ▁* ▁src ▁, ▁int ▁* ▁consumed ▁, ▁int ▁src _ size ▁, ▁int ▁dst _ size ▁, ▁int ▁update _ ctx ▁, ▁int ▁nearest _ ne ighbour ▁) ▁{ ▁int ▁dst _ index ▁; ▁int ▁index ▁= ▁c ▁-> ▁index ▁; ▁int ▁frac ▁= ▁c ▁-> ▁frac ▁; ▁int ▁dst _ incr _ frac ▁= ▁c ▁-> ▁dst _ incr ▁% ▁c ▁-> ▁src _ incr ▁; ▁int ▁dst _ incr ▁= ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁int ▁comp ensation _ distance ▁= ▁c ▁-> ▁comp ensation _ distance ▁; ▁if ▁( ▁! ▁dst ▁!= ▁! ▁src ▁) ▁return ▁AVERROR ▁( ▁EINVAL ▁) ▁; ▁if ▁( ▁nearest _ ne ighbour ▁) ▁{ ▁int 64_ t ▁index 2 ▁= ▁( ▁( ▁int 64_ t ▁) ▁index ▁) ▁<< ▁32 ▁; ▁int 64_ t ▁incr ▁= ▁( ▁1 LL ▁<< ▁32 ▁) ▁* ▁c ▁-> ▁dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁dst _ size ▁= ▁FF MIN ▁( ▁dst _ size ▁, ▁( ▁src _ size ▁- ▁1 ▁- ▁index ▁) ▁* ▁( ▁int 64_ t ▁) ▁c ▁-> ▁src _ incr ▁/ ▁c ▁-> ▁dst _ incr ▁) ▁; ▁if ▁( ▁dst ▁) ▁{ ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁dst _ size ▁; ▁dst _ index ▁++ ▁) ▁{ ▁c ▁-> ▁res ample _ ne arest ▁( ▁dst ▁, ▁dst _ index ▁, ▁src ▁, ▁index 2 ▁>> ▁32 ▁) ▁; ▁index 2 ▁+= ▁incr ▁; ▁} ▁} ▁else ▁{ ▁dst _ index ▁= ▁dst _ size ▁; ▁} ▁index ▁+= ▁dst _ index ▁* ▁dst _ incr ▁; ▁index ▁+= ▁( ▁frac ▁+ ▁dst _ index ▁* ▁( ▁int 64_ t ▁) ▁dst _ incr _ frac ▁) ▁/ ▁c ▁-> ▁src _ incr ▁; ▁frac ▁= ▁( ▁frac ▁+ ▁dst _ index ▁* ▁( ▁int 64_ t ▁) ▁dst _ incr _ frac ▁) ▁% ▁c ▁-> ▁src _ incr ▁; ▁} ▁else ▁{ ▁for ▁( ▁dst _ index ▁= ▁0 ▁; ▁dst _ index ▁< ▁dst _ size ▁; ▁dst _ index ▁++ ▁) ▁{ ▁int ▁sample _ index ▁= ▁index ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁if ▁( ▁sample _ index ▁+ ▁c ▁-> ▁filter _ length ▁> ▁src _ size ▁|| ▁- ▁sample _ index ▁>= ▁src _ size ▁) ▁break ▁; ▁if ▁( ▁dst ▁) ▁c ▁-> ▁res ample _ one ▁( ▁c ▁, ▁dst ▁, ▁dst _ index ▁, ▁src ▁, ▁src _ size ▁, ▁index ▁, ▁frac ▁) ▁; ▁frac ▁+= ▁dst _ incr _ frac ▁; ▁index ▁+= ▁dst _ incr ▁; ▁if ▁( ▁frac ▁>= ▁c ▁-> ▁src _ incr ▁) ▁{ ▁frac ▁-= ▁c ▁-> ▁src _ incr ▁; ▁index ▁++ ▁; ▁} ▁if ▁( ▁dst _ index ▁+ ▁1 ▁== ▁comp ensation _ distance ▁) ▁{ ▁comp ensation _ distance ▁= ▁0 ▁; ▁dst _ incr _ frac ▁= ▁c ▁-> ▁ideal _ dst _ incr ▁% ▁c ▁-> ▁src _ incr ▁; ▁dst _ incr ▁= ▁c ▁-> ▁ideal _ dst _ incr ▁/ ▁c ▁-> ▁src _ incr ▁; ▁} ▁} ▁} ▁if ▁( ▁consumed ▁) ▁* ▁consumed ▁= ▁FF MAX ▁( ▁index ▁, ▁0 ▁) ▁>> ▁c ▁-> ▁phase _ shift ▁; ▁if ▁( ▁update _ ctx ▁) ▁{ ▁if ▁( ▁index ▁>= ▁0 ▁) ▁index ▁&= ▁c ▁-> ▁phase _ mask ▁; ▁if ▁( ▁comp ensation _ distance ▁) ▁{ ▁comp ensation _ distance ▁-= ▁dst _ index ▁; ▁if ▁( ▁comp ensation _ distance ▁<= ▁0 ▁) ▁return ▁AVERROR _ BUG ▁; ▁} ▁c ▁-> ▁frac ▁= ▁frac ▁; ▁c ▁-> ▁index ▁= ▁index ▁; ▁c ▁-> ▁dst _ incr ▁= ▁dst _ incr _ frac ▁+ ▁c ▁-> ▁src _ incr ▁* ▁dst _ incr ▁; ▁c ▁-> ▁comp ensation _ distance ▁= ▁comp ensation _ distance ▁; ▁} ▁return ▁dst _ index ▁; ▁}	1
▁static ▁int ▁h ls _ mux _ init ▁( ▁AVFormatContext ▁* ▁s ▁) ▁{ ▁H LS Context ▁* ▁h ls ▁= ▁s ▁-> ▁priv _ data ▁; ▁AVFormatContext ▁* ▁oc ▁; ▁AVFormatContext ▁* ▁v tt _ oc ▁= ▁NULL ▁; ▁int ▁i ▁, ▁ret ▁; ▁ret ▁= ▁avformat _ alloc _ output _ context 2 ▁( ▁& ▁h ls ▁-> ▁av f ▁, ▁h ls ▁-> ▁of orm at ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁oc ▁= ▁h ls ▁-> ▁av f ▁; ▁oc ▁-> ▁of orm at ▁= ▁h ls ▁-> ▁of orm at ▁; ▁oc ▁-> ▁interrupt _ callback ▁= ▁s ▁-> ▁interrupt _ callback ▁; ▁oc ▁-> ▁max _ delay ▁= ▁s ▁-> ▁max _ delay ▁; ▁av _ dict _ copy ▁( ▁& ▁oc ▁-> ▁metadata ▁, ▁s ▁-> ▁metadata ▁, ▁0 ▁) ▁; ▁if ▁( ▁h ls ▁-> ▁v tt _ of orm at ▁) ▁{ ▁ret ▁= ▁avformat _ alloc _ output _ context 2 ▁( ▁& ▁h ls ▁-> ▁v tt _ av f ▁, ▁h ls ▁-> ▁v tt _ of orm at ▁, ▁NULL ▁, ▁NULL ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁return ▁ret ▁; ▁v tt _ oc ▁= ▁h ls ▁-> ▁v tt _ av f ▁; ▁v tt _ oc ▁-> ▁of orm at ▁= ▁h ls ▁-> ▁v tt _ of orm at ▁; ▁av _ dict _ copy ▁( ▁& ▁v tt _ oc ▁-> ▁metadata ▁, ▁s ▁-> ▁metadata ▁, ▁0 ▁) ▁; ▁} ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁s ▁-> ▁nb _ streams ▁; ▁i ▁++ ▁) ▁{ ▁AVStream ▁* ▁st ▁; ▁AVFormatContext ▁* ▁loc ▁; ▁if ▁( ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁codec ▁-> ▁codec _ type ▁== ▁AVMEDIA _ TYPE _ SUBTITLE ▁) ▁loc ▁= ▁v tt _ oc ▁; ▁else ▁loc ▁= ▁oc ▁; ▁if ▁( ▁! ▁( ▁st ▁= ▁avformat _ new _ stream ▁( ▁loc ▁, ▁NULL ▁) ▁) ▁) ▁return ▁AVERROR ▁( ▁ENOMEM ▁) ▁; ▁avcodec _ copy _ context ▁( ▁st ▁-> ▁codec ▁, ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁codec ▁) ▁; ▁st ▁-> ▁sample _ aspect _ ratio ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁sample _ aspect _ ratio ▁; ▁st ▁-> ▁time _ base ▁= ▁s ▁-> ▁streams ▁[ ▁i ▁] ▁-> ▁time _ base ▁; ▁} ▁h ls ▁-> ▁start _ pos ▁= ▁0 ▁; ▁return ▁0 ▁; ▁}	0
▁static ▁int ▁h ls _ read _ packet ▁( ▁AVFormatContext ▁* ▁s ▁, ▁AVPacket ▁* ▁pkt ▁) ▁{ ▁H LS Context ▁* ▁c ▁= ▁s ▁-> ▁priv _ data ▁; ▁int ▁ret ▁, ▁i ▁, ▁min variant ▁= ▁-1 ▁; ▁if ▁( ▁c ▁-> ▁first _ packet ▁) ▁{ ▁re check _ discard _ flags ▁( ▁s ▁, ▁1 ▁) ▁; ▁c ▁-> ▁first _ packet ▁= ▁0 ▁; ▁} ▁start ▁: ▁c ▁-> ▁end _ of _ segment ▁= ▁0 ▁; ▁for ▁( ▁i ▁= ▁0 ▁; ▁i ▁< ▁c ▁-> ▁n _ variants ▁; ▁i ▁++ ▁) ▁{ ▁struct ▁variant ▁* ▁var ▁= ▁c ▁-> ▁variants ▁[ ▁i ▁] ▁; ▁if ▁( ▁var ▁-> ▁needed ▁&& ▁! ▁var ▁-> ▁pkt ▁. ▁data ▁) ▁{ ▁while ▁( ▁1 ▁) ▁{ ▁int 64_ t ▁ts _ diff ▁; ▁AVStream ▁* ▁st ▁; ▁ret ▁= ▁av _ read _ frame ▁( ▁var ▁-> ▁ctx ▁, ▁& ▁var ▁-> ▁pkt ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁if ▁( ▁! ▁var ▁-> ▁pb ▁. ▁eof _ reached ▁) ▁return ▁ret ▁; ▁reset _ packet ▁( ▁& ▁var ▁-> ▁pkt ▁) ▁; ▁break ▁; ▁} ▁else ▁{ ▁if ▁( ▁c ▁-> ▁first _ timestamp ▁== ▁AV _ NOP TS _ VALUE ▁) ▁c ▁-> ▁first _ timestamp ▁= ▁var ▁-> ▁pkt ▁. ▁dts ▁; ▁} ▁if ▁( ▁c ▁-> ▁seek _ timestamp ▁== ▁AV _ NOP TS _ VALUE ▁) ▁break ▁; ▁if ▁( ▁var ▁-> ▁pkt ▁. ▁dts ▁== ▁AV _ NOP TS _ VALUE ▁) ▁{ ▁c ▁-> ▁seek _ timestamp ▁= ▁AV _ NOP TS _ VALUE ▁; ▁break ▁; ▁} ▁st ▁= ▁var ▁-> ▁ctx ▁-> ▁streams ▁[ ▁var ▁-> ▁pkt ▁. ▁stream _ index ▁] ▁; ▁ts _ diff ▁= ▁av _ re scale _ rnd ▁( ▁var ▁-> ▁pkt ▁. ▁dts ▁, ▁AV _ TIME _ BASE ▁, ▁st ▁-> ▁time _ base ▁. ▁den ▁, ▁AV _ ROUND _ DOWN ▁) ▁- ▁c ▁-> ▁seek _ timestamp ▁; ▁if ▁( ▁ts _ diff ▁>= ▁0 ▁&& ▁( ▁c ▁-> ▁seek _ flags ▁& ▁AV SEEK _ FLAG _ ANY ▁|| ▁var ▁-> ▁pkt ▁. ▁flags ▁& ▁AV _ PKT _ FLAG _ KEY ▁) ▁) ▁{ ▁c ▁-> ▁seek _ timestamp ▁= ▁AV _ NOP TS _ VALUE ▁; ▁break ▁; ▁} ▁} ▁} ▁if ▁( ▁var ▁-> ▁pkt ▁. ▁data ▁) ▁{ ▁if ▁( ▁min variant ▁< ▁0 ▁|| ▁var ▁-> ▁pkt ▁. ▁dts ▁< ▁c ▁-> ▁variants ▁[ ▁min variant ▁] ▁-> ▁pkt ▁. ▁dts ▁) ▁min variant ▁= ▁i ▁; ▁} ▁} ▁if ▁( ▁c ▁-> ▁end _ of _ segment ▁) ▁{ ▁if ▁( ▁re check _ discard _ flags ▁( ▁s ▁, ▁0 ▁) ▁) ▁goto ▁start ▁; ▁} ▁if ▁( ▁min variant ▁>= ▁0 ▁) ▁{ ▁* ▁pkt ▁= ▁c ▁-> ▁variants ▁[ ▁min variant ▁] ▁-> ▁pkt ▁; ▁pkt ▁-> ▁stream _ index ▁+= ▁c ▁-> ▁variants ▁[ ▁min variant ▁] ▁-> ▁stream _ offset ▁; ▁reset _ packet ▁( ▁& ▁c ▁-> ▁variants ▁[ ▁min variant ▁] ▁-> ▁pkt ▁) ▁; ▁return ▁0 ▁; ▁} ▁return ▁AVERROR _ EOF ▁; ▁}	1
